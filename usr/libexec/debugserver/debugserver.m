uint64_t std::shared_ptr<RNBRemote>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t RNBRunLoopGetStartModeFromRemote(RNBRemote *a1)
{
  if (!a1) {
    return 6;
  }
  v2 = (pthread_mutex_t *)((char *)a1 + 120);
  while (1)
  {
    if (DNBLogEnabledForAny(0x40000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents( 0x%08x) ...", "RNBRunLoopGetStartModeFromRemote", 160);
    }
    int v3 = PThreadEvent::WaitForSetEvents(v2, 0xA0u, 0);
    if (DNBLogEnabledForAny(0x40000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents( 0x%08x) => 0x%08x", "RNBRunLoopGetStartModeFromRemote", 160, v3);
    }
    if ((v3 & 0x80) != 0)
    {
      if (g_isatty)
      {
        v15 = __stderrp;
        v16 = "error: packet read thread exited.\n";
        size_t v17 = 34;
        goto LABEL_28;
      }
      v18 = "error: packet read thread exited.\n";
      goto LABEL_36;
    }
    if ((v3 & 0x20) == 0)
    {
      if (DNBLogEnabledForAny(0x10000)) {
        _DNBLogThreaded("%s Connection closed before getting \"A\" packet.", "RNBRunLoopGetStartModeFromRemote");
      }
      return 6;
    }
    int v20 = 0;
    int v10 = RNBRemote::HandleReceivedPacket((uint64_t)a1, &v20);
    if ((v20 - 26) <= 2) {
      break;
    }
    if (v10)
    {
      if (v10 == 2)
      {
        if (!g_isatty)
        {
          v18 = "error: connection lost.\n";
          goto LABEL_36;
        }
        v15 = __stderrp;
        v16 = "error: connection lost.\n";
        size_t v17 = 24;
LABEL_28:
        fwrite(v16, v17, 1uLL, v15);
        return 6;
      }
      BOOL v11 = DNBLogEnabledForAny(0x10000);
      v12 = "%s Error getting packet.";
      if (v11) {
LABEL_3:
      }
        _DNBLogThreaded(v12, "RNBRunLoopGetStartModeFromRemote");
    }
    else
    {
      if (v20 == 6) {
        return 3;
      }
      BOOL v13 = DNBLogEnabledForAny(0x10000);
      v12 = "#### %s";
      if (v13) {
        goto LABEL_3;
      }
    }
  }
  if (v10)
  {
    if (g_isatty)
    {
      v15 = __stderrp;
      v16 = "error: attach failed.\n";
      size_t v17 = 22;
      goto LABEL_28;
    }
    v18 = "error: attach failed.\n";
LABEL_36:
    _DNBLog(0, (uint64_t)v18, v4, v5, v6, v7, v8, v9, v19);
    return 6;
  }
  if (g_isatty) {
    fwrite("Attach succeeded, ready to debug.\n", 0x22uLL, 1uLL, __stdoutp);
  }
  else {
    _DNBLog(0, (uint64_t)"Attach succeeded, ready to debug.\n", v4, v5, v6, v7, v8, v9, v19);
  }
  return 4;
}

uint64_t RNBRunLoopLaunchInferior(RNBRemote *a1, const char *a2, const char *a3, const char *a4, BOOL a5)
{
  if (DNBLogEnabledForAny(0x10000))
  {
    int v10 = RNBContext::ArgumentAtIndex(a1, 0);
    _DNBLogThreaded("%s Launching '%s'...", "RNBRunLoopLaunchInferior", v10);
  }
  uint64_t v12 = *((void *)a1 + 43);
  uint64_t v11 = *((void *)a1 + 44);
  unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v12) >> 3);
  unint64_t v14 = v13 + 1;
  if (v13 == -1)
  {
    v15 = 0;
    if (v11 == v12) {
      goto LABEL_11;
    }
  }
  else
  {
    if (v14 >> 61) {
      goto LABEL_91;
    }
    v15 = (const char **)operator new(8 * v14);
    bzero(v15, 0x5555555555555558 * ((v11 - v12) >> 3) + 8);
    if (v11 == v12) {
      goto LABEL_11;
    }
  }
  unint64_t v16 = 0;
  if (v13 <= 1) {
    unint64_t v13 = 1;
  }
  do
  {
    v15[v16] = RNBContext::ArgumentAtIndex(a1, v16);
    ++v16;
  }
  while (v13 != v16);
LABEL_11:
  uint64_t v18 = *((void *)a1 + 46);
  uint64_t v17 = *((void *)a1 + 47);
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v18) >> 3);
  unint64_t v20 = v19 + 1;
  if (v19 == -1)
  {
    v21 = 0;
    if (v17 == v18) {
      goto LABEL_19;
    }
    goto LABEL_16;
  }
  if (v20 >> 61) {
LABEL_91:
  }
    abort();
  v21 = operator new(8 * v20);
  bzero(v21, 0x5555555555555558 * ((v17 - v18) >> 3) + 8);
  if (v17 == v18) {
    goto LABEL_19;
  }
LABEL_16:
  unint64_t v22 = 0;
  if (v19 <= 1) {
    unint64_t v19 = 1;
  }
  do
  {
    *((void *)v21 + v22) = RNBContext::EnvironmentAtIndex(a1, v22);
    ++v22;
  }
  while (v19 != v22);
LABEL_19:
  int v23 = g_launch_flavor;
  v24 = *v15;
  if (!g_launch_flavor)
  {
    size_t v25 = strlen(v24);
    if (v25 >= 4 && v24[v25 - 4] == 46 && v24[v25 - 3] == 97 && v24[v25 - 2] == 112 && v24[v25 - 1] == 112) {
      int v23 = 5;
    }
    else {
      int v23 = 1;
    }
  }
  *((_DWORD *)a1 + 76) = v23;
  if (!DNBResolveExecutablePath(v24, __dst, 0x400uLL)) {
    strlcpy(__dst, *v15, 0x400uLL);
  }
  v38[0] = 0;
  v26 = (char *)a1 + 88;
  if ((*((char *)a1 + 111) & 0x80000000) == 0)
  {
    if (*((unsigned char *)a1 + 111)) {
      goto LABEL_41;
    }
    goto LABEL_34;
  }
  if (!*((void *)a1 + 12) || (v26 = *(const char **)v26) == 0)
  {
LABEL_34:
    if (*((char *)a1 + 415) < 0)
    {
      if (*((void *)a1 + 50)) {
        v26 = (const char *)*((void *)a1 + 49);
      }
      else {
        v26 = 0;
      }
    }
    else if (*((unsigned char *)a1 + 415))
    {
      v26 = (char *)a1 + 392;
    }
    else
    {
      v26 = 0;
    }
  }
LABEL_41:
  v27 = (char *)a1 + 416;
  if (*((char *)a1 + 439) < 0) {
    v27 = *(const char **)v27;
  }
  int v28 = DNBProcessLaunch(a1, __dst, v15, (const char **)v21, v26, a2, a3, a4, a5, g_disable_aslr, v27, v38, 0x400uLL);
  int v29 = v28;
  g_pid = v28;
  if (v28 || !v38[0])
  {
    if (!v28)
    {
      if (DNBLogEnabled()) {
        _DNBLogThreaded("%s DNBProcessLaunch() failed to launch process, unknown failure", "RNBRunLoopLaunchInferior");
      }
      *((void *)a1 + 39) = 0xFFFFFFFFLL;
      v30 = (std::string *)((char *)a1 + 320);
      if (*((char *)a1 + 343) < 0)
      {
        **((unsigned char **)a1 + 40) = 0;
        *((void *)a1 + 41) = 0;
      }
      else
      {
        *((unsigned char *)a1 + 320) = 0;
        *((unsigned char *)a1 + 343) = 0;
      }
      v31 = "<unknown failure>";
      goto LABEL_62;
    }
    *((void *)a1 + 39) = 0;
    if ((*((char *)a1 + 343) & 0x80000000) == 0)
    {
LABEL_59:
      *((unsigned char *)a1 + 320) = 0;
      *((unsigned char *)a1 + 343) = 0;
      goto LABEL_63;
    }
  }
  else
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("%s DNBProcessLaunch() returned error: '%s'", "RNBRunLoopLaunchInferior", v38);
    }
    *((void *)a1 + 39) = 0xFFFFFFFFLL;
    if (*((char *)a1 + 343) < 0)
    {
      **((unsigned char **)a1 + 40) = 0;
      *((void *)a1 + 41) = 0;
      if (v38[0]) {
        goto LABEL_49;
      }
    }
    else
    {
      *((unsigned char *)a1 + 320) = 0;
      *((unsigned char *)a1 + 343) = 0;
      if (v38[0])
      {
LABEL_49:
        v30 = (std::string *)((char *)a1 + 320);
        v31 = v38;
LABEL_62:
        std::string::assign(v30, v31);
        goto LABEL_63;
      }
    }
    if ((*((char *)a1 + 343) & 0x80000000) == 0) {
      goto LABEL_59;
    }
  }
  **((unsigned char **)a1 + 40) = 0;
  *((void *)a1 + 41) = 0;
LABEL_63:
  if (*((_DWORD *)a1 + 118) != -1
    && (PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)a1 + 120), 0x20u, 0) & 0x20) != 0)
  {
    int v37 = 0;
    if (RNBRemote::HandleReceivedPacket((uint64_t)a1, &v37))
    {
      if (DNBLogEnabledForAny(0x10000)) {
        _DNBLogThreaded("%s Error getting packet.", "RNBRunLoopLaunchInferior");
      }
LABEL_85:
      uint64_t v35 = 6;
      if (v21) {
LABEL_86:
      }
        operator delete(v21);
      goto LABEL_87;
    }
    if (v37 != 54 && DNBLogEnabledForAny(0x10000)) {
      _DNBLogThreaded("%s Didn't get the expected qLaunchSuccess packet.", "RNBRunLoopLaunchInferior");
    }
  }
  if (!v29) {
    goto LABEL_85;
  }
  while (1)
  {
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, INFINITE)...", "RNBRunLoopLaunchInferior", v29);
    }
    int v32 = DNBProcessWaitForEvents(v29, 3u, 1, 0);
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, INFINITE) => 0x%8.8x", "RNBRunLoopLaunchInferior", v29, v32);
    }
    if (!v32)
    {
LABEL_81:
      g_pid = 0;
      goto LABEL_85;
    }
    if ((v32 & 3) != 0)
    {
      unsigned int State = DNBProcessGetState(v29);
      if (DNBLogEnabledForAny(0x200000))
      {
        v34 = DNBStateAsString(State);
        _DNBLogThreaded("%s process %4.4x state changed (eEventProcessStateChanged): %s", "RNBRunLoopLaunchInferior", v29, v34);
      }
      if (State - 8 < 2) {
        goto LABEL_81;
      }
      if (State == 7 || State == 4) {
        break;
      }
    }
    DNBProcessResetEvents(v29, v32);
  }
  RNBContext::SetProcessID(a1, v29);
  uint64_t v35 = 4;
  if (v21) {
    goto LABEL_86;
  }
LABEL_87:
  operator delete(v15);
  return v35;
}

uint64_t RNBRunLoopLaunchAttaching(RNBRemote *a1, int a2, int *a3)
{
  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("%s Attaching to pid %i...", "RNBRunLoopLaunchAttaching", a2);
  }
  int v6 = DNBProcessAttach(a2, 0, (uint64_t)a1 + 448, __s, 1024);
  *a3 = v6;
  g_pid = v6;
  if (*a3)
  {
    RNBContext::SetProcessID(a1, *a3);
    return 4;
  }
  *((void *)a1 + 39) = 0xFFFFFFFFLL;
  if (*((char *)a1 + 343) < 0)
  {
    **((unsigned char **)a1 + 40) = 0;
    *((void *)a1 + 41) = 0;
    if (!__s[0]) {
      return 6;
    }
    goto LABEL_7;
  }
  *((unsigned char *)a1 + 320) = 0;
  *((unsigned char *)a1 + 343) = 0;
  if (__s[0]) {
LABEL_7:
  }
    std::string::assign((std::string *)((char *)a1 + 320), __s);
  return 6;
}

void signal_handler(SysSignal *a1)
{
  if (DNBLogEnabledForAny(0x10000))
  {
    v2 = SysSignal::Name(a1);
    _DNBLogThreaded("%s (%s)", "signal_handler", v2);
  }
  if (a1 == 13)
  {
    g_sigpipe_received = 1;
  }
  else if (a1 == 2)
  {
    int v3 = g_sigint_received++;
    if (!g_pid || v3 || DNBProcessGetState(g_pid) - 5 > 1) {
      exit(2);
    }
    int v4 = g_pid;
    DNBProcessSignal(v4, 17);
  }
}

uint64_t HandleProcessStateChange(RNBRemote *a1, int a2)
{
  int v2 = *((_DWORD *)a1 + 3);
  if (v2)
  {
    unsigned int State = DNBProcessGetState(*((_DWORD *)a1 + 3));
    if (DNBLogEnabledForAny(0x10000))
    {
      int v6 = DNBStateAsString(State);
      _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s", "HandleProcessStateChange", a2, v6);
    }
    uint64_t result = 6;
    switch(State)
    {
      case 2u:
      case 3u:
      case 5u:
      case 6u:
        return 4;
      case 4u:
      case 7u:
      case 0xAu:
        g_sigint_received = 0;
        if (a2) {
          return 4;
        }
        uint64_t v8 = *((void *)a1 + 14);
        uint64_t StopCount = DNBProcessGetStopCount(v2);
        if (*((void *)a1 + 14) == StopCount)
        {
          if (DNBLogEnabledForAny(0x10000))
          {
            DNBStateAsString(State);
            _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? skipping...");
            return 4;
          }
        }
        else
        {
          *((void *)a1 + 14) = StopCount;
          RNBRemote::FlushSTDIO((int *)a1);
          uint64_t v10 = *((void *)a1 + 14);
          BOOL v11 = DNBLogEnabledForAny(0x10000);
          if (v10 == 1)
          {
            if (v11)
            {
              DNBStateAsString(State);
              _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? no, first stop...");
              return 4;
            }
          }
          else
          {
            if (v11)
            {
              uint64_t v12 = DNBStateAsString(State);
              _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? YES!!!", "HandleProcessStateChange", 0, v12, *((void *)a1 + 14), v8);
            }
            RNBRemote::NotifyThatProcessStopped(a1);
          }
        }
        return 4;
      case 9u:
        RNBRemote::HandlePacket_last_signal(a1, 0);
        return 6;
      default:
        return result;
    }
  }
  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("#### %s error: pid invalid, exiting...", "HandleProcessStateChange");
  }
  return 6;
}

uint64_t RNBRunLoopInferiorExecuting(RNBRemote *a1)
{
  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("#### %s", "RNBRunLoopInferiorExecuting");
  }
  uint64_t v2 = HandleProcessStateChange(a1, 1);
  while (*((_DWORD *)a1 + 3))
  {
    memset(&__p, 0, sizeof(__p));
    if (RNBContext::ProcessStateRunning(a1)) {
      unsigned int v3 = 189;
    }
    else {
      unsigned int v3 = 165;
    }
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) ...", "RNBRunLoopInferiorExecuting", v3);
    }
    int v4 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)a1 + 120), v3, 0);
    if (DNBLogEnabledForAny(0x200000))
    {
      uint64_t v5 = RNBContext::EventsAsString((int)a1, v4, &__p);
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) => 0x%08x (%s)", "RNBRunLoopInferiorExecuting", v3, v4, (const char *)v5);
    }
    if (!v4)
    {
      uint64_t v6 = v2;
LABEL_24:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_51;
      }
      goto LABEL_4;
    }
    if ((v4 & 0xC) != 0) {
      RNBRemote::FlushSTDIO((int *)a1);
    }
    if ((v4 & 0x10) != 0)
    {
      RNBRemote::SendAsyncProfileData((size_t)a1);
      if ((v4 & 0x20) == 0)
      {
LABEL_18:
        if ((v4 & 1) == 0) {
          goto LABEL_19;
        }
        goto LABEL_31;
      }
    }
    else if ((v4 & 0x20) == 0)
    {
      goto LABEL_18;
    }
    v4 ^= 0x20u;
    if (RNBContext::ProcessStateRunning(a1))
    {
      RNBRemote::HandleAsyncPacket((uint64_t)a1, 0);
      if ((v4 & 1) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      RNBRemote::HandleReceivedPacket((uint64_t)a1, 0);
      if ((v4 & 1) == 0)
      {
LABEL_19:
        uint64_t v6 = v2;
        if ((v4 & 4) == 0) {
          goto LABEL_20;
        }
        goto LABEL_32;
      }
    }
LABEL_31:
    uint64_t v7 = HandleProcessStateChange(a1, 0);
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)a1 + 120), 1);
    v4 ^= 1u;
    uint64_t v6 = v7;
    if ((v4 & 4) == 0)
    {
LABEL_20:
      if ((v4 & 0x80) != 0) {
        goto LABEL_35;
      }
      goto LABEL_21;
    }
LABEL_32:
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"debugserver's process monitoring thread has exited.", v8, v9, v10, v11, v12, v13, v37);
    }
    uint64_t v6 = 6;
    if ((v4 & 0x80) != 0)
    {
LABEL_35:
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"debugserver's packet communication to lldb has been shut down.", v14, v15, v16, v17, v18, v19, v37);
      }
      uint64_t v20 = *((unsigned int *)a1 + 3);
      if (v20)
      {
        BOOL v21 = RNBContext::ProcessStateRunning(a1);
        int v22 = *((unsigned __int8 *)a1 + 440);
        if (v21)
        {
          BOOL v23 = DNBLogEnabled();
          if (v22)
          {
            if (v23) {
              _DNBLog(0, (uint64_t)"debugserver has a valid PID %d, it is still running. detaching from the inferior process.", v24, v25, v26, v27, v28, v29, v20);
            }
            goto LABEL_45;
          }
          if (v23) {
            _DNBLog(0, (uint64_t)"debugserver killing the inferior process, pid %d.", v24, v25, v26, v27, v28, v29, v20);
          }
          DNBProcessKill(v20);
        }
        else if (*((unsigned char *)a1 + 440))
        {
          if (DNBLogEnabled()) {
            _DNBLog(0, (uint64_t)"debugserver has a valid PID %d but it may no longer be running, detaching from the inferior process.", v30, v31, v32, v33, v34, v35, v20);
          }
LABEL_45:
          DNBProcessDetach(v20);
        }
      }
      uint64_t v6 = 6;
      goto LABEL_50;
    }
LABEL_21:
    if (!v4) {
      goto LABEL_24;
    }
LABEL_50:
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)a1 + 120), v4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_51:
    }
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_4:
    uint64_t v2 = 4;
    if (v6 != 4) {
      return v6;
    }
  }
  return v2;
}

uint64_t RNBRunLoopPlatform(RNBRemote *a1)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)a1 + 120);
  do
  {
    memset(&__p, 0, sizeof(__p));
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) ...", "RNBRunLoopPlatform", 160);
    }
    int v3 = PThreadEvent::WaitForSetEvents(v2, 0xA0u, 0);
    if (DNBLogEnabledForAny(0x200000))
    {
      int v4 = RNBContext::EventsAsString((int)a1, v3, &__p);
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) => 0x%08x (%s)", "RNBRunLoopPlatform", 160, v3, (const char *)v4);
    }
    if (!v3)
    {
      int v6 = 5;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        continue;
      }
LABEL_19:
      operator delete(__p.__r_.__value_.__l.__data_);
      continue;
    }
    if ((v3 & 0x20) != 0)
    {
      if (RNBRemote::HandleReceivedPacket((uint64_t)a1, 0) == 2) {
        int v5 = 6;
      }
      else {
        int v5 = 5;
      }
    }
    else
    {
      int v5 = 5;
    }
    if ((v3 & 0x80) != 0) {
      int v6 = 6;
    }
    else {
      int v6 = v5;
    }
    PThreadEvent::ResetEvents(v2, v3);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_19;
    }
  }
  while (v6 == 5);
  return 6;
}

void ASLLogCallback(void *a1, char a2, const char *format, va_list ap)
{
  if (format)
  {
    uint64_t v7 = (__asl_object_s *)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg;
    if (!ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg)
    {
      ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg = (uint64_t)asl_new(0);
      snprintf(__str, 0x400uLL, "com.apple.%s-%s", "debugserver", "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n");
      asl_set((asl_object_t)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg, "Sender", __str);
      uint64_t v7 = (__asl_object_s *)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg;
    }
    if ((a2 & 2) != 0) {
      int v8 = 3;
    }
    else {
      int v8 = 4;
    }
    if (a2) {
      int v9 = 2;
    }
    else {
      int v9 = v8;
    }
    asl_vlog(0, v7, v9, format, ap);
  }
}

FILE *FileLogCallback(FILE *result, unsigned int a2, const char *a3, va_list a4)
{
  if (result && a3)
  {
    int v4 = result;
    vfprintf(result, a3, a4);
    fputc(10, v4);
    return (FILE *)fflush(v4);
  }
  return result;
}

void show_usage_and_exit(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (g_isatty)
  {
    fprintf(__stderrp, "Usage:\n  %s host:port [program-name program-arg1 program-arg2 ...]\n", "debugserver");
    if (g_isatty)
    {
LABEL_3:
      fprintf(__stderrp, "  %s /path/file [program-name program-arg1 program-arg2 ...]\n", "debugserver");
      if (g_isatty) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else
  {
    _DNBLog(0, (uint64_t)"Usage:\n  %s host:port [program-name program-arg1 program-arg2 ...]\n", a3, a4, a5, a6, a7, a8, (uint64_t)"debugserver");
    if (g_isatty) {
      goto LABEL_3;
    }
  }
  _DNBLog(0, (uint64_t)"  %s /path/file [program-name program-arg1 program-arg2 ...]\n", v9, v10, v11, v12, v13, v14, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_4:
    fprintf(__stderrp, "  %s host:port --attach=<pid>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  _DNBLog(0, (uint64_t)"  %s host:port --attach=<pid>\n", v15, v16, v17, v18, v19, v20, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_5:
    fprintf(__stderrp, "  %s /path/file --attach=<pid>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  _DNBLog(0, (uint64_t)"  %s /path/file --attach=<pid>\n", v21, v22, v23, v24, v25, v26, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_6:
    fprintf(__stderrp, "  %s host:port --attach=<process_name>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_12:
  _DNBLog(0, (uint64_t)"  %s host:port --attach=<process_name>\n", v27, v28, v29, v30, v31, v32, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_7:
    fprintf(__stderrp, "  %s /path/file --attach=<process_name>\n", "debugserver");
    exit(a1);
  }
LABEL_13:
  _DNBLog(0, (uint64_t)"  %s /path/file --attach=<process_name>\n", v33, v34, v35, v36, v37, v38, (uint64_t)"debugserver");
  exit(a1);
}

int main(int argc, const char **argv, const char **envp)
{
  unsetenv("DYLD_INSERT_LIBRARIES");
  v393 = *argv;
  pthread_setname_np("main thread");
  int v425 = 0;
  int v5 = pthread_self();
  if (!pthread_getschedparam(v5, &v425, &v426))
  {
    v426.sched_priority = 47;
    int v6 = pthread_self();
    pthread_setschedparam(v6, v425, &v426);
  }
  getpid();
  proc_set_wakemon_params();
  g_isatty = isatty(0);
  signal(13, (void (__cdecl *)(int))signal_handler);
  signal(1, (void (__cdecl *)(int))signal_handler);
  sigset_t v424 = 0x80000;
  uint64_t v7 = (OsLogger *)sigprocmask(1, &v424, 0);
  LogFunction = (void *)OsLogger::GetLogFunction(v7);
  if (LogFunction)
  {
    DNBLogSetLogCallback(LogFunction, 0);
    if (!DNBLogEnabled()) {
      goto LABEL_9;
    }
    uint64_t v15 = "debugserver will use os_log for internal logging.";
  }
  else
  {
    DNBLogSetLogCallback(ASLLogCallback, 0);
    if (!DNBLogEnabled()) {
      goto LABEL_9;
    }
    uint64_t v15 = "debugserver will use ASL for internal logging.";
  }
  _DNBLog(0, (uint64_t)v15, v9, v10, v11, v12, v13, v14, (uint64_t)v386);
LABEL_9:
  DNBLogSetLogMask(0);
  LODWORD(__dst[0].__r_.__value_.__l.__data_) = 0;
  v428[0] = 4;
  int v16 = sysctlbyname("security.mac.amfi.developer_mode_status", __dst, v428, 0, 0);
  if (v16 | LODWORD(__dst[0].__r_.__value_.__l.__data_))
  {
    uint64_t v23 = operator new(0x338uLL);
    v23[1] = 0;
    v23[2] = 0;
    *uint64_t v23 = off_100068C38;
    uint64_t v24 = (uint64_t)(v23 + 3);
    RNBRemote::RNBRemote((RNBRemote *)(v23 + 3));
    uint64_t v25 = (std::__shared_weak_count *)qword_1000796A0;
    g_remoteSP = (uint64_t)(v23 + 3);
    qword_1000796A0 = (uint64_t)v23;
    if (!v25) {
      goto LABEL_14;
    }
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
    uint64_t v24 = g_remoteSP;
    if (g_remoteSP)
    {
LABEL_14:
      int v423 = 0;
      v421[0] = 0;
      v421[1] = 0;
      uint64_t v422 = 0;
      v418 = 0;
      uint64_t v419 = 0;
      uint64_t v420 = 0;
      memset(&v417, 0, sizeof(v417));
      v414 = 0;
      uint64_t v415 = 0;
      uint64_t v416 = 0;
      v411 = 0;
      uint64_t v412 = 0;
      uint64_t v413 = 0;
      v409[0] = 0;
      v409[1] = 0;
      uint64_t v410 = 0;
      v407[0] = 0;
      v407[1] = 0;
      uint64_t v408 = 0;
      *(_WORD *)v429 = 29803;
      if (g_long_options)
      {
        int v26 = 2;
        uint64_t v27 = &dword_100070118;
        while (1)
        {
          uint64_t v30 = *v27;
          if (v30 <= 0x7F)
          {
            if ((_DefaultRuneLocale.__runetype[v30] & 0x100) == 0) {
              goto LABEL_18;
            }
          }
          else if (!__maskrune(v30, 0x100uLL))
          {
            goto LABEL_18;
          }
          int v31 = v26 + 1;
          v429[v26] = *v27;
          int v32 = *(v27 - 4);
          if (v32 == 1)
          {
            int v28 = 2;
          }
          else
          {
            if (v32 != 2)
            {
              ++v26;
              goto LABEL_18;
            }
            v429[v31] = 58;
            int v31 = v26 + 2;
            int v28 = 3;
          }
          v26 += v28;
          v429[v31] = 58;
LABEL_18:
          uint64_t v29 = *((void *)v27 + 1);
          v27 += 8;
          if (!v29) {
            goto LABEL_33;
          }
        }
      }
      int v26 = 2;
LABEL_33:
      v429[v26] = 0;
      optreset = 1;
      optind = 1;
      uint64_t v38 = getopt_long_only(argc, (char *const *)argv, v429, (const option *)&g_long_options, &v423);
      if (v38 != -1)
      {
        uint64_t v39 = v38;
        int v40 = 0;
        char v391 = 0;
        int v401 = 0;
        char v390 = 0;
        unsigned int v398 = 0;
        v399 = 0;
        unint64_t v397 = 0;
        int v394 = 0;
        useconds_t v396 = 1000;
        int StartModeFromRemote = 6;
        while (2)
        {
          if (DNBLogEnabled()) {
            _DNBLogDebug((uint64_t)"option: ch == %c (0x%2.2x) --%s%c%s\n", v44, v45, v46, v47, v48, v49, v50, v39);
          }
          switch((int)v39)
          {
            case '2':
              communication_fd = atoi(optarg);
              goto LABEL_38;
            case 'A':
              v42 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_38;
              }
              v43 = (std::string *)&v414;
              goto LABEL_37;
            case 'D':
              g_disable_aslr = 1;
              goto LABEL_38;
            case 'E':
              goto LABEL_36;
            case 'F':
              int v40 = 1;
              goto LABEL_38;
            case 'I':
              v42 = optarg;
              v43 = (std::string *)(v24 + 16);
              goto LABEL_37;
            case 'K':
              g_detach_on_error = 0;
              goto LABEL_38;
            case 'O':
              v42 = optarg;
              v43 = (std::string *)(v24 + 40);
              goto LABEL_37;
            case 'P':
              v42 = optarg;
              v43 = (std::string *)v407;
              goto LABEL_37;
            case 'R':
              int v401 = 1;
              goto LABEL_38;
            case 'S':
              setsid();
              goto LABEL_38;
            case 'U':
              RNBContext::AddDefaultIgnoredExceptions((RNBContext *)v24);
              goto LABEL_38;
            case 'V':
              BOOL IsTranslated = DNBDebugserverIsTranslated();
              v347 = " (running under translation)";
              if (!IsTranslated) {
                v347 = (const char *)&unk_10005A589;
              }
              printf("%s-%s for %s%s.\n", "debugserver", "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n", "arm64", v347);
              exit(0);
            case 'W':
              v42 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_38;
              }
              v43 = (std::string *)&v411;
              goto LABEL_37;
            case 'X':
              char v391 = 1;
              goto LABEL_38;
            case 'a':
              if (!optarg) {
                goto LABEL_38;
              }
              uint64_t v53 = *optarg;
              if (!*optarg) {
                goto LABEL_38;
              }
              if ((v53 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v53] & 0x400) != 0)
              {
                v428[0] = 0;
                unint64_t v397 = strtoul(optarg, (char **)v428, 0);
                if (!v428[0] || *(unsigned char *)v428[0])
                {
                  if (!g_isatty)
                  {
                    _DNBLog(0, (uint64_t)"error: invalid pid option '%s'\n", v82, v83, v84, v85, v86, v87, (uint64_t)optarg);
                    exit(4);
                  }
                  fprintf(__stderrp, "error: invalid pid option '%s'\n", optarg);
                  exit(4);
                }
                int StartModeFromRemote = 2;
              }
              else
              {
                v52 = &v417;
                v51 = optarg;
LABEL_55:
                std::string::assign(v52, v51);
                int StartModeFromRemote = 2;
              }
              goto LABEL_38;
            case 'd':
              if (optarg)
              {
                if (*optarg)
                {
                  v428[0] = 0;
                  unsigned int v398 = strtoul(optarg, (char **)v428, 0);
                  if (!v428[0] || *(unsigned char *)v428[0])
                  {
                    if (!g_isatty)
                    {
                      _DNBLog(0, (uint64_t)"error: invalid waitfor-duration option value '%s'.\n", v54, v55, v56, v57, v58, v59, (uint64_t)optarg);
                      exit(7);
                    }
                    fprintf(__stderrp, "error: invalid waitfor-duration option value '%s'.\n", optarg);
                    exit(7);
                  }
                }
              }
              goto LABEL_38;
            case 'e':
              RNBContext::PushEnvironment((RNBContext *)v24, optarg);
              goto LABEL_38;
            case 'f':
              if (optarg && *optarg) {
                int v394 = strtoul(optarg, 0, 0);
              }
              goto LABEL_38;
            case 'g':
              DNBLogSetDebug(1);
              goto LABEL_38;
            case 'i':
              if (optarg)
              {
                if (*optarg)
                {
                  v428[0] = 0;
                  useconds_t v396 = strtoul(optarg, (char **)v428, 0);
                  if (!v428[0] || *(unsigned char *)v428[0])
                  {
                    if (!g_isatty)
                    {
                      _DNBLog(0, (uint64_t)"error: invalid waitfor-interval option value '%s'.\n", v75, v76, v77, v78, v79, v80, (uint64_t)optarg);
                      exit(6);
                    }
                    fprintf(__stderrp, "error: invalid waitfor-interval option value '%s'.\n", optarg);
                    exit(6);
                  }
                }
              }
              goto LABEL_38;
            case 'k':
              g_lockdown_opt = 1;
              goto LABEL_38;
            case 'l':
              v60 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_38;
              }
              if (!strcasecmp(optarg, "stdout"))
              {
                v81 = __stdoutp;
                if (__stdoutp) {
                  goto LABEL_106;
                }
              }
              else if (!strcasecmp(v60, "stderr"))
              {
                v81 = __stderrp;
                if (__stderrp)
                {
LABEL_106:
                  v399 = v81;
                  goto LABEL_38;
                }
              }
              else
              {
                v61 = fopen(v60, "w");
                if (v61)
                {
                  v399 = v61;
                  setlinebuf(v61);
                  goto LABEL_38;
                }
              }
              int v389 = v40;
              v88 = __error();
              v89 = strerror(*v88);
              if (g_isatty)
              {
                v400 = __stderrp;
                v90 = optarg;
                v91 = __error();
                v92 = "unknown error";
                if (v89) {
                  v92 = v89;
                }
                fprintf(v400, "Failed to open log file '%s' for writing: errno = %i (%s)", v90, *v91, v92);
              }
              else
              {
                v99 = optarg;
                __error();
                _DNBLog(0, (uint64_t)"Failed to open log file '%s' for writing: errno = %i (%s)", v100, v101, v102, v103, v104, v105, (uint64_t)v99);
              }
              v399 = 0;
              int v40 = v389;
LABEL_38:
              uint64_t v39 = getopt_long_only(argc, (char *const *)argv, v429, (const option *)&g_long_options, &v423);
              if (v39 != -1) {
                continue;
              }
              goto LABEL_126;
            case 'n':
              char v390 = 1;
              goto LABEL_38;
            case 'p':
              int StartModeFromRemote = 5;
              goto LABEL_38;
            case 's':
              std::string::assign((std::string *)(v24 + 16), optarg);
              std::string::assign((std::string *)(v24 + 40), optarg);
LABEL_36:
              v42 = optarg;
              v43 = (std::string *)(v24 + 64);
              goto LABEL_37;
            case 't':
              g_applist_opt = 1;
              goto LABEL_38;
            case 'u':
              v42 = optarg;
              v43 = (std::string *)v409;
LABEL_37:
              std::string::assign(v43, v42);
              goto LABEL_38;
            case 'v':
              DNBLogSetVerbose(1);
              goto LABEL_38;
            case 'w':
              v51 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_38;
              }
              v52 = (std::string *)&v418;
              goto LABEL_55;
            case 'x':
              v62 = optarg;
              if (optarg && *optarg)
              {
                if (!strcasecmp(optarg, "auto"))
                {
                  g_launch_flavor = 0;
                }
                else if (strcasestr(v62, "posix") == optarg)
                {
                  if (DNBLogEnabled()) {
                    _DNBLog(0, (uint64_t)"[LaunchAttach] launch flavor is posix_spawn via cmdline option", v93, v94, v95, v96, v97, v98, (uint64_t)v386);
                  }
                  g_launch_flavor = 1;
                }
                else if (strcasestr(optarg, "fork") == optarg)
                {
                  g_launch_flavor = 2;
                }
                else if (strcasestr(optarg, "backboard") == optarg)
                {
                  if (DNBLogEnabled()) {
                    _DNBLog(0, (uint64_t)"[LaunchAttach] launch flavor is BKS via cmdline option", v106, v107, v108, v109, v110, v111, (uint64_t)v386);
                  }
                  g_launch_flavor = 4;
                }
                else
                {
                  if (strcasestr(optarg, "frontboard") != optarg)
                  {
                    if (g_isatty) {
                      fprintf(__stderrp, "error: invalid TYPE for the --launch=TYPE (-x TYPE) option: '%s'\n", optarg);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"error: invalid TYPE for the --launch=TYPE (-x TYPE) option: '%s'\n", v63, v64, v65, v66, v67, v68, (uint64_t)optarg);
                    }
                    if (g_isatty) {
                      fwrite("Valid values TYPE are:\n", 0x17uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"Valid values TYPE are:\n", v350, v351, v352, v353, v354, v355, (uint64_t)v388);
                    }
                    if (g_isatty) {
                      fwrite("  auto       Auto-detect the best launch method to use.\n", 0x38uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"  auto       Auto-detect the best launch method to use.\n", v356, v357, v358, v359, v360, v361, (uint64_t)v388);
                    }
                    if (g_isatty) {
                      fwrite("  posix      Launch the executable using posix_spawn.\n", 0x36uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"  posix      Launch the executable using posix_spawn.\n", v362, v363, v364, v365, v366, v367, (uint64_t)v388);
                    }
                    if (g_isatty) {
                      fwrite("  fork       Launch the executable using fork and exec.\n", 0x38uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"  fork       Launch the executable using fork and exec.\n", v368, v369, v370, v371, v372, v373, (uint64_t)v388);
                    }
                    if (g_isatty) {
                      fwrite("  backboard  Launch the executable through BackBoard Services.\n", 0x3FuLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog(0, (uint64_t)"  backboard  Launch the executable through BackBoard Services.\n", v374, v375, v376, v377, v378, v379, (uint64_t)v388);
                    }
                    if (!g_isatty)
                    {
                      _DNBLog(0, (uint64_t)"  frontboard  Launch the executable through FrontBoard Services.\n", v380, v381, v382, v383, v384, v385, (uint64_t)v388);
                      exit(5);
                    }
                    fwrite("  frontboard  Launch the executable through FrontBoard Services.\n", 0x41uLL, 1uLL, __stderrp);
                    exit(5);
                  }
                  if (DNBLogEnabled()) {
                    _DNBLog(0, (uint64_t)"[LaunchAttach] launch flavor is FBS via cmdline option", v69, v70, v71, v72, v73, v74, (uint64_t)v386);
                  }
                  g_launch_flavor = 5;
                }
              }
              goto LABEL_38;
            default:
              goto LABEL_38;
          }
        }
      }
      unint64_t v397 = 0;
      unsigned int v398 = 0;
      v399 = 0;
      char v390 = 0;
      int v401 = 0;
      char v391 = 0;
      int v40 = 0;
      int StartModeFromRemote = 6;
      int v394 = 0;
      useconds_t v396 = 1000;
LABEL_126:
      if (SHIBYTE(v416) < 0)
      {
        uint64_t v112 = (uint64_t)v399;
        if (!v415) {
          goto LABEL_132;
        }
        v113 = v414;
      }
      else
      {
        uint64_t v112 = (uint64_t)v399;
        if (!HIBYTE(v416)) {
          goto LABEL_132;
        }
        v113 = (const char *)&v414;
      }
      DNBSetArchitecture(v113);
LABEL_132:
      uint64_t v114 = optind;
      if (SHIBYTE(v413) < 0)
      {
        if (!v412) {
          goto LABEL_138;
        }
        v115 = v411;
      }
      else
      {
        if (!HIBYTE(v413)) {
          goto LABEL_138;
        }
        v115 = (const char *)&v411;
      }
      if (!RNBContext::SetWorkingDirectory((RNBContext *)v24, v115))
      {
        if (!g_isatty)
        {
          v348 = &v411;
          if (v413 < 0) {
            v348 = v411;
          }
          _DNBLog(0, (uint64_t)"error: working directory doesn't exist '%s'.\n", v116, v117, v118, v119, v120, v121, (uint64_t)v348);
          exit(8);
        }
        v349 = (const char *)&v411;
        if (v413 < 0) {
          v349 = v411;
        }
        fprintf(__stderrp, "error: working directory doesn't exist '%s'.\n", v349);
        exit(8);
      }
LABEL_138:
      v122 = &argv[v114];
      *(unsigned char *)(v24 + 440) = g_detach_on_error;
      RNBRemote::Initialize((RNBRemote *)v24);
      if (v112)
      {
        if (DNBLogEnabled()) {
          _DNBLog(0, (uint64_t)"debugserver is switching to logging to a file.", v123, v124, v125, v126, v127, v128, (uint64_t)v386);
        }
        DNBLogSetLogCallback(FileLogCallback, v112);
        if (v394) {
          int v129 = v394;
        }
        else {
          int v129 = -1;
        }
      }
      else
      {
        int v129 = v394;
      }
      uint64_t v130 = (argc - v114);
      DNBLogSetLogMask(v129);
      if (DNBLogEnabled() && (int)v130 >= 1)
      {
        for (uint64_t i = 0; i != v130; ++i)
        {
          if (DNBLogEnabled()) {
            _DNBLogDebug((uint64_t)"argv[%i] = %s", v132, v133, v134, v135, v136, v137, v138, i);
          }
        }
      }
      BOOL v139 = DNBDebugserverIsTranslated();
      v146 = " (running under translation)";
      if (!v139) {
        v146 = (const char *)&unk_10005A589;
      }
      if (g_isatty)
      {
        v147 = v421;
        if (v422 < 0) {
          v147 = (void **)v421[0];
        }
        fprintf(__stdoutp, "%s-%s %sfor %s%s.\n", "debugserver", "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n", (const char *)v147, "arm64", v146);
      }
      else
      {
        _DNBLog(0, (uint64_t)"%s-%s %sfor %s%s.\n", v140, v141, v142, v143, v144, v145, (uint64_t)"debugserver");
      }
      memset(&v406, 0, sizeof(v406));
      int v405 = 0x7FFFFFFF;
      LOBYTE(v428[0]) = 0;
      if (g_lockdown_opt || g_applist_opt || communication_fd != -1) {
        goto LABEL_250;
      }
      if ((int)v130 <= 0) {
        show_usage_and_exit(1, v148, v149, v150, v151, v152, v153, v154);
      }
      v155 = *v122;
      size_t v156 = strlen(*v122);
      if (v156 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_531;
      }
      std::string::size_type v157 = v156;
      if (v156 >= 0x17)
      {
        uint64_t v159 = (v156 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v156 | 7) != 0x17) {
          uint64_t v159 = v156 | 7;
        }
        uint64_t v160 = v159 + 1;
        v158 = (std::string *)operator new(v159 + 1);
        __dst[0].__r_.__value_.__l.__size_ = v157;
        __dst[0].__r_.__value_.__r.__words[2] = v160 | 0x8000000000000000;
        __dst[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v158;
      }
      else
      {
        *((unsigned char *)&__dst[0].__r_.__value_.__s + 23) = v156;
        v158 = __dst;
        if (!v156)
        {
LABEL_172:
          v158->__r_.__value_.__s.__data_[v157] = 0;
          std::string::size_type v161 = std::string::rfind(__dst, 58, 0xFFFFFFFFFFFFFFFFLL);
          if (v161 == -1)
          {
            if (sscanf(*v122, "%i", &v405) == 1)
            {
              std::string::assign(&v406, "127.0.0.1");
              if (DNBLogEnabled())
              {
                if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  v180 = &v406;
                }
                else {
                  v180 = (std::string *)v406.__r_.__value_.__r.__words[0];
                }
                _DNBLogDebug((uint64_t)"host = '%s'  port = %i", v173, v174, v175, v176, v177, v178, v179, (uint64_t)v180);
              }
LABEL_249:
              LODWORD(v130) = v130 - 1;
              ++v122;
              if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__dst[0].__r_.__value_.__l.__data_);
                if (StartModeFromRemote == 2) {
                  goto LABEL_266;
                }
LABEL_251:
                if (StartModeFromRemote == 5) {
                  goto LABEL_266;
                }
                if (v130 && !g_lockdown_opt)
                {
                  if ((int)v130 >= 1)
                  {
                    uint64_t v210 = 0;
                    do
                    {
                      if (DNBLogEnabled()) {
                        _DNBLogDebug((uint64_t)"inferior_argv[%i] = '%s'", v211, v212, v213, v214, v215, v216, v217, v210);
                      }
                      RNBContext::PushArgument((RNBContext *)v24, v122[v210++]);
                    }
                    while (v130 != v210);
                  }
                  int StartModeFromRemote = 3;
                  goto LABEL_269;
                }
                if (g_lockdown_opt)
                {
                  int v218 = open("/dev/null", 2);
                  dup2(v218, 1);
                  dup2(v218, 2);
LABEL_263:
                  if (DNBLogEnabled()) {
                    _DNBLogDebug((uint64_t)"Get args from remote protocol...", v219, v220, v221, v222, v223, v224, v225, (uint64_t)v387);
                  }
                  int StartModeFromRemote = 1;
LABEL_266:
                  if (((StartModeFromRemote != 3) & ~v40) != 0)
                  {
LABEL_272:
                    bzero(__dst, 0x400uLL);
                    v395 = (DNBError *)(v24 + 312);
                    int v392 = v391 & 1;
                    while (1)
                    {
                      int v236 = StartModeFromRemote - 1;
                      int StartModeFromRemote = 6;
                      switch(v236)
                      {
                        case 0:
                          if (g_lockdown_opt)
                          {
                            if (*(_DWORD *)(v24 + 472) != -1) {
                              goto LABEL_474;
                            }
                            if (RNBSocket::ConnectToService((RNBSocket *)(v24 + 472), v392))
                            {
                              if (g_isatty)
                              {
                                v243 = __stderrp;
                                v244 = "Failed to get connection from a remote gdb process.\n";
                                size_t v245 = 52;
                                goto LABEL_480;
                              }
                              _DNBLog(0, (uint64_t)"Failed to get connection from a remote gdb process.\n", v237, v238, v239, v240, v241, v242, (uint64_t)v387);
                            }
                            else
                            {
                              if (!g_applist_opt) {
                                goto LABEL_473;
                              }
                              if (DNBLogEnabled()) {
                                _DNBLog(0, (uint64_t)"debugserver running in applist mode under lockdown", v296, v297, v298, v299, v300, v301, (uint64_t)v387);
                              }
                              memset(&__p, 0, sizeof(__p));
                              if (!ListApplications(&__p))
                              {
                                if (DNBLogEnabled())
                                {
                                  p_p = &__p;
                                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                                    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                                  }
                                  _DNBLogDebug((uint64_t)"Task list: %s", v302, v303, v304, v305, v306, v307, v308, (uint64_t)p_p);
                                }
                                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  v310 = &__p;
                                }
                                else {
                                  v310 = (std::string *)__p.__r_.__value_.__r.__words[0];
                                }
                                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                                }
                                else {
                                  size_t size = __p.__r_.__value_.__l.__size_;
                                }
                                RNBSocket::Write((RNBSocket *)(v24 + 472), v310, size);
                                memset(&v402, 0, sizeof(v402));
                                RNBSocket::Read((int *)(v24 + 472), (uint64_t)&v402);
                                if (SHIBYTE(v402.__r_.__value_.__r.__words[2]) < 0) {
                                  operator delete(v402.__r_.__value_.__l.__data_);
                                }
                              }
                              RNBSocket::Disconnect((RNBSocket *)(v24 + 472));
                              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__p.__r_.__value_.__l.__data_);
                              }
                            }
                          }
                          else
                          {
                            uint64_t v230 = v405;
                            if (v405 == 0x7FFFFFFF)
                            {
                              if (LOBYTE(v428[0]) == 47)
                              {
                                if (!RNBSocket::OpenFile((RNBSocket *)(v24 + 472), (const char *)v428)) {
                                  goto LABEL_474;
                                }
                              }
                              else
                              {
                                if (communication_fd < 0) {
                                  goto LABEL_474;
                                }
                                if (!RNBSocket::useFD((RNBSocket *)(v24 + 472), communication_fd))
                                {
LABEL_473:
                                  RNBRemote::StartReadRemoteDataThread((RNBRemote *)v24);
                                  goto LABEL_474;
                                }
                              }
                            }
                            else
                            {
                              if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                v269 = &v406;
                              }
                              else {
                                v269 = (std::string *)v406.__r_.__value_.__r.__words[0];
                              }
                              if (v408 >= 0) {
                                v270 = v407;
                              }
                              else {
                                v270 = (void **)v407[0];
                              }
                              if (v410 >= 0) {
                                v271 = v409;
                              }
                              else {
                                v271 = (void **)v409[0];
                              }
                              if (ConnectRemote((RNBRemote *)v24, (char *)v269, v405, v401 & 1, (const char *)v270, (const char *)v271, v234, v235))
                              {
LABEL_474:
                                if (g_isatty) {
                                  fwrite("Got a connection, waiting for process information for launching or attaching.\n", 0x4EuLL, 1uLL, __stdoutp);
                                }
                                else {
                                  _DNBLog(0, (uint64_t)"Got a connection, waiting for process information for launching or attaching.\n", v230, v231, v232, v233, v234, v235, (uint64_t)v387);
                                }
                                int StartModeFromRemote = RNBRunLoopGetStartModeFromRemote((RNBRemote *)v24);
                              }
                            }
                          }
                          continue;
                        case 1:
                          uint64_t v251 = HIBYTE(v420);
                          if (v420 < 0) {
                            uint64_t v251 = v419;
                          }
                          if (v251)
                          {
                            if (v398)
                            {
                              gettimeofday((timeval *)&__p, 0);
                              v402.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0]
                                                                + v398
                                                                + SLODWORD(__p.__r_.__value_.__r.__words[1]) / 1000000;
                              v402.__r_.__value_.__l.__size_ = 1000 * LODWORD(__p.__r_.__value_.__r.__words[1])
                                                             % 1000000000;
                              v252 = (timespec *)&v402;
                            }
                            else
                            {
                              v252 = 0;
                            }
                            int v256 = g_launch_flavor;
                            if (!g_launch_flavor)
                            {
                              if (v420 >= 0) {
                                v257 = (const char *)&v418;
                              }
                              else {
                                v257 = (const char *)v418;
                              }
                              size_t v258 = strlen(v257);
                              if (v258 >= 4
                                && v257[v258 - 4] == 46
                                && v257[v258 - 3] == 97
                                && v257[v258 - 2] == 112
                                && v257[v258 - 1] == 112)
                              {
                                int v256 = 5;
                              }
                              else
                              {
                                int v256 = 1;
                              }
                            }
                            *(_DWORD *)(v24 + 304) = v256;
                            if (g_isatty)
                            {
                              if (v420 >= 0) {
                                v259 = (const char *)&v418;
                              }
                              else {
                                v259 = (const char *)v418;
                              }
                              fprintf(__stdoutp, "Waiting to attach to process %s...\n", v259);
                            }
                            else
                            {
                              if (v420 >= 0) {
                                v260 = &v418;
                              }
                              else {
                                v260 = v418;
                              }
                              _DNBLog(0, (uint64_t)"Waiting to attach to process %s...\n", v230, v231, v232, v233, v234, v235, (uint64_t)v260);
                            }
                            if (v420 >= 0) {
                              v261 = (char *)&v418;
                            }
                            else {
                              v261 = (char *)v418;
                            }
                            int v262 = DNBProcessAttachWait((RNBContext *)v24, v261, 0, v252, v396, (char *)__dst, 0x400uLL, 0, 0);
                            goto LABEL_354;
                          }
                          if (v397)
                          {
                            if (g_isatty) {
                              fprintf(__stdoutp, "Attaching to process %i...\n", v397);
                            }
                            else {
                              _DNBLog(0, (uint64_t)"Attaching to process %i...\n", v230, v231, v232, v233, v234, v235, v397);
                            }
                            LODWORD(__p.__r_.__value_.__l.__data_) = 0;
                            if (RNBRunLoopLaunchAttaching((RNBRemote *)v24, v397, (int *)&__p) != 4)
                            {
                              DNBError::AsString(v395);
                              if (g_isatty) {
                                fprintf(__stderrp, "error: failed to attach process %i: %s\n");
                              }
                              else {
                                _DNBLog(0, (uint64_t)"error: failed to attach process %i: %s\n", v313, v314, v315, v316, v317, v318, v397);
                              }
LABEL_448:
                              int v312 = 6;
                              goto LABEL_449;
                            }
                            goto LABEL_445;
                          }
                          std::string::size_type v286 = HIBYTE(v417.__r_.__value_.__r.__words[2]);
                          if ((v417.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                            std::string::size_type v286 = v417.__r_.__value_.__l.__size_;
                          }
                          if (v286)
                          {
                            if (v398)
                            {
                              gettimeofday((timeval *)&__p, 0);
                              v402.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0]
                                                                + v398
                                                                + SLODWORD(__p.__r_.__value_.__r.__words[1]) / 1000000;
                              v402.__r_.__value_.__l.__size_ = 1000 * LODWORD(__p.__r_.__value_.__r.__words[1])
                                                             % 1000000000;
                              v287 = &v402;
                            }
                            else
                            {
                              v287 = 0;
                            }
                            if (g_isatty)
                            {
                              if ((v417.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                v322 = &v417;
                              }
                              else {
                                v322 = (std::string *)v417.__r_.__value_.__r.__words[0];
                              }
                              fprintf(__stdoutp, "Attaching to process %s...\n", (const char *)v322);
                            }
                            else
                            {
                              if ((v417.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                v323 = &v417;
                              }
                              else {
                                v323 = (std::string *)v417.__r_.__value_.__r.__words[0];
                              }
                              _DNBLog(0, (uint64_t)"Attaching to process %s...\n", v230, v231, v232, v233, v234, v235, (uint64_t)v323);
                            }
                            if ((v417.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                              v324 = &v417;
                            }
                            else {
                              v324 = (std::string *)v417.__r_.__value_.__r.__words[0];
                            }
                            int v262 = DNBProcessAttachByName((char *)v324, (uint64_t)v287, v24 + 448, __dst, 1024);
LABEL_354:
                            g_pid = v262;
                            if (!v262)
                            {
                              *(void *)(v24 + 312) = 0xFFFFFFFFLL;
                              if (*(char *)(v24 + 343) < 0)
                              {
                                **(unsigned char **)(v24 + 320) = 0;
                                *(void *)(v24 + 328) = 0;
                                if (__dst[0].__r_.__value_.__s.__data_[0]) {
LABEL_358:
                                }
                                  std::string::assign((std::string *)(v24 + 320), (const std::string::value_type *)__dst);
                              }
                              else
                              {
                                *(unsigned char *)(v24 + 320) = 0;
                                *(unsigned char *)(v24 + 343) = 0;
                                if (__dst[0].__r_.__value_.__s.__data_[0]) {
                                  goto LABEL_358;
                                }
                              }
                              if (g_isatty)
                              {
                                fprintf(__stderrp, "error: failed to attach to process named: \"%s\" %s\n");
                              }
                              else
                              {
                                if (v420 >= 0) {
                                  v295 = &v418;
                                }
                                else {
                                  v295 = v418;
                                }
                                _DNBLog(0, (uint64_t)"error: failed to attach to process named: \"%s\" %s\n", v263, v264, v265, v266, v267, v268, (uint64_t)v295);
                              }
                              goto LABEL_448;
                            }
                            RNBContext::SetProcessID((RNBContext *)v24, v262);
LABEL_445:
                            int v312 = 4;
LABEL_449:
                            int StartModeFromRemote = 6;
                            if (v312 != 6)
                            {
                              uint64_t v230 = v405;
                              if (v405 == 0x7FFFFFFF)
                              {
                                if (LOBYTE(v428[0]) == 47)
                                {
                                  if (!RNBSocket::OpenFile((RNBSocket *)(v24 + 472), (const char *)v428)) {
                                    goto LABEL_468;
                                  }
                                }
                                else
                                {
                                  if (communication_fd < 0) {
                                    goto LABEL_468;
                                  }
                                  if (!RNBSocket::useFD((RNBSocket *)(v24 + 472), communication_fd))
                                  {
                                    RNBRemote::StartReadRemoteDataThread((RNBRemote *)v24);
                                    goto LABEL_468;
                                  }
                                }
                              }
                              else
                              {
                                if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  v319 = &v406;
                                }
                                else {
                                  v319 = (std::string *)v406.__r_.__value_.__r.__words[0];
                                }
                                if (v408 >= 0) {
                                  v320 = v407;
                                }
                                else {
                                  v320 = (void **)v407[0];
                                }
                                if (v410 >= 0) {
                                  v321 = v409;
                                }
                                else {
                                  v321 = (void **)v409[0];
                                }
                                if (ConnectRemote((RNBRemote *)v24, (char *)v319, v405, v401 & 1, (const char *)v320, (const char *)v321, v234, v235))
                                {
LABEL_468:
                                  if (g_isatty) {
                                    fprintf(__stdoutp, "Waiting for debugger instructions for process %d.\n", v397);
                                  }
                                  else {
                                    _DNBLog(0, (uint64_t)"Waiting for debugger instructions for process %d.\n", v230, v231, v232, v233, v234, v235, v397);
                                  }
                                  int StartModeFromRemote = v312;
                                }
                              }
                            }
                          }
                          else if (g_isatty)
                          {
                            v243 = __stderrp;
                            v244 = "error: asked to attach with empty name and invalid PID.\n";
                            size_t v245 = 56;
LABEL_480:
                            fwrite(v244, v245, 1uLL, v243);
                          }
                          else
                          {
                            _DNBLog(0, (uint64_t)"error: asked to attach with empty name and invalid PID.\n", v230, v231, v232, v233, v234, v235, (uint64_t)v387);
                          }
                          continue;
                        case 2:
                          if (*(char *)(v24 + 39) < 0)
                          {
                            if (*(void *)(v24 + 24))
                            {
                              v246 = *(const char **)(v24 + 16);
                              int v247 = *(char *)(v24 + 63);
                              if ((v247 & 0x80000000) == 0) {
                                goto LABEL_289;
                              }
                            }
                            else
                            {
                              v246 = 0;
                              int v247 = *(char *)(v24 + 63);
                              if ((v247 & 0x80000000) == 0) {
                                goto LABEL_289;
                              }
                            }
                          }
                          else
                          {
                            if (*(unsigned char *)(v24 + 39)) {
                              v246 = (const char *)(v24 + 16);
                            }
                            else {
                              v246 = 0;
                            }
                            int v247 = *(char *)(v24 + 63);
                            if ((v247 & 0x80000000) == 0)
                            {
LABEL_289:
                              if (v247) {
                                v248 = (const char *)(v24 + 40);
                              }
                              else {
                                v248 = 0;
                              }
                              int v249 = *(char *)(v24 + 87);
                              if (v249 < 0)
                              {
LABEL_316:
                                if (*(void *)(v24 + 72)) {
                                  v250 = *(const char **)(v24 + 64);
                                }
                                else {
                                  v250 = 0;
                                }
                                goto LABEL_377;
                              }
                              goto LABEL_293;
                            }
                          }
                          if (*(void *)(v24 + 48))
                          {
                            v248 = *(const char **)(v24 + 40);
                            int v249 = *(char *)(v24 + 87);
                            if (v249 < 0) {
                              goto LABEL_316;
                            }
                          }
                          else
                          {
                            v248 = 0;
                            int v249 = *(char *)(v24 + 87);
                            if (v249 < 0) {
                              goto LABEL_316;
                            }
                          }
LABEL_293:
                          if (v249) {
                            v250 = (const char *)(v24 + 64);
                          }
                          else {
                            v250 = 0;
                          }
LABEL_377:
                          int v272 = RNBRunLoopLaunchInferior((RNBRemote *)v24, v246, v248, v250, v390 & 1);
                          if (v272 == 4)
                          {
                            if (v405 == 0x7FFFFFFF)
                            {
                              if (LOBYTE(v428[0]) == 47)
                              {
                                if (!RNBSocket::OpenFile((RNBSocket *)(v24 + 472), (const char *)v428)) {
                                  goto LABEL_407;
                                }
                              }
                              else
                              {
                                if (communication_fd < 0) {
                                  goto LABEL_407;
                                }
                                if (!RNBSocket::useFD((RNBSocket *)(v24 + 472), communication_fd))
                                {
                                  RNBRemote::StartReadRemoteDataThread((RNBRemote *)v24);
                                  goto LABEL_407;
                                }
                              }
                            }
                            else
                            {
                              if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                v283 = &v406;
                              }
                              else {
                                v283 = (std::string *)v406.__r_.__value_.__r.__words[0];
                              }
                              if (v408 >= 0) {
                                v284 = v407;
                              }
                              else {
                                v284 = (void **)v407[0];
                              }
                              if (v410 >= 0) {
                                v285 = v409;
                              }
                              else {
                                v285 = (void **)v409[0];
                              }
                              if (ConnectRemote((RNBRemote *)v24, (char *)v283, v405, v401 & 1, (const char *)v284, (const char *)v285, v273, v274))
                              {
LABEL_407:
                                if (*(void *)(v24 + 352) != *(void *)(v24 + 344))
                                {
                                  v288 = RNBContext::ArgumentAtIndex((RNBContext *)v24, 0);
                                  if (!DNBLogEnabled()) {
                                    goto LABEL_410;
                                  }
LABEL_409:
                                  _DNBLog(0, (uint64_t)"[LaunchAttach] Successfully launched %s (pid = %d).\n", v289, v290, v291, v292, v293, v294, (uint64_t)v288);
                                  goto LABEL_410;
                                }
                                v288 = "<unknown>";
                                if (DNBLogEnabled()) {
                                  goto LABEL_409;
                                }
LABEL_410:
                                if (g_isatty) {
                                  fprintf(__stdoutp, "Got a connection, launched process %s (pid = %d).\n", v288, *(_DWORD *)(v24 + 12));
                                }
                                else {
                                  _DNBLog(0, (uint64_t)"Got a connection, launched process %s (pid = %d).\n", v289, v290, v291, v292, v293, v294, (uint64_t)v288);
                                }
                                int StartModeFromRemote = 4;
                              }
                            }
                          }
                          else
                          {
                            int StartModeFromRemote = v272;
                            uint64_t v275 = DNBError::AsString(v395);
                            if (g_isatty)
                            {
                              if (v275) {
                                v282 = (const char *)v275;
                              }
                              else {
                                v282 = "unknown error.";
                              }
                              fprintf(__stderrp, "error: failed to launch process %s: %s\n", v393, v282);
                            }
                            else
                            {
                              _DNBLog(0, (uint64_t)"error: failed to launch process %s: %s\n", v276, v277, v278, v279, v280, v281, (uint64_t)v393);
                            }
                          }
                          continue;
                        case 3:
                          int StartModeFromRemote = RNBRunLoopInferiorExecuting((RNBRemote *)v24);
                          continue;
                        case 4:
                          if (v405 == 0x7FFFFFFF)
                          {
                            if (LOBYTE(v428[0]) == 47)
                            {
                              if (!RNBSocket::OpenFile((RNBSocket *)(v24 + 472), (const char *)v428)) {
                                goto LABEL_328;
                              }
                            }
                            else
                            {
                              if (communication_fd < 0) {
                                goto LABEL_328;
                              }
                              if (!RNBSocket::useFD((RNBSocket *)(v24 + 472), communication_fd))
                              {
                                RNBRemote::StartReadRemoteDataThread((RNBRemote *)v24);
                                goto LABEL_328;
                              }
                            }
                          }
                          else
                          {
                            if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                              v253 = &v406;
                            }
                            else {
                              v253 = (std::string *)v406.__r_.__value_.__r.__words[0];
                            }
                            if (v408 >= 0) {
                              v254 = v407;
                            }
                            else {
                              v254 = (void **)v407[0];
                            }
                            if (v410 >= 0) {
                              v255 = v409;
                            }
                            else {
                              v255 = (void **)v409[0];
                            }
                            if (ConnectRemote((RNBRemote *)v24, (char *)v253, v405, v401 & 1, (const char *)v254, (const char *)v255, v234, v235))
                            {
LABEL_328:
                              RNBRunLoopPlatform((RNBRemote *)v24);
                            }
                          }
                          break;
                        case 5:
                          RNBRemote::StopReadRemoteDataThread((RNBRemote *)v24);
                          RNBContext::SetProcessID((RNBContext *)v24, 0);
                          if (g_isatty) {
                            fwrite("Exiting.\n", 9uLL, 1uLL, __stdoutp);
                          }
                          else {
                            _DNBLog(0, (uint64_t)"Exiting.\n", v325, v326, v327, v328, v329, v330, (uint64_t)v387);
                          }
                          int v36 = 0;
                          goto LABEL_501;
                        default:
                          continue;
                      }
                    }
                  }
LABEL_269:
                  v226 = _NSGetEnviron();
                  v227 = **v226;
                  if (v227)
                  {
                    v228 = (const char **)(*v226 + 1);
                    do
                    {
                      RNBContext::PushEnvironmentIfNeeded((RNBContext *)v24, v227);
                      v229 = *v228++;
                      v227 = v229;
                    }
                    while (v229);
                  }
                  goto LABEL_272;
                }
                if (!g_applist_opt) {
                  goto LABEL_263;
                }
                if (DNBLogEnabled()) {
                  _DNBLog(0, (uint64_t)"debugserver running in --applist mode", v332, v333, v334, v335, v336, v337, (uint64_t)v387);
                }
                memset(__dst, 0, 24);
                uint64_t v338 = ListApplications(__dst);
                int v36 = v338;
                if (v338)
                {
                  if (g_isatty) {
                    fprintf(__stderrp, "error: ListApplications returned error %i\n", v338);
                  }
                  else {
                    _DNBLog(0, (uint64_t)"error: ListApplications returned error %i\n", v339, v340, v341, v342, v343, v344, v338);
                  }
                }
                else
                {
                  if ((__dst[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    v345 = __dst;
                  }
                  else {
                    v345 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
                  }
                  fputs((const char *)v345, __stdoutp);
                }
                if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst[0].__r_.__value_.__l.__data_);
                }
LABEL_501:
                if (SHIBYTE(v406.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v406.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v408) & 0x80000000) == 0)
                  {
LABEL_503:
                    if ((SHIBYTE(v410) & 0x80000000) == 0) {
                      goto LABEL_504;
                    }
                    goto LABEL_512;
                  }
                }
                else if ((SHIBYTE(v408) & 0x80000000) == 0)
                {
                  goto LABEL_503;
                }
                operator delete(v407[0]);
                if ((SHIBYTE(v410) & 0x80000000) == 0)
                {
LABEL_504:
                  if ((SHIBYTE(v413) & 0x80000000) == 0) {
                    goto LABEL_505;
                  }
                  goto LABEL_513;
                }
LABEL_512:
                operator delete(v409[0]);
                if ((SHIBYTE(v413) & 0x80000000) == 0)
                {
LABEL_505:
                  if ((SHIBYTE(v416) & 0x80000000) == 0) {
                    goto LABEL_506;
                  }
                  goto LABEL_514;
                }
LABEL_513:
                operator delete(v411);
                if ((SHIBYTE(v416) & 0x80000000) == 0)
                {
LABEL_506:
                  if ((SHIBYTE(v417.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_507;
                  }
                  goto LABEL_515;
                }
LABEL_514:
                operator delete(v414);
                if ((SHIBYTE(v417.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_507:
                  if ((SHIBYTE(v420) & 0x80000000) == 0) {
                    goto LABEL_508;
                  }
                  goto LABEL_516;
                }
LABEL_515:
                operator delete(v417.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v420) & 0x80000000) == 0)
                {
LABEL_508:
                  if ((SHIBYTE(v422) & 0x80000000) == 0) {
                    return v36;
                  }
LABEL_517:
                  operator delete(v421[0]);
                  return v36;
                }
LABEL_516:
                operator delete(v418);
                if ((SHIBYTE(v422) & 0x80000000) == 0) {
                  return v36;
                }
                goto LABEL_517;
              }
LABEL_250:
              if (StartModeFromRemote == 2) {
                goto LABEL_266;
              }
              goto LABEL_251;
            }
            v191 = *v122;
            if (**v122 == 47)
            {
              int v405 = 0x7FFFFFFF;
              strlcpy((char *)v428, v191, 0x400uLL);
              goto LABEL_249;
            }
            goto LABEL_544;
          }
          std::string::size_type v162 = v161;
          std::string::size_type v163 = HIBYTE(__dst[0].__r_.__value_.__r.__words[2]);
          if ((__dst[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v164 = __dst;
          }
          else
          {
            std::string::size_type v163 = __dst[0].__r_.__value_.__l.__size_;
            v164 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
          }
          if (v163 >= v161) {
            std::string::size_type v165 = v161;
          }
          else {
            std::string::size_type v165 = v163;
          }
          if (v165 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_531;
          }
          if (v165 >= 0x17)
          {
            uint64_t v181 = (v165 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v165 | 7) != 0x17) {
              uint64_t v181 = v165 | 7;
            }
            uint64_t v182 = v181 + 1;
            v166 = (std::string *)operator new(v181 + 1);
            __p.__r_.__value_.__l.__size_ = v165;
            __p.__r_.__value_.__r.__words[2] = v182 | 0x8000000000000000;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v166;
          }
          else
          {
            *((unsigned char *)&__p.__r_.__value_.__s + 23) = v165;
            v166 = &__p;
            if (!v165)
            {
LABEL_193:
              v166->__r_.__value_.__s.__data_[v165] = 0;
              if (SHIBYTE(v406.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v406.__r_.__value_.__l.__data_);
              }
              std::string v406 = __p;
              if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::size_type v183 = __dst[0].__r_.__value_.__l.__size_;
                if (__dst[0].__r_.__value_.__l.__size_ <= v162) {
                  goto LABEL_531;
                }
                v184 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
              }
              else
              {
                std::string::size_type v183 = HIBYTE(__dst[0].__r_.__value_.__r.__words[2]);
                if (v162 >= HIBYTE(__dst[0].__r_.__value_.__r.__words[2])) {
                  goto LABEL_531;
                }
                v184 = __dst;
              }
              std::string::size_type v185 = v162 + 1;
              std::string::size_type v186 = v183 - (v162 + 1);
              if (v186 > 0x7FFFFFFFFFFFFFF7) {
LABEL_531:
              }
                abort();
              if (v186 >= 0x17)
              {
                uint64_t v188 = (v186 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v186 | 7) != 0x17) {
                  uint64_t v188 = v186 | 7;
                }
                uint64_t v189 = v188 + 1;
                v187 = (std::string *)operator new(v188 + 1);
                __p.__r_.__value_.__l.__size_ = v186;
                __p.__r_.__value_.__r.__words[2] = v189 | 0x8000000000000000;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v187;
              }
              else
              {
                *((unsigned char *)&__p.__r_.__value_.__s + 23) = v186;
                v187 = &__p;
                if (v183 == v185)
                {
LABEL_208:
                  v187->__r_.__value_.__s.__data_[v186] = 0;
                  __endptr = 0;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    v190 = &__p;
                  }
                  else {
                    v190 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  int v405 = strtoul((const char *)v190, &__endptr, 0);
                  std::string::size_type v192 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    v193 = &__p;
                  }
                  else {
                    v193 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    std::string::size_type v192 = __p.__r_.__value_.__l.__size_;
                  }
                  if (__endptr >= (char *)v193 + v192)
                  {
                    if (SHIBYTE(v406.__r_.__value_.__r.__words[2]) < 0)
                    {
                      if (*v406.__r_.__value_.__l.__data_ == 91)
                      {
                        std::string::size_type v194 = v406.__r_.__value_.__l.__size_;
                        if (*(unsigned char *)(v406.__r_.__value_.__r.__words[0] + v406.__r_.__value_.__l.__size_ - 1) == 93)
                        {
                          if (!v406.__r_.__value_.__l.__size_) {
                            goto LABEL_531;
                          }
                          v195 = (std::string::value_type *)(v406.__r_.__value_.__r.__words[0] + 1);
                          goto LABEL_226;
                        }
                      }
                    }
                    else if (v406.__r_.__value_.__s.__data_[0] == 91)
                    {
                      std::string::size_type v194 = HIBYTE(v406.__r_.__value_.__r.__words[2]);
                      if (v406.__r_.__value_.__s.__data_[HIBYTE(v406.__r_.__value_.__r.__words[2]) - 1] == 93)
                      {
                        if (!*((unsigned char *)&v406.__r_.__value_.__s + 23)) {
                          goto LABEL_531;
                        }
                        v195 = &v406.__r_.__value_.__s.__data_[1];
LABEL_226:
                        std::string::size_type v196 = v194 - 2;
                        std::string::size_type v197 = v194 - 1;
                        if (v197 >= v196) {
                          std::string::size_type v198 = v196;
                        }
                        else {
                          std::string::size_type v198 = v197;
                        }
                        if (v198 <= 0x7FFFFFFFFFFFFFF7)
                        {
                          if (v198 >= 0x17)
                          {
                            uint64_t v200 = (v198 & 0xFFFFFFFFFFFFFFF8) + 8;
                            if ((v198 | 7) != 0x17) {
                              uint64_t v200 = v198 | 7;
                            }
                            uint64_t v201 = v200 + 1;
                            v199 = (std::string *)operator new(v200 + 1);
                            v402.__r_.__value_.__l.__size_ = v198;
                            v402.__r_.__value_.__r.__words[2] = v201 | 0x8000000000000000;
                            v402.__r_.__value_.__r.__words[0] = (std::string::size_type)v199;
                          }
                          else
                          {
                            *((unsigned char *)&v402.__r_.__value_.__s + 23) = v198;
                            v199 = &v402;
                            if (!v198) {
                              goto LABEL_240;
                            }
                          }
                          memmove(v199, v195, v198);
LABEL_240:
                          v199->__r_.__value_.__s.__data_[v198] = 0;
                          if (SHIBYTE(v406.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(v406.__r_.__value_.__l.__data_);
                          }
                          std::string v406 = v402;
                          goto LABEL_243;
                        }
                        goto LABEL_531;
                      }
                    }
LABEL_243:
                    if (DNBLogEnabled())
                    {
                      v209 = &v406;
                      if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        v209 = (std::string *)v406.__r_.__value_.__r.__words[0];
                      }
                      _DNBLogDebug((uint64_t)"host = '%s'  port = %i", v202, v203, v204, v205, v206, v207, v208, (uint64_t)v209);
                    }
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p.__r_.__value_.__l.__data_);
                    }
                    goto LABEL_249;
                  }
LABEL_544:
                  show_usage_and_exit(2, (uint64_t)v191, v167, v168, v169, v170, v171, v172);
                }
              }
              memmove(v187, (char *)v184 + v185, v186);
              goto LABEL_208;
            }
          }
          memmove(v166, v164, v165);
          goto LABEL_193;
        }
      }
      memmove(v158, v155, v157);
      goto LABEL_172;
    }
    if (g_isatty)
    {
      uint64_t v33 = __stderrp;
      uint64_t v34 = "error: failed to create a remote connection class\n";
      size_t v35 = 50;
      goto LABEL_29;
    }
    uint64_t v37 = "error: failed to create a remote connection class\n";
LABEL_31:
    _DNBLog(0, (uint64_t)v37, v17, v18, v19, v20, v21, v22, (uint64_t)v386);
    return -1;
  }
  if (!g_isatty)
  {
    uint64_t v37 = "error: Developer mode must be enabled to use debugserver.\n";
    goto LABEL_31;
  }
  uint64_t v33 = __stderrp;
  uint64_t v34 = "error: Developer mode must be enabled to use debugserver.\n";
  size_t v35 = 58;
LABEL_29:
  fwrite(v34, v35, 1uLL, v33);
  return -1;
}

void RNBContext::PushEnvironment(RNBContext *this, const char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (long long *)operator new(v7 + 1);
      *((void *)&__dst + 1) = v5;
      unint64_t v14 = v8 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v14) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        *((unsigned char *)p_dst + v5) = 0;
        unint64_t v9 = *((void *)this + 47);
        if (v9 >= *((void *)this + 48))
        {
          uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 46, (uint64_t)&__dst);
          int v12 = SHIBYTE(v14);
          *((void *)this + 47) = v11;
          if (v12 < 0) {
            operator delete((void *)__dst);
          }
        }
        else
        {
          long long v10 = __dst;
          *(void *)(v9 + 16) = v14;
          *(_OWORD *)unint64_t v9 = v10;
          *((void *)this + 47) = v9 + 24;
        }
        return;
      }
    }
    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }
}

void RNBContext::PushArgument(RNBContext *this, const char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (long long *)operator new(v7 + 1);
      *((void *)&__dst + 1) = v5;
      unint64_t v14 = v8 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v14) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        *((unsigned char *)p_dst + v5) = 0;
        unint64_t v9 = *((void *)this + 44);
        if (v9 >= *((void *)this + 45))
        {
          uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 43, (uint64_t)&__dst);
          int v12 = SHIBYTE(v14);
          *((void *)this + 44) = v11;
          if (v12 < 0) {
            operator delete((void *)__dst);
          }
        }
        else
        {
          long long v10 = __dst;
          *(void *)(v9 + 16) = v14;
          *(_OWORD *)unint64_t v9 = v10;
          *((void *)this + 44) = v9 + 24;
        }
        return;
      }
    }
    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }
}

BOOL ConnectRemote(RNBRemote *a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 118) != -1) {
    return 1;
  }
  unsigned __int16 v9 = a3;
  int v12 = (RNBRemote *)((char *)a1 + 472);
  if (!a4)
  {
    if (a3)
    {
      if (!g_isatty)
      {
        _DNBLog(0, (uint64_t)"Listening to port %i for a connection from %s...\n", a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a3);
        if (!a6) {
          goto LABEL_22;
        }
        goto LABEL_15;
      }
      uint64_t v15 = "127.0.0.1";
      if (a2) {
        uint64_t v15 = a2;
      }
      fprintf(__stdoutp, "Listening to port %i for a connection from %s...\n", a3, v15);
    }
    if (!a6) {
      goto LABEL_22;
    }
LABEL_15:
    if (*a6)
    {
      if (!RNBSocket::Listen(v12, a2, v9, (void (*)(const void *, unsigned __int16))PortWasBoundCallbackUnixSocket, a6))goto LABEL_17; {
LABEL_23:
      }
      if (g_isatty) {
        fwrite("Failed to get connection from a remote gdb process.\n", 0x34uLL, 1uLL, __stderrp);
      }
      else {
        _DNBLog(0, (uint64_t)"Failed to get connection from a remote gdb process.\n", v16, v17, v18, v19, v20, v21, v22);
      }
      return 0;
    }
LABEL_22:
    if (!RNBSocket::Listen(v12, a2, v9, (void (*)(const void *, unsigned __int16))PortWasBoundCallbackNamedPipe, a5))goto LABEL_17; {
    goto LABEL_23;
    }
  }
  if (a3)
  {
    if (RNBSocket::Connect((RNBRemote *)((char *)a1 + 472), (lldb_private::SocketAddress *)a2, (unsigned __int16)a3))
    {
      BOOL result = DNBLogEnabled();
      if (result)
      {
        _DNBLogThreaded("Failed to reverse connect to %s:%i.\n");
        return 0;
      }
      return result;
    }
LABEL_17:
    RNBRemote::StartReadRemoteDataThread(a1);
    return 1;
  }
  BOOL result = DNBLogEnabled();
  if (result)
  {
    _DNBLogThreaded("error: invalid port supplied for reverse connection: %i.\n");
    return 0;
  }
  return result;
}

char *std::vector<std::string>::__push_back_slow_path<std::string>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  unsigned __int16 v9 = &v7[24 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  long long v10 = v8 + 24;
  uint64_t v11 = (void **)*a1;
  int v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v12 - 3);
      *((void *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0;
      *(v12 - 1) = 0;
      *(v12 - 3) = 0;
      v12 -= 3;
    }
    while (v12 != v11);
    int v12 = (void **)*a1;
    unint64_t v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v10;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

const char *PortWasBoundCallbackUnixSocket(const char *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = result;
    if (*result)
    {
      int v4 = socket(1, 1, 0);
      if (v4 < 0) {
        PortWasBoundCallbackUnixSocket();
      }
      int v5 = v4;
      v15.sa_family = 1;
      strlcpy(v15.sa_data, v2, 0x67uLL);
      char v16 = 0;
      v15.sa_len = strlen(v15.sa_data) + 2;
      int v6 = strlen(v15.sa_data);
      if (connect(v5, &v15, v6 + 2) < 0) {
        PortWasBoundCallbackUnixSocket();
      }
      if (g_isatty) {
        fprintf(__stdoutp, "Listening to port %i...\n", a2);
      }
      else {
        _DNBLog(0, (uint64_t)"Listening to port %i...\n", v7, v8, v9, v10, v11, v12, a2);
      }
      size_t v13 = snprintf(__str, 0x40uLL, "%u", a2);
      if (send(v5, __str, v13, 0) != v13) {
        PortWasBoundCallbackUnixSocket();
      }
      return (const char *)close(v5);
    }
  }
  return result;
}

const char *PortWasBoundCallbackNamedPipe(const char *result, int a2)
{
  if (result && *result)
  {
    BOOL result = (const char *)open(result, 1);
    if ((result & 0x80000000) == 0)
    {
      int v3 = (int)result;
      int v4 = snprintf(__str, 0x40uLL, "%u", a2);
      write(v3, __str, v4 + 1);
      return (const char *)close(v3);
    }
  }
  return result;
}

void std::__shared_ptr_emplace<RNBRemote>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100068C38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RNBRemote>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100068C38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void std::__shared_ptr_emplace<RNBRemote>::__on_zero_shared(uint64_t a1)
{
}

uint64_t _GLOBAL__sub_I_debugserver_cpp()
{
  return __cxa_atexit((void (*)(void *))std::shared_ptr<RNBRemote>::~shared_ptr[abi:nn180100], &g_remoteSP, (void *)&_mh_execute_header);
}

uint64_t std::map<unsigned int,DNBArchPluginInfoTag>::~map[abi:nn180100](uint64_t a1)
{
  return a1;
}

uint64_t DNBArchProtocol::GetCPUType(DNBArchProtocol *this)
{
  return g_current_cpu_type;
}

uint64_t DNBArchProtocol::GetCPUSubType(DNBArchProtocol *this)
{
  return g_current_cpu_subtype;
}

uint64_t DNBArchProtocol::SetArchitecture(DNBArchProtocol *this, int a2)
{
  int v3 = (int)this;
  g_current_cpu_type = (int)this;
  g_current_cpu_subtype = a2;
  uint64_t v4 = qword_1000796C0;
  if (!qword_1000796C0) {
    goto LABEL_12;
  }
  int v5 = &qword_1000796C0;
  do
  {
    unsigned int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 >= this;
    if (v6 >= this) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      int v5 = (uint64_t *)v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != &qword_1000796C0 && *((_DWORD *)v5 + 8) <= this) {
    uint64_t v9 = 1;
  }
  else {
LABEL_12:
  }
    uint64_t v9 = 0;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("DNBArchProtocol::SetDefaultArchitecture (cpu_type=0x%8.8x, cpu_subtype=0x%8.8x) => %i", v3, a2, v9);
  }
  return v9;
}

void DNBArchProtocol::EnableAMXRegisters(DNBArchProtocol *this)
{
  enable_amx = 1;
}

__n128 DNBArchProtocol::RegisterArchPlugin(unsigned int *a1)
{
  unsigned int v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = qword_1000796C0;
    if (qword_1000796C0)
    {
      while (1)
      {
        while (1)
        {
          int v5 = (uint64_t *)v3;
          unsigned int v6 = *(_DWORD *)(v3 + 32);
          if (v1 >= v6) {
            break;
          }
          uint64_t v3 = *v5;
          uint64_t v4 = v5;
          if (!*v5) {
            goto LABEL_9;
          }
        }
        if (v6 >= v1) {
          break;
        }
        uint64_t v3 = v5[1];
        if (!v3)
        {
          uint64_t v4 = v5 + 1;
          goto LABEL_9;
        }
      }
    }
    else
    {
      uint64_t v4 = &qword_1000796C0;
      int v5 = &qword_1000796C0;
LABEL_9:
      BOOL v7 = v5;
      int v5 = (uint64_t *)operator new(0x48uLL);
      *((_DWORD *)v5 + 8) = v1;
      *(_OWORD *)(v5 + 5) = 0u;
      *(_OWORD *)(v5 + 7) = 0u;
      *int v5 = 0;
      v5[1] = 0;
      v5[2] = (uint64_t)v7;
      *uint64_t v4 = (uint64_t)v5;
      uint64_t v8 = v5;
      if (*(void *)g_arch_plugins)
      {
        g_arch_plugins = *(void *)g_arch_plugins;
        uint64_t v8 = (uint64_t *)*v4;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1000796C0, v8);
      ++qword_1000796C8;
    }
    __n128 result = *(__n128 *)a1;
    *(_OWORD *)(v5 + 7) = *((_OWORD *)a1 + 1);
    *(__n128 *)(v5 + 5) = result;
  }
  return result;
}

uint64_t DNBArchProtocol::GetRegisterCPUType(DNBArchProtocol *this)
{
  uint64_t v1 = qword_1000796C0;
  if (!qword_1000796C0) {
    return 0;
  }
  unint64_t v2 = &qword_1000796C0;
  do
  {
    unsigned int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 >= g_current_cpu_type;
    if (v3 >= g_current_cpu_type) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (v4) {
      unint64_t v2 = (uint64_t *)v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 != &qword_1000796C0 && g_current_cpu_type >= *((_DWORD *)v2 + 8)) {
    return *((unsigned int *)v2 + 10);
  }
  else {
    return 0;
  }
}

uint64_t DNBArchProtocol::GetRegisterSetInfo(DNBArchProtocol *this, unint64_t *a2)
{
  uint64_t v2 = qword_1000796C0;
  if (qword_1000796C0)
  {
    unsigned int v3 = &qword_1000796C0;
    do
    {
      unsigned int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 >= g_current_cpu_type;
      if (v4 >= g_current_cpu_type) {
        unsigned int v6 = (uint64_t *)v2;
      }
      else {
        unsigned int v6 = (uint64_t *)(v2 + 8);
      }
      if (v5) {
        unsigned int v3 = (uint64_t *)v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != &qword_1000796C0 && g_current_cpu_type >= *((_DWORD *)v3 + 8)) {
      return ((uint64_t (*)(DNBArchProtocol *, void))v3[7])(this, enable_amx);
    }
  }
  *(void *)this = 0;
  return 0;
}

uint64_t DNBArchProtocol::Create()
{
  uint64_t v0 = qword_1000796C0;
  if (!qword_1000796C0) {
    return 0;
  }
  uint64_t v1 = &qword_1000796C0;
  do
  {
    unsigned int v2 = *(_DWORD *)(v0 + 32);
    BOOL v3 = v2 >= g_current_cpu_type;
    if (v2 >= g_current_cpu_type) {
      unsigned int v4 = (uint64_t *)v0;
    }
    else {
      unsigned int v4 = (uint64_t *)(v0 + 8);
    }
    if (v3) {
      uint64_t v1 = (uint64_t *)v0;
    }
    uint64_t v0 = *v4;
  }
  while (*v4);
  if (v1 != &qword_1000796C0 && g_current_cpu_type >= *((_DWORD *)v1 + 8)) {
    return ((uint64_t (*)(void))v1[6])();
  }
  else {
    return 0;
  }
}

uint64_t DNBArchProtocol::GetBreakpointOpcode(DNBArchProtocol *this)
{
  uint64_t v1 = qword_1000796C0;
  if (!qword_1000796C0) {
    return 0;
  }
  unsigned int v2 = &qword_1000796C0;
  do
  {
    unsigned int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 >= g_current_cpu_type;
    if (v3 >= g_current_cpu_type) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (v4) {
      unsigned int v2 = (uint64_t *)v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 != &qword_1000796C0 && g_current_cpu_type >= *((_DWORD *)v2 + 8)) {
    return ((uint64_t (*)(DNBArchProtocol *))v2[8])(this);
  }
  else {
    return 0;
  }
}

void std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      unsigned int v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), BOOL v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            uint64_t v9 = (uint64_t *)a2[2];
          }
          else
          {
            uint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              unsigned int v3 = *(uint64_t **)(v2 + 16);
            }
            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            *uint64_t v9 = v2;
            *(void *)(v2 + 16) = v9;
            unsigned int v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          *unsigned int v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), BOOL v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unsigned int v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          unsigned int v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        uint64_t *v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *BOOL v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t _GLOBAL__sub_I_DNBArch_cpp()
{
  qword_1000796C8 = 0;
  qword_1000796C0 = 0;
  g_arch_plugins = (uint64_t)&qword_1000796C0;
  return __cxa_atexit((void (*)(void *))std::map<unsigned int,DNBArchPluginInfoTag>::~map[abi:nn180100], &g_arch_plugins, (void *)&_mh_execute_header);
}

void DNBBreakpointList::DNBBreakpointList(DNBBreakpointList *this)
{
  *((void *)this + 2) = 0;
  *((void *)this + 1) = 0;
  *(void *)this = (char *)this + 8;
}

void DNBBreakpointList::~DNBBreakpointList(DNBBreakpointList *this)
{
}

char *DNBBreakpointList::Add(uint64_t **this, unint64_t a2, int a3, int a4)
{
  if (a4) {
    char v7 = 2;
  }
  else {
    char v7 = 0;
  }
  uint64_t v9 = (char *)(this + 1);
  int v8 = this[1];
  uint64_t v10 = this + 1;
  uint64_t v11 = this + 1;
  if (v8)
  {
    uint64_t v12 = this[1];
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v12;
        unint64_t v13 = v12[4];
        if (v13 <= a2) {
          break;
        }
        uint64_t v12 = *v11;
        uint64_t v10 = v11;
        if (!*v11) {
          goto LABEL_11;
        }
      }
      if (v13 >= a2) {
        break;
      }
      uint64_t v12 = v11[1];
      if (!v12)
      {
        uint64_t v10 = v11 + 1;
        goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    uint64_t v14 = operator new(0x48uLL);
    v14[4] = a2;
    *((_DWORD *)v14 + 10) = 1;
    *((_DWORD *)v14 + 11) = a3;
    v14[6] = 0;
    v14[7] = a2;
    *((unsigned char *)v14 + 64) = v7;
    *((_DWORD *)v14 + 17) = -1;
    *uint64_t v14 = 0;
    v14[1] = 0;
    v14[2] = v11;
    *uint64_t v10 = v14;
    sockaddr v15 = (uint64_t *)**this;
    if (v15)
    {
      *this = v15;
      char v16 = *v10;
    }
    else
    {
      char v16 = v14;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(this[1], v16);
    int v8 = this[1];
    this[2] = (uint64_t *)((char *)this[2] + 1);
  }
  if (!v8) {
    goto LABEL_26;
  }
  uint64_t v17 = v9;
  do
  {
    unint64_t v18 = v8[4];
    BOOL v19 = v18 >= a2;
    if (v18 >= a2) {
      uint64_t v20 = (uint64_t **)v8;
    }
    else {
      uint64_t v20 = (uint64_t **)(v8 + 1);
    }
    if (v19) {
      uint64_t v17 = (char *)v8;
    }
    int v8 = *v20;
  }
  while (*v20);
  if (v17 == v9 || *((void *)v17 + 4) > a2) {
LABEL_26:
  }
    uint64_t v17 = v9;
  return v17 + 40;
}

uint64_t DNBBreakpointList::Remove(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = (uint64_t *)((char *)this + 8);
  uint64_t result = *((void *)this + 1);
  if (result)
  {
    BOOL v5 = v4;
    uint64_t v6 = result;
    do
    {
      unint64_t v7 = *(void *)(v6 + 32);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v6;
      }
      else {
        uint64_t v9 = (uint64_t *)(v6 + 8);
      }
      if (v8) {
        BOOL v5 = (uint64_t *)v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 == v4 || v5[4] > a2)
    {
      return 0;
    }
    else
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          uint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*(uint64_t **)this == v5) {
        *(void *)this = v11;
      }
      --*((void *)this + 2);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)result, v5);
      operator delete(v5);
      return 1;
    }
  }
  return result;
}

char *DNBBreakpointList::FindByAddress(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = (void *)*((void *)this + 1);
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (!v4) {
    return 0;
  }
  BOOL v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      BOOL v5 = (char *)v3;
    }
    unsigned int v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2) {
    return 0;
  }
  unint64_t v9 = *((void *)v5 + 4);
  uint64_t v10 = v5 + 40;
  if (v9 <= a2) {
    return v10;
  }
  else {
    return 0;
  }
}

char *DNBBreakpointList::FindByHardwareIndex(DNBBreakpointList *this, int a2)
{
  uint64_t v4 = *(char **)this;
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (v4 == v2) {
    return 0;
  }
  while (*((_DWORD *)v3 + 17) != a2)
  {
    unint64_t v6 = (char *)*((void *)v3 + 1);
    if (v6)
    {
      do
      {
        BOOL v7 = v6;
        unint64_t v6 = *(char **)v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        BOOL v7 = (char *)*((void *)v3 + 2);
        BOOL v8 = *(void *)v7 == (void)v3;
        unsigned int v3 = v7;
      }
      while (!v8);
    }
    unsigned int v3 = v7;
    if (v7 == v2) {
      return 0;
    }
  }
  return v3 + 40;
}

char *DNBBreakpointList::FindNearestWatchpoint(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = *(char **)this;
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (v4 == v2) {
    return 0;
  }
  BOOL v5 = v3;
  do
  {
    if (v5[64])
    {
      unint64_t v6 = *((void *)v5 + 7);
      if (v6 <= a2 && v6 + *((unsigned int *)v5 + 11) >= a2) {
        return v5 + 40;
      }
    }
    BOOL v8 = (char *)*((void *)v5 + 1);
    if (v8)
    {
      do
      {
        unint64_t v9 = v8;
        BOOL v8 = *(char **)v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        unint64_t v9 = (char *)*((void *)v5 + 2);
        BOOL v10 = *(void *)v9 == (void)v5;
        BOOL v5 = v9;
      }
      while (!v10);
    }
    BOOL v5 = v9;
  }
  while (v9 != v2);
  if (v3 == v2) {
    return 0;
  }
  uint64_t v11 = 0;
  unsigned int v12 = -1;
  do
  {
    if (v3[64])
    {
      unint64_t v13 = *((void *)v3 + 7);
      if (v13 <= a2) {
        unsigned int v14 = a2 - (v13 + *((_DWORD *)v3 + 11));
      }
      else {
        unsigned int v14 = v13 - a2;
      }
      if (v12 > v14) {
        uint64_t v11 = v3 + 40;
      }
      if (v12 >= v14) {
        unsigned int v12 = v14;
      }
    }
    sockaddr v15 = (char *)*((void *)v3 + 1);
    if (v15)
    {
      do
      {
        char v16 = v15;
        sockaddr v15 = *(char **)v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        char v16 = (char *)*((void *)v3 + 2);
        BOOL v10 = *(void *)v16 == (void)v3;
        unsigned int v3 = v16;
      }
      while (!v10);
    }
    unsigned int v3 = v16;
  }
  while (v16 != v2);
  return (char *)v11;
}

uint64_t DNBBreakpointList::FindBreakpointsThatOverlapRange(void *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v5 = *(void **)a4;
  *(void *)(a4 + 8) = *(void *)a4;
  BOOL v7 = a1 + 1;
  unint64_t v6 = (void *)a1[1];
  if (v6)
  {
    BOOL v10 = a1 + 1;
    do
    {
      unint64_t v11 = v6[4];
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = v6 + 1;
      }
      if (v12) {
        BOOL v10 = v6;
      }
      unint64_t v6 = (void *)*v13;
    }
    while (*v13);
    if (v10 != v7)
    {
      if (v10 != (void *)*a1)
      {
        uint64_t v14 = *v10;
        if (*v10)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = *(void *)(v14 + 8);
          }
          while (v14);
        }
        else
        {
          char v16 = v10;
          do
          {
            uint64_t v15 = v16[2];
            BOOL v17 = *(void *)v15 == (void)v16;
            char v16 = (void *)v15;
          }
          while (v17);
        }
        if ((*(unsigned char *)(v15 + 64) & 5) == 1 && *(_DWORD *)(v15 + 68) == -1)
        {
          uint64_t v47 = *(unsigned int *)(v15 + 44);
          if (v47)
          {
            unint64_t v48 = *(void *)(v15 + 56);
            if (a3 + a2 > v48 && v48 + v47 > a2)
            {
              uint64_t v49 = v10 + 5;
              unint64_t v50 = *(void *)(a4 + 16);
              if ((unint64_t)v5 >= v50)
              {
                uint64_t v52 = v50 - (void)v5;
                uint64_t v53 = v52 >> 2;
                if ((unint64_t)(v52 >> 2) <= 1) {
                  uint64_t v53 = 1;
                }
                BOOL v12 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8;
                unint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
                if (!v12) {
                  unint64_t v54 = v53;
                }
                if (v54 >> 61) {
LABEL_78:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                uint64_t v55 = v54;
                uint64_t v56 = operator new(8 * v54);
                uint64_t v57 = &v56[v55];
                *uint64_t v56 = v49;
                v51 = v56 + 1;
                *(void *)a4 = v56;
                *(void *)(a4 + 8) = v56 + 1;
                *(void *)(a4 + 16) = v57;
                if (v5) {
                  operator delete(v5);
                }
              }
              else
              {
                *BOOL v5 = v49;
                v51 = v5 + 1;
              }
              *(void *)(a4 + 8) = v51;
              BOOL v5 = v51;
            }
          }
        }
      }
      unint64_t v18 = a3 + a2;
      while (1)
      {
        unint64_t v19 = v10[7];
        if (v19 - a2 >= a3) {
          return ((uint64_t)v5 - *(void *)a4) >> 3;
        }
        if ((v10[8] & 5) == 1 && *((_DWORD *)v10 + 17) == -1)
        {
          uint64_t v20 = *((unsigned int *)v10 + 11);
          if (v20)
          {
            if (v18 > v19 && v19 + v20 > a2) {
              break;
            }
          }
        }
LABEL_21:
        if (v10 == v7) {
          return ((uint64_t)v5 - *(void *)a4) >> 3;
        }
      }
      uint64_t v21 = v10 + 5;
      unint64_t v22 = *(void *)(a4 + 16);
      if ((unint64_t)v5 < v22)
      {
        *BOOL v5 = v21;
        uint64_t v23 = v5 + 1;
LABEL_48:
        *(void *)(a4 + 8) = v23;
        uint64_t v37 = (void *)v10[1];
        if (v37)
        {
          do
          {
            BOOL v10 = v37;
            uint64_t v37 = (void *)*v37;
          }
          while (v37);
        }
        else
        {
          do
          {
            uint64_t v38 = v10;
            BOOL v10 = (void *)v10[2];
          }
          while ((void *)*v10 != v38);
        }
        BOOL v5 = v23;
        goto LABEL_21;
      }
      uint64_t v24 = *(char **)a4;
      uint64_t v25 = (uint64_t)v5 - *(void *)a4;
      uint64_t v26 = v25 >> 3;
      unint64_t v27 = (v25 >> 3) + 1;
      if (v27 >> 61) {
        abort();
      }
      uint64_t v28 = v22 - (void)v24;
      if (v28 >> 2 > v27) {
        unint64_t v27 = v28 >> 2;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      unint64_t v58 = v27;
      unint64_t v59 = v18;
      if (v27)
      {
        if (v27 >> 61) {
          goto LABEL_78;
        }
        uint64_t v29 = operator new(8 * v27);
        uint64_t v21 = v10 + 5;
      }
      else
      {
        uint64_t v29 = 0;
      }
      uint64_t v30 = &v29[8 * v26];
      void *v30 = v21;
      uint64_t v23 = v30 + 1;
      if (v5 == (void *)v24)
      {
        unint64_t v32 = v58;
        goto LABEL_45;
      }
      unint64_t v31 = (char *)v5 - v24 - 8;
      unint64_t v32 = v58;
      if (v31 >= 0x168)
      {
        unint64_t v39 = ((char *)(v5 - 1) - v24) & 0xFFFFFFFFFFFFFFF8;
        if (&v29[v25 - 8 - v39] > &v29[v25 - 8])
        {
          uint64_t v33 = (char *)v5;
        }
        else if ((void *)((char *)v5 - v39 - 8) > v5 - 1)
        {
          uint64_t v33 = (char *)v5;
        }
        else if ((unint64_t)((char *)v5 - &v29[v25]) >= 0x20)
        {
          uint64_t v40 = (v31 >> 3) + 1;
          uint64_t v41 = 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v33 = (char *)&v5[v41 / 0xFFFFFFFFFFFFFFF8];
          uint64_t v30 = (void *)((char *)v30 - v41);
          v42 = &v29[8 * v26 - 16];
          v43 = (long long *)(v5 - 2);
          uint64_t v44 = v40 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v45 = *v43;
            *(v42 - 1) = *(v43 - 1);
            _OWORD *v42 = v45;
            v42 -= 2;
            v43 -= 2;
            v44 -= 4;
          }
          while (v44);
          if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_43;
          }
        }
        else
        {
          uint64_t v33 = (char *)v5;
        }
      }
      else
      {
        uint64_t v33 = (char *)v5;
      }
      do
      {
        uint64_t v34 = *((void *)v33 - 1);
        v33 -= 8;
        *--uint64_t v30 = v34;
      }
      while (v33 != v24);
LABEL_43:
      BOOL v5 = *(void **)a4;
LABEL_45:
      *(void *)a4 = v30;
      *(void *)(a4 + 8) = v23;
      *(void *)(a4 + 16) = &v29[8 * v32];
      if (v5)
      {
        size_t v35 = v5;
        int v36 = v23;
        operator delete(v35);
        uint64_t v23 = v36;
      }
      unint64_t v18 = v59;
      goto LABEL_48;
    }
  }
  return ((uint64_t)v5 - *(void *)a4) >> 3;
}

void *DNBBreakpointList::DisableAll(DNBBreakpointList *this)
{
  unsigned int v3 = *(void **)this;
  uint64_t result = (void *)((char *)this + 8);
  uint64_t v2 = v3;
  if (v3 != result)
  {
    do
    {
      *((_DWORD *)v2 + 17) = -1;
      *((unsigned char *)v2 + 64) &= ~1u;
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          BOOL v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          BOOL v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != result);
  }
  return result;
}

void *DNBBreakpointList::RemoveTrapsFromBuffer(void *this, unint64_t a2, uint64_t a3, char *a4)
{
  BOOL v5 = (char *)(this + 1);
  uint64_t v4 = (void *)this[1];
  if (v4)
  {
    BOOL v8 = (char *)(this + 1);
    do
    {
      unint64_t v9 = v4[4];
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        unint64_t v11 = v4;
      }
      else {
        unint64_t v11 = v4 + 1;
      }
      if (v10) {
        BOOL v8 = (char *)v4;
      }
      uint64_t v4 = (void *)*v11;
    }
    while (*v11);
    if (v8 != v5)
    {
      unint64_t v12 = a3 + a2;
      do
      {
        if (*((void *)v8 + 4) >= v12) {
          break;
        }
        if ((v8[64] & 5) == 1 && *((_DWORD *)v8 + 17) == -1)
        {
          unint64_t v16 = *((unsigned int *)v8 + 11);
          if (v16)
          {
            unint64_t v17 = *((void *)v8 + 7);
            if (v12 > v17 && v17 + v16 > a2)
            {
              if (v12 >= v17 + v16) {
                unint64_t v18 = v17 + v16;
              }
              else {
                unint64_t v18 = v12;
              }
              if (v17 <= a2) {
                unint64_t v19 = a2;
              }
              else {
                unint64_t v19 = *((void *)v8 + 7);
              }
              BOOL v10 = a2 >= v17;
              unint64_t v20 = a2 - v17;
              if (!v10) {
                unint64_t v20 = 0;
              }
              if (v19 >= v12) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              if (v18 <= a2) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              if (v20 + v18 - v19 > v16) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              this = memcpy(&a4[v19 - a2], &v8[v20 + 48], v18 - v19);
            }
          }
        }
        unint64_t v13 = (char *)*((void *)v8 + 1);
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            unint64_t v13 = *(char **)v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (char *)*((void *)v8 + 2);
            BOOL v15 = *(void *)v14 == (void)v8;
            BOOL v8 = v14;
          }
          while (!v15);
        }
        BOOL v8 = v14;
      }
      while (v14 != v5);
    }
  }
  return this;
}

uint64_t DNBBreakpointList::DisableAllBreakpoints(uint64_t this, MachProcess *a2)
{
  uint64_t v2 = (void *)(this + 8);
  unsigned int v3 = *(void **)this;
  if (*(void *)this != this + 8)
  {
    do
    {
      this = MachProcess::DisableBreakpoint(a2, v3[7], 0);
      BOOL v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          BOOL v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          unsigned int v3 = v6;
        }
        while (!v7);
      }
      unsigned int v3 = v6;
    }
    while (v6 != v2);
  }
  return this;
}

uint64_t DNBBreakpointList::DisableAllWatchpoints(uint64_t this, MachProcess *a2)
{
  uint64_t v2 = (void *)(this + 8);
  unsigned int v3 = *(void **)this;
  if (*(void *)this != this + 8)
  {
    do
    {
      this = MachProcess::DisableWatchpoint(a2, v3[7], 0);
      BOOL v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          BOOL v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          unsigned int v3 = v6;
        }
        while (!v7);
      }
      unsigned int v3 = v6;
    }
    while (v6 != v2);
  }
  return this;
}

void DNBBreakpointList::RemoveDisabled(DNBBreakpointList *this)
{
  uint64_t v2 = (char *)this + 8;
  uint64_t v1 = *(char **)this;
  if (*(DNBBreakpointList **)this != (DNBBreakpointList *)((char *)this + 8))
  {
    do
    {
      BOOL v5 = (char *)*((void *)v1 + 1);
      if (v1[64])
      {
        if (v5)
        {
          do
          {
            BOOL v7 = v5;
            BOOL v5 = *(char **)v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            BOOL v7 = (char *)*((void *)v1 + 2);
            BOOL v8 = *(void *)v7 == (void)v1;
            uint64_t v1 = v7;
          }
          while (!v8);
        }
      }
      else
      {
        BOOL v6 = v1;
        if (v5)
        {
          do
          {
            BOOL v7 = v5;
            BOOL v5 = *(char **)v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            BOOL v7 = (char *)*((void *)v6 + 2);
            BOOL v8 = *(void *)v7 == (void)v6;
            BOOL v6 = v7;
          }
          while (!v8);
        }
        if (*(char **)this == v1) {
          *(void *)this = v7;
        }
        uint64_t v4 = (uint64_t *)*((void *)this + 1);
        --*((void *)this + 2);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, (uint64_t *)v1);
        operator delete(v1);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unsigned int v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unsigned int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      unsigned int v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  BOOL v7 = *v6;
  if (*v6 == v3)
  {
    *BOOL v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      BOOL v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      BOOL v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *unsigned int v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v14 = (uint64_t **)v7[2];
    if (*v14 == v7) {
      break;
    }
    if (*((unsigned char *)v7 + 24))
    {
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_40;
      }
    }
    else
    {
      *((unsigned char *)v7 + 24) = 1;
      *((unsigned char *)v14 + 24) = 0;
      unint64_t v17 = v14[1];
      unint64_t v18 = (uint64_t *)*v17;
      v14[1] = (uint64_t *)*v17;
      if (v18) {
        v18[2] = (uint64_t)v14;
      }
      v17[2] = (uint64_t)v14[2];
      v14[2][*v14[2] != (void)v14] = (uint64_t)v17;
      *unint64_t v17 = (uint64_t)v14;
      v14[2] = v17;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      BOOL v7 = *(uint64_t **)(*v7 + 8);
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_40;
      }
    }
    if (!*((unsigned char *)v15 + 24))
    {
      unint64_t v19 = (uint64_t *)v7[1];
      if (!v19) {
        goto LABEL_64;
      }
LABEL_63:
      if (*((unsigned char *)v19 + 24))
      {
LABEL_64:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v23 = v15[1];
        *BOOL v7 = v23;
        if (v23) {
          *(void *)(v23 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        unint64_t v19 = v7;
      }
      else
      {
        BOOL v15 = v7;
      }
      uint64_t v27 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v27 + 24);
      *(unsigned char *)(v27 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      uint64_t v28 = *(uint64_t **)(v27 + 8);
      uint64_t v29 = *v28;
      *(void *)(v27 + 8) = *v28;
      if (v29) {
        *(void *)(v29 + 16) = v27;
      }
      v28[2] = *(void *)(v27 + 16);
      *(void *)(*(void *)(v27 + 16) + 8 * (**(void **)(v27 + 16) != v27)) = v28;
      *uint64_t v28 = v27;
      *(void *)(v27 + 16) = v28;
      return result;
    }
LABEL_40:
    unint64_t v19 = (uint64_t *)v7[1];
    if (v19 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_63;
    }
    *((unsigned char *)v7 + 24) = 0;
    unint64_t v12 = (uint64_t *)v7[2];
    if (v12 == result)
    {
      unint64_t v12 = result;
LABEL_61:
      *((unsigned char *)v12 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v12 + 24)) {
      goto LABEL_61;
    }
LABEL_26:
    BOOL v7 = *(uint64_t **)(v12[2] + 8 * (*(void *)v12[2] == (void)v12));
  }
  if (*((unsigned char *)v7 + 24))
  {
    unint64_t v16 = (void *)*v7;
    if (!*v7) {
      goto LABEL_51;
    }
LABEL_50:
    if (!*((unsigned char *)v16 + 24)) {
      goto LABEL_67;
    }
  }
  else
  {
    *((unsigned char *)v7 + 24) = 1;
    *((unsigned char *)v14 + 24) = 0;
    unint64_t v20 = (uint64_t *)v7[1];
    *uint64_t v14 = v20;
    if (v20) {
      v20[2] = (uint64_t)v14;
    }
    v7[2] = (uint64_t)v14[2];
    v14[2][*v14[2] != (void)v14] = (uint64_t)v7;
    v7[1] = (uint64_t)v14;
    v14[2] = v7;
    if (result == (uint64_t *)v14) {
      uint64_t result = v7;
    }
    BOOL v7 = *v14;
    unint64_t v16 = (void *)**v14;
    if (v16) {
      goto LABEL_50;
    }
  }
LABEL_51:
  uint64_t v21 = (uint64_t *)v7[1];
  if (!v21 || *((unsigned char *)v21 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    unint64_t v12 = (uint64_t *)v7[2];
    if (*((unsigned char *)v12 + 24)) {
      BOOL v13 = v12 == result;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      goto LABEL_61;
    }
    goto LABEL_26;
  }
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_67:
    uint64_t v21 = v7;
  }
  else
  {
    *((unsigned char *)v21 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = *v21;
    v7[1] = *v21;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    v21[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v21;
    uint64_t *v21 = (uint64_t)v7;
    v7[2] = (uint64_t)v21;
    unint64_t v16 = v7;
  }
  uint64_t v24 = (uint64_t *)v21[2];
  *((unsigned char *)v21 + 24) = *((unsigned char *)v24 + 24);
  *((unsigned char *)v24 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  uint64_t v25 = *v24;
  uint64_t v26 = *(void *)(*v24 + 8);
  uint64_t *v24 = v26;
  if (v26) {
    *(void *)(v26 + 16) = v24;
  }
  *(void *)(v25 + 16) = v24[2];
  *(void *)(v24[2] + 8 * (*(void *)v24[2] != (void)v24)) = v25;
  *(void *)(v25 + 8) = v24;
  v24[2] = v25;
  return result;
}

uint64_t kqueue_thread(void *a1)
{
  int v1 = (int)a1;
  pthread_setname_np("kqueue thread");
  int v21 = 0;
  uint64_t v2 = pthread_self();
  if (!pthread_getschedparam(v2, &v21, &v22))
  {
    v22.sched_priority = 47;
    unsigned int v3 = pthread_self();
    pthread_setschedparam(v3, v21, &v22);
  }
  do
  {
    while (kevent(v1, 0, 0, &eventlist, 1, 0) != -1)
    {
      if ((eventlist.flags & 0x4000) != 0)
      {
        int data = eventlist.data;
        uint64_t v10 = strerror(eventlist.data);
        if (DNBLogEnabled())
        {
          uint64_t v11 = "Unknown error";
          if (v10) {
            uint64_t v11 = v10;
          }
          _DNBLogError("Failed to initialize kqueue event: (%d): %s", data, v11);
        }
        return 0;
      }
      int v19 = 0;
      int ident = eventlist.ident;
      pid_t v5 = waitpid(eventlist.ident, &v19, 0);
      int v6 = v19 & 0x7F;
      if (v6 == 127)
      {
        int v8 = v19 >> 8;
        if (v19 >> 8 != 19 && DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("waitpid (%i) -> STOPPED (signal = %i)", v5, v8);
        }
      }
      else
      {
        if ((v19 & 0x7F) == 0)
        {
          int v15 = BYTE1(v19);
          if (DNBLogEnabledForAny(2)) {
            _DNBLogThreaded("waitpid (%i) -> EXITED (status = %i)", v5, v15);
          }
          int v16 = eventlist.data;
          if ((eventlist.data & 0x20000) == 0) {
            goto LABEL_26;
          }
LABEL_32:
          unint64_t v17 = "Terminated due to memory issue";
          goto LABEL_34;
        }
        if (ident < 0) {
          int ident = -ident;
        }
        BOOL v7 = DNBLogEnabledForAny(2);
        if (v5 == ident)
        {
          if (v7) {
            _DNBLogThreaded("waitpid (%i) -> SIGNALED and EXITED (signal = %i)", v5, v6);
          }
          snprintf(__str, 0x40uLL, "Terminated due to signal %i", v6);
          DNBProcessSetExitInfo(v5, __str);
          int v15 = 127;
          int v16 = eventlist.data;
          if ((eventlist.data & 0x20000) != 0) {
            goto LABEL_32;
          }
LABEL_26:
          if ((v16 & 0x10000) == 0)
          {
            if ((v16 & 0x40000) != 0)
            {
              unint64_t v17 = "Terminated due to code signing error";
              goto LABEL_34;
            }
LABEL_35:
            if (DNBLogEnabledForAny(2)) {
              _DNBLogThreaded("waitpid_process_thread (): setting exit status for pid = %i to %i", v5, v15);
            }
            DNBProcessSetExitStatus(v5, v19);
            return 0;
          }
          unint64_t v17 = "Terminated due to decrypt failure";
LABEL_34:
          DNBProcessSetExitInfo(v5, v17);
          goto LABEL_35;
        }
        if (v7) {
          _DNBLogThreaded("waitpid (%i) -> SIGNALED (signal = %i)", v5, v6);
        }
      }
    }
  }
  while (*__error() == 4);
  if (DNBLogEnabled())
  {
    int v12 = *__error();
    BOOL v13 = __error();
    uint64_t v14 = strerror(*v13);
    _DNBLogError("kqueue failed with error: (%d): %s", v12, v14);
  }
  return 0;
}

uint64_t DNBProcessSetExitInfo(int a1, const char *a2)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < a1;
        if (v4 >= a1) {
          int v6 = (uint64_t *)v2;
        }
        else {
          int v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }
      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= a1)
      {
        uint64_t v9 = *(MachProcess **)(v3 + 40);
        uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
        if (v10)
        {
          uint64_t v7 = 1;
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          MachProcess::SetExitInfo(v9, a2);
          if (atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            return v7;
          }
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          MachProcess::SetExitInfo(v9, a2);
        }
        return 1;
      }
    }
  }
  return 0;
}

uint64_t DNBProcessSetExitStatus(int a1, int a2)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < a1;
        if (v4 >= a1) {
          int v6 = (uint64_t *)v2;
        }
        else {
          int v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }
      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= a1)
      {
        uint64_t v9 = *(void *)(v3 + 40);
        uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
        if (v10)
        {
          uint64_t v7 = 1;
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          *(_DWORD *)(v9 + 72) = a2;
          MachProcess::SetState(v9, 9u);
          if (atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            return v7;
          }
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          *(_DWORD *)(v9 + 72) = a2;
          MachProcess::SetState(v9, 9u);
        }
        return 1;
      }
    }
  }
  return 0;
}

uint64_t DNBProcessLaunch(RNBContext *a1, const char *a2, const char **a3, const char **a4, const char *a5, const char *a6, const char *a7, const char *a8, BOOL a9, int a10, const char *a11, char *a12, size_t a13)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s(path='%s', argv = %p, envp = %p, working_dir=%s, stdin=%s, stdout=%s, stderr=%s, no-stdio=%i, launch_flavor = %u, disable_aslr = %d, err = %p, err_len = %llu) called...", "DNBProcessLaunch", a2, a3, a4, a5, a6, a7, a8, a9, *((_DWORD *)a1 + 76), a10, a12, a13);
  }
  if (a12) {
    BOOL v21 = a13 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21) {
    *a12 = 0;
  }
  if (stat(a2, &v24) != -1) {
    operator new();
  }
  sched_param v22 = __error();
  strerror_r(*v22, (char *)__p, 0x100uLL);
  snprintf(a12, a13, "%s (%s)", (const char *)__p, a2);
  return 0;
}

uint64_t spawn_waitpid_thread(int a1)
{
  int v2 = kqueue();
  if (v2 == -1)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("Could not get kqueue for pid = %i.", a1);
    }
    int v4 = (void *)a1;
  }
  else
  {
    int v3 = v2;
    pthread_t v10 = 0;
    int v4 = (void *)a1;
    changelist.int ident = a1;
    *(void *)&changelist.filter = 0x860000000001FFFBLL;
    changelist.int data = 0;
    changelist.uint data = 0;
    int v5 = kevent(v2, &changelist, 1, 0, 0, 0);
    if (v5)
    {
      int v6 = v5;
      if (DNBLogEnabled()) {
        _DNBLogError("Failed to register kqueue NOTE_EXIT event for pid %i, error: %d.", a1, v6);
      }
    }
    else if (!pthread_create(&v10, 0, (void *(__cdecl *)(void *))kqueue_thread, (void *)v3))
    {
      int ident = v10;
      return pthread_detach(ident);
    }
  }
  changelist.int ident = 0;
  uint64_t result = pthread_create((pthread_t *)&changelist, 0, (void *(__cdecl *)(void *))waitpid_thread, v4);
  if (result) {
    return result;
  }
  int ident = (_opaque_pthread_t *)changelist.ident;
  return pthread_detach(ident);
}

uint64_t AddProcessToMap(int a1, uint64_t *a2)
{
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr;
  if (!GetProcessMap(BOOL)::g_process_map_ptr)
  {
    pthread_mutex_lock(&GetProcessMap(BOOL)::g_process_map_mutex);
    if (!GetProcessMap(BOOL)::g_process_map_ptr) {
      operator new();
    }
    pthread_mutex_unlock(&GetProcessMap(BOOL)::g_process_map_mutex);
    uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr;
    if (!GetProcessMap(BOOL)::g_process_map_ptr) {
      return 0;
    }
  }
  uint64_t v6 = *a2;
  int v5 = (std::__shared_weak_count *)a2[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = (uint64_t **)(v4 + 8);
  uint64_t v7 = *(uint64_t **)(v4 + 8);
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        int v10 = *((_DWORD *)v7 + 8);
        if (v10 <= a1) {
          break;
        }
        uint64_t v7 = *v9;
        int v8 = v9;
        if (!*v9) {
          goto LABEL_14;
        }
      }
      if (v10 >= a1) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        int v8 = v9 + 1;
        goto LABEL_14;
      }
    }
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t **)(v4 + 8);
LABEL_14:
    uint64_t v11 = operator new(0x38uLL);
    v11[8] = a1;
    *((void *)v11 + 5) = v6;
    *((void *)v11 + 6) = v5;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    *int v8 = (uint64_t *)v11;
    uint64_t v12 = **(void **)v4;
    if (v12)
    {
      *(void *)uint64_t v4 = v12;
      BOOL v13 = *v8;
    }
    else
    {
      BOOL v13 = (uint64_t *)v11;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 8), v13);
    ++*(void *)(v4 + 16);
  }
  return 1;
}

uint64_t DNBProcessGetPIDByName(char *a1)
{
  memset(__p, 0, sizeof(__p));
  if (GetAllInfosMatchingName(a1, __p) == 1)
  {
    uint64_t v1 = *((unsigned int *)__p[0] + 10);
LABEL_4:
    operator delete(__p[0]);
    return v1;
  }
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  if (__p[0]) {
    goto LABEL_4;
  }
  return v2;
}

uint64_t GetAllInfosMatchingName(char *__s, void *a2)
{
  uint64_t v2 = (char *)*a2;
  a2[1] = *a2;
  if (__s)
  {
    int v3 = __s;
    uint64_t v4 = v2;
    if (*__s)
    {
      uint64_t v6 = strrchr(__s, 47);
      if (v6) {
        int v3 = v6 + 1;
      }
      size_t v7 = strlen(v3);
      std::string __p = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v8 = DNBGetAllInfos((char **)&__p);
      if (v8)
      {
        unint64_t v9 = v8;
        uint64_t v10 = 0;
        unsigned int v11 = 0;
        size_t v35 = v7;
        do
        {
          BOOL v13 = (char *)__p + 648 * v10;
          if (v13[36]) {
            BOOL v14 = v13[36] == 5;
          }
          else {
            BOOL v14 = 1;
          }
          if (v14 || strncasecmp(v3, v13 + 243, 0x10uLL)) {
            goto LABEL_10;
          }
          if (v7 < 0x11)
          {
            unint64_t v18 = (char *)a2[1];
            unint64_t v25 = a2[2];
            if ((unint64_t)v18 >= v25)
            {
              uint64_t v26 = (char *)*a2;
              uint64_t v27 = 0x2C3F35BA781948B1 * ((uint64_t)&v18[-*a2] >> 3);
              unint64_t v28 = v27 + 1;
              if ((unint64_t)(v27 + 1) > 0x6522C3F35BA781) {
LABEL_57:
              }
                abort();
              unint64_t v29 = 0x2C3F35BA781948B1 * ((uint64_t)(v25 - (void)v26) >> 3);
              if (2 * v29 > v28) {
                unint64_t v28 = 2 * v29;
              }
              if (v29 >= 0x329161F9ADD3C0) {
                unint64_t v23 = 0x6522C3F35BA781;
              }
              else {
                unint64_t v23 = v28;
              }
              if (v23)
              {
                if (v23 > 0x6522C3F35BA781) {
LABEL_58:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                uint64_t v30 = (char *)operator new(648 * v23);
              }
              else
              {
                uint64_t v30 = 0;
              }
              uint64_t v34 = v30;
              unint64_t v31 = &v30[648 * v27];
              memcpy(v31, v13, 0x288uLL);
              unint64_t v32 = v31;
              if (v18 != v26)
              {
                do
                {
                  v18 -= 648;
                  v32 -= 648;
                  memcpy(v32, v18, 0x288uLL);
                }
                while (v18 != v26);
LABEL_45:
                unint64_t v18 = (char *)*a2;
              }
LABEL_46:
              uint64_t v12 = v31 + 648;
              *a2 = v32;
              a2[1] = v31 + 648;
              a2[2] = &v34[648 * v23];
              if (v18) {
                operator delete(v18);
              }
              size_t v7 = v35;
              goto LABEL_9;
            }
          }
          else
          {
            if (proc_pidpath(*((_DWORD *)v13 + 10), buffer, 0x400u) < 1) {
              goto LABEL_10;
            }
            int v15 = strrchr(buffer, 47);
            int v16 = v15 ? v15 + 1 : buffer;
            if (strncasecmp(v3, v16, 0x400uLL)) {
              goto LABEL_10;
            }
            BOOL v13 = (char *)__p + 648 * v10;
            unint64_t v18 = (char *)a2[1];
            unint64_t v17 = a2[2];
            if ((unint64_t)v18 >= v17)
            {
              int v19 = (char *)*a2;
              uint64_t v20 = 0x2C3F35BA781948B1 * ((uint64_t)&v18[-*a2] >> 3);
              unint64_t v21 = v20 + 1;
              if ((unint64_t)(v20 + 1) > 0x6522C3F35BA781) {
                goto LABEL_57;
              }
              unint64_t v22 = 0x2C3F35BA781948B1 * ((uint64_t)(v17 - (void)v19) >> 3);
              if (2 * v22 > v21) {
                unint64_t v21 = 2 * v22;
              }
              if (v22 >= 0x329161F9ADD3C0) {
                unint64_t v23 = 0x6522C3F35BA781;
              }
              else {
                unint64_t v23 = v21;
              }
              if (v23)
              {
                if (v23 > 0x6522C3F35BA781) {
                  goto LABEL_58;
                }
                stat v24 = (char *)operator new(648 * v23);
              }
              else
              {
                stat v24 = 0;
              }
              uint64_t v34 = v24;
              unint64_t v31 = &v24[648 * v20];
              memcpy(v31, v13, 0x288uLL);
              unint64_t v32 = v31;
              if (v18 != v19)
              {
                do
                {
                  v18 -= 648;
                  v32 -= 648;
                  memcpy(v32, v18, 0x288uLL);
                }
                while (v18 != v19);
                goto LABEL_45;
              }
              goto LABEL_46;
            }
          }
          memcpy(v18, v13, 0x288uLL);
          uint64_t v12 = v18 + 648;
LABEL_9:
          a2[1] = v12;
LABEL_10:
          uint64_t v10 = ++v11;
        }
        while (v9 > v11);
      }
      if (__p)
      {
        uint64_t v37 = __p;
        operator delete(__p);
      }
      uint64_t v2 = (char *)*a2;
      uint64_t v4 = (char *)a2[1];
    }
  }
  else
  {
    uint64_t v4 = v2;
  }
  return 0x2C3F35BA781948B1 * ((v4 - v2) >> 3);
}

uint64_t DNBProcessAttachByName(char *__s, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5)
{
  if (a4 && a5) {
    *a4 = 0;
  }
  memset(__p, 0, sizeof(__p));
  uint64_t AllInfosMatchingName = GetAllInfosMatchingName(__s, __p);
  if (AllInfosMatchingName == 1)
  {
    BOOL v14 = __p[0];
    uint64_t v12 = DNBProcessAttach(*((_DWORD *)__p[0] + 10), a2, a3, a4, a5);
LABEL_11:
    operator delete(v14);
    return v12;
  }
  uint64_t v11 = AllInfosMatchingName;
  if (AllInfosMatchingName)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("error: %llu processes match '%s':\n", v11, __s);
    }
    int v15 = (char *)__p[0] + 243;
    do
    {
      if (DNBLogEnabled()) {
        _DNBLogError("%6u - %s\n", *(_DWORD *)(v15 - 203), v15);
      }
      v15 += 648;
      --v11;
    }
    while (v11);
  }
  else if (DNBLogEnabled())
  {
    _DNBLogError("error: no processes match '%s'\n", __s);
  }
  uint64_t v12 = 0;
  uint64_t result = 0;
  BOOL v14 = __p[0];
  if (__p[0]) {
    goto LABEL_11;
  }
  return result;
}

uint64_t DNBProcessAttach(int a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5)
{
  if (a4) {
    BOOL v6 = a5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    *a4 = 0;
  }
  if (!getenv("LLDB_DEBUGSERVER_PATH"))
  {
    *(void *)BOOL v13 = 0xE00000001;
    int v14 = 1;
    int v15 = a1;
    size_t v8 = 648;
    if (!sysctl(v13, 4u, &v11, &v8, 0, 0) && v8 && (v12 & 2) != 0)
    {
      if (communication_fd == -1)
      {
        fwrite("Trying to attach to a translated process with the native debugserver, exiting...\n", 0x51uLL, 1uLL, __stderrp);
        exit(1);
      }
      DNBProcessAttach(v10, communication_fd, v9, a1);
    }
  }
  v13[0] = 0;
  size_t v11 = 4;
  if (sysctlbyname("sysctl.proc_translated", v13, &v11, 0, 0) == -1 || v13[0] != 1) {
    operator new();
  }
  return 0xFFFFFFFFLL;
}

BOOL DNBDebugserverIsTranslated(void)
{
  int v3 = 0;
  size_t v2 = 4;
  return sysctlbyname("sysctl.proc_translated", &v3, &v2, 0, 0) != -1 && v3 == 1;
}

uint64_t DNBProcessWaitForEvents(int a1, unsigned int a2, int a3, timespec *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      size_t v8 = (uint64_t *)v4;
    }
    else {
      size_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0;
  }
  uint64_t v11 = *(void *)(v5 + 40);
  char v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v13 = (pthread_mutex_t *)(v11 + 1288);
  if (a3)
  {
    uint64_t v9 = PThreadEvent::WaitForSetEvents(v13, a2, a4);
    if (!v12) {
      return v9;
    }
  }
  else
  {
    uint64_t v9 = PThreadEvent::WaitForEventsToReset(v13, a2, a4);
    if (!v12) {
      return v9;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  return v9;
}

uint64_t DNBProcessGetState(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  size_t v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t State = MachProcess::GetState(v8);
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return State;
  }

  return MachProcess::GetState(v8);
}

const char *DNBStateAsString(unsigned int a1)
{
  if (a1 > 0xA) {
    return "nub_state_t ???";
  }
  else {
    return off_100068CB8[a1];
  }
}

void DNBProcessResetEvents(int a1, int a2)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < a1;
        if (v4 >= a1) {
          int v6 = (uint64_t *)v2;
        }
        else {
          int v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }
      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= a1)
      {
        uint64_t v7 = *(void *)(v3 + 40);
        size_t v8 = *(std::__shared_weak_count **)(v3 + 48);
        if (v8)
        {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          PThreadEvent::ResetEvents((pthread_mutex_t *)(v7 + 1288), a2);
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        else
        {
          PThreadEvent::ResetEvents((pthread_mutex_t *)(v7 + 1288), a2);
        }
      }
    }
  }
}

uint64_t DNBGetAllInfos(char **a1)
{
  int v11 = 0;
  size_t v9 = 0;
  *(void *)uint64_t v10 = 0xE00000001;
  if (sysctl(v10, 3u, 0, &v9, 0, 0) < 0)
  {
    a1[1] = *a1;
    perror("sysctl (mib, miblen, NULL, &num_processes, NULL, 0)");
    return 0;
  }
  else
  {
    uint64_t v2 = *a1;
    uint64_t v3 = a1[1];
    size_t v4 = 0x2C3F35BA781948B1 * ((v3 - *a1) >> 3);
    if (v9 / 0x288 <= v4)
    {
      if (v9 / 0x288 < v4)
      {
        uint64_t v3 = &v2[648 * (v9 / 0x288)];
        a1[1] = v3;
      }
    }
    else
    {
      std::vector<kinfo_proc>::__append(a1, v9 / 0x288 - v4);
      uint64_t v2 = *a1;
      uint64_t v3 = a1[1];
    }
    size_t v9 = v3 - v2;
    if (sysctl(v10, 3u, v2, &v9, 0, 0) < 0)
    {
      uint64_t result = 0;
      a1[1] = *a1;
    }
    else
    {
      BOOL v5 = *a1;
      int v6 = a1[1];
      size_t v7 = 0x2C3F35BA781948B1 * ((v6 - *a1) >> 3);
      if (v9 / 0x288 <= v7)
      {
        if (v9 / 0x288 < v7)
        {
          int v6 = &v5[648 * (v9 / 0x288)];
          a1[1] = v6;
        }
      }
      else
      {
        std::vector<kinfo_proc>::__append(a1, v9 / 0x288 - v7);
        BOOL v5 = *a1;
        int v6 = a1[1];
      }
      return 0x2C3F35BA781948B1 * ((v6 - v5) >> 3);
    }
  }
  return result;
}

uint64_t DNBGetDyldProcessState@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < (int)result;
        if (v4 >= (int)result) {
          int v6 = (uint64_t *)v2;
        }
        else {
          int v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }
      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= (int)result)
      {
        size_t v7 = *(MachProcess **)(v3 + 40);
        uint64_t v8 = *(void *)(v3 + 48);
        if (v8)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
          MachProcess::GetDyldProcessState(v7);
        }
        MachProcess::GetDyldProcessState(v7);
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t DNBProcessAttachWait(RNBContext *a1, char *a2, int a3, timespec *a4, useconds_t a5, char *a6, size_t a7, unsigned int (*a8)(void *), void *a9)
{
  *(_OWORD *)uint64_t v40 = 0u;
  long long v41 = 0u;
  memset(v39, 0, sizeof(v39));
  int v17 = *((_DWORD *)a1 + 76);
  CFStringRef v18 = MachProcess::PrepareForAttach(a2, v17, 1, (uint64_t)v40);
  if (LODWORD(v40[0]))
  {
    if (DNBLogEnabled())
    {
      int v19 = (const char *)DNBError::AsString((DNBError *)v40);
      _DNBLogError("Error in PrepareForAttach: %s", v19);
    }
    uint64_t v20 = 0;
    goto LABEL_51;
  }
  unint64_t v21 = (MachProcess *)v18;
  if (v18) {
    BOOL v22 = 1;
  }
  else {
    BOOL v22 = a3 == 0;
  }
  size_t v35 = a7;
  if (v22) {
    uint64_t AllInfosMatchingName = 0;
  }
  else {
    uint64_t AllInfosMatchingName = GetAllInfosMatchingName(a2, v39);
  }
  uint64_t v33 = a1;
  uint64_t v34 = a6;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("Waiting for '%s' to appear...\n", a2);
  }
  int v36 = (void *)v39[0];
  uint64_t v24 = v39[0] + 40;
  while (1)
  {
    if (v21)
    {
      unsigned int v25 = MachProcess::CheckForProcess((uint64_t)v21, v17);
      if (v25)
      {
        int v31 = v25;
LABEL_46:
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Attaching to %s with pid %i...\n", a2, v31);
        }
        usleep(a5);
        uint64_t v20 = DNBProcessAttach(v31, (uint64_t)a4, (uint64_t)v33 + 448, v34, v35);
        uint64_t v30 = v36;
        goto LABEL_49;
      }
    }
    else
    {
      __p.tv_sec = 0;
      *(void *)&__p.tv_usec = 0;
      uint64_t v38 = 0;
      uint64_t v26 = GetAllInfosMatchingName(a2, &__p);
      if (v26)
      {
        for (uint64_t i = 0; i != v26; ++i)
        {
          int v31 = *(_DWORD *)(__p.tv_sec + 648 * i + 40);
          unint64_t v28 = (_DWORD *)v24;
          uint64_t v29 = AllInfosMatchingName;
          if (AllInfosMatchingName)
          {
            while (v31 != *v28)
            {
              v28 += 162;
              if (!--v29) {
                goto LABEL_20;
              }
            }
          }
          else
          {
LABEL_20:
            if (v31) {
              goto LABEL_27;
            }
          }
        }
      }
      int v31 = 0;
LABEL_27:
      if (__p.tv_sec) {
        operator delete((void *)__p.tv_sec);
      }
      if (v31) {
        goto LABEL_46;
      }
    }
    if (a4)
    {
      gettimeofday(&__p, 0);
      if (__p.tv_sec > a4->tv_sec || __p.tv_sec >= a4->tv_sec && a4->tv_nsec < 1000 * __p.tv_usec) {
        break;
      }
    }
    if (a8 && a8(a9))
    {
      uint64_t v30 = v36;
      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded("DNBProcessAttachWait cancelled by should_cancel callback.");
      }
      uint64_t v20 = 0;
LABEL_49:
      MachProcess::CleanupAfterAttach(v21, v17, (DNBError *)(v20 != 0), (DNBError *)v40);
      if (!v30) {
        goto LABEL_51;
      }
      goto LABEL_50;
    }
    usleep(a5);
  }
  if (v34 && v35) {
    snprintf(v34, v35, "operation timed out");
  }
  uint64_t v30 = v36;
  if (DNBLogEnabled()) {
    _DNBLogError("error: waiting for process '%s' timed out.\n", a2);
  }
  uint64_t v20 = 0;
  if (v36) {
LABEL_50:
  }
    operator delete(v30);
LABEL_51:
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[1]);
  }
  return v20;
}

uint64_t DNBProcessDetach(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v1 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v1;
    }
    else {
      int v6 = (uint64_t *)(v1 + 8);
    }
    if (!v5) {
      uint64_t v3 = v1;
    }
    uint64_t v1 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(MachProcess **)(v3 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v3 + 48);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (DNBLogEnabled()) {
    _DNBLogThreaded("Disabling breakpoints and watchpoints, and detaching from %d.", a1);
  }
  MachProcess::DisableAllBreakpoints(v10, 1);
  MachProcess::DisableAllWatchpoints(v10, 1);
  uint64_t v7 = MachProcess::Detach(v10);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v7;
}

uint64_t DNBProcessKill(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (!v9) {
    return MachProcess::Kill(v8, 0);
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v6 = MachProcess::Kill(v8, 0);
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v6;
}

BOOL DNBProcessSignal(int a1, int a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::Signal(v9, a2, 0);
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v7 = MachProcess::Signal(v9, a2, 0);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

BOOL DNBProcessInterrupt(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (!v9) {
    return MachProcess::Interrupt(v8);
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v6 = MachProcess::Interrupt(v8);
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v6;
}

BOOL DNBProcessSendEvent(int a1, char *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)timeval __p = 0u;
  long long v12 = 0u;
  BOOL v7 = MachProcess::SendEvent(v9, a2, (DNBError *)__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[1]);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

BOOL DNBProcessGetExitStatus(int a1, int *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v2;
    }
    else {
      BOOL v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  int v11 = *(MachProcess **)(v4 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v4 + 48);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int State = MachProcess::GetState(v11);
  BOOL v8 = State == 9;
  if (a2 && State == 9) {
    *a2 = *((_DWORD *)v11 + 18);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v8;
}

void *DNBProcessGetExitInfo(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(void *)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = (void *)(v8 + 80);
  if (*(char *)(v8 + 103) < 0) {
    BOOL v6 = (void *)*v6;
  }
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v6;
}

uint64_t DNBThreadGetName(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t Name = MachProcess::ThreadGetName(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return Name;
  }

  return MachProcess::ThreadGetName(v9, a2);
}

BOOL DNBThreadGetIdentifierInfo(int a1, uint64_t a2, thread_identifier_info *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  int v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (!v11) {
    return MachThreadList::GetIdentifierInfo((MachThreadList *)(v10 + 968), a2, a3);
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL IdentifierInfo = MachThreadList::GetIdentifierInfo((MachThreadList *)(v10 + 968), a2, a3);
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return IdentifierInfo;
}

uint64_t DNBThreadGetState(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t State = MachProcess::ThreadGetState(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return State;
  }

  return MachProcess::ThreadGetState(v9, a2);
}

double DNBGetGenealogyInfoForThread@<D0>(BOOL *a1@<X2>, int a2@<W0>, unint64_t a3@<X1>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v5)
    {
      uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v7 = *(_DWORD *)(v5 + 32);
        BOOL v8 = v7 < a2;
        if (v7 >= a2) {
          size_t v9 = (uint64_t *)v5;
        }
        else {
          size_t v9 = (uint64_t *)(v5 + 8);
        }
        if (!v8) {
          uint64_t v6 = v5;
        }
        uint64_t v5 = *v9;
      }
      while (*v9);
      if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a2)
      {
        uint64_t v10 = *(MachProcess **)(v6 + 40);
        int v11 = *(std::__shared_weak_count **)(v6 + 48);
        if (v11)
        {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          MachProcess::GetGenealogyInfoForThread(v10, a1, a3, &v13);
          double result = *(double *)&v13;
          *(_OWORD *)a4 = v13;
          if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        else
        {
          MachProcess::GetGenealogyInfoForThread(v10, a1, a3, &v13);
          double result = *(double *)&v13;
          *(_OWORD *)a4 = v13;
        }
      }
    }
  }
  return result;
}

double DNBGetGenealogyImageInfo@<D0>(int a1@<W0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v4)
    {
      uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v6 = *(_DWORD *)(v4 + 32);
        BOOL v7 = v6 < a1;
        if (v6 >= a1) {
          BOOL v8 = (uint64_t *)v4;
        }
        else {
          BOOL v8 = (uint64_t *)(v4 + 8);
        }
        if (!v7) {
          uint64_t v5 = v4;
        }
        uint64_t v4 = *v8;
      }
      while (*v8);
      if (v5 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v5 + 32) <= a1)
      {
        size_t v9 = *(MachProcess **)(v5 + 40);
        uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (v10)
        {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          MachProcess::GetGenealogyImageInfo(v9, a2, &v12);
          double result = *(double *)&v12;
          *(_OWORD *)a3 = v12;
          if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
        else
        {
          MachProcess::GetGenealogyImageInfo(v9, a2, &v12);
          double result = *(double *)&v12;
          *(_OWORD *)a3 = v12;
        }
      }
    }
  }
  return result;
}

void DNBGetRequestedQoSForThread(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v5;
    }
    else {
      size_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a1)
  {
    uint64_t v10 = *(MachProcess **)(v6 + 40);
    int v11 = *(std::__shared_weak_count **)(v6 + 48);
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      MachProcess::GetRequestedQoS(v10, a2, a3, a4, a5);
      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    else
    {
      MachProcess::GetRequestedQoS(v10, a2, a3, a4, a5);
    }
  }
  else
  {
LABEL_12:
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    *(_DWORD *)(a5 + 48) = -1;
  }
}

uint64_t DNBGetPThreadT(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return -1;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return -1;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t PThreadT = MachProcess::GetPThreadT(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return PThreadT;
  }

  return MachProcess::GetPThreadT(v9, a2);
}

uint64_t DNBGetDispatchQueueT(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return -1;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return -1;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t DispatchQueueT = MachProcess::GetDispatchQueueT(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return DispatchQueueT;
  }

  return MachProcess::GetDispatchQueueT(v9, a2);
}

uint64_t DNBGetTSDAddressForThread(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    return -1;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v5;
    }
    else {
      size_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v6 + 32) > a1) {
    return -1;
  }
  long long v12 = *(MachProcess **)(v6 + 40);
  long long v13 = *(std::__shared_weak_count **)(v6 + 48);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t TSDAddressForThread = MachProcess::GetTSDAddressForThread(v12, a2, a3, a4, a5);
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    return TSDAddressForThread;
  }

  return MachProcess::GetTSDAddressForThread(v12, a2, a3, a4, a5);
}

uint64_t DNBGetAllLoadedLibrariesInfos@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v3)
    {
      int v5 = result;
      uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v7 = *(_DWORD *)(v3 + 32);
        BOOL v8 = v7 < (int)result;
        if (v7 >= (int)result) {
          size_t v9 = (uint64_t *)v3;
        }
        else {
          size_t v9 = (uint64_t *)(v3 + 8);
        }
        if (!v8) {
          uint64_t v6 = v3;
        }
        uint64_t v3 = *v9;
      }
      while (*v9);
      if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= (int)result)
      {
        uint64_t v10 = *(MachProcess **)(v6 + 40);
        uint64_t v11 = *(void *)(v6 + 48);
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          MachProcess::GetAllLoadedLibrariesInfos(v10, v5, a2);
        }
        MachProcess::GetAllLoadedLibrariesInfos(v10, v5, a2);
      }
    }
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t DNBGetLibrariesInfoForAddresses@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v3)
    {
      int v5 = result;
      uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v7 = *(_DWORD *)(v3 + 32);
        BOOL v8 = v7 < (int)result;
        if (v7 >= (int)result) {
          size_t v9 = (uint64_t *)v3;
        }
        else {
          size_t v9 = (uint64_t *)(v3 + 8);
        }
        if (!v8) {
          uint64_t v6 = v3;
        }
        uint64_t v3 = *v9;
      }
      while (*v9);
      if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= (int)result)
      {
        uint64_t v10 = *(void *)(v6 + 40);
        uint64_t v11 = *(void *)(v6 + 48);
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          MachProcess::GetLibrariesInfoForAddresses(v10, v5, a2);
        }
        MachProcess::GetLibrariesInfoForAddresses(v10, v5, a2);
      }
    }
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t DNBGetSharedCacheInfo@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < (int)result;
        if (v4 >= (int)result) {
          uint64_t v6 = (uint64_t *)v2;
        }
        else {
          uint64_t v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }
      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= (int)result)
      {
        int v7 = *(MachProcess **)(v3 + 40);
        uint64_t v8 = *(void *)(v3 + 48);
        if (v8)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
          MachProcess::GetSharedCacheInfo(v7);
        }
        MachProcess::GetSharedCacheInfo(v7);
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

BOOL DNBProcessResume(int a1, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s(pid = %4.4x)", "DNBProcessResume", a1);
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v6 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v8 = *(_DWORD *)(v6 + 32);
    BOOL v9 = v8 < a1;
    if (v8 >= a1) {
      uint64_t v10 = (uint64_t *)v6;
    }
    else {
      uint64_t v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v7 + 32) > a1) {
    return 0;
  }
  int v14 = *(MachProcess **)(v7 + 40);
  long long v13 = *(std::__shared_weak_count **)(v7 + 48);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)&v16, a2, a3);
  if (v16 == v17) {
    int v15 = 5;
  }
  else {
    int v15 = 4;
  }
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)&v16, v15, 0);
  BOOL v11 = MachProcess::Resume(v14, (char **)&v16);
  if (__p) {
    operator delete(__p);
  }
  if (v16)
  {
    int v17 = v16;
    operator delete(v16);
  }
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return v11;
}

BOOL DNBBreakpointSet(int a1, unint64_t a2, uint64_t a3, int a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      int v8 = (uint64_t *)v4;
    }
    else {
      int v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0;
  }
  BOOL v11 = *(uint64_t ***)(v5 + 40);
  long long v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v9 = MachProcess::CreateBreakpoint(v11, a2, a3, a4 != 0) != 0;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  return v9;
}

BOOL DNBBreakpointClear(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  BOOL v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::DisableBreakpoint(v9, a2, 1);
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v7 = MachProcess::DisableBreakpoint(v9, a2, 1);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

BOOL DNBWatchpointSet(int a1, unint64_t a2, uint64_t a3, int a4, int a5)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      BOOL v9 = (uint64_t *)v5;
    }
    else {
      BOOL v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v6 + 32) > a1) {
    return 0;
  }
  long long v12 = *(uint64_t ***)(v6 + 40);
  long long v13 = *(std::__shared_weak_count **)(v6 + 48);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v10 = MachProcess::CreateWatchpoint(v12, a2, a3, a4, a5 != 0) != 0;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return v10;
}

BOOL DNBWatchpointClear(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  BOOL v9 = *(MachProcess **)(v3 + 40);
  BOOL v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::DisableWatchpoint(v9, a2, 1);
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v7 = MachProcess::DisableWatchpoint(v9, a2, 1);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

uint64_t DNBWatchpointGetNumSupportedHWP(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  BOOL v8 = *(MachThread ****)(v2 + 40);
  BOOL v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t NumSupportedHardwareWatchpoints = MachProcess::GetNumSupportedHardwareWatchpoints(v8);
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return NumSupportedHardwareWatchpoints;
  }

  return MachProcess::GetNumSupportedHardwareWatchpoints(v8);
}

unint64_t DNBProcessMemoryRead(int a1, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0;
  }
  BOOL v11 = *(MachProcess **)(v5 + 40);
  long long v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t Memory = MachProcess::ReadMemory(v11, a2, a3, a4);
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    return Memory;
  }

  return MachProcess::ReadMemory(v11, a2, a3, a4);
}

uint64_t DNBProcessMemoryReadInteger(int a1, mach_vm_address_t a2, unint64_t a3, uint64_t a4)
{
  if (a3 <= 8 && DNBProcessMemoryRead(a1, a2, a3, (char *)&v7) == a3)
  {
    switch(a3)
    {
      case 1uLL:
        a4 = v7;
        break;
      case 2uLL:
        a4 = (unsigned __int16)v7;
        break;
      case 3uLL:
        a4 = v7 & 0xFFFFFF;
        break;
      case 4uLL:
      case 5uLL:
      case 6uLL:
      case 7uLL:
        a4 = v7;
        break;
      case 8uLL:
        a4 = v7;
        break;
      default:
        return a4;
    }
  }
  return a4;
}

uint64_t DNBProcessMemoryReadPointer(int a1, mach_vm_address_t a2)
{
  int CPUType = DNBProcessGetCPUType(a1);
  if (!CPUType) {
    return 0;
  }
  int v5 = CPUType;
  unint64_t v6 = (CPUType & 0x1000000) != 0 ? 8 : 4;
  if (DNBProcessMemoryRead(a1, a2, v6, (char *)&v8) != v6) {
    return 0;
  }
  if ((v5 & 0x1000000) != 0) {
    return v8;
  }
  return v8;
}

uint64_t DNBProcessGetCPUType(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  BOOL v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t CPUType = MachProcess::GetCPUType(v8);
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return CPUType;
  }

  return MachProcess::GetCPUType(v8);
}

uint64_t DNBProcessMemoryReadCString@<X0>(int a1@<W0>, mach_vm_address_t a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  __s[255] = 0;
  do
  {
    uint64_t result = DNBProcessMemoryRead(a1, a2, 0xFFuLL, __s);
    if (!result) {
      break;
    }
    size_t v7 = strlen(__s);
    uint64_t result = (uint64_t)std::string::append(a3, __s, v7);
    a2 += v7;
  }
  while (v7 == 255);
  return result;
}

std::string *DNBProcessMemoryReadCStringFixed@<X0>(std::string *a1@<X8>)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  int v2 = __chkstk_darwin();
  BOOL v4 = (char *)&v7 - ((v3 + 16) & 0xFFFFFFFFFFFFFFF0);
  v4[v3] = 0;
  uint64_t result = (std::string *)DNBProcessMemoryRead(v2, v5, v3, v4);
  if (result) {
    return std::string::assign(a1, v4);
  }
  return result;
}

unint64_t DNBProcessMemoryWrite(int a1, unint64_t a2, unint64_t a3, char *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0;
  }
  BOOL v11 = *(MachProcess **)(v5 + 40);
  long long v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v9 = MachProcess::WriteMemory(v11, a2, a3, a4);
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    return v9;
  }

  return MachProcess::WriteMemory(v11, a2, a3, a4);
}

mach_vm_address_t DNBProcessMemoryAllocate(int a1, mach_vm_size_t a2, unsigned int a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  BOOL v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    mach_vm_address_t Memory = MachTask::AllocateMemory((MachTask *)(v10 + 104), a2, a3);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    return Memory;
  }

  return MachTask::AllocateMemory((MachTask *)(v10 + 104), a2, a3);
}

BOOL DNBProcessMemoryDeallocate(int a1, mach_vm_address_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v7 = MachTask::DeallocateMemory((MachTask *)(v9 + 104), a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return v7;
  }

  return MachTask::DeallocateMemory((MachTask *)(v9 + 104), a2);
}

uint64_t DNBProcessMemoryRegionInfo(int a1, unint64_t a2, uint64_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  BOOL v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t MemoryRegionInfo = MachTask::GetMemoryRegionInfo(v10 + 104, a2, a3);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    return MemoryRegionInfo;
  }

  return MachTask::GetMemoryRegionInfo(v10 + 104, a2, a3);
}

void DNBProcessGetProfileData(int a1@<W0>, __int16 a2@<W1>, task_basic_info *a3@<X2>, uint64_t a4@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v5 + 32) <= a1)
  {
    uint64_t v9 = *(void *)(v5 + 40);
    uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      MachTask::GetProfileData(v9 + 104, a2, a3, (void **)a4);
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      MachTask::GetProfileData(v9 + 104, a2, a3, (void **)a4);
    }
  }
  else
  {
LABEL_12:
    *(unsigned char *)(a4 + 23) = 0;
    *(unsigned char *)a4 = 0;
  }
}

uint64_t DNBProcessSetEnableAsyncProfiling(int a1, int a2, int a3, int a4)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v4)
    {
      uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v6 = *(_DWORD *)(v4 + 32);
        BOOL v7 = v6 < a1;
        if (v6 >= a1) {
          uint64_t v8 = (uint64_t *)v4;
        }
        else {
          uint64_t v8 = (uint64_t *)(v4 + 8);
        }
        if (!v7) {
          uint64_t v5 = v4;
        }
        uint64_t v4 = *v8;
      }
      while (*v8);
      if (v5 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v5 + 32) <= a1)
      {
        BOOL v11 = *(pthread_mutex_t **)(v5 + 40);
        long long v12 = *(std::__shared_weak_count **)(v5 + 48);
        if (v12)
        {
          uint64_t v9 = 1;
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          MachProcess::SetEnableAsyncProfiling(v11, a2 != 0, a3, a4);
          if (atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            return v9;
          }
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        else
        {
          MachProcess::SetEnableAsyncProfiling(v11, a2 != 0, a3, a4);
        }
        return 1;
      }
    }
  }
  return 0;
}

uint64_t DNBProcessGetNumThreads(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t NumThreads = MachProcess::GetNumThreads(v8);
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return NumThreads;
  }

  return MachProcess::GetNumThreads(v8);
}

uint64_t DNBProcessGetCurrentThread(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t CurrentThread = MachProcess::GetCurrentThread(v8);
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return CurrentThread;
  }

  return MachProcess::GetCurrentThread(v8);
}

uint64_t DNBProcessSetCurrentThread(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = MachProcess::SetCurrentThread(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return v7;
  }

  return MachProcess::SetCurrentThread(v9, a2);
}

uint64_t DNBThreadGetStopReason(int a1, uint64_t a2, _DWORD *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  BOOL v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (!v11) {
    return MachProcess::GetThreadStoppedReason(v10, a2, a3);
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t ThreadStoppedReason = MachProcess::GetThreadStoppedReason(v10, a2, a3);
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return ThreadStoppedReason;
}

char *DNBThreadGetInfo(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    ThreadInfo = MachProcess::GetThreadInfo(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return ThreadInfo;
  }

  return MachProcess::GetThreadInfo(v9, a2);
}

uint64_t DNBProcessGetThreadAtIndex(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t ThreadAtIndex = MachProcess::GetThreadAtIndex(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return ThreadAtIndex;
  }

  return MachProcess::GetThreadAtIndex(v9, a2);
}

BOOL DNBProcessSyncThreadState(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v7 = MachProcess::SyncThreadState(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return v7;
  }

  return MachProcess::SyncThreadState(v9, a2);
}

uint64_t DNBProcessGetSharedLibraryInfoAddress(int a1)
{
  *(_OWORD *)timeval __p = 0u;
  long long v11 = 0u;
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return -1;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return -1;
  }
  uint64_t v8 = *(void *)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t DYLDAllImageInfosAddress = MachTask::GetDYLDAllImageInfosAddress((MachTask *)(v8 + 104), (DNBError *)__p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[1]);
  }
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return DYLDAllImageInfosAddress;
}

uint64_t DNBThreadGetRegisterValueByID(int a1, uint64_t a2, int a3, int a4, void *a5)
{
  bzero(a5, 0x88uLL);
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v7 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < a1;
    if (v9 >= a1) {
      long long v11 = (uint64_t *)v7;
    }
    else {
      long long v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if (v8 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v8 + 32) > a1) {
    return 0;
  }
  uint64_t v14 = *(void *)(v8 + 40);
  int v15 = *(std::__shared_weak_count **)(v8 + 48);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a2)
  {
    uint64_t RegisterValue = MachProcess::GetRegisterValue(v14, a2);
    if (!v15) {
      return RegisterValue;
    }
  }
  else
  {
    uint64_t RegisterValue = 0;
    if (!v15) {
      return RegisterValue;
    }
  }
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return RegisterValue;
}

uint64_t DNBThreadSetRegisterValueByID(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  BOOL v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::SetRegisterValue(v9, a2);
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v7 = MachProcess::SetRegisterValue(v9, a2);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

uint64_t DNBThreadGetRegisterContext(int a1, uint64_t a2, void *a3, size_t a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1)
  {
LABEL_12:
    uint64_t v9 = 0;
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(v5 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v5 + 48);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a2)
  {
LABEL_13:
    bzero(a3, a4);
    uint64_t RegisterContext = 0;
    if (!v9) {
      return RegisterContext;
    }
    goto LABEL_14;
  }
  uint64_t RegisterContext = MachThreadList::GetRegisterContext((MachThreadList *)(v12 + 968), a2, a3);
  if (!v9) {
    return RegisterContext;
  }
LABEL_14:
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return RegisterContext;
}

uint64_t DNBThreadSetRegisterContext(int a1, uint64_t a2, const void *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  long long v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a2)
  {
    uint64_t v8 = MachThreadList::SetRegisterContext((MachThreadList *)(v10 + 968), a2, a3);
    if (!v11) {
      return v8;
    }
  }
  else
  {
    uint64_t v8 = 0;
    if (!v11) {
      return v8;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return v8;
}

uint64_t DNBThreadSaveRegisterState(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = MachThreadList::SaveRegisterState((MachThreadList *)(v9 + 968), a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return v7;
  }

  return MachThreadList::SaveRegisterState((MachThreadList *)(v9 + 968), a2);
}

uint64_t DNBThreadRestoreRegisterState(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachThreadList::RestoreRegisterState((MachThreadList *)(v9 + 968), a2);
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v7 = MachThreadList::RestoreRegisterState((MachThreadList *)(v9 + 968), a2);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  return v7;
}

size_t DNBProcessGetAvailableSTDOUT(int a1, char *a2, size_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(MachProcess **)(v4 + 40);
  long long v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    size_t AvailableSTDOUT = MachProcess::GetAvailableSTDOUT(v10, a2, a3);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    return AvailableSTDOUT;
  }

  return MachProcess::GetAvailableSTDOUT(v10, a2, a3);
}

uint64_t DNBProcessGetAvailableSTDERR(int a1, char *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t AvailableSTDERR = MachProcess::GetAvailableSTDERR(v9, a2);
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return AvailableSTDERR;
  }

  return MachProcess::GetAvailableSTDERR(v9, a2);
}

size_t DNBProcessGetAvailableProfileData(int a1, char *a2, size_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0;
  }
  uint64_t v10 = *(MachProcess **)(v4 + 40);
  long long v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    size_t AsyncProfileData = MachProcess::GetAsyncProfileData(v10, a2, a3);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    return AsyncProfileData;
  }

  return MachProcess::GetAsyncProfileData(v10, a2, a3);
}

uint64_t DNBProcessGetStopCount(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v2 + 32) <= a1)
  {
    uint64_t v8 = *(void *)(v2 + 40);
    uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      unsigned int v6 = *(_DWORD *)(v8 + 444);
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      return *(unsigned int *)(v8 + 444);
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

BOOL DNBResolveExecutablePath(const char *a1, char *a2, size_t a3)
{
  if (!a1 || !*a1) {
    return 0;
  }
  memset(&v20, 0, sizeof(v20));
  CFString::GlobPath(a1, (uint64_t)&v20);
  std::string::size_type size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v20.__r_.__value_.__l.__size_;
  }
  if (!size) {
    std::string::assign(&v20, a1);
  }
  if (stat(a1, &v19) || (v19.st_mode & 0xF000) != 0x4000) {
    goto LABEL_19;
  }
  CFBundle::CFBundle((CFBundle *)__source, a1);
  uint64_t v7 = CFBundle::CopyExecutableURL((CFBundle *)__source);
  *(void *)&v18.st_dev = off_100068CA8;
  v18.st_ino = (__darwin_ino64_t)v7;
  if (!v7)
  {
LABEL_18:
    CFBundle::~CFBundle((CFBundle *)__source);
LABEL_19:
    if (realpath_DARWIN_EXTSN(a1, __source))
    {
      strlcpy(a2, __source, a3);
      size_t v9 = strlen(a2) + 1;
LABEL_21:
      BOOL v8 = v9 < a3;
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_22;
      }
    }
    else
    {
      long long v11 = getenv("PATH");
      if (v11)
      {
        uint64_t v12 = v11;
        while (*v12)
        {
          long long v13 = strchr(v12, 58);
          if (v13)
          {
            uint64_t v14 = v13;
            if (v13 <= v12) {
              break;
            }
            std::string::assign(&v20, v12, v13 - v12);
            uint64_t v12 = v14 + 1;
          }
          else
          {
            std::string::assign(&v20, v12);
            uint64_t v12 = 0;
          }
          std::string::push_back(&v20, 47);
          std::string::append(&v20, a1);
          if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v15 = &v20;
          }
          else {
            int v15 = (std::string *)v20.__r_.__value_.__r.__words[0];
          }
          if (!stat((const char *)v15, &v18))
          {
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v16 = &v20;
            }
            else {
              int v16 = (std::string *)v20.__r_.__value_.__r.__words[0];
            }
            strlcpy(a2, (const char *)v16, a3);
            std::string::size_type v17 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v17 = v20.__r_.__value_.__l.__size_;
            }
            size_t v9 = v17 + 1;
            goto LABEL_21;
          }
          if (!v12) {
            break;
          }
        }
      }
      BOOL v8 = 0;
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_22;
      }
    }
    return v8;
  }
  if (!CFURLGetFileSystemRepresentation(v7, 1u, (UInt8 *)a2, a3))
  {
    *(void *)&v18.st_dev = off_100068CA8;
    if (v18.st_ino) {
      CFRelease((CFTypeRef)v18.st_ino);
    }
    goto LABEL_18;
  }
  *(void *)&v18.st_dev = off_100068CA8;
  if (v18.st_ino) {
    CFRelease((CFTypeRef)v18.st_ino);
  }
  CFBundle::~CFBundle((CFBundle *)__source);
  BOOL v8 = 1;
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
LABEL_22:
  }
    operator delete(v20.__r_.__value_.__l.__data_);
  return v8;
}

void *CFReleaser<__CFURL const*>::~CFReleaser(void *a1)
{
  *a1 = off_100068CA8;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

double DNBInitialize(void)
{
  BOOL v0 = DNBLogEnabledForAny(2);
  if (v0) {
    _DNBLogThreaded("DNBInitialize ()");
  }

  return DNBArchMachARM64::Initialize((DNBArchMachARM64 *)v0);
}

const char *DNBSetArchitecture(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*result) {
      return 0;
    }
    if (!strcasecmp(result, "i386"))
    {
      uint64_t v2 = 7;
      int v3 = 0;
    }
    else if (!strcasecmp(v1, "x86_64"))
    {
      uint64_t v2 = 16777223;
      int v3 = 3;
    }
    else if (!strcasecmp(v1, "x86_64h"))
    {
      uint64_t v2 = 16777223;
      int v3 = 8;
    }
    else if (!strncmp(v1, "arm64_32", 8uLL) || !strncmp(v1, "aarch64_32", 0xAuLL))
    {
      uint64_t v2 = 33554444;
      int v3 = 0;
    }
    else if (!strncmp(v1, "arm64e", 6uLL))
    {
      uint64_t v2 = 16777228;
      int v3 = 2;
    }
    else if (!strncmp(v1, "arm64", 5uLL) || !strncmp(v1, "aarch64", 7uLL))
    {
      uint64_t v2 = 16777228;
      int v3 = 0;
    }
    else if (!strncmp(v1, "armv8", 5uLL))
    {
      uint64_t v2 = 16777228;
      int v3 = 1;
    }
    else if (!strncmp(v1, "armv7em", 7uLL))
    {
      uint64_t v2 = 12;
      int v3 = 16;
    }
    else if (!strncmp(v1, "armv7m", 6uLL))
    {
      uint64_t v2 = 12;
      int v3 = 15;
    }
    else if (!strncmp(v1, "armv7k", 6uLL))
    {
      uint64_t v2 = 12;
      int v3 = 12;
    }
    else if (!strncmp(v1, "armv7s", 6uLL))
    {
      uint64_t v2 = 12;
      int v3 = 11;
    }
    else if (!strncmp(v1, "armv7", 5uLL))
    {
      uint64_t v2 = 12;
      int v3 = 9;
    }
    else if (!strncmp(v1, "armv6m", 6uLL))
    {
      uint64_t v2 = 12;
      int v3 = 14;
    }
    else if (!strncmp(v1, "armv6", 5uLL))
    {
      uint64_t v2 = 12;
      int v3 = 6;
    }
    else if (!strncmp(v1, "armv5", 5uLL))
    {
      uint64_t v2 = 12;
      int v3 = 7;
    }
    else if (!strncmp(v1, "armv4t", 6uLL))
    {
      uint64_t v2 = 12;
      int v3 = 5;
    }
    else
    {
      if (strncmp(v1, "arm", 3uLL)) {
        return 0;
      }
      uint64_t v2 = 12;
      int v3 = 0;
    }
    return (const char *)DNBArchProtocol::SetArchitecture((DNBArchProtocol *)v2, v3);
  }
  return result;
}

BOOL DNBGetAddressingBits(unsigned int *a1)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&DNBGetAddressingBits(unsigned int &)::g_once_flag, memory_order_acquire) != -1)
  {
    unsigned int v6 = &v4;
    int v5 = &v6;
    std::__call_once(&DNBGetAddressingBits(unsigned int &)::g_once_flag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<DNBGetAddressingBits(unsigned int &)::$_0 &&>>);
  }
  int v2 = DNBGetAddressingBits(unsigned int &)::g_addressing_bits;
  *a1 = DNBGetAddressingBits(unsigned int &)::g_addressing_bits;
  return v2 != 0;
}

uint64_t waitpid_thread(void *a1)
{
  pid_t v1 = (int)a1;
  int v13 = 0;
  pthread_setname_np("waitpid thread");
  int v11 = 0;
  int v2 = pthread_self();
  if (!pthread_getschedparam(v2, &v11, &v12))
  {
    v12.sched_priority = 47;
    int v3 = pthread_self();
    pthread_setschedparam(v3, v11, &v12);
  }
  do
  {
    while (1)
    {
      pid_t v4 = waitpid(v1, &v13, 0);
      if (DNBLogEnabledForAny(2))
      {
        int v5 = v13;
        unsigned int v6 = __error();
        _DNBLogThreaded("waitpid_thread (): waitpid (pid = %i, &status, 0) => %i, status = %i, errno = %i", v1, v4, v5, *v6);
      }
      if (v4 < 0) {
        break;
      }
      if ((~v13 & 0x7F) != 0 || (v13 & 0xFFFFFF00) == 4864)
      {
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("waitpid_thread (): setting exit status for pid = %i to %i", v4, v13);
        }
        int v8 = v13;
        int v9 = v4;
        goto LABEL_19;
      }
    }
  }
  while (*__error() == 4);
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("waitpid_thread (): main loop exited, setting exit status to an invalid value (-1) for pid %i", v1);
  }
  int v9 = v1;
  int v8 = -1;
LABEL_19:
  DNBProcessSetExitStatus(v9, v8);
  return 0;
}

void std::__shared_ptr_pointer<MachProcess *,std::shared_ptr<MachProcess>::__shared_ptr_default_delete<MachProcess,MachProcess>,std::allocator<MachProcess>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

MachProcess *std::__shared_ptr_pointer<MachProcess *,std::shared_ptr<MachProcess>::__shared_ptr_default_delete<MachProcess,MachProcess>,std::allocator<MachProcess>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(MachProcess **)(a1 + 24);
  if (result)
  {
    MachProcess::~MachProcess(result);
    operator delete();
  }
  return result;
}

void std::vector<kinfo_proc>::__append(char **a1, unint64_t a2)
{
  int v5 = a1[1];
  pid_t v4 = a1[2];
  if (0x2C3F35BA781948B1 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 648 * ((648 * a2 - 648) / 0x288) + 648;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    unsigned int v6 = *a1;
    uint64_t v7 = 0x2C3F35BA781948B1 * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x6522C3F35BA781) {
      abort();
    }
    unint64_t v9 = 0x2C3F35BA781948B1 * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x329161F9ADD3C0) {
      unint64_t v10 = 0x6522C3F35BA781;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x6522C3F35BA781) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v11 = (char *)operator new(648 * v10);
    }
    else
    {
      int v11 = 0;
    }
    int v13 = &v11[648 * v7];
    uint64_t v14 = &v11[648 * v10];
    size_t v15 = 648 * ((648 * a2 - 648) / 0x288) + 648;
    bzero(v13, v15);
    int v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        v5 -= 648;
        v13 -= 648;
        memcpy(v13, v5, 0x288uLL);
      }
      while (v5 != v6);
      int v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void CFReleaser<__CFURL const*>::~CFReleaser(void *a1)
{
  *a1 = off_100068CA8;
  int v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

uint64_t std::__call_once_proxy[abi:nn180100]<std::tuple<DNBGetAddressingBits(unsigned int &)::$_0 &&>>()
{
  size_t v1 = 4;
  uint64_t result = sysctlbyname("machdep.virtual_address_size", &DNBGetAddressingBits(unsigned int &)::g_addressing_bits, &v1, 0, 0);
  if (result) {
    DNBGetAddressingBits(unsigned int &)::g_addressing_bits = 0;
  }
  return result;
}

void DNBDataRef::DNBDataRef(DNBDataRef *this, const unsigned __int8 *a2, uint64_t a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = &a2[a3];
  *((unsigned char *)this + 16) = a4;
  *((unsigned char *)this + 17) = 0;
  *((void *)this + 3) = -1;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
}

uint64_t DNBDataRef::Get32(DNBDataRef *this, unsigned int *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *((void *)this + 1) - *(void *)this;
  BOOL v4 = v3 >= v2;
  unint64_t v5 = v3 - v2;
  if (!v4) {
    unint64_t v5 = 0;
  }
  if (v5 < 4) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(*(void *)this + v2);
  unsigned int v7 = bswap32(v6);
  if (*((unsigned char *)this + 16)) {
    uint64_t result = v7;
  }
  else {
    uint64_t result = v6;
  }
  *a2 = v2 + 4;
  return result;
}

unint64_t DNBDataRef::GetMax64(DNBDataRef *this, unsigned int *a2, int a3)
{
  switch(a3)
  {
    case 1:
      unint64_t v3 = *a2;
      if (*((void *)this + 1) - *(void *)this <= v3) {
        return 0;
      }
      unint64_t v4 = *(unsigned __int8 *)(*(void *)this + v3);
      unsigned int v5 = v3 + 1;
LABEL_17:
      *a2 = v5;
      return v4;
    case 2:
      unint64_t v4 = 0;
      unint64_t v15 = *a2;
      unint64_t v16 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v16 >= v15;
      unint64_t v17 = v16 - v15;
      if (!v8) {
        unint64_t v17 = 0;
      }
      if (v17 >= 2)
      {
        LODWORD(v4) = *(unsigned __int16 *)(*(void *)this + v15);
        unsigned int v18 = bswap32(v4) >> 16;
        if (*((unsigned char *)this + 16)) {
          LOWORD(v4) = v18;
        }
        *a2 = v15 + 2;
        return (unsigned __int16)v4;
      }
      return v4;
    case 4:
      unint64_t v4 = 0;
      unint64_t v6 = *a2;
      unint64_t v7 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v7 >= v6;
      unint64_t v9 = v7 - v6;
      if (!v8) {
        unint64_t v9 = 0;
      }
      if (v9 < 4) {
        return v4;
      }
      LODWORD(v4) = *(_DWORD *)(*(void *)this + v6);
      unsigned int v10 = bswap32(v4);
      if (*((unsigned char *)this + 16)) {
        unint64_t v4 = v10;
      }
      else {
        unint64_t v4 = v4;
      }
      unsigned int v5 = v6 + 4;
      goto LABEL_17;
    case 8:
      unint64_t v4 = 0;
      unint64_t v11 = *a2;
      unint64_t v12 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v12 >= v11;
      unint64_t v13 = v12 - v11;
      if (!v8) {
        unint64_t v13 = 0;
      }
      if (v13 < 8) {
        return v4;
      }
      unint64_t v4 = *(void *)(*(void *)this + v11);
      unint64_t v14 = bswap64(v4);
      if (*((unsigned char *)this + 16)) {
        unint64_t v4 = v14;
      }
      unsigned int v5 = v11 + 8;
      goto LABEL_17;
    default:
      DNBDataRef::GetMax64();
  }
}

uint64_t DNBDataRef::GetCStr(DNBDataRef *this, unsigned int *a2, int a3)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)this >= *((void *)this + 1)) {
    return 0;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = v3 + v5;
  if (a3) {
    unsigned int v7 = v5 + a3;
  }
  else {
    unsigned int v7 = v5 + strlen((const char *)(v3 + v5)) + 1;
  }
  *a2 = v7;
  return v6;
}

uint64_t DNBDataRef::Dump(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int a6, const char *a7)
{
  int v7 = a2;
  __str[0] = 0;
  unsigned int v91 = a2;
  if (a2 >= a3) {
    return a2;
  }
  unint64_t v9 = a2;
  if (a1[1] - *a1 <= (unint64_t)a2) {
    return a2;
  }
  unsigned int v13 = 0;
  unint64_t v14 = 0;
  if (a7) {
    unint64_t v15 = a7;
  }
  else {
    unint64_t v15 = " %lld";
  }
  unint64_t v16 = " 0x%llx";
  if (a7) {
    unint64_t v16 = a7;
  }
  v89 = v16;
  unint64_t v17 = " %16.16llx";
  if (a7) {
    unint64_t v17 = a7;
  }
  __format = (char *)v17;
  uint64_t v87 = v15;
  if (a7) {
    unsigned int v18 = a7;
  }
  else {
    unsigned int v18 = " %8.8x";
  }
  stat v19 = " %4.4x";
  if (a7) {
    stat v19 = a7;
  }
  uint64_t v84 = v19;
  uint64_t v85 = v18;
  if (a7) {
    std::string v20 = a7;
  }
  else {
    std::string v20 = " %c";
  }
  unint64_t v21 = " %2.2x";
  if (a7) {
    unint64_t v21 = a7;
  }
  uint64_t v82 = v21;
  uint64_t v83 = (char *)v20;
  LODWORD(v22) = a2;
  int v88 = a2;
  do
  {
    if (v13 % a6)
    {
      if (v14 >= 0x400) {
        goto LABEL_30;
      }
    }
    else
    {
      if (__str[0] && DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"%s", v31, v32, v33, v34, v35, v36, (uint64_t)__str);
      }
      unint64_t v14 = snprintf(__str, 0x400uLL, "0x%8.8llx:", (v22 - v7) + a4);
      if (v14 >= 0x400)
      {
LABEL_30:
        if (DNBLogEnabled()) {
          _DNBLog(0, (uint64_t)"%s", v25, v26, v27, v28, v29, v30, (uint64_t)__str);
        }
        unint64_t v14 = 0;
        __str[0] = 0;
        if (a5 > 7) {
          goto LABEL_23;
        }
      }
    }
    switch(a5)
    {
      case 0u:
        if (a1[1] - *a1 <= v9)
        {
          uint64_t v37 = 0;
        }
        else
        {
          uint64_t v37 = *(unsigned __int8 *)(*a1 + v9);
          unsigned int v91 = v22 + 1;
        }
        int v23 = snprintf(&__str[v14], 1024 - v14, v82, v37);
        goto LABEL_22;
      case 1u:
        if (a1[1] - *a1 <= v9)
        {
          unsigned int v38 = 0;
          unint64_t v39 = &__str[v14];
          size_t v40 = 1024 - v14;
        }
        else
        {
          unsigned int v38 = *(char *)(*a1 + v9);
          unsigned int v91 = v22 + 1;
          unint64_t v39 = &__str[v14];
          size_t v40 = 1024 - v14;
          if ((v38 & 0x80000000) != 0)
          {
            __uint32_t v41 = __maskrune(v38, 0x40000uLL);
            goto LABEL_80;
          }
        }
        __uint32_t v41 = _DefaultRuneLocale.__runetype[v38] & 0x40000;
LABEL_80:
        if (v41) {
          uint64_t v70 = v38;
        }
        else {
          uint64_t v70 = 32;
        }
        v14 += snprintf(v39, v40, v83, v70);
        int v7 = v88;
        goto LABEL_23;
      case 2u:
        unint64_t v42 = a1[1] - *a1;
        BOOL v43 = v42 >= v9;
        unint64_t v44 = v42 - v9;
        if (!v43) {
          unint64_t v44 = 0;
        }
        if (v44 < 2)
        {
          LOWORD(v45) = 0;
        }
        else
        {
          unsigned int v45 = *(unsigned __int16 *)(*a1 + v9);
          unsigned int v46 = bswap32(v45) >> 16;
          if (*((unsigned char *)a1 + 16)) {
            LOWORD(v45) = v46;
          }
          unsigned int v91 = v22 + 2;
        }
        int v23 = snprintf(&__str[v14], 1024 - v14, v84, (unsigned __int16)v45);
        goto LABEL_22;
      case 3u:
        unint64_t v47 = a1[1] - *a1;
        BOOL v43 = v47 >= v9;
        unint64_t v48 = v47 - v9;
        if (!v43) {
          unint64_t v48 = 0;
        }
        if (v48 < 4)
        {
          uint64_t v49 = 0;
        }
        else
        {
          LODWORD(v49) = *(_DWORD *)(*a1 + v9);
          unsigned int v50 = bswap32(v49);
          if (*((unsigned char *)a1 + 16)) {
            uint64_t v49 = v50;
          }
          else {
            uint64_t v49 = v49;
          }
          unsigned int v91 = v22 + 4;
        }
        int v23 = snprintf(&__str[v14], 1024 - v14, v85, v49);
        goto LABEL_22;
      case 4u:
        unint64_t v51 = 0;
        unint64_t v52 = a1[1] - *a1;
        BOOL v43 = v52 >= v9;
        unint64_t v53 = v52 - v9;
        if (!v43) {
          unint64_t v53 = 0;
        }
        if (v53 >= 8)
        {
          unint64_t v51 = *(void *)(*a1 + v9);
          unint64_t v54 = bswap64(v51);
          if (*((unsigned char *)a1 + 16)) {
            unint64_t v51 = v54;
          }
          unsigned int v91 = v22 + 8;
        }
        int v23 = snprintf(&__str[v14], 1024 - v14, __format, v51);
        goto LABEL_22;
      case 5u:
        if (!*((unsigned char *)a1 + 17)) {
          DNBDataRef::Dump();
        }
        unint64_t Max64 = DNBDataRef::GetMax64((DNBDataRef *)a1, &v91, *((unsigned __int8 *)a1 + 17));
        int v7 = v88;
        int v23 = snprintf(&__str[v14], 1024 - v14, v89, Max64);
        goto LABEL_22;
      case 6u:
        unint64_t v55 = a1[1];
        if (*a1 >= v55)
        {
          uint64_t v58 = 0;
        }
        else
        {
          uint64_t v56 = 0;
          uint64_t v57 = 0;
          uint64_t v58 = 0;
          unint64_t v59 = *a1 + v9;
          do
          {
            if (v59 + v56 >= v55) {
              break;
            }
            char v60 = *(unsigned char *)(v59 + v56);
            v58 |= (unint64_t)(v60 & 0x7F) << v57;
            v57 += 7;
            ++v56;
          }
          while (v60 < 0);
          unsigned int v91 = v56 + v22;
        }
        int v23 = snprintf(&__str[v14], 1024 - v14, v89, v58);
        goto LABEL_22;
      case 7u:
        uint64_t v61 = *a1;
        unint64_t v62 = a1[1];
        if (*a1 >= v62)
        {
          uint64_t v71 = 0;
          goto LABEL_99;
        }
        uint64_t v63 = v61 + v9;
        if (v61 + v9 >= v62)
        {
          uint64_t v66 = 0;
          int v68 = 0;
          int v67 = 0;
          BOOL v72 = 1;
          goto LABEL_94;
        }
        uint64_t v64 = 0;
        int v65 = 0;
        uint64_t v66 = 0;
        int v67 = v62 - (v22 + v61);
        int v68 = 7 * v67;
        break;
      default:
        goto LABEL_23;
    }
    while (1)
    {
      char v69 = *(unsigned char *)(v63 + v64);
      v66 |= (unint64_t)(v69 & 0x7F) << v65;
      if ((v69 & 0x80) == 0) {
        break;
      }
      ++v64;
      v65 += 7;
      if (v63 + v64 >= v62) {
        goto LABEL_93;
      }
    }
    int v68 = v65 + 7;
    int v67 = v64 + 1;
LABEL_93:
    BOOL v72 = (v69 & 0x40) == 0;
LABEL_94:
    if (v68 > 31) {
      BOOL v72 = 1;
    }
    uint64_t v73 = -1 << v68;
    if (v72) {
      uint64_t v73 = 0;
    }
    uint64_t v71 = v73 | v66;
    unsigned int v91 = v67 + v22;
LABEL_99:
    int v23 = snprintf(&__str[v14], 1024 - v14, v87, v71);
LABEL_22:
    v14 += v23;
LABEL_23:
    ++v13;
    uint64_t v22 = v91;
    BOOL v24 = v91 < a3 && a1[1] - *a1 > (unint64_t)v91;
    unint64_t v9 = v91;
  }
  while (v24);
  if (__str[0] && DNBLogEnabled()) {
    _DNBLog(0, (uint64_t)"%s", v74, v75, v76, v77, v78, v79, (uint64_t)__str);
  }
  return v22;
}

uint64_t DNBError::AsString(DNBError *this)
{
  mach_error_t v2 = *(_DWORD *)this;
  if (!v2) {
    return 0;
  }
  if (*((char *)this + 31) < 0)
  {
    if (*((void *)this + 2)) {
      goto LABEL_13;
    }
  }
  else if (*((unsigned char *)this + 31))
  {
    goto LABEL_13;
  }
  uint64_t v3 = "Should have set BackBoard error when making the error string.";
  switch(*((_DWORD *)this + 1))
  {
    case 1:
      unint64_t v4 = mach_error_string(v2);
      goto LABEL_9;
    case 2:
      unint64_t v4 = strerror(v2);
LABEL_9:
      uint64_t v3 = v4;
      if (!v4) {
        break;
      }
      goto LABEL_12;
    case 4:
      goto LABEL_12;
    case 5:
      uint64_t v3 = "Should have set FrontBoard error when making the error string.";
LABEL_12:
      std::string::assign((std::string *)((char *)this + 8), v3);
      break;
    default:
      break;
  }
LABEL_13:
  if (*((char *)this + 31) < 0)
  {
    if (*((void *)this + 2)) {
      return *((void *)this + 1);
    }
    return 0;
  }
  if (*((unsigned char *)this + 31)) {
    return (uint64_t)this + 8;
  }
  else {
    return 0;
  }
}

void DNBError::LogThreadedIfError(DNBError *this, const char *a2, ...)
{
  va_start(va, a2);
  if (*(_DWORD *)this)
  {
    uint64_t v5 = 0;
    vasprintf(&v5, a2, va);
    if (v5)
    {
      uint64_t v3 = DNBError::AsString(this);
      if (DNBLogEnabled())
      {
        unint64_t v4 = "???";
        if (v3) {
          unint64_t v4 = (const char *)v3;
        }
        _DNBLogThreaded("error: %s err = %s (0x%8.8x)", v5, v4, *(_DWORD *)this);
      }
      free(v5);
    }
  }
}

void DNBError::LogThreaded(DNBError *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v3 = 0;
  vasprintf(&v3, a2, va);
  if (v3)
  {
    if (*(_DWORD *)this)
    {
      DNBError::AsString(this);
      if (DNBLogEnabled()) {
        _DNBLogThreaded("error: %s err = %s (0x%8.8x)");
      }
    }
    else if (DNBLogEnabled())
    {
      _DNBLogThreaded("%s err = 0x%8.8x");
    }
    free(v3);
  }
}

uint64_t DNBLogSetDebug(uint64_t result)
{
  g_debug = result;
  return result;
}

uint64_t DNBLogSetVerbose(uint64_t result)
{
  g_verbose = result;
  return result;
}

BOOL DNBLogCheckLogBit(int a1)
{
  return (g_log_bits & a1) != 0;
}

uint64_t DNBLogSetLogMask(int a1)
{
  uint64_t v1 = g_log_bits;
  g_log_bits = a1;
  return v1;
}

void *DNBLogSetLogCallback(void *result, uint64_t a2)
{
  g_log_callback = result;
  g_log_baton = a2;
  return result;
}

void *DNBLogGetLogCallback()
{
  return g_log_callback;
}

BOOL DNBLogEnabled()
{
  return g_log_callback != 0;
}

BOOL DNBLogEnabledForAny(int a1)
{
  return (g_log_bits & a1) != 0 && g_log_callback != 0;
}

uint64_t _DNBLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  {
    PThreadMutex::PThreadMutex((PThreadMutex *)&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex, 2);
    __cxa_atexit((void (*)(void *))PThreadMutex::~PThreadMutex, &_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex, (void *)&_mh_execute_header);
  }
  pthread_mutex_lock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
  if (g_log_callback) {
    g_log_callback(g_log_baton, a1, a2, &a9);
  }
  return pthread_mutex_unlock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
}

uint64_t _DNBLogDebug(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v9 = off_100079000;
  if (g_log_callback) {
    BOOL v10 = g_debug == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t v11 = result;
    {
      PThreadMutex::PThreadMutex((PThreadMutex *)&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex, 2);
      unint64_t v9 = off_100079000;
      __cxa_atexit((void (*)(void *))PThreadMutex::~PThreadMutex, &_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex, (void *)&_mh_execute_header);
    }
    pthread_mutex_lock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
    unint64_t v12 = v9[228];
    if (v12) {
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t *))v12)(g_log_baton, 8, v11, &a9);
    }
    return pthread_mutex_unlock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
  }
  return result;
}

void _DNBLogThreaded(char *a1, ...)
{
  va_start(va, a1);
  if (g_log_callback)
  {
    BOOL v10 = 0;
    vasprintf(&v10, a1, va);
    if (v10)
    {
      gettimeofday((timeval *)&_DNBLogThreaded::tv, 0);
      int v1 = _DNBLogThreaded::g_timeval;
      if ((void)_DNBLogThreaded::g_timeval)
      {
        _DNBLogThreaded::delta = _DNBLogThreaded::tv - _DNBLogThreaded::g_timeval;
        _DNBLogThreaded::delta = DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval);
        if (DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval) >= 0)
        {
LABEL_8:
          _DNBLogThreaded::g_timeval = _DNBLogThreaded::tv;
          mach_port_name_t v2 = mach_thread_self();
          uint64_t v3 = ++g_message_id;
          getpid();
          _DNBLog(32, (uint64_t)"%u +%lu.%06u sec [%4.4x/%4.4x]: %s", v4, v5, v6, v7, v8, v9, v3);
          mach_port_deallocate(mach_task_self_, v2);
          free(v10);
          return;
        }
        _DNBLogThreaded::delta = _DNBLogThreaded::tv - _DNBLogThreaded::g_timeval - 1;
        int v1 = DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval) + 1000000;
      }
      else
      {
        _DNBLogThreaded::delta = 0;
      }
      _DNBLogThreaded::delta = v1;
      goto LABEL_8;
    }
  }
}

void _DNBLogError(char *a1, ...)
{
  va_start(va, a1);
  if (g_log_callback)
  {
    uint64_t v7 = 0;
    vasprintf(&v7, a1, va);
    if (v7)
    {
      _DNBLog(2, (uint64_t)"error: %s", v1, v2, v3, v4, v5, v6, (uint64_t)v7);
      free(v7);
    }
  }
}

void _DNBLogWarning(char *a1, ...)
{
  va_start(va, a1);
  if (g_log_callback)
  {
    uint64_t v7 = 0;
    vasprintf(&v7, a1, va);
    if (v7)
    {
      _DNBLog(4, (uint64_t)"warning: %s", v1, v2, v3, v4, v5, v6, (uint64_t)v7);
      free(v7);
    }
  }
}

void PThreadMutex::~PThreadMutex(pthread_mutex_t *this)
{
  if (pthread_mutex_destroy(this))
  {
    if (!pthread_mutex_unlock(this)) {
      pthread_mutex_destroy(this);
    }
  }
}

void PThreadMutex::PThreadMutex(PThreadMutex *this, int a2)
{
  if (pthread_mutexattr_init(&v4)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutexattr_settype(&v4, a2)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutex_init((pthread_mutex_t *)this, &v4)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutexattr_destroy(&v4)) {
    PThreadMutex::PThreadMutex();
  }
}

void DNBThreadResumeActions::DNBThreadResumeActions(DNBThreadResumeActions *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

void std::vector<BOOL>::assign(char **a1, unint64_t a2, unsigned __int8 *a3)
{
  a1[1] = 0;
  if (a2)
  {
    uint64_t v6 = a1[2];
    unint64_t v7 = (void)v6 << 6;
    if ((void)v6 << 6 >= a2)
    {
      a1[1] = (char *)a2;
    }
    else
    {
      unsigned int v18 = 0;
      long long v19 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0) {
        abort();
      }
      unint64_t v8 = (void)v6 << 7;
      if (v8 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
        unint64_t v8 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      }
      if (v7 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)&v18, v9);
      uint64_t v11 = v18;
      unint64_t v12 = (char *)*((void *)&v19 + 1);
      unsigned int v18 = *a1;
      BOOL v10 = v18;
      long long v13 = *(_OWORD *)(a1 + 1);
      *a1 = v11;
      a1[1] = (char *)a2;
      a1[2] = v12;
      long long v19 = v13;
      if (v10) {
        operator delete(v10);
      }
    }
    unint64_t v14 = *a1;
    int v15 = *a3;
    unint64_t v16 = a2 >> 6;
    if (v15)
    {
      size_t v17 = 8 * v16;
      if (a2 >= 0x40) {
        memset(v14, 255, v17);
      }
      if ((a2 & 0x3F) != 0) {
        *(void *)&v14[v17] |= 0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F);
      }
    }
    else
    {
      if (a2 >= 0x40) {
        bzero(v14, 8 * v16);
      }
      if ((a2 & 0x3F) != 0) {
        *(void *)&v14[8 * v16] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F));
      }
    }
  }
}

uint64_t DNBThreadResumeActions::DNBThreadResumeActions(uint64_t a1, char *a2, size_t __sz)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (a2 && __sz)
  {
    std::vector<DNBThreadResumeAction>::__assign_with_size[abi:nn180100]<DNBThreadResumeAction const*,DNBThreadResumeAction const*>((void *)a1, a2, &a2[24 * __sz], __sz);
    unsigned __int8 v6 = 0;
    std::vector<BOOL>::assign((char **)(a1 + 24), __sz, &v6);
  }
  return a1;
}

uint64_t DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(char **a1, int a2, int a3)
{
  unint64_t v7 = *a1;
  unsigned __int8 v6 = a1[1];
  unint64_t v8 = (v6 - *a1) / 24;
  if (v6 == *a1)
  {
LABEL_8:
    unint64_t v12 = (unint64_t)a1[2];
    if ((unint64_t)v6 >= v12)
    {
      unint64_t v14 = v8 + 1;
      if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_35;
      }
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)v7) >> 3);
      if (2 * v15 > v14) {
        unint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x555555555555555) {
        unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v16 = v14;
      }
      if (v16)
      {
        if (v16 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        size_t v17 = (char *)operator new(24 * v16);
      }
      else
      {
        size_t v17 = 0;
      }
      long long v19 = &v17[24 * v8];
      *(void *)long long v19 = 0;
      *((_DWORD *)v19 + 2) = a2;
      *((_DWORD *)v19 + 3) = a3;
      *((void *)v19 + 2) = -1;
      long long v13 = v19 + 24;
      if (v6 != v7)
      {
        do
        {
          long long v20 = *(_OWORD *)(v6 - 24);
          *((void *)v19 - 1) = *((void *)v6 - 1);
          *(_OWORD *)(v19 - 24) = v20;
          v19 -= 24;
          v6 -= 24;
        }
        while (v6 != v7);
        unsigned __int8 v6 = *a1;
      }
      *a1 = v19;
      a1[1] = v13;
      a1[2] = &v17[24 * v16];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *(void *)unsigned __int8 v6 = 0;
      *((_DWORD *)v6 + 2) = a2;
      *((_DWORD *)v6 + 3) = a3;
      *((void *)v6 + 2) = -1;
      long long v13 = v6 + 24;
    }
    a1[1] = v13;
    unint64_t v21 = (unint64_t)a1[4];
    uint64_t v22 = a1[5];
    if (v21 != (void)v22 << 6)
    {
LABEL_34:
      a1[4] = (char *)(v21 + 1);
      uint64_t result = 1;
      *(void *)&a1[3][(v21 >> 3) & 0x1FFFFFFFFFFFFFF8] &= ~(1 << v21);
      return result;
    }
    if ((uint64_t)(v21 + 1) >= 0)
    {
      unint64_t v23 = (void)v22 << 7;
      if (v23 <= (v21 & 0xFFFFFFFFFFFFFFC0) + 64) {
        unint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFC0) + 64;
      }
      if (v21 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v24 = v23;
      }
      else {
        unint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)(a1 + 3), v24);
      unint64_t v21 = (unint64_t)a1[4];
      goto LABEL_34;
    }
LABEL_35:
    abort();
  }
  if (v8 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = (v6 - *a1) / 24;
  }
  BOOL v10 = *a1;
  while (1)
  {
    uint64_t v11 = *(void *)v10;
    v10 += 24;
    if (!v11) {
      return 0;
    }
    if (!--v9) {
      goto LABEL_8;
    }
  }
}

uint64_t DNBThreadResumeActions::DNBThreadResumeActions(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)a1, a2, a3);
  return a1;
}

void DNBThreadResumeActions::Append(char **a1, long long *a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v8 = *a1;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_27;
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (void)v8) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v13 = (char *)operator new(24 * v12);
    }
    else
    {
      long long v13 = 0;
    }
    unint64_t v14 = &v13[24 * v9];
    *(_OWORD *)unint64_t v14 = *a2;
    *((void *)v14 + 2) = *((void *)a2 + 2);
    unint64_t v7 = v14 + 24;
    if (v5 != v8)
    {
      do
      {
        long long v15 = *(_OWORD *)(v5 - 24);
        *((void *)v14 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v14 - 24) = v15;
        v14 -= 24;
        v5 -= 24;
      }
      while (v5 != v8);
      uint64_t v5 = *a1;
    }
    *a1 = v14;
    a1[1] = v7;
    a1[2] = &v13[24 * v12];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    long long v6 = *a2;
    *((void *)v5 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
    unint64_t v7 = v5 + 24;
  }
  a1[1] = v7;
  unint64_t v16 = (unint64_t)a1[4];
  size_t v17 = a1[5];
  if (v16 != (void)v17 << 6) {
    goto LABEL_26;
  }
  if ((uint64_t)(v16 + 1) < 0) {
LABEL_27:
  }
    abort();
  unint64_t v18 = (void)v17 << 7;
  if (v18 <= (v16 & 0xFFFFFFFFFFFFFFC0) + 64) {
    unint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFC0) + 64;
  }
  if (v16 <= 0x3FFFFFFFFFFFFFFELL) {
    unint64_t v19 = v18;
  }
  else {
    unint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
  }
  std::vector<BOOL>::reserve((uint64_t)(a1 + 3), v19);
  unint64_t v16 = (unint64_t)a1[4];
LABEL_26:
  a1[4] = (char *)(v16 + 1);
  *(void *)&a1[3][(v16 >> 3) & 0x1FFFFFFFFFFFFFF8] &= ~(1 << v16);
}

void DNBThreadResumeActions::AppendAction(char **a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  *(void *)&long long v5 = a2;
  *((void *)&v5 + 1) = __PAIR64__(a4, a3);
  uint64_t v6 = a5;
  DNBThreadResumeActions::Append(a1, &v5);
}

void *DNBThreadResumeActions::GetActionForThread(DNBThreadResumeActions *this, uint64_t a2, int a3)
{
  uint64_t v3 = *(void **)this;
  unint64_t v4 = (void *)*((void *)this + 1);
  unint64_t v5 = ((uint64_t)v4 - *(void *)this) / 24;
  if (v4 == *(void **)this)
  {
LABEL_8:
    uint64_t result = 0;
    if (a2 && a3 && v4 != v3)
    {
      if (v5 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v5;
      }
      while (*v3)
      {
        v3 += 3;
        if (!--v8) {
          return 0;
        }
      }
      return v3;
    }
  }
  else
  {
    if (v5 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = ((uint64_t)v4 - *(void *)this) / 24;
    }
    uint64_t result = *(void **)this;
    while (*result != a2)
    {
      result += 3;
      if (!--v6) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t DNBThreadResumeActions::NumActionsWithState(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1] - *a1;
  if (!v3) {
    return 0;
  }
  unint64_t v4 = v3 / 24;
  if (v4 <= 1) {
    unint64_t v4 = 1;
  }
  if (v4 < 2)
  {
    unint64_t v5 = 0;
    uint64_t result = 0;
LABEL_14:
    unint64_t v14 = v4 - v5;
    long long v15 = (int *)(v2 + 24 * v5 + 8);
    do
    {
      int v16 = *v15;
      v15 += 6;
      if (v16 == a2) {
        ++result;
      }
      --v14;
    }
    while (v14);
    return result;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v9 = (int *)(v2 + 32);
  unint64_t v10 = v4 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    int v11 = *(v9 - 6);
    int v13 = *v9;
    v9 += 12;
    int v12 = v13;
    if (v11 == a2) {
      ++v7;
    }
    if (v12 == a2) {
      ++v8;
    }
    v10 -= 2;
  }
  while (v10);
  uint64_t result = v8 + v7;
  if (v4 != v5) {
    goto LABEL_14;
  }
  return result;
}

uint64_t DNBThreadResumeActions::SetSignalHandledForThread(uint64_t this, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t **)this;
    uint64_t v3 = *(void *)(this + 8);
    uint64_t v4 = v3 - *(void *)this;
    if (v3 != *(void *)this)
    {
      unint64_t v5 = 0;
      unint64_t v6 = v4 / 24;
      if (v6 <= 1) {
        unint64_t v6 = 1;
      }
      do
      {
        uint64_t v7 = *v2;
        v2 += 3;
        if (v7 == a2) {
          *(void *)(*(void *)(this + 24) + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v5;
        }
        ++v5;
      }
      while (v6 != v5);
    }
  }
  return this;
}

void *std::vector<DNBThreadResumeAction>::__assign_with_size[abi:nn180100]<DNBThreadResumeAction const*,DNBThreadResumeAction const*>(void *result, char *__src, char *a3, size_t __sz)
{
  unint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *result) >> 3) < __sz)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_23;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= __sz) {
      uint64_t v11 = __sz;
    }
    unint64_t v12 = v10 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_23:
    }
      abort();
    uint64_t v13 = 3 * v12;
    uint64_t result = operator new(24 * v12);
    unint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    long long v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  long long v15 = (void **)(result + 1);
  int v16 = (unsigned char *)result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 3) >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    unint64_t v18 = (void *)*result;
LABEL_21:
    uint64_t result = memmove(v18, __src, v14);
    goto LABEL_22;
  }
  size_t v17 = &__src[8 * ((v16 - v9) >> 3)];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    unint64_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v17;
  if (v14)
  {
    unint64_t v18 = v9;
    __src = v17;
    goto LABEL_21;
  }
LABEL_22:
  int *v15 = &v9[v14];
  return result;
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2 > *(void *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v3 = ((a2 - 1) >> 6) + 1;
    uint64_t v4 = (uint64_t *)operator new(8 * v3);
    unint64_t v5 = *(void **)a1;
    unint64_t v6 = *(void *)(a1 + 8);
    int v7 = v6 & 0x3F;
    unint64_t v8 = (v6 - 1) >> 6;
    if (v6 < 0x41) {
      unint64_t v8 = 0;
    }
    v4[v8] = 0;
    if (v6 > 0x3F || (v6 & 0x3F) != 0)
    {
      int v9 = 0;
      int v10 = 0;
      uint64_t v11 = &v5[v6 >> 6];
      unint64_t v12 = v4;
      uint64_t v13 = v5;
      do
      {
        uint64_t v14 = 1 << v9;
        if ((*v13 >> v10)) {
          uint64_t v15 = *v12 | v14;
        }
        else {
          uint64_t v15 = *v12 & ~v14;
        }
        uint64_t *v12 = v15;
        v13 += v10 == 63;
        if (v10 == 63) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        v12 += v9 == 63;
        if (v9 == 63) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
      }
      while (v10 != v7 || v13 != v11);
    }
    *(void *)a1 = v4;
    *(void *)(a1 + 16) = v3;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void StdStringExtractor::StdStringExtractor(StdStringExtractor *this, const char *a2)
{
  *(void *)this = off_100068D20;
  *(_OWORD *)((char *)this + 8) = 0u;
  unint64_t v3 = (std::string *)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  if (a2) {
    std::string::assign(v3, a2);
  }
}

void StdStringExtractor::~StdStringExtractor(void **this)
{
  *this = off_100068D20;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = off_100068D20;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  operator delete();
}

uint64_t StdStringExtractor::GetChar(StdStringExtractor *this, char a2)
{
  unint64_t v2 = *((void *)this + 4);
  unint64_t v3 = *((unsigned __int8 *)this + 31);
  if (*((char *)this + 31) < 0)
  {
    if (v2 < *((void *)this + 2)) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v5 = -1;
    goto LABEL_8;
  }
  if (v2 >= v3) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v4 = (void *)((char *)this + 8);
  if ((v3 & 0x80) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  a2 = *((unsigned char *)v4 + v2);
  uint64_t v5 = v2 + 1;
LABEL_8:
  *((void *)this + 4) = v5;
  return a2;
}

uint64_t StdStringExtractor::DecodeHexU8(StdStringExtractor *this)
{
  int v2 = *((char *)this + 31);
  if (v2 < 0) {
    unint64_t v3 = *((void *)this + 2);
  }
  else {
    unint64_t v3 = *((unsigned __int8 *)this + 31);
  }
  uint64_t v4 = (char *)this + 8;
  unint64_t v5 = *((void *)this + 4);
  if (v5 < v3)
  {
    while (1)
    {
      if (*((char *)this + 31) < 0)
      {
        __darwin_ct_rune_t v7 = *(char *)(*(void *)v4 + v5);
        if (v7 < 0)
        {
LABEL_6:
          int v6 = __maskrune(v7, 0x4000uLL);
          unint64_t v5 = *((void *)this + 4);
          if (!v6) {
            goto LABEL_13;
          }
          goto LABEL_7;
        }
      }
      else
      {
        __darwin_ct_rune_t v7 = v4[v5];
        if (v7 < 0) {
          goto LABEL_6;
        }
      }
      if ((_DefaultRuneLocale.__runetype[v7] & 0x4000) == 0)
      {
LABEL_13:
        LOBYTE(v2) = *((unsigned char *)this + 31);
        break;
      }
LABEL_7:
      *((void *)this + 4) = ++v5;
      if (v5 >= v3) {
        goto LABEL_13;
      }
    }
  }
  if ((v2 & 0x80) != 0)
  {
    unint64_t v8 = *((void *)this + 2);
    if (v5 >= v8) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    unint64_t v8 = v2;
    if (v5 >= v2) {
      return 0xFFFFFFFFLL;
    }
  }
  if (v8 - v5 < 2) {
    return 0xFFFFFFFFLL;
  }
  int v10 = (char *)this + 8;
  if ((v2 & 0x80) != 0) {
    int v10 = *(char **)v4;
  }
  int v11 = v10[v5];
  unsigned int v12 = v11 - 97;
  int v13 = v11 - 48;
  if ((v11 - 48) >= 0xA) {
    int v13 = -1;
  }
  if ((v11 - 65) <= 5) {
    int v14 = v11 - 55;
  }
  else {
    int v14 = v13;
  }
  int v15 = v11 - 87;
  if (v12 > 5) {
    int v15 = v14;
  }
  if ((v2 & 0x80) != 0) {
    uint64_t v4 = *(char **)v4;
  }
  int v16 = v4[v5 + 1];
  unsigned int v17 = v16 - 97;
  int v18 = v16 - 48;
  if ((v16 - 48) >= 0xA) {
    int v18 = -1;
  }
  if ((v16 - 65) <= 5) {
    int v19 = v16 - 55;
  }
  else {
    int v19 = v18;
  }
  int v20 = v16 - 87;
  if (v17 > 5) {
    int v20 = v19;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (v15 != -1 && v20 != -1)
  {
    *((void *)this + 4) = v5 + 2;
    return (v20 + 16 * v15);
  }
  return result;
}

unint64_t StdStringExtractor::GetU32(StdStringExtractor *this, uint64_t a2, int a3)
{
  unint64_t v5 = *((void *)this + 4);
  int v6 = (char *)this + 8;
  if (*((char *)this + 31) < 0)
  {
    if (v5 >= *((void *)this + 2)) {
      return a2;
    }
    __endptr = 0;
    int v6 = *(const char **)v6;
  }
  else
  {
    if (v5 >= *((unsigned __int8 *)this + 31)) {
      return a2;
    }
    __endptr = 0;
  }
  __darwin_ct_rune_t v7 = (char *)&v6[v5];
  unint64_t v8 = strtoul(&v6[v5], &__endptr, a3);
  if (__endptr && __endptr != v7)
  {
    *((void *)this + 4) = __endptr - v6;
    return v8;
  }
  return a2;
}

uint64_t StdStringExtractor::GetHexMaxU32(StdStringExtractor *this, char a2, uint64_t a3)
{
  if (*((char *)this + 31) < 0) {
    unint64_t v6 = *((void *)this + 2);
  }
  else {
    unint64_t v6 = *((unsigned __int8 *)this + 31);
  }
  __darwin_ct_rune_t v7 = (char **)((char *)this + 8);
  for (unint64_t i = *((void *)this + 4); i < v6; *((void *)this + 4) = i)
  {
    if (*((char *)this + 31) < 0)
    {
      __darwin_ct_rune_t v9 = (*v7)[i];
      if (v9 < 0)
      {
LABEL_6:
        if (!__maskrune(v9, 0x4000uLL)) {
          break;
        }
        goto LABEL_7;
      }
    }
    else
    {
      __darwin_ct_rune_t v9 = *((char *)v7 + i);
      if (v9 < 0) {
        goto LABEL_6;
      }
    }
    if ((_DefaultRuneLocale.__runetype[v9] & 0x4000) == 0) {
      break;
    }
LABEL_7:
    unint64_t i = *((void *)this + 4) + 1;
  }
  unint64_t v10 = *((unsigned __int8 *)this + 31);
  unint64_t v11 = *((void *)this + 4);
  if (a2)
  {
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    char v14 = 0;
    while (1)
    {
      unint64_t v18 = v10;
      if ((v10 & 0x80) != 0) {
        unint64_t v18 = *((void *)this + 2);
      }
      if (v11 >= v18) {
        return v12;
      }
      int v19 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        int v19 = *v7;
      }
      int v20 = v19[v11];
      if (v20 < 0 || (_DefaultRuneLocale.__runetype[v20] & 0x10000) == 0) {
        return v12;
      }
      if (v13 > 7) {
        goto LABEL_74;
      }
      unint64_t v21 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        unint64_t v21 = *v7;
      }
      int v22 = v21[v11];
      unsigned int v23 = v22 - 97;
      char v24 = v22 - 48;
      if ((v22 - 48) >= 0xA) {
        char v24 = -1;
      }
      if ((v22 - 65) <= 5) {
        char v25 = v22 - 55;
      }
      else {
        char v25 = v24;
      }
      unsigned __int8 v26 = v22 - 87;
      if (v23 <= 5) {
        unsigned __int8 v27 = v26;
      }
      else {
        unsigned __int8 v27 = v25;
      }
      unint64_t v28 = v11 + 1;
      *((void *)this + 4) = v11 + 1;
      if ((v10 & 0x80) != 0)
      {
        if (v28 >= *((void *)this + 2)) {
          goto LABEL_15;
        }
      }
      else if (v28 >= v10)
      {
        goto LABEL_15;
      }
      if ((v10 & 0x80) != 0)
      {
        int v29 = (*v7)[v28];
        if (v29 < 0) {
          goto LABEL_15;
        }
      }
      else
      {
        int v29 = *((char *)v7 + v28);
        if (v29 < 0) {
          goto LABEL_15;
        }
      }
      if ((_DefaultRuneLocale.__runetype[v29] & 0x10000) == 0)
      {
LABEL_15:
        int v15 = v27 << v14;
        char v16 = 4;
        int v17 = 1;
        goto LABEL_16;
      }
      uint64_t v30 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        uint64_t v30 = *v7;
      }
      int v31 = v30[v28];
      if ((v31 - 97) > 5)
      {
        unsigned int v33 = v31 - 65;
        char v34 = v31 - 48;
        if ((v31 - 48) >= 0xA) {
          char v34 = -1;
        }
        unsigned __int8 v35 = v31 - 55;
        if (v33 <= 5) {
          unsigned __int8 v32 = v35;
        }
        else {
          unsigned __int8 v32 = v34;
        }
      }
      else
      {
        unsigned __int8 v32 = v31 - 87;
      }
      unint64_t v28 = v11 + 2;
      *((void *)this + 4) = v11 + 2;
      int v15 = (v27 << (v14 + 4)) | (v32 << v14);
      char v16 = 8;
      int v17 = 2;
LABEL_16:
      v13 += v17;
      v14 += v16;
      uint64_t v12 = v15 | v12;
      unint64_t v11 = v28;
    }
  }
  uint64_t v36 = 0;
  uint64_t v12 = 0;
  while (1)
  {
    unint64_t v42 = v10;
    if ((v10 & 0x80) != 0) {
      unint64_t v42 = *((void *)this + 2);
    }
    if (v11 + v36 >= v42) {
      return v12;
    }
    BOOL v43 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      BOOL v43 = *v7;
    }
    int v44 = v43[v11 + v36];
    if (v44 < 0 || (_DefaultRuneLocale.__runetype[v44] & 0x10000) == 0) {
      return v12;
    }
    if (v36 == 8) {
      break;
    }
    unsigned int v45 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      unsigned int v45 = *v7;
    }
    int v37 = v45[v11 + v36];
    unsigned int v38 = v37 - 97;
    char v39 = v37 - 48;
    if ((v37 - 48) >= 0xA) {
      char v39 = -1;
    }
    if ((v37 - 65) <= 5) {
      char v40 = v37 - 55;
    }
    else {
      char v40 = v39;
    }
    unsigned __int8 v41 = v37 - 87;
    if (v38 > 5) {
      unsigned __int8 v41 = v40;
    }
    uint64_t v12 = v41 | (16 * v12);
    *((void *)this + 4) = v11 + v36++ + 1;
  }
LABEL_74:
  *((void *)this + 4) = -1;
  return a3;
}

unint64_t StdStringExtractor::GetHexMaxU64(StdStringExtractor *this, char a2, uint64_t a3)
{
  if (*((char *)this + 31) < 0) {
    unint64_t v6 = *((void *)this + 2);
  }
  else {
    unint64_t v6 = *((unsigned __int8 *)this + 31);
  }
  __darwin_ct_rune_t v7 = (char **)((char *)this + 8);
  for (unint64_t i = *((void *)this + 4); i < v6; *((void *)this + 4) = i)
  {
    if (*((char *)this + 31) < 0)
    {
      __darwin_ct_rune_t v9 = (*v7)[i];
      if (v9 < 0)
      {
LABEL_6:
        if (!__maskrune(v9, 0x4000uLL)) {
          break;
        }
        goto LABEL_7;
      }
    }
    else
    {
      __darwin_ct_rune_t v9 = *((char *)v7 + i);
      if (v9 < 0) {
        goto LABEL_6;
      }
    }
    if ((_DefaultRuneLocale.__runetype[v9] & 0x4000) == 0) {
      break;
    }
LABEL_7:
    unint64_t i = *((void *)this + 4) + 1;
  }
  unint64_t v10 = *((unsigned __int8 *)this + 31);
  unint64_t v11 = *((void *)this + 4);
  if (a2)
  {
    unint64_t v12 = 0;
    unsigned int v13 = 0;
    char v14 = 0;
    while (1)
    {
      unint64_t v18 = v10;
      if ((v10 & 0x80) != 0) {
        unint64_t v18 = *((void *)this + 2);
      }
      if (v11 >= v18) {
        return v12;
      }
      int v19 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        int v19 = *v7;
      }
      int v20 = v19[v11];
      if (v20 < 0 || (_DefaultRuneLocale.__runetype[v20] & 0x10000) == 0) {
        return v12;
      }
      if (v13 > 0xF) {
        goto LABEL_75;
      }
      unint64_t v21 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        unint64_t v21 = *v7;
      }
      int v22 = v21[v11];
      unsigned int v23 = v22 - 97;
      char v24 = v22 - 48;
      if ((v22 - 48) >= 0xA) {
        char v24 = -1;
      }
      if ((v22 - 65) <= 5) {
        char v25 = v22 - 55;
      }
      else {
        char v25 = v24;
      }
      unsigned __int8 v26 = v22 - 87;
      if (v23 <= 5) {
        unsigned __int8 v27 = v26;
      }
      else {
        unsigned __int8 v27 = v25;
      }
      unint64_t v28 = v11 + 1;
      *((void *)this + 4) = v11 + 1;
      if ((v10 & 0x80) != 0)
      {
        if (v28 >= *((void *)this + 2)) {
          goto LABEL_15;
        }
      }
      else if (v28 >= v10)
      {
        goto LABEL_15;
      }
      if ((v10 & 0x80) != 0)
      {
        int v29 = (*v7)[v28];
        if (v29 < 0) {
          goto LABEL_15;
        }
      }
      else
      {
        int v29 = *((char *)v7 + v28);
        if (v29 < 0) {
          goto LABEL_15;
        }
      }
      if ((_DefaultRuneLocale.__runetype[v29] & 0x10000) == 0)
      {
LABEL_15:
        unint64_t v15 = (unint64_t)v27 << v14;
        char v16 = 4;
        int v17 = 1;
        goto LABEL_16;
      }
      uint64_t v30 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        uint64_t v30 = *v7;
      }
      int v31 = v30[v28];
      unsigned int v32 = v31 - 97;
      char v33 = v31 - 48;
      if ((v31 - 48) >= 0xA) {
        char v33 = -1;
      }
      if ((v31 - 65) <= 5) {
        char v34 = v31 - 55;
      }
      else {
        char v34 = v33;
      }
      unsigned __int8 v35 = v31 - 87;
      if (v32 <= 5) {
        unsigned __int8 v36 = v35;
      }
      else {
        unsigned __int8 v36 = v34;
      }
      unint64_t v28 = v11 + 2;
      *((void *)this + 4) = v11 + 2;
      unint64_t v15 = ((unint64_t)v27 << (v14 + 4)) | ((unint64_t)v36 << v14);
      char v16 = 8;
      int v17 = 2;
LABEL_16:
      v13 += v17;
      v14 += v16;
      v12 |= v15;
      unint64_t v11 = v28;
    }
  }
  uint64_t v37 = 0;
  unint64_t v12 = 0;
  while (1)
  {
    unint64_t v43 = v10;
    if ((v10 & 0x80) != 0) {
      unint64_t v43 = *((void *)this + 2);
    }
    if (v11 + v37 >= v43) {
      return v12;
    }
    int v44 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      int v44 = *v7;
    }
    int v45 = v44[v11 + v37];
    if (v45 < 0 || (_DefaultRuneLocale.__runetype[v45] & 0x10000) == 0) {
      return v12;
    }
    if (v37 == 16) {
      break;
    }
    unsigned int v46 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      unsigned int v46 = *v7;
    }
    int v38 = v46[v11 + v37];
    unsigned int v39 = v38 - 97;
    char v40 = v38 - 48;
    if ((v38 - 48) >= 0xA) {
      char v40 = -1;
    }
    if ((v38 - 65) <= 5) {
      char v41 = v38 - 55;
    }
    else {
      char v41 = v40;
    }
    unsigned __int8 v42 = v38 - 87;
    if (v39 > 5) {
      unsigned __int8 v42 = v41;
    }
    unint64_t v12 = v42 | (16 * v12);
    *((void *)this + 4) = v11 + v37++ + 1;
  }
LABEL_75:
  *((void *)this + 4) = -1;
  return a3;
}

unint64_t StdStringExtractor::GetHexBytes(StdStringExtractor *this, unsigned char *a2, unint64_t a3, int __c)
{
  if (a3)
  {
    unint64_t v8 = 0;
    unint64_t v9 = *((void *)this + 4);
    while (1)
    {
      if (*((char *)this + 31) < 0)
      {
        unint64_t v10 = *((void *)this + 2);
        if (v9 >= v10) {
          break;
        }
      }
      else
      {
        unint64_t v10 = *((unsigned __int8 *)this + 31);
        if (v9 >= v10) {
          break;
        }
      }
      if (v10 == v9) {
        break;
      }
      int v11 = StdStringExtractor::DecodeHexU8(this);
      if (v11 == -1)
      {
        *((void *)this + 4) = -1;
        LOBYTE(v11) = __c;
      }
      a2[v8] = v11;
      unint64_t v9 = *((void *)this + 4);
      if (v9 == -1) {
        break;
      }
      if (a3 == ++v8) {
        return a3;
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  if (a3 > v8) {
    memset(&a2[v8], __c, a3 - v8);
  }
  return v8;
}

std::string::size_type StdStringExtractor::GetHexByteString(uint64_t a1, std::string *this)
{
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    *this->__r_.__value_.__l.__data_ = 0;
    this->__r_.__value_.__l.__size_ = 0;
  }
  else
  {
    this->__r_.__value_.__s.__data_[0] = 0;
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
  }
  unint64_t v4 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 31) < 0)
  {
    unint64_t v5 = *(void *)(a1 + 16);
    if (v4 < v5) {
      goto LABEL_6;
    }
LABEL_8:
    std::string::size_type v6 = 0;
    goto LABEL_9;
  }
  unint64_t v5 = *(unsigned __int8 *)(a1 + 31);
  if (v4 >= v5) {
    goto LABEL_8;
  }
LABEL_6:
  std::string::size_type v6 = (v5 - v4) >> 1;
LABEL_9:
  std::string::reserve(this, v6);
  while (1)
  {
    int v7 = StdStringExtractor::DecodeHexU8((StdStringExtractor *)a1);
    if (v7 == -1) {
      break;
    }
    if (!(_BYTE)v7) {
      goto LABEL_14;
    }
    std::string::append(this, 1uLL, v7);
  }
  *(void *)(a1 + 32) = -1;
LABEL_14:
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    return HIBYTE(this->__r_.__value_.__r.__words[2]);
  }
  else {
    return this->__r_.__value_.__l.__size_;
  }
}

uint64_t StdStringExtractor::GetNameColonValue(uint64_t a1, std::string *a2, std::string *a3)
{
  std::string::size_type v6 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 31) < 0)
  {
    if (v6 >= *(void *)(a1 + 16))
    {
LABEL_8:
      uint64_t result = 0;
      uint64_t v11 = -1;
      goto LABEL_9;
    }
  }
  else if (v6 >= *(unsigned __int8 *)(a1 + 31))
  {
    goto LABEL_8;
  }
  std::string::size_type v7 = std::string::find((const std::string *)(a1 + 8), 58, v6);
  if (v7 == -1) {
    goto LABEL_8;
  }
  std::string::size_type v8 = v7;
  std::string::size_type v9 = std::string::find((const std::string *)(a1 + 8), 59, v7);
  if (v9 == -1) {
    goto LABEL_8;
  }
  std::string::size_type v10 = v9;
  std::string::assign(a2, (const std::string *)(a1 + 8), *(void *)(a1 + 32), v8 - *(void *)(a1 + 32));
  std::string::assign(a3, (const std::string *)(a1 + 8), v8 + 1, v10 - (v8 + 1));
  uint64_t v11 = v10 + 1;
  uint64_t result = 1;
LABEL_9:
  *(void *)(a1 + 32) = v11;
  return result;
}

double lldb_private::SocketAddress::SocketAddress(lldb_private::SocketAddress *this)
{
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

uint64_t lldb_private::SocketAddress::GetLength(lldb_private::SocketAddress *this)
{
  return *(unsigned __int8 *)this;
}

uint64_t lldb_private::SocketAddress::GetMaxLength(lldb_private::SocketAddress *this)
{
  return 128;
}

uint64_t lldb_private::SocketAddress::GetFamily(lldb_private::SocketAddress *this)
{
  return *((unsigned __int8 *)this + 1);
}

unint64_t lldb_private::SocketAddress::GetIPAddress@<X0>(unint64_t this@<X0>, unsigned char *a2@<X8>)
{
  memset(v10, 0, 46);
  int v3 = *(unsigned __int8 *)(this + 1);
  if (v3 == 30)
  {
    unint64_t v4 = (const void *)(this + 8);
    int v5 = 30;
  }
  else
  {
    if (v3 != 2)
    {
LABEL_10:
      a2[23] = 0;
      *a2 = 0;
      return this;
    }
    unint64_t v4 = (const void *)(this + 4);
    int v5 = 2;
  }
  this = (unint64_t)inet_ntop(v5, v4, (char *)v10, 0x2Eu);
  if (!this) {
    goto LABEL_10;
  }
  this = strlen((const char *)v10);
  if (this > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v6 = this;
  if (this >= 0x17)
  {
    uint64_t v7 = (this & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((this | 7) != 0x17) {
      uint64_t v7 = this | 7;
    }
    uint64_t v8 = v7 + 1;
    std::string::size_type v9 = operator new(v7 + 1);
    *((void *)a2 + 1) = v6;
    *((void *)a2 + 2) = v8 | 0x8000000000000000;
    *(void *)a2 = v9;
    a2 = v9;
  }
  else
  {
    a2[23] = this;
    if (!this) {
      goto LABEL_15;
    }
  }
  this = (unint64_t)memcpy(a2, v10, v6);
LABEL_15:
  a2[v6] = 0;
  return this;
}

uint64_t lldb_private::SocketAddress::GetPort(lldb_private::SocketAddress *this)
{
  int v1 = *((unsigned __int8 *)this + 1);
  if (v1 == 30 || v1 == 2) {
    return bswap32(*((unsigned __int16 *)this + 1)) >> 16;
  }
  else {
    return 0;
  }
}

uint64_t lldb_private::SocketAddress::SetPort(lldb_private::SocketAddress *this, unsigned int a2)
{
  int v2 = *((unsigned __int8 *)this + 1);
  if (v2 != 30 && v2 != 2) {
    return 0;
  }
  *((_WORD *)this + 1) = __rev16(a2);
  return 1;
}

void lldb_private::SocketAddress::GetAddressInfo(lldb_private::SocketAddress *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, char **a7@<X8>)
{
  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  memset(&v40.ai_addrlen, 0, 32);
  v40.ai_socktype = a4;
  v40.ai_protocol = a5;
  v40.ai_flags = a6;
  v40.ai_family = (int)a3;
  unsigned int v39 = 0;
  int v8 = getaddrinfo((const char *)this, a2, &v40, &v39);
  std::string::size_type v9 = v39;
  if (!v8 && v39)
  {
    std::string::size_type v10 = 0;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    do
    {
      long long v47 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long __dst = 0u;
      ai_addr = v9->ai_addr;
      if (ai_addr)
      {
        size_t ai_addrlen = v9->ai_addrlen;
        if ((ai_addrlen - 1) <= 0x7F) {
          memcpy(&__dst, ai_addr, ai_addrlen);
        }
      }
      if (v10 < v11)
      {
        long long v13 = __dst;
        long long v14 = v42;
        long long v15 = v44;
        *((_OWORD *)v10 + 2) = v43;
        *((_OWORD *)v10 + 3) = v15;
        *(_OWORD *)std::string::size_type v10 = v13;
        *((_OWORD *)v10 + 1) = v14;
        long long v16 = v45;
        long long v17 = v46;
        long long v18 = v48;
        *((_OWORD *)v10 + 6) = v47;
        *((_OWORD *)v10 + 7) = v18;
        *((_OWORD *)v10 + 4) = v16;
        *((_OWORD *)v10 + 5) = v17;
        int v19 = v10 + 128;
      }
      else
      {
        uint64_t v22 = (v10 - v12) >> 7;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 57) {
          abort();
        }
        if ((v11 - v12) >> 6 > v23) {
          unint64_t v23 = (v11 - v12) >> 6;
        }
        if ((unint64_t)(v11 - v12) >= 0x7FFFFFFFFFFFFF80) {
          unint64_t v24 = 0x1FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v23;
        }
        if (v24)
        {
          if (v24 >> 57) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          char v25 = (char *)operator new(v24 << 7);
        }
        else
        {
          char v25 = 0;
        }
        unsigned __int8 v26 = &v25[128 * v22];
        long long v27 = v46;
        long long v28 = v47;
        *((_OWORD *)v26 + 4) = v45;
        *((_OWORD *)v26 + 5) = v27;
        long long v29 = v48;
        *((_OWORD *)v26 + 6) = v28;
        *((_OWORD *)v26 + 7) = v29;
        long long v30 = v42;
        *(_OWORD *)unsigned __int8 v26 = __dst;
        *((_OWORD *)v26 + 1) = v30;
        long long v31 = v44;
        *((_OWORD *)v26 + 2) = v43;
        *((_OWORD *)v26 + 3) = v31;
        if (v10 == v12)
        {
          unint64_t v12 = &v25[128 * v22];
        }
        else
        {
          unsigned int v32 = &v25[128 * v22];
          do
          {
            long long v33 = *((_OWORD *)v10 - 8);
            long long v34 = *((_OWORD *)v10 - 7);
            long long v35 = *((_OWORD *)v10 - 5);
            *((_OWORD *)v32 - 6) = *((_OWORD *)v10 - 6);
            *((_OWORD *)v32 - 5) = v35;
            *((_OWORD *)v32 - 8) = v33;
            *((_OWORD *)v32 - 7) = v34;
            long long v36 = *((_OWORD *)v10 - 4);
            long long v37 = *((_OWORD *)v10 - 3);
            long long v38 = *((_OWORD *)v10 - 1);
            *((_OWORD *)v32 - 2) = *((_OWORD *)v10 - 2);
            *((_OWORD *)v32 - 1) = v38;
            *((_OWORD *)v32 - 4) = v36;
            *((_OWORD *)v32 - 3) = v37;
            v32 -= 128;
            v10 -= 128;
          }
          while (v10 != v12);
          std::string::size_type v10 = v12;
          unint64_t v12 = v32;
        }
        uint64_t v11 = &v25[128 * v24];
        int v19 = v26 + 128;
        *a7 = v12;
        a7[1] = v26 + 128;
        a7[2] = v11;
        if (v10) {
          operator delete(v10);
        }
      }
      a7[1] = v19;
      std::string::size_type v9 = v9->ai_next;
      std::string::size_type v10 = v19;
    }
    while (v9);
    std::string::size_type v9 = v39;
  }
  if (v9) {
    freeaddrinfo(v9);
  }
}

uint64_t lldb_private::SocketAddress::SetToAnyAddress(lldb_private::SocketAddress *this, int a2, unsigned int a3)
{
  if (a2 == 30)
  {
    *(_WORD *)this = 7708;
    *((_WORD *)this + 1) = __rev16(a3);
    *(in6_addr *)((char *)this + 8) = in6addr_any;
    return 1;
  }
  else if (a2 == 2)
  {
    *(_WORD *)this = 528;
    *((_WORD *)this + 1) = __rev16(a3);
    *((_DWORD *)this + 1) = 0;
    return 1;
  }
  else
  {
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    return 0;
  }
}

BOOL lldb_private::SocketAddress::IsAnyAddr(lldb_private::SocketAddress *this)
{
  if (*((unsigned char *)this + 1) == 2)
  {
    int v1 = *((_DWORD *)this + 1);
  }
  else
  {
    unint64_t v2 = bswap64(*((void *)this + 1));
    unint64_t v3 = bswap64(*(unint64_t *)in6addr_any.__u6_addr8);
    if (v2 == v3
      && (v2 = bswap64(*((void *)this + 2)), unint64_t v3 = bswap64(*(void *)&in6addr_any.__u6_addr32[2]), v2 == v3))
    {
      int v1 = 0;
    }
    else if (v2 < v3)
    {
      int v1 = -1;
    }
    else
    {
      int v1 = 1;
    }
  }
  return v1 == 0;
}

BOOL lldb_private::SocketAddress::IsLocalhost(lldb_private::SocketAddress *this)
{
  if (*((unsigned char *)this + 1) == 2) {
    return *((_DWORD *)this + 1) == 16777343;
  }
  return *((void *)this + 1) == *(void *)in6addr_loopback.__u6_addr8
      && *((void *)this + 2) == *(void *)&in6addr_loopback.__u6_addr32[2];
}

BOOL lldb_private::SocketAddress::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = a1[1];
  if (v2 != a2[1] || *a1 != *a2) {
    return 0;
  }
  if (v2 != 30)
  {
    if (v2 == 2) {
      return *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1);
    }
    return 0;
  }
  return *((void *)a1 + 1) == *((void *)a2 + 1) && *((void *)a1 + 2) == *((void *)a2 + 2);
}

void PseudoTerminal::PseudoTerminal(PseudoTerminal *this)
{
  *(void *)this = -1;
}

void PseudoTerminal::~PseudoTerminal(PseudoTerminal *this)
{
  int v2 = *(_DWORD *)this;
  if (v2 >= 1)
  {
    close(v2);
    *(_DWORD *)this = -1;
  }
  int v3 = *((_DWORD *)this + 1);
  if (v3 >= 1)
  {
    close(v3);
    *((_DWORD *)this + 1) = -1;
  }
}

uint64_t PseudoTerminal::OpenFirstAvailablePrimary(PseudoTerminal *this, int a2)
{
  int v3 = posix_openpt(a2);
  *(_DWORD *)this = v3;
  if (v3 < 0) {
    return 4294967294;
  }
  int v4 = grantpt(v3);
  int v5 = *(_DWORD *)this;
  if (v4 < 0)
  {
    uint64_t v6 = 4294967293;
    if (v5 <= 0) {
      return v6;
    }
LABEL_7:
    close(v5);
    *(_DWORD *)this = -1;
    return v6;
  }
  if (unlockpt(v5) < 0)
  {
    int v5 = *(_DWORD *)this;
    uint64_t v6 = 4294967292;
    if (*(int *)this < 1) {
      return v6;
    }
    goto LABEL_7;
  }
  return 0;
}

char *PseudoTerminal::SecondaryName(PseudoTerminal *this)
{
  int v1 = *(_DWORD *)this;
  if (v1 < 0) {
    return 0;
  }
  else {
    return ptsname(v1);
  }
}

uint64_t PseudoTerminal::Fork(int *a1, int *a2)
{
  int v4 = posix_openpt(131074);
  *a1 = v4;
  if (v4 < 0)
  {
    uint64_t result = 0xFFFFFFFFLL;
    int v12 = -2;
    goto LABEL_33;
  }
  int v5 = grantpt(v4);
  int v6 = *a1;
  if (v5 < 0)
  {
    int v12 = -3;
    if (v6 <= 0)
    {
LABEL_29:
      uint64_t result = 0xFFFFFFFFLL;
      goto LABEL_33;
    }
LABEL_27:
    close(v6);
    uint64_t result = 0xFFFFFFFFLL;
    *a1 = -1;
    goto LABEL_33;
  }
  if (unlockpt(v6) < 0)
  {
    int v6 = *a1;
    int v12 = -4;
    if (*a1 < 1) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }
  *a2 = 0;
  uint64_t result = fork();
  if ((result & 0x80000000) != 0)
  {
    int v12 = -7;
  }
  else
  {
    if (result) {
      return result;
    }
    setsid();
    int v8 = a1[1];
    if (v8 >= 1)
    {
      close(v8);
      a1[1] = -1;
    }
    if (*a1 < 0)
    {
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = (uint64_t)ptsname(*a1);
      if (result)
      {
        int v9 = open((const char *)result, 2);
        a1[1] = v9;
        if (v9 < 0)
        {
          uint64_t result = 0;
          int v12 = -6;
        }
        else
        {
          *a2 = 0;
          if (*a1 >= 1)
          {
            close(*a1);
            *a1 = -1;
            int v9 = a1[1];
          }
          if (ioctl(v9, 0x20007461uLL, 0) < 0) {
            *a2 = -9;
          }
          if (dup2(a1[1], 0))
          {
            int v10 = *a2;
            if (!*a2) {
              int v10 = -10;
            }
            *a2 = v10;
          }
          if (dup2(a1[1], 1) != 1)
          {
            int v11 = *a2;
            if (!*a2) {
              int v11 = -11;
            }
            *a2 = v11;
          }
          if (dup2(a1[1], 2) == 2) {
            return 0;
          }
          uint64_t result = 0;
          if (*a2) {
            int v12 = *a2;
          }
          else {
            int v12 = -12;
          }
        }
        goto LABEL_33;
      }
    }
    int v12 = -5;
  }
LABEL_33:
  *a2 = v12;
  return result;
}

void PThreadEvent::PThreadEvent(PThreadEvent *this, int a2, int a3)
{
  if (pthread_mutex_init((pthread_mutex_t *)this, 0)) {
    PThreadEvent::PThreadEvent();
  }
  pthread_cond_init((pthread_cond_t *)((char *)this + 64), 0);
  pthread_cond_init((pthread_cond_t *)((char *)this + 112), 0);
  *((_DWORD *)this + 40) = a2;
  *((_DWORD *)this + 41) = a3;
  *((_DWORD *)this + 42) = 0;
}

void PThreadEvent::~PThreadEvent(PThreadEvent *this)
{
  if (pthread_mutex_destroy((pthread_mutex_t *)this))
  {
    if (!pthread_mutex_unlock((pthread_mutex_t *)this)) {
      pthread_mutex_destroy((pthread_mutex_t *)this);
    }
  }
}

uint64_t PThreadEvent::GetEventBits(pthread_mutex_t *this)
{
  pthread_mutex_lock(this);
  uint64_t v2 = *(unsigned int *)&this[2].__opaque[24];
  pthread_mutex_unlock(this);
  return v2;
}

pthread_mutex_t *PThreadEvent::SetEvents(pthread_mutex_t *this, int a2)
{
  if (a2)
  {
    int v3 = this;
    pthread_mutex_lock(this);
    int v4 = *(_DWORD *)&v3[2].__opaque[24];
    *(_DWORD *)&v3[2].__opaque[24] = v4 | a2;
    if (v4 != (v4 | a2)) {
      pthread_cond_broadcast((pthread_cond_t *)&v3[1]);
    }
    return (pthread_mutex_t *)pthread_mutex_unlock(v3);
  }
  return this;
}

pthread_mutex_t *PThreadEvent::ResetEvents(pthread_mutex_t *this, int a2)
{
  if (a2)
  {
    int v3 = this;
    pthread_mutex_lock(this);
    int v4 = *(_DWORD *)&v3[2].__opaque[24];
    int v5 = v4 & ~a2;
    *(_DWORD *)&v3[2].__opaque[24] = v5;
    if (v4 != v5) {
      pthread_cond_broadcast((pthread_cond_t *)&v3[1].__opaque[40]);
    }
    return (pthread_mutex_t *)pthread_mutex_unlock(v3);
  }
  return this;
}

uint64_t PThreadEvent::WaitForSetEvents(pthread_mutex_t *this, unsigned int a2, const timespec *a3)
{
  pthread_mutex_lock(this);
  while (1)
  {
    int v7 = *(_DWORD *)&this[2].__opaque[24];
    uint64_t v8 = v7 & a2;
    if ((v7 & a2) != 0) {
      break;
    }
    int v9 = (pthread_cond_t *)&this[1];
    if (a3)
    {
      int v6 = pthread_cond_timedwait(v9, this, a3);
      if (v6 == 60)
      {
        uint64_t v8 = *(_DWORD *)&this[2].__opaque[24] & a2;
        break;
      }
    }
    else
    {
      int v6 = pthread_cond_wait(v9, this);
    }
    if (v6)
    {
      uint64_t v8 = 0;
      break;
    }
  }
  pthread_mutex_unlock(this);
  return v8;
}

uint64_t PThreadEvent::WaitForEventsToReset(pthread_mutex_t *this, unsigned int a2, const timespec *a3)
{
  pthread_mutex_lock(this);
  while ((*(_DWORD *)&this[2].__opaque[24] & a2) != 0)
  {
    int v6 = (pthread_cond_t *)&this[1].__opaque[40];
    if (a3)
    {
      if (pthread_cond_timedwait(v6, this, a3))
      {
LABEL_6:
        uint64_t v7 = *(_DWORD *)&this[2].__opaque[24] & a2;
        goto LABEL_8;
      }
    }
    else if (pthread_cond_wait(v6, this))
    {
      goto LABEL_6;
    }
  }
  uint64_t v7 = 0;
LABEL_8:
  pthread_mutex_unlock(this);
  return v7;
}

uint64_t PThreadEvent::WaitForResetAck(PThreadEvent *this, int a2, const timespec *a3)
{
  int v3 = *((_DWORD *)this + 42) & a2;
  if (!v3) {
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)this);
  while ((*((_DWORD *)this + 40) & v3) != 0)
  {
    int v6 = (pthread_cond_t *)((char *)this + 112);
    if (a3)
    {
      if (pthread_cond_timedwait(v6, (pthread_mutex_t *)this, a3))
      {
LABEL_7:
        uint64_t v7 = *((_DWORD *)this + 40) & v3;
        goto LABEL_10;
      }
    }
    else if (pthread_cond_wait(v6, (pthread_mutex_t *)this))
    {
      goto LABEL_7;
    }
  }
  uint64_t v7 = 0;
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)this);
  return v7;
}

void RNBContext::~RNBContext(void **this)
{
  *this = off_100068D40;
  if (*((_DWORD *)this + 3)) {
    RNBContext::StopProcessStatusThread((RNBContext *)this);
  }
  *((_DWORD *)this + 3) = 0;
  uint64_t v2 = this[56];
  if (v2)
  {
    this[57] = v2;
    operator delete(v2);
  }
  if (*((char *)this + 439) < 0)
  {
    operator delete(this[52]);
    if ((*((char *)this + 415) & 0x80000000) == 0)
    {
LABEL_7:
      int v3 = (void **)this[46];
      if (!v3) {
        goto LABEL_8;
      }
      goto LABEL_17;
    }
  }
  else if ((*((char *)this + 415) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(this[49]);
  int v3 = (void **)this[46];
  if (!v3)
  {
LABEL_8:
    int v4 = (void **)this[43];
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }
LABEL_17:
  int v5 = (void **)this[47];
  int v6 = v3;
  if (v5 != v3)
  {
    do
    {
      if (*((char *)v5 - 1) < 0) {
        operator delete(*(v5 - 3));
      }
      v5 -= 3;
    }
    while (v5 != v3);
    int v6 = (void **)this[46];
  }
  this[47] = v3;
  operator delete(v6);
  int v4 = (void **)this[43];
  if (!v4)
  {
LABEL_9:
    if ((*((char *)this + 343) & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_35;
  }
LABEL_28:
  uint64_t v7 = (void **)this[44];
  uint64_t v8 = v4;
  if (v7 != v4)
  {
    do
    {
      if (*((char *)v7 - 1) < 0) {
        operator delete(*(v7 - 3));
      }
      v7 -= 3;
    }
    while (v7 != v4);
    uint64_t v8 = (void **)this[43];
  }
  this[44] = v4;
  operator delete(v8);
  if (*((char *)this + 343) < 0) {
LABEL_35:
  }
    operator delete(this[40]);
LABEL_10:
  PThreadEvent::~PThreadEvent((PThreadEvent *)(this + 15));
  if (*((char *)this + 111) < 0)
  {
    operator delete(this[11]);
    if ((*((char *)this + 87) & 0x80000000) == 0)
    {
LABEL_12:
      if ((*((char *)this + 63) & 0x80000000) == 0) {
        goto LABEL_13;
      }
      goto LABEL_24;
    }
  }
  else if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    goto LABEL_12;
  }
  operator delete(this[8]);
  if ((*((char *)this + 63) & 0x80000000) == 0)
  {
LABEL_13:
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      return;
    }
LABEL_25:
    operator delete(this[2]);
    return;
  }
LABEL_24:
  operator delete(this[5]);
  if (*((char *)this + 39) < 0) {
    goto LABEL_25;
  }
}

{
  uint64_t vars8;

  RNBContext::~RNBContext(this);

  operator delete();
}

void RNBContext::SetProcessID(RNBContext *this, int a2)
{
  if (*((_DWORD *)this + 3)) {
    RNBContext::StopProcessStatusThread(this);
  }
  *((_DWORD *)this + 3) = a2;
  if (a2)
  {
    RNBContext::StartProcessStatusThread((pthread_t *)this);
  }
}

char *RNBContext::EnvironmentAtIndex(RNBContext *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 46);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 47) - v2) >> 3) <= a2) {
    return 0;
  }
  uint64_t result = (char *)(v2 + 24 * a2);
  if (result[23] < 0) {
    return *(char **)result;
  }
  return result;
}

void RNBContext::PushEnvironmentIfNeeded(RNBContext *this, const char *__s)
{
  if (!__s) {
    return;
  }
  size_t v4 = strlen(__s);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
LABEL_58:
  }
    abort();
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = v5;
    int64_t v40 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_9;
  }
  HIBYTE(v40) = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_9:
  }
    memcpy(p_dst, __s, v5);
  *((unsigned char *)p_dst + v5) = 0;
  GetEnvironmentKey((uint64_t)&__dst, (uint64_t *)&__p);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v9 = *((void *)this + 46);
  uint64_t v10 = *((void *)this + 47);
  long long v37 = this;
  if (v9 != v10)
  {
    int v11 = (char)v43;
    size_t v12 = v42;
    __s1 = __p;
    if ((v43 & 0x80u) == 0) {
      size_t v13 = v43;
    }
    else {
      size_t v13 = v42;
    }
    uint64_t v14 = v43 - 1;
    do
    {
      GetEnvironmentKey(v9, (uint64_t *)&__dst);
      uint64_t v15 = HIBYTE(v40);
      int v16 = SHIBYTE(v40);
      if (v40 < 0) {
        uint64_t v15 = *((void *)&__dst + 1);
      }
      if (v13 == v15)
      {
        if (v40 >= 0) {
          long long v17 = (unsigned __int8 *)&__dst;
        }
        else {
          long long v17 = (unsigned __int8 *)__dst;
        }
        if (v11 < 0)
        {
          BOOL v26 = memcmp(__s1, v17, v12) == 0;
        }
        else
        {
          if (!v11)
          {
            BOOL v26 = 1;
            if ((SHIBYTE(v40) & 0x80000000) == 0) {
              goto LABEL_37;
            }
LABEL_36:
            operator delete((void *)__dst);
            goto LABEL_37;
          }
          p_p = &__p;
          uint64_t v19 = v14;
          do
          {
            int v21 = *(unsigned __int8 *)p_p;
            p_p = (void **)((char *)p_p + 1);
            int v20 = v21;
            int v23 = *v17++;
            int v22 = v23;
            BOOL v25 = v19-- != 0;
            BOOL v26 = v20 == v22;
          }
          while (v20 == v22 && v25);
        }
        if (v16 < 0) {
          goto LABEL_36;
        }
      }
      else
      {
        BOOL v26 = 0;
        if (SHIBYTE(v40) < 0) {
          goto LABEL_36;
        }
      }
LABEL_37:
      if (v26) {
        goto LABEL_55;
      }
      v9 += 24;
    }
    while (v9 != v10);
  }
  size_t v27 = strlen(__s);
  if (v27 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_58;
  }
  size_t v28 = v27;
  if (v27 >= 0x17)
  {
    uint64_t v31 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v31 = v27 | 7;
    }
    uint64_t v32 = v31 + 1;
    long long v29 = (long long *)operator new(v31 + 1);
    *((void *)&__dst + 1) = v28;
    int64_t v40 = v32 | 0x8000000000000000;
    *(void *)&long long __dst = v29;
    long long v30 = v37;
    goto LABEL_49;
  }
  HIBYTE(v40) = v27;
  long long v29 = &__dst;
  long long v30 = v37;
  if (v27) {
LABEL_49:
  }
    memcpy(v29, __s, v28);
  *((unsigned char *)v29 + v28) = 0;
  unint64_t v33 = *((void *)v30 + 47);
  if (v33 >= *((void *)v30 + 48))
  {
    long long v35 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)v30 + 46, (uint64_t)&__dst);
    int v36 = SHIBYTE(v40);
    *((void *)v30 + 47) = v35;
    if (v36 < 0) {
      operator delete((void *)__dst);
    }
  }
  else
  {
    long long v34 = __dst;
    *(void *)(v33 + 16) = v40;
    *(_OWORD *)unint64_t v33 = v34;
    *((void *)v30 + 47) = v33 + 24;
  }
  LOBYTE(v11) = v43;
LABEL_55:
  if ((v11 & 0x80) != 0) {
    operator delete(__p);
  }
}

std::string::size_type GetEnvironmentKey@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  std::string::size_type result = std::string::find((const std::string *)a1, 61, 0);
  size_t v5 = *(unsigned __int8 *)(a1 + 23);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    size_t v5 = *(void *)(a1 + 8);
  }
  if (v6 >= 0) {
    uint64_t v7 = (const void *)a1;
  }
  else {
    uint64_t v7 = *(const void **)a1;
  }
  if (v5 >= result) {
    size_t v8 = result;
  }
  else {
    size_t v8 = v5;
  }
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v8 >= 0x17)
  {
    uint64_t v10 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v10 = v8 | 7;
    }
    uint64_t v11 = v10 + 1;
    uint64_t v9 = operator new(v10 + 1);
    a2[1] = v8;
    a2[2] = v11 | 0x8000000000000000;
    *a2 = (uint64_t)v9;
    goto LABEL_16;
  }
  *((unsigned char *)a2 + 23) = v8;
  uint64_t v9 = a2;
  if (v8) {
LABEL_16:
  }
    std::string::size_type result = (std::string::size_type)memmove(v9, v7, v8);
  *((unsigned char *)v9 + v8) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v14 = a2[1];
    if (v14)
    {
      uint64_t v15 = (uint64_t *)*a2;
      if (*(unsigned char *)(*a2 + v14 - 1) == 61)
      {
        uint64_t v13 = v14 - 1;
        a2[1] = v13;
        a2 = v15;
        goto LABEL_24;
      }
    }
  }
  else
  {
    uint64_t v12 = *((unsigned __int8 *)a2 + 23);
    if (*((unsigned char *)a2 + 23) && *((unsigned char *)a2 + v12 - 1) == 61)
    {
      uint64_t v13 = v12 - 1;
      *((unsigned char *)a2 + 23) = v13;
LABEL_24:
      *((unsigned char *)a2 + v13) = 0;
    }
  }
  return result;
}

char *RNBContext::ArgumentAtIndex(RNBContext *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 43);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 44) - v2) >> 3) <= a2) {
    return 0;
  }
  std::string::size_type result = (char *)(v2 + 24 * a2);
  if (result[23] < 0) {
    return *(char **)result;
  }
  return result;
}

BOOL RNBContext::SetWorkingDirectory(RNBContext *this, const char *a2)
{
  int v4 = stat(a2, &v6);
  if (v4)
  {
    if (*((char *)this + 415) < 0)
    {
      **((unsigned char **)this + 49) = 0;
      *((void *)this + 50) = 0;
    }
    else
    {
      *((unsigned char *)this + 392) = 0;
      *((unsigned char *)this + 415) = 0;
    }
  }
  else
  {
    std::string::assign((std::string *)((char *)this + 392), a2);
  }
  return v4 == 0;
}

void RNBContext::StopProcessStatusThread(RNBContext *this)
{
  if (DNBLogEnabledForAny(0x400000)) {
    _DNBLogThreaded("RNBContext::%s called", "StopProcessStatusThread");
  }
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 120);
  if ((PThreadEvent::GetEventBits(v2) & 2) != 0)
  {
    gettimeofday(&v5, 0);
    v4.tv_sec = v5.tv_sec + v5.tv_usec / 1000000 + 2;
    v4.tv_nsec = 1000 * v5.tv_usec % 1000000000;
    int v3 = PThreadEvent::WaitForSetEvents(v2, 4u, &v4);
    if (DNBLogEnabledForAny(0x400000))
    {
      if (v3 == 4) {
        _DNBLogThreaded("RNBContext::%s thread stopped as requeseted");
      }
      else {
        _DNBLogThreaded("RNBContext::%s thread did not stop in 2 seconds...");
      }
    }
  }
}

void RNBContext::StartProcessStatusThread(pthread_t *this)
{
  if (DNBLogEnabledForAny(0x400000)) {
    _DNBLogThreaded("RNBContext::%s called", "StartProcessStatusThread");
  }
  uint64_t v2 = (pthread_mutex_t *)(this + 15);
  if ((PThreadEvent::GetEventBits((pthread_mutex_t *)(this + 15)) & 2) == 0)
  {
    int v3 = pthread_create(this + 37, 0, (void *(__cdecl *)(void *))RNBContext::ThreadFunctionProcessStatus, this);
    if (v3)
    {
      int v4 = v3;
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded("RNBContext::%s thread failed to start: err = %i", "StartProcessStatusThread", v4);
      }
      PThreadEvent::ResetEvents(v2, 2);
      PThreadEvent::SetEvents(v2, 4);
    }
    else
    {
      PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(this + 15), 2u, 0);
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded("RNBContext::%s thread got started!", "StartProcessStatusThread");
      }
    }
  }
}

uint64_t RNBContext::ThreadFunctionProcessStatus(RNBContext *this, void *a2)
{
  uint64_t v4 = g_remoteSP;
  int v3 = (std::__shared_weak_count *)qword_1000796A0;
  if (qword_1000796A0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1000796A0 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    int v5 = *(_DWORD *)(v4 + 12);
    if (DNBLogEnabledForAny(0x400000)) {
      _DNBLogThreaded("RNBContext::%s (arg=%p, pid=%4.4x): thread starting...", "ThreadFunctionProcessStatus", this, v5);
    }
    stat v6 = (pthread_mutex_t *)(v4 + 120);
    PThreadEvent::SetEvents(v6, 2);
    pthread_setname_np("child process status watcher thread");
    int v13 = 0;
    uint64_t v7 = pthread_self();
    if (!pthread_getschedparam(v7, &v13, &v14))
    {
      v14.sched_priority = 47;
      size_t v8 = pthread_self();
      pthread_setschedparam(v8, v13, &v14);
    }
    while (1)
    {
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded("RNBContext::%s calling DNBProcessWaitForEvent(pid, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged | eEventStdioAvailable | eEventProfileDataAvailable, true)...", "ThreadFunctionProcessStatus");
      }
      int v9 = DNBProcessWaitForEvents(v5, 0x1Bu, 1, 0);
      if (DNBLogEnabledForAny(0x400000))
      {
        _DNBLogThreaded("RNBContext::%s calling DNBProcessWaitForEvent(pid, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged | eEventStdioAvailable | eEventProfileDataAvailable, true) => 0x%8.8x", "ThreadFunctionProcessStatus", v9);
        if (!v9) {
          goto LABEL_18;
        }
LABEL_13:
        if ((v9 & 8) != 0)
        {
          if (DNBLogEnabledForAny(0x400000)) {
            _DNBLogThreaded("RNBContext::%s (pid=%4.4x) got stdio available event....", "ThreadFunctionProcessStatus", v5);
          }
          PThreadEvent::SetEvents(v6, 8);
          PThreadEvent::WaitForResetAck((PThreadEvent *)v6, 8, 0);
          if ((v9 & 0x10) != 0)
          {
LABEL_23:
            if (DNBLogEnabledForAny(0x400000)) {
              _DNBLogThreaded("RNBContext::%s (pid=%4.4x) got profile data event....", "ThreadFunctionProcessStatus", v5);
            }
            PThreadEvent::SetEvents(v6, 16);
            PThreadEvent::WaitForResetAck((PThreadEvent *)v6, 16, 0);
            if ((v9 & 3) == 0) {
              goto LABEL_8;
            }
            goto LABEL_26;
          }
        }
        else if ((v9 & 0x10) != 0)
        {
          goto LABEL_23;
        }
        if ((v9 & 3) == 0) {
          goto LABEL_8;
        }
LABEL_26:
        unsigned int State = DNBProcessGetState(v5);
        if (DNBLogEnabledForAny(0x400000))
        {
          uint64_t v11 = DNBStateAsString(State);
          _DNBLogThreaded("RNBContext::%s (pid=%4.4x) got process state change: %s", "ThreadFunctionProcessStatus", v5, v11);
        }
        PThreadEvent::SetEvents(v6, 1);
        PThreadEvent::WaitForResetAck((PThreadEvent *)v6, 1, 0);
        if (State <= 9 && ((1 << State) & 0x301) != 0)
        {
          DNBProcessResetEvents(v5, v9);
          if (DNBLogEnabledForAny(0x400000)) {
            _DNBLogThreaded("RNBContext::%s (arg=%p, pid=%4.4x): thread exiting...", "ThreadFunctionProcessStatus", this, v5);
          }
          PThreadEvent::ResetEvents(v6, 2);
          PThreadEvent::SetEvents(v6, 4);
          break;
        }
LABEL_8:
        DNBProcessResetEvents(v5, v9);
      }
      else
      {
        if (v9) {
          goto LABEL_13;
        }
LABEL_18:
        if (DNBLogEnabledForAny(0x400000)) {
          _DNBLogThreaded("RNBContext::%s (pid=%4.4x) got ZERO back from DNBProcessWaitForEvent....", "ThreadFunctionProcessStatus", v5);
        }
      }
    }
  }
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *, void *))v3->__on_zero_shared)(v3, a2);
    std::__shared_weak_count::__release_weak(v3);
  }
  return 0;
}

std::string *RNBContext::EventsAsString(int a1, char a2, std::string *this)
{
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    this->__r_.__value_.__s.__data_[0] = 0;
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
    if ((a2 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  *this->__r_.__value_.__l.__data_ = 0;
  this->__r_.__value_.__l.__size_ = 0;
  if (a2) {
LABEL_3:
  }
    std::string::append(this, "proc_state_changed ");
LABEL_4:
  if ((a2 & 2) != 0)
  {
    std::string::append(this, "proc_thread_running ");
    if ((a2 & 4) == 0)
    {
LABEL_6:
      if ((a2 & 8) == 0) {
        goto LABEL_7;
      }
      goto LABEL_16;
    }
  }
  else if ((a2 & 4) == 0)
  {
    goto LABEL_6;
  }
  std::string::append(this, "proc_thread_exiting ");
  if ((a2 & 8) == 0)
  {
LABEL_7:
    if ((a2 & 0x10) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  std::string::append(this, "proc_stdio_available ");
  if ((a2 & 0x10) == 0)
  {
LABEL_8:
    if ((a2 & 0x20) == 0) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }
LABEL_17:
  std::string::append(this, "proc_profile_data ");
  if ((a2 & 0x20) == 0)
  {
LABEL_9:
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_18:
  std::string::append(this, "read_packet_available ");
  if ((a2 & 0x40) != 0)
  {
LABEL_10:
    std::string::append(this, "read_thread_running ");
    std::string::append(this, "read_thread_running ");
  }
LABEL_11:
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    return this;
  }
  else {
    return (std::string *)this->__r_.__value_.__r.__words[0];
  }
}

uint64_t RNBContext::LaunchStatusAsString(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  int v3 = (_DWORD *)(a1 + 312);
  uint64_t v4 = DNBError::AsString((DNBError *)(a1 + 312));
  if (v4)
  {
    int v5 = (char *)v4;
  }
  else
  {
    snprintf(__str, 0x40uLL, "%u", *v3);
    int v5 = __str;
  }
  std::string::assign((std::string *)a2, v5);
  if (*(char *)(a2 + 23) >= 0) {
    return a2;
  }
  else {
    return *(void *)a2;
  }
}

BOOL RNBContext::ProcessStateRunning(RNBContext *this)
{
  return DNBProcessGetState(*((_DWORD *)this + 3)) - 5 < 2;
}

BOOL RNBContext::AddIgnoredException(RNBContext *this, MachException *a2)
{
  int v3 = MachException::ExceptionMask(a2, (const char *)a2);
  int v4 = v3;
  if (v3)
  {
    stat v6 = (char *)*((void *)this + 57);
    unint64_t v5 = *((void *)this + 58);
    if ((unint64_t)v6 >= v5)
    {
      size_t v8 = (char *)*((void *)this + 56);
      uint64_t v9 = (v6 - v8) >> 2;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 62) {
        abort();
      }
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 1 > v10) {
        unint64_t v10 = v11 >> 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        int v13 = operator new(4 * v12);
      }
      else
      {
        int v13 = 0;
      }
      sched_param v14 = &v13[4 * v9];
      uint64_t v15 = &v13[4 * v12];
      *sched_param v14 = v4;
      uint64_t v7 = v14 + 1;
      if (v6 != v8)
      {
        unint64_t v16 = v6 - v8 - 4;
        if (v16 < 0x2C) {
          goto LABEL_29;
        }
        if ((unint64_t)(v8 - v13) < 0x20) {
          goto LABEL_29;
        }
        uint64_t v17 = (v16 >> 2) + 1;
        uint64_t v18 = 4 * (v17 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v19 = &v6[-v18];
        sched_param v14 = (_DWORD *)((char *)v14 - v18);
        int v20 = &v13[4 * v9 - 16];
        int v21 = v6 - 16;
        uint64_t v22 = v17 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v23 = *(_OWORD *)v21;
          *(v20 - 1) = *((_OWORD *)v21 - 1);
          *int v20 = v23;
          v20 -= 2;
          v21 -= 32;
          v22 -= 8;
        }
        while (v22);
        stat v6 = v19;
        if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_29:
          do
          {
            int v24 = *((_DWORD *)v6 - 1);
            v6 -= 4;
            *--sched_param v14 = v24;
          }
          while (v6 != v8);
        }
      }
      *((void *)this + 56) = v14;
      *((void *)this + 57) = v7;
      *((void *)this + 58) = v15;
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(_DWORD *)stat v6 = v3;
      uint64_t v7 = v6 + 4;
    }
    *((void *)this + 57) = v7;
  }
  return v4 != 0;
}

void RNBContext::AddDefaultIgnoredExceptions(RNBContext *this)
{
  int v3 = (char *)*((void *)this + 57);
  uint64_t v2 = (char *)*((void *)this + 58);
  int v4 = v3;
  if (v3 >= v2)
  {
    stat v6 = (char *)*((void *)this + 56);
    uint64_t v7 = (v3 - v6) >> 2;
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 62) {
      goto LABEL_69;
    }
    uint64_t v9 = v2 - v6;
    if (v9 >> 1 > v8) {
      unint64_t v8 = v9 >> 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 62) {
        goto LABEL_70;
      }
      uint64_t v11 = operator new(4 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    unint64_t v12 = &v11[4 * v7];
    uint64_t v2 = &v11[4 * v10];
    _DWORD *v12 = 2;
    unint64_t v5 = (char *)(v12 + 1);
    if (v3 != v6)
    {
      unint64_t v13 = v3 - v6 - 4;
      if (v13 < 0x2C) {
        goto LABEL_73;
      }
      if ((unint64_t)(v6 - v11) < 0x20) {
        goto LABEL_73;
      }
      uint64_t v14 = (v13 >> 2) + 1;
      uint64_t v15 = 4 * (v14 & 0x7FFFFFFFFFFFFFF8);
      int v4 = &v3[-v15];
      unint64_t v12 = (_DWORD *)((char *)v12 - v15);
      unint64_t v16 = &v11[4 * v7 - 16];
      uint64_t v17 = (long long *)(v3 - 16);
      uint64_t v18 = v14 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v19 = *v17;
        *(v16 - 1) = *(v17 - 1);
        _OWORD *v16 = v19;
        v16 -= 2;
        v17 -= 2;
        v18 -= 8;
      }
      while (v18);
      if (v14 != (v14 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_73:
        do
        {
          int v20 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *--unint64_t v12 = v20;
        }
        while (v4 != v6);
      }
    }
    *((void *)this + 56) = v12;
    *((void *)this + 57) = v5;
    *((void *)this + 58) = v2;
    if (v6)
    {
      operator delete(v6);
      uint64_t v2 = (char *)*((void *)this + 58);
    }
  }
  else
  {
    *(_DWORD *)int v3 = 2;
    unint64_t v5 = v3 + 4;
  }
  *((void *)this + 57) = v5;
  if (v5 < v2)
  {
    *(_DWORD *)unint64_t v5 = 4;
    int v21 = v5 + 4;
    goto LABEL_45;
  }
  uint64_t v22 = (char *)*((void *)this + 56);
  uint64_t v23 = (v5 - v22) >> 2;
  unint64_t v24 = v23 + 1;
  if ((unint64_t)(v23 + 1) >> 62) {
    goto LABEL_69;
  }
  uint64_t v25 = v2 - v22;
  if (v25 >> 1 > v24) {
    unint64_t v24 = v25 >> 1;
  }
  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v26 = v24;
  }
  if (v26)
  {
    if (v26 >> 62) {
      goto LABEL_70;
    }
    size_t v27 = operator new(4 * v26);
  }
  else
  {
    size_t v27 = 0;
  }
  size_t v28 = &v27[4 * v23];
  uint64_t v2 = &v27[4 * v26];
  *size_t v28 = 4;
  int v21 = (char *)(v28 + 1);
  if (v5 != v22)
  {
    unint64_t v29 = v5 - v22 - 4;
    if (v29 < 0x2C)
    {
      long long v30 = v5;
      goto LABEL_42;
    }
    if ((unint64_t)(v22 - v27) < 0x20)
    {
      long long v30 = v5;
      do
      {
LABEL_42:
        int v37 = *((_DWORD *)v30 - 1);
        v30 -= 4;
        *--size_t v28 = v37;
      }
      while (v30 != v22);
      goto LABEL_43;
    }
    uint64_t v31 = (v29 >> 2) + 1;
    uint64_t v32 = 4 * (v31 & 0x7FFFFFFFFFFFFFF8);
    long long v30 = &v5[-v32];
    size_t v28 = (_DWORD *)((char *)v28 - v32);
    unint64_t v33 = &v27[4 * v23 - 16];
    long long v34 = v5 - 16;
    uint64_t v35 = v31 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v36 = *(_OWORD *)v34;
      *(v33 - 1) = *((_OWORD *)v34 - 1);
      *unint64_t v33 = v36;
      v33 -= 2;
      v34 -= 32;
      v35 -= 8;
    }
    while (v35);
    if (v31 != (v31 & 0x7FFFFFFFFFFFFFF8)) {
      goto LABEL_42;
    }
  }
LABEL_43:
  *((void *)this + 56) = v28;
  *((void *)this + 57) = v21;
  *((void *)this + 58) = v2;
  if (v22)
  {
    operator delete(v22);
    uint64_t v2 = (char *)*((void *)this + 58);
  }
LABEL_45:
  *((void *)this + 57) = v21;
  if (v21 < v2)
  {
    *(_DWORD *)int v21 = 8;
    long long v38 = v21 + 4;
    goto LABEL_68;
  }
  unsigned int v39 = (char *)*((void *)this + 56);
  uint64_t v40 = (v21 - v39) >> 2;
  unint64_t v41 = v40 + 1;
  if ((unint64_t)(v40 + 1) >> 62) {
LABEL_69:
  }
    abort();
  uint64_t v42 = v2 - v39;
  if (v42 >> 1 > v41) {
    unint64_t v41 = v42 >> 1;
  }
  if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v43 = v41;
  }
  if (v43)
  {
    if (!(v43 >> 62))
    {
      long long v44 = operator new(4 * v43);
      goto LABEL_57;
    }
LABEL_70:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  long long v44 = 0;
LABEL_57:
  long long v45 = &v44[4 * v40];
  long long v46 = &v44[4 * v43];
  *long long v45 = 8;
  long long v38 = v45 + 1;
  if (v21 == v39) {
    goto LABEL_66;
  }
  unint64_t v47 = v21 - v39 - 4;
  if (v47 < 0x2C)
  {
    long long v48 = v21;
    goto LABEL_65;
  }
  if ((unint64_t)(v39 - v44) < 0x20)
  {
    long long v48 = v21;
    do
    {
LABEL_65:
      int v55 = *((_DWORD *)v48 - 1);
      v48 -= 4;
      *--long long v45 = v55;
    }
    while (v48 != v39);
    goto LABEL_66;
  }
  uint64_t v49 = (v47 >> 2) + 1;
  uint64_t v50 = 4 * (v49 & 0x7FFFFFFFFFFFFFF8);
  long long v48 = &v21[-v50];
  long long v45 = (_DWORD *)((char *)v45 - v50);
  unint64_t v51 = &v44[4 * v40 - 16];
  unint64_t v52 = v21 - 16;
  uint64_t v53 = v49 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v54 = *(_OWORD *)v52;
    *(v51 - 1) = *((_OWORD *)v52 - 1);
    _OWORD *v51 = v54;
    v51 -= 2;
    v52 -= 32;
    v53 -= 8;
  }
  while (v53);
  if (v49 != (v49 & 0x7FFFFFFFFFFFFFF8)) {
    goto LABEL_65;
  }
LABEL_66:
  *((void *)this + 56) = v45;
  *((void *)this + 57) = v38;
  *((void *)this + 58) = v46;
  if (v39) {
    operator delete(v39);
  }
LABEL_68:
  *((void *)this + 57) = v38;
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    stat v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    stat v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void RNBRemote::RNBRemote(RNBRemote *this)
{
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(void *)this = off_100068D40;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  PThreadEvent::PThreadEvent((RNBRemote *)((char *)this + 120), 0, 255);
  *((_DWORD *)this + 76) = 0;
  *((void *)this + 56) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((unsigned char *)this + 440) = 0;
  *((_DWORD *)this + 118) = -1;
  *((_WORD *)this + 238) = 0;
  *((void *)this + 60) = 0;
  DNBTimer::DNBTimer((RNBRemote *)((char *)this + 488), 1);
  *((void *)this + 66) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((void *)this + 67) = -1;
  *((void *)this + 68) = -1;
  if (pthread_mutex_init((pthread_mutex_t *)((char *)this + 552), 0)) {
    PThreadEvent::PThreadEvent();
  }
  *((_WORD *)this + 324) = -1;
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)((char *)this + 616) = v2;
  *(_OWORD *)((char *)this + 632) = v2;
  *((void *)this + 82) = -1;
  *((_DWORD *)this + 166) = -1;
  *(_OWORD *)((char *)this + 668) = 0u;
  *(_OWORD *)((char *)this + 684) = 0u;
  *(_OWORD *)((char *)this + 700) = 0u;
  *(_OWORD *)((char *)this + 716) = 0u;
  *(_OWORD *)((char *)this + 732) = 0u;
  *(_OWORD *)((char *)this + 748) = 0u;
  *(_OWORD *)((char *)this + 760) = 0u;
  *((void *)this + 97) = 395;
  *((void *)this + 98) = 384;
  *((unsigned char *)this + 792) = 0;
  *((_DWORD *)this + 199) = 4;
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("%s", "RNBRemote::RNBRemote()");
  }
  RNBRemote::CreatePacketTable(this);
}

void RNBRemote::CreatePacketTable(RNBRemote *this)
{
  long long v2 = (void **)((char *)this + 672);
  RNBRemote::Packet::Packet((uint64_t)&v634, 1, 0, 0, 0, 0, "+", "ACK");
  int v3 = (char **)((char *)this + 680);
  unint64_t v4 = *((void *)this + 85);
  if (v4 < *((void *)this + 86))
  {
    long long v5 = v634;
    long long v6 = v635;
    *(void *)(v4 + 32) = v636;
    *(_OWORD *)unint64_t v4 = v5;
    *(_OWORD *)(v4 + 16) = v6;
    long long v7 = *(_OWORD *)__p;
    *(void *)(v4 + 56) = v638;
    *(_OWORD *)(v4 + 40) = v7;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v8 = v640;
    *(_OWORD *)(v4 + 64) = *(_OWORD *)v639;
    *(void *)(v4 + 80) = v8;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v4 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  uint64_t v9 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v10 = SHIBYTE(v640);
  *int v3 = v9;
  if ((v10 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_6:
  }
    operator delete(__p[0]);
LABEL_7:
  RNBRemote::Packet::Packet((uint64_t)&v634, 2, 0, 0, 0, 0, "-", "!ACK");
  unint64_t v11 = *((void *)this + 85);
  if (v11 < *((void *)this + 86))
  {
    long long v12 = v634;
    long long v13 = v635;
    *(void *)(v11 + 32) = v636;
    *(_OWORD *)unint64_t v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
    long long v14 = *(_OWORD *)__p;
    *(void *)(v11 + 56) = v638;
    *(_OWORD *)(v11 + 40) = v14;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v15 = v640;
    *(_OWORD *)(v11 + 64) = *(_OWORD *)v639;
    *(void *)(v11 + 80) = v15;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v11 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  unint64_t v16 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v17 = SHIBYTE(v640);
  *int v3 = v16;
  if ((v17 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_12:
  }
    operator delete(__p[0]);
LABEL_13:
  RNBRemote::Packet::Packet((uint64_t)&v634, 17, (uint64_t)RNBRemote::HandlePacket_m, 0, 0, 0, "m", "Read memory");
  unint64_t v18 = *((void *)this + 85);
  if (v18 < *((void *)this + 86))
  {
    long long v19 = v634;
    long long v20 = v635;
    *(void *)(v18 + 32) = v636;
    *(_OWORD *)unint64_t v18 = v19;
    *(_OWORD *)(v18 + 16) = v20;
    long long v21 = *(_OWORD *)__p;
    *(void *)(v18 + 56) = v638;
    *(_OWORD *)(v18 + 40) = v21;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v22 = v640;
    *(_OWORD *)(v18 + 64) = *(_OWORD *)v639;
    *(void *)(v18 + 80) = v22;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v18 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v23 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v24 = SHIBYTE(v640);
  *int v3 = v23;
  if ((v24 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_18:
  }
    operator delete(__p[0]);
LABEL_19:
  RNBRemote::Packet::Packet((uint64_t)&v634, 19, (uint64_t)RNBRemote::HandlePacket_p, 0, 0, 0, "p", "Read one register");
  unint64_t v25 = *((void *)this + 85);
  if (v25 < *((void *)this + 86))
  {
    long long v26 = v634;
    long long v27 = v635;
    *(void *)(v25 + 32) = v636;
    *(_OWORD *)unint64_t v25 = v26;
    *(_OWORD *)(v25 + 16) = v27;
    long long v28 = *(_OWORD *)__p;
    *(void *)(v25 + 56) = v638;
    *(_OWORD *)(v25 + 40) = v28;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v29 = v640;
    *(_OWORD *)(v25 + 64) = *(_OWORD *)v639;
    *(void *)(v25 + 80) = v29;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v25 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  long long v30 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v31 = SHIBYTE(v640);
  *int v3 = v30;
  if ((v31 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_24:
  }
    operator delete(__p[0]);
LABEL_25:
  RNBRemote::Packet::Packet((uint64_t)&v634, 11, (uint64_t)RNBRemote::HandlePacket_g, 0, 0, 0, "g", "Read registers");
  unint64_t v32 = *((void *)this + 85);
  if (v32 < *((void *)this + 86))
  {
    long long v33 = v634;
    long long v34 = v635;
    *(void *)(v32 + 32) = v636;
    *(_OWORD *)unint64_t v32 = v33;
    *(_OWORD *)(v32 + 16) = v34;
    long long v35 = *(_OWORD *)__p;
    *(void *)(v32 + 56) = v638;
    *(_OWORD *)(v32 + 40) = v35;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v36 = v640;
    *(_OWORD *)(v32 + 64) = *(_OWORD *)v639;
    *(void *)(v32 + 80) = v36;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v32 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  int v37 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v38 = SHIBYTE(v640);
  *int v3 = v37;
  if ((v38 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_30:
  }
    operator delete(__p[0]);
LABEL_31:
  RNBRemote::Packet::Packet((uint64_t)&v634, 18, (uint64_t)RNBRemote::HandlePacket_M, 0, 0, 0, "M", "Write memory");
  unint64_t v39 = *((void *)this + 85);
  if (v39 < *((void *)this + 86))
  {
    long long v40 = v634;
    long long v41 = v635;
    *(void *)(v39 + 32) = v636;
    *(_OWORD *)unint64_t v39 = v40;
    *(_OWORD *)(v39 + 16) = v41;
    long long v42 = *(_OWORD *)__p;
    *(void *)(v39 + 56) = v638;
    *(_OWORD *)(v39 + 40) = v42;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v43 = v640;
    *(_OWORD *)(v39 + 64) = *(_OWORD *)v639;
    *(void *)(v39 + 80) = v43;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v39 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  long long v44 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v45 = SHIBYTE(v640);
  *int v3 = v44;
  if ((v45 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_36:
  }
    operator delete(__p[0]);
LABEL_37:
  RNBRemote::Packet::Packet((uint64_t)&v634, 20, (uint64_t)RNBRemote::HandlePacket_P, 0, 0, 0, "P", "Write one register");
  unint64_t v46 = *((void *)this + 85);
  if (v46 < *((void *)this + 86))
  {
    long long v47 = v634;
    long long v48 = v635;
    *(void *)(v46 + 32) = v636;
    *(_OWORD *)unint64_t v46 = v47;
    *(_OWORD *)(v46 + 16) = v48;
    long long v49 = *(_OWORD *)__p;
    *(void *)(v46 + 56) = v638;
    *(_OWORD *)(v46 + 40) = v49;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v50 = v640;
    *(_OWORD *)(v46 + 64) = *(_OWORD *)v639;
    *(void *)(v46 + 80) = v50;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v46 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  unint64_t v51 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v52 = SHIBYTE(v640);
  *int v3 = v51;
  if ((v52 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_42:
  }
    operator delete(__p[0]);
LABEL_43:
  RNBRemote::Packet::Packet((uint64_t)&v634, 12, (uint64_t)RNBRemote::HandlePacket_G, 0, 0, 0, "G", "Write registers");
  unint64_t v53 = *((void *)this + 85);
  if (v53 < *((void *)this + 86))
  {
    long long v54 = v634;
    long long v55 = v635;
    *(void *)(v53 + 32) = v636;
    *(_OWORD *)unint64_t v53 = v54;
    *(_OWORD *)(v53 + 16) = v55;
    long long v56 = *(_OWORD *)__p;
    *(void *)(v53 + 56) = v638;
    *(_OWORD *)(v53 + 40) = v56;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v57 = v640;
    *(_OWORD *)(v53 + 64) = *(_OWORD *)v639;
    *(void *)(v53 + 80) = v57;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v53 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  uint64_t v58 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v59 = SHIBYTE(v640);
  *int v3 = v58;
  if ((v59 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_48:
  }
    operator delete(__p[0]);
LABEL_49:
  RNBRemote::Packet::Packet((uint64_t)&v634, 34, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "Z0", "Insert memory breakpoint");
  unint64_t v60 = *((void *)this + 85);
  if (v60 < *((void *)this + 86))
  {
    long long v61 = v634;
    long long v62 = v635;
    *(void *)(v60 + 32) = v636;
    *(_OWORD *)unint64_t v60 = v61;
    *(_OWORD *)(v60 + 16) = v62;
    long long v63 = *(_OWORD *)__p;
    *(void *)(v60 + 56) = v638;
    *(_OWORD *)(v60 + 40) = v63;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v64 = v640;
    *(_OWORD *)(v60 + 64) = *(_OWORD *)v639;
    *(void *)(v60 + 80) = v64;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v60 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  int v65 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v66 = SHIBYTE(v640);
  *int v3 = v65;
  if ((v66 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_54:
  }
    operator delete(__p[0]);
LABEL_55:
  RNBRemote::Packet::Packet((uint64_t)&v634, 35, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "z0", "Remove memory breakpoint");
  unint64_t v67 = *((void *)this + 85);
  if (v67 < *((void *)this + 86))
  {
    long long v68 = v634;
    long long v69 = v635;
    *(void *)(v67 + 32) = v636;
    *(_OWORD *)unint64_t v67 = v68;
    *(_OWORD *)(v67 + 16) = v69;
    long long v70 = *(_OWORD *)__p;
    *(void *)(v67 + 56) = v638;
    *(_OWORD *)(v67 + 40) = v70;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v71 = v640;
    *(_OWORD *)(v67 + 64) = *(_OWORD *)v639;
    *(void *)(v67 + 80) = v71;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v67 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  BOOL v72 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v73 = SHIBYTE(v640);
  *int v3 = v72;
  if ((v73 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_60:
  }
    operator delete(__p[0]);
LABEL_61:
  RNBRemote::Packet::Packet((uint64_t)&v634, 22, (uint64_t)RNBRemote::HandlePacket_s, 0, 0, 0, "s", "Single step");
  unint64_t v74 = *((void *)this + 85);
  if (v74 < *((void *)this + 86))
  {
    long long v75 = v634;
    long long v76 = v635;
    *(void *)(v74 + 32) = v636;
    *(_OWORD *)unint64_t v74 = v75;
    *(_OWORD *)(v74 + 16) = v76;
    long long v77 = *(_OWORD *)__p;
    *(void *)(v74 + 56) = v638;
    *(_OWORD *)(v74 + 40) = v77;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v78 = v640;
    *(_OWORD *)(v74 + 64) = *(_OWORD *)v639;
    *(void *)(v74 + 80) = v78;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v74 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  uint64_t v79 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v80 = SHIBYTE(v640);
  *int v3 = v79;
  if ((v80 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_66:
  }
    operator delete(__p[0]);
LABEL_67:
  RNBRemote::Packet::Packet((uint64_t)&v634, 8, (uint64_t)RNBRemote::HandlePacket_c, 0, 0, 0, "c", "continue");
  unint64_t v81 = *((void *)this + 85);
  if (v81 < *((void *)this + 86))
  {
    long long v82 = v634;
    long long v83 = v635;
    *(void *)(v81 + 32) = v636;
    *(_OWORD *)unint64_t v81 = v82;
    *(_OWORD *)(v81 + 16) = v83;
    long long v84 = *(_OWORD *)__p;
    *(void *)(v81 + 56) = v638;
    *(_OWORD *)(v81 + 40) = v84;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v85 = v640;
    *(_OWORD *)(v81 + 64) = *(_OWORD *)v639;
    *(void *)(v81 + 80) = v85;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v81 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  uint64_t v86 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v87 = SHIBYTE(v640);
  *int v3 = v86;
  if ((v87 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_72:
  }
    operator delete(__p[0]);
LABEL_73:
  RNBRemote::Packet::Packet((uint64_t)&v634, 23, (uint64_t)RNBRemote::HandlePacket_S, 0, 0, 0, "S", "Single step with signal");
  unint64_t v88 = *((void *)this + 85);
  if (v88 < *((void *)this + 86))
  {
    long long v89 = v634;
    long long v90 = v635;
    *(void *)(v88 + 32) = v636;
    *(_OWORD *)unint64_t v88 = v89;
    *(_OWORD *)(v88 + 16) = v90;
    long long v91 = *(_OWORD *)__p;
    *(void *)(v88 + 56) = v638;
    *(_OWORD *)(v88 + 40) = v91;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v92 = v640;
    *(_OWORD *)(v88 + 64) = *(_OWORD *)v639;
    *(void *)(v88 + 80) = v92;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v88 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }
  uint64_t v93 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v94 = SHIBYTE(v640);
  *int v3 = v93;
  if ((v94 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_78:
  }
    operator delete(__p[0]);
LABEL_79:
  RNBRemote::Packet::Packet((uint64_t)&v634, 13, (uint64_t)RNBRemote::HandlePacket_H, 0, 0, 0, "H", "Set thread");
  unint64_t v95 = *((void *)this + 85);
  if (v95 < *((void *)this + 86))
  {
    long long v96 = v634;
    long long v97 = v635;
    *(void *)(v95 + 32) = v636;
    *(_OWORD *)unint64_t v95 = v96;
    *(_OWORD *)(v95 + 16) = v97;
    long long v98 = *(_OWORD *)__p;
    *(void *)(v95 + 56) = v638;
    *(_OWORD *)(v95 + 40) = v98;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v99 = v640;
    *(_OWORD *)(v95 + 64) = *(_OWORD *)v639;
    *(void *)(v95 + 80) = v99;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v95 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  uint64_t v100 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v101 = SHIBYTE(v640);
  *int v3 = v100;
  if ((v101 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_84:
  }
    operator delete(__p[0]);
LABEL_85:
  RNBRemote::Packet::Packet((uint64_t)&v634, 3, (uint64_t)RNBRemote::HandlePacket_last_signal, 0, (uint64_t)RNBRemote::HandlePacket_stop_process, 0, "\x03", "^C");
  unint64_t v102 = *((void *)this + 85);
  if (v102 < *((void *)this + 86))
  {
    long long v103 = v634;
    long long v104 = v635;
    *(void *)(v102 + 32) = v636;
    *(_OWORD *)unint64_t v102 = v103;
    *(_OWORD *)(v102 + 16) = v104;
    long long v105 = *(_OWORD *)__p;
    *(void *)(v102 + 56) = v638;
    *(_OWORD *)(v102 + 40) = v105;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v106 = v640;
    *(_OWORD *)(v102 + 64) = *(_OWORD *)v639;
    *(void *)(v102 + 80) = v106;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v102 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }
  uint64_t v107 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v108 = SHIBYTE(v640);
  *int v3 = v107;
  if ((v108 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_90:
  }
    operator delete(__p[0]);
LABEL_91:
  RNBRemote::Packet::Packet((uint64_t)&v634, 5, (uint64_t)RNBRemote::HandlePacket_last_signal, 0, 0, 0, "?", "Why did target halt");
  unint64_t v109 = *((void *)this + 85);
  if (v109 < *((void *)this + 86))
  {
    long long v110 = v634;
    long long v111 = v635;
    *(void *)(v109 + 32) = v636;
    *(_OWORD *)unint64_t v109 = v110;
    *(_OWORD *)(v109 + 16) = v111;
    long long v112 = *(_OWORD *)__p;
    *(void *)(v109 + 56) = v638;
    *(_OWORD *)(v109 + 40) = v112;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v113 = v640;
    *(_OWORD *)(v109 + 64) = *(_OWORD *)v639;
    *(void *)(v109 + 80) = v113;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v109 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }
  uint64_t v114 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v115 = SHIBYTE(v640);
  *int v3 = v114;
  if ((v115 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_96:
  }
    operator delete(__p[0]);
LABEL_97:
  RNBRemote::Packet::Packet((uint64_t)&v634, 6, (uint64_t)RNBRemote::HandlePacket_A, 0, 0, 0, "A", "Set argv");
  unint64_t v116 = *((void *)this + 85);
  if (v116 < *((void *)this + 86))
  {
    long long v117 = v634;
    long long v118 = v635;
    *(void *)(v116 + 32) = v636;
    *(_OWORD *)unint64_t v116 = v117;
    *(_OWORD *)(v116 + 16) = v118;
    long long v119 = *(_OWORD *)__p;
    *(void *)(v116 + 56) = v638;
    *(_OWORD *)(v116 + 40) = v119;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v120 = v640;
    *(_OWORD *)(v116 + 64) = *(_OWORD *)v639;
    *(void *)(v116 + 80) = v120;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v116 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  uint64_t v121 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v122 = SHIBYTE(v640);
  *int v3 = v121;
  if ((v122 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_102:
  }
    operator delete(__p[0]);
LABEL_103:
  RNBRemote::Packet::Packet((uint64_t)&v634, 9, (uint64_t)RNBRemote::HandlePacket_C, 0, 0, 0, "C", "Continue with signal");
  unint64_t v123 = *((void *)this + 85);
  if (v123 < *((void *)this + 86))
  {
    long long v124 = v634;
    long long v125 = v635;
    *(void *)(v123 + 32) = v636;
    *(_OWORD *)unint64_t v123 = v124;
    *(_OWORD *)(v123 + 16) = v125;
    long long v126 = *(_OWORD *)__p;
    *(void *)(v123 + 56) = v638;
    *(_OWORD *)(v123 + 40) = v126;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v127 = v640;
    *(_OWORD *)(v123 + 64) = *(_OWORD *)v639;
    *(void *)(v123 + 80) = v127;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v123 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }
  uint64_t v128 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v129 = SHIBYTE(v640);
  *int v3 = v128;
  if ((v129 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_108:
  }
    operator delete(__p[0]);
LABEL_109:
  RNBRemote::Packet::Packet((uint64_t)&v634, 10, (uint64_t)RNBRemote::HandlePacket_D, 0, 0, 0, "D", "Detach gdb from remote system");
  unint64_t v130 = *((void *)this + 85);
  if (v130 < *((void *)this + 86))
  {
    long long v131 = v634;
    long long v132 = v635;
    *(void *)(v130 + 32) = v636;
    *(_OWORD *)unint64_t v130 = v131;
    *(_OWORD *)(v130 + 16) = v132;
    long long v133 = *(_OWORD *)__p;
    *(void *)(v130 + 56) = v638;
    *(_OWORD *)(v130 + 40) = v133;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v134 = v640;
    *(_OWORD *)(v130 + 64) = *(_OWORD *)v639;
    *(void *)(v130 + 80) = v134;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v130 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }
  uint64_t v135 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v136 = SHIBYTE(v640);
  *int v3 = v135;
  if ((v136 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_114:
  }
    operator delete(__p[0]);
LABEL_115:
  RNBRemote::Packet::Packet((uint64_t)&v634, 16, (uint64_t)RNBRemote::HandlePacket_k, 0, 0, 0, "k", "Kill");
  unint64_t v137 = *((void *)this + 85);
  if (v137 < *((void *)this + 86))
  {
    long long v138 = v634;
    long long v139 = v635;
    *(void *)(v137 + 32) = v636;
    *(_OWORD *)unint64_t v137 = v138;
    *(_OWORD *)(v137 + 16) = v139;
    long long v140 = *(_OWORD *)__p;
    *(void *)(v137 + 56) = v638;
    *(_OWORD *)(v137 + 40) = v140;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v141 = v640;
    *(_OWORD *)(v137 + 64) = *(_OWORD *)v639;
    *(void *)(v137 + 80) = v141;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v137 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
  uint64_t v142 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v143 = SHIBYTE(v640);
  *int v3 = v142;
  if ((v143 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_120:
  }
    operator delete(__p[0]);
LABEL_121:
  RNBRemote::Packet::Packet((uint64_t)&v634, 25, (uint64_t)RNBRemote::HandlePacket_T, 0, 0, 0, "T", "Is thread alive");
  unint64_t v144 = *((void *)this + 85);
  if (v144 < *((void *)this + 86))
  {
    long long v145 = v634;
    long long v146 = v635;
    *(void *)(v144 + 32) = v636;
    *(_OWORD *)unint64_t v144 = v145;
    *(_OWORD *)(v144 + 16) = v146;
    long long v147 = *(_OWORD *)__p;
    *(void *)(v144 + 56) = v638;
    *(_OWORD *)(v144 + 40) = v147;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v148 = v640;
    *(_OWORD *)(v144 + 64) = *(_OWORD *)v639;
    *(void *)(v144 + 80) = v148;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v144 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }
  uint64_t v149 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v150 = SHIBYTE(v640);
  *int v3 = v149;
  if ((v150 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_126:
  }
    operator delete(__p[0]);
LABEL_127:
  RNBRemote::Packet::Packet((uint64_t)&v634, 58, (uint64_t)RNBRemote::HandlePacket_qSupported, 0, 0, 0, "qSupported", "Query about supported features");
  unint64_t v151 = *((void *)this + 85);
  if (v151 < *((void *)this + 86))
  {
    long long v152 = v634;
    long long v153 = v635;
    *(void *)(v151 + 32) = v636;
    *(_OWORD *)unint64_t v151 = v152;
    *(_OWORD *)(v151 + 16) = v153;
    long long v154 = *(_OWORD *)__p;
    *(void *)(v151 + 56) = v638;
    *(_OWORD *)(v151 + 40) = v154;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v155 = v640;
    *(_OWORD *)(v151 + 64) = *(_OWORD *)v639;
    *(void *)(v151 + 80) = v155;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v151 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_133;
    }
    goto LABEL_132;
  }
  size_t v156 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v157 = SHIBYTE(v640);
  *int v3 = v156;
  if ((v157 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_133;
    }
    goto LABEL_132;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_132:
  }
    operator delete(__p[0]);
LABEL_133:
  RNBRemote::Packet::Packet((uint64_t)&v634, 26, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vAttach", "Attach to a new process");
  unint64_t v158 = *((void *)this + 85);
  if (v158 < *((void *)this + 86))
  {
    long long v159 = v634;
    long long v160 = v635;
    *(void *)(v158 + 32) = v636;
    *(_OWORD *)unint64_t v158 = v159;
    *(_OWORD *)(v158 + 16) = v160;
    long long v161 = *(_OWORD *)__p;
    *(void *)(v158 + 56) = v638;
    *(_OWORD *)(v158 + 40) = v161;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v162 = v640;
    *(_OWORD *)(v158 + 64) = *(_OWORD *)v639;
    *(void *)(v158 + 80) = v162;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v158 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_139;
    }
    goto LABEL_138;
  }
  std::string::size_type v163 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v164 = SHIBYTE(v640);
  *int v3 = v163;
  if ((v164 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_139;
    }
    goto LABEL_138;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_138:
  }
    operator delete(__p[0]);
LABEL_139:
  RNBRemote::Packet::Packet((uint64_t)&v634, 27, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vAttachWait", "Wait for a process to start up then attach to it");
  unint64_t v165 = *((void *)this + 85);
  if (v165 < *((void *)this + 86))
  {
    long long v166 = v634;
    long long v167 = v635;
    *(void *)(v165 + 32) = v636;
    *(_OWORD *)unint64_t v165 = v166;
    *(_OWORD *)(v165 + 16) = v167;
    long long v168 = *(_OWORD *)__p;
    *(void *)(v165 + 56) = v638;
    *(_OWORD *)(v165 + 40) = v168;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v169 = v640;
    *(_OWORD *)(v165 + 64) = *(_OWORD *)v639;
    *(void *)(v165 + 80) = v169;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v165 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_145;
    }
    goto LABEL_144;
  }
  uint64_t v170 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v171 = SHIBYTE(v640);
  *int v3 = v170;
  if ((v171 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_145;
    }
    goto LABEL_144;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_144:
  }
    operator delete(__p[0]);
LABEL_145:
  RNBRemote::Packet::Packet((uint64_t)&v634, 28, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vAttachOrWait", "Attach to the process or if it doesn't exist, wait for the process to start up then attach to it");
  unint64_t v172 = *((void *)this + 85);
  if (v172 < *((void *)this + 86))
  {
    long long v173 = v634;
    long long v174 = v635;
    *(void *)(v172 + 32) = v636;
    *(_OWORD *)unint64_t v172 = v173;
    *(_OWORD *)(v172 + 16) = v174;
    long long v175 = *(_OWORD *)__p;
    *(void *)(v172 + 56) = v638;
    *(_OWORD *)(v172 + 40) = v175;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v176 = v640;
    *(_OWORD *)(v172 + 64) = *(_OWORD *)v639;
    *(void *)(v172 + 80) = v176;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v172 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_151;
    }
    goto LABEL_150;
  }
  uint64_t v177 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v178 = SHIBYTE(v640);
  *int v3 = v177;
  if ((v178 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_151;
    }
    goto LABEL_150;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_150:
  }
    operator delete(__p[0]);
LABEL_151:
  RNBRemote::Packet::Packet((uint64_t)&v634, 29, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vAttachName", "Attach to an existing process by name");
  unint64_t v179 = *((void *)this + 85);
  if (v179 < *((void *)this + 86))
  {
    long long v180 = v634;
    long long v181 = v635;
    *(void *)(v179 + 32) = v636;
    *(_OWORD *)unint64_t v179 = v180;
    *(_OWORD *)(v179 + 16) = v181;
    long long v182 = *(_OWORD *)__p;
    *(void *)(v179 + 56) = v638;
    *(_OWORD *)(v179 + 40) = v182;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v183 = v640;
    *(_OWORD *)(v179 + 64) = *(_OWORD *)v639;
    *(void *)(v179 + 80) = v183;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v179 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_157;
    }
    goto LABEL_156;
  }
  v184 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v185 = SHIBYTE(v640);
  *int v3 = v184;
  if ((v185 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_157;
    }
    goto LABEL_156;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_156:
  }
    operator delete(__p[0]);
LABEL_157:
  RNBRemote::Packet::Packet((uint64_t)&v634, 31, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vCont;",
    "Verbose resume with thread actions");
  unint64_t v186 = *((void *)this + 85);
  if (v186 < *((void *)this + 86))
  {
    long long v187 = v634;
    long long v188 = v635;
    *(void *)(v186 + 32) = v636;
    *(_OWORD *)unint64_t v186 = v187;
    *(_OWORD *)(v186 + 16) = v188;
    long long v189 = *(_OWORD *)__p;
    *(void *)(v186 + 56) = v638;
    *(_OWORD *)(v186 + 40) = v189;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v190 = v640;
    *(_OWORD *)(v186 + 64) = *(_OWORD *)v639;
    *(void *)(v186 + 80) = v190;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v186 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }
  v191 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v192 = SHIBYTE(v640);
  *int v3 = v191;
  if ((v192 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_162:
  }
    operator delete(__p[0]);
LABEL_163:
  RNBRemote::Packet::Packet((uint64_t)&v634, 31, (uint64_t)RNBRemote::HandlePacket_v, 0, 0, 0, "vCont?", "List valid continue-with-thread-actions actions");
  unint64_t v193 = *((void *)this + 85);
  if (v193 < *((void *)this + 86))
  {
    long long v194 = v634;
    long long v195 = v635;
    *(void *)(v193 + 32) = v636;
    *(_OWORD *)unint64_t v193 = v194;
    *(_OWORD *)(v193 + 16) = v195;
    long long v196 = *(_OWORD *)__p;
    *(void *)(v193 + 56) = v638;
    *(_OWORD *)(v193 + 40) = v196;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v197 = v640;
    *(_OWORD *)(v193 + 64) = *(_OWORD *)v639;
    *(void *)(v193 + 80) = v197;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v193 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_169;
    }
    goto LABEL_168;
  }
  std::string::size_type v198 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v199 = SHIBYTE(v640);
  *int v3 = v198;
  if ((v199 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_169;
    }
    goto LABEL_168;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_168:
  }
    operator delete(__p[0]);
LABEL_169:
  RNBRemote::Packet::Packet((uint64_t)&v634, 32, (uint64_t)RNBRemote::HandlePacket_x, 0, 0, 0, "x", "Read data from memory");
  unint64_t v200 = *((void *)this + 85);
  if (v200 < *((void *)this + 86))
  {
    long long v201 = v634;
    long long v202 = v635;
    *(void *)(v200 + 32) = v636;
    *(_OWORD *)unint64_t v200 = v201;
    *(_OWORD *)(v200 + 16) = v202;
    long long v203 = *(_OWORD *)__p;
    *(void *)(v200 + 56) = v638;
    *(_OWORD *)(v200 + 40) = v203;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v204 = v640;
    *(_OWORD *)(v200 + 64) = *(_OWORD *)v639;
    *(void *)(v200 + 80) = v204;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v200 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_175;
    }
    goto LABEL_174;
  }
  uint64_t v205 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v206 = SHIBYTE(v640);
  *int v3 = v205;
  if ((v206 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_175;
    }
    goto LABEL_174;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_174:
  }
    operator delete(__p[0]);
LABEL_175:
  RNBRemote::Packet::Packet((uint64_t)&v634, 33, (uint64_t)RNBRemote::HandlePacket_X, 0, 0, 0, "X", "Write data to memory");
  unint64_t v207 = *((void *)this + 85);
  if (v207 < *((void *)this + 86))
  {
    long long v208 = v634;
    long long v209 = v635;
    *(void *)(v207 + 32) = v636;
    *(_OWORD *)unint64_t v207 = v208;
    *(_OWORD *)(v207 + 16) = v209;
    long long v210 = *(_OWORD *)__p;
    *(void *)(v207 + 56) = v638;
    *(_OWORD *)(v207 + 40) = v210;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v211 = v640;
    *(_OWORD *)(v207 + 64) = *(_OWORD *)v639;
    *(void *)(v207 + 80) = v211;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v207 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_180;
  }
  uint64_t v212 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v213 = SHIBYTE(v640);
  *int v3 = v212;
  if ((v213 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_180;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_180:
  }
    operator delete(__p[0]);
LABEL_181:
  RNBRemote::Packet::Packet((uint64_t)&v634, 36, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "Z1", "Insert hardware breakpoint");
  unint64_t v214 = *((void *)this + 85);
  if (v214 < *((void *)this + 86))
  {
    long long v215 = v634;
    long long v216 = v635;
    *(void *)(v214 + 32) = v636;
    *(_OWORD *)unint64_t v214 = v215;
    *(_OWORD *)(v214 + 16) = v216;
    long long v217 = *(_OWORD *)__p;
    *(void *)(v214 + 56) = v638;
    *(_OWORD *)(v214 + 40) = v217;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v218 = v640;
    *(_OWORD *)(v214 + 64) = *(_OWORD *)v639;
    *(void *)(v214 + 80) = v218;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v214 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_187;
    }
    goto LABEL_186;
  }
  uint64_t v219 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v220 = SHIBYTE(v640);
  *int v3 = v219;
  if ((v220 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_187;
    }
    goto LABEL_186;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_186:
  }
    operator delete(__p[0]);
LABEL_187:
  RNBRemote::Packet::Packet((uint64_t)&v634, 37, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "z1", "Remove hardware breakpoint");
  unint64_t v221 = *((void *)this + 85);
  if (v221 < *((void *)this + 86))
  {
    long long v222 = v634;
    long long v223 = v635;
    *(void *)(v221 + 32) = v636;
    *(_OWORD *)unint64_t v221 = v222;
    *(_OWORD *)(v221 + 16) = v223;
    long long v224 = *(_OWORD *)__p;
    *(void *)(v221 + 56) = v638;
    *(_OWORD *)(v221 + 40) = v224;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v225 = v640;
    *(_OWORD *)(v221 + 64) = *(_OWORD *)v639;
    *(void *)(v221 + 80) = v225;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v221 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_193;
    }
    goto LABEL_192;
  }
  v226 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v227 = SHIBYTE(v640);
  *int v3 = v226;
  if ((v227 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_193;
    }
    goto LABEL_192;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_192:
  }
    operator delete(__p[0]);
LABEL_193:
  RNBRemote::Packet::Packet((uint64_t)&v634, 38, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "Z2", "Insert write watchpoint");
  unint64_t v228 = *((void *)this + 85);
  if (v228 < *((void *)this + 86))
  {
    long long v229 = v634;
    long long v230 = v635;
    *(void *)(v228 + 32) = v636;
    *(_OWORD *)unint64_t v228 = v229;
    *(_OWORD *)(v228 + 16) = v230;
    long long v231 = *(_OWORD *)__p;
    *(void *)(v228 + 56) = v638;
    *(_OWORD *)(v228 + 40) = v231;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v232 = v640;
    *(_OWORD *)(v228 + 64) = *(_OWORD *)v639;
    *(void *)(v228 + 80) = v232;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v228 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_199;
    }
    goto LABEL_198;
  }
  uint64_t v233 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v234 = SHIBYTE(v640);
  *int v3 = v233;
  if ((v234 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_199;
    }
    goto LABEL_198;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_198:
  }
    operator delete(__p[0]);
LABEL_199:
  RNBRemote::Packet::Packet((uint64_t)&v634, 39, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "z2", "Remove write watchpoint");
  unint64_t v235 = *((void *)this + 85);
  if (v235 < *((void *)this + 86))
  {
    long long v236 = v634;
    long long v237 = v635;
    *(void *)(v235 + 32) = v636;
    *(_OWORD *)unint64_t v235 = v236;
    *(_OWORD *)(v235 + 16) = v237;
    long long v238 = *(_OWORD *)__p;
    *(void *)(v235 + 56) = v638;
    *(_OWORD *)(v235 + 40) = v238;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v239 = v640;
    *(_OWORD *)(v235 + 64) = *(_OWORD *)v639;
    *(void *)(v235 + 80) = v239;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v235 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_205;
    }
    goto LABEL_204;
  }
  uint64_t v240 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v241 = SHIBYTE(v640);
  *int v3 = v240;
  if ((v241 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_205;
    }
    goto LABEL_204;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_204:
  }
    operator delete(__p[0]);
LABEL_205:
  RNBRemote::Packet::Packet((uint64_t)&v634, 40, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "Z3", "Insert read watchpoint");
  unint64_t v242 = *((void *)this + 85);
  if (v242 < *((void *)this + 86))
  {
    long long v243 = v634;
    long long v244 = v635;
    *(void *)(v242 + 32) = v636;
    *(_OWORD *)unint64_t v242 = v243;
    *(_OWORD *)(v242 + 16) = v244;
    long long v245 = *(_OWORD *)__p;
    *(void *)(v242 + 56) = v638;
    *(_OWORD *)(v242 + 40) = v245;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v246 = v640;
    *(_OWORD *)(v242 + 64) = *(_OWORD *)v639;
    *(void *)(v242 + 80) = v246;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v242 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_211;
    }
    goto LABEL_210;
  }
  int v247 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v248 = SHIBYTE(v640);
  *int v3 = v247;
  if ((v248 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_211;
    }
    goto LABEL_210;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_210:
  }
    operator delete(__p[0]);
LABEL_211:
  RNBRemote::Packet::Packet((uint64_t)&v634, 41, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "z3", "Remove read watchpoint");
  unint64_t v249 = *((void *)this + 85);
  if (v249 < *((void *)this + 86))
  {
    long long v250 = v634;
    long long v251 = v635;
    *(void *)(v249 + 32) = v636;
    *(_OWORD *)unint64_t v249 = v250;
    *(_OWORD *)(v249 + 16) = v251;
    long long v252 = *(_OWORD *)__p;
    *(void *)(v249 + 56) = v638;
    *(_OWORD *)(v249 + 40) = v252;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v253 = v640;
    *(_OWORD *)(v249 + 64) = *(_OWORD *)v639;
    *(void *)(v249 + 80) = v253;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v249 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_217;
    }
    goto LABEL_216;
  }
  v254 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v255 = SHIBYTE(v640);
  *int v3 = v254;
  if ((v255 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_217;
    }
    goto LABEL_216;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_216:
  }
    operator delete(__p[0]);
LABEL_217:
  RNBRemote::Packet::Packet((uint64_t)&v634, 42, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "Z4", "Insert access watchpoint");
  unint64_t v256 = *((void *)this + 85);
  if (v256 < *((void *)this + 86))
  {
    long long v257 = v634;
    long long v258 = v635;
    *(void *)(v256 + 32) = v636;
    *(_OWORD *)unint64_t v256 = v257;
    *(_OWORD *)(v256 + 16) = v258;
    long long v259 = *(_OWORD *)__p;
    *(void *)(v256 + 56) = v638;
    *(_OWORD *)(v256 + 40) = v259;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v260 = v640;
    *(_OWORD *)(v256 + 64) = *(_OWORD *)v639;
    *(void *)(v256 + 80) = v260;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v256 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_223;
    }
    goto LABEL_222;
  }
  v261 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v262 = SHIBYTE(v640);
  *int v3 = v261;
  if ((v262 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_223;
    }
    goto LABEL_222;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_222:
  }
    operator delete(__p[0]);
LABEL_223:
  RNBRemote::Packet::Packet((uint64_t)&v634, 43, (uint64_t)RNBRemote::HandlePacket_z, 0, 0, 0, "z4", "Remove access watchpoint");
  unint64_t v263 = *((void *)this + 85);
  if (v263 < *((void *)this + 86))
  {
    long long v264 = v634;
    long long v265 = v635;
    *(void *)(v263 + 32) = v636;
    *(_OWORD *)unint64_t v263 = v264;
    *(_OWORD *)(v263 + 16) = v265;
    long long v266 = *(_OWORD *)__p;
    *(void *)(v263 + 56) = v638;
    *(_OWORD *)(v263 + 40) = v266;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v267 = v640;
    *(_OWORD *)(v263 + 64) = *(_OWORD *)v639;
    *(void *)(v263 + 80) = v267;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v263 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }
  uint64_t v268 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v269 = SHIBYTE(v640);
  *int v3 = v268;
  if ((v269 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_228:
  }
    operator delete(__p[0]);
LABEL_229:
  RNBRemote::Packet::Packet((uint64_t)&v634, 44, (uint64_t)RNBRemote::HandlePacket_qRcmd, 0, 0, 0, "qRcmd", "Monitor command");
  unint64_t v270 = *((void *)this + 85);
  if (v270 < *((void *)this + 86))
  {
    long long v271 = v634;
    long long v272 = v635;
    *(void *)(v270 + 32) = v636;
    *(_OWORD *)unint64_t v270 = v271;
    *(_OWORD *)(v270 + 16) = v272;
    long long v273 = *(_OWORD *)__p;
    *(void *)(v270 + 56) = v638;
    *(_OWORD *)(v270 + 40) = v273;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v274 = v640;
    *(_OWORD *)(v270 + 64) = *(_OWORD *)v639;
    *(void *)(v270 + 80) = v274;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v270 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_235;
    }
    goto LABEL_234;
  }
  uint64_t v275 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v276 = SHIBYTE(v640);
  *int v3 = v275;
  if ((v276 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_235;
    }
    goto LABEL_234;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_234:
  }
    operator delete(__p[0]);
LABEL_235:
  RNBRemote::Packet::Packet((uint64_t)&v634, 45, (uint64_t)RNBRemote::HandlePacket_qC, 0, 0, 0, "qC", "Query current thread ID");
  unint64_t v277 = *((void *)this + 85);
  if (v277 < *((void *)this + 86))
  {
    long long v278 = v634;
    long long v279 = v635;
    *(void *)(v277 + 32) = v636;
    *(_OWORD *)unint64_t v277 = v278;
    *(_OWORD *)(v277 + 16) = v279;
    long long v280 = *(_OWORD *)__p;
    *(void *)(v277 + 56) = v638;
    *(_OWORD *)(v277 + 40) = v280;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v281 = v640;
    *(_OWORD *)(v277 + 64) = *(_OWORD *)v639;
    *(void *)(v277 + 80) = v281;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v277 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_241;
    }
    goto LABEL_240;
  }
  v282 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v283 = SHIBYTE(v640);
  *int v3 = v282;
  if ((v283 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_241;
    }
    goto LABEL_240;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_240:
  }
    operator delete(__p[0]);
LABEL_241:
  RNBRemote::Packet::Packet((uint64_t)&v634, 47, (uint64_t)RNBRemote::HandlePacket_qEcho, 0, 0, 0, "qEcho:", "Echo the packet back to allow the debugger to sync up with this server");
  unint64_t v284 = *((void *)this + 85);
  if (v284 < *((void *)this + 86))
  {
    long long v285 = v634;
    long long v286 = v635;
    *(void *)(v284 + 32) = v636;
    *(_OWORD *)unint64_t v284 = v285;
    *(_OWORD *)(v284 + 16) = v286;
    long long v287 = *(_OWORD *)__p;
    *(void *)(v284 + 56) = v638;
    *(_OWORD *)(v284 + 40) = v287;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v288 = v640;
    *(_OWORD *)(v284 + 64) = *(_OWORD *)v639;
    *(void *)(v284 + 80) = v288;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v284 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_247;
    }
    goto LABEL_246;
  }
  uint64_t v289 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v290 = SHIBYTE(v640);
  *int v3 = v289;
  if ((v290 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_247;
    }
    goto LABEL_246;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_246:
  }
    operator delete(__p[0]);
LABEL_247:
  RNBRemote::Packet::Packet((uint64_t)&v634, 46, (uint64_t)RNBRemote::HandlePacket_qGetPid, 0, 0, 0, "qGetPid", "Query process id");
  unint64_t v291 = *((void *)this + 85);
  if (v291 < *((void *)this + 86))
  {
    long long v292 = v634;
    long long v293 = v635;
    *(void *)(v291 + 32) = v636;
    *(_OWORD *)unint64_t v291 = v292;
    *(_OWORD *)(v291 + 16) = v293;
    long long v294 = *(_OWORD *)__p;
    *(void *)(v291 + 56) = v638;
    *(_OWORD *)(v291 + 40) = v294;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v295 = v640;
    *(_OWORD *)(v291 + 64) = *(_OWORD *)v639;
    *(void *)(v291 + 80) = v295;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v291 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_253;
    }
    goto LABEL_252;
  }
  uint64_t v296 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v297 = SHIBYTE(v640);
  *int v3 = v296;
  if ((v297 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_253;
    }
    goto LABEL_252;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_252:
  }
    operator delete(__p[0]);
LABEL_253:
  RNBRemote::Packet::Packet((uint64_t)&v634, 48, (uint64_t)RNBRemote::HandlePacket_qThreadInfo, 0, 0, 0, "qfThreadInfo", "Get list of active threads (first req)");
  unint64_t v298 = *((void *)this + 85);
  if (v298 < *((void *)this + 86))
  {
    long long v299 = v634;
    long long v300 = v635;
    *(void *)(v298 + 32) = v636;
    *(_OWORD *)unint64_t v298 = v299;
    *(_OWORD *)(v298 + 16) = v300;
    long long v301 = *(_OWORD *)__p;
    *(void *)(v298 + 56) = v638;
    *(_OWORD *)(v298 + 40) = v301;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v302 = v640;
    *(_OWORD *)(v298 + 64) = *(_OWORD *)v639;
    *(void *)(v298 + 80) = v302;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v298 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_259;
    }
    goto LABEL_258;
  }
  uint64_t v303 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v304 = SHIBYTE(v640);
  *int v3 = v303;
  if ((v304 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_259;
    }
    goto LABEL_258;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_258:
  }
    operator delete(__p[0]);
LABEL_259:
  RNBRemote::Packet::Packet((uint64_t)&v634, 49, (uint64_t)RNBRemote::HandlePacket_qThreadInfo, 0, 0, 0, "qsThreadInfo", "Get list of active threads (subsequent req)");
  unint64_t v305 = *((void *)this + 85);
  if (v305 < *((void *)this + 86))
  {
    long long v306 = v634;
    long long v307 = v635;
    *(void *)(v305 + 32) = v636;
    *(_OWORD *)unint64_t v305 = v306;
    *(_OWORD *)(v305 + 16) = v307;
    long long v308 = *(_OWORD *)__p;
    *(void *)(v305 + 56) = v638;
    *(_OWORD *)(v305 + 40) = v308;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v309 = v640;
    *(_OWORD *)(v305 + 64) = *(_OWORD *)v639;
    *(void *)(v305 + 80) = v309;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v305 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_265;
    }
    goto LABEL_264;
  }
  v310 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v311 = SHIBYTE(v640);
  *int v3 = v310;
  if ((v311 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_265;
    }
    goto LABEL_264;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_264:
  }
    operator delete(__p[0]);
LABEL_265:
  RNBRemote::Packet::Packet((uint64_t)&v634, 51, (uint64_t)RNBRemote::HandlePacket_qThreadStopInfo, 0, 0, 0, "qThreadStopInfo", "Get detailed info on why the specified thread stopped");
  unint64_t v312 = *((void *)this + 85);
  if (v312 < *((void *)this + 86))
  {
    long long v313 = v634;
    long long v314 = v635;
    *(void *)(v312 + 32) = v636;
    *(_OWORD *)unint64_t v312 = v313;
    *(_OWORD *)(v312 + 16) = v314;
    long long v315 = *(_OWORD *)__p;
    *(void *)(v312 + 56) = v638;
    *(_OWORD *)(v312 + 40) = v315;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v316 = v640;
    *(_OWORD *)(v312 + 64) = *(_OWORD *)v639;
    *(void *)(v312 + 80) = v316;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v312 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_271;
    }
    goto LABEL_270;
  }
  uint64_t v317 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v318 = SHIBYTE(v640);
  *int v3 = v317;
  if ((v318 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_271;
    }
    goto LABEL_270;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_270:
  }
    operator delete(__p[0]);
LABEL_271:
  RNBRemote::Packet::Packet((uint64_t)&v634, 50, (uint64_t)RNBRemote::HandlePacket_qThreadExtraInfo, 0, 0, 0, "qThreadExtraInfo", "Get printable status of a thread");
  unint64_t v319 = *((void *)this + 85);
  if (v319 < *((void *)this + 86))
  {
    long long v320 = v634;
    long long v321 = v635;
    *(void *)(v319 + 32) = v636;
    *(_OWORD *)unint64_t v319 = v320;
    *(_OWORD *)(v319 + 16) = v321;
    long long v322 = *(_OWORD *)__p;
    *(void *)(v319 + 56) = v638;
    *(_OWORD *)(v319 + 40) = v322;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v323 = v640;
    *(_OWORD *)(v319 + 64) = *(_OWORD *)v639;
    *(void *)(v319 + 80) = v323;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v319 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_277;
    }
    goto LABEL_276;
  }
  v324 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v325 = SHIBYTE(v640);
  *int v3 = v324;
  if ((v325 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_277;
    }
    goto LABEL_276;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_276:
  }
    operator delete(__p[0]);
LABEL_277:
  RNBRemote::Packet::Packet((uint64_t)&v634, 54, (uint64_t)RNBRemote::HandlePacket_qLaunchSuccess, 0, 0, 0, "qLaunchSuccess", "Report the success or failure of the launch attempt");
  unint64_t v326 = *((void *)this + 85);
  if (v326 < *((void *)this + 86))
  {
    long long v327 = v634;
    long long v328 = v635;
    *(void *)(v326 + 32) = v636;
    *(_OWORD *)unint64_t v326 = v327;
    *(_OWORD *)(v326 + 16) = v328;
    long long v329 = *(_OWORD *)__p;
    *(void *)(v326 + 56) = v638;
    *(_OWORD *)(v326 + 40) = v329;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v330 = v640;
    *(_OWORD *)(v326 + 64) = *(_OWORD *)v639;
    *(void *)(v326 + 80) = v330;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v326 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_283;
    }
    goto LABEL_282;
  }
  v331 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v332 = SHIBYTE(v640);
  *int v3 = v331;
  if ((v332 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_283;
    }
    goto LABEL_282;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_282:
  }
    operator delete(__p[0]);
LABEL_283:
  RNBRemote::Packet::Packet((uint64_t)&v634, 55, (uint64_t)RNBRemote::HandlePacket_qRegisterInfo, 0, 0, 0, "qRegisterInfo", "Dynamically discover remote register context information.");
  unint64_t v333 = *((void *)this + 85);
  if (v333 < *((void *)this + 86))
  {
    long long v334 = v634;
    long long v335 = v635;
    *(void *)(v333 + 32) = v636;
    *(_OWORD *)unint64_t v333 = v334;
    *(_OWORD *)(v333 + 16) = v335;
    long long v336 = *(_OWORD *)__p;
    *(void *)(v333 + 56) = v638;
    *(_OWORD *)(v333 + 40) = v336;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v337 = v640;
    *(_OWORD *)(v333 + 64) = *(_OWORD *)v639;
    *(void *)(v333 + 80) = v337;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v333 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_289;
    }
    goto LABEL_288;
  }
  uint64_t v338 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v339 = SHIBYTE(v640);
  *int v3 = v338;
  if ((v339 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_289;
    }
    goto LABEL_288;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_288:
  }
    operator delete(__p[0]);
LABEL_289:
  RNBRemote::Packet::Packet((uint64_t)&v634, 56, (uint64_t)RNBRemote::HandlePacket_qShlibInfoAddr, 0, 0, 0, "qShlibInfoAddr", "Returns the address that contains info needed for getting shared library notifications");
  unint64_t v340 = *((void *)this + 85);
  if (v340 < *((void *)this + 86))
  {
    long long v341 = v634;
    long long v342 = v635;
    *(void *)(v340 + 32) = v636;
    *(_OWORD *)unint64_t v340 = v341;
    *(_OWORD *)(v340 + 16) = v342;
    long long v343 = *(_OWORD *)__p;
    *(void *)(v340 + 56) = v638;
    *(_OWORD *)(v340 + 40) = v343;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v344 = v640;
    *(_OWORD *)(v340 + 64) = *(_OWORD *)v639;
    *(void *)(v340 + 80) = v344;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v340 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_295;
    }
    goto LABEL_294;
  }
  v345 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v346 = SHIBYTE(v640);
  *int v3 = v345;
  if ((v346 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_295;
    }
    goto LABEL_294;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_294:
  }
    operator delete(__p[0]);
LABEL_295:
  RNBRemote::Packet::Packet((uint64_t)&v634, 57, (uint64_t)RNBRemote::HandlePacket_qStepPacketSupported, 0, 0, 0, "qStepPacketSupported", "Replys with OK if the 's' packet is supported.");
  unint64_t v347 = *((void *)this + 85);
  if (v347 < *((void *)this + 86))
  {
    long long v348 = v634;
    long long v349 = v635;
    *(void *)(v347 + 32) = v636;
    *(_OWORD *)unint64_t v347 = v348;
    *(_OWORD *)(v347 + 16) = v349;
    long long v350 = *(_OWORD *)__p;
    *(void *)(v347 + 56) = v638;
    *(_OWORD *)(v347 + 40) = v350;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v351 = v640;
    *(_OWORD *)(v347 + 64) = *(_OWORD *)v639;
    *(void *)(v347 + 80) = v351;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v347 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_301;
    }
    goto LABEL_300;
  }
  uint64_t v352 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v353 = SHIBYTE(v640);
  *int v3 = v352;
  if ((v353 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_301;
    }
    goto LABEL_300;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_300:
  }
    operator delete(__p[0]);
LABEL_301:
  RNBRemote::Packet::Packet((uint64_t)&v634, 59, (uint64_t)RNBRemote::HandlePacket_qVAttachOrWaitSupported, 0, 0, 0, "qVAttachOrWaitSupported", "Replys with OK if the 'vAttachOrWait' packet is supported.");
  unint64_t v354 = *((void *)this + 85);
  if (v354 < *((void *)this + 86))
  {
    long long v355 = v634;
    long long v356 = v635;
    *(void *)(v354 + 32) = v636;
    *(_OWORD *)unint64_t v354 = v355;
    *(_OWORD *)(v354 + 16) = v356;
    long long v357 = *(_OWORD *)__p;
    *(void *)(v354 + 56) = v638;
    *(_OWORD *)(v354 + 40) = v357;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v358 = v640;
    *(_OWORD *)(v354 + 64) = *(_OWORD *)v639;
    *(void *)(v354 + 80) = v358;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v354 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_307;
    }
    goto LABEL_306;
  }
  uint64_t v359 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v360 = SHIBYTE(v640);
  *int v3 = v359;
  if ((v360 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_307;
    }
    goto LABEL_306;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_306:
  }
    operator delete(__p[0]);
LABEL_307:
  RNBRemote::Packet::Packet((uint64_t)&v634, 60, (uint64_t)RNBRemote::HandlePacket_qSyncThreadStateSupported, 0, 0, 0, "qSyncThreadStateSupported", "Replys with OK if the 'QSyncThreadState:' packet is supported.");
  unint64_t v361 = *((void *)this + 85);
  if (v361 < *((void *)this + 86))
  {
    long long v362 = v634;
    long long v363 = v635;
    *(void *)(v361 + 32) = v636;
    *(_OWORD *)unint64_t v361 = v362;
    *(_OWORD *)(v361 + 16) = v363;
    long long v364 = *(_OWORD *)__p;
    *(void *)(v361 + 56) = v638;
    *(_OWORD *)(v361 + 40) = v364;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v365 = v640;
    *(_OWORD *)(v361 + 64) = *(_OWORD *)v639;
    *(void *)(v361 + 80) = v365;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v361 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_313;
    }
    goto LABEL_312;
  }
  uint64_t v366 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v367 = SHIBYTE(v640);
  *int v3 = v366;
  if ((v367 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_313;
    }
    goto LABEL_312;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_312:
  }
    operator delete(__p[0]);
LABEL_313:
  RNBRemote::Packet::Packet((uint64_t)&v634, 61, (uint64_t)RNBRemote::HandlePacket_qHostInfo, 0, 0, 0, "qHostInfo", "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v368 = *((void *)this + 85);
  if (v368 < *((void *)this + 86))
  {
    long long v369 = v634;
    long long v370 = v635;
    *(void *)(v368 + 32) = v636;
    *(_OWORD *)unint64_t v368 = v369;
    *(_OWORD *)(v368 + 16) = v370;
    long long v371 = *(_OWORD *)__p;
    *(void *)(v368 + 56) = v638;
    *(_OWORD *)(v368 + 40) = v371;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v372 = v640;
    *(_OWORD *)(v368 + 64) = *(_OWORD *)v639;
    *(void *)(v368 + 80) = v372;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v368 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_319;
    }
    goto LABEL_318;
  }
  uint64_t v373 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v374 = SHIBYTE(v640);
  *int v3 = v373;
  if ((v374 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_319;
    }
    goto LABEL_318;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_318:
  }
    operator delete(__p[0]);
LABEL_319:
  RNBRemote::Packet::Packet((uint64_t)&v634, 62, (uint64_t)RNBRemote::HandlePacket_qGDBServerVersion, 0, 0, 0, "qGDBServerVersion", "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v375 = *((void *)this + 85);
  if (v375 < *((void *)this + 86))
  {
    long long v376 = v634;
    long long v377 = v635;
    *(void *)(v375 + 32) = v636;
    *(_OWORD *)unint64_t v375 = v376;
    *(_OWORD *)(v375 + 16) = v377;
    long long v378 = *(_OWORD *)__p;
    *(void *)(v375 + 56) = v638;
    *(_OWORD *)(v375 + 40) = v378;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v379 = v640;
    *(_OWORD *)(v375 + 64) = *(_OWORD *)v639;
    *(void *)(v375 + 80) = v379;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v375 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_325;
    }
    goto LABEL_324;
  }
  uint64_t v380 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v381 = SHIBYTE(v640);
  *int v3 = v380;
  if ((v381 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_325;
    }
    goto LABEL_324;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_324:
  }
    operator delete(__p[0]);
LABEL_325:
  RNBRemote::Packet::Packet((uint64_t)&v634, 63, (uint64_t)RNBRemote::HandlePacket_qProcessInfo, 0, 0, 0, "qProcessInfo", "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v382 = *((void *)this + 85);
  if (v382 < *((void *)this + 86))
  {
    long long v383 = v634;
    long long v384 = v635;
    *(void *)(v382 + 32) = v636;
    *(_OWORD *)unint64_t v382 = v383;
    *(_OWORD *)(v382 + 16) = v384;
    long long v385 = *(_OWORD *)__p;
    *(void *)(v382 + 56) = v638;
    *(_OWORD *)(v382 + 40) = v385;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v386 = v640;
    *(_OWORD *)(v382 + 64) = *(_OWORD *)v639;
    *(void *)(v382 + 80) = v386;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v382 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_331;
    }
    goto LABEL_330;
  }
  v387 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v388 = SHIBYTE(v640);
  *int v3 = v387;
  if ((v388 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_331;
    }
    goto LABEL_330;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_330:
  }
    operator delete(__p[0]);
LABEL_331:
  RNBRemote::Packet::Packet((uint64_t)&v634, 53, (uint64_t)RNBRemote::HandlePacket_qSymbol, 0, 0, 0, "qSymbol:", "Notify that host debugger is ready to do symbol lookups");
  unint64_t v389 = *((void *)this + 85);
  if (v389 < *((void *)this + 86))
  {
    long long v390 = v634;
    long long v391 = v635;
    *(void *)(v389 + 32) = v636;
    *(_OWORD *)unint64_t v389 = v390;
    *(_OWORD *)(v389 + 16) = v391;
    long long v392 = *(_OWORD *)__p;
    *(void *)(v389 + 56) = v638;
    *(_OWORD *)(v389 + 40) = v392;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v393 = v640;
    *(_OWORD *)(v389 + 64) = *(_OWORD *)v639;
    *(void *)(v389 + 80) = v393;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v389 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_337;
    }
    goto LABEL_336;
  }
  int v394 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v395 = SHIBYTE(v640);
  *int v3 = v394;
  if ((v395 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_337;
    }
    goto LABEL_336;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_336:
  }
    operator delete(__p[0]);
LABEL_337:
  RNBRemote::Packet::Packet((uint64_t)&v634, 64, (uint64_t)RNBRemote::HandlePacket_jThreadExtendedInfo, 0, 0, 0, "jThreadExtendedInfo", "Replies with JSON data of thread extended information.");
  unint64_t v396 = *((void *)this + 85);
  if (v396 < *((void *)this + 86))
  {
    long long v397 = v634;
    long long v398 = v635;
    *(void *)(v396 + 32) = v636;
    *(_OWORD *)unint64_t v396 = v397;
    *(_OWORD *)(v396 + 16) = v398;
    long long v399 = *(_OWORD *)__p;
    *(void *)(v396 + 56) = v638;
    *(_OWORD *)(v396 + 40) = v399;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v400 = v640;
    *(_OWORD *)(v396 + 64) = *(_OWORD *)v639;
    *(void *)(v396 + 80) = v400;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v396 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_343;
    }
    goto LABEL_342;
  }
  int v401 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v402 = SHIBYTE(v640);
  *int v3 = v401;
  if ((v402 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_343;
    }
    goto LABEL_342;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_342:
  }
    operator delete(__p[0]);
LABEL_343:
  RNBRemote::Packet::Packet((uint64_t)&v634, 65, (uint64_t)RNBRemote::HandlePacket_jGetLoadedDynamicLibrariesInfos, 0, 0, 0, "jGetLoadedDynamicLibrariesInfos", "Replies with JSON data of all the shared libraries loaded in this process.");
  unint64_t v403 = *((void *)this + 85);
  if (v403 < *((void *)this + 86))
  {
    long long v404 = v634;
    long long v405 = v635;
    *(void *)(v403 + 32) = v636;
    *(_OWORD *)unint64_t v403 = v404;
    *(_OWORD *)(v403 + 16) = v405;
    long long v406 = *(_OWORD *)__p;
    *(void *)(v403 + 56) = v638;
    *(_OWORD *)(v403 + 40) = v406;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v407 = v640;
    *(_OWORD *)(v403 + 64) = *(_OWORD *)v639;
    *(void *)(v403 + 80) = v407;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v403 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_349;
    }
    goto LABEL_348;
  }
  uint64_t v408 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v409 = SHIBYTE(v640);
  *int v3 = v408;
  if ((v409 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_349;
    }
    goto LABEL_348;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_348:
  }
    operator delete(__p[0]);
LABEL_349:
  RNBRemote::Packet::Packet((uint64_t)&v634, 66, (uint64_t)RNBRemote::HandlePacket_jThreadsInfo, 0, 0, 0, "jThreadsInfo", "Replies with JSON data with information about all threads.");
  unint64_t v410 = *((void *)this + 85);
  if (v410 < *((void *)this + 86))
  {
    long long v411 = v634;
    long long v412 = v635;
    *(void *)(v410 + 32) = v636;
    *(_OWORD *)unint64_t v410 = v411;
    *(_OWORD *)(v410 + 16) = v412;
    long long v413 = *(_OWORD *)__p;
    *(void *)(v410 + 56) = v638;
    *(_OWORD *)(v410 + 40) = v413;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v414 = v640;
    *(_OWORD *)(v410 + 64) = *(_OWORD *)v639;
    *(void *)(v410 + 80) = v414;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v410 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_355;
    }
    goto LABEL_354;
  }
  uint64_t v415 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v416 = SHIBYTE(v640);
  *int v3 = v415;
  if ((v416 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_355;
    }
    goto LABEL_354;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_354:
  }
    operator delete(__p[0]);
LABEL_355:
  RNBRemote::Packet::Packet((uint64_t)&v634, 67, (uint64_t)RNBRemote::HandlePacket_jGetSharedCacheInfo, 0, 0, 0, "jGetSharedCacheInfo", "Replies with JSON data about the location and uuid of the shared cache in the inferior process.");
  unint64_t v417 = *((void *)this + 85);
  if (v417 < *((void *)this + 86))
  {
    long long v418 = v634;
    long long v419 = v635;
    *(void *)(v417 + 32) = v636;
    *(_OWORD *)unint64_t v417 = v418;
    *(_OWORD *)(v417 + 16) = v419;
    long long v420 = *(_OWORD *)__p;
    *(void *)(v417 + 56) = v638;
    *(_OWORD *)(v417 + 40) = v420;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v421 = v640;
    *(_OWORD *)(v417 + 64) = *(_OWORD *)v639;
    *(void *)(v417 + 80) = v421;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v417 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_361;
    }
    goto LABEL_360;
  }
  uint64_t v422 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v423 = SHIBYTE(v640);
  *int v3 = v422;
  if ((v423 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_361;
    }
    goto LABEL_360;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_360:
  }
    operator delete(__p[0]);
LABEL_361:
  RNBRemote::Packet::Packet((uint64_t)&v634, 69, (uint64_t)RNBRemote::HandlePacket_QStartNoAckMode, 0, 0, 0, "QStartNoAckMode", "Request that debugserver stop acking remote protocol packets");
  unint64_t v424 = *((void *)this + 85);
  if (v424 < *((void *)this + 86))
  {
    long long v425 = v634;
    long long v426 = v635;
    *(void *)(v424 + 32) = v636;
    *(_OWORD *)unint64_t v424 = v425;
    *(_OWORD *)(v424 + 16) = v426;
    long long v427 = *(_OWORD *)__p;
    *(void *)(v424 + 56) = v638;
    *(_OWORD *)(v424 + 40) = v427;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v428 = v640;
    *(_OWORD *)(v424 + 64) = *(_OWORD *)v639;
    *(void *)(v424 + 80) = v428;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v424 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_367;
    }
    goto LABEL_366;
  }
  v429 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v430 = SHIBYTE(v640);
  *int v3 = v429;
  if ((v430 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_367;
    }
    goto LABEL_366;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_366:
  }
    operator delete(__p[0]);
LABEL_367:
  RNBRemote::Packet::Packet((uint64_t)&v634, 70, (uint64_t)RNBRemote::HandlePacket_QThreadSuffixSupported, 0, 0, 0, "QThreadSuffixSupported", "Check if thread specific packets (register packets 'g', 'G', 'p', and 'P') support having the thread ID appended to the end of the command");
  unint64_t v431 = *((void *)this + 85);
  if (v431 < *((void *)this + 86))
  {
    long long v432 = v634;
    long long v433 = v635;
    *(void *)(v431 + 32) = v636;
    *(_OWORD *)unint64_t v431 = v432;
    *(_OWORD *)(v431 + 16) = v433;
    long long v434 = *(_OWORD *)__p;
    *(void *)(v431 + 56) = v638;
    *(_OWORD *)(v431 + 40) = v434;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v435 = v640;
    *(_OWORD *)(v431 + 64) = *(_OWORD *)v639;
    *(void *)(v431 + 80) = v435;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v431 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_373;
    }
    goto LABEL_372;
  }
  v436 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v437 = SHIBYTE(v640);
  *int v3 = v436;
  if ((v437 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_373;
    }
    goto LABEL_372;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_372:
  }
    operator delete(__p[0]);
LABEL_373:
  RNBRemote::Packet::Packet((uint64_t)&v634, 71, (uint64_t)RNBRemote::HandlePacket_QSetLogging, 0, 0, 0, "QSetLogging:", "Turn on log channels in debugserver");
  unint64_t v438 = *((void *)this + 85);
  if (v438 < *((void *)this + 86))
  {
    long long v439 = v634;
    long long v440 = v635;
    *(void *)(v438 + 32) = v636;
    *(_OWORD *)unint64_t v438 = v439;
    *(_OWORD *)(v438 + 16) = v440;
    long long v441 = *(_OWORD *)__p;
    *(void *)(v438 + 56) = v638;
    *(_OWORD *)(v438 + 40) = v441;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v442 = v640;
    *(_OWORD *)(v438 + 64) = *(_OWORD *)v639;
    *(void *)(v438 + 80) = v442;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v438 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_379;
    }
    goto LABEL_378;
  }
  v443 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v444 = SHIBYTE(v640);
  *int v3 = v443;
  if ((v444 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_379;
    }
    goto LABEL_378;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_378:
  }
    operator delete(__p[0]);
LABEL_379:
  RNBRemote::Packet::Packet((uint64_t)&v634, 72, (uint64_t)RNBRemote::HandlePacket_QSetIgnoredExceptions, 0, 0, 0, "QSetIgnoredExceptions:", "Set the exception types debugserver won't wait for, allowing them to be turned into the equivalent BSD signals by the normal means.");
  unint64_t v445 = *((void *)this + 85);
  if (v445 < *((void *)this + 86))
  {
    long long v446 = v634;
    long long v447 = v635;
    *(void *)(v445 + 32) = v636;
    *(_OWORD *)unint64_t v445 = v446;
    *(_OWORD *)(v445 + 16) = v447;
    long long v448 = *(_OWORD *)__p;
    *(void *)(v445 + 56) = v638;
    *(_OWORD *)(v445 + 40) = v448;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v449 = v640;
    *(_OWORD *)(v445 + 64) = *(_OWORD *)v639;
    *(void *)(v445 + 80) = v449;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v445 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_385;
    }
    goto LABEL_384;
  }
  v450 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v451 = SHIBYTE(v640);
  *int v3 = v450;
  if ((v451 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_385;
    }
    goto LABEL_384;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_384:
  }
    operator delete(__p[0]);
LABEL_385:
  RNBRemote::Packet::Packet((uint64_t)&v634, 73, (uint64_t)RNBRemote::HandlePacket_QSetMaxPacketSize, 0, 0, 0, "QSetMaxPacketSize:", "Tell debugserver the max sized packet gdb can handle");
  unint64_t v452 = *((void *)this + 85);
  if (v452 < *((void *)this + 86))
  {
    long long v453 = v634;
    long long v454 = v635;
    *(void *)(v452 + 32) = v636;
    *(_OWORD *)unint64_t v452 = v453;
    *(_OWORD *)(v452 + 16) = v454;
    long long v455 = *(_OWORD *)__p;
    *(void *)(v452 + 56) = v638;
    *(_OWORD *)(v452 + 40) = v455;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v456 = v640;
    *(_OWORD *)(v452 + 64) = *(_OWORD *)v639;
    *(void *)(v452 + 80) = v456;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v452 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_391;
    }
    goto LABEL_390;
  }
  v457 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v458 = SHIBYTE(v640);
  *int v3 = v457;
  if ((v458 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_391;
    }
    goto LABEL_390;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_390:
  }
    operator delete(__p[0]);
LABEL_391:
  RNBRemote::Packet::Packet((uint64_t)&v634, 74, (uint64_t)RNBRemote::HandlePacket_QSetMaxPayloadSize, 0, 0, 0, "QSetMaxPayloadSize:", "Tell debugserver the max sized payload gdb can handle");
  unint64_t v459 = *((void *)this + 85);
  if (v459 < *((void *)this + 86))
  {
    long long v460 = v634;
    long long v461 = v635;
    *(void *)(v459 + 32) = v636;
    *(_OWORD *)unint64_t v459 = v460;
    *(_OWORD *)(v459 + 16) = v461;
    long long v462 = *(_OWORD *)__p;
    *(void *)(v459 + 56) = v638;
    *(_OWORD *)(v459 + 40) = v462;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v463 = v640;
    *(_OWORD *)(v459 + 64) = *(_OWORD *)v639;
    *(void *)(v459 + 80) = v463;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v459 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_397;
    }
    goto LABEL_396;
  }
  v464 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v465 = SHIBYTE(v640);
  *int v3 = v464;
  if ((v465 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_397;
    }
    goto LABEL_396;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_396:
  }
    operator delete(__p[0]);
LABEL_397:
  RNBRemote::Packet::Packet((uint64_t)&v634, 75, (uint64_t)RNBRemote::HandlePacket_QEnvironment, 0, 0, 0, "QEnvironment:", "Add an environment variable to the inferior's environment");
  unint64_t v466 = *((void *)this + 85);
  if (v466 < *((void *)this + 86))
  {
    long long v467 = v634;
    long long v468 = v635;
    *(void *)(v466 + 32) = v636;
    *(_OWORD *)unint64_t v466 = v467;
    *(_OWORD *)(v466 + 16) = v468;
    long long v469 = *(_OWORD *)__p;
    *(void *)(v466 + 56) = v638;
    *(_OWORD *)(v466 + 40) = v469;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v470 = v640;
    *(_OWORD *)(v466 + 64) = *(_OWORD *)v639;
    *(void *)(v466 + 80) = v470;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v466 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_403;
    }
    goto LABEL_402;
  }
  v471 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v472 = SHIBYTE(v640);
  *int v3 = v471;
  if ((v472 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_403;
    }
    goto LABEL_402;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_402:
  }
    operator delete(__p[0]);
LABEL_403:
  RNBRemote::Packet::Packet((uint64_t)&v634, 76, (uint64_t)RNBRemote::HandlePacket_QEnvironmentHexEncoded, 0, 0, 0, "QEnvironmentHexEncoded:", "Add an environment variable to the inferior's environment");
  unint64_t v473 = *((void *)this + 85);
  if (v473 < *((void *)this + 86))
  {
    long long v474 = v634;
    long long v475 = v635;
    *(void *)(v473 + 32) = v636;
    *(_OWORD *)unint64_t v473 = v474;
    *(_OWORD *)(v473 + 16) = v475;
    long long v476 = *(_OWORD *)__p;
    *(void *)(v473 + 56) = v638;
    *(_OWORD *)(v473 + 40) = v476;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v477 = v640;
    *(_OWORD *)(v473 + 64) = *(_OWORD *)v639;
    *(void *)(v473 + 80) = v477;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v473 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_409;
    }
    goto LABEL_408;
  }
  v478 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v479 = SHIBYTE(v640);
  *int v3 = v478;
  if ((v479 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_409;
    }
    goto LABEL_408;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_408:
  }
    operator delete(__p[0]);
LABEL_409:
  RNBRemote::Packet::Packet((uint64_t)&v634, 77, (uint64_t)RNBRemote::HandlePacket_QLaunchArch, 0, 0, 0, "QLaunchArch:", "Set the architecture to use when launching a process for hosts that can run multiple architecture slices from universal files.");
  unint64_t v480 = *((void *)this + 85);
  if (v480 < *((void *)this + 86))
  {
    long long v481 = v634;
    long long v482 = v635;
    *(void *)(v480 + 32) = v636;
    *(_OWORD *)unint64_t v480 = v481;
    *(_OWORD *)(v480 + 16) = v482;
    long long v483 = *(_OWORD *)__p;
    *(void *)(v480 + 56) = v638;
    *(_OWORD *)(v480 + 40) = v483;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v484 = v640;
    *(_OWORD *)(v480 + 64) = *(_OWORD *)v639;
    *(void *)(v480 + 80) = v484;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v480 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_415;
    }
    goto LABEL_414;
  }
  v485 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v486 = SHIBYTE(v640);
  *int v3 = v485;
  if ((v486 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_415;
    }
    goto LABEL_414;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_414:
  }
    operator delete(__p[0]);
LABEL_415:
  RNBRemote::Packet::Packet((uint64_t)&v634, 78, (uint64_t)RNBRemote::HandlePacket_QSetDisableASLR, 0, 0, 0, "QSetDisableASLR:", "Set whether to disable ASLR when launching the process with the set argv ('A') packet");
  unint64_t v487 = *((void *)this + 85);
  if (v487 < *((void *)this + 86))
  {
    long long v488 = v634;
    long long v489 = v635;
    *(void *)(v487 + 32) = v636;
    *(_OWORD *)unint64_t v487 = v488;
    *(_OWORD *)(v487 + 16) = v489;
    long long v490 = *(_OWORD *)__p;
    *(void *)(v487 + 56) = v638;
    *(_OWORD *)(v487 + 40) = v490;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v491 = v640;
    *(_OWORD *)(v487 + 64) = *(_OWORD *)v639;
    *(void *)(v487 + 80) = v491;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v487 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_421;
    }
    goto LABEL_420;
  }
  v492 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v493 = SHIBYTE(v640);
  *int v3 = v492;
  if ((v493 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_421;
    }
    goto LABEL_420;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_420:
  }
    operator delete(__p[0]);
LABEL_421:
  RNBRemote::Packet::Packet((uint64_t)&v634, 79, (uint64_t)RNBRemote::HandlePacket_QSetSTDIO, 0, 0, 0, "QSetSTDIN:", "Set the standard input for a process to be launched with the 'A' packet");
  unint64_t v494 = *((void *)this + 85);
  if (v494 < *((void *)this + 86))
  {
    long long v495 = v634;
    long long v496 = v635;
    *(void *)(v494 + 32) = v636;
    *(_OWORD *)unint64_t v494 = v495;
    *(_OWORD *)(v494 + 16) = v496;
    long long v497 = *(_OWORD *)__p;
    *(void *)(v494 + 56) = v638;
    *(_OWORD *)(v494 + 40) = v497;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v498 = v640;
    *(_OWORD *)(v494 + 64) = *(_OWORD *)v639;
    *(void *)(v494 + 80) = v498;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v494 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_427;
    }
    goto LABEL_426;
  }
  v499 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v500 = SHIBYTE(v640);
  *int v3 = v499;
  if ((v500 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_427;
    }
    goto LABEL_426;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_426:
  }
    operator delete(__p[0]);
LABEL_427:
  RNBRemote::Packet::Packet((uint64_t)&v634, 80, (uint64_t)RNBRemote::HandlePacket_QSetSTDIO, 0, 0, 0, "QSetSTDOUT:", "Set the standard output for a process to be launched with the 'A' packet");
  unint64_t v501 = *((void *)this + 85);
  if (v501 < *((void *)this + 86))
  {
    long long v502 = v634;
    long long v503 = v635;
    *(void *)(v501 + 32) = v636;
    *(_OWORD *)unint64_t v501 = v502;
    *(_OWORD *)(v501 + 16) = v503;
    long long v504 = *(_OWORD *)__p;
    *(void *)(v501 + 56) = v638;
    *(_OWORD *)(v501 + 40) = v504;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v505 = v640;
    *(_OWORD *)(v501 + 64) = *(_OWORD *)v639;
    *(void *)(v501 + 80) = v505;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v501 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_433;
    }
    goto LABEL_432;
  }
  v506 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v507 = SHIBYTE(v640);
  *int v3 = v506;
  if ((v507 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_433;
    }
    goto LABEL_432;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_432:
  }
    operator delete(__p[0]);
LABEL_433:
  RNBRemote::Packet::Packet((uint64_t)&v634, 81, (uint64_t)RNBRemote::HandlePacket_QSetSTDIO, 0, 0, 0, "QSetSTDERR:", "Set the standard error for a process to be launched with the 'A' packet");
  unint64_t v508 = *((void *)this + 85);
  if (v508 < *((void *)this + 86))
  {
    long long v509 = v634;
    long long v510 = v635;
    *(void *)(v508 + 32) = v636;
    *(_OWORD *)unint64_t v508 = v509;
    *(_OWORD *)(v508 + 16) = v510;
    long long v511 = *(_OWORD *)__p;
    *(void *)(v508 + 56) = v638;
    *(_OWORD *)(v508 + 40) = v511;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v512 = v640;
    *(_OWORD *)(v508 + 64) = *(_OWORD *)v639;
    *(void *)(v508 + 80) = v512;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v508 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_439;
    }
    goto LABEL_438;
  }
  v513 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v514 = SHIBYTE(v640);
  *int v3 = v513;
  if ((v514 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_439;
    }
    goto LABEL_438;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_438:
  }
    operator delete(__p[0]);
LABEL_439:
  RNBRemote::Packet::Packet((uint64_t)&v634, 82, (uint64_t)RNBRemote::HandlePacket_QSetWorkingDir, 0, 0, 0, "QSetWorkingDir:", "Set the working directory for a process to be launched with the 'A' packet");
  unint64_t v515 = *((void *)this + 85);
  if (v515 < *((void *)this + 86))
  {
    long long v516 = v634;
    long long v517 = v635;
    *(void *)(v515 + 32) = v636;
    *(_OWORD *)unint64_t v515 = v516;
    *(_OWORD *)(v515 + 16) = v517;
    long long v518 = *(_OWORD *)__p;
    *(void *)(v515 + 56) = v638;
    *(_OWORD *)(v515 + 40) = v518;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v519 = v640;
    *(_OWORD *)(v515 + 64) = *(_OWORD *)v639;
    *(void *)(v515 + 80) = v519;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v515 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_445;
    }
    goto LABEL_444;
  }
  v520 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v521 = SHIBYTE(v640);
  *int v3 = v520;
  if ((v521 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_445;
    }
    goto LABEL_444;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_444:
  }
    operator delete(__p[0]);
LABEL_445:
  RNBRemote::Packet::Packet((uint64_t)&v634, 83, (uint64_t)RNBRemote::HandlePacket_QListThreadsInStopReply, 0, 0, 0, "QListThreadsInStopReply", "Set if the 'threads' key should be added to the stop reply packets with a list of all thread IDs.");
  unint64_t v522 = *((void *)this + 85);
  if (v522 < *((void *)this + 86))
  {
    long long v523 = v634;
    long long v524 = v635;
    *(void *)(v522 + 32) = v636;
    *(_OWORD *)unint64_t v522 = v523;
    *(_OWORD *)(v522 + 16) = v524;
    long long v525 = *(_OWORD *)__p;
    *(void *)(v522 + 56) = v638;
    *(_OWORD *)(v522 + 40) = v525;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v526 = v640;
    *(_OWORD *)(v522 + 64) = *(_OWORD *)v639;
    *(void *)(v522 + 80) = v526;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v522 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_451;
    }
    goto LABEL_450;
  }
  v527 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v528 = SHIBYTE(v640);
  *int v3 = v527;
  if ((v528 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_451;
    }
    goto LABEL_450;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_450:
  }
    operator delete(__p[0]);
LABEL_451:
  RNBRemote::Packet::Packet((uint64_t)&v634, 84, (uint64_t)RNBRemote::HandlePacket_QSyncThreadState, 0, 0, 0, "QSyncThreadState:", "Do whatever is necessary to make sure 'thread' is in a safe state to call functions on.");
  unint64_t v529 = *((void *)this + 85);
  if (v529 < *((void *)this + 86))
  {
    long long v530 = v634;
    long long v531 = v635;
    *(void *)(v529 + 32) = v636;
    *(_OWORD *)unint64_t v529 = v530;
    *(_OWORD *)(v529 + 16) = v531;
    long long v532 = *(_OWORD *)__p;
    *(void *)(v529 + 56) = v638;
    *(_OWORD *)(v529 + 40) = v532;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v533 = v640;
    *(_OWORD *)(v529 + 64) = *(_OWORD *)v639;
    *(void *)(v529 + 80) = v533;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v529 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_457;
    }
    goto LABEL_456;
  }
  v534 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v535 = SHIBYTE(v640);
  *int v3 = v534;
  if ((v535 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_457;
    }
    goto LABEL_456;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_456:
  }
    operator delete(__p[0]);
LABEL_457:
  RNBRemote::Packet::Packet((uint64_t)&v634, 90, (uint64_t)RNBRemote::HandlePacket_AllocateMemory, 0, 0, 0, "_M", "Allocate memory in the inferior process.");
  unint64_t v536 = *((void *)this + 85);
  if (v536 < *((void *)this + 86))
  {
    long long v537 = v634;
    long long v538 = v635;
    *(void *)(v536 + 32) = v636;
    *(_OWORD *)unint64_t v536 = v537;
    *(_OWORD *)(v536 + 16) = v538;
    long long v539 = *(_OWORD *)__p;
    *(void *)(v536 + 56) = v638;
    *(_OWORD *)(v536 + 40) = v539;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v540 = v640;
    *(_OWORD *)(v536 + 64) = *(_OWORD *)v639;
    *(void *)(v536 + 80) = v540;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v536 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_463;
    }
    goto LABEL_462;
  }
  v541 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v542 = SHIBYTE(v640);
  *int v3 = v541;
  if ((v542 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_463;
    }
    goto LABEL_462;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_462:
  }
    operator delete(__p[0]);
LABEL_463:
  RNBRemote::Packet::Packet((uint64_t)&v634, 91, (uint64_t)RNBRemote::HandlePacket_DeallocateMemory, 0, 0, 0, "_m", "Deallocate memory in the inferior process.");
  unint64_t v543 = *((void *)this + 85);
  if (v543 < *((void *)this + 86))
  {
    long long v544 = v634;
    long long v545 = v635;
    *(void *)(v543 + 32) = v636;
    *(_OWORD *)unint64_t v543 = v544;
    *(_OWORD *)(v543 + 16) = v545;
    long long v546 = *(_OWORD *)__p;
    *(void *)(v543 + 56) = v638;
    *(_OWORD *)(v543 + 40) = v546;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v547 = v640;
    *(_OWORD *)(v543 + 64) = *(_OWORD *)v639;
    *(void *)(v543 + 80) = v547;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v543 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_469;
    }
    goto LABEL_468;
  }
  v548 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v549 = SHIBYTE(v640);
  *int v3 = v548;
  if ((v549 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_469;
    }
    goto LABEL_468;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_468:
  }
    operator delete(__p[0]);
LABEL_469:
  RNBRemote::Packet::Packet((uint64_t)&v634, 93, (uint64_t)RNBRemote::HandlePacket_SaveRegisterState, 0, 0, 0, "QSaveRegisterState", "Save the register state for the current thread and return a decimal save ID.");
  unint64_t v550 = *((void *)this + 85);
  if (v550 < *((void *)this + 86))
  {
    long long v551 = v634;
    long long v552 = v635;
    *(void *)(v550 + 32) = v636;
    *(_OWORD *)unint64_t v550 = v551;
    *(_OWORD *)(v550 + 16) = v552;
    long long v553 = *(_OWORD *)__p;
    *(void *)(v550 + 56) = v638;
    *(_OWORD *)(v550 + 40) = v553;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v554 = v640;
    *(_OWORD *)(v550 + 64) = *(_OWORD *)v639;
    *(void *)(v550 + 80) = v554;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v550 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_475;
    }
    goto LABEL_474;
  }
  v555 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v556 = SHIBYTE(v640);
  *int v3 = v555;
  if ((v556 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_475;
    }
    goto LABEL_474;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_474:
  }
    operator delete(__p[0]);
LABEL_475:
  RNBRemote::Packet::Packet((uint64_t)&v634, 94, (uint64_t)RNBRemote::HandlePacket_RestoreRegisterState, 0, 0, 0, "QRestoreRegisterState:", "Restore the register state given a save ID previously returned from a call to QSaveRegisterState.");
  unint64_t v557 = *((void *)this + 85);
  if (v557 < *((void *)this + 86))
  {
    long long v558 = v634;
    long long v559 = v635;
    *(void *)(v557 + 32) = v636;
    *(_OWORD *)unint64_t v557 = v558;
    *(_OWORD *)(v557 + 16) = v559;
    long long v560 = *(_OWORD *)__p;
    *(void *)(v557 + 56) = v638;
    *(_OWORD *)(v557 + 40) = v560;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v561 = v640;
    *(_OWORD *)(v557 + 64) = *(_OWORD *)v639;
    *(void *)(v557 + 80) = v561;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v557 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_481;
    }
    goto LABEL_480;
  }
  v562 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v563 = SHIBYTE(v640);
  *int v3 = v562;
  if ((v563 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_481;
    }
    goto LABEL_480;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_480:
  }
    operator delete(__p[0]);
LABEL_481:
  RNBRemote::Packet::Packet((uint64_t)&v634, 85, (uint64_t)RNBRemote::HandlePacket_MemoryRegionInfo, 0, 0, 0, "qMemoryRegionInfo", "Return size and attributes of a memory region that contains the given address");
  unint64_t v564 = *((void *)this + 85);
  if (v564 < *((void *)this + 86))
  {
    long long v565 = v634;
    long long v566 = v635;
    *(void *)(v564 + 32) = v636;
    *(_OWORD *)unint64_t v564 = v565;
    *(_OWORD *)(v564 + 16) = v566;
    long long v567 = *(_OWORD *)__p;
    *(void *)(v564 + 56) = v638;
    *(_OWORD *)(v564 + 40) = v567;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v568 = v640;
    *(_OWORD *)(v564 + 64) = *(_OWORD *)v639;
    *(void *)(v564 + 80) = v568;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v564 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_487;
    }
    goto LABEL_486;
  }
  v569 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v570 = SHIBYTE(v640);
  *int v3 = v569;
  if ((v570 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_487;
    }
    goto LABEL_486;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_486:
  }
    operator delete(__p[0]);
LABEL_487:
  RNBRemote::Packet::Packet((uint64_t)&v634, 86, (uint64_t)RNBRemote::HandlePacket_GetProfileData, 0, 0, 0, "qGetProfileData", "Return profiling data of the current target.");
  unint64_t v571 = *((void *)this + 85);
  if (v571 < *((void *)this + 86))
  {
    long long v572 = v634;
    long long v573 = v635;
    *(void *)(v571 + 32) = v636;
    *(_OWORD *)unint64_t v571 = v572;
    *(_OWORD *)(v571 + 16) = v573;
    long long v574 = *(_OWORD *)__p;
    *(void *)(v571 + 56) = v638;
    *(_OWORD *)(v571 + 40) = v574;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v575 = v640;
    *(_OWORD *)(v571 + 64) = *(_OWORD *)v639;
    *(void *)(v571 + 80) = v575;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v571 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_493;
    }
    goto LABEL_492;
  }
  v576 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v577 = SHIBYTE(v640);
  *int v3 = v576;
  if ((v577 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_493;
    }
    goto LABEL_492;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_492:
  }
    operator delete(__p[0]);
LABEL_493:
  RNBRemote::Packet::Packet((uint64_t)&v634, 87, (uint64_t)RNBRemote::HandlePacket_SetEnableAsyncProfiling, 0, 0, 0, "QSetEnableAsyncProfiling", "Enable or disable the profiling of current target.");
  unint64_t v578 = *((void *)this + 85);
  if (v578 < *((void *)this + 86))
  {
    long long v579 = v634;
    long long v580 = v635;
    *(void *)(v578 + 32) = v636;
    *(_OWORD *)unint64_t v578 = v579;
    *(_OWORD *)(v578 + 16) = v580;
    long long v581 = *(_OWORD *)__p;
    *(void *)(v578 + 56) = v638;
    *(_OWORD *)(v578 + 40) = v581;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v582 = v640;
    *(_OWORD *)(v578 + 64) = *(_OWORD *)v639;
    *(void *)(v578 + 80) = v582;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v578 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_499;
    }
    goto LABEL_498;
  }
  v583 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v584 = SHIBYTE(v640);
  *int v3 = v583;
  if ((v584 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_499;
    }
    goto LABEL_498;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_498:
  }
    operator delete(__p[0]);
LABEL_499:
  RNBRemote::Packet::Packet((uint64_t)&v634, 88, (uint64_t)RNBRemote::HandlePacket_QEnableCompression, 0, 0, 0, "QEnableCompression:", "Enable compression for the remainder of the connection");
  unint64_t v585 = *((void *)this + 85);
  if (v585 < *((void *)this + 86))
  {
    long long v586 = v634;
    long long v587 = v635;
    *(void *)(v585 + 32) = v636;
    *(_OWORD *)unint64_t v585 = v586;
    *(_OWORD *)(v585 + 16) = v587;
    long long v588 = *(_OWORD *)__p;
    *(void *)(v585 + 56) = v638;
    *(_OWORD *)(v585 + 40) = v588;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v589 = v640;
    *(_OWORD *)(v585 + 64) = *(_OWORD *)v639;
    *(void *)(v585 + 80) = v589;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v585 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_505;
    }
    goto LABEL_504;
  }
  v590 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v591 = SHIBYTE(v640);
  *int v3 = v590;
  if ((v591 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_505;
    }
    goto LABEL_504;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_504:
  }
    operator delete(__p[0]);
LABEL_505:
  RNBRemote::Packet::Packet((uint64_t)&v634, 89, (uint64_t)RNBRemote::HandlePacket_WatchpointSupportInfo, 0, 0, 0, "qWatchpointSupportInfo", "Return the number of supported hardware watchpoints");
  unint64_t v592 = *((void *)this + 85);
  if (v592 < *((void *)this + 86))
  {
    long long v593 = v634;
    long long v594 = v635;
    *(void *)(v592 + 32) = v636;
    *(_OWORD *)unint64_t v592 = v593;
    *(_OWORD *)(v592 + 16) = v594;
    long long v595 = *(_OWORD *)__p;
    *(void *)(v592 + 56) = v638;
    *(_OWORD *)(v592 + 40) = v595;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v596 = v640;
    *(_OWORD *)(v592 + 64) = *(_OWORD *)v639;
    *(void *)(v592 + 80) = v596;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v592 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_511;
    }
    goto LABEL_510;
  }
  v597 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v598 = SHIBYTE(v640);
  *int v3 = v597;
  if ((v598 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_511;
    }
    goto LABEL_510;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_510:
  }
    operator delete(__p[0]);
LABEL_511:
  RNBRemote::Packet::Packet((uint64_t)&v634, 92, (uint64_t)RNBRemote::HandlePacket_QSetProcessEvent, 0, 0, 0, "QSetProcessEvent:", "Set a process event, to be passed to the process, can be set before the process is started, or after.");
  unint64_t v599 = *((void *)this + 85);
  if (v599 < *((void *)this + 86))
  {
    long long v600 = v634;
    long long v601 = v635;
    *(void *)(v599 + 32) = v636;
    *(_OWORD *)unint64_t v599 = v600;
    *(_OWORD *)(v599 + 16) = v601;
    long long v602 = *(_OWORD *)__p;
    *(void *)(v599 + 56) = v638;
    *(_OWORD *)(v599 + 40) = v602;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v603 = v640;
    *(_OWORD *)(v599 + 64) = *(_OWORD *)v639;
    *(void *)(v599 + 80) = v603;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v599 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_517;
    }
    goto LABEL_516;
  }
  v604 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v605 = SHIBYTE(v640);
  *int v3 = v604;
  if ((v605 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_517;
    }
    goto LABEL_516;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_516:
  }
    operator delete(__p[0]);
LABEL_517:
  RNBRemote::Packet::Packet((uint64_t)&v634, 96, (uint64_t)RNBRemote::HandlePacket_QSetDetachOnError, 0, 0, 0, "QSetDetachOnError:", "Set whether debugserver will detach (1) or kill (0) from the process it is controlling if it loses connection to lldb.");
  unint64_t v606 = *((void *)this + 85);
  if (v606 < *((void *)this + 86))
  {
    long long v607 = v634;
    long long v608 = v635;
    *(void *)(v606 + 32) = v636;
    *(_OWORD *)unint64_t v606 = v607;
    *(_OWORD *)(v606 + 16) = v608;
    long long v609 = *(_OWORD *)__p;
    *(void *)(v606 + 56) = v638;
    *(_OWORD *)(v606 + 40) = v609;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v610 = v640;
    *(_OWORD *)(v606 + 64) = *(_OWORD *)v639;
    *(void *)(v606 + 80) = v610;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v606 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_523;
    }
    goto LABEL_522;
  }
  v611 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v612 = SHIBYTE(v640);
  *int v3 = v611;
  if ((v612 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_523;
    }
    goto LABEL_522;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_522:
  }
    operator delete(__p[0]);
LABEL_523:
  RNBRemote::Packet::Packet((uint64_t)&v634, 95, (uint64_t)RNBRemote::HandlePacket_qSpeedTest, 0, 0, 0, "qSpeedTest:", "Test the maximum speed at which packet can be sent/received.");
  unint64_t v613 = *((void *)this + 85);
  if (v613 < *((void *)this + 86))
  {
    long long v614 = v634;
    long long v615 = v635;
    *(void *)(v613 + 32) = v636;
    *(_OWORD *)unint64_t v613 = v614;
    *(_OWORD *)(v613 + 16) = v615;
    long long v616 = *(_OWORD *)__p;
    *(void *)(v613 + 56) = v638;
    *(_OWORD *)(v613 + 40) = v616;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v617 = v640;
    *(_OWORD *)(v613 + 64) = *(_OWORD *)v639;
    *(void *)(v613 + 80) = v617;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v613 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_529;
    }
    goto LABEL_528;
  }
  v618 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v619 = SHIBYTE(v640);
  *int v3 = v618;
  if ((v619 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_529;
    }
    goto LABEL_528;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_528:
  }
    operator delete(__p[0]);
LABEL_529:
  RNBRemote::Packet::Packet((uint64_t)&v634, 97, (uint64_t)RNBRemote::HandlePacket_qXfer, 0, 0, 0, "qXfer:", "Support the qXfer packet.");
  unint64_t v620 = *((void *)this + 85);
  if (v620 < *((void *)this + 86))
  {
    long long v621 = v634;
    long long v622 = v635;
    *(void *)(v620 + 32) = v636;
    *(_OWORD *)unint64_t v620 = v621;
    *(_OWORD *)(v620 + 16) = v622;
    long long v623 = *(_OWORD *)__p;
    *(void *)(v620 + 56) = v638;
    *(_OWORD *)(v620 + 40) = v623;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v624 = v640;
    *(_OWORD *)(v620 + 64) = *(_OWORD *)v639;
    *(void *)(v620 + 80) = v624;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v620 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_535;
    }
    goto LABEL_534;
  }
  v625 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v626 = SHIBYTE(v640);
  *int v3 = v625;
  if ((v626 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_535;
    }
    goto LABEL_534;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_534:
  }
    operator delete(__p[0]);
LABEL_535:
  RNBRemote::Packet::Packet((uint64_t)&v634, 98, (uint64_t)RNBRemote::HandlePacket_jGetDyldProcessState, 0, 0, 0, "jGetDyldProcessState", "Query the process state from dyld.");
  unint64_t v627 = *((void *)this + 85);
  if (v627 < *((void *)this + 86))
  {
    long long v628 = v634;
    long long v629 = v635;
    *(void *)(v627 + 32) = v636;
    *(_OWORD *)unint64_t v627 = v628;
    *(_OWORD *)(v627 + 16) = v629;
    long long v630 = *(_OWORD *)__p;
    *(void *)(v627 + 56) = v638;
    *(_OWORD *)(v627 + 40) = v630;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v631 = v640;
    *(_OWORD *)(v627 + 64) = *(_OWORD *)v639;
    *(void *)(v627 + 80) = v631;
    uint64_t v638 = 0;
    v639[0] = 0;
    v639[1] = 0;
    uint64_t v640 = 0;
    *int v3 = (char *)(v627 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_540;
  }
  v632 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v633 = SHIBYTE(v640);
  *int v3 = v632;
  if ((v633 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_540;
  }
  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_540:
  }
    operator delete(__p[0]);
}

void RNBRemote::~RNBRemote(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("%s", "RNBRemote::~RNBRemote()");
  }
  RNBRemote::StopReadRemoteDataThread(this);
  if (*((char *)this + 767) < 0) {
    operator delete(*((void **)this + 93));
  }
  std::deque<std::string>::~deque[abi:nn180100]((uint64_t)this + 696);
  uint64_t v2 = *((void *)this + 84);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 85);
    unint64_t v4 = (void *)*((void *)this + 84);
    if (v3 == v2)
    {
LABEL_15:
      *((void *)this + 85) = v2;
      operator delete(v4);
      goto LABEL_16;
    }
    while (1)
    {
      if (*(char *)(v3 - 1) < 0)
      {
        operator delete(*(void **)(v3 - 24));
        if (*(char *)(v3 - 25) < 0) {
LABEL_13:
        }
          operator delete(*(void **)(v3 - 48));
      }
      else if (*(char *)(v3 - 25) < 0)
      {
        goto LABEL_13;
      }
      v3 -= 88;
      if (v3 == v2)
      {
        unint64_t v4 = (void *)*((void *)this + 84);
        goto LABEL_15;
      }
    }
  }
LABEL_16:
  if (!pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552))
    || pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 552)))
  {
    if ((*((char *)this + 535) & 0x80000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552));
  if (*((char *)this + 535) < 0) {
LABEL_19:
  }
    operator delete(*((void **)this + 64));
LABEL_20:
  RNBSocket::Disconnect((RNBRemote *)((char *)this + 472));
  long long v5 = (pthread_mutex_t *)*((void *)this + 61);
  *((void *)this + 61) = 0;
  if (v5)
  {
    if (pthread_mutex_destroy(v5))
    {
      if (!pthread_mutex_unlock(v5)) {
        pthread_mutex_destroy(v5);
      }
    }
    operator delete();
  }

  RNBContext::~RNBContext(this);
}

uint64_t RNBRemote::StopReadRemoteDataThread(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v2 = (pthread_mutex_t *)*((void *)this + 61);
    if (v2) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v16, 0);
    int tv_sec = v16.tv_sec;
    __darwin_suseconds_t tv_usec = v16.tv_usec;
    uint64_t v5 = *((void *)this + 62);
    int v6 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v16;
    if (v2) {
      pthread_mutex_unlock(v2);
    }
    _DNBLogThreaded("%8u RNBRemote::%s called", tv_usec - v6 + 1000000 * (tv_sec - v5), "StopReadRemoteDataThread");
  }
  uint64_t result = PThreadEvent::GetEventBits((pthread_mutex_t *)((char *)this + 120));
  if ((result & 0x40) != 0)
  {
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"debugserver about to shut down packet communications to lldb.", v8, v9, v10, v11, v12, v13, v14);
    }
    RNBSocket::Disconnect((RNBRemote *)((char *)this + 472));
    gettimeofday(&v16, 0);
    v15.int tv_sec = v16.tv_sec + v16.tv_usec / 1000000 + 2;
    v15.tv_nsec = 1000 * v16.tv_usec % 1000000000;
    return PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 120), 0x80u, &v15);
  }
  return result;
}

uint64_t RNBRemote::HandlePacket_m(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (__s && *__s && strlen(__s) > 2)
  {
    __endptr = 0;
    uint64_t v11 = __s + 1;
    *__error() = 0;
    mach_vm_address_t v12 = strtoull(__s + 1, &__endptr, 16);
    if (*__error() && !v12)
    {
      long long v7 = this;
      int v8 = 3108;
LABEL_16:
      uint64_t v9 = v11;
      goto LABEL_5;
    }
    if (*__endptr != 44)
    {
      long long v7 = this;
      int v8 = 3112;
      goto LABEL_16;
    }
    uint64_t v11 = __endptr + 1;
    *__error() = 0;
    size_t v13 = strtoul(v11, 0, 16);
    if (*__error() && !v13)
    {
      long long v7 = this;
      int v8 = 3122;
      goto LABEL_16;
    }
    if (!v13)
    {
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)&unk_10005A589);
      uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
      if (v28 < 0)
      {
        int v17 = (char *)__p[0];
LABEL_39:
        operator delete(v17);
      }
      return v16;
    }
    std::basic_string<unsigned char>::basic_string[abi:nn180100](&__b, v13, 0);
    if ((char)v32 < 0)
    {
      unint64_t v14 = v31;
      if (v31)
      {
        p_b = __b;
        goto LABEL_25;
      }
    }
    else
    {
      unint64_t v14 = v32;
      if (v32)
      {
        p_b = (char *)&__b;
LABEL_25:
        unint64_t v18 = DNBProcessMemoryRead(*((_DWORD *)this + 3), v12, v14, p_b);
        if (v18)
        {
          unint64_t v19 = v18;
          std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
          for (uint64_t i = 0; i != v19; ++i)
          {
            long long v21 = __p[0];
            uint64_t v22 = (char *)__p + *((void *)__p[0] - 3);
            if (*((_DWORD *)v22 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)__p + *((void *)__p[0] - 3)));
              uint64_t v23 = std::locale::use_facet(&v25, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 32);
              std::locale::~locale(&v25);
              long long v21 = __p[0];
            }
            *((_DWORD *)v22 + 36) = 48;
            *(_DWORD *)((char *)&__p[1] + *(v21 - 3)) = *(_DWORD *)((unsigned char *)&__p[1] + *(v21 - 3)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&__p[1] + *(v21 - 3)) = *(_DWORD *)((unsigned char *)&__p[1] + *(v21 - 3)) & 0xFFFFFF4F | 0x80;
            *(void *)&v29[*(v21 - 3)] = 2;
            std::ostream::operator<<();
          }
          std::stringbuf::str();
          uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v25);
          if (v26 < 0) {
            operator delete(v25.__locale_);
          }
          std::ostringstream::~ostringstream((uint64_t)__p);
          goto LABEL_37;
        }
        int v24 = "E08";
LABEL_35:
        std::string::basic_string[abi:nn180100]<0>(__p, v24);
        uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
LABEL_37:
        if ((char)v32 < 0)
        {
          int v17 = __b;
          goto LABEL_39;
        }
        return v16;
      }
    }
    int v24 = "E78";
    goto LABEL_35;
  }
  long long v7 = this;
  int v8 = 3100;
  uint64_t v9 = __s;
LABEL_5:

  return RNBRemote::HandlePacket_ILLFORMED(v7, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v9, a5);
}

uint64_t RNBRemote::HandlePacket_p(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (g_num_reg_entries)
  {
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    if (!a2) {
      goto LABEL_10;
    }
  }
  if (*a2)
  {
    int v7 = *((_DWORD *)this + 3);
    if (!v7)
    {
      char v28 = 3;
      LODWORD(__p) = 3486021;
      uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
      if (v28 < 0) {
        operator delete(__p);
      }
      return v13;
    }
    *__error() = 0;
    __endptr = 0;
    unsigned int v8 = strtoul(a2 + 1, &__endptr, 16);
    if (*__error() && !v8)
    {
      uint64_t v10 = this;
      int v11 = 4112;
      return RNBRemote::HandlePacket_ILLFORMED(v10, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v11, a2, v9);
    }
    if (*((unsigned char *)this + 782))
    {
      if (!__endptr || (unint64_t v14 = strstr(__endptr, "thread:")) == 0 || (CurrentThread = strtoul(v14 + 7, 0, 16)) == 0)
      {
LABEL_26:
        uint64_t v10 = this;
        int v11 = 4117;
        return RNBRemote::HandlePacket_ILLFORMED(v10, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v11, a2, v9);
      }
    }
    else
    {
      unint64_t CurrentThread = *((void *)this + 68);
      if (CurrentThread + 1 <= 1)
      {
        unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
        if (!CurrentThread) {
          goto LABEL_26;
        }
      }
    }
    uint64_t v22 = g_reg_entries;
    unint64_t v23 = g_num_reg_entries;
    *(void **)((char *)&__p + *((void *)__p - 3)) = v16;
    int v17 = (std::ios_base *)((char *)&__p + *((void *)__p - 3));
    std::ios_base::init(v17, &v27);
    v17[1].__vftable = 0;
    v17[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)uint64_t v29 = 0u;
    long long v30 = 0u;
    int v31 = 16;
    if (v8 < v23 && v22)
    {
      unint64_t v18 = v22 + ((unint64_t)v8 << 7);
      if (*(_DWORD *)(v18 + 12) == -1)
      {
        size_t v19 = *(unsigned int *)(v18 + 36);
        if (v19)
        {
          std::basic_string<unsigned char>::basic_string[abi:nn180100](__b, v19, 0);
          long long v20 = (v25 & 0x80u) == 0 ? __b : (void **)__b[0];
          long long v21 = (v25 & 0x80u) == 0 ? (void *)v25 : __b[1];
          append_hex_value((uint64_t)&__p, (uint64_t)v20, (uint64_t)v21, 0);
          if ((char)v25 < 0) {
            operator delete(__b[0]);
          }
        }
      }
      else
      {
        register_value_in_hex_fixed_width((uint64_t)&__p, v7, CurrentThread, v22 + ((unint64_t)v8 << 7), 0);
      }
    }
    else
    {
      if (DNBLogEnabled()) {
        _DNBLogError("RNBRemote::HandlePacket_p(%s): unknown register number %u requested\n", a2, v8);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"00000000", 8);
    }
    std::stringbuf::str();
    uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__b);
    if ((char)v25 < 0) {
      operator delete(__b[0]);
    }
    if (SBYTE7(v30) < 0) {
      operator delete(v29[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    return v13;
  }
LABEL_10:

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 4100, a2, a5);
}

uint64_t RNBRemote::HandlePacket_g(RNBRemote *this, char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v19 + (void)*(v19 - 3)) = v4;
  uint64_t v5 = (std::ios_base *)((char *)&v19 + (void)*(v19 - 3));
  std::ios_base::init(v5, &v20);
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)long long v21 = 0u;
  long long v22 = 0u;
  int v23 = 16;
  int v6 = *((_DWORD *)this + 3);
  if (!v6)
  {
    char v18 = 3;
    int v10 = 3223877;
    goto LABEL_20;
  }
  if (g_num_reg_entries)
  {
    if (*((unsigned char *)this + 782))
    {
LABEL_4:
      int v7 = strstr(a2 + 1, "thread:");
      if (!v7 || (unint64_t CurrentThread = strtoul(v7 + 7, 0, 16)) == 0)
      {
LABEL_17:
        uint64_t v14 = RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 3295, a2, v8);
        goto LABEL_23;
      }
      goto LABEL_11;
    }
  }
  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    int v6 = *((_DWORD *)this + 3);
    if (*((unsigned char *)this + 782)) {
      goto LABEL_4;
    }
  }
  unint64_t CurrentThread = *((void *)this + 68);
  if (CurrentThread + 1 <= 1)
  {
    unint64_t CurrentThread = DNBProcessGetCurrentThread(v6);
    if (!CurrentThread) {
      goto LABEL_17;
    }
  }
LABEL_11:
  size_t RegisterContext = DNBThreadGetRegisterContext(v6, CurrentThread, 0, 0);
  if (RegisterContext)
  {
    size_t v12 = RegisterContext;
    if ((RegisterContext & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v13 = operator new(RegisterContext);
    bzero(v13, v12);
    if (DNBThreadGetRegisterContext(v6, CurrentThread, v13, v12))
    {
      append_hex_value((uint64_t)&v19, (uint64_t)v13, v12, 0);
      std::stringbuf::str();
      uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      timespec v15 = v13;
      goto LABEL_22;
    }
    operator delete(v13);
  }
  char v18 = 3;
  int v10 = 3422021;
LABEL_20:
  LODWORD(__p[0]) = v10;
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if ((v18 & 0x80000000) == 0) {
    goto LABEL_23;
  }
  timespec v15 = __p[0];
LABEL_22:
  operator delete(v15);
LABEL_23:
  if (SBYTE7(v22) < 0) {
    operator delete(v21[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v14;
}

uint64_t RNBRemote::HandlePacket_M(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (!__s || !*__s || strlen(__s) <= 2)
  {
    int v7 = this;
    int v8 = 3027;
    uint64_t v9 = __s;
LABEL_5:
    return RNBRemote::HandlePacket_ILLFORMED(v7, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v9, a5);
  }
  __endptr = 0;
  int v11 = __s + 1;
  *__error() = 0;
  unint64_t v12 = strtoull(__s + 1, &__endptr, 16);
  if (*__error() && !v12)
  {
    int v7 = this;
    int v8 = 3035;
LABEL_16:
    uint64_t v9 = v11;
    goto LABEL_5;
  }
  if (*__endptr != 44)
  {
    int v7 = this;
    int v8 = 3039;
    goto LABEL_16;
  }
  uint64_t v13 = __endptr + 1;
  *__error() = 0;
  unint64_t v14 = strtoul(v13, &__endptr, 16);
  if (*__error() && !v14)
  {
    int v7 = this;
    int v8 = 3049;
    uint64_t v9 = v13;
    goto LABEL_5;
  }
  if (!v14) {
    goto LABEL_30;
  }
  if (*__endptr != 58)
  {
    int v7 = this;
    int v8 = 3057;
    uint64_t v9 = v13;
    goto LABEL_5;
  }
  timespec v15 = __endptr + 1;
  size_t v16 = strlen(__endptr + 1);
  if (v16)
  {
    int v7 = this;
    int v8 = 3065;
    uint64_t v9 = __endptr + 1;
    goto LABEL_5;
  }
  if (!v16) {
    goto LABEL_30;
  }
  __chkstk_darwin(v16);
  char v18 = &__str[-((v17 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
  bzero(v18, v17);
  char v19 = *v15;
  if (*v15)
  {
    long long v20 = v18;
    do
    {
      char v21 = v15[1];
      if (!v21) {
        break;
      }
      __str[0] = v19;
      __str[1] = v21;
      __str[2] = 0;
      *__error() = 0;
      char v22 = strtoul(__str, 0, 16);
      if (*__error()) {
        BOOL v23 = v22 == 0;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23)
      {
        int v7 = this;
        int v8 = 3083;
        uint64_t v9 = v15;
        goto LABEL_5;
      }
      *v20++ = v22;
      int v24 = v15[2];
      v15 += 2;
      char v19 = v24;
    }
    while (v24);
  }
  if (DNBProcessMemoryWrite(*((_DWORD *)this + 3), v12, v14, v18) != v14) {
    unsigned __int8 v25 = "E09";
  }
  else {
LABEL_30:
  }
    unsigned __int8 v25 = "OK";
  std::string::basic_string[abi:nn180100]<0>(__str, v25);
  uint64_t v26 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__str);
  if (v29 < 0) {
    operator delete(*(void **)__str);
  }
  return v26;
}

uint64_t RNBRemote::HandlePacket_P(RNBRemote *this, char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (g_num_reg_entries)
  {
    if (!a2) {
      goto LABEL_16;
    }
  }
  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    if (!a2) {
      goto LABEL_16;
    }
  }
  if (*a2)
  {
    int v7 = *((_DWORD *)this + 3);
    if (!v7)
    {
      BYTE7(v29) = 3;
      LODWORD(__p[0]) = 3682885;
      uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
      if (SBYTE7(v29) < 0) {
        operator delete(__p[0]);
      }
      return v20;
    }
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v34, a2);
    int Char = StdStringExtractor::GetChar(v8, 0);
    unsigned int HexMaxU32 = StdStringExtractor::GetHexMaxU32((StdStringExtractor *)v34, 0, 0xFFFFFFFFLL);
    int v11 = StdStringExtractor::GetChar((StdStringExtractor *)v34, 0);
    if (Char != 80)
    {
      char v21 = this;
      int v22 = 4169;
LABEL_22:
      uint64_t v20 = RNBRemote::HandlePacket_ILLFORMED(v21, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v22, a2, v12);
      goto LABEL_31;
    }
    if (HexMaxU32 == -1)
    {
      BYTE7(v29) = 3;
      int v23 = 3748421;
    }
    else
    {
      if (v11 == 61)
      {
        if (g_num_reg_entries <= (unint64_t)HexMaxU32)
        {
          int v24 = "E47";
        }
        else
        {
          unint64_t v13 = g_reg_entries + ((unint64_t)HexMaxU32 << 7);
          if (*(_DWORD *)(v13 + 8) != -1 || *(_DWORD *)(v13 + 12) != -1)
          {
            *(_OWORD *)timeval __p = *(_OWORD *)(v13 + 8);
            long long v14 = *(_OWORD *)(v13 + 24);
            long long v15 = *(_OWORD *)(v13 + 40);
            long long v16 = *(_OWORD *)(v13 + 56);
            uint64_t v32 = *(void *)(v13 + 72);
            long long v30 = v15;
            long long v31 = v16;
            long long v29 = v14;
            StdStringExtractor::GetHexBytes((StdStringExtractor *)v34, v33, *(unsigned int *)(v13 + 36), 204);
            ThreadIDFromThreadSuffix = RNBRemote::ExtractThreadIDFromThreadSuffix(this, a2);
            if (ThreadIDFromThreadSuffix)
            {
              if (DNBThreadSetRegisterValueByID(v7, (uint64_t)ThreadIDFromThreadSuffix)) {
                char v18 = "OK";
              }
              else {
                char v18 = "E32";
              }
              std::string::basic_string[abi:nn180100]<0>(v26, v18);
              uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v26);
              if ((v27 & 0x80000000) == 0) {
                goto LABEL_31;
              }
              unsigned __int8 v25 = (void *)v26[0];
              goto LABEL_30;
            }
            char v21 = this;
            int v22 = 4199;
            goto LABEL_22;
          }
          if (DNBLogEnabled()) {
            _DNBLogError("RNBRemote::HandlePacket_P(%s): unknown register number %u requested\n", a2, HexMaxU32);
          }
          int v24 = "E48";
        }
        std::string::basic_string[abi:nn180100]<0>(__p, v24);
LABEL_28:
        uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
        if (SBYTE7(v29) < 0)
        {
          unsigned __int8 v25 = __p[0];
LABEL_30:
          operator delete(v25);
        }
LABEL_31:
        StdStringExtractor::~StdStringExtractor(v34);
        return v20;
      }
      BYTE7(v29) = 3;
      int v23 = 3158853;
    }
    LODWORD(__p[0]) = v23;
    goto LABEL_28;
  }
LABEL_16:

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 4153, a2, a5);
}

uint64_t RNBRemote::HandlePacket_G(RNBRemote *this, char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    if (!g_num_reg_entries) {
      RNBRemote::InitializeRegisters(this, 0);
    }
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)__p, a2);
    uint64_t v21 = 1;
    int v5 = *((_DWORD *)this + 3);
    if (*((unsigned char *)this + 782))
    {
      if (!a2 || (int v6 = strstr(a2, "thread:")) == 0 || (CurrentThread = strtoul(v6 + 7, 0, 16)) == 0)
      {
LABEL_18:
        uint64_t v8 = RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 3333, a2, v4);
LABEL_30:
        StdStringExtractor::~StdStringExtractor(__p);
        return v8;
      }
    }
    else
    {
      unint64_t CurrentThread = *((void *)this + 68);
      if (CurrentThread + 1 <= 1)
      {
        unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
        if (!CurrentThread) {
          goto LABEL_18;
        }
      }
    }
    size_t RegisterContext = DNBThreadGetRegisterContext(v5, CurrentThread, 0, 0);
    if (!RegisterContext)
    {
      char v18 = 3;
      LODWORD(v17[0]) = 3487301;
      uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v17);
      if ((v18 & 0x80000000) == 0) {
        goto LABEL_30;
      }
      unint64_t v13 = v17[0];
LABEL_29:
      operator delete(v13);
      goto LABEL_30;
    }
    size_t v10 = RegisterContext;
    if ((RegisterContext & 0x8000000000000000) != 0) {
      abort();
    }
    int v11 = operator new(RegisterContext);
    bzero(v11, v10);
    unint64_t HexBytes = StdStringExtractor::GetHexBytes((StdStringExtractor *)__p, v11, v10, 204);
    if (HexBytes == v10)
    {
      if (DNBThreadSetRegisterContext(v5, CurrentThread, v11) == v10)
      {
        char v18 = 2;
        strcpy((char *)v17, "OK");
LABEL_26:
        uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v17);
        if (v18 < 0) {
          operator delete(v17[0]);
        }
        unint64_t v13 = v11;
        goto LABEL_29;
      }
      char v18 = 3;
      int v15 = 3487045;
    }
    else
    {
      unint64_t v14 = HexBytes;
      if (DNBLogEnabled()) {
        _DNBLogError("RNBRemote::HandlePacket_G(%s): extracted %llu of %llu bytes, size mismatch\n", a2, v14, v10);
      }
      char v18 = 3;
      int v15 = 3421765;
    }
    LODWORD(v17[0]) = v15;
    goto LABEL_26;
  }
  char v20 = 3;
  LODWORD(__p[0]) = 3223877;
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  return v8;
}

uint64_t RNBRemote::HandlePacket_z(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = a2;
  if (a2 && (int v7 = *(unsigned __int8 *)a2, *a2))
  {
    int v8 = *((_DWORD *)this + 3);
    if (!v8)
    {
      char v25 = 3;
      LODWORD(__p[0]) = 3486021;
      goto LABEL_13;
    }
    uint64_t v9 = a2 + 3;
    if (a2[2] == 44)
    {
      int v10 = a2[1];
      int v23 = 0;
      *__error() = 0;
      unint64_t v11 = strtoull(v9, &v23, 16);
      if (*__error() && !v11)
      {
        unint64_t v13 = this;
        int v14 = 3986;
        return RNBRemote::HandlePacket_ILLFORMED(v13, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v14, v9, v12);
      }
      uint64_t v9 = v23 + 1;
      if (*v23 != 44)
      {
        unint64_t v13 = this;
        int v14 = 3990;
        return RNBRemote::HandlePacket_ILLFORMED(v13, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v14, v9, v12);
      }
      *__error() = 0;
      unint64_t v18 = strtoul(v9, &v23, 16);
      if (*__error() && !v18)
      {
        unint64_t v13 = this;
        int v14 = 3996;
        return RNBRemote::HandlePacket_ILLFORMED(v13, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v14, v9, v12);
      }
      if (v7 != 122)
      {
        if (v7 == 90)
        {
          if ((v10 - 50) < 3)
          {
            if (v10 == 51) {
              int v20 = 1;
            }
            else {
              int v20 = 3;
            }
            if (v10 == 50) {
              int v21 = 2;
            }
            else {
              int v21 = v20;
            }
            if (!DNBWatchpointSet(v8, v11, v18, v21, 1)) {
              goto LABEL_40;
            }
            goto LABEL_43;
          }
          if ((v10 - 48) <= 1)
          {
            if (!DNBBreakpointSet(v8, v11, v18, v10 == 49))
            {
LABEL_40:
              int v22 = "E09";
LABEL_46:
              std::string::basic_string[abi:nn180100]<0>(__p, v22);
LABEL_13:
              uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
              if (v25 < 0) {
                operator delete(__p[0]);
              }
              return v17;
            }
LABEL_43:
            int v22 = "OK";
            goto LABEL_46;
          }
        }
        return RNBRemote::HandlePacket_UNIMPLEMENTED(this, v9);
      }
      if ((v10 - 50) >= 3)
      {
        if ((v10 - 48) > 1) {
          return RNBRemote::HandlePacket_UNIMPLEMENTED(this, v9);
        }
        if (DNBBreakpointClear(v8, v11)) {
          goto LABEL_43;
        }
      }
      else if (DNBWatchpointClear(v8, v11))
      {
        goto LABEL_43;
      }
      int v22 = "E08";
      goto LABEL_46;
    }
    int v15 = 3978;
    int v5 = a2 + 3;
  }
  else
  {
    int v15 = 3968;
  }

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v15, v5, a5);
}

uint64_t RNBRemote::HandlePacket_s(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    uint64_t CurrentThread = *((void *)this + 67);
    if ((unint64_t)(CurrentThread + 1) > 1
      || (uint64_t CurrentThread = *((void *)this + 68), (unint64_t)(CurrentThread + 1) > 1)
      || (uint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3))) != 0)
    {
      DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&v12);
      DNBThreadResumeActions::AppendAction((char **)&v12, CurrentThread, 6u, 0, -1);
      DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)&v12, 4, 0);
      BOOL v5 = DNBProcessResume(v3, (char *)v12, 0xAAAAAAAAAAAAAAABLL * ((v13 - (unsigned char *)v12) >> 3));
      uint64_t v6 = 0;
      if (!v5)
      {
        char v11 = 3;
        LODWORD(__p) = 3748933;
        uint64_t v6 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
        if (v11 < 0) {
          operator delete(__p);
        }
      }
      if (v15) {
        operator delete(v15);
      }
      int v7 = v12;
      if (v12)
      {
        unint64_t v13 = v12;
LABEL_15:
        operator delete(v7);
        return v6;
      }
      return v6;
    }
    char v14 = 3;
    int v8 = 3355461;
  }
  else
  {
    char v14 = 3;
    int v8 = 3289925;
  }
  LODWORD(v12) = v8;
  uint64_t v6 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v12);
  if (v14 < 0)
  {
    int v7 = v12;
    goto LABEL_15;
  }
  return v6;
}

uint64_t RNBRemote::HandlePacket_c(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    char v16 = 3;
    LODWORD(v14) = 3355205;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v14);
    if ((v16 & 0x80000000) == 0) {
      return v8;
    }
    int v10 = v14;
LABEL_15:
    operator delete(v10);
    return v8;
  }
  long long v18 = xmmword_100065D20;
  uint64_t v19 = -1;
  BOOL v5 = a2 + 1;
  if (a2[1])
  {
    *(void *)&long long v18 = *((void *)this + 67);
    *__error() = 0;
    unint64_t v6 = strtoull(v5, 0, 16);
    uint64_t v19 = v6;
    if (*__error())
    {
      if (!v6) {
        return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 4226, a2, v7);
      }
    }
  }
  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&v14);
  DNBThreadResumeActions::Append((char **)&v14, &v18);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)&v14, 5, 0);
  BOOL v9 = DNBProcessResume(v3, (char *)v14, 0xAAAAAAAAAAAAAAABLL * ((v15 - (unsigned char *)v14) >> 3));
  uint64_t v8 = 0;
  if (!v9)
  {
    char v13 = 3;
    LODWORD(__p) = 3486277;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (v13 < 0) {
      operator delete(__p);
    }
  }
  if (v17) {
    operator delete(v17);
  }
  int v10 = v14;
  if (v14)
  {
    int v15 = v14;
    goto LABEL_15;
  }
  return v8;
}

uint64_t RNBRemote::HandlePacket_S(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    char v22 = 3;
    int v9 = 3552069;
LABEL_19:
    LODWORD(__endptr) = v9;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__endptr);
    if ((v22 & 0x80000000) == 0) {
      return v8;
    }
    int v15 = __endptr;
LABEL_21:
    operator delete(v15);
    return v8;
  }
  long long v24 = xmmword_100065D38;
  uint64_t v25 = -1;
  BOOL v5 = a2 + 1;
  if (a2[1])
  {
    __endptr = 0;
    *__error() = 0;
    HIDWORD(v24) = strtoul(v5, &__endptr, 16);
    if (*__error())
    {
      int v7 = 4617;
      return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v7, a2, v6);
    }
    int v10 = __endptr;
    if (*__endptr == 59)
    {
      *__error() = 0;
      unint64_t v11 = strtoull(v10 + 1, 0, 16);
      uint64_t v25 = v11;
      if (*__error())
      {
        if (!v11)
        {
          int v7 = 4623;
          return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v7, a2, v6);
        }
      }
    }
  }
  uint64_t v12 = *((void *)this + 67);
  *(void *)&long long v24 = v12;
  if ((unint64_t)(v12 + 1) <= 1)
  {
    char v22 = 3;
    int v9 = 3159109;
    goto LABEL_19;
  }
  int State = DNBThreadGetState(v3, v12);
  if (State == 9 || State == 0)
  {
    char v22 = 3;
    int v9 = 3617605;
    goto LABEL_19;
  }
  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&__endptr);
  DNBThreadResumeActions::Append(&__endptr, &v24);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&__endptr, 4, 0);
  BOOL v17 = DNBProcessResume(v3, __endptr, 0xAAAAAAAAAAAAAAABLL * ((v21 - __endptr) >> 3));
  uint64_t v8 = 0;
  if (!v17)
  {
    char v19 = 3;
    LODWORD(__p) = 3748677;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (v19 < 0) {
      operator delete(__p);
    }
  }
  if (v23) {
    operator delete(v23);
  }
  int v15 = __endptr;
  if (__endptr)
  {
    int v21 = __endptr;
    goto LABEL_21;
  }
  return v8;
}

uint64_t RNBRemote::HandlePacket_H(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  BOOL v5 = this;
  unint64_t v6 = a2 + 1;
  if ((*((unsigned __int8 *)a2 + 1) | 4) == 0x67)
  {
    *__error() = 0;
    unint64_t v8 = strtoul(a2 + 2, 0, 16);
    if (*__error()) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9)
    {
      int v10 = *(unsigned __int8 *)v6;
      if (v10 == 99)
      {
        *((void *)v5 + 67) = v8;
        int v10 = *(unsigned __int8 *)v6;
      }
      if (v10 == 103)
      {
        DNBProcessSetCurrentThread(*((_DWORD *)v5 + 3), v8);
        *((void *)v5 + 68) = v8;
      }
      char v15 = 2;
      strcpy((char *)__p, "OK");
      uint64_t v11 = RNBRemote::SendPacket((uint64_t)v5, (uint64_t)__p);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
      return v11;
    }
    this = v5;
    int v13 = 1552;
  }
  else
  {
    int v13 = 1539;
  }

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v13, v6, a5);
}

uint64_t RNBRemote::HandlePacket_last_signal(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    HIBYTE(v30) = 3;
    LODWORD(__dst) = 3289157;
    goto LABEL_41;
  }
  unsigned int State = DNBProcessGetState(*((_DWORD *)this + 3));
  uint64_t v5 = 0;
  if (State > 0xA) {
    return v5;
  }
  if (((1 << State) & 0x203) == 0)
  {
    if (((1 << State) & 0x490) != 0)
    {
      uint64_t CurrentThread = DNBProcessGetCurrentThread(v3);
      DNBProcessSetCurrentThread(*((_DWORD *)this + 3), CurrentThread);
      *((void *)this + 68) = CurrentThread;
      RNBRemote::SendStopReplyPacketForThread(this, CurrentThread);
      return 0;
    }
    return v5;
  }
  *(void *)__str = 0;
  uint64_t v38 = 0;
  int v36 = 0;
  if (DNBProcessGetExitStatus(v3, &v36))
  {
    if (v36)
    {
      if ((v36 & 0x7F) == 0x7F)
      {
        if (v36 >> 8 != 19) {
          snprintf(__str, 0x10uLL, "S%02x");
        }
      }
      else if ((v36 & 0x7F) != 0)
      {
        snprintf(__str, 0x10uLL, "X%02x");
      }
      else
      {
        snprintf(__str, 0x10uLL, "W%02x");
      }
    }
  }
  else
  {
    int v36 = 0;
  }
  if (!__str[0])
  {
    strcpy(__str, "W00");
    HIBYTE(v38) = 0;
  }
  ExitInfo = DNBProcessGetExitInfo(v3);
  if (ExitInfo)
  {
    unint64_t v8 = ExitInfo;
    if (*(unsigned char *)ExitInfo)
    {
      *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&__dst + (void)*(__dst - 3)) = v9;
      int v10 = (std::ios_base *)((char *)&__dst + (void)*(__dst - 3));
      std::ios_base::init(v10, &v29);
      v10[1].__vftable = 0;
      v10[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf();
      *(_OWORD *)timeval __p = 0u;
      long long v33 = 0u;
      int v34 = 16;
      size_t v11 = strlen(__str);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__dst, (uint64_t)__str, v11);
      LOBYTE(v26.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__dst, (uint64_t)&v26, 1);
      uint64_t v12 = __dst;
      int v13 = (char *)&__dst + (void)*(__dst - 3);
      if (*((_DWORD *)v13 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)&__dst + (void)*(__dst - 3)));
        char v14 = std::locale::use_facet(&v26, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 32);
        std::locale::~locale(&v26);
        uint64_t v12 = __dst;
      }
      *((_DWORD *)v13 + 36) = 48;
      *(_DWORD *)((char *)&__dst + (void)*(v12 - 3) + 8) = *(_DWORD *)((unsigned char *)&__dst + (void)*(v12 - 3) + 8) & 0xFFFFFFB5 | 8;
      *(_DWORD *)((char *)&__dst + (void)*(v12 - 3) + 8) = *(_DWORD *)((unsigned char *)&__dst + (void)*(v12 - 3) + 8) & 0xFFFFFF4F | 0x80;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__dst, (uint64_t)"description", 11);
      LOBYTE(v26.__locale_) = 58;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__dst, (uint64_t)&v26, 1);
      if (*v8)
      {
        char v15 = v8 + 1;
        do
        {
          BOOL v17 = __dst;
          long long v18 = (char *)&__dst + (void)*(__dst - 3);
          if (*((_DWORD *)v18 + 36) == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)&__dst + (void)*(__dst - 3)));
            char v19 = std::locale::use_facet(&v26, &std::ctype<char>::id);
            ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 32);
            std::locale::~locale(&v26);
            BOOL v17 = __dst;
          }
          *((_DWORD *)v18 + 36) = 48;
          *(_DWORD *)((char *)&v29 + (void)*(v17 - 3)) = *(_DWORD *)((unsigned char *)&v29 + (void)*(v17 - 3)) & 0xFFFFFFB5 | 8;
          *(_DWORD *)((char *)&v29 + (void)*(v17 - 3)) = *(_DWORD *)((unsigned char *)&v29 + (void)*(v17 - 3)) & 0xFFFFFF4F | 0x80;
          *(void *)&v31[(void)*(v17 - 3)] = 2;
          std::ostream::operator<<();
        }
        while (*v15++);
      }
      LOBYTE(v26.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__dst, (uint64_t)&v26, 1);
      std::stringbuf::str();
      uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v26);
      if (v27 < 0) {
        operator delete(v26.__locale_);
      }
      *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&__dst
      if (SBYTE7(v33) < 0) {
        operator delete(__p[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      return v5;
    }
  }
  size_t v20 = strlen(__str);
  if (v20 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v21 = v20;
  if (v20 >= 0x17)
  {
    uint64_t v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v20 | 7) != 0x17) {
      uint64_t v23 = v20 | 7;
    }
    uint64_t v24 = v23 + 1;
    p_dst = (void (__cdecl ***)(std::ostringstream *__hidden))operator new(v23 + 1);
    long long v29 = (void (__cdecl **)(std::stringbuf *__hidden))v21;
    unint64_t v30 = v24 | 0x8000000000000000;
    long long __dst = (void (__cdecl **)(std::ostringstream *__hidden))p_dst;
  }
  else
  {
    HIBYTE(v30) = v20;
    p_dst = &__dst;
    if (!v20) {
      goto LABEL_40;
    }
  }
  memcpy(p_dst, __str, v21);
LABEL_40:
  *((unsigned char *)p_dst + v21) = 0;
LABEL_41:
  uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__dst);
  if (SHIBYTE(v30) < 0) {
    operator delete(__dst);
  }
  return v5;
}

uint64_t RNBRemote::HandlePacket_stop_process(RNBRemote *this, const char *a2)
{
  if (!DNBProcessInterrupt(*((_DWORD *)this + 3)))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("RNBRemote::HandlePacket_stop_process() sending extra stop reply because DNBProcessInterrupt returned false");
    }
    RNBRemote::HandlePacket_last_signal(this, v3);
  }
  return 0;
}

uint64_t RNBRemote::HandlePacket_A(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  unint64_t v6 = a2;
  if (!a2 || !*a2)
  {
    int v8 = 1459;
    goto LABEL_7;
  }
  unint64_t v6 = a2 + 1;
  if (a2[1] < 1 || (_DefaultRuneLocale.__runetype[*((unsigned __int8 *)a2 + 1)] & 0x400) == 0)
  {
    int v8 = 1464;
LABEL_7:
    return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v6, a5);
  }
  int v10 = a2 + 1;
  while (*v10)
  {
    memset(&v27, 0, sizeof(v27));
    __endptr = 0;
    *__error() = 0;
    int64_t v11 = strtoul(v10, &__endptr, 10);
    if (*__error()) {
      BOOL v13 = v11 == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      char v15 = this;
      int v16 = 1483;
    }
    else if (*__endptr == 44)
    {
      int v10 = __endptr + 1;
      *__error() = 0;
      unint64_t v14 = strtoul(v10, &__endptr, 10);
      if (!*__error() || v14)
      {
        if (*__endptr == 44)
        {
          BOOL v17 = __endptr + 1;
          __endptr = v17;
          int v10 = &v17[v11];
          if (v11 >= 1)
          {
            do
            {
              char v20 = *v17;
              size_t v21 = v17 + 1;
              if (!*v17 || v21 >= v10) {
                break;
              }
              char v23 = *v21;
              if (!*v21) {
                break;
              }
              __str[0] = v20;
              __str[1] = v23;
              __str[2] = 0;
              *__error() = 0;
              int v24 = strtoul(__str, 0, 16);
              if (*__error() && !v24)
              {
                char v15 = this;
                int v16 = 1515;
                goto LABEL_42;
              }
              std::string::push_back(&v27, v24);
              BOOL v17 = (char *)(v21 + 1);
            }
            while (v21 + 1 < v10);
          }
          if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v18 = &v27;
          }
          else {
            long long v18 = (std::string *)v27.__r_.__value_.__r.__words[0];
          }
          RNBContext::PushArgument(this, (const char *)v18);
          if (*v10 == 44) {
            ++v10;
          }
          char v19 = 1;
          if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_11;
          }
LABEL_43:
          operator delete(v27.__r_.__value_.__l.__data_);
          goto LABEL_11;
        }
        char v15 = this;
        int v16 = 1499;
      }
      else
      {
        char v15 = this;
        int v16 = 1495;
      }
    }
    else
    {
      char v15 = this;
      int v16 = 1487;
    }
LABEL_42:
    uint64_t v5 = RNBRemote::HandlePacket_ILLFORMED(v15, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v16, v6, v12);
    char v19 = 0;
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_43;
    }
LABEL_11:
    if ((v19 & 1) == 0) {
      return v5;
    }
  }
  *((unsigned char *)&v27.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v27, "OK");
  RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v27);
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  return 0;
}

uint64_t RNBRemote::HandlePacket_C(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    char v19 = 3;
    LODWORD(__endptr) = 3552069;
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__endptr);
    if ((v19 & 0x80000000) == 0) {
      return v9;
    }
    int v10 = __endptr;
LABEL_24:
    operator delete(v10);
    return v9;
  }
  long long v21 = xmmword_100065D20;
  uint64_t v22 = -1;
  uint64_t v5 = a2 + 1;
  if (a2[1])
  {
    *(void *)&long long v21 = *((void *)this + 67);
    __endptr = 0;
    *__error() = 0;
    int v6 = strtoul(v5, &__endptr, 16);
    if (*__error())
    {
      int v8 = 4501;
      return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, a2, v7);
    }
    int64_t v11 = __endptr;
    if (*__endptr == 59)
    {
      *__error() = 0;
      unint64_t v12 = strtoull(v11 + 1, 0, 16);
      uint64_t v22 = v12;
      if (*__error())
      {
        if (!v12)
        {
          int v8 = 4507;
          return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, a2, v7);
        }
      }
    }
  }
  else
  {
    int v6 = -1;
  }
  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&__endptr);
  DNBThreadResumeActions::Append(&__endptr, &v21);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&__endptr, 5, SHIDWORD(v21));
  if (DNBProcessSignal(v3, v6))
  {
    if (DNBProcessResume(v3, __endptr, 0xAAAAAAAAAAAAAAABLL * ((v18 - __endptr) >> 3)))
    {
      uint64_t v9 = 0;
      goto LABEL_20;
    }
    char v16 = 3;
    int v13 = 3683141;
  }
  else
  {
    char v16 = 3;
    int v13 = 3290437;
  }
  LODWORD(__p) = v13;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v16 < 0) {
    operator delete(__p);
  }
LABEL_20:
  if (v20) {
    operator delete(v20);
  }
  int v10 = __endptr;
  if (__endptr)
  {
    long long v18 = __endptr;
    goto LABEL_24;
  }
  return v9;
}

uint64_t RNBRemote::HandlePacket_D(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"detaching from pid %u due to D packet", v3, v4, v5, v6, v7, v8, *((unsigned int *)this + 3));
    }
    if (DNBProcessDetach(*((_DWORD *)this + 3)))
    {
      char v17 = 2;
      strcpy((char *)__p, "OK");
      goto LABEL_9;
    }
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"error while detaching from pid %u due to D packet", v9, v10, v11, v12, v13, v14, *((unsigned int *)this + 3));
    }
  }
  char v17 = 1;
  LOWORD(__p[0]) = 69;
LABEL_9:
  RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

uint64_t RNBRemote::HandlePacket_k(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabled()) {
    _DNBLog(0, (uint64_t)"Got a 'k' packet, killing the inferior process.", v3, v4, v5, v6, v7, v8, v11);
  }
  int v9 = *((_DWORD *)this + 3);
  if (v9) {
    DNBProcessKill(v9);
  }
  char v13 = 3;
  LODWORD(__p) = 3747928;
  RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v13 < 0) {
    operator delete(__p);
  }
  return 0;
}

uint64_t RNBRemote::HandlePacket_T(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v5 = (int *)this;
  uint64_t v6 = a2 + 1;
  if (!a2[1])
  {
    int v8 = 3944;
    goto LABEL_7;
  }
  if (*((_DWORD *)this + 3))
  {
    *__error() = 0;
    unint64_t v7 = strtoul(v6, 0, 16);
    if (*__error() && !v7)
    {
      this = (RNBRemote *)v5;
      int v8 = 3953;
LABEL_7:
      return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v6, a5);
    }
    unsigned int State = DNBThreadGetState(v5[3], v7);
    if (State <= 9 && ((1 << State) & 0x281) != 0)
    {
      char v13 = 3;
      LODWORD(__p[0]) = 3551557;
    }
    else
    {
      char v13 = 2;
      strcpy((char *)__p, "OK");
    }
  }
  else
  {
    char v13 = 3;
    LODWORD(__p[0]) = 3486021;
  }
  uint64_t v11 = RNBRemote::SendPacket((uint64_t)v5, (uint64_t)__p);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

uint64_t RNBRemote::HandlePacket_qSupported(RNBRemote *this, char *__s1)
{
  uint64_t v3 = strstr(__s1, "amx+");
  if (v3) {
    DNBArchProtocol::EnableAMXRegisters((DNBArchProtocol *)v3);
  }
  snprintf(__str, 0x100uLL, "qXfer:features:read+;PacketSize=%x;qEcho+;native-signals+", 0x20000);
  strcat(__str, ";SupportedCompressions=lzfse,zlib-deflate,lz4,lzma;DefaultCompressionMinSize=");
  snprintf(__s2, 0x10uLL, "%zu", *((void *)this + 98));
  HIBYTE(v12) = 0;
  strcat(__str, __s2);
  size_t v4 = strlen(__str);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    size_t v12 = v5;
    unint64_t v13 = v8 | 0x8000000000000000;
    *(void *)__s2 = v6;
    goto LABEL_10;
  }
  HIBYTE(v13) = v4;
  uint64_t v6 = __s2;
  if (v4) {
LABEL_10:
  }
    memcpy(v6, __str, v5);
  *((unsigned char *)v6 + v5) = 0;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__s2);
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)__s2);
  }
  return v9;
}

uint64_t RNBRemote::HandlePacket_v(RNBRemote *this, const char *__s1)
{
  if (!strcmp(__s1, "vCont;c"))
  {
    return RNBRemote::HandlePacket_c(this, "c");
  }
  if (!strcmp(__s1, "vCont;s"))
  {
    return RNBRemote::HandlePacket_s(this, v4);
  }
  if (strncmp(__s1, "vCont", 5uLL))
  {
    if (strncmp(__s1, "vAttach", 7uLL))
    {
      return RNBRemote::HandlePacket_UNIMPLEMENTED(this, __s1);
    }
    bzero(__s, 0x400uLL);
    memset(&__p, 0, sizeof(__p));
    if (!strncmp(__s1, "vAttachWait;", 0xCuLL))
    {
      int v18 = *((unsigned __int8 *)__s1 + 12);
      char v17 = (char *)(__s1 + 12);
      std::string::value_type v16 = v18;
      long long v118 = v17;
      if (!v18)
      {
LABEL_48:
        if (DNBLogEnabled())
        {
          uint64_t v23 = getpid();
          _DNBLog(0, (uint64_t)"[LaunchAttach] START %d vAttachWait for process name '%s'", v24, v25, v26, v27, v28, v29, v23);
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v31 = DNBProcessAttachWait(this, (char *)p_p, 1, 0, 0x3E8u, __s, 0x400uLL, (unsigned int (*)(void *))RNBRemoteShouldCancelCallback, 0);
        goto LABEL_67;
      }
      while (1)
      {
        __endptr.__r_.__value_.__s.__data_[0] = v16;
        *(_WORD *)((char *)&__endptr.__r_.__value_.__l.__data_ + 1) = v17[1];
        *__error() = 0;
        int v19 = strtoul((const char *)&__endptr, 0, 16);
        if (*__error() && v19 == 0) {
          break;
        }
        std::string::push_back(&__p, v19);
        int v22 = v17[2];
        v17 += 2;
        std::string::value_type v16 = v22;
        if (!v22)
        {
          long long v118 = v17;
          goto LABEL_48;
        }
      }
      int v65 = this;
      int v66 = 3770;
    }
    else
    {
      if (strncmp(__s1, "vAttachOrWait;", 0xEuLL))
      {
        if (strncmp(__s1, "vAttachName;", 0xCuLL))
        {
          if (strncmp(__s1, "vAttach;", 8uLL))
          {
            uint64_t v9 = RNBRemote::HandlePacket_UNIMPLEMENTED(this, __s1);
            goto LABEL_138;
          }
          unint64_t v67 = __s1 + 8;
          long long v118 = (char *)(__s1 + 8);
          v113.__r_.__value_.__r.__words[0] = 0;
          PIDByuint64_t Name = strtoul(__s1 + 8, &v113.__r_.__value_.__l.__data_, 16);
          if (v67 == v113.__r_.__value_.__l.__data_ || *v113.__r_.__value_.__l.__data_)
          {
            uint64_t v45 = 0;
          }
          else
          {
            gettimeofday((timeval *)&__endptr, 0);
            v115.__r_.__value_.__r.__words[0] = __endptr.__r_.__value_.__r.__words[0]
                                              + SLODWORD(__endptr.__r_.__value_.__r.__words[1]) / 1000000
                                              + 30;
            v115.__r_.__value_.__l.__size_ = 1000 * LODWORD(__endptr.__r_.__value_.__r.__words[1]) % 1000000000;
            if (DNBLogEnabled())
            {
              uint64_t v101 = getpid();
              _DNBLog(0, (uint64_t)"[LaunchAttach] START %d vAttach to pid %d", v102, v103, v104, v105, v106, v107, v101);
            }
            uint64_t v45 = DNBProcessAttach(PIDByName, (uint64_t)&v115, (uint64_t)this + 448, __s, 1024);
          }
LABEL_68:
          if (v45)
          {
            if (v45 == -1)
            {
              if (DNBLogEnabled()) {
                _DNBLogError("debugserver is x86_64 binary running in translation, attach failed.");
              }
              std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
              cstring_to_asciihex_string("debugserver is x86_64 binary running in translation, attach failed.", &v115);
              if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v47 = &v115;
              }
              else {
                long long v47 = (std::string *)v115.__r_.__value_.__r.__words[0];
              }
              if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(v115.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = v115.__r_.__value_.__l.__size_;
              }
              std::string::append(&__endptr, (const std::string::value_type *)v47, size);
              if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v115.__r_.__value_.__l.__data_);
              }
              if ((__endptr.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_endptr = &__endptr;
              }
              else {
                p_endptr = (std::string *)__endptr.__r_.__value_.__r.__words[0];
              }
              std::string::basic_string[abi:nn180100]<0>(&v115, (char *)p_endptr);
              RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v115);
              goto LABEL_84;
            }
            if (*((_DWORD *)this + 3) != v45) {
              RNBContext::SetProcessID(this, v45);
            }
            if (DNBLogEnabled()) {
              _DNBLog(0, (uint64_t)"Successfully attached to pid %d", v51, v52, v53, v54, v55, v56, v45);
            }
            RNBRemote::HandlePacket_last_signal(this, v50);
            uint64_t v9 = 0;
LABEL_138:
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              char v15 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_140:
              operator delete(v15);
            }
            return v9;
          }
          if (DNBLogEnabled()) {
            _DNBLogError("Attach failed");
          }
          *((void *)this + 39) = 0xFFFFFFFFLL;
          if (*((char *)this + 343) < 0)
          {
            **((unsigned char **)this + 40) = 0;
            *((void *)this + 41) = 0;
          }
          else
          {
            *((unsigned char *)this + 320) = 0;
            *((unsigned char *)this + 343) = 0;
          }
          if (__s[0]) {
            long long v70 = __s;
          }
          else {
            long long v70 = "attach failed";
          }
          DNBError::SetErrorString((std::string *)this + 13, v70);
          if (!PIDByName)
          {
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              if (!__p.__r_.__value_.__l.__size_) {
                goto LABEL_189;
              }
              unint64_t v74 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            else
            {
              if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
                goto LABEL_189;
              }
              unint64_t v74 = &__p;
            }
            PIDByuint64_t Name = DNBProcessGetPIDByName((char *)v74);
            if (!PIDByName) {
              goto LABEL_189;
            }
          }
          if (process_does_not_exist(PIDByName))
          {
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to pid that doesn't exist");
            }
            std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
            uint64_t v71 = "no such process.";
LABEL_127:
            cstring_to_asciihex_string(v71, &v115);
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              BOOL v72 = &v115;
            }
            else {
              BOOL v72 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v73 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v73 = v115.__r_.__value_.__l.__size_;
            }
            std::string::append(&__endptr, (const std::string::value_type *)v72, v73);
            if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v115.__r_.__value_.__l.__data_);
            }
            uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__endptr);
            goto LABEL_136;
          }
          if (process_is_already_being_debugged(PIDByName))
          {
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to process already being debugged");
            }
            std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
            uint64_t v71 = "tried to attach to process already being debugged";
            goto LABEL_127;
          }
          *(void *)__val = 0;
          if (attach_failed_due_to_uid_mismatch(PIDByName, &__val[1], __val))
          {
            uid_t v75 = __val[1];
            std::to_string(&v115, __val[1]);
            long long v76 = std::string::insert(&v115, 0, "uid ");
            std::string::size_type v77 = v76->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__endptr.__r_.__value_.__l.__data_ = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
            __endptr.__r_.__value_.__r.__words[2] = v77;
            v76->__r_.__value_.__l.__size_ = 0;
            v76->__r_.__value_.__r.__words[2] = 0;
            v76->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v115.__r_.__value_.__l.__data_);
            }
            uid_t v78 = __val[0];
            std::to_string(&v113, __val[0]);
            uint64_t v79 = std::string::insert(&v113, 0, "uid ");
            std::string::size_type v80 = v79->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v115.__r_.__value_.__l.__data_ = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
            v115.__r_.__value_.__r.__words[2] = v80;
            v79->__r_.__value_.__l.__size_ = 0;
            v79->__r_.__value_.__r.__words[2] = 0;
            v79->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v113.__r_.__value_.__l.__data_);
            }
            unint64_t v81 = getpwuid(v75);
            if (v81 && v81->pw_name) {
              std::string::assign(&__endptr, v81->pw_name);
            }
            long long v82 = getpwuid(v78);
            if (v82 && v82->pw_name) {
              std::string::assign(&v115, v82->pw_name);
            }
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to process with uid mismatch");
            }
            std::string::basic_string[abi:nn180100]<0>(&v113, "E96;");
            std::operator+<char>();
            long long v83 = std::string::append(&v108, "' and process is running as user '");
            std::string::size_type v84 = v83->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v109.__r_.__value_.__l.__data_ = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
            v109.__r_.__value_.__r.__words[2] = v84;
            v83->__r_.__value_.__l.__size_ = 0;
            v83->__r_.__value_.__r.__words[2] = 0;
            v83->__r_.__value_.__r.__words[0] = 0;
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v85 = &v115;
            }
            else {
              uint64_t v85 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v86 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v86 = v115.__r_.__value_.__l.__size_;
            }
            int v87 = std::string::append(&v109, (const std::string::value_type *)v85, v86);
            std::string::size_type v88 = v87->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v110.__r_.__value_.__l.__data_ = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
            v110.__r_.__value_.__r.__words[2] = v88;
            v87->__r_.__value_.__l.__size_ = 0;
            v87->__r_.__value_.__r.__words[2] = 0;
            v87->__r_.__value_.__r.__words[0] = 0;
            long long v89 = std::string::append(&v110, "'");
            std::string::size_type v90 = v89->__r_.__value_.__r.__words[2];
            *(_OWORD *)long long v111 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
            uint64_t v112 = v90;
            v89->__r_.__value_.__l.__size_ = 0;
            v89->__r_.__value_.__r.__words[2] = 0;
            v89->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v110.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v109.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_166:
                if ((SHIBYTE(v108.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_167;
                }
LABEL_224:
                operator delete(v108.__r_.__value_.__l.__data_);
LABEL_167:
                if (v112 >= 0) {
                  long long v91 = v111;
                }
                else {
                  long long v91 = (void **)v111[0];
                }
                cstring_to_asciihex_string((const char *)v91, &v110);
                if ((v110.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v92 = &v110;
                }
                else {
                  uint64_t v92 = (std::string *)v110.__r_.__value_.__r.__words[0];
                }
                if ((v110.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v93 = HIBYTE(v110.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v93 = v110.__r_.__value_.__l.__size_;
                }
                std::string::append(&v113, (const std::string::value_type *)v92, v93);
                if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v110.__r_.__value_.__l.__data_);
                }
                uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v113);
                if (SHIBYTE(v112) < 0)
                {
                  operator delete(v111[0]);
                  if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_180:
                    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_136;
                    }
LABEL_227:
                    operator delete(v115.__r_.__value_.__l.__data_);
LABEL_136:
                    if (SHIBYTE(__endptr.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__endptr.__r_.__value_.__l.__data_);
                    }
                    goto LABEL_138;
                  }
                }
                else if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_180;
                }
                operator delete(v113.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_136;
                }
                goto LABEL_227;
              }
            }
            else if ((SHIBYTE(v109.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_166;
            }
            operator delete(v109.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v108.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_167;
            }
            goto LABEL_224;
          }
LABEL_189:
          std::string::basic_string[abi:nn180100]<0>(&__endptr, "attach failed");
          if (__s[0])
          {
            if (*(void *)__s == 0x7420656C62616E75
              && *(void *)&__s[8] == 0x207472617473206FLL
              && *(void *)&__s[16] == 0x6563786520656874
              && *(void *)&__s[24] == 0x6874206E6F697470
              && *(void *)&__s[29] == 0x64616572687420)
            {
              strcpy(__s, "Not allowed to attach to process.  Look in the console messages (Console.app), near the debugserver entries, when the attach failed.  The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.");
              __s[1023] = 0;
            }
            std::string::append(&__endptr, " (");
            std::string::append(&__endptr, __s);
            std::string::append(&__endptr, ")");
          }
          std::string::basic_string[abi:nn180100]<0>(&v115, "E96;");
          if ((__endptr.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v98 = &__endptr;
          }
          else {
            long long v98 = (std::string *)__endptr.__r_.__value_.__r.__words[0];
          }
          cstring_to_asciihex_string((const char *)v98, &v113);
          if ((v113.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v99 = &v113;
          }
          else {
            uint64_t v99 = (std::string *)v113.__r_.__value_.__r.__words[0];
          }
          if ((v113.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v100 = HIBYTE(v113.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v100 = v113.__r_.__value_.__l.__size_;
          }
          std::string::append(&v115, (const std::string::value_type *)v99, v100);
          if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v113.__r_.__value_.__l.__data_);
          }
          RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v115);
          if (DNBLogEnabled()) {
            _DNBLogError("Attach failed: \"%s\".", __s);
          }
LABEL_84:
          if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v115.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__endptr.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_86;
            }
          }
          else if ((SHIBYTE(__endptr.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_86:
            uint64_t v9 = 1;
            goto LABEL_138;
          }
          operator delete(__endptr.__r_.__value_.__l.__data_);
          goto LABEL_86;
        }
        long long v118 = (char *)(__s1 + 12);
        if (GetProcessNameFrom_vAttach(&v118, &__p))
        {
          if (DNBLogEnabled())
          {
            uint64_t v57 = getpid();
            _DNBLog(0, (uint64_t)"[LaunchAttach] START %d vAttachName attach to process name '%s'", v58, v59, v60, v61, v62, v63, v57);
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v64 = &__p;
          }
          else {
            uint64_t v64 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          uint64_t v31 = DNBProcessAttachByName((char *)v64, 0, (uint64_t)this + 448, __s, 1024);
LABEL_67:
          uint64_t v45 = v31;
          PIDByuint64_t Name = 0;
          goto LABEL_68;
        }
        long long v69 = v118;
        int v65 = this;
        int v66 = 3797;
LABEL_113:
        uint64_t v9 = RNBRemote::HandlePacket_ILLFORMED(v65, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v66, v69, v20);
        goto LABEL_138;
      }
      int v33 = *((unsigned __int8 *)__s1 + 14);
      char v17 = (char *)(__s1 + 14);
      std::string::value_type v32 = v33;
      long long v118 = v17;
      if (!v33)
      {
LABEL_61:
        if (DNBLogEnabled())
        {
          uint64_t v37 = getpid();
          _DNBLog(0, (uint64_t)"[LaunchAttach] START %d vAttachWaitOrWait for process name '%s'", v38, v39, v40, v41, v42, v43, v37);
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v44 = &__p;
        }
        else {
          long long v44 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v31 = DNBProcessAttachWait(this, (char *)v44, 0, 0, 0x3E8u, __s, 0x400uLL, (unsigned int (*)(void *))RNBRemoteShouldCancelCallback, 0);
        goto LABEL_67;
      }
      while (1)
      {
        __endptr.__r_.__value_.__s.__data_[0] = v32;
        *(_WORD *)((char *)&__endptr.__r_.__value_.__l.__data_ + 1) = v17[1];
        *__error() = 0;
        int v34 = strtoul((const char *)&__endptr, 0, 16);
        if (*__error() && v34 == 0) {
          break;
        }
        std::string::push_back(&__p, v34);
        int v36 = v17[2];
        v17 += 2;
        std::string::value_type v32 = v36;
        if (!v36)
        {
          long long v118 = v17;
          goto LABEL_61;
        }
      }
      int v65 = this;
      int v66 = 3783;
    }
    long long v69 = v17;
    goto LABEL_113;
  }
  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)__s);
  uint64_t v6 = __s1 + 5;
  long long v118 = (char *)(__s1 + 5);
  __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(__s1 + 5);
  int64_t v7 = strlen(__s1 + 5);
  if (__s1[5] == 63)
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 13;
    strcpy((char *)&__p, "vCont;c;C;s;S");
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      uint64_t v10 = *(void **)&__s[24];
      if (!*(void *)&__s[24]) {
        goto LABEL_39;
      }
LABEL_38:
      operator delete(v10);
      goto LABEL_39;
    }
LABEL_37:
    uint64_t v10 = *(void **)&__s[24];
    if (!*(void *)&__s[24]) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  if (v7 < 1)
  {
LABEL_36:
    DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)__s, 4, 0);
    DNBProcessResume(*((_DWORD *)this + 3), *(char **)__s, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__s[8] - *(void *)__s) >> 3));
    uint64_t v9 = 0;
    goto LABEL_37;
  }
  uint64_t v11 = &v6[v7];
  size_t v12 = __s1 + 5;
  while (2)
  {
    if (*v12 != 59) {
      goto LABEL_36;
    }
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
    __p.__r_.__value_.__r.__words[2] = -1;
    __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(v12 + 2);
    HIDWORD(v13) = v12[1] - 67;
    LODWORD(v13) = HIDWORD(v13);
    switch((v13 >> 4))
    {
      case 0u:
        *__error() = 0;
        HIDWORD(__p.__r_.__value_.__r.__words[1]) = strtoul(v12 + 2, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error()) {
          goto LABEL_29;
        }
        int v68 = 3714;
        goto LABEL_184;
      case 1u:
        *__error() = 0;
        HIDWORD(__p.__r_.__value_.__r.__words[1]) = strtoul(v12 + 2, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error()) {
          goto LABEL_32;
        }
        int v68 = 3727;
        goto LABEL_184;
      case 2u:
LABEL_29:
        LODWORD(__p.__r_.__value_.__r.__words[1]) = 5;
        goto LABEL_33;
      case 3u:
LABEL_32:
        LODWORD(__p.__r_.__value_.__r.__words[1]) = 6;
        goto LABEL_33;
      default:
        RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 3736, v6, v8);
LABEL_33:
        size_t v12 = (const char *)__endptr.__r_.__value_.__r.__words[0];
        if (*__endptr.__r_.__value_.__l.__data_ != 58) {
          goto LABEL_25;
        }
        *__error() = 0;
        __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(v12 + 1);
        __p.__r_.__value_.__r.__words[0] = strtoul(v12 + 1, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error())
        {
          size_t v12 = (const char *)__endptr.__r_.__value_.__r.__words[0];
LABEL_25:
          DNBThreadResumeActions::Append((char **)__s, (long long *)&__p);
          if (v12 >= v11) {
            goto LABEL_36;
          }
          continue;
        }
        int v68 = 3745;
LABEL_184:
        uint64_t v9 = RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v68, v6, v14);
        uint64_t v10 = *(void **)&__s[24];
        if (*(void *)&__s[24]) {
          goto LABEL_38;
        }
LABEL_39:
        char v15 = *(void **)__s;
        if (*(void *)__s)
        {
          *(void *)&__s[8] = *(void *)__s;
          goto LABEL_140;
        }
        return v9;
    }
  }
}

uint64_t RNBRemote::HandlePacket_x(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (__s && *__s && strlen(__s) > 2)
  {
    std::string __endptr = 0;
    uint64_t v11 = __s + 1;
    *__error() = 0;
    mach_vm_address_t v12 = strtoull(__s + 1, &__endptr, 16);
    if (*__error())
    {
      int64_t v7 = this;
      int v8 = 3170;
LABEL_14:
      uint64_t v9 = v11;
      goto LABEL_5;
    }
    if (*__endptr != 44)
    {
      int64_t v7 = this;
      int v8 = 3174;
      goto LABEL_14;
    }
    uint64_t v11 = __endptr + 1;
    *__error() = 0;
    size_t v13 = strtoul(v11, 0, 16);
    if (*__error())
    {
      int64_t v7 = this;
      int v8 = 3184;
      goto LABEL_14;
    }
    if (v13)
    {
      std::vector<unsigned char>::vector(&v77, v13);
      if (v79 - (void)v77 == v13)
      {
        unint64_t v14 = DNBProcessMemoryRead(*((_DWORD *)this + 3), v12, v78 - v77, v77);
        if (v14)
        {
          unint64_t v15 = v14;
          unint64_t v74 = 0;
          uid_t v75 = 0;
          long long v76 = 0;
          std::vector<unsigned char>::reserve((uint64_t)&v74, v14 + 30);
          uint64_t v16 = 0;
          while (1)
          {
            unsigned int v17 = v77[v16];
            BOOL v18 = v17 > 0x2A || ((1 << v17) & 0x41800000000) == 0;
            if (v18 && v17 != 125)
            {
              std::vector<unsigned char>::push_back[abi:nn180100](&v74, &v77[v16]);
              goto LABEL_20;
            }
            int v19 = v75;
            if (v75 >= v76) {
              break;
            }
            *uid_t v75 = 125;
            char v20 = v19 + 1;
LABEL_58:
            uid_t v75 = v20;
            char v39 = v77[v16] ^ 0x20;
            if (v20 >= v76)
            {
              uint64_t v40 = v74;
              unint64_t v41 = v20 - v74;
              uint64_t v42 = v20 - v74 + 1;
              if (v42 < 0) {
LABEL_110:
              }
                abort();
              unint64_t v43 = v76 - v74;
              if (2 * (v76 - v74) > (unint64_t)v42) {
                uint64_t v42 = 2 * v43;
              }
              if (v43 >= 0x3FFFFFFFFFFFFFFFLL) {
                size_t v44 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                size_t v44 = v42;
              }
              if (v44) {
                uint64_t v45 = (char *)operator new(v44);
              }
              else {
                uint64_t v45 = 0;
              }
              unint64_t v46 = &v45[v41];
              long long v47 = &v45[v44];
              v45[v41] = v39;
              uint64_t v48 = (uint64_t)&v45[v41 + 1];
              if (v20 == v40)
              {
                unint64_t v74 = &v45[v41];
                uid_t v75 = &v45[v41 + 1];
                long long v76 = v47;
              }
              else
              {
                if (v41 < 8 || (unint64_t)(v40 - v45) < 0x20)
                {
                  long long v49 = v20;
                  goto LABEL_72;
                }
                if (v41 >= 0x20)
                {
                  unint64_t v52 = v41 & 0xFFFFFFFFFFFFFFE0;
                  uint64_t v53 = &v45[v41 - 16];
                  uint64_t v54 = (long long *)(v20 - 16);
                  unint64_t v55 = v41 & 0xFFFFFFFFFFFFFFE0;
                  do
                  {
                    long long v56 = *v54;
                    *((_OWORD *)v53 - 1) = *(v54 - 1);
                    *(_OWORD *)uint64_t v53 = v56;
                    v53 -= 32;
                    v54 -= 2;
                    v55 -= 32;
                  }
                  while (v55);
                  if (v41 != v52)
                  {
                    if ((v41 & 0x18) == 0)
                    {
                      v46 -= v52;
                      long long v49 = &v20[-v52];
                      goto LABEL_72;
                    }
                    goto LABEL_85;
                  }
                }
                else
                {
                  unint64_t v52 = 0;
LABEL_85:
                  long long v49 = &v20[-(v41 & 0xFFFFFFFFFFFFFFF8)];
                  v46 -= v41 & 0xFFFFFFFFFFFFFFF8;
                  uint64_t v57 = &v45[&v20[-v52] - v40 - 8];
                  uint64_t v58 = (uint64_t *)&v20[-v52 - 8];
                  unint64_t v59 = v52 - (v41 & 0xFFFFFFFFFFFFFFF8);
                  do
                  {
                    uint64_t v60 = *v58--;
                    *(void *)uint64_t v57 = v60;
                    v57 -= 8;
                    v59 += 8;
                  }
                  while (v59);
                  if (v41 != (v41 & 0xFFFFFFFFFFFFFFF8))
                  {
LABEL_72:
                    uint64_t v50 = v46 - 1;
                    do
                    {
                      char v51 = *--v49;
                      *v50-- = v51;
                    }
                    while (v49 != v40);
                  }
                }
                char v20 = v74;
                unint64_t v74 = v45;
                uid_t v75 = &v45[v41 + 1];
                long long v76 = v47;
                if (!v20)
                {
LABEL_78:
                  uid_t v75 = (char *)v48;
                  goto LABEL_20;
                }
              }
              operator delete(v20);
              goto LABEL_78;
            }
            *char v20 = v39;
            uid_t v75 = v20 + 1;
LABEL_20:
            if (++v16 == v15)
            {
              int v65 = v74;
              uint64_t v64 = v75;
              std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v72);
              unint64_t v66 = v64 - v65;
              if (v64 != v65)
              {
                uint64_t v67 = 0;
                if (v66 <= 1) {
                  uint64_t v68 = 1;
                }
                else {
                  uint64_t v68 = v66;
                }
                do
                {
                  LOBYTE(__p[0]) = v74[v67];
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v72, (uint64_t)__p, 1);
                  ++v67;
                }
                while (v68 != v67);
              }
              std::stringbuf::str();
              uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
              if (v71 < 0) {
                operator delete(__p[0]);
              }
              std::ostringstream::~ostringstream((uint64_t)v72);
              long long v69 = v74;
              if (v74)
              {
                uid_t v75 = v74;
                goto LABEL_105;
              }
              goto LABEL_106;
            }
          }
          long long v21 = v74;
          unint64_t v22 = v75 - v74;
          uint64_t v23 = v75 - v74 + 1;
          if (v23 < 0) {
            goto LABEL_110;
          }
          unint64_t v24 = v76 - v74;
          if (2 * (v76 - v74) > (unint64_t)v23) {
            uint64_t v23 = 2 * v24;
          }
          if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v25 = v23;
          }
          if (v25) {
            uint64_t v26 = (char *)operator new(v25);
          }
          else {
            uint64_t v26 = 0;
          }
          uint64_t v27 = &v26[v22];
          v26[v22] = 125;
          char v20 = &v26[v22 + 1];
          if (v19 == v21)
          {
LABEL_56:
            unint64_t v74 = v27;
            uid_t v75 = &v26[v22 + 1];
            long long v76 = &v26[v25];
            if (v19) {
              operator delete(v19);
            }
            goto LABEL_58;
          }
          if (v22 >= 8 && (unint64_t)(v21 - v26) >= 0x20)
          {
            if (v22 < 0x20)
            {
              unint64_t v28 = 0;
              goto LABEL_48;
            }
            unint64_t v28 = v22 & 0xFFFFFFFFFFFFFFE0;
            uint64_t v29 = &v26[v22 - 16];
            unint64_t v30 = v19 - 16;
            unint64_t v31 = v22 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v32 = *(_OWORD *)v30;
              *((_OWORD *)v29 - 1) = *((_OWORD *)v30 - 1);
              *(_OWORD *)uint64_t v29 = v32;
              v29 -= 32;
              v30 -= 32;
              v31 -= 32;
            }
            while (v31);
            if (v22 == v28) {
              goto LABEL_55;
            }
            if ((v22 & 0x18) != 0)
            {
LABEL_48:
              v27 -= v22 & 0xFFFFFFFFFFFFFFF8;
              int v33 = &v26[&v19[-v28] - v21 - 8];
              int v34 = &v19[-v28 - 8];
              unint64_t v35 = v28 - (v22 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                uint64_t v36 = *(void *)v34;
                v34 -= 8;
                *(void *)int v33 = v36;
                v33 -= 8;
                v35 += 8;
              }
              while (v35);
              v19 -= v22 & 0xFFFFFFFFFFFFFFF8;
              if (v22 == (v22 & 0xFFFFFFFFFFFFFFF8)) {
                goto LABEL_55;
              }
              goto LABEL_53;
            }
            v27 -= v28;
            v19 -= v28;
          }
LABEL_53:
          uint64_t v37 = v27 - 1;
          do
          {
            char v38 = *--v19;
            *v37-- = v38;
          }
          while (v19 != v21);
LABEL_55:
          int v19 = v74;
          uint64_t v27 = v26;
          goto LABEL_56;
        }
        uint64_t v63 = "E80";
      }
      else
      {
        uint64_t v63 = "E79";
      }
      std::string::basic_string[abi:nn180100]<0>(v72, v63);
      uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v72);
      if (v73 < 0)
      {
        long long v69 = (char *)v72[0];
LABEL_105:
        operator delete(v69);
      }
LABEL_106:
      uint64_t v62 = v77;
      if (v77)
      {
        uid_t v78 = v77;
        goto LABEL_108;
      }
    }
    else
    {
      std::string::basic_string[abi:nn180100]<0>(v72, "OK");
      uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v72);
      if (v73 < 0)
      {
        uint64_t v62 = (char *)v72[0];
LABEL_108:
        operator delete(v62);
      }
    }
    return v61;
  }
  int64_t v7 = this;
  int v8 = 3162;
  uint64_t v9 = __s;
LABEL_5:

  return RNBRemote::HandlePacket_ILLFORMED(v7, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v9, a5);
}

uint64_t RNBRemote::HandlePacket_X(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  size_t v5 = __s;
  if (__s && *__s && strlen(__s) > 2)
  {
    std::string __endptr = 0;
    ++v5;
    *__error() = 0;
    unint64_t v10 = strtoull(v5, &__endptr, 16);
    if (*__error() && !v10)
    {
      int64_t v7 = this;
      int v8 = 3234;
      goto LABEL_5;
    }
    uint64_t v11 = __endptr;
    if (*__endptr != 44)
    {
      int64_t v7 = this;
      int v8 = 3238;
      goto LABEL_5;
    }
    size_t v5 = __endptr + 1;
    *__error() = 0;
    unint64_t v12 = strtoul(v11 + 1, 0, 16);
    if (*__error() && !v12)
    {
      int64_t v7 = this;
      int v8 = 3252;
      goto LABEL_5;
    }
    if (!v12)
    {
      std::string::basic_string[abi:nn180100]<0>(v37, "OK");
      uint64_t v23 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v37);
      if ((v38 & 0x80000000) == 0) {
        return v23;
      }
      unint64_t v24 = (void *)v37[0];
LABEL_41:
      operator delete(v24);
      return v23;
    }
    decode_binary_data(v11, 0xFFFFFFFFFFFFFFFFLL, v37);
    unint64_t v13 = v37[0];
    unint64_t v14 = v37[1];
    __chkstk_darwin(v15);
    unsigned int v17 = (char *)v35 - v16;
    bzero((char *)v35 - v16, v18);
    unint64_t v19 = v14 - v13;
    if (v14 != v13)
    {
      char v20 = v17;
      long long v21 = (char *)v13;
      if (v19 < 8) {
        goto LABEL_33;
      }
      char v20 = v17;
      long long v21 = (char *)v13;
      if ((unint64_t)&v17[-v13] < 0x20) {
        goto LABEL_33;
      }
      if (v19 < 0x20)
      {
        unint64_t v22 = 0;
        goto LABEL_28;
      }
      unint64_t v22 = v19 & 0xFFFFFFFFFFFFFFE0;
      size_t v25 = (long long *)(v13 + 16);
      uint64_t v26 = v17 + 16;
      unint64_t v27 = v19 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v28 = *v25;
        *(v26 - 1) = *(v25 - 1);
        _OWORD *v26 = v28;
        v25 += 2;
        v26 += 2;
        v27 -= 32;
      }
      while (v27);
      if (v19 != v22)
      {
        if ((v19 & 0x18) == 0)
        {
          long long v21 = (char *)(v13 + v22);
          char v20 = &v17[v22];
          goto LABEL_33;
        }
LABEL_28:
        char v20 = &v17[v19 & 0xFFFFFFFFFFFFFFF8];
        long long v21 = (char *)(v13 + (v19 & 0xFFFFFFFFFFFFFFF8));
        uint64_t v29 = (uint64_t *)(v13 + v22);
        unint64_t v30 = &v17[v22];
        unint64_t v31 = v22 - (v19 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          uint64_t v32 = *v29++;
          *(void *)unint64_t v30 = v32;
          v30 += 8;
          v31 += 8;
        }
        while (v31);
        if (v19 == (v19 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_34;
        }
        do
        {
LABEL_33:
          char v33 = *v21++;
          *v20++ = v33;
        }
        while (v21 != (char *)v14);
      }
    }
LABEL_34:
    if (DNBProcessMemoryWrite(*((_DWORD *)this + 3), v10, v14 - v13, v17) == v19) {
      int v34 = "OK";
    }
    else {
      int v34 = "E08";
    }
    std::string::basic_string[abi:nn180100]<0>(v35, v34);
    uint64_t v23 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v35);
    if (v36 < 0) {
      operator delete(v35[0]);
    }
    if (!v13) {
      return v23;
    }
    unint64_t v24 = (void *)v13;
    goto LABEL_41;
  }
  int64_t v7 = this;
  int v8 = 3226;
LABEL_5:

  return RNBRemote::HandlePacket_ILLFORMED(v7, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v8, v5, a5);
}

uint64_t RNBRemote::HandlePacket_qRcmd(RNBRemote *this, const char *a2)
{
  memset(&v53, 0, sizeof(v53));
  LOBYTE(v3) = a2[6];
  if ((_BYTE)v3)
  {
    size_t v5 = a2 + 8;
    while (1)
    {
      unsigned __int8 v6 = *(v5 - 1);
      if (!v6)
      {
        *((unsigned char *)&__str.__r_.__value_.__s + 23) = 3;
        strcpy((char *)&__str, "E73");
        uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__str);
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_21;
        }
        goto LABEL_27;
      }
      __str.__r_.__value_.__s.__data_[0] = v3;
      *(_WORD *)((char *)&__str.__r_.__value_.__l.__data_ + 1) = v6;
      *__error() = 0;
      int v7 = strtoul((const char *)&__str, 0, 16);
      BOOL v9 = *__error() && v7 == 0;
      if (v9) {
        break;
      }
      std::string::push_back(&v53, v7);
      int v3 = *(unsigned __int8 *)v5;
      v5 += 2;
      if (!v3) {
        goto LABEL_9;
      }
    }
    uint64_t v14 = RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 1742, a2, v8);
    if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v14;
    }
    goto LABEL_22;
  }
LABEL_9:
  get_identifier(&v53, &__str);
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) == 3)
    {
      p_str = &__str;
      goto LABEL_14;
    }
LABEL_18:
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3749445;
    uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    goto LABEL_19;
  }
  if (__str.__r_.__value_.__l.__size_ != 3) {
    goto LABEL_18;
  }
  p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
LABEL_14:
  int data_low = LOWORD(p_str->__r_.__value_.__l.__data_);
  int v12 = p_str->__r_.__value_.__s.__data_[2];
  if (data_low != 25971 || v12 != 116) {
    goto LABEL_18;
  }
  get_identifier(&v53, &__p);
  memset(&v50, 0, sizeof(v50));
  unsigned int v16 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  if ((*((unsigned char *)&v53.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    std::string::size_type size = v53.__r_.__value_.__l.__size_;
    if (!v53.__r_.__value_.__l.__size_)
    {
      memset(&v49, 0, sizeof(v49));
      goto LABEL_55;
    }
    unsigned int v17 = (std::string *)v53.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&v53.__r_.__value_.__s + 23)) {
      goto LABEL_44;
    }
    unsigned int v17 = &v53;
    std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  unint64_t v19 = k_space_delimiters;
  size_t v20 = strlen(k_space_delimiters);
  long long v21 = v17;
  if (v20)
  {
    size_t v22 = v20;
    long long v21 = v17;
    while (memchr(v19, v21->__r_.__value_.__s.__data_[0], v22))
    {
      long long v21 = (std::string *)((char *)v21 + 1);
      if (!--size)
      {
        std::string::size_type v23 = -1;
        goto LABEL_42;
      }
    }
  }
  std::string::size_type v23 = (char *)v21 - (char *)v17;
  if (v21 != v17)
  {
LABEL_42:
    std::string::erase(&v53, 0, v23);
    unsigned int v16 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  if ((v16 & 0x80) == 0)
  {
LABEL_44:
    int v24 = 0;
    if (!v16) {
      goto LABEL_51;
    }
    goto LABEL_47;
  }
  int v24 = 1;
  if (!v53.__r_.__value_.__l.__size_) {
    goto LABEL_51;
  }
LABEL_47:
  BOOL v9 = v24 == 0;
  size_t v25 = &v53;
  if (!v9) {
    size_t v25 = (std::string *)v53.__r_.__value_.__r.__words[0];
  }
  if (v25->__r_.__value_.__s.__data_[0] == 61)
  {
    std::string::operator=(&v50, 61);
    std::string::erase(&v53, 0, 1uLL);
    unsigned int v16 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
LABEL_51:
  memset(&v49, 0, sizeof(v49));
  if ((v16 & 0x80) != 0)
  {
LABEL_55:
    std::string::size_type v26 = v53.__r_.__value_.__l.__size_;
    if (!v53.__r_.__value_.__l.__size_) {
      goto LABEL_67;
    }
    unint64_t v27 = (std::string *)v53.__r_.__value_.__r.__words[0];
    goto LABEL_57;
  }
  if (!v16) {
    goto LABEL_65;
  }
  std::string::size_type v26 = v16;
  unint64_t v27 = &v53;
LABEL_57:
  long long v28 = k_space_delimiters;
  size_t v29 = strlen(k_space_delimiters);
  unint64_t v30 = v27;
  if (v29)
  {
    size_t v31 = v29;
    unint64_t v30 = v27;
    while (memchr(v28, v30->__r_.__value_.__s.__data_[0], v31))
    {
      unint64_t v30 = (std::string *)((char *)v30 + 1);
      if (!--v26)
      {
        std::string::size_type v32 = -1;
        goto LABEL_63;
      }
    }
  }
  std::string::size_type v32 = (char *)v30 - (char *)v27;
  if (v30 != v27)
  {
LABEL_63:
    std::string::erase(&v53, 0, v32);
    unsigned int v16 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  if ((v16 & 0x80) == 0)
  {
LABEL_65:
    if (!v16) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  if (v53.__r_.__value_.__l.__size_)
  {
LABEL_66:
    std::string v49 = v53;
    memset(&v53, 0, sizeof(v53));
  }
LABEL_67:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ == 7)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (*(_DWORD *)__p.__r_.__value_.__l.__data_ != 1718054764
        || *(_DWORD *)(__p.__r_.__value_.__r.__words[0] + 3) != 1701603686)
      {
        goto LABEL_79;
      }
LABEL_94:
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v40 = &v49;
      }
      else {
        uint64_t v40 = (std::string *)v49.__r_.__value_.__r.__words[0];
      }
      unint64_t v41 = fopen((const char *)v40, "w");
      if (!v41)
      {
        char v48 = 3;
        int v39 = 3225413;
        goto LABEL_84;
      }
      DNBLogSetLogCallback(FileLogCallback, (uint64_t)v41);
      char v48 = 2;
      strcpy((char *)v47, "OK");
      goto LABEL_85;
    }
LABEL_83:
    char v48 = 3;
    int v39 = 3159877;
LABEL_84:
    LODWORD(v47[0]) = v39;
    goto LABEL_85;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 7) {
    goto LABEL_83;
  }
  if (LODWORD(__p.__r_.__value_.__l.__data_) == 1718054764
    && *(_DWORD *)((char *)__p.__r_.__value_.__r.__words + 3) == 1701603686)
  {
    goto LABEL_94;
  }
  p_p = &__p;
LABEL_79:
  int data = (int)p_p->__r_.__value_.__l.__data_;
  int v37 = *(_DWORD *)((char *)p_p->__r_.__value_.__r.__words + 3);
  if (data != 1835495276 || v37 != 1802723693) {
    goto LABEL_83;
  }
  unint64_t v46 = 0;
  *__error() = 0;
  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v42 = &v49;
  }
  else {
    uint64_t v42 = (std::string *)v49.__r_.__value_.__r.__words[0];
  }
  int v43 = strtoul((const char *)v42, &v46, 0);
  if (*__error() || !v46 || *v46)
  {
    *__error() = 0;
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v44 = &v49;
    }
    else {
      size_t v44 = (std::string *)v49.__r_.__value_.__r.__words[0];
    }
    int v45 = strtoul((const char *)v44, &v46, 16);
    if (*__error() || !v46 || *v46)
    {
      char v48 = 3;
      int v39 = 3290949;
      goto LABEL_84;
    }
    DNBLogSetLogMask(v45);
  }
  else
  {
    DNBLogSetLogMask(v43);
    if (!DNBLogGetLogCallback()) {
      DNBLogSetLogCallback(ASLLogCallback, 0);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v47, "OK");
LABEL_85:
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v47);
  if ((v48 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_87;
    }
LABEL_90:
    operator delete(v49.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_91;
  }
  operator delete(v47[0]);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_90;
  }
LABEL_87:
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_19;
  }
LABEL_91:
  operator delete(v50.__r_.__value_.__l.__data_);
LABEL_19:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_27:
    operator delete(__str.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v14;
    }
    goto LABEL_22;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_27;
  }
LABEL_21:
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
LABEL_22:
  }
    operator delete(v53.__r_.__value_.__l.__data_);
  return v14;
}

uint64_t RNBRemote::HandlePacket_qC(RNBRemote *this, const char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v12 + (void)*(v12 - 3)) = v3;
  size_t v4 = (std::ios_base *)((char *)&v12 + (void)*(v12 - 3));
  std::ios_base::init(v4, &v13);
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)uint64_t v14 = 0u;
  long long v15 = 0u;
  int v16 = 16;
  int v5 = *((_DWORD *)this + 3);
  if (v5)
  {
    uint64_t CurrentThread = DNBProcessGetCurrentThread(v5);
    DNBProcessSetCurrentThread(*((_DWORD *)this + 3), CurrentThread);
    *((void *)this + 68) = CurrentThread;
  }
  int v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v12, (uint64_t)"QC", 2);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) = *(_DWORD *)((unsigned char *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v11 < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v15) < 0) {
    operator delete(v14[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v8;
}

uint64_t RNBRemote::HandlePacket_qEcho(RNBRemote *this, const char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  int v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unsigned __int8 v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v12 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v12) = v4;
  unsigned __int8 v6 = __dst;
  if (v4) {
LABEL_8:
  }
    memcpy(v6, __s, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__dst);
  if (SHIBYTE(v12) < 0) {
    operator delete(__dst[0]);
  }
  return v9;
}

uint64_t RNBRemote::HandlePacket_qGetPid(RNBRemote *this, const char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v9 + (void)*(v9 - 3)) = v3;
  size_t v4 = (std::ios_base *)((char *)&v9 + (void)*(v9 - 3));
  std::ios_base::init(v4, &v10);
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)char v11 = 0u;
  long long v12 = 0u;
  int v13 = 16;
  *(_DWORD *)((char *)&v9 + (void)*(v9 - 3) + 8) = *(_DWORD *)((unsigned char *)&v9 + (void)*(v9 - 3) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v12) < 0) {
    operator delete(v11[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v5;
}

uint64_t RNBRemote::HandlePacket_qThreadInfo(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    if (a2[1] == 102)
    {
      uint64_t NumThreads = DNBProcessGetNumThreads(*((_DWORD *)this + 3));
      *(void **)((char *)&v12 + *((void *)v12 - 3)) = v5;
      unsigned __int8 v6 = (std::ios_base *)((char *)&v12 + *((void *)v12 - 3));
      std::ios_base::init(v6, &v13);
      v6[1].__vftable = 0;
      v6[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf();
      *(_OWORD *)long long v15 = 0u;
      long long v16 = 0u;
      int v17 = 16;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v12, (uint64_t)"m", 1);
      if (NumThreads)
      {
        DNBProcessGetThreadAtIndex(v3, 0);
        *(_DWORD *)((char *)&v12 + *((void *)v12 - 3) + 8) = *(_DWORD *)((unsigned char *)&v12 + *((void *)v12 - 3) + 8) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
        if (NumThreads != 1)
        {
          for (unint64_t i = 1; i != NumThreads; ++i)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v12, (uint64_t)",", 1);
            DNBProcessGetThreadAtIndex(v3, i);
            *(_DWORD *)((char *)&v13 + *((void *)v12 - 3)) = *(_DWORD *)((unsigned char *)&v13 + *((void *)v12 - 3)) & 0xFFFFFFB5 | 8;
            std::ostream::operator<<();
          }
        }
      }
      std::stringbuf::str();
      uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
      if (v11 < 0) {
        operator delete(__p);
      }
      if (SBYTE7(v16) < 0) {
        operator delete(v15[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      return v8;
    }
    char v14 = 1;
    LOWORD(v12) = 108;
  }
  else
  {
    char v14 = 2;
    strcpy((char *)&v12, "OK");
  }
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v12);
  if (v14 < 0) {
    operator delete(v12);
  }
  return v8;
}

uint64_t RNBRemote::HandlePacket_qThreadStopInfo(RNBRemote *this, const char *a2)
{
  unint64_t v3 = strtoul(a2 + 15, 0, 16);

  return RNBRemote::SendStopReplyPacketForThread(this, v3);
}

uint64_t RNBRemote::HandlePacket_qThreadExtraInfo(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v5 = this;
  int v6 = *((_DWORD *)this + 3);
  if (v6)
  {
    uint64_t v7 = a2 + 17;
    if (a2[16] != 44)
    {
      int v9 = 1659;
      goto LABEL_8;
    }
    *__error() = 0;
    unint64_t v8 = strtoul(v7, 0, 16);
    if (*__error() && !v8)
    {
      this = v5;
      int v9 = 1665;
LABEL_8:
      return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v9, v7, a5);
    }
    Info = DNBThreadGetInfo(v6, v8);
    if (Info)
    {
      long long v12 = Info;
      if (*Info)
      {
        size_t v13 = strlen(Info);
        return RNBRemote::SendHexEncodedBytePacket(v5, 0, v12, v13, 0);
      }
    }
    char v16 = 4;
    strcpy((char *)__p, "4f6b");
  }
  else
  {
    char v16 = 2;
    strcpy((char *)__p, "OK");
  }
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)v5, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  return v14;
}

uint64_t RNBRemote::HandlePacket_qLaunchSuccess(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3) && *((_DWORD *)this + 78))
  {
    *(void **)((char *)&__p + *((void *)__p - 3)) = v4;
    uint64_t v5 = (std::ios_base *)((char *)&__p + *((void *)__p - 3));
    std::ios_base::init(v5, &v31);
    v5[1].__vftable = 0;
    v5[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    long long v33 = 0u;
    long long v34 = 0u;
    int v35 = 16;
    v28[0] = 0;
    v28[1] = 0;
    uint64_t v29 = 0;
    int v6 = (const char *)RNBContext::LaunchStatusAsString((uint64_t)this, (uint64_t)v28);
    size_t v7 = strlen(v6);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v8 = v7;
    if (v7 >= 0x17)
    {
      uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v10 = v7 | 7;
      }
      uint64_t v11 = v10 + 1;
      p_dst = (void **)operator new(v10 + 1);
      size_t v25 = v8;
      int64_t v26 = v11 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v26) = v7;
      p_dst = (void **)&__dst;
      if (!v7)
      {
LABEL_13:
        *((unsigned char *)p_dst + v8) = 0;
        memset(&v27, 0, sizeof(v27));
        int v12 = SHIBYTE(v26);
        size_t v13 = __dst;
        if (v26 >= 0) {
          size_t v14 = HIBYTE(v26);
        }
        else {
          size_t v14 = v25;
        }
        if (v26 >= 0) {
          long long v15 = (void **)&__dst;
        }
        else {
          long long v15 = __dst;
        }
        for (; v14; --v14)
        {
          unsigned int v17 = *(unsigned __int8 *)v15;
          long long v15 = (void **)((char *)v15 + 1);
          unsigned int v16 = v17;
          uint64_t v18 = (1 << v17) & 0x41800000000;
          BOOL v19 = v17 > 0x2A || v18 == 0;
          if (!v19 || v16 == 125)
          {
            std::string::push_back(&v27, 125);
            LOBYTE(v16) = v16 ^ 0x20;
          }
          std::string::push_back(&v27, v16);
        }
        if (v12 < 0) {
          operator delete(v13);
        }
        size_t v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"E", 1);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v21 = &v27;
        }
        else {
          long long v21 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v27.__r_.__value_.__l.__size_;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, size);
        std::stringbuf::str();
        uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__dst);
        if (SHIBYTE(v26) < 0)
        {
          operator delete(__dst);
          if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_40:
            if ((SHIBYTE(v29) & 0x80000000) == 0)
            {
LABEL_41:
              if (SBYTE7(v34) < 0) {
                operator delete((void *)v33);
              }
              std::streambuf::~streambuf();
              std::ostream::~ostream();
              std::ios::~ios();
              return v3;
            }
LABEL_47:
            operator delete(v28[0]);
            goto LABEL_41;
          }
        }
        else if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_40;
        }
        operator delete(v27.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v29) & 0x80000000) == 0) {
          goto LABEL_41;
        }
        goto LABEL_47;
      }
    }
    memmove(p_dst, v6, v8);
    goto LABEL_13;
  }
  char v32 = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v32 < 0) {
    operator delete(__p);
  }
  return v3;
}

uint64_t RNBRemote::HandlePacket_qRegisterInfo(RNBRemote *this, const char *a2)
{
  if (!g_num_reg_entries) {
    RNBRemote::InitializeRegisters(this, 0);
  }
  unint64_t v78 = 0;
  uint64_t v4 = DNBGetRegisterSetInfo(&v78);
  unint64_t v5 = strtoul(a2 + 13, 0, 16);
  if (v5 >= g_num_reg_entries)
  {
    char v73 = 3;
    LODWORD(__p) = 3486789;
    uint64_t v25 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (v73 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v68 = this;
    uint64_t v6 = g_reg_entries;
    *(void **)((char *)&__p + *((void *)__p - 3)) = v7;
    size_t v8 = (std::ios_base *)((char *)&__p + *((void *)__p - 3));
    std::ios_base::init(v8, &v72);
    v8[1].__vftable = 0;
    v8[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)unint64_t v74 = 0u;
    long long v75 = 0u;
    int v76 = 16;
    unint64_t v9 = v6 + (v5 << 7);
    uint64_t v10 = (const char **)(v9 + 16);
    if (*(void *)(v9 + 16))
    {
      uint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"name:", 5);
      size_t v12 = strlen(*v10);
      size_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)*v10, v12);
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&v69, 1);
    }
    uint64_t v15 = *(void *)(v9 + 24);
    size_t v14 = (const char **)(v9 + 24);
    if (v15)
    {
      unsigned int v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"alt-name:", 9);
      size_t v17 = strlen(*v14);
      uint64_t v18 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)*v14, v17);
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)&v69, 1);
    }
    BOOL v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"bitsize:", 8);
    *(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 8) = *(_DWORD *)((unsigned char *)v19 + *(void *)(*v19 - 24) + 8) & 0xFFFFFFB5 | 2;
    unint64_t v20 = v6 + (v5 << 7);
    long long v21 = (void *)std::ostream::operator<<();
    LOBYTE(v69.__locale_) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)&v69, 1);
    size_t v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"offset:", 7);
    *(_DWORD *)((char *)v22 + *(void *)(*v22 - 24) + 8) = *(_DWORD *)((unsigned char *)v22 + *(void *)(*v22 - 24) + 8) & 0xFFFFFFB5 | 2;
    std::string::size_type v23 = (void *)std::ostream::operator<<();
    LOBYTE(v69.__locale_) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)&v69, 1);
    switch(*(_WORD *)(v20 + 32))
    {
      case 1:
        int v24 = "encoding:uint;";
        goto LABEL_13;
      case 2:
        int v24 = "encoding:sint;";
LABEL_13:
        uint64_t v26 = 14;
        goto LABEL_16;
      case 3:
        int v24 = "encoding:ieee754;";
        uint64_t v26 = 17;
        goto LABEL_16;
      case 4:
        int v24 = "encoding:vector;";
        uint64_t v26 = 16;
LABEL_16:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)v24, v26);
        break;
      default:
        break;
    }
    switch(*(_WORD *)(v20 + 34))
    {
      case 1:
        std::string v27 = "format:binary;";
        uint64_t v28 = 14;
        goto LABEL_33;
      case 2:
        std::string v27 = "format:decimal;";
        uint64_t v28 = 15;
        goto LABEL_33;
      case 3:
        std::string v27 = "format:hex;";
        uint64_t v28 = 11;
        goto LABEL_33;
      case 4:
        std::string v27 = "format:float;";
        uint64_t v28 = 13;
        goto LABEL_33;
      case 5:
        std::string v27 = "format:vector-sint8;";
        goto LABEL_24;
      case 6:
        std::string v27 = "format:vector-uint8;";
LABEL_24:
        uint64_t v28 = 20;
        goto LABEL_33;
      case 7:
        std::string v27 = "format:vector-sint16;";
        goto LABEL_29;
      case 8:
        std::string v27 = "format:vector-uint16;";
        goto LABEL_29;
      case 9:
        std::string v27 = "format:vector-sint32;";
        goto LABEL_29;
      case 0xA:
        std::string v27 = "format:vector-uint32;";
LABEL_29:
        uint64_t v28 = 21;
        goto LABEL_33;
      case 0xB:
        std::string v27 = "format:vector-float32;";
        goto LABEL_32;
      case 0xC:
        std::string v27 = "format:vector-uint128;";
LABEL_32:
        uint64_t v28 = 22;
LABEL_33:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)v27, v28);
        break;
      default:
        break;
    }
    if (v4)
    {
      unsigned int v30 = *((_DWORD *)v10 - 2);
      uint64_t v29 = (unsigned int *)(v10 - 1);
      if (v78 > v30)
      {
        size_t v31 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"set:", 4);
        char v32 = *(const char **)(v4 + 24 * *v29);
        size_t v33 = strlen(v32);
        long long v34 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)v32, v33);
        LOBYTE(v69.__locale_) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)&v69, 1);
      }
    }
    if (*(_DWORD *)(v6 + (v5 << 7) + 44) != -1)
    {
      int v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"ehframe:", 8);
      *(_DWORD *)((char *)v35 + *(void *)(*v35 - 24) + 8) = *(_DWORD *)((unsigned char *)v35 + *(void *)(*v35 - 24) + 8) & 0xFFFFFFB5 | 2;
      char v36 = (void *)std::ostream::operator<<();
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)&v69, 1);
    }
    if (*(_DWORD *)(v6 + (v5 << 7) + 48) != -1)
    {
      int v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"dwarf:", 6);
      *(_DWORD *)((char *)v37 + *(void *)(*v37 - 24) + 8) = *(_DWORD *)((unsigned char *)v37 + *(void *)(*v37 - 24) + 8) & 0xFFFFFFB5 | 2;
      char v38 = (void *)std::ostream::operator<<();
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v38, (uint64_t)&v69, 1);
    }
    unint64_t v39 = v6 + (v5 << 7);
    switch(*(_DWORD *)(v39 + 52))
    {
      case 0:
        uint64_t v40 = "generic:pc;";
        goto LABEL_46;
      case 1:
        uint64_t v40 = "generic:sp;";
        goto LABEL_46;
      case 2:
        uint64_t v40 = "generic:fp;";
        goto LABEL_46;
      case 3:
        uint64_t v40 = "generic:ra;";
LABEL_46:
        uint64_t v41 = 11;
        goto LABEL_57;
      case 4:
        uint64_t v40 = "generic:flags;";
        uint64_t v41 = 14;
        goto LABEL_57;
      case 5:
        uint64_t v40 = "generic:arg1;";
        goto LABEL_56;
      case 6:
        uint64_t v40 = "generic:arg2;";
        goto LABEL_56;
      case 7:
        uint64_t v40 = "generic:arg3;";
        goto LABEL_56;
      case 8:
        uint64_t v40 = "generic:arg4;";
        goto LABEL_56;
      case 9:
        uint64_t v40 = "generic:arg5;";
        goto LABEL_56;
      case 0xA:
        uint64_t v40 = "generic:arg6;";
        goto LABEL_56;
      case 0xB:
        uint64_t v40 = "generic:arg7;";
        goto LABEL_56;
      case 0xC:
        uint64_t v40 = "generic:arg8;";
LABEL_56:
        uint64_t v41 = 13;
LABEL_57:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)v40, v41);
        break;
      default:
        break;
    }
    uint64_t v43 = *(void *)(v39 + 80);
    uint64_t v42 = (void *)(v39 + 80);
    size_t v44 = v42 + 1;
    if (v43 != v42[1])
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"container-regs:", 15);
      uint64_t v45 = *v44 - *v42;
      if (*v44 != *v42)
      {
        if ((unint64_t)(v45 >> 2) <= 1) {
          uint64_t v46 = 1;
        }
        else {
          uint64_t v46 = v45 >> 2;
        }
        long long v47 = __p;
        char v48 = (char *)&__p + *((void *)__p - 3);
        if (*((_DWORD *)v48 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
          std::string v49 = std::locale::use_facet(&v69, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 32);
          std::locale::~locale(&v69);
          long long v47 = __p;
        }
        *((_DWORD *)v48 + 36) = 48;
        *(_DWORD *)((char *)&__p + *(v47 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v47 - 3) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&__p + *(v47 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v47 - 3) + 8) & 0xFFFFFF4F | 0x80;
        std::ostream::operator<<();
        if ((unint64_t)v45 >= 8)
        {
          uint64_t v60 = 1;
          do
          {
            LOBYTE(v69.__locale_) = 44;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v69, 1);
            uint64_t v61 = __p;
            uint64_t v62 = (char *)&__p + *((void *)__p - 3);
            if (*((_DWORD *)v62 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
              uint64_t v63 = std::locale::use_facet(&v69, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v63->__vftable[2].~facet_0)(v63, 32);
              std::locale::~locale(&v69);
              uint64_t v61 = __p;
            }
            *((_DWORD *)v62 + 36) = 48;
            *(_DWORD *)((char *)&v72 + *(v61 - 3)) = *(_DWORD *)((unsigned char *)&v72 + *(v61 - 3)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&v72 + *(v61 - 3)) = *(_DWORD *)((unsigned char *)&v72 + *(v61 - 3)) & 0xFFFFFF4F | 0x80;
            std::ostream::operator<<();
            ++v60;
          }
          while (v46 != v60);
        }
      }
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v69, 1);
    }
    unint64_t v50 = v6 + (v5 << 7);
    uint64_t v52 = *(void *)(v50 + 104);
    char v51 = (void *)(v50 + 104);
    std::string v53 = v51 + 1;
    if (v52 != v51[1])
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"invalidate-regs:", 16);
      uint64_t v54 = *v53 - *v51;
      if (*v53 != *v51)
      {
        if ((unint64_t)(v54 >> 2) <= 1) {
          uint64_t v55 = 1;
        }
        else {
          uint64_t v55 = v54 >> 2;
        }
        long long v56 = __p;
        uint64_t v57 = (char *)&__p + *((void *)__p - 3);
        if (*((_DWORD *)v57 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
          uint64_t v58 = std::locale::use_facet(&v69, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 32);
          std::locale::~locale(&v69);
          long long v56 = __p;
        }
        *((_DWORD *)v57 + 36) = 48;
        *(_DWORD *)((char *)&__p + *(v56 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v56 - 3) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&__p + *(v56 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v56 - 3) + 8) & 0xFFFFFF4F | 0x80;
        std::ostream::operator<<();
        if ((unint64_t)v54 >= 8)
        {
          uint64_t v64 = 1;
          do
          {
            LOBYTE(v69.__locale_) = 44;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v69, 1);
            int v65 = __p;
            unint64_t v66 = (char *)&__p + *((void *)__p - 3);
            if (*((_DWORD *)v66 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
              uint64_t v67 = std::locale::use_facet(&v69, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 32);
              std::locale::~locale(&v69);
              int v65 = __p;
            }
            *((_DWORD *)v66 + 36) = 48;
            *(_DWORD *)((char *)&v72 + *(v65 - 3)) = *(_DWORD *)((unsigned char *)&v72 + *(v65 - 3)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&v72 + *(v65 - 3)) = *(_DWORD *)((unsigned char *)&v72 + *(v65 - 3)) & 0xFFFFFF4F | 0x80;
            std::ostream::operator<<();
            ++v64;
          }
          while (v55 != v64);
        }
      }
      LOBYTE(v69.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v69, 1);
    }
    std::stringbuf::str();
    uint64_t v25 = RNBRemote::SendPacket((uint64_t)v68, (uint64_t)&v69);
    if (v70 < 0) {
      operator delete(v69.__locale_);
    }
    if (SBYTE7(v75) < 0) {
      operator delete(v74[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  return v25;
}

uint64_t RNBRemote::HandlePacket_qShlibInfoAddr(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3 || DNBProcessGetSharedLibraryInfoAddress(v3) == -1)
  {
    char v15 = 3;
    LODWORD(v13) = 3421253;
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v13);
    if (v15 < 0) {
      operator delete(v13);
    }
  }
  else
  {
    *(void **)((char *)&v13 + *((void *)v13 - 3)) = v4;
    unint64_t v5 = (std::ios_base *)((char *)&v13 + *((void *)v13 - 3));
    std::ios_base::init(v5, &v14);
    v5[1].__vftable = 0;
    v5[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)unsigned int v16 = 0u;
    long long v17 = 0u;
    int v18 = 16;
    uint64_t v6 = v13;
    size_t v7 = (char *)&v13 + *((void *)v13 - 3);
    if (*((_DWORD *)v7 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v13 + *((void *)v13 - 3)));
      size_t v8 = std::locale::use_facet((const std::locale *)__p, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
      std::locale::~locale((std::locale *)__p);
      uint64_t v6 = v13;
    }
    *((_DWORD *)v7 + 36) = 48;
    *(_DWORD *)((char *)&v13 + *(v6 - 3) + 8) = *(_DWORD *)((unsigned char *)&v13 + *(v6 - 3) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v13 + *(v6 - 3) + 8) = *(_DWORD *)((unsigned char *)&v13 + *(v6 - 3) + 8) & 0xFFFFFF4F | 0x80;
    std::ostream::operator<<();
    std::stringbuf::str();
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE7(v17) < 0) {
      operator delete(v16[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  return v9;
}

uint64_t RNBRemote::HandlePacket_qStepPacketSupported(RNBRemote *this, const char *a2)
{
  char v5 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_qVAttachOrWaitSupported(RNBRemote *this, const char *a2)
{
  char v5 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_qSyncThreadStateSupported(RNBRemote *this, const char *a2)
{
  char v5 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_qHostInfo(RNBRemote *this, const char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v42 + (void)*(v42 - 3)) = v3;
  uint64_t v4 = (std::ios_base *)((char *)&v42 + (void)*(v42 - 3));
  std::ios_base::init(v4, &v43);
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long __p = 0u;
  long long v45 = 0u;
  int v46 = 16;
  int v5 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype;
  if (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype)
  {
    int v6 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64;
    goto LABEL_15;
  }
  GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64 = 0;
  size_t v35 = 4;
  if (!sysctlbyname("hw.cputype", &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype, &v35, 0, 0))
  {
    size_t v35 = 4;
    if (!sysctlbyname("hw.cpu64bit_capable", &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_is_64_bit_capable, &v35, 0, 0)&& GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_is_64_bit_capable&& (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype & 0x1000000) == 0)
    {
      GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64 = 1;
      GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype |= 0x1000000u;
    }
  }
  size_t v35 = 4;
  int v7 = sysctlbyname("hw.cpusubtype", &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype, &v35, 0, 0);
  int v5 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype;
  int v6 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64;
  if (!v7
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype == 16777223
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype == 4)
  {
    GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype = 3;
    int v6 = 1;
    int v5 = 16777223;
    goto LABEL_15;
  }
  if (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype)
  {
LABEL_15:
    size_t v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"cputype:", 8);
    *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = *(_DWORD *)((unsigned char *)v8 + *(void *)(*v8 - 24) + 8) & 0xFFFFFFB5 | 2;
    uint64_t v9 = (void *)std::ostream::operator<<();
    LOBYTE(v35) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)&v35, 1);
    uint64_t v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"cpusubtype:", 11);
    *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 2;
    uint64_t v11 = (void *)std::ostream::operator<<();
    LOBYTE(v35) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)&v35, 1);
  }
  unsigned int v41 = 0;
  if (DNBGetAddressingBits(&v41))
  {
    char v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"addressing_bits:", 16);
    *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24) + 8) = *(_DWORD *)((unsigned char *)v12 + *(void *)(*v12 - 24) + 8) & 0xFFFFFFB5 | 2;
    size_t v13 = (void *)std::ostream::operator<<();
    LOBYTE(v35) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&v35, 1);
  }
  if (v5 == 12 || v5 == 33554444 || v5 == 16777228)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"ostype:ios;", 11);
    size_t v14 = "watchpoint_exceptions_received:before;";
    uint64_t v15 = 38;
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"ostype:macosx;", 14);
    size_t v14 = "watchpoint_exceptions_received:after;";
    uint64_t v15 = 37;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)v14, v15);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"vendor:apple;", 13);
  unint64_t v39 = 0;
  unint64_t v40 = 0;
  unint64_t v38 = 0;
  if (DNBGetOSVersionNumbers(&v40, &v39, &v38))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"os_version:", 11);
    unsigned int v16 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)".", 1);
    std::ostream::operator<<();
    if (v38 != -1)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)".", 1);
      std::ostream::operator<<();
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)";", 1);
  }
  DNBGetMacCatalystVersionString();
  if ((char)v37 < 0)
  {
    uint64_t v17 = v36;
    if (v36)
    {
      int v18 = (unsigned __int8 *)v35;
LABEL_32:
      while (1)
      {
        int v19 = *v18;
        if (v19 != 46 && (v19 - 48) >= 0xA) {
          break;
        }
        ++v18;
        if (!--v17)
        {
          long long v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"maccatalyst_version:", 20);
          if ((v37 & 0x80u) == 0) {
            uint64_t v22 = (uint64_t)&v35;
          }
          else {
            uint64_t v22 = v35;
          }
          if ((v37 & 0x80u) == 0) {
            uint64_t v23 = v37;
          }
          else {
            uint64_t v23 = v36;
          }
          int v24 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, v22, v23);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)";", 1);
          break;
        }
      }
    }
  }
  else
  {
    uint64_t v17 = v37;
    if (v37)
    {
      int v18 = (unsigned __int8 *)&v35;
      goto LABEL_32;
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"endian:little;", 14);
  if (v6)
  {
    uint64_t v25 = (void **)"ptrsize:8;";
    uint64_t v26 = &v42;
    uint64_t v27 = 10;
  }
  else
  {
    uint64_t v28 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"ptrsize:", 8);
    *(_DWORD *)((char *)v28 + *(void *)(*v28 - 24) + 8) = *(_DWORD *)((unsigned char *)v28 + *(void *)(*v28 - 24) + 8) & 0xFFFFFFB5 | 2;
    uint64_t v26 = (void (__cdecl ***)(std::ostringstream *__hidden))std::ostream::operator<<();
    LOBYTE(v33[0]) = 59;
    uint64_t v25 = v33;
    uint64_t v27 = 1;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)v25, v27);
  uint64_t v29 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v42, (uint64_t)"vm-page-size:", 13);
  *(_DWORD *)((char *)v29 + *(void *)(*v29 - 24) + 8) = *(_DWORD *)((unsigned char *)v29 + *(void *)(*v29 - 24) + 8) & 0xFFFFFFB5 | 2;
  unsigned int v30 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)";", 1);
  std::stringbuf::str();
  uint64_t v31 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v33);
  if (v34 < 0)
  {
    operator delete(v33[0]);
    if (((char)v37 & 0x80000000) == 0) {
      goto LABEL_49;
    }
  }
  else if (((char)v37 & 0x80000000) == 0)
  {
    goto LABEL_49;
  }
  operator delete((void *)v35);
LABEL_49:
  if (SBYTE7(v45) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v31;
}

uint64_t RNBRemote::HandlePacket_qGDBServerVersion(RNBRemote *this, const char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v10 + (void)*(v10 - 3)) = v3;
  uint64_t v4 = (std::ios_base *)((char *)&v10 + (void)*(v10 - 3));
  std::ios_base::init(v4, &v11);
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)char v12 = 0u;
  long long v13 = 0u;
  int v14 = 16;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v10, (uint64_t)"name:debugserver;", 17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v10, (uint64_t)"version:", 8);
  int v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)";", 1);
  std::stringbuf::str();
  uint64_t v6 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v9 < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v13) < 0) {
    operator delete(v12[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v6;
}

uint64_t RNBRemote::HandlePacket_qProcessInfo(RNBRemote *this, const char *a2)
{
  uint64_t v2 = __chkstk_darwin(this);
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v54 + (void)*(v54 - 3)) = v3;
  uint64_t v4 = (std::ios_base *)((char *)&v54 + (void)*(v54 - 3));
  std::ios_base::init(v4, &v55);
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long v56 = 0u;
  long long v57 = 0u;
  int v58 = 16;
  int v6 = *(_DWORD *)(v2 + 12);
  if (!v6)
  {
    char v61 = 3;
    strcpy((char *)v60, "E68");
    goto LABEL_40;
  }
  int v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"pid:", 4);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) = *(_DWORD *)((unsigned char *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  size_t v8 = (void *)std::ostream::operator<<();
  LOBYTE(v60[0]) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)v60, 1);
  *(void *)int v65 = 0xE00000001;
  v65[2] = 1;
  v65[3] = v6;
  size_t v53 = 648;
  if (!sysctl(v65, 4u, v64, &v53, 0, 0))
  {
    if (v53)
    {
      char v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"parent-pid:", 11);
      *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(*v9 - 24) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v10 = (void *)std::ostream::operator<<();
      LOBYTE(v60[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v60, 1);
      uint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"real-uid:", 9);
      *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24) + 8) = *(_DWORD *)((unsigned char *)v11 + *(void *)(*v11 - 24) + 8) & 0xFFFFFFB5 | 8;
      char v12 = (void *)std::ostream::operator<<();
      LOBYTE(v60[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)v60, 1);
      long long v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"real-gid:", 9);
      *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
      int v14 = (void *)std::ostream::operator<<();
      LOBYTE(v60[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)v60, 1);
      uint64_t v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"effective-uid:", 14);
      *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24) + 8) = *(_DWORD *)((unsigned char *)v15 + *(void *)(*v15 - 24) + 8) & 0xFFFFFFB5 | 8;
      unsigned int v16 = (void *)std::ostream::operator<<();
      LOBYTE(v60[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v60, 1);
      if (v64[212] >= 1)
      {
        uint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"effective-gid:", 14);
        *(_DWORD *)((char *)v17 + *(void *)(*v17 - 24) + 8) = *(_DWORD *)((unsigned char *)v17 + *(void *)(*v17 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 8;
        int v18 = (void *)std::ostream::operator<<();
        LOBYTE(v60[0]) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)v60, 1);
      }
    }
  }
  int CPUType = DNBProcessGetCPUType(v6);
  if (!CPUType)
  {
    int CPUType = 16777228;
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"Unable to get the process cpu_type, making a best guess.", v20, v21, v22, v23, v24, v25, v44);
    }
  }
  uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"cputype:", 8);
  *(_DWORD *)((char *)v26 + *(void *)(*v26 - 24) + 8) = *(_DWORD *)((unsigned char *)v26 + *(void *)(*v26 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v27 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)";", 1);
  int v52 = 0;
  size_t v51 = 4;
  int v28 = sysctlbyname("hw.cpu64bit_capable", &v52, &v51, 0, 0);
  int v29 = v52;
  int v50 = 0;
  size_t v49 = 4;
  if (!sysctlbyname("hw.cpusubtype", &v50, &v49, 0, 0))
  {
    if (v28 || !v29) {
      goto LABEL_18;
    }
    if (CPUType == 12)
    {
      int v30 = 12;
    }
    else
    {
      if (CPUType != 7)
      {
LABEL_18:
        uint64_t v31 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"cpusubtype:", 11);
        *(_DWORD *)((char *)v31 + *(void *)(*v31 - 24) + 8) = *(_DWORD *)((unsigned char *)v31 + *(void *)(*v31 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 8;
        char v32 = (void *)std::ostream::operator<<();
        LOBYTE(v60[0]) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)v60, 1);
        goto LABEL_19;
      }
      int v30 = 3;
    }
    int v50 = v30;
    goto LABEL_18;
  }
LABEL_19:
  size_t v33 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"ptrsize:", 8);
  *(_DWORD *)((char *)v33 + *(void *)(*v33 - 24) + 8) = *(_DWORD *)((unsigned char *)v33 + *(void *)(*v33 - 24) + 8) & 0xFFFFFFB5 | 2;
  char v34 = (void *)std::ostream::operator<<();
  LOBYTE(v60[0]) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)v60, 1);
  if (CPUType == 12 || CPUType == 33554444 || CPUType == 16777228)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"ostype:ios;", 11);
  }
  else
  {
    if ((CPUType & 0xFEFFFFFF) == 7)
    {
      uint64_t v62 = 0x3100000001;
      int v63 = v6;
      size_t v48 = 0x2000;
      if (!sysctl((int *)&v62, 3u, v60, &v48, 0, 0))
      {
        DNBDataRef::DNBDataRef((DNBDataRef *)&v46, (const unsigned __int8 *)v60, v48, 0);
        unsigned int v45 = 0;
        int v35 = DNBDataRef::Get32((DNBDataRef *)&v46, &v45);
        if (DNBDataRef::GetCStr((DNBDataRef *)&v46, &v45, 0))
        {
          if (v46)
          {
            unint64_t v36 = v45;
            if (v47 - v46 > (unint64_t)v45)
            {
              unsigned int v37 = v45 + 1;
              do
              {
                if (*(unsigned char *)(v46 + v36)) {
                  break;
                }
                unsigned int v45 = v37;
                unint64_t v36 = v37++;
              }
              while (v47 - v46 > v36);
            }
          }
          for (; v35; --v35)
            DNBDataRef::GetCStr((DNBDataRef *)&v46, &v45, 0);
          do
          {
            CStr = (const char *)DNBDataRef::GetCStr((DNBDataRef *)&v46, &v45, 0);
            if (!CStr) {
              break;
            }
            unint64_t v39 = CStr;
            if (!strncmp(CStr, "SIMULATOR_UDID=", 0xFuLL))
            {
              DNBDataRef::~DNBDataRef((DNBDataRef *)&v46);
              unint64_t v40 = "ostype:ios;";
              uint64_t v41 = 11;
              goto LABEL_38;
            }
          }
          while (*v39);
        }
        DNBDataRef::~DNBDataRef((DNBDataRef *)&v46);
      }
    }
    unint64_t v40 = "ostype:macosx;";
    uint64_t v41 = 14;
LABEL_38:
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)v40, v41);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"vendor:apple;", 13);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v54, (uint64_t)"endian:little;", 14);
  std::stringbuf::str();
LABEL_40:
  uint64_t v42 = RNBRemote::SendPacket(v2, (uint64_t)v60);
  if (v61 < 0) {
    operator delete(v60[0]);
  }
  uint64_t v55 = v5;
  if (SBYTE7(v57) < 0) {
    operator delete((void *)v56);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v42;
}

uint64_t RNBRemote::HandlePacket_qSymbol(RNBRemote *this, char *a2)
{
  int v3 = a2 + 8;
  uint64_t v4 = strchr(a2 + 8, 58);
  memset(&v43, 0, sizeof(v43));
  memset(&v42, 0, sizeof(v42));
  if (v4 > v3) {
    std::string::assign(&v42, v3, v4 - v3);
  }
  int v7 = v4[1];
  int v6 = v4 + 1;
  int v5 = v7;
  if (!v7)
  {
    *((_DWORD *)this + 166) = 0;
    goto LABEL_44;
  }
  uint64_t v8 = 0;
  memset(&v36, 0, sizeof(v36));
  do
  {
    int v9 = v6[v8];
    if ((v9 - 97) > 5)
    {
      if ((v9 - 65) > 5)
      {
        unsigned int v10 = v9 - 48;
        if (v10 > 9) {
          break;
        }
      }
      else
      {
        unsigned int v10 = v9 - 55;
      }
    }
    else
    {
      unsigned int v10 = v9 - 87;
    }
    if (v10 == -1) {
      break;
    }
    int v11 = v6[v8 + 1];
    if ((v11 - 97) > 5)
    {
      if ((v11 - 65) > 5)
      {
        unsigned int v12 = v11 - 48;
        if (v12 > 9) {
          break;
        }
      }
      else
      {
        unsigned int v12 = v11 - 55;
      }
    }
    else
    {
      unsigned int v12 = v11 - 87;
    }
    if (v12 == -1) {
      break;
    }
    std::string::push_back(&v36, v12 + 16 * v10);
    v8 += 2;
  }
  while (v8 < 0x1FFFFFFFELL);
  std::string v43 = v36;
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v42.__r_.__value_.__l.__size_) {
      goto LABEL_40;
    }
    long long v13 = (std::string *)v42.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&v42.__r_.__value_.__s + 23)) {
      goto LABEL_40;
    }
    long long v13 = &v42;
  }
  unint64_t v14 = strtoull((const char *)v13, 0, 16);
  if (v14)
  {
    int v15 = SHIBYTE(v43.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_26:
      if (v15 != 22)
      {
        int v5 = *((_DWORD *)this + 166) + 1;
        *((_DWORD *)this + 166) = v5;
LABEL_44:
        v43.__r_.__value_.__s.__data_[0] = 0;
        *((unsigned char *)&v43.__r_.__value_.__s + 23) = 0;
        if (v5) {
          goto LABEL_48;
        }
        goto LABEL_45;
      }
      unsigned int v16 = &v43;
      goto LABEL_31;
    }
  }
  else
  {
    __error();
    int v15 = SHIBYTE(v43.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
  }
  if (v43.__r_.__value_.__l.__size_ != 22) {
    goto LABEL_40;
  }
  unsigned int v16 = (std::string *)v43.__r_.__value_.__r.__words[0];
LABEL_31:
  std::string::size_type v17 = v16->__r_.__value_.__r.__words[0];
  std::string::size_type size = v16->__r_.__value_.__l.__size_;
  uint64_t v19 = *(std::string::size_type *)((char *)&v16->__r_.__value_.__r.__words[1] + 6);
  if (v17 == 0x6863746170736964 && size == 0x6F5F65756575715FLL && v19 == 0x7374657366666F5FLL) {
    *((void *)this + 82) = v14;
  }
LABEL_40:
  int v22 = SHIBYTE(v43.__r_.__value_.__r.__words[2]);
  int v5 = *((_DWORD *)this + 166) + 1;
  *((_DWORD *)this + 166) = v5;
  if ((v22 & 0x80000000) == 0) {
    goto LABEL_44;
  }
  *v43.__r_.__value_.__l.__data_ = 0;
  v43.__r_.__value_.__l.__size_ = 0;
  if (*((_DWORD *)this + 166)) {
    goto LABEL_48;
  }
LABEL_45:
  if (*((void *)this + 82) == -1) {
    std::string::assign(&v43, "dispatch_queue_offsets");
  }
  else {
    *((_DWORD *)this + 166) = 1;
  }
LABEL_48:
  std::string::size_type v23 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v23 = v43.__r_.__value_.__l.__size_;
  }
  if (v23)
  {
    *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words
                              + *(void *)(v36.__r_.__value_.__r.__words[0] - 24)) = v24;
    uint64_t v25 = (std::ios_base *)((char *)&v36 + *(void *)(v36.__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v25, &v36.__r_.__value_.__r.__words[1]);
    v25[1].__vftable = 0;
    v25[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)long long __p = 0u;
    long long v39 = 0u;
    int v40 = 16;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v36, (uint64_t)"qSymbol:", 8);
    std::string::size_type v26 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
    if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v26 = v43.__r_.__value_.__l.__size_;
    }
    if (v26)
    {
      for (std::string::size_type i = 0; i < v28; ++i)
      {
        std::string::size_type v29 = v36.__r_.__value_.__r.__words[0];
        int v30 = (char *)&v36 + *(void *)(v36.__r_.__value_.__r.__words[0] - 24);
        if (*((_DWORD *)v30 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v36 + *(void *)(v36.__r_.__value_.__r.__words[0] - 24)));
          uint64_t v31 = std::locale::use_facet(&v34, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 32);
          std::locale::~locale(&v34);
          std::string::size_type v29 = v36.__r_.__value_.__r.__words[0];
        }
        *((_DWORD *)v30 + 36) = 48;
        *(_DWORD *)((char *)&v36.__r_.__value_.__r.__words[1] + *(void *)(v29 - 24)) = *(_DWORD *)((unsigned char *)&v36.__r_.__value_.__r.__words[1] + *(void *)(v29 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&v36.__r_.__value_.__r.__words[1] + *(void *)(v29 - 24)) = *(_DWORD *)((unsigned char *)&v36.__r_.__value_.__r.__words[1] + *(void *)(v29 - 24)) & 0xFFFFFF4F | 0x80;
        *(void *)&v37[*(void *)(v29 - 24)] = 2;
        std::ostream::operator<<();
        std::string::size_type v28 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
        if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v28 = v43.__r_.__value_.__l.__size_;
        }
      }
    }
    std::stringbuf::str();
    uint64_t v32 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v34);
    if (v35 < 0) {
      operator delete(v34.__locale_);
    }
    *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words
    if (SBYTE7(v39) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_71:
      operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_72;
      }
      return v32;
    }
  }
  else
  {
    *((unsigned char *)&v36.__r_.__value_.__s + 23) = 2;
    strcpy((char *)&v36, "OK");
    uint64_t v32 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v36);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v36.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_71;
      }
    }
    else if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      goto LABEL_71;
    }
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
LABEL_72:
  }
    operator delete(v43.__r_.__value_.__l.__data_);
  return v32;
}

uint64_t RNBRemote::HandlePacket_jThreadExtendedInfo(RNBRemote *this, char *a2)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v132 + (void)*(v132 - 3)) = v4;
  int v5 = (std::ios_base *)((char *)&v132 + (void)*(v132 - 3));
  std::ios_base::init(v5, &v133);
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long __p = 0u;
  long long v135 = 0u;
  int v136 = 16;
  int v7 = *((_DWORD *)this + 3);
  if (v7)
  {
    if (!strncmp(a2, "jThreadExtendedInfo:{", 0x15uLL))
    {
      unsigned int v10 = a2 + 21;
      uint64_t integer_value_for_key_name_from_json = get_integer_value_for_key_name_from_json("thread", a2 + 21);
      uint64_t v12 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_base_address_offset", a2 + 21);
      uint64_t v13 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_base_offset", v10);
      uint64_t v14 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_entry_size", v10);
      int v15 = v10;
      uint64_t v16 = get_integer_value_for_key_name_from_json("dti_qos_class_index", v15);
      if (integer_value_for_key_name_from_json != -1)
      {
        unint64_t v120 = v16;
        uint64_t v17 = DNBGetPThreadT(v7, integer_value_for_key_name_from_json);
        unint64_t v126 = integer_value_for_key_name_from_json;
        uint64_t v123 = v17;
        if (v14 == -1 || v13 == -1)
        {
          BOOL v21 = 0;
          int v122 = 0;
          uint64_t v20 = 0;
          BOOL v131 = 0;
          BOOL v23 = v17 != -1;
          double v22 = 0.0;
          uint64_t v19 = -1;
        }
        else
        {
          uint64_t v18 = DNBGetTSDAddressForThread(v7, integer_value_for_key_name_from_json, v12, v13, v14);
          uint64_t v19 = v18;
          uint64_t v20 = 0;
          BOOL v131 = 0;
          BOOL v21 = v18 != -1;
          double v22 = 0.0;
          BOOL v23 = v123 != -1;
          if (v123 == -1 || v18 == -1)
          {
            int v122 = 0;
          }
          else
          {
            uint64_t v116 = v18;
            __str.__r_.__value_.__r.__words[0] = 0;
            gettimeofday((timeval *)&__str.__r_.__value_.__r.__words[1], 0);
            int v118 = v7;
            DNBGetGenealogyInfoForThread(&v131, v7, v126, &v128);
            __darwin_time_t tv_sec = v128.tv_sec;
            int v122 = *(std::__shared_weak_count **)&v128.tv_usec;
            std::string::size_type v24 = (pthread_mutex_t *)__str.__r_.__value_.__r.__words[0];
            if (__str.__r_.__value_.__r.__words[0]) {
              pthread_mutex_lock((pthread_mutex_t *)__str.__r_.__value_.__l.__data_);
            }
            gettimeofday(&v128, 0);
            __darwin_time_t v25 = v128.tv_sec;
            uint64_t tv_usec = v128.tv_usec;
            std::string::size_type size = __str.__r_.__value_.__l.__size_;
            uint64_t v28 = SLODWORD(__str.__r_.__value_.__r.__words[2]);
            if (v24) {
              pthread_mutex_unlock(v24);
            }
            double v29 = (double)(tv_usec - v28 + 1000000 * (v25 - size));
            int v7 = v118;
            if (v24)
            {
              if (pthread_mutex_destroy(v24) && !pthread_mutex_unlock(v24)) {
                pthread_mutex_destroy(v24);
              }
              operator delete();
            }
            BOOL v21 = 1;
            BOOL v23 = 1;
            double v22 = v29 / 1000000.0;
            uint64_t v19 = v116;
            uint64_t v20 = (const std::string *)tv_sec;
          }
        }
        timeval v128 = (timeval)0;
        *(_OWORD *)int v129 = 0u;
        int v130 = 1065353216;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"{", 1);
        long long v125 = v20;
        if (!v20 || v131)
        {
          if (!v131)
          {
            BOOL v35 = v23;
            uint64_t v36 = v126;
            if (!v21)
            {
              if (!v35)
              {
                if (DNBGetDispatchQueueT(v7, v126) == -1) {
                  goto LABEL_164;
                }
                goto LABEL_163;
              }
              goto LABEL_158;
            }
            goto LABEL_131;
          }
          BOOL v121 = v21;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_query_timed_out\":true", 31);
          BOOL v35 = v23;
          if (v22 == 0.0)
          {
            BOOL v41 = 1;
            uint64_t v36 = v126;
          }
          else
          {
            __str.__r_.__value_.__s.__data_[0] = 0;
            snprintf((char *)&__str, 0x40uLL, "%f", v22);
            uint64_t v36 = v126;
            if (__str.__r_.__value_.__s.__data_[0])
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
              uint64_t v37 = v19;
              unint64_t v38 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_query_duration\":", 26);
              size_t v39 = strlen((const char *)&__str);
              int v40 = v38;
              uint64_t v19 = v37;
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)&__str, v39);
            }
            BOOL v41 = 1;
          }
LABEL_128:
          if (!v121)
          {
LABEL_155:
            if (!v35)
            {
              if (DNBGetDispatchQueueT(v7, v36) == -1)
              {
LABEL_164:
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
                uint64_t v104 = &v127;
                std::stringbuf::str();
                memset(&__str, 0, sizeof(__str));
                char v105 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
                if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v106 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v106 = v127.__r_.__value_.__l.__size_;
                }
                if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v104 = (std::string *)v127.__r_.__value_.__r.__words[0];
                }
                if (v106)
                {
                  do
                  {
                    unsigned int v108 = v104->__r_.__value_.__s.__data_[0];
                    uint64_t v104 = (std::string *)((char *)v104 + 1);
                    unsigned int v107 = v108;
                    uint64_t v109 = (1 << v108) & 0x41800000000;
                    BOOL v110 = v108 > 0x2A || v109 == 0;
                    if (!v110 || v107 == 125)
                    {
                      std::string::push_back(&__str, 125);
                      LOBYTE(v107) = v107 ^ 0x20;
                    }
                    std::string::push_back(&__str, v107);
                    --v106;
                  }
                  while (v106);
                  char v105 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
                }
                if (v105 < 0) {
                  operator delete(v127.__r_.__value_.__l.__data_);
                }
                uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__str);
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
                long long v111 = v129[0];
                if (v129[0])
                {
                  do
                  {
                    uint64_t v112 = (void *)*v111;
                    operator delete(v111);
                    long long v111 = v112;
                  }
                  while (v112);
                }
                std::string v113 = (void *)v128.tv_sec;
                v128.__darwin_time_t tv_sec = 0;
                if (v113) {
                  operator delete(v113);
                }
                if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
                  std::__shared_weak_count::__release_weak(v122);
                }
                goto LABEL_7;
              }
              if (!v41)
              {
LABEL_163:
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"dispatch_queue_t\":", 19);
                std::ostream::operator<<();
                goto LABEL_164;
              }
LABEL_162:
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
              goto LABEL_163;
            }
            if (v41) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
            }
LABEL_158:
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"pthread_t\":", 12);
            std::ostream::operator<<();
            if (DNBGetDispatchQueueT(v7, v36) == -1) {
              goto LABEL_164;
            }
            goto LABEL_162;
          }
          if (v41) {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
          }
LABEL_131:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"tsd_address\":", 14);
          std::ostream::operator<<();
          if (v120 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            DNBGetRequestedQoSForThread(v7, v36, v19, v120, (uint64_t)&__str);
            if (v140 != -1)
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"requested_qos\":{", 17);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"enum_value\":", 13);
              unint64_t v95 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v95, (uint64_t)",", 1);
              long long v96 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"constant_name\":\"", 17);
              json_string_quote_metachars(&__str, &v127);
              if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v97 = &v127;
              }
              else {
                long long v97 = (std::string *)v127.__r_.__value_.__r.__words[0];
              }
              if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v98 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v98 = v127.__r_.__value_.__l.__size_;
              }
              uint64_t v99 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v96, (uint64_t)v97, v98);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v99, (uint64_t)"\",", 2);
              if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v127.__r_.__value_.__l.__data_);
              }
              std::string::size_type v100 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"printable_name\":\"", 18);
              json_string_quote_metachars(&v139, &v127);
              if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v101 = &v127;
              }
              else {
                uint64_t v101 = (std::string *)v127.__r_.__value_.__r.__words[0];
              }
              if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v102 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v102 = v127.__r_.__value_.__l.__size_;
              }
              uint64_t v103 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v100, (uint64_t)v101, v102);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v103, (uint64_t)"\"", 1);
              if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v127.__r_.__value_.__l.__data_);
              }
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
            }
            if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v139.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }
          BOOL v41 = 1;
          goto LABEL_155;
        }
        BOOL v121 = v21;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_query_timed_out\":false,", 33);
        std::string v115 = this;
        int v119 = v7;
        BOOL v114 = v23;
        uint64_t v117 = v19;
        if (v22 == 0.0)
        {
          uint64_t v31 = v20;
          uint64_t v36 = v126;
          if (v20->__r_.__value_.__l.__size_)
          {
LABEL_48:
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity\":{", 12);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"start\":", 8);
            std::string v42 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v42, (uint64_t)",", 1);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"id\":", 5);
            std::string v43 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)",", 1);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"parent_id\":", 12);
            uint64_t v44 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)",", 1);
            unsigned int v45 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"name\":\"", 8);
            json_string_quote_metachars(v31 + 1, &__str);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_str = &__str;
            }
            else {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v47 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v47 = __str.__r_.__value_.__l.__size_;
            }
            size_t v48 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)p_str, v47);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v48, (uint64_t)"\",", 2);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            size_t v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"reason\":\"", 10);
            json_string_quote_metachars(v31 + 2, &__str);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v50 = &__str;
            }
            else {
              int v50 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v51 = __str.__r_.__value_.__l.__size_;
            }
            int v52 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\"", 1);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            int v53 = 1;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
            std::string::pointer data = v31[3].__r_.__value_.__l.__data_;
            uint64_t v54 = (std::string::__raw *)&v31[3];
            long long v56 = (const std::string **)&v54->__words[1];
            if ((std::string::pointer)v54->__words[1] != data)
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
              goto LABEL_67;
            }
            int v34 = 1;
            goto LABEL_84;
          }
          int v34 = 0;
        }
        else
        {
          __str.__r_.__value_.__s.__data_[0] = 0;
          snprintf((char *)&__str, 0x40uLL, "%f", v22);
          int v30 = __str.__r_.__value_.__s.__data_[0];
          uint64_t v31 = v20;
          if (__str.__r_.__value_.__s.__data_[0])
          {
            uint64_t v32 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_query_duration\":", 26);
            size_t v33 = strlen((const char *)&__str);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)&__str, v33);
            int v34 = 1;
          }
          else
          {
            int v34 = 0;
          }
          uint64_t v36 = v126;
          if (v20->__r_.__value_.__l.__size_)
          {
            if (v30) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
            }
            goto LABEL_48;
          }
        }
        std::string::pointer v57 = v31[3].__r_.__value_.__l.__data_;
        uint64_t v54 = (std::string::__raw *)&v31[3];
        long long v56 = (const std::string **)&v54->__words[1];
        if ((std::string::pointer)v54->__words[1] != v57)
        {
LABEL_67:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"trace_messages\":[", 18);
          int v58 = (const std::string *)v54->__words[0];
          if ((const std::string *)v54->__words[0] != *v56)
          {
            char v59 = 0;
            do
            {
              if (v59) {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
              }
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"{", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"timestamp\":", 12);
              uint64_t v60 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_id\":", 14);
              char v61 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v61, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"trace_id\":", 11);
              uint64_t v62 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v62, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"thread\":", 9);
              int v63 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v63, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"type\":", 7);
              uint64_t v64 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)",", 1);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"process_info_index\":", 21);
              int v65 = (unsigned int *)&v58[1].__r_.__value_.__r.__words[1] + 1;
              unint64_t v66 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)",", 1);
              std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v128, v65, v65);
              uint64_t v67 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"message\":\"", 11);
              uint64_t v68 = (const std::string *)(v65 + 1);
              json_string_quote_metachars(v68, &__str);
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::locale v69 = &__str;
              }
              else {
                std::locale v69 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v70 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v70 = __str.__r_.__value_.__l.__size_;
              }
              char v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)v69, v70);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)"\"", 1);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              char v59 = 1;
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
              int v58 = v68 + 1;
            }
            while (v58 != *v56);
          }
          int v53 = 1;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"]", 1);
          BOOL v72 = (const std::string **)&v125[4];
          p_std::string::size_type size = (const std::string **)&v125[4].__r_.__value_.__l.__size_;
          if (v125[4].__r_.__value_.__l.__size_ - v125[4].__r_.__value_.__r.__words[0] != 48)
          {
            int v34 = 1;
LABEL_99:
            this = v115;
            uint64_t v36 = v126;
            goto LABEL_100;
          }
LABEL_86:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
LABEL_87:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"breadcrumb\":{", 14);
          for (std::string::size_type i = *v72; i != *p_size; std::string::size_type i = v79 + 1)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"breadcrumb_id\":", 16);
            long long v75 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)",", 1);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"activity_id\":", 14);
            int v76 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v76, (uint64_t)",", 1);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"timestamp\":", 12);
            std::string::size_type v77 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v77, (uint64_t)",", 1);
            unint64_t v78 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"name\":\"", 8);
            uint64_t v79 = i + 1;
            json_string_quote_metachars(v79, &__str);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v80 = &__str;
            }
            else {
              std::string::size_type v80 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v81 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v81 = __str.__r_.__value_.__l.__size_;
            }
            long long v82 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v78, (uint64_t)v80, v81);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v82, (uint64_t)"\"", 1);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }
          int v34 = 1;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
          int v53 = 1;
          goto LABEL_99;
        }
        int v53 = 0;
LABEL_84:
        p_std::string::size_type size = (const std::string **)&v125[4].__r_.__value_.__l.__size_;
        if (v125[4].__r_.__value_.__l.__size_ - v125[4].__r_.__value_.__r.__words[0] != 48)
        {
LABEL_100:
          int v7 = v119;
          if (v129[1])
          {
            if (v53) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
            }
            long long v83 = (void **)v129[0];
            if (v129[0])
            {
              char v84 = 0;
              do
              {
                if (v84) {
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)",", 1);
                }
                v85.n128_f64[0] = DNBGetGenealogyImageInfo(v119, *((unsigned int *)v83 + 4), &__str);
                long long v86 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
                if (__str.__r_.__value_.__r.__words[0])
                {
                  if ((v84 & 1) == 0) {
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"process_infos\":[", 17);
                  }
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"{", 1);
                  uuid_unparse_upper((const unsigned __int8 *)(v86 + 24), (char *)&__str);
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"process_info_index\":", 21);
                  int v87 = (void *)std::ostream::operator<<();
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v87, (uint64_t)",", 1);
                  std::string::size_type v88 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"image_path\":\"", 14);
                  json_string_quote_metachars((const std::string *)v86, &v127);
                  if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    long long v89 = &v127;
                  }
                  else {
                    long long v89 = (std::string *)v127.__r_.__value_.__r.__words[0];
                  }
                  if ((v127.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v90 = HIBYTE(v127.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v90 = v127.__r_.__value_.__l.__size_;
                  }
                  long long v91 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v88, (uint64_t)v89, v90);
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v91, (uint64_t)"\",", 2);
                  if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v127.__r_.__value_.__l.__data_);
                  }
                  uint64_t v92 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"\"image_uuid\":\"", 14);
                  size_t v93 = strlen((const char *)&__str);
                  int v94 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v92, (uint64_t)&__str, v93);
                  char v84 = 1;
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v94, (uint64_t)"\"", 1);
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"}", 1);
                }
                if (*((void *)&v86 + 1)
                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v86 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  (*(void (**)(void, __n128))(**((void **)&v86 + 1) + 16))(*((void *)&v86 + 1), v85);
                  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v86 + 1));
                }
                long long v83 = (void **)*v83;
              }
              while (v83);
              this = v115;
              int v7 = v119;
              int v34 = 1;
              if (v84) {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v132, (uint64_t)"]", 1);
              }
            }
            else
            {
              int v34 = 1;
              int v7 = v119;
            }
            uint64_t v36 = v126;
          }
          BOOL v41 = v34 != 0;
          BOOL v35 = v114;
          uint64_t v19 = v117;
          goto LABEL_128;
        }
        BOOL v72 = (const std::string **)&v125[4];
        if (!v53) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }
    }
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 2;
    strcpy((char *)&__str, "OK");
  }
  else
  {
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 3;
    strcpy((char *)&__str, "E81");
  }
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_7:
  long long v133 = v6;
  if (SBYTE7(v135) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v8;
}

uint64_t RNBRemote::HandlePacket_jGetLoadedDynamicLibrariesInfos(RNBRemote *this, const char *__s1)
{
  uint64_t v4 = *((unsigned int *)this + 3);
  if (!v4)
  {
    char v19 = 3;
    LODWORD(v17) = 3356741;
    goto LABEL_31;
  }
  if (strncmp(__s1, "jGetLoadedDynamicLibrariesInfos:{", 0x21uLL))
  {
LABEL_30:
    char v19 = 2;
    strcpy((char *)&v17, "OK");
LABEL_31:
    uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v17);
    if (v19 < 0) {
      operator delete(v17);
    }
    return v2;
  }
  int v6 = (char *)(__s1 + 33);
  std::string::size_type v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  BOOL v25 = 0;
  BOOL v24 = 1;
  get_BOOLean_value_for_key_name_from_json("report_load_commands", v6, &v24);
  if (get_BOOLean_value_for_key_name_from_json("fetch_all_solibs", v6, &v25) && v25)
  {
    DNBGetAllLoadedLibrariesInfos(v4, v24, &v17);
    uint64_t v2 = (uint64_t)v17;
    int v7 = (std::__shared_weak_count *)v18;
    if (!v17) {
      goto LABEL_24;
    }
  }
  else
  {
    if (!get_array_of_ints_value_for_key_name_from_json("solib_addresses", v6, (uint64_t)&v26))
    {
      int v7 = 0;
      goto LABEL_24;
    }
    DNBGetLibrariesInfoForAddresses(v4, &v26, &v17);
    uint64_t v2 = (uint64_t)v17;
    int v7 = (std::__shared_weak_count *)v18;
    if (!v17) {
      goto LABEL_24;
    }
  }
  *(void **)((char *)&v17 + *((void *)v17 - 3)) = v8;
  int v9 = (std::ios_base *)((char *)&v17 + *((void *)v17 - 3));
  std::ios_base::init(v9, &v18);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)uint64_t v20 = 0u;
  long long v21 = 0u;
  int v22 = 16;
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 40))(v2, &v17);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  std::stringbuf::str();
  if (v16 < 0)
  {
    uint64_t v2 = v15;
    operator delete(__p);
    if (v15) {
      goto LABEL_12;
    }
  }
  else if (v16)
  {
LABEL_12:
    std::stringbuf::str();
    uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (v16 < 0) {
      operator delete(__p);
    }
    int v10 = 0;
    goto LABEL_21;
  }
  char v16 = 3;
  LODWORD(__p) = 3422277;
  RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (v16 < 0) {
    operator delete(__p);
  }
  int v10 = 1;
LABEL_21:
  if (SBYTE7(v21) < 0) {
    operator delete(v20[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  if (!v10)
  {
    int v11 = 0;
    uint64_t v12 = v26;
    if (!v26) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_24:
  int v11 = 1;
  uint64_t v12 = v26;
  if (v26)
  {
LABEL_25:
    uint64_t v27 = v12;
    operator delete(v12);
  }
LABEL_26:
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v11) {
    goto LABEL_30;
  }
  return v2;
}

std::ios_base *RNBRemote::HandlePacket_jThreadsInfo(RNBRemote *this, const char *a2)
{
  int v3 = v32;
  uint64_t v4 = v2;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v32 + (void)*(v32 - 3)) = (void (__cdecl **)(std::ostringstream *__hidden))v2;
  int v5 = (std::ios_base *)((char *)&v32 + (void)*(v32 - 3));
  std::ios_base::init(v5, &v33);
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long v34 = 0u;
  long long v35 = 0u;
  int v36 = 16;
  std::string::size_type v26 = v3;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v26 + (void)*(v3 - 3)) = (void (__cdecl **)(std::ostringstream *__hidden))v4;
  int v6 = (std::ios_base *)((char *)&v26 + (void)*(v26 - 3));
  std::ios_base::init(v6, &v27);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long v28 = 0u;
  long long v29 = 0u;
  int v30 = 16;
  if (*((_DWORD *)this + 3))
  {
    RNBRemote::GetJSONThreadsInfo((uint64_t)this, 0, &v24);
    int v7 = v24;
    if (!v24) {
      goto LABEL_14;
    }
    uint64_t v17 = v3;
    *(void **)((char *)&v17 + (void)*(v3 - 3)) = v4;
    uint64_t v4 = (std::ios_base *)((char *)&v17 + *((void *)v17 - 3));
    std::ios_base::init(v4, &v18);
    v4[1].__vftable = 0;
    v4[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)uint64_t v20 = 0u;
    long long v21 = 0u;
    int v22 = 16;
    ((void (*)(std::__shared_weak_count *, void **))v7->__vftable[1].~__shared_weak_count)(v7, &v17);
    ((void (*)(std::__shared_weak_count *))v7->__get_deleter)(v7);
    std::stringbuf::str();
    if (v16 < 0)
    {
      operator delete(__p[0]);
      if (__p[1]) {
        goto LABEL_5;
      }
    }
    else if (v16)
    {
LABEL_5:
      std::stringbuf::str();
      uint64_t v4 = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
      int v8 = 0;
LABEL_11:
      if (SBYTE7(v21) < 0) {
        operator delete(v20[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (!v8)
      {
        int v9 = 0;
        int v10 = v25;
        if (!v25) {
          goto LABEL_18;
        }
        goto LABEL_17;
      }
LABEL_14:
      int v9 = 1;
      int v10 = v25;
      if (!v25)
      {
LABEL_18:
        if (!v9) {
          goto LABEL_22;
        }
        goto LABEL_19;
      }
LABEL_17:
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
        if (!v9) {
          goto LABEL_22;
        }
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    int v8 = 1;
    goto LABEL_11;
  }
LABEL_19:
  char v19 = 3;
  LODWORD(v17) = 3487813;
  uint64_t v4 = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v17);
  if (v19 < 0) {
    operator delete(v17);
  }
LABEL_22:
  if (SBYTE7(v29) < 0) {
    operator delete((void *)v28);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  uint64_t v32 = v11;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v32 + (void)*(v11 - 3)) = v12;
  if (SBYTE7(v35) < 0) {
    operator delete((void *)v34);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v4;
}

uint64_t RNBRemote::HandlePacket_jGetSharedCacheInfo(RNBRemote *this, const char *__s1)
{
  uint64_t v4 = *((unsigned int *)this + 3);
  if (!v4)
  {
    char v16 = 3;
    LODWORD(v14) = 3487813;
    goto LABEL_25;
  }
  if (!strncmp(__s1, "jGetSharedCacheInfo:{", 0x15uLL))
  {
    DNBGetSharedCacheInfo(v4, &v21);
    if (!v21) {
      goto LABEL_18;
    }
    *(void **)((char *)&v14 + *((void *)v14 - 3)) = v5;
    int v6 = (std::ios_base *)((char *)&v14 + *((void *)v14 - 3));
    std::ios_base::init(v6, &v15);
    v6[1].__vftable = 0;
    v6[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)uint64_t v17 = 0u;
    long long v18 = 0u;
    int v19 = 16;
    (*(void (**)(uint64_t, void **))(*(void *)v21 + 40))(v21, &v14);
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
    std::stringbuf::str();
    if (v13 < 0)
    {
      uint64_t v2 = v12;
      operator delete(__p);
      if (v12) {
        goto LABEL_6;
      }
    }
    else if (v13)
    {
LABEL_6:
      std::stringbuf::str();
      uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
      if (v13 < 0) {
        operator delete(__p);
      }
      int v7 = 0;
      goto LABEL_15;
    }
    char v13 = 3;
    LODWORD(__p) = 3553349;
    RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if (v13 < 0) {
      operator delete(__p);
    }
    int v7 = 1;
LABEL_15:
    if (SBYTE7(v18) < 0) {
      operator delete(v17[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    if (!v7)
    {
      int v8 = 0;
      int v9 = v22;
      if (!v22) {
        goto LABEL_23;
      }
LABEL_21:
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
LABEL_23:
      if (!v8) {
        return v2;
      }
      goto LABEL_24;
    }
LABEL_18:
    int v8 = 1;
    int v9 = v22;
    if (!v22) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
LABEL_24:
  char v16 = 2;
  strcpy((char *)&v14, "OK");
LABEL_25:
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v14);
  if (v16 < 0) {
    operator delete(v14);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_QStartNoAckMode(RNBRemote *this, const char *a2)
{
  char v6 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *((unsigned char *)this + 781) = 1;
  return v3;
}

uint64_t RNBRemote::HandlePacket_QThreadSuffixSupported(RNBRemote *this, const char *a2)
{
  *((unsigned char *)this + 782) = 1;
  char v5 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_QSetLogging(RNBRemote *this, char *a2)
{
  set_logging(a2 + 12);
  char v6 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSetIgnoredExceptions(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3))
  {
    uint64_t v4 = (char *)(a2 + 22);
    while (1)
    {
      int v7 = strchr(v4, 124);
      if (!v7)
      {
        if (!RNBContext::AddIgnoredException(this, (MachException *)v4)) {
          goto LABEL_29;
        }
        goto LABEL_27;
      }
      int v8 = v7;
      size_t v9 = v7 - v4;
      if ((unint64_t)(v7 - v4) >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v9 >= 0x17) {
        break;
      }
      HIBYTE(v18) = (_BYTE)v7 - (_BYTE)v4;
      p_p = &__p;
      if (v7 != v4) {
        goto LABEL_15;
      }
LABEL_16:
      p_p[v9] = 0;
      if ((SHIBYTE(v18) & 0x80000000) == 0)
      {
        if (!HIBYTE(v18)) {
          goto LABEL_29;
        }
        char v13 = (MachException *)&__p;
LABEL_21:
        BOOL v5 = RNBContext::AddIgnoredException(this, v13);
        if (v5)
        {
          uint64_t v4 = v8 + 1;
          int v6 = 0;
        }
        else
        {
          int v6 = 3;
        }
        if ((SHIBYTE(v18) & 0x80000000) == 0) {
          goto LABEL_6;
        }
        goto LABEL_5;
      }
      if (v17)
      {
        char v13 = (MachException *)__p;
        goto LABEL_21;
      }
      BOOL v5 = 0;
      int v6 = 3;
LABEL_5:
      operator delete(__p);
LABEL_6:
      if (v6)
      {
        if (!v5)
        {
LABEL_29:
          HIBYTE(v18) = 3;
          int v3 = 3552069;
          goto LABEL_30;
        }
LABEL_27:
        HIBYTE(v18) = 2;
        strcpy((char *)&__p, "OK");
        goto LABEL_31;
      }
    }
    uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v11 = v9 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_p = operator new(v11 + 1);
    size_t v17 = v9;
    unint64_t v18 = v12 | 0x8000000000000000;
    long long __p = p_p;
LABEL_15:
    memmove(p_p, v4, v9);
    goto LABEL_16;
  }
  HIBYTE(v18) = 3;
  int v3 = 3486533;
LABEL_30:
  LODWORD(__p) = v3;
LABEL_31:
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p);
  }
  return v14;
}

uint64_t RNBRemote::HandlePacket_QSetMaxPacketSize(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 18;
  *__error() = 0;
  int v4 = strtoul(v3, 0, 16);
  if (*__error()) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 2438, v3, v5);
  }
  else
  {
    *((_DWORD *)this + 194) = v4 - 5;
    char v10 = 2;
    strcpy((char *)__p, "OK");
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return v7;
  }
}

uint64_t RNBRemote::HandlePacket_QSetMaxPayloadSize(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 19;
  *__error() = 0;
  int v4 = strtoul(v3, 0, 16);
  if (*__error()) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 2424, v3, v5);
  }
  else
  {
    *((_DWORD *)this + 194) = v4;
    char v10 = 2;
    strcpy((char *)__p, "OK");
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return v7;
  }
}

uint64_t RNBRemote::HandlePacket_QEnvironment(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    int v4 = (pthread_mutex_t *)*((void *)this + 61);
    if (v4) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v11, 0);
    int tv_sec = v11.tv_sec;
    __darwin_suseconds_t tv_usec = v11.tv_usec;
    uint64_t v7 = *((void *)this + 62);
    int v8 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v11;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    _DNBLogThreaded("%8u RNBRemote::%s Handling QEnvironment: \"%s\"", tv_usec - v8 + 1000000 * (tv_sec - v7), "HandlePacket_QEnvironment", a2);
  }
  RNBContext::PushEnvironment(this, a2 + 13);
  char v12 = 2;
  strcpy((char *)&v11, "OK");
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v11);
  if (v12 < 0) {
    operator delete((void *)v11.tv_sec);
  }
  return v9;
}

uint64_t RNBRemote::HandlePacket_QEnvironmentHexEncoded(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    BOOL v5 = (pthread_mutex_t *)*((void *)this + 61);
    if (v5) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday((timeval *)&v23, 0);
    int data = (int)v23.__r_.__value_.__l.__data_;
    int v7 = v23.__r_.__value_.__r.__words[1];
    uint64_t v8 = *((void *)this + 62);
    int v9 = *((_DWORD *)this + 126);
    *((_OWORD *)this + 31) = *(_OWORD *)&v23.__r_.__value_.__l.__data_;
    if (v5) {
      pthread_mutex_unlock(v5);
    }
    _DNBLogThreaded("%8u RNBRemote::%s Handling QEnvironmentHexEncoded: \"%s\"", v7 - v9 + 1000000 * (data - v8), "HandlePacket_QEnvironmentHexEncoded", a2);
  }
  timeval v11 = a2 + 23;
  int v10 = *((unsigned __int8 *)a2 + 23);
  memset(&v23, 0, sizeof(v23));
  if (v10)
  {
    char v12 = a2 + 25;
    do
    {
      char v13 = *(v12 - 1);
      if (!v13)
      {
        size_t v17 = this;
        int v18 = 2488;
        goto LABEL_20;
      }
      __str[0] = v10;
      __str[1] = v13;
      __str[2] = 0;
      *__error() = 0;
      int v14 = strtoul(__str, 0, 16);
      if (*__error()) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        size_t v17 = this;
        int v18 = 2499;
LABEL_20:
        uint64_t v19 = RNBRemote::HandlePacket_ILLFORMED(v17, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v18, v11, v4);
        if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v19;
        }
        goto LABEL_27;
      }
      std::string::push_back(&v23, v14);
      int v10 = *(unsigned __int8 *)v12;
      v12 += 2;
    }
    while (v10);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!v23.__r_.__value_.__l.__size_) {
        goto LABEL_25;
      }
      char v16 = (std::string *)v23.__r_.__value_.__r.__words[0];
    }
    else
    {
      if (!*((unsigned char *)&v23.__r_.__value_.__s + 23)) {
        goto LABEL_25;
      }
      char v16 = &v23;
    }
    RNBContext::PushEnvironment(this, (const char *)v16);
  }
LABEL_25:
  char v22 = 2;
  strcpy(__str, "OK");
  uint64_t v19 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__str);
  if (v22 < 0)
  {
    operator delete(*(void **)__str);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v19;
    }
    goto LABEL_27;
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
LABEL_27:
  }
    operator delete(v23.__r_.__value_.__l.__data_);
  return v19;
}

uint64_t RNBRemote::HandlePacket_QLaunchArch(RNBRemote *this, const char *a2)
{
  if (DNBSetArchitecture(a2 + 12))
  {
    char v6 = 2;
    strcpy((char *)__p, "OK");
  }
  else
  {
    char v6 = 3;
    LODWORD(__p[0]) = 3356229;
  }
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSetDisableASLR(RNBRemote *this, const char *a2)
{
  int v2 = a2[16];
  if (v2 == 48)
  {
    int v3 = 0;
    goto LABEL_5;
  }
  if (v2 == 49)
  {
    int v3 = 1;
LABEL_5:
    g_disable_aslr = v3;
    char v7 = 2;
    strcpy((char *)__p, "OK");
    goto LABEL_7;
  }
  char v7 = 3;
  LODWORD(__p[0]) = 3552581;
LABEL_7:
  uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t RNBRemote::HandlePacket_QSetSTDIO(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    char v10 = 3;
    LODWORD(__p[0]) = 3683653;
    uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return v3;
  }
  StdStringExtractor::StdStringExtractor((StdStringExtractor *)__p, a2);
  uint64_t v11 = 7;
  int Char = StdStringExtractor::GetChar((StdStringExtractor *)__p, 0);
  while (StdStringExtractor::GetChar((StdStringExtractor *)__p, 0) != 58)
    ;
  switch(Char)
  {
    case 'E':
      StdStringExtractor::GetHexByteString((uint64_t)__p, (std::string *)((char *)this + 64));
      int v5 = *((char *)this + 87);
      if (v5 < 0)
      {
        if (!*((void *)this + 9)) {
          break;
        }
        goto LABEL_17;
      }
      goto LABEL_16;
    case 'O':
      StdStringExtractor::GetHexByteString((uint64_t)__p, (std::string *)((char *)this + 40));
      int v5 = *((char *)this + 63);
      if (v5 < 0)
      {
        if (!*((void *)this + 6)) {
          break;
        }
        goto LABEL_17;
      }
LABEL_16:
      if (!(_BYTE)v5) {
        break;
      }
      goto LABEL_17;
    case 'I':
      StdStringExtractor::GetHexByteString((uint64_t)__p, (std::string *)((char *)this + 16));
      if (*((char *)this + 39) < 0)
      {
        if (!*((void *)this + 3)) {
          break;
        }
      }
      else if (!*((unsigned char *)this + 39))
      {
        break;
      }
LABEL_17:
      char v8 = 2;
      strcpy((char *)v7, "OK");
      goto LABEL_18;
  }
  char v8 = 3;
  LODWORD(v7[0]) = 3618117;
LABEL_18:
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v7);
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  StdStringExtractor::~StdStringExtractor(__p);
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSetWorkingDir(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3))
  {
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v12, a2 + 15);
    if (!StdStringExtractor::GetHexByteString(v4, (std::string *)((char *)this + 88)))
    {
      HIBYTE(__p.st_gid) = 3;
      __p.st_dev = 3749189;
      uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
      if (SHIBYTE(__p.st_gid) < 0)
      {
        char v6 = *(void **)&__p.st_dev;
LABEL_28:
        operator delete(v6);
      }
LABEL_29:
      StdStringExtractor::~StdStringExtractor(v12);
      return v3;
    }
    if (*((char *)this + 111) < 0)
    {
      if (*((void *)this + 12)) {
        int v5 = (const char *)*((void *)this + 11);
      }
      else {
        int v5 = 0;
      }
    }
    else if (*((unsigned char *)this + 111))
    {
      int v5 = (char *)this + 88;
    }
    else
    {
      int v5 = 0;
    }
    if (stat(v5, &__p) == -1)
    {
      if (*((char *)this + 111) < 0)
      {
        **((unsigned char **)this + 11) = 0;
        *((void *)this + 12) = 0;
      }
      else
      {
        *((unsigned char *)this + 88) = 0;
        *((unsigned char *)this + 111) = 0;
      }
      char v10 = 3;
      int v7 = 3225157;
    }
    else
    {
      if ((__p.st_mode & 0xF000) == 0x4000)
      {
        char v10 = 2;
        strcpy((char *)v9, "OK");
        goto LABEL_26;
      }
      if (*((char *)this + 111) < 0)
      {
        **((unsigned char **)this + 11) = 0;
        *((void *)this + 12) = 0;
      }
      else
      {
        *((unsigned char *)this + 88) = 0;
        *((unsigned char *)this + 111) = 0;
      }
      char v10 = 3;
      int v7 = 3290693;
    }
    LODWORD(v9[0]) = v7;
LABEL_26:
    uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v9);
    if (v10 < 0)
    {
      char v6 = v9[0];
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  HIBYTE(__p.st_gid) = 3;
  __p.st_dev = 3159621;
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
  if (SHIBYTE(__p.st_gid) < 0) {
    operator delete(*(void **)&__p.st_dev);
  }
  return v3;
}

uint64_t RNBRemote::HandlePacket_QListThreadsInStopReply(RNBRemote *this, const char *a2)
{
  char v6 = 2;
  strcpy((char *)__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *((unsigned char *)this + 783) = 1;
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSyncThreadState(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3)) {
    goto LABEL_7;
  }
  *__error() = 0;
  uint64_t v4 = a2 + 17;
  unint64_t v5 = strtoul(v4, 0, 16);
  if (*__error()) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7)
  {
    if (!DNBProcessSyncThreadState(*((_DWORD *)this + 3), v5))
    {
      char v11 = 3;
      LODWORD(__p[0]) = 3225157;
      goto LABEL_8;
    }
LABEL_7:
    char v11 = 2;
    strcpy((char *)__p, "OK");
LABEL_8:
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    return v8;
  }

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 2363, v4, v6);
}

uint64_t RNBRemote::HandlePacket_AllocateMemory(RNBRemote *this, const char *a2)
{
  StdStringExtractor::StdStringExtractor((StdStringExtractor *)v25, a2);
  v25[4] = (void *)2;
  unint64_t HexMaxU64 = StdStringExtractor::GetHexMaxU64(v3, 0, 0);
  if (!HexMaxU64) {
    goto LABEL_19;
  }
  mach_vm_size_t v5 = HexMaxU64;
  if (StdStringExtractor::GetChar((StdStringExtractor *)v25, 0) != 44) {
    goto LABEL_19;
  }
  int Char = StdStringExtractor::GetChar((StdStringExtractor *)v25, 0);
  for (unsigned int i = 0; Char; Char = StdStringExtractor::GetChar((StdStringExtractor *)v25, 0))
  {
    if (Char == 114)
    {
      int v14 = 2;
    }
    else if ((char)Char == 120)
    {
      int v14 = 4;
    }
    else
    {
      if ((char)Char != 119) {
        goto LABEL_19;
      }
      int v14 = 1;
    }
    i |= v14;
  }
  if (DNBProcessMemoryAllocate(*((_DWORD *)this + 3), v5, i) != -1)
  {
    *(void **)((char *)&v18 + *((void *)v18 - 3)) = v8;
    int v9 = (std::ios_base *)((char *)&v18 + *((void *)v18 - 3));
    std::ios_base::init(v9, &v19);
    v9[1].__vftable = 0;
    v9[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)stat __p = 0u;
    long long v22 = 0u;
    int v23 = 16;
    char v10 = v18;
    char v11 = (char *)&v18 + *((void *)v18 - 3);
    if (*((_DWORD *)v11 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v18 + *((void *)v18 - 3)));
      char v12 = std::locale::use_facet(&v16, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
      std::locale::~locale(&v16);
      char v10 = v18;
    }
    *((_DWORD *)v11 + 36) = 48;
    *(_DWORD *)((char *)&v18 + *(v10 - 3) + 8) = *(_DWORD *)((unsigned char *)&v18 + *(v10 - 3) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v18 + *(v10 - 3) + 8) = *(_DWORD *)((unsigned char *)&v18 + *(v10 - 3) + 8) & 0xFFFFFF4F | 0x80;
    std::ostream::operator<<();
    std::stringbuf::str();
    uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v16);
    if (v17 < 0) {
      operator delete(v16.__locale_);
    }
    if (SBYTE7(v22) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else
  {
LABEL_19:
    char v20 = 3;
    LODWORD(v18) = 3355973;
    uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v18);
    if (v20 < 0) {
      operator delete(v18);
    }
  }
  StdStringExtractor::~StdStringExtractor(v25);
  return v13;
}

uint64_t RNBRemote::HandlePacket_DeallocateMemory(RNBRemote *this, const char *a2)
{
  StdStringExtractor::StdStringExtractor((StdStringExtractor *)v8, a2);
  v8[4] = (void *)2;
  mach_vm_address_t HexMaxU64 = StdStringExtractor::GetHexMaxU64((StdStringExtractor *)v8, 0, -1);
  if (HexMaxU64 == -1 || !DNBProcessMemoryDeallocate(*((_DWORD *)this + 3), HexMaxU64))
  {
    char v7 = 3;
    LODWORD(__p[0]) = 3421509;
  }
  else
  {
    char v7 = 2;
    strcpy((char *)__p, "OK");
  }
  uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  StdStringExtractor::~StdStringExtractor(v8);
  return v4;
}

uint64_t RNBRemote::HandlePacket_SaveRegisterState(RNBRemote *this, char *__s1, uint64_t a3, uint64_t a4, const char *a5)
{
  int v7 = *((_DWORD *)this + 3);
  if (!*((unsigned char *)this + 782))
  {
    unint64_t CurrentThread = *((void *)this + 68);
    if (CurrentThread + 1 <= 1)
    {
      unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
      if (!CurrentThread) {
        goto LABEL_13;
      }
    }
LABEL_8:
    int v10 = DNBThreadSaveRegisterState(v7, CurrentThread);
    if (!v10)
    {
      char v24 = 3;
      strcpy(__str, "E75");
      uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__str);
      if (v24 < 0)
      {
        int v18 = *(void **)__str;
LABEL_26:
        operator delete(v18);
      }
      return v17;
    }
    snprintf(__str, 0x40uLL, "%u", v10);
    size_t v11 = strlen(__str);
    if (v11 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v12 = v11;
    if (v11 >= 0x17)
    {
      uint64_t v19 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v19 = v11 | 7;
      }
      uint64_t v20 = v19 + 1;
      uint64_t v13 = operator new(v19 + 1);
      __dst[1] = v12;
      unint64_t v22 = v20 | 0x8000000000000000;
      __dst[0] = v13;
    }
    else
    {
      HIBYTE(v22) = v11;
      uint64_t v13 = __dst;
      if (!v11)
      {
LABEL_24:
        *((unsigned char *)v13 + v12) = 0;
        uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__dst);
        if (SHIBYTE(v22) < 0)
        {
          int v18 = (void *)__dst[0];
          goto LABEL_26;
        }
        return v17;
      }
    }
    memcpy(v13, __str, v12);
    goto LABEL_24;
  }
  if (!__s1) {
    goto LABEL_14;
  }
  uint64_t v8 = strstr(__s1, "thread:");
  if (!v8) {
    goto LABEL_14;
  }
  unint64_t CurrentThread = strtoul(v8 + 7, 0, 16);
  if (CurrentThread) {
    goto LABEL_8;
  }
LABEL_13:
  if (!*((unsigned char *)this + 782))
  {
    int v14 = this;
    int v15 = 3473;
    goto LABEL_15;
  }
LABEL_14:
  int v14 = this;
  int v15 = 3470;
LABEL_15:

  return RNBRemote::HandlePacket_ILLFORMED(v14, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v15, __s1, a5);
}

uint64_t RNBRemote::HandlePacket_RestoreRegisterState(RNBRemote *this, char *__s1, uint64_t a3, uint64_t a4, const char *a5)
{
  int v7 = *((_DWORD *)this + 3);
  if (*((unsigned char *)this + 782))
  {
    if (!__s1) {
      goto LABEL_12;
    }
    uint64_t v8 = strstr(__s1, "thread:");
    if (!v8) {
      goto LABEL_12;
    }
    unint64_t CurrentThread = strtoul(v8 + 7, 0, 16);
    if (!CurrentThread)
    {
LABEL_11:
      if (!*((unsigned char *)this + 782))
      {
        int v10 = this;
        int v11 = 3514;
        goto LABEL_13;
      }
LABEL_12:
      int v10 = this;
      int v11 = 3511;
LABEL_13:
      return RNBRemote::HandlePacket_ILLFORMED(v10, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", v11, __s1, a5);
    }
  }
  else
  {
    unint64_t CurrentThread = *((void *)this + 68);
    if (CurrentThread + 1 <= 1)
    {
      unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
      if (!CurrentThread) {
        goto LABEL_11;
      }
    }
  }
  StdStringExtractor::StdStringExtractor((StdStringExtractor *)v17, __s1);
  v17[4] = (void *)22;
  if (!StdStringExtractor::GetU32((StdStringExtractor *)v17, 0, 0))
  {
    char v16 = 3;
    int v13 = 3553093;
LABEL_18:
    LODWORD(__p[0]) = v13;
    goto LABEL_19;
  }
  if (!DNBThreadRestoreRegisterState(v7, CurrentThread))
  {
    char v16 = 3;
    int v13 = 3618629;
    goto LABEL_18;
  }
  char v16 = 2;
  strcpy((char *)__p, "OK");
LABEL_19:
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  StdStringExtractor::~StdStringExtractor(v17);
  return v14;
}

uint64_t RNBRemote::HandlePacket_MemoryRegionInfo(RNBRemote *this, const char *a2)
{
  if (!a2[17])
  {
    char v33 = 2;
    strcpy((char *)&v31, "OK");
LABEL_13:
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v31);
    if ((v33 & 0x80000000) == 0) {
      return v7;
    }
    uint64_t v8 = v31;
LABEL_57:
    operator delete(v8);
    return v7;
  }
  if (a2[17] != 58)
  {
    char v33 = 3;
    LODWORD(v31) = 3618373;
    goto LABEL_13;
  }
  uint64_t v3 = a2 + 18;
  if (a2[18] == 48 && (*((unsigned __int8 *)a2 + 19) | 0x20) == 0x78) {
    uint64_t v3 = a2 + 20;
  }
  *__error() = 0;
  unint64_t v4 = strtoul(v3, 0, 16);
  if (!*__error() || v4)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    int v40 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    DNBProcessMemoryRegionInfo(*((_DWORD *)this + 3), v4, (uint64_t)&v38);
    *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v31 + (void)*(v31 - 3)) = v9;
    int v10 = (std::ios_base *)((char *)&v31 + (void)*(v31 - 3));
    std::ios_base::init(v10, &v32);
    v10[1].__vftable = 0;
    v10[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)long long v34 = 0u;
    long long v35 = 0u;
    int v36 = 16;
    int v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"start:", 6);
    *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24) + 8) = *(_DWORD *)((unsigned char *)v11 + *(void *)(*v11 - 24) + 8) & 0xFFFFFFB5 | 8;
    size_t v12 = (void *)std::ostream::operator<<();
    LOBYTE(__p[0]) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)__p, 1);
    if (v39)
    {
      int v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"size:", 5);
      *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v14 = (void *)std::ostream::operator<<();
      LOBYTE(__p[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)__p, 1);
    }
    if (!v40) {
      goto LABEL_43;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"permissions:", 12);
    char v15 = v40;
    if ((v40 & 2) != 0)
    {
      LOBYTE(__p[0]) = 114;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)__p, 1);
      char v15 = v40;
      if ((v40 & 1) == 0)
      {
LABEL_20:
        if ((v15 & 4) == 0) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }
    else if ((v40 & 1) == 0)
    {
      goto LABEL_20;
    }
    LOBYTE(__p[0]) = 119;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)__p, 1);
    if ((v40 & 4) == 0)
    {
LABEL_22:
      LOBYTE(__p[0]) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)__p, 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"dirty-pages:", 12);
      uint64_t v16 = *((void *)&v41 + 1);
      if (*((void *)&v41 + 1) != (void)v41)
      {
        uint64_t v17 = v41 + 8;
        *(_DWORD *)((char *)&v31 + (void)*(v31 - 3) + 8) = *(_DWORD *)((unsigned char *)&v31 + (void)*(v31 - 3) + 8) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
        while (v17 != v16)
        {
          v17 += 8;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)",", 1);
          *(_DWORD *)((char *)&v32 + (void)*(v31 - 3)) = *(_DWORD *)((unsigned char *)&v32 + (void)*(v31 - 3)) & 0xFFFFFFB5 | 8;
          std::ostream::operator<<();
        }
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)";", 1);
      if (*((void *)&v42 + 1) != (void)v43)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"type:", 5);
        if ((void)v43 != *((void *)&v42 + 1))
        {
          int v18 = *(char *)(*((void *)&v42 + 1) + 23);
          uint64_t v19 = v18 >= 0 ? *((void *)&v42 + 1) : **((void **)&v42 + 1);
          uint64_t v20 = v18 >= 0 ? *(unsigned __int8 *)(*((void *)&v42 + 1) + 23) : *(void *)(*((void *)&v42 + 1) + 8);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, v19, v20);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - *((void *)&v42 + 1)) >> 3) >= 2)
          {
            uint64_t v21 = 0;
            unint64_t v22 = 1;
            do
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)",", 1);
              int v23 = *(char *)(*((void *)&v42 + 1) + v21 + 47);
              if (v23 >= 0) {
                uint64_t v24 = *((void *)&v42 + 1) + v21 + 24;
              }
              else {
                uint64_t v24 = *(void *)(*((void *)&v42 + 1) + v21 + 24);
              }
              if (v23 >= 0) {
                uint64_t v25 = *(unsigned __int8 *)(*((void *)&v42 + 1) + v21 + 47);
              }
              else {
                uint64_t v25 = *(void *)(*((void *)&v42 + 1) + v21 + 32);
              }
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, v24, v25);
              ++v22;
              v21 += 24;
            }
            while (v22 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - *((void *)&v42 + 1)) >> 3));
          }
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)";", 1);
      }
LABEL_43:
      std::stringbuf::str();
      uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
      if (v30 < 0) {
        operator delete(__p[0]);
      }
      *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v31
      if (SBYTE7(v35) < 0) {
        operator delete(v34[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      uint64_t v26 = *((void *)&v42 + 1);
      if (*((void *)&v42 + 1))
      {
        uint64_t v27 = v43;
        long long v28 = (void *)*((void *)&v42 + 1);
        if ((void)v43 != *((void *)&v42 + 1))
        {
          do
          {
            if (*(char *)(v27 - 1) < 0) {
              operator delete(*(void **)(v27 - 24));
            }
            v27 -= 24;
          }
          while (v27 != v26);
          long long v28 = (void *)*((void *)&v42 + 1);
        }
        *(void *)&long long v43 = v26;
        operator delete(v28);
      }
      uint64_t v8 = (void (__cdecl **)(std::ostringstream *__hidden))v41;
      if (!(void)v41) {
        return v7;
      }
      *((void *)&v41 + 1) = v41;
      goto LABEL_57;
    }
LABEL_21:
    LOBYTE(__p[0]) = 120;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)__p, 1);
    goto LABEL_22;
  }

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 4281, v3, v5);
}

uint64_t RNBRemote::HandlePacket_GetProfileData(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    int v14 = *((_DWORD *)this + 3);
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v31, a2 + 16);
    memset(&v30, 0, sizeof(v30));
    memset(&__str, 0, sizeof(__str));
    __int16 v4 = -1;
    if (StdStringExtractor::GetNameColonValue(v2, &v30, &__str))
    {
      do
      {
        if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v30.__r_.__value_.__l.__size_ == 9)
          {
            mach_vm_size_t v5 = (std::string *)v30.__r_.__value_.__r.__words[0];
LABEL_11:
            std::string::size_type v6 = v5->__r_.__value_.__r.__words[0];
            int v7 = v5->__r_.__value_.__s.__data_[8];
            if (v6 == 0x7079745F6E616373 && v7 == 101)
            {
              unint64_t v22 = v19;
              *(void **)((char *)&v22 + *((void *)v19 - 3)) = v17;
              uint64_t v23 = 0;
              int v9 = (std::ios_base *)((char *)&v22 + *((void *)v22 - 3));
              std::ios_base::init(v9, v24);
              v9[1].__vftable = 0;
              v9[1].__fmtflags_ = -1;
              std::streambuf::basic_streambuf();
              long long __p = 0u;
              long long v26 = 0u;
              int v27 = 8;
              std::string::operator=((std::string *)&__p, &__str);
              std::stringbuf::__init_buf_ptrs[abi:nn180100]((uint64_t)v24);
              LODWORD(v20[0]) = 0;
              *(_DWORD *)((char *)&v24[-1] + *((void *)v22 - 3)) = *(_DWORD *)((unsigned char *)&v24[-1] + *((void *)v22 - 3)) & 0xFFFFFFB5 | 8;
              int v10 = (void *)std::istream::operator>>();
              if ((*(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 32) & 5) == 0) {
                __int16 v4 = (__int16)v20[0];
              }
              unint64_t v22 = v18;
              *(void **)((char *)&v22 + *((void *)v18 - 3)) = v16;
              if (SBYTE7(v26) < 0) {
                operator delete((void *)__p);
              }
              std::streambuf::~streambuf();
              std::istream::~istream();
              std::ios::~ios();
            }
          }
        }
        else if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) == 9)
        {
          mach_vm_size_t v5 = &v30;
          goto LABEL_11;
        }
      }
      while ((StdStringExtractor::GetNameColonValue((uint64_t)v31, &v30, &__str) & 1) != 0);
    }
    DNBProcessGetProfileData(v14, v4, v3, (uint64_t)&v22);
    uint64_t v11 = HIBYTE(v24[0]);
    if (v24[0] < 0) {
      uint64_t v11 = v23;
    }
    if (v11)
    {
      uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v22);
      if (SHIBYTE(v24[0]) < 0)
      {
LABEL_35:
        operator delete(v22);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_36:
          operator delete(__str.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
LABEL_30:
        if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_32:
          StdStringExtractor::~StdStringExtractor(v31);
          return v12;
        }
LABEL_31:
        operator delete(v30.__r_.__value_.__l.__data_);
        goto LABEL_32;
      }
    }
    else
    {
      char v21 = 2;
      strcpy((char *)v20, "OK");
      uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v20);
      if (v21 < 0)
      {
        operator delete(v20[0]);
        if (SHIBYTE(v24[0]) < 0) {
          goto LABEL_35;
        }
      }
      else if (SHIBYTE(v24[0]) < 0)
      {
        goto LABEL_35;
      }
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_36;
    }
    goto LABEL_30;
  }
  HIBYTE(v24[0]) = 2;
  strcpy((char *)&v22, "OK");
  uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v22);
  if (SHIBYTE(v24[0]) < 0) {
    operator delete(v22);
  }
  return v12;
}

uint64_t RNBRemote::HandlePacket_SetEnableAsyncProfiling(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v38, a2 + 25);
    memset(&__str, 0, sizeof(__str));
    memset(&v37, 0, sizeof(v37));
    long long v26 = this;
    if (StdStringExtractor::GetNameColonValue(v4, &v37, &__str))
    {
      unint64_t v5 = 0;
      BOOL v6 = 0;
      int v28 = -1;
      while (1)
      {
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v37.__r_.__value_.__l.__size_ == 6)
          {
            if (*(_DWORD *)v37.__r_.__value_.__l.__data_ != 1650552421
              || *(_WORD *)(v37.__r_.__value_.__r.__words[0] + 4) != 25964)
            {
              goto LABEL_5;
            }
LABEL_40:
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_str = &__str;
            }
            else {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            BOOL v6 = strtoul((const char *)p_str, 0, 10) != 0;
            goto LABEL_5;
          }
          if (v37.__r_.__value_.__l.__size_ == 9)
          {
            uint64_t v11 = (std::string *)v37.__r_.__value_.__r.__words[0];
LABEL_45:
            std::string::size_type v14 = v11->__r_.__value_.__r.__words[0];
            int v15 = v11->__r_.__value_.__s.__data_[8];
            if (v14 == 0x7079745F6E616373 && v15 == 101)
            {
              BOOL v27 = v6;
              long long v29 = v25;
              *(void **)((char *)&v29 + *((void *)v25 - 3)) = v23;
              uint64_t v30 = 0;
              uint64_t v17 = (std::ios_base *)((char *)&v29 + *((void *)v29 - 3));
              std::ios_base::init(v17, v31);
              v17[1].__vftable = 0;
              v17[1].__fmtflags_ = -1;
              std::streambuf::basic_streambuf();
              long long __p = 0u;
              long long v33 = 0u;
              int v34 = 8;
              std::string::operator=((std::string *)&__p, &__str);
              std::stringbuf::__init_buf_ptrs[abi:nn180100]((uint64_t)v31);
              *(_DWORD *)((char *)&v31[-1] + *((void *)v29 - 3)) = *(_DWORD *)((unsigned char *)&v31[-1] + *((void *)v29 - 3)) & 0xFFFFFFB5 | 8;
              int v18 = (void *)std::istream::operator>>();
              int v19 = v28;
              if ((*(_DWORD *)((unsigned char *)v18 + *(void *)(*v18 - 24) + 32) & 5) == 0) {
                int v19 = 0;
              }
              int v28 = v19;
              long long v29 = v24;
              *(void **)((char *)&v29 + *((void *)v24 - 3)) = v22;
              if (SBYTE7(v33) < 0) {
                operator delete((void *)__p);
              }
              std::streambuf::~streambuf();
              std::istream::~istream();
              std::ios::~ios();
              BOOL v6 = v27;
            }
            goto LABEL_5;
          }
          if (v37.__r_.__value_.__l.__size_ == 13
            && *(void *)v37.__r_.__value_.__l.__data_ == 0x6C61767265746E69
            && *(void *)(v37.__r_.__value_.__r.__words[0] + 5) == 0x636573755F6C6176)
          {
LABEL_24:
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v9 = &__str;
            }
            else {
              int v9 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            unint64_t v5 = strtoul((const char *)v9, 0, 10);
          }
        }
        else
        {
          if (HIBYTE(v37.__r_.__value_.__r.__words[2]) == 6)
          {
            if (LODWORD(v37.__r_.__value_.__l.__data_) != 1650552421
              || WORD2(v37.__r_.__value_.__r.__words[0]) != 25964)
            {
              goto LABEL_5;
            }
            goto LABEL_40;
          }
          if (HIBYTE(v37.__r_.__value_.__r.__words[2]) == 9)
          {
            uint64_t v11 = &v37;
            goto LABEL_45;
          }
          if (HIBYTE(v37.__r_.__value_.__r.__words[2]) == 13
            && v37.__r_.__value_.__r.__words[0] == 0x6C61767265746E69
            && *(std::string::size_type *)((char *)v37.__r_.__value_.__r.__words + 5) == 0x636573755F6C6176)
          {
            goto LABEL_24;
          }
        }
LABEL_5:
        if ((StdStringExtractor::GetNameColonValue((uint64_t)v38, &v37, &__str) & 1) == 0) {
          goto LABEL_57;
        }
      }
    }
    LOBYTE(v6) = 0;
    unint64_t v5 = 0;
    int v28 = -1;
LABEL_57:
    DNBProcessSetEnableAsyncProfiling(v3, v5 != 0 && v6, v5, v28);
    HIBYTE(v31[0]) = 2;
    strcpy((char *)&v29, "OK");
    uint64_t v20 = RNBRemote::SendPacket((uint64_t)v26, (uint64_t)&v29);
    if (SHIBYTE(v31[0]) < 0)
    {
      operator delete(v29);
      if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_59:
        if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_61:
          StdStringExtractor::~StdStringExtractor(v38);
          return v20;
        }
LABEL_60:
        operator delete(v37.__r_.__value_.__l.__data_);
        goto LABEL_61;
      }
    }
    else if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_59;
    }
    operator delete(__str.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  HIBYTE(v31[0]) = 2;
  strcpy((char *)&v29, "OK");
  uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v29);
  if (SHIBYTE(v31[0]) < 0) {
    operator delete(v29);
  }
  return v20;
}

uint64_t RNBRemote::HandlePacket_QEnableCompression(RNBRemote *this, char *a2)
{
  int v3 = a2 + 19;
  unint64_t v4 = *((void *)this + 98);
  unint64_t v5 = strstr(a2 + 19, "minsize:");
  if (v5)
  {
    BOOL v6 = v5 + 8;
    *__error() = 0;
    unint64_t v4 = strtoul(v6, 0, 10);
    if (*__error() || v4 == -1) {
      unint64_t v4 = *((void *)this + 98);
    }
  }
  if (strstr(v3, "type:zlib-deflate;"))
  {
    *((_DWORD *)this + 199) = 0;
    goto LABEL_13;
  }
  if (strstr(v3, "type:lz4;"))
  {
    *((_DWORD *)this + 199) = 1;
LABEL_13:
    *((unsigned char *)this + 792) = 1;
    *((void *)this + 98) = v4;
LABEL_14:
    char v11 = 2;
    strcpy((char *)__p, "OK");
    goto LABEL_15;
  }
  if (strstr(v3, "type:lzma;"))
  {
    *((_DWORD *)this + 199) = 2;
    *((unsigned char *)this + 792) = 1;
    *((void *)this + 98) = v4;
    goto LABEL_14;
  }
  if (strstr(v3, "type:lzfse;"))
  {
    *((_DWORD *)this + 199) = 3;
    goto LABEL_13;
  }
  char v11 = 3;
  LODWORD(__p[0]) = 3684421;
LABEL_15:
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return v8;
}

uint64_t RNBRemote::HandlePacket_WatchpointSupportInfo(RNBRemote *this, const char *a2)
{
  if (a2[22] == 58)
  {
    *__error() = 0;
    DNBWatchpointGetNumSupportedHWP(*((_DWORD *)this + 3));
    *(void **)((char *)&v11 + *((void *)v11 - 3)) = v3;
    unint64_t v4 = (std::ios_base *)((char *)&v11 + *((void *)v11 - 3));
    std::ios_base::init(v4, &v12);
    v4[1].__vftable = 0;
    v4[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)std::string::size_type v14 = 0u;
    long long v15 = 0u;
    int v16 = 16;
    unint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v11, (uint64_t)"num:", 4);
    *(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v5 + *(void *)(*v5 - 24) + 8) & 0xFFFFFFB5 | 2;
    BOOL v6 = (void *)std::ostream::operator<<();
    LOBYTE(__p[0]) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)__p, 1);
    std::stringbuf::str();
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE7(v15) < 0) {
      operator delete(v14[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else
  {
    if (a2[22])
    {
      char v13 = 3;
      LODWORD(v11) = 3618373;
    }
    else
    {
      char v13 = 2;
      strcpy((char *)&v11, "OK");
    }
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v11);
    if (v13 < 0) {
      operator delete(v11);
    }
  }
  return v7;
}

uint64_t RNBRemote::HandlePacket_QSetProcessEvent(RNBRemote *this, const char *a2)
{
  int v3 = (char *)(a2 + 17);
  int v4 = *((_DWORD *)this + 3);
  if (v4)
  {
    if (!DNBProcessSendEvent(v4, v3))
    {
      char v8 = 3;
      LODWORD(__p[0]) = 3160133;
      goto LABEL_6;
    }
  }
  else
  {
    std::string::assign((std::string *)((char *)this + 416), v3);
  }
  char v8 = 2;
  strcpy((char *)__p, "OK");
LABEL_6:
  uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

uint64_t RNBRemote::HandlePacket_QSetDetachOnError(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = a2[18];
  if (v5 == 48)
  {
    char v6 = 0;
    goto LABEL_5;
  }
  if (v5 == 49)
  {
    char v6 = 1;
LABEL_5:
    *((unsigned char *)this + 440) = v6;
    char v10 = 2;
    strcpy((char *)__p, "OK");
    uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return v7;
  }

  return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 2384, a2 + 18, a5);
}

uint64_t RNBRemote::HandlePacket_qSpeedTest(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 25;
  std::string __endptr = 0;
  *__error() = 0;
  size_t v4 = strtoul(v3, &__endptr, 16);
  if (*__error())
  {
    return RNBRemote::HandlePacket_ILLFORMED(this, "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp", 4444, v3, v5);
  }
  if (*__endptr == 59)
  {
    strcpy((char *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data, "data:");
    memset((char *)&word_10007984C + 1, 97, v4);
    *((unsigned char *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data + v4 + 5) = 0;
    size_t v7 = strlen((const char *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    char v8 = (void *)v7;
    if (v7 >= 0x17)
    {
      uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v10 = v7 | 7;
      }
      uint64_t v11 = v10 + 1;
      int v9 = operator new(v10 + 1);
      __p[1] = v8;
      unint64_t v14 = v11 | 0x8000000000000000;
      __p[0] = v9;
    }
    else
    {
      HIBYTE(v14) = v7;
      int v9 = __p;
      if (!v7) {
        goto LABEL_15;
      }
    }
    memcpy(v9, &RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data, (size_t)v8);
LABEL_15:
    *((unsigned char *)v8 + (void)v9) = 0;
    goto LABEL_16;
  }
  HIBYTE(v14) = 3;
  LODWORD(__p[0]) = 3749701;
LABEL_16:
  uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  return v12;
}

const char *RNBRemote::HandlePacket_qXfer(RNBRemote *this, char *a2)
{
  uint64_t v2 = a2;
  size_t v4 = a2 + 6;
  int v5 = strchr(a2 + 6, 58);
  if (v5)
  {
    char v6 = v5;
    size_t v7 = v5 - v4;
    if ((unint64_t)(v5 - v4) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_145;
    }
    if (v7 >= 0x17)
    {
      uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v9 = v7 | 7;
      }
      uint64_t v10 = v9 + 1;
      p_dst = (void **)operator new(v9 + 1);
      size_t v77 = v7;
      unint64_t v78 = v10 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v78) = (_BYTE)v5 - (_BYTE)v4;
      p_dst = (void **)&__dst;
      if (v5 == v4)
      {
LABEL_10:
        *((unsigned char *)p_dst + v7) = 0;
        uint64_t v11 = v6 + 1;
        uint64_t v12 = strchr(v6 + 1, 58);
        if (!v12)
        {
          char v66 = 3;
          LODWORD(__p[0]) = 3553349;
          RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
          if (v66 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_68;
        }
        char v13 = v12;
        size_t v14 = v12 - v11;
        if ((unint64_t)(v12 - v11) > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_145;
        }
        if (v14 >= 0x17)
        {
          uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v14 | 7) != 0x17) {
            uint64_t v16 = v14 | 7;
          }
          uint64_t v17 = v16 + 1;
          long long v15 = (void **)operator new(v16 + 1);
          v74[1] = (void *)v14;
          unint64_t v75 = v17 | 0x8000000000000000;
          v74[0] = v15;
        }
        else
        {
          HIBYTE(v75) = (_BYTE)v12 - (_BYTE)v11;
          long long v15 = v74;
          if (v12 == v11)
          {
LABEL_22:
            *((unsigned char *)v15 + v14) = 0;
            int v18 = v13 + 1;
            int v19 = strchr(v13 + 1, 58);
            if (!v19)
            {
              char v66 = 3;
              LODWORD(__p[0]) = 3487813;
              RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
              if (v66 < 0) {
                operator delete(__p[0]);
              }
              goto LABEL_66;
            }
            uint64_t v20 = v19;
            size_t v21 = v19 - v18;
            if ((unint64_t)(v19 - v18) > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_145;
            }
            if (v21 >= 0x17)
            {
              uint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v21 | 7) != 0x17) {
                uint64_t v23 = v21 | 7;
              }
              uint64_t v24 = v23 + 1;
              unint64_t v22 = (void **)operator new(v23 + 1);
              v72[1] = (void *)v21;
              unint64_t v73 = v24 | 0x8000000000000000;
              v72[0] = v22;
            }
            else
            {
              HIBYTE(v73) = (_BYTE)v19 - (_BYTE)v18;
              unint64_t v22 = v72;
              if (v19 == v18)
              {
LABEL_34:
                *((unsigned char *)v22 + v21) = 0;
                uint64_t v25 = v20 + 1;
                long long v26 = strchr(v20 + 1, 44);
                if (!v26) {
                  goto LABEL_75;
                }
                BOOL v27 = v26;
                size_t v28 = v26 - v25;
                if ((unint64_t)(v26 - v25) > 0x7FFFFFFFFFFFFFF7) {
                  goto LABEL_145;
                }
                if (v28 >= 0x17)
                {
                  uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v28 | 7) != 0x17) {
                    uint64_t v30 = v28 | 7;
                  }
                  uint64_t v31 = v30 + 1;
                  long long v29 = (void **)operator new(v30 + 1);
                  v70[1] = (void *)v28;
                  int64_t v71 = v31 | 0x8000000000000000;
                  v70[0] = v29;
                }
                else
                {
                  HIBYTE(v71) = (_BYTE)v26 - (_BYTE)v25;
                  long long v29 = v70;
                  if (v26 == v25)
                  {
LABEL_44:
                    *((unsigned char *)v29 + v28) = 0;
                    uint64_t v32 = v27 + 1;
                    size_t v33 = strlen(v27 + 1);
                    if (v33 <= 0x7FFFFFFFFFFFFFF7)
                    {
                      int v34 = (void *)v33;
                      if (v33 >= 0x17)
                      {
                        uint64_t v36 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v33 | 7) != 0x17) {
                          uint64_t v36 = v33 | 7;
                        }
                        uint64_t v37 = v36 + 1;
                        long long v35 = (void **)operator new(v36 + 1);
                        v68[1] = v34;
                        int64_t v69 = v37 | 0x8000000000000000;
                        v68[0] = v35;
                      }
                      else
                      {
                        HIBYTE(v69) = v33;
                        long long v35 = v68;
                        if (!v33)
                        {
LABEL_52:
                          *((unsigned char *)v34 + (void)v35) = 0;
                          std::string __endptr = 0;
                          if (v71 >= 0) {
                            uint64_t v38 = (const char *)v70;
                          }
                          else {
                            uint64_t v38 = (const char *)v70[0];
                          }
                          unint64_t v39 = strtoul(v38, &__endptr, 16);
                          if (*__endptr
                            || ((std::string::size_type v40 = v39, v69 >= 0) ? (v41 = (const char *)v68) : (v41 = (const char *)v68[0]),
                                unint64_t v42 = strtoul(v41, &__endptr, 16),
                                *__endptr))
                          {
                            int v43 = 1;
                            if ((SHIBYTE(v69) & 0x80000000) == 0) {
                              goto LABEL_62;
                            }
                            goto LABEL_61;
                          }
                          std::string::size_type v47 = v42;
                          if (SHIBYTE(v78) < 0)
                          {
                            if (v77 != 8) {
                              goto LABEL_97;
                            }
                            size_t v48 = __dst;
                          }
                          else
                          {
                            if (SHIBYTE(v78) != 8) {
                              goto LABEL_97;
                            }
                            size_t v48 = (void **)&__dst;
                          }
                          if (*v48 == (void *)0x7365727574616566
                            && std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v74, "read")&& std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v72, "target.xml"))
                          {
                            std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
                            if (v40)
                            {
                              std::string::size_type v49 = *((void *)&g_target_xml + 1);
                              if (byte_10047986F >= 0) {
                                std::string::size_type v49 = byte_10047986F;
                              }
                              if (v40 >= v49) {
                                goto LABEL_141;
                              }
                              std::string::basic_string(&v64, (const std::string *)&g_target_xml, v40, v47, (std::allocator<char> *)&v63);
                              std::string::size_type size = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                              if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                                std::string::size_type size = v64.__r_.__value_.__l.__size_;
                              }
                              if (size >= v47) {
                                std::string::value_type v51 = 109;
                              }
                              else {
                                std::string::value_type v51 = 108;
                              }
                              v63.__r_.__value_.__s.__data_[0] = v51;
                              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v63, 1);
                              if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                uint64_t v55 = &v64;
                              }
                              else {
                                uint64_t v55 = (std::string *)v64.__r_.__value_.__r.__words[0];
                              }
                              std::string::basic_string[abi:nn180100]<0>(v61, (char *)v55);
                              binary_encode_string((unsigned __int8 *)v61, &v63);
                              if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                long long v56 = &v63;
                              }
                              else {
                                long long v56 = (std::string *)v63.__r_.__value_.__r.__words[0];
                              }
                              if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                std::string::size_type v57 = HIBYTE(v63.__r_.__value_.__r.__words[2]);
                              }
                              else {
                                std::string::size_type v57 = v63.__r_.__value_.__l.__size_;
                              }
                              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v56, v57);
                              if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
                              {
                                operator delete(v63.__r_.__value_.__l.__data_);
                                if ((v62 & 0x80000000) == 0)
                                {
LABEL_123:
                                  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                                    goto LABEL_139;
                                  }
LABEL_141:
                                  std::stringbuf::str();
                                  goto LABEL_142;
                                }
                              }
                              else if ((v62 & 0x80000000) == 0)
                              {
                                goto LABEL_123;
                              }
                              operator delete(v61[0]);
                              if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_141;
                              }
LABEL_139:
                              uint64_t v60 = (void *)v64.__r_.__value_.__r.__words[0];
LABEL_140:
                              operator delete(v60);
                              goto LABEL_141;
                            }
                            RNBRemote::InitializeRegisters(this, 1);
                            UpdateTargetXML();
                            if (byte_10047986F < 0)
                            {
                              std::string::size_type v52 = *((void *)&g_target_xml + 1);
                              if (*((void *)&g_target_xml + 1)) {
                                goto LABEL_102;
                              }
                            }
                            else
                            {
                              std::string::size_type v52 = byte_10047986F;
                              if (byte_10047986F)
                              {
LABEL_102:
                                if (v47 <= v52)
                                {
                                  v64.__r_.__value_.__s.__data_[0] = 109;
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v64, 1);
                                  std::string::basic_string(&v63, (const std::string *)&g_target_xml, 0, v47, (std::allocator<char> *)v61);
                                  binary_encode_string((unsigned __int8 *)&v63, &v64);
                                  if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                    int v58 = &v64;
                                  }
                                  else {
                                    int v58 = (std::string *)v64.__r_.__value_.__r.__words[0];
                                  }
                                  if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                    std::string::size_type v59 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                                  }
                                  else {
                                    std::string::size_type v59 = v64.__r_.__value_.__l.__size_;
                                  }
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v58, v59);
                                  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                                    operator delete(v64.__r_.__value_.__l.__data_);
                                  }
                                  if ((SHIBYTE(v63.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                    goto LABEL_141;
                                  }
                                  uint64_t v60 = (void *)v63.__r_.__value_.__r.__words[0];
                                  goto LABEL_140;
                                }
                                v64.__r_.__value_.__s.__data_[0] = 108;
                                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v64, 1);
                                binary_encode_string((unsigned __int8 *)&g_target_xml, &v64);
                                if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  int v53 = &v64;
                                }
                                else {
                                  int v53 = (std::string *)v64.__r_.__value_.__r.__words[0];
                                }
                                if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  std::string::size_type v54 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                                }
                                else {
                                  std::string::size_type v54 = v64.__r_.__value_.__l.__size_;
                                }
                                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v53, v54);
                                if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                  goto LABEL_141;
                                }
                                goto LABEL_139;
                              }
                            }
                            std::string::basic_string[abi:nn180100]<0>(&v64, "E83");
LABEL_142:
                            uint64_t v2 = (const char *)RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v64);
                            if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                              operator delete(v64.__r_.__value_.__l.__data_);
                            }
                            std::ostringstream::~ostringstream((uint64_t)__p);
LABEL_98:
                            int v43 = 0;
                            if ((SHIBYTE(v69) & 0x80000000) == 0)
                            {
LABEL_62:
                              if (SHIBYTE(v71) < 0)
                              {
                                operator delete(v70[0]);
                                if (!v43)
                                {
LABEL_64:
                                  if ((SHIBYTE(v73) & 0x80000000) == 0) {
                                    goto LABEL_65;
                                  }
LABEL_76:
                                  operator delete(v72[0]);
                                  if ((v43 & 1) == 0) {
                                    goto LABEL_77;
                                  }
LABEL_66:
                                  char v44 = 1;
                                  if ((SHIBYTE(v75) & 0x80000000) == 0) {
                                    goto LABEL_67;
                                  }
LABEL_78:
                                  operator delete(v74[0]);
                                  if ((v44 & 1) == 0) {
                                    goto LABEL_79;
                                  }
LABEL_68:
                                  int v45 = 1;
                                  if ((SHIBYTE(v78) & 0x80000000) == 0) {
                                    goto LABEL_70;
                                  }
                                  goto LABEL_69;
                                }
                              }
                              else if (!v43)
                              {
                                goto LABEL_64;
                              }
LABEL_75:
                              LOBYTE(v43) = 1;
                              if ((SHIBYTE(v73) & 0x80000000) == 0)
                              {
LABEL_65:
                                if (v43) {
                                  goto LABEL_66;
                                }
LABEL_77:
                                char v44 = 0;
                                if ((SHIBYTE(v75) & 0x80000000) == 0)
                                {
LABEL_67:
                                  if (v44) {
                                    goto LABEL_68;
                                  }
LABEL_79:
                                  int v45 = 0;
                                  if ((SHIBYTE(v78) & 0x80000000) == 0)
                                  {
LABEL_70:
                                    if (!v45) {
                                      return v2;
                                    }
                                    goto LABEL_71;
                                  }
LABEL_69:
                                  operator delete(__dst);
                                  goto LABEL_70;
                                }
                                goto LABEL_78;
                              }
                              goto LABEL_76;
                            }
LABEL_61:
                            operator delete(v68[0]);
                            goto LABEL_62;
                          }
LABEL_97:
                          uint64_t v2 = (const char *)RNBRemote::HandlePacket_UNIMPLEMENTED(this, v2);
                          goto LABEL_98;
                        }
                      }
                      memmove(v35, v32, (size_t)v34);
                      goto LABEL_52;
                    }
LABEL_145:
                    abort();
                  }
                }
                memmove(v29, v25, v28);
                goto LABEL_44;
              }
            }
            memmove(v22, v18, v21);
            goto LABEL_34;
          }
        }
        memmove(v15, v11, v14);
        goto LABEL_22;
      }
    }
    memcpy(p_dst, v4, v7);
    goto LABEL_10;
  }
LABEL_71:
  char v66 = 3;
  LODWORD(__p[0]) = 3291205;
  uint64_t v2 = (const char *)RNBRemote::SendPacket((uint64_t)this, (uint64_t)__p);
  if (v66 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t RNBRemote::HandlePacket_jGetDyldProcessState(RNBRemote *this, const char *a2)
{
  uint64_t v3 = *((unsigned int *)this + 3);
  if (v3)
  {
    DNBGetDyldProcessState(v3, &v20);
    if (!v20)
    {
LABEL_15:
      char v15 = 3;
      LODWORD(v13) = 3684421;
      uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v13);
      if (v15 < 0) {
        operator delete(v13);
      }
LABEL_17:
      char v8 = v21;
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      return v4;
    }
    *(void **)((char *)&v13 + *((void *)v13 - 3)) = v5;
    char v6 = (std::ios_base *)((char *)&v13 + *((void *)v13 - 3));
    std::ios_base::init(v6, &v14);
    v6[1].__vftable = 0;
    v6[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)uint64_t v16 = 0u;
    long long v17 = 0u;
    int v18 = 16;
    (*(void (**)(uint64_t, void **))(*(void *)v20 + 40))(v20, &v13);
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
    std::stringbuf::str();
    if (v12 < 0)
    {
      uint64_t v4 = v11;
      operator delete(__p);
      if (v11) {
        goto LABEL_5;
      }
    }
    else if (v12)
    {
LABEL_5:
      std::stringbuf::str();
      uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
      if (v12 < 0) {
        operator delete(__p);
      }
      int v7 = 0;
LABEL_12:
      if (SBYTE7(v17) < 0) {
        operator delete(v16[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (!v7) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }
    int v7 = 1;
    goto LABEL_12;
  }
  char v15 = 3;
  LODWORD(v13) = 3618885;
  uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v13);
  if (v15 < 0) {
    operator delete(v13);
  }
  return v4;
}

int *RNBRemote::FlushSTDIO(int *this)
{
  int v1 = this[3];
  if (v1)
  {
    uint64_t v2 = (RNBRemote *)this;
    size_t AvailableSTDOUT = DNBProcessGetAvailableSTDOUT(this[3], v6, 0x100uLL);
    if (AvailableSTDOUT)
    {
      size_t v4 = AvailableSTDOUT;
      do
      {
        RNBRemote::SendHexEncodedBytePacket(v2, "O", v6, v4, 0);
        size_t v4 = DNBProcessGetAvailableSTDOUT(v1, v6, 0x100uLL);
      }
      while (v4);
    }
    this = (int *)DNBProcessGetAvailableSTDERR(v1, v6);
    if (this)
    {
      uint64_t v5 = (uint64_t)this;
      do
      {
        RNBRemote::SendHexEncodedBytePacket(v2, "O", v6, v5, 0);
        this = (int *)DNBProcessGetAvailableSTDERR(v1, v6);
        uint64_t v5 = (uint64_t)this;
      }
      while (this);
    }
  }
  return this;
}

size_t RNBRemote::SendAsyncProfileData(size_t this)
{
  int v1 = *(_DWORD *)(this + 12);
  if (v1)
  {
    uint64_t v2 = this;
    this = DNBProcessGetAvailableProfileData(*(_DWORD *)(this + 12), __s, 0x400uLL);
    if (this)
    {
      std::string::size_type v3 = this;
      do
      {
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 1;
        LOWORD(__p.__r_.__value_.__l.__data_) = 65;
        std::string::append(&__p, __s, v3);
        RNBRemote::SendPacket(v2, (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        this = DNBProcessGetAvailableProfileData(v1, __s, 0x400uLL);
        std::string::size_type v3 = this;
      }
      while (this);
    }
  }
  return this;
}

uint64_t RNBRemote::SendHexEncodedBytePacket(RNBRemote *this, const char *a2, char *a3, uint64_t a4, const char *a5)
{
  *(void *)((char *)&v22[-1] + (void)*(v21 - 3)) = v8;
  uint64_t v9 = (std::ios_base *)((char *)&v22[-1] + (void)*(v21 - 3));
  std::ios_base::init(v9, v22);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)std::string __p = 0u;
  long long v24 = 0u;
  int v25 = 16;
  if (a2 && *a2)
  {
    size_t v10 = strlen(a2);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)a2, v10);
  }
  for (; a4; --a4)
  {
    uint64_t v11 = v21;
    char v12 = (char *)&v22[-1] + (void)*(v21 - 3);
    if (*((_DWORD *)v12 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v22[-1] + (void)*(v21 - 3)));
      char v13 = std::locale::use_facet(&v19, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 32);
      std::locale::~locale(&v19);
      uint64_t v11 = v21;
    }
    *((_DWORD *)v12 + 36) = 48;
    *(_DWORD *)((char *)v22 + (void)*(v11 - 3)) = *(_DWORD *)((unsigned char *)v22 + (void)*(v11 - 3)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)v22 + (void)*(v11 - 3)) = *(_DWORD *)((unsigned char *)v22 + (void)*(v11 - 3)) & 0xFFFFFF4F | 0x80;
    *(void *)((char *)&v22[2] + (void)*(v11 - 3)) = 2;
    ++a3;
    std::ostream::operator<<();
  }
  if (a5 && *a5)
  {
    size_t v14 = strlen(a5);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)a5, v14);
  }
  std::stringbuf::str();
  uint64_t v15 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v19);
  if (v20 < 0) {
    operator delete(v19.__locale_);
  }
  if (SBYTE7(v24) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v15;
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  *(void *)a1 = v3;
  *(void *)(a1 + *(void *)(v3 - 24)) = v2;
  size_t v4 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v4, (void *)(a1 + 8));
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

uint64_t RNBRemote::SendPacket(uint64_t a1, uint64_t a2)
{
  if (DNBLogEnabledForAny(0x40000))
  {
    size_t v4 = *(pthread_mutex_t **)(a1 + 488);
    if (v4) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday((timeval *)&v47, 0);
    int data = (int)v47.__r_.__value_.__l.__data_;
    int v6 = v47.__r_.__value_.__r.__words[1];
    uint64_t v7 = *(void *)(a1 + 496);
    int v8 = *(_DWORD *)(a1 + 504);
    *(_OWORD *)(a1 + 496) = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = (const char *)a2;
    }
    else {
      uint64_t v9 = *(const char **)a2;
    }
    _DNBLogThreaded("%8d RNBRemote::%s (%s) called", v6 - v8 + 1000000 * (data - v7), "SendPacket", v9);
  }
  RNBRemote::CompressString((std::string *)a2, a1, (uint64_t)v56);
  std::operator+<char>();
  size_t v10 = std::string::append(&v47, "#");
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v47.__r_.__value_.__l.__data_);
    if (*(unsigned char *)(a1 + 781)) {
      goto LABEL_12;
    }
  }
  else if (*(unsigned char *)(a1 + 781))
  {
LABEL_12:
    char v12 = "00";
    goto LABEL_31;
  }
  unint64_t v13 = v57;
  if ((v57 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)v56[1];
  }
  if (v13)
  {
    size_t v14 = (void **)v56[0];
    if (v13 == 1)
    {
      unint64_t v15 = 0;
      unsigned __int8 v16 = 0;
    }
    else
    {
      char v18 = 0;
      char v19 = 0;
      unint64_t v15 = v13 & 0xFFFFFFFFFFFFFFFELL;
      char v20 = v56;
      if ((v57 & 0x80u) != 0) {
        char v20 = (void **)v56[0];
      }
      size_t v21 = (char *)v20 + 1;
      unint64_t v22 = v13 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        char v24 = *(unsigned char *)v20;
        char v20 = (void **)((char *)v20 + 2);
        char v23 = v24;
        char v25 = *v21;
        v21 += 2;
        v18 += v23;
        v19 += v25;
        v22 -= 2;
      }
      while (v22);
      unsigned __int8 v16 = v19 + v18;
      if (v13 == v15) {
        goto LABEL_29;
      }
    }
    if ((v57 & 0x80u) == 0) {
      size_t v14 = v56;
    }
    long long v26 = (char *)(v13 - v15);
    BOOL v27 = (char *)v14 + v15;
    do
    {
      char v28 = *v27++;
      v16 += v28;
      --v26;
    }
    while (v26);
LABEL_29:
    int v17 = v16;
    goto LABEL_30;
  }
  int v17 = 0;
LABEL_30:
  char v12 = __str;
  snprintf(__str, 5uLL, "%02x", v17);
LABEL_31:
  std::string::append(&v55, v12);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v29 = &v55;
  }
  else {
    long long v29 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v55.__r_.__value_.__l.__size_;
  }
  uint64_t v31 = RNBSocket::Write((RNBSocket *)(a1 + 472), v29, size);
  if (v31) {
    goto LABEL_46;
  }
  if (!*(unsigned char *)(a1 + 781))
  {
    v52[0] = 0;
    v52[1] = 0;
    uint64_t v53 = 0;
    LODWORD(v47.__r_.__value_.__l.__data_) = 0;
    *(_OWORD *)&v47.__r_.__value_.__r.__words[1] = 0u;
    long long v48 = 0u;
    *(_OWORD *)std::string::size_type v49 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v51 = 0u;
    uint64_t Packet = RNBRemote::GetPacket(a1, v52, &v47, 1);
    if (Packet)
    {
      uint64_t v31 = Packet;
      if (!DNBLogEnabledForAny(0x100000))
      {
        if ((SHIBYTE(v51) & 0x80000000) == 0) {
          goto LABEL_44;
        }
LABEL_68:
        operator delete(__p[1]);
        if ((SHIBYTE(__p[0]) & 0x80000000) == 0)
        {
LABEL_45:
          if ((SHIBYTE(v53) & 0x80000000) == 0) {
            goto LABEL_46;
          }
LABEL_70:
          operator delete(v52[0]);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_71;
          }
          goto LABEL_47;
        }
        goto LABEL_69;
      }
      long long v41 = *(pthread_mutex_t **)(a1 + 488);
      if (v41) {
        pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
      }
      gettimeofday(&v58, 0);
      int tv_sec = v58.tv_sec;
      __darwin_suseconds_t tv_usec = v58.tv_usec;
      uint64_t v44 = *(void *)(a1 + 496);
      int v45 = *(_DWORD *)(a1 + 504);
      *(timeval *)(a1 + 496) = v58;
      if (v41) {
        pthread_mutex_unlock(v41);
      }
      uint64_t v46 = &v55;
      if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v46 = (std::string *)v55.__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded("%8d RNBRemote::%s (%s) got error trying to get reply...", tv_usec - v45 + 1000000 * (tv_sec - v44), "SendPacket", (const char *)v46);
      if (SHIBYTE(v51) < 0) {
        goto LABEL_68;
      }
    }
    else
    {
      if (DNBLogEnabledForAny(0x40000))
      {
        int v34 = *(pthread_mutex_t **)(a1 + 488);
        if (v34) {
          pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
        }
        gettimeofday(&v58, 0);
        int v35 = v58.tv_sec;
        __darwin_suseconds_t v36 = v58.tv_usec;
        uint64_t v37 = *(void *)(a1 + 496);
        int v38 = *(_DWORD *)(a1 + 504);
        *(timeval *)(a1 + 496) = v58;
        if (v34) {
          pthread_mutex_unlock(v34);
        }
        unint64_t v39 = &v55;
        if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unint64_t v39 = (std::string *)v55.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v40 = v52;
        if (v53 < 0) {
          std::string::size_type v40 = (void **)v52[0];
        }
        _DNBLogThreaded("%8d RNBRemote::%s (%s) got reply: '%s'", v36 - v38 + 1000000 * (v35 - v37), "SendPacket", (const char *)v39, (const char *)v40);
      }
      uint64_t v31 = LODWORD(v47.__r_.__value_.__l.__data_) != 1;
      if (SHIBYTE(v51) < 0) {
        goto LABEL_68;
      }
    }
LABEL_44:
    if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
      goto LABEL_45;
    }
LABEL_69:
    operator delete(v49[0]);
    if (SHIBYTE(v53) < 0) {
      goto LABEL_70;
    }
LABEL_46:
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_71;
    }
    goto LABEL_47;
  }
  uint64_t v31 = 0;
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_71:
    operator delete(v55.__r_.__value_.__l.__data_);
    if ((char)v57 < 0) {
      goto LABEL_72;
    }
    return v31;
  }
LABEL_47:
  if ((char)v57 < 0) {
LABEL_72:
  }
    operator delete(v56[0]);
  return v31;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return a1;
}

void RNBRemote::CompressString(std::string *__str@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (*(unsigned char *)(a2 + 792))
  {
    *(unsigned char *)(a2 + 792) = 0;
LABEL_4:
    std::string::operator=((std::string *)a3, __str);
    return;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 796);
  if (v5 == 4) {
    goto LABEL_4;
  }
  if ((SHIBYTE(__str->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    if (*(void *)(a2 + 784) < size) {
      goto LABEL_9;
    }
LABEL_13:
    std::operator+<char>();
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = *(_OWORD *)__stra;
    *(void *)(a3 + 16) = v22;
    return;
  }
  std::string::size_type size = __str->__r_.__value_.__l.__size_;
  if (size <= *(void *)(a2 + 784)) {
    goto LABEL_13;
  }
LABEL_9:
  size_t v7 = size + 128;
  if (size == -128)
  {
    int v8 = 0;
  }
  else
  {
    if ((v7 & 0x8000000000000000) != 0) {
      abort();
    }
    int v8 = (unsigned __int8 *)operator new(size + 128);
    bzero(v8, v7);
  }
  if (RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf_type == v5)
  {
LABEL_23:
    if (v5 <= 3)
    {
      int v10 = SHIBYTE(__str->__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v10 >= 0 ? __str : (std::string *)__str->__r_.__value_.__r.__words[0];
      size_t v12 = v10 >= 0 ? HIBYTE(__str->__r_.__value_.__r.__words[2]) : __str->__r_.__value_.__l.__size_;
      size_t v13 = compression_encode_buffer(v8, v7, (const uint8_t *)v11, v12, (void *)RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf, (compression_algorithm)dword_100065D10[v5]);
      if (v13)
      {
        size_t v14 = v13;
        if (*(char *)(a3 + 23) < 0)
        {
          **(unsigned char **)a3 = 0;
          *(void *)(a3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)a3 = 0;
          *(unsigned char *)(a3 + 23) = 0;
        }
        std::string::reserve((std::string *)a3, v13);
        std::string::assign((std::string *)a3, "C");
        std::string::size_type v15 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
        if ((v15 & 0x80u) != 0) {
          std::string::size_type v15 = __str->__r_.__value_.__l.__size_;
        }
        snprintf(__stra, 0x10uLL, "%zu:", v15);
        __stra[15] = 0;
        std::string::append((std::string *)a3, __stra);
        unsigned __int8 v16 = v8;
        do
        {
          unsigned int v18 = *v16++;
          unsigned int v17 = v18;
          uint64_t v19 = (1 << v18) & 0x41800000001;
          BOOL v20 = v18 > 0x2A || v19 == 0;
          if (!v20 || v17 == 125)
          {
            std::string::push_back((std::string *)a3, 125);
            LOBYTE(v17) = v17 ^ 0x20;
          }
          std::string::push_back((std::string *)a3, v17);
          --v14;
        }
        while (v14);
LABEL_36:
        operator delete(v8);
        return;
      }
    }
    goto LABEL_33;
  }
  if (RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf)
  {
    free((void *)RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf);
    RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf = 0;
  }
  if (v5 <= 3)
  {
    size_t v9 = compression_encode_scratch_buffer_size((compression_algorithm)dword_100065D10[v5]);
    if (v9)
    {
      RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf = (uint64_t)malloc_type_malloc(v9, 0x26F84502uLL);
      RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf_type = v5;
    }
    goto LABEL_23;
  }
LABEL_33:
  std::operator+<char>();
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  *(_OWORD *)a3 = *(_OWORD *)__stra;
  *(void *)(a3 + 16) = v22;
  if (v8) {
    goto LABEL_36;
  }
}

void *std::vector<unsigned char>::vector(void *a1, size_t __sz)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (__sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      abort();
    }
    size_t v4 = (char *)operator new(__sz);
    *a1 = v4;
    unsigned int v5 = &v4[__sz];
    a1[2] = &v4[__sz];
    bzero(v4, __sz);
    a1[1] = v5;
  }
  return a1;
}

__darwin_time_t DNBTimer::ElapsedMicroSeconds(pthread_mutex_t **this, int a2)
{
  size_t v4 = *this;
  if (*this) {
    pthread_mutex_lock(*this);
  }
  gettimeofday(&v12, 0);
  size_t v7 = this[1];
  unsigned int v5 = (timeval *)(this + 1);
  int v6 = v7;
  uint64_t tv_usec = v5->tv_usec;
  if (a2) {
    *unsigned int v5 = v12;
  }
  __darwin_time_t tv_sec = v12.tv_sec;
  uint64_t v10 = v12.tv_usec;
  if (v4) {
    pthread_mutex_unlock(v4);
  }
  return v10 - tv_usec + 1000000 * (tv_sec - (void)v6);
}

uint64_t RNBRemote::GetPacket(uint64_t a1, std::string *a2, uint64_t a3, int a4)
{
  memset(&__str, 0, sizeof(__str));
  if (RNBRemote::GetPacketPayload(a1, &__str))
  {
    char EventBits = PThreadEvent::GetEventBits((pthread_mutex_t *)(a1 + 120));
    uint64_t v9 = 1;
    if (!a4 || (EventBits & 0x40) == 0) {
      goto LABEL_45;
    }
    while (1)
    {
      int v10 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(a1 + 120), 0xA0u, 0);
      if (!v10)
      {
        while (1)
          ;
      }
      char v11 = v10;
      if ((v10 & 0x20) != 0 && !RNBRemote::GetPacketPayload(a1, &__str)) {
        break;
      }
      if (v11 < 0)
      {
        uint64_t v9 = 2;
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v9;
        }
        goto LABEL_46;
      }
    }
  }
  timeval v12 = *(long long **)(a1 + 672);
  size_t v13 = *(long long **)(a1 + 680);
  if (v12 != v13)
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    uint64_t v16 = (uint64_t)v12 + 40;
    while (1)
    {
      if (*(char *)(v16 + 23) < 0)
      {
        std::string::size_type v17 = *(void *)(v16 + 8);
        if (v17 == -1) {
          abort();
        }
      }
      else
      {
        std::string::size_type v17 = *(unsigned __int8 *)(v16 + 23);
      }
      size_t v18 = size >= v17 ? v17 : size;
      uint64_t v19 = *(char *)(v16 + 23) >= 0 ? (const void *)v16 : *(const void **)v16;
      if (!memcmp(p_str, v19, v18) && v17 <= size) {
        break;
      }
      size_t v21 = (long long *)(v16 + 48);
      v16 += 88;
      if (v21 == v13) {
        goto LABEL_37;
      }
    }
    timeval v12 = (long long *)(v16 - 40);
  }
  if (v12 != v13)
  {
    long long v22 = *v12;
    long long v23 = v12[1];
    *(void *)(a3 + 32) = *((void *)v12 + 4);
    *(_OWORD *)a3 = v22;
    *(_OWORD *)(a3 + 16) = v23;
    std::string::operator=((std::string *)(a3 + 40), (const std::string *)((char *)v12 + 40));
    std::string::operator=((std::string *)(a3 + 64), (const std::string *)(v12 + 4));
    std::string::operator=(a2, &__str);
    uint64_t v9 = 0;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_46;
    }
    return v9;
  }
LABEL_37:
  if (DNBLogEnabledForAny(0x800000))
  {
    char v24 = &__str;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      char v24 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("unimplemented packet: '%s'", (const char *)v24);
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v25 = &__str;
  }
  else {
    char v25 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  RNBRemote::HandlePacket_UNIMPLEMENTED((RNBRemote *)a1, (const char *)v25);
  uint64_t v9 = 1;
LABEL_45:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
LABEL_46:
  }
    operator delete(__str.__r_.__value_.__l.__data_);
  return v9;
}

uint64_t RNBRemote::GetPacketPayload(uint64_t a1, std::string *a2)
{
  size_t v4 = (pthread_mutex_t *)(a1 + 552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
  if (!*(void *)(a1 + 736))
  {
    PThreadEvent::ResetEvents((pthread_mutex_t *)(a1 + 120), 32);
    pthread_mutex_unlock(v4);
    return 1;
  }
  unint64_t v5 = *(void *)(*(void *)(a1 + 704) + 8 * (*(void *)(a1 + 728) / 0xAAuLL))
     + 24 * (*(void *)(a1 + 728) % 0xAAuLL);
  std::string::size_type v6 = a2->__r_.__value_.__r.__words[2];
  long long v7 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
  std::string::size_type v8 = *(void *)(v5 + 16);
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
  a2->__r_.__value_.__r.__words[2] = v8;
  *(_OWORD *)unint64_t v5 = v7;
  *(void *)(v5 + 16) = v6;
  unint64_t v9 = *(void *)(a1 + 728);
  unint64_t v10 = *(void *)(*(void *)(a1 + 704) + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
  if (*(char *)(v10 + 23) < 0)
  {
    operator delete(*(void **)v10);
    unint64_t v9 = *(void *)(a1 + 728);
  }
  --*(void *)(a1 + 736);
  unint64_t v11 = v9 + 1;
  *(void *)(a1 + 728) = v11;
  if (v11 >= 0x154)
  {
    operator delete(**(void ***)(a1 + 704));
    *(void *)(a1 + 704) += 8;
    *(void *)(a1 + 728) -= 170;
  }
  pthread_mutex_unlock(v4);
  if (!*(void *)(a1 + 736)) {
    PThreadEvent::ResetEvents((pthread_mutex_t *)(a1 + 120), 32);
  }
  uint64_t v12 = 0;
  int v13 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  size_t v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
  if (v13 >= 0) {
    std::string::size_type v15 = a2;
  }
  else {
    std::string::size_type v15 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  int v16 = v15->__r_.__value_.__s.__data_[0];
  if (v16 > 42)
  {
    if (v16 == 43 || v16 == 45) {
      return v12;
    }
LABEL_20:
    if (DNBLogEnabledForAny(0x100000))
    {
      size_t v18 = *(pthread_mutex_t **)(a1 + 488);
      if (v18) {
        pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
      }
      gettimeofday(&v70, 0);
      int tv_sec = v70.tv_sec;
      __darwin_suseconds_t tv_usec = v70.tv_usec;
      uint64_t v21 = *(void *)(a1 + 496);
      int v22 = *(_DWORD *)(a1 + 504);
      *(timeval *)(a1 + 496) = v70;
      if (v18) {
        pthread_mutex_unlock(v18);
      }
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v23 = (const char *)a2;
      }
      else {
        long long v23 = (const char *)a2->__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded("%8u RNBRemote::%s tossing unexpected packet???? %s", tv_usec - v22 + 1000000 * (tv_sec - v21), "GetPacketPayload", v23);
    }
    if (!*(unsigned char *)(a1 + 781))
    {
LABEL_30:
      uint64_t v12 = 1;
      RNBSocket::Write((RNBSocket *)(a1 + 472), "-", 1uLL);
      return v12;
    }
    return 1;
  }
  if (v16 == 3) {
    return v12;
  }
  if (v16 != 36) {
    goto LABEL_20;
  }
  if (*(unsigned char *)(a1 + 781))
  {
    uint64_t v17 = 0;
    goto LABEL_47;
  }
  unint64_t size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  if (v13 < 0) {
    unint64_t size = a2->__r_.__value_.__l.__size_;
  }
  unint64_t v25 = size - 2;
  if (size < 2)
  {
LABEL_44:
    if (v13 >= 0) {
      size_t v14 = a2;
    }
    uint64_t v17 = strtol((const char *)v14 + v25, 0, 16);
LABEL_47:
    std::string::erase(a2, 0, 1uLL);
    std::string::size_type v30 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    if ((v30 & 0x80u) != 0) {
      std::string::size_type v30 = a2->__r_.__value_.__l.__size_;
    }
    std::string::erase(a2, v30 - 3, 0xFFFFFFFFFFFFFFFFLL);
    if (*(unsigned char *)(a1 + 781)) {
      return 0;
    }
    int v31 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
    BOOL v32 = v31 < 0;
    size_t v33 = (int8x8_t *)a2->__r_.__value_.__r.__words[0];
    if (v31 >= 0) {
      size_t v33 = (int8x8_t *)a2;
    }
    unint64_t v34 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    if (v32) {
      unint64_t v34 = a2->__r_.__value_.__l.__size_;
    }
    if (!v34)
    {
      unsigned int v35 = 0;
LABEL_80:
      if (v17 == v35)
      {
        RNBSocket::Write((RNBSocket *)(a1 + 472), "+", 1uLL);
        return 0;
      }
      if (DNBLogEnabledForAny(0x20000))
      {
        int v68 = DNBTimer::ElapsedMicroSeconds((pthread_mutex_t **)(a1 + 488), 1);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int64_t v69 = (const char *)a2;
        }
        else {
          int64_t v69 = (const char *)a2->__r_.__value_.__r.__words[0];
        }
        _DNBLogThreaded("%8u RNBRemote::%s sending ACK for '%s' (error: packet checksum mismatch  (0x%2.2lx != 0x%2.2x))", v68, "GetPacketPayload", v69, v17, v35);
      }
      goto LABEL_30;
    }
    if (v34 < 8)
    {
      unsigned int v35 = 0;
      __darwin_suseconds_t v36 = (char *)v33;
      goto LABEL_78;
    }
    if (v34 >= 0x20)
    {
      int32x4_t v44 = 0uLL;
      unint64_t v43 = v34 & 0xFFFFFFFFFFFFFFE0;
      int32x4_t v45 = 0uLL;
      uint64_t v46 = v33 + 2;
      unint64_t v47 = v34 & 0xFFFFFFFFFFFFFFE0;
      int32x4_t v48 = 0uLL;
      int32x4_t v49 = 0uLL;
      int32x4_t v50 = 0uLL;
      int32x4_t v51 = 0uLL;
      int32x4_t v52 = 0uLL;
      int32x4_t v53 = 0uLL;
      do
      {
        int8x16_t v54 = *(int8x16_t *)v46[-2].i8;
        int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
        int16x8_t v56 = vmovl_high_s8(v54);
        int16x8_t v57 = vmovl_s8(*v46);
        int16x8_t v58 = vmovl_high_s8(*(int8x16_t *)v46->i8);
        int32x4_t v49 = vaddw_high_s16(v49, v56);
        int32x4_t v48 = vaddw_s16(v48, *(int16x4_t *)v56.i8);
        int32x4_t v45 = vaddw_high_s16(v45, v55);
        int32x4_t v44 = vaddw_s16(v44, *(int16x4_t *)v55.i8);
        int32x4_t v53 = vaddw_high_s16(v53, v58);
        int32x4_t v52 = vaddw_s16(v52, *(int16x4_t *)v58.i8);
        int32x4_t v51 = vaddw_high_s16(v51, v57);
        int32x4_t v50 = vaddw_s16(v50, *(int16x4_t *)v57.i8);
        v46 += 4;
        v47 -= 32;
      }
      while (v47);
      unsigned int v35 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v50, v44), vaddq_s32(v52, v48)), vaddq_s32(vaddq_s32(v51, v45), vaddq_s32(v53, v49))));
      if (v34 == v43) {
        goto LABEL_80;
      }
      if ((v34 & 0x18) == 0)
      {
        __darwin_suseconds_t v36 = (char *)v33 + v43;
LABEL_78:
        int v65 = (char *)v33 + v34;
        do
        {
          int v66 = *v36++;
          v35 += v66;
        }
        while (v36 != v65);
        goto LABEL_80;
      }
    }
    else
    {
      unsigned int v35 = 0;
      unint64_t v43 = 0;
    }
    __darwin_suseconds_t v36 = (char *)v33 + (v34 & 0xFFFFFFFFFFFFFFF8);
    int32x4_t v59 = 0uLL;
    int32x4_t v60 = (int32x4_t)v35;
    char v61 = (int8x8_t *)((char *)v33 + v43);
    unint64_t v62 = v43 - (v34 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      int8x8_t v63 = *v61++;
      int16x8_t v64 = vmovl_s8(v63);
      int32x4_t v59 = vaddw_high_s16(v59, v64);
      int32x4_t v60 = vaddw_s16(v60, *(int16x4_t *)v64.i8);
      v62 += 8;
    }
    while (v62);
    unsigned int v35 = vaddvq_s32(vaddq_s32(v60, v59));
    if (v34 == (v34 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_80;
    }
    goto LABEL_78;
  }
  unsigned int v26 = v13 >> 31;
  while (1)
  {
    BOOL v27 = (v26 & 1) != 0 ? (char *)a2->__r_.__value_.__r.__words[0] : (char *)a2;
    unsigned __int8 v28 = __tolower(v27[v25]);
    if ((v28 & 0x80) != 0 || (_DefaultRuneLocale.__runetype[v28] & 0x10000) == 0) {
      break;
    }
    ++v25;
    int v13 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
    unsigned int v26 = v13 >> 31;
    unint64_t v29 = a2->__r_.__value_.__l.__size_;
    if (v13 >= 0) {
      unint64_t v29 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    }
    if (v25 >= v29)
    {
      size_t v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
      unint64_t v25 = v29 - 2;
      goto LABEL_44;
    }
  }
  uint64_t v12 = 1;
  RNBSocket::Write((RNBSocket *)(a1 + 472), "-", 1uLL);
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v37 = *(pthread_mutex_t **)(a1 + 488);
    if (v37) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday(&v70, 0);
    int v38 = v70.tv_sec;
    __darwin_suseconds_t v39 = v70.tv_usec;
    uint64_t v40 = *(void *)(a1 + 496);
    int v41 = *(_DWORD *)(a1 + 504);
    *(timeval *)(a1 + 496) = v70;
    if (v37) {
      pthread_mutex_unlock(v37);
    }
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v42 = (const char *)a2;
    }
    else {
      unint64_t v42 = (const char *)a2->__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("%8u RNBRemote::%s error: packet with invalid checksum characters: %s", v39 - v41 + 1000000 * (v38 - v40), "GetPacketPayload", v42);
    return 1;
  }
  return v12;
}

uint64_t RNBRemote::HandlePacket_UNIMPLEMENTED(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x40000))
  {
    size_t v4 = (pthread_mutex_t *)*((void *)this + 61);
    if (v4) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v12, 0);
    int tv_sec = v12.tv_sec;
    __darwin_suseconds_t tv_usec = v12.tv_usec;
    uint64_t v7 = *((void *)this + 62);
    int v8 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v12;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    unint64_t v9 = "NULL";
    if (a2) {
      unint64_t v9 = a2;
    }
    _DNBLogThreaded("%8u RNBRemote::%s(\"%s\")", tv_usec - v8 + 1000000 * (tv_sec - v7), "HandlePacket_UNIMPLEMENTED", v9);
  }
  char v13 = 0;
  LOBYTE(v12.tv_sec) = 0;
  uint64_t v10 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v12);
  if (v13 < 0) {
    operator delete((void *)v12.tv_sec);
  }
  return v10;
}

uint64_t RNBRemote::HandlePacket_ILLFORMED(RNBRemote *this, const char *a2, int a3, const char *a4, const char *a5)
{
  if (DNBLogEnabledForAny(0x800000))
  {
    unint64_t v9 = (pthread_mutex_t *)*((void *)this + 61);
    if (v9) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v16, 0);
    int tv_sec = v16.tv_sec;
    __darwin_suseconds_t tv_usec = v16.tv_usec;
    uint64_t v12 = *((void *)this + 62);
    int v13 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v16;
    if (v9) {
      pthread_mutex_unlock(v9);
    }
    _DNBLogThreaded("%8u %s:%i ILLFORMED: '%s' (%s)", tv_usec - v13 + 1000000 * (tv_sec - v12), a2, a3, "HandlePacket_ILLFORMED", a4);
  }
  char v17 = 3;
  LODWORD(v16.tv_sec) = 3354693;
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&v16);
  if (v17 < 0) {
    operator delete((void *)v16.tv_sec);
  }
  return v14;
}

uint64_t RNBRemote::HandleAsyncPacket(uint64_t a1, _DWORD *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    size_t v4 = *(pthread_mutex_t **)(a1 + 488);
    if (v4) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday((timeval *)v19, 0);
    int v5 = *(_DWORD *)v19;
    int v6 = *(_DWORD *)&v19[8];
    uint64_t v7 = *(void *)(a1 + 496);
    int v8 = *(_DWORD *)(a1 + 504);
    *(_OWORD *)(a1 + 496) = *(_OWORD *)v19;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    _DNBLogThreaded("%8u RNBRemote::%s", v6 - v8 + 1000000 * (v5 - v7), "HandleAsyncPacket");
  }
  {
    DNBTimer::DNBTimer((DNBTimer *)&RNBRemote::HandleAsyncPacket(RNBRemote::PacketEnum *)::g_packetTimer, 1);
    __cxa_atexit((void (*)(void *))DNBTimer::~DNBTimer, &RNBRemote::HandleAsyncPacket(RNBRemote::PacketEnum *)::g_packetTimer, (void *)&_mh_execute_header);
  }
  memset(&v24, 0, sizeof(v24));
  *(_DWORD *)uint64_t v19 = 0;
  *(_OWORD *)&v19[8] = 0u;
  long long v20 = 0u;
  *(_OWORD *)uint64_t v21 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v23 = 0u;
  uint64_t Packet = RNBRemote::GetPacket(a1, &v24, (uint64_t)v19, 0);
  if (!Packet)
  {
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!v24.__r_.__value_.__l.__size_) {
        goto LABEL_23;
      }
      __darwin_ct_rune_t v11 = *v24.__r_.__value_.__l.__data_;
      if ((v11 & 0x80000000) == 0)
      {
LABEL_16:
        if ((_DefaultRuneLocale.__runetype[v11] & 0x40000) == 0)
        {
LABEL_23:
          if (DNBLogEnabledForAny(9437184)) {
            _DNBLogThreaded("HandleAsyncPacket (%s);");
          }
          goto LABEL_25;
        }
LABEL_21:
        if (DNBLogEnabledForAny(9437184)) {
          _DNBLogThreaded("HandleAsyncPacket (\"%s\");");
        }
LABEL_25:
        uint64_t v13 = *((void *)&v20 + 1);
        uint64_t v12 = (uint64_t (*)(void *, std::string *))v20;
        uint64_t v14 = BYTE8(v20) & 1;
        if (*((void *)&v20 + 1)) {
          BOOL v15 = (BYTE8(v20) & 1 | (unint64_t)v20) == 0;
        }
        else {
          BOOL v15 = 1;
        }
        int v16 = !v15;
        if ((void)v20 || v16)
        {
          if (a2) {
            *a2 = *(_DWORD *)v19;
          }
          char v17 = (void *)(a1 + (v13 >> 1));
          if (v14) {
            uint64_t v12 = *(uint64_t (**)(void *, std::string *))(*v17 + v12);
          }
          if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v18 = &v24;
          }
          else {
            size_t v18 = (std::string *)v24.__r_.__value_.__r.__words[0];
          }
          uint64_t Packet = v12(v17, v18);
          if (SHIBYTE(v23) < 0) {
            goto LABEL_43;
          }
        }
        else
        {
          uint64_t Packet = 0;
          if (SHIBYTE(v23) < 0) {
            goto LABEL_43;
          }
        }
LABEL_10:
        if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
          goto LABEL_11;
        }
LABEL_44:
        operator delete(v21[0]);
        if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return Packet;
        }
LABEL_45:
        operator delete(v24.__r_.__value_.__l.__data_);
        return Packet;
      }
    }
    else
    {
      if (!*((unsigned char *)&v24.__r_.__value_.__s + 23)) {
        goto LABEL_23;
      }
      __darwin_ct_rune_t v11 = v24.__r_.__value_.__s.__data_[0];
      if ((v24.__r_.__value_.__s.__data_[0] & 0x80000000) == 0) {
        goto LABEL_16;
      }
    }
    if (!__maskrune(v11, 0x40000uLL)) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if ((SHIBYTE(v23) & 0x80000000) == 0) {
    goto LABEL_10;
  }
LABEL_43:
  operator delete(__p[1]);
  if (SHIBYTE(__p[0]) < 0) {
    goto LABEL_44;
  }
LABEL_11:
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_45;
  }
  return Packet;
}

void DNBTimer::~DNBTimer(pthread_mutex_t **this)
{
  int v1 = *this;
  *this = 0;
  if (v1)
  {
    if (pthread_mutex_destroy(v1))
    {
      if (!pthread_mutex_unlock(v1)) {
        pthread_mutex_destroy(v1);
      }
    }
    operator delete();
  }
}

uint64_t RNBRemote::HandleReceivedPacket(uint64_t a1, _DWORD *a2)
{
  {
    DNBTimer::DNBTimer((DNBTimer *)&RNBRemote::HandleReceivedPacket(RNBRemote::PacketEnum *)::g_packetTimer, 1);
    __cxa_atexit((void (*)(void *))DNBTimer::~DNBTimer, &RNBRemote::HandleReceivedPacket(RNBRemote::PacketEnum *)::g_packetTimer, (void *)&_mh_execute_header);
  }
  memset(&v20, 0, sizeof(v20));
  int v14 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)char v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v19 = 0u;
  if (RNBRemote::GetPacket(a1, &v20, (uint64_t)&v14, 0))
  {
    uint64_t v4 = 1;
    if ((SHIBYTE(v19) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (DNBLogEnabledForAny(0x100000))
  {
    int v5 = &v20;
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v5 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("HandleReceivedPacket (\"%s\");", (const char *)v5);
  }
  uint64_t v7 = *((void *)&v15 + 1);
  int v6 = (uint64_t (*)(void *, std::string *))v15;
  uint64_t v8 = BYTE8(v15) & 1;
  if (*((void *)&v15 + 1)) {
    BOOL v9 = (BYTE8(v15) & 1 | (unint64_t)v15) == 0;
  }
  else {
    BOOL v9 = 1;
  }
  int v10 = !v9;
  if (!(void)v15 && !v10)
  {
    uint64_t v4 = 0;
    if ((SHIBYTE(v19) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (a2) {
    *a2 = v14;
  }
  __darwin_ct_rune_t v11 = (void *)(a1 + (v7 >> 1));
  if (v8) {
    int v6 = *(uint64_t (**)(void *, std::string *))(*v11 + v6);
  }
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v12 = &v20;
  }
  else {
    uint64_t v12 = (std::string *)v20.__r_.__value_.__r.__words[0];
  }
  uint64_t v4 = v6(v11, v12);
  if (SHIBYTE(v19) < 0) {
LABEL_27:
  }
    operator delete(__p[1]);
LABEL_28:
  if (SHIBYTE(__p[0]) < 0)
  {
    operator delete(v17[0]);
    if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v4;
    }
LABEL_32:
    operator delete(v20.__r_.__value_.__l.__data_);
    return v4;
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
  return v4;
}

pthread_mutex_t *RNBRemote::CommDataReceived(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
  memset(&v53, 0, sizeof(v53));
  if (*(char *)(a1 + 767) < 0)
  {
    int v5 = (std::string *)(a1 + 744);
    if (!*(void *)(a1 + 752)) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  int v5 = (std::string *)(a1 + 744);
  if (*(unsigned char *)(a1 + 767))
  {
LABEL_3:
    std::string v53 = *v5;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
  }
LABEL_4:
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v7 = *(const std::string::value_type **)a2;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a2 + 8);
  }
  std::string::append(&v53, v7, v8);
  char v9 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v53.__r_.__value_.__l.__size_;
  }
  if (!size) {
    goto LABEL_96;
  }
  int32x4_t v48 = v5;
  int32x4_t v49 = v4;
  std::string::size_type v11 = 0;
  int32x4_t v50 = (timeval *)(a1 + 496);
  while (1)
  {
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v14 = &v53;
    }
    else {
      int v14 = (std::string *)v53.__r_.__value_.__r.__words[0];
    }
    int v15 = v14->__r_.__value_.__s.__data_[v11];
    if (v15 > 42)
    {
      if (v15 != 45)
      {
        std::string::size_type v16 = v11;
        if (v15 != 43) {
          goto LABEL_34;
        }
      }
      goto LABEL_33;
    }
    if (v15 != 3) {
      break;
    }
LABEL_33:
    std::string::size_type v16 = v11 + 1;
    if (v11 == -2) {
      goto LABEL_74;
    }
LABEL_34:
    if (v16 <= v11)
    {
      if (DNBLogEnabledForAny(0x40000))
      {
        int v22 = *(pthread_mutex_t **)(a1 + 488);
        if (v22) {
          pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
        }
        gettimeofday(&__dst, 0);
        int tv_sec = __dst.tv_sec;
        __darwin_suseconds_t tv_usec = __dst.tv_usec;
        uint64_t v25 = *(void *)(a1 + 496);
        int v26 = *(_DWORD *)(a1 + 504);
        *int32x4_t v50 = __dst;
        if (v22) {
          pthread_mutex_unlock(v22);
        }
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v12 = &v53;
        }
        else {
          uint64_t v12 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        _DNBLogThreaded("%8d RNBRemote::%s tossing junk byte at %c", tv_usec - v26 + 1000000 * (tv_sec - v25), "CommDataReceived", v12->__r_.__value_.__s.__data_[v11]);
      }
      std::string::size_type v13 = v11 + 1;
      goto LABEL_20;
    }
    int v18 = *(_DWORD *)(a1 + 668);
    *(_DWORD *)(a1 + 668) = v18 + 1;
    std::string::size_type v13 = v11 + 1;
    std::string::size_type v19 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
    if (v16 != v11 + 1
      || v18
      || ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (std::string v20 = &v53)
        : (std::string v20 = (std::string *)v53.__r_.__value_.__r.__words[0]),
          v20->__r_.__value_.__s.__data_[v11] != 43))
    {
      if ((*((unsigned char *)&v53.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        std::string::size_type v19 = v53.__r_.__value_.__l.__size_;
        if (v53.__r_.__value_.__l.__size_ < v11) {
          goto LABEL_101;
        }
        uint64_t v21 = (std::string *)v53.__r_.__value_.__r.__words[0];
      }
      else
      {
        if (v11 > HIBYTE(v53.__r_.__value_.__r.__words[2])) {
          goto LABEL_101;
        }
        uint64_t v21 = &v53;
      }
      size_t v27 = v19 - v11;
      if (v27 >= v16 - v11) {
        size_t v28 = v16 - v11;
      }
      else {
        size_t v28 = v27;
      }
      if (v28 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_101;
      }
      if (v28 >= 0x17)
      {
        uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v28 | 7) != 0x17) {
          uint64_t v30 = v28 | 7;
        }
        uint64_t v31 = v30 + 1;
        p_dst = operator new(v30 + 1);
        *(void *)&__dst.__darwin_suseconds_t tv_usec = v28;
        int64_t v52 = v31 | 0x8000000000000000;
        __dst.int tv_sec = (__darwin_time_t)p_dst;
      }
      else
      {
        HIBYTE(v52) = v28;
        p_dst = &__dst;
        if (!v28) {
          goto LABEL_62;
        }
      }
      memmove(p_dst, (char *)v21 + v11, v28);
LABEL_62:
      *((unsigned char *)p_dst + v28) = 0;
      uint64_t v32 = *(void *)(a1 + 704);
      if (*(void *)(a1 + 712) == v32) {
        uint64_t v33 = 0;
      }
      else {
        uint64_t v33 = 170 * ((*(void *)(a1 + 712) - v32) >> 3) - 1;
      }
      unint64_t v34 = *(void *)(a1 + 736) + *(void *)(a1 + 728);
      if (v33 == v34)
      {
        std::deque<std::string>::__add_back_capacity(a1 + 696);
        uint64_t v32 = *(void *)(a1 + 704);
        unint64_t v34 = *(void *)(a1 + 736) + *(void *)(a1 + 728);
      }
      unsigned int v35 = (timeval *)(*(void *)(v32 + 8 * (v34 / 0xAA)) + 24 * (v34 % 0xAA));
      *unsigned int v35 = __dst;
      v35[1].int tv_sec = v52;
      ++*(void *)(a1 + 736);
      if (DNBLogEnabledForAny(0x800000))
      {
        unint64_t v36 = *(void *)(a1 + 736) + *(void *)(a1 + 728) - 1;
        unint64_t v37 = *(void *)(*(void *)(a1 + 704) + 8 * (v36 / 0xAA)) + 24 * (v36 % 0xAA);
        if (*(char *)(v37 + 23) < 0) {
          unint64_t v37 = *(void *)v37;
        }
        _DNBLogThreaded("getpkt: %s", (const char *)v37);
      }
      std::string::size_type v13 = v16;
    }
LABEL_20:
    std::string::size_type v11 = v13;
    if (v13 >= size) {
      goto LABEL_95;
    }
  }
  std::string::size_type v16 = v11;
  if (v15 != 36) {
    goto LABEL_34;
  }
  std::string::size_type v17 = std::string::find(&v53, 35, v11 + 1);
  if (v17 != -1)
  {
    std::string::size_type v16 = v17 + 3;
    if (v17 + 3 <= size && v17 != -4) {
      goto LABEL_34;
    }
  }
LABEL_74:
  if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type v38 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
    __darwin_suseconds_t v39 = v48;
    if (v11 <= HIBYTE(v53.__r_.__value_.__r.__words[2]))
    {
      uint64_t v40 = &v53;
      goto LABEL_79;
    }
    goto LABEL_101;
  }
  std::string::size_type v38 = v53.__r_.__value_.__l.__size_;
  __darwin_suseconds_t v39 = v48;
  if (v53.__r_.__value_.__l.__size_ < v11) {
    goto LABEL_101;
  }
  uint64_t v40 = (std::string *)v53.__r_.__value_.__r.__words[0];
LABEL_79:
  size_t v41 = v38 - v11;
  if (v38 - v11 > 0x7FFFFFFFFFFFFFF7) {
LABEL_101:
  }
    abort();
  if (v41 >= 0x17)
  {
    uint64_t v43 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v41 | 7) != 0x17) {
      uint64_t v43 = v41 | 7;
    }
    uint64_t v44 = v43 + 1;
    unint64_t v42 = operator new(v43 + 1);
    *(void *)&__dst.__darwin_suseconds_t tv_usec = v41;
    int64_t v52 = v44 | 0x8000000000000000;
    __dst.int tv_sec = (__darwin_time_t)v42;
    goto LABEL_86;
  }
  HIBYTE(v52) = v38 - v11;
  unint64_t v42 = &__dst;
  if (v38 != v11) {
LABEL_86:
  }
    memmove(v42, (char *)v40 + v11, v41);
  *((unsigned char *)v42 + v41) = 0;
  if (v52 >= 0) {
    int32x4_t v45 = (const std::string::value_type *)&__dst;
  }
  else {
    int32x4_t v45 = (const std::string::value_type *)__dst.tv_sec;
  }
  if (v52 >= 0) {
    std::string::size_type v46 = HIBYTE(v52);
  }
  else {
    std::string::size_type v46 = *(void *)&__dst.tv_usec;
  }
  std::string::append(v39, v45, v46);
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)__dst.tv_sec);
  }
LABEL_95:
  char v9 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  uint64_t v4 = v49;
LABEL_96:
  if (v9 < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  uint64_t result = (pthread_mutex_t *)pthread_mutex_unlock(v4);
  if (*(void *)(a1 + 736)) {
    return PThreadEvent::SetEvents((pthread_mutex_t *)(a1 + 120), 32);
  }
  return result;
}

uint64_t RNBRemote::StartReadRemoteDataThread(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v2 = (pthread_mutex_t *)*((void *)this + 61);
    if (v2) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v8, 0);
    int tv_sec = v8.tv_sec;
    __darwin_suseconds_t tv_usec = v8.tv_usec;
    uint64_t v5 = *((void *)this + 62);
    int v6 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v8;
    if (v2) {
      pthread_mutex_unlock(v2);
    }
    _DNBLogThreaded("%8u RNBRemote::%s called", tv_usec - v6 + 1000000 * (tv_sec - v5), "StartReadRemoteDataThread");
  }
  uint64_t result = PThreadEvent::GetEventBits((pthread_mutex_t *)((char *)this + 120));
  if ((result & 0x40) == 0)
  {
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 120), 128);
    if (pthread_create((pthread_t *)this + 96, 0, (void *(__cdecl *)(void *))RNBRemote::ThreadFunctionReadRemoteData, this))
    {
      PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 120), 64);
      return (uint64_t)PThreadEvent::SetEvents((pthread_mutex_t *)((char *)this + 120), 128);
    }
    else
    {
      return PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 120), 0x40u, 0);
    }
  }
  return result;
}

uint64_t RNBRemote::ThreadFunctionReadRemoteData(RNBRemote *this, void *a2)
{
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("RNBRemote::%s (%p): thread starting...", "ThreadFunctionReadRemoteData", this);
  }
  uint64_t v4 = g_remoteSP;
  uint64_t v3 = (std::__shared_weak_count *)qword_1000796A0;
  if (qword_1000796A0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1000796A0 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    pthread_setname_np("read gdb-remote packets thread");
    int v11 = 0;
    uint64_t v5 = pthread_self();
    if (!pthread_getschedparam(v5, &v11, &v12))
    {
      v12.sched_priority = 47;
      int v6 = pthread_self();
      pthread_setschedparam(v6, v11, &v12);
    }
    PThreadEvent::SetEvents((pthread_mutex_t *)(v4 + 120), 64);
    while (1)
    {
      std::string __p = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      int v7 = RNBSocket::Read((int *)(v4 + 472), (uint64_t)&__p);
      uint64_t v8 = HIBYTE(v15);
      char v9 = HIBYTE(v15);
      if (!v7)
      {
        if (v15 < 0) {
          uint64_t v8 = v14;
        }
        if (v8)
        {
          RNBRemote::CommDataReceived(v4, (uint64_t)&__p);
          char v9 = HIBYTE(v15);
        }
      }
      if (v9 < 0) {
        operator delete(__p);
      }
      if (v7 == 2) {
        break;
      }
      if (v7 == 1)
      {
        if (DNBLogEnabledForAny(0x100000)) {
          _DNBLogThreaded("RNBSocket::GetCommData returned error %u");
        }
        goto LABEL_22;
      }
    }
    if (DNBLogEnabledForAny(0x100000)) {
      _DNBLogThreaded("RNBSocket::GetCommData returned not connected...");
    }
LABEL_22:
    PThreadEvent::ResetEvents((pthread_mutex_t *)(v4 + 120), 64);
    PThreadEvent::SetEvents((pthread_mutex_t *)(v4 + 120), 128);
  }
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("RNBRemote::%s (%p): thread exiting...", "ThreadFunctionReadRemoteData", this);
  }
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return 0;
}

void decode_binary_data(const char *__s@<X0>, size_t a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2)
  {
    size_t v3 = a2;
    uint64_t v4 = __s;
    if (a2 != -1 || (size_t v3 = strlen(__s)) != 0)
    {
      int v6 = 0;
      while (1)
      {
        uint64_t v8 = v4;
        size_t v9 = v3;
        int v11 = *(unsigned __int8 *)v4++;
        int v10 = v11;
        if (--v3 && v10 == 125)
        {
          size_t v3 = v9 - 2;
          uint64_t v4 = v8 + 2;
          LOBYTE(v10) = v8[1] ^ 0x20;
        }
        unint64_t v12 = a3[2];
        if ((unint64_t)v6 >= v12) {
          break;
        }
        *int v6 = v10;
        uint64_t v7 = (uint64_t)(v6 + 1);
LABEL_6:
        a3[1] = v7;
        int v6 = (unsigned char *)v7;
        if (!v3) {
          return;
        }
      }
      unint64_t v13 = *a3;
      unint64_t v14 = (unint64_t)&v6[-*a3];
      unint64_t v15 = v14 + 1;
      if ((uint64_t)(v14 + 1) < 0) {
        abort();
      }
      unint64_t v16 = v12 - v13;
      if (2 * v16 > v15) {
        unint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v15;
      }
      if (v17) {
        int v18 = operator new(v17);
      }
      else {
        int v18 = 0;
      }
      std::string::size_type v19 = (char *)v18 + v14;
      *((unsigned char *)v18 + v14) = v10;
      uint64_t v7 = (uint64_t)v18 + v14 + 1;
      if (v6 == (unsigned char *)v13)
      {
LABEL_29:
        *a3 = (unint64_t)v19;
        a3[1] = v7;
        a3[2] = (unint64_t)v18 + v17;
        if (v6) {
          operator delete(v6);
        }
        goto LABEL_6;
      }
      if (v14 < 8
        || (char *)v18 + v14 - 1 - &v6[~v13] > (unint64_t)v18 + v14 - 1
        || v13 > (unint64_t)(v6 - 1)
        || v13 - (unint64_t)v18 < 0x20)
      {
        std::string v20 = v6;
        goto LABEL_26;
      }
      if (v14 >= 0x20)
      {
        unint64_t v23 = v14 & 0xFFFFFFFFFFFFFFE0;
        std::string v24 = (char *)v18 + v14 - 16;
        uint64_t v25 = (long long *)(v6 - 16);
        unint64_t v26 = v14 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v27 = *v25;
          *(v24 - 1) = *(v25 - 1);
          _OWORD *v24 = v27;
          v24 -= 2;
          v25 -= 2;
          v26 -= 32;
        }
        while (v26);
        if (v14 == v23) {
          goto LABEL_28;
        }
        if ((v14 & 0x18) == 0)
        {
          v19 -= v23;
          std::string v20 = &v6[-v23];
LABEL_26:
          uint64_t v21 = v19 - 1;
          do
          {
            char v22 = *--v20;
            *v21-- = v22;
          }
          while (v20 != (unsigned char *)v13);
LABEL_28:
          int v6 = (unsigned char *)*a3;
          std::string::size_type v19 = (char *)v18;
          goto LABEL_29;
        }
      }
      else
      {
        unint64_t v23 = 0;
      }
      std::string v20 = &v6[-(v14 & 0xFFFFFFFFFFFFFFF8)];
      v19 -= v14 & 0xFFFFFFFFFFFFFFF8;
      size_t v28 = &v6[-v23 - v13 - 8 + (void)v18];
      unint64_t v29 = (uint64_t *)&v6[-v23 - 8];
      unint64_t v30 = v23 - (v14 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v31 = *v29--;
        *v28-- = v31;
        v30 += 8;
      }
      while (v30);
      if (v14 == (v14 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      goto LABEL_26;
    }
  }
}

void std::vector<unsigned char>::push_back[abi:nn180100](void *a1, char *a2)
{
  uint64_t v5 = (char *)a1[1];
  unint64_t v4 = a1[2];
  int v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *uint64_t v5 = *a2;
    uint64_t v7 = (uint64_t)(v5 + 1);
    goto LABEL_32;
  }
  uint64_t v8 = (char *)*a1;
  unint64_t v9 = (unint64_t)&v5[-*a1];
  unint64_t v10 = v9 + 1;
  if ((uint64_t)(v9 + 1) < 0) {
    abort();
  }
  unint64_t v11 = v4 - (void)v8;
  if (2 * v11 > v10) {
    unint64_t v10 = 2 * v11;
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v12 = v10;
  }
  if (v12) {
    unint64_t v13 = operator new(v12);
  }
  else {
    unint64_t v13 = 0;
  }
  unint64_t v14 = &v13[v9];
  unint64_t v15 = &v13[v12];
  v13[v9] = *a2;
  uint64_t v7 = (uint64_t)&v13[v9 + 1];
  if (v5 == v8)
  {
    v13 += v9;
    goto LABEL_30;
  }
  if (v9 >= 8 && (unint64_t)(v8 - v13) >= 0x20)
  {
    if (v9 < 0x20)
    {
      unint64_t v16 = 0;
      goto LABEL_22;
    }
    unint64_t v16 = v9 & 0xFFFFFFFFFFFFFFE0;
    size_t v17 = (long long *)(v5 - 16);
    int v18 = &v13[v5 - 16 - v8];
    unint64_t v19 = v9 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v20 = *v17;
      *(v18 - 1) = *(v17 - 1);
      _OWORD *v18 = v20;
      v18 -= 2;
      v17 -= 2;
      v19 -= 32;
    }
    while (v19);
    if (v9 == v16) {
      goto LABEL_29;
    }
    if ((v9 & 0x18) != 0)
    {
LABEL_22:
      int v6 = &v5[-(v9 & 0xFFFFFFFFFFFFFFF8)];
      v14 -= v9 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v21 = &v5[-v16 - 8];
      char v22 = &v13[v21 - v8];
      unint64_t v23 = v16 - (v9 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v24 = *(void *)v21;
        v21 -= 8;
        *v22-- = v24;
        v23 += 8;
      }
      while (v23);
      if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_29;
      }
      goto LABEL_27;
    }
    v14 -= v16;
    int v6 = &v5[-v16];
  }
LABEL_27:
  uint64_t v25 = v14 - 1;
  do
  {
    char v26 = *--v6;
    *v25-- = v26;
  }
  while (v6 != v8);
LABEL_29:
  int v6 = (char *)*a1;
LABEL_30:
  *a1 = v13;
  a1[1] = v7;
  a1[2] = v15;
  if (v6) {
    operator delete(v6);
  }
LABEL_32:
  a1[1] = v7;
}

void json_string_quote_metachars(const std::string *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v2 = a1;
  if (std::string::find(a1, 34, 0) == -1)
  {
    if (SHIBYTE(v2->__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v8 = (const std::string::value_type *)v2->__r_.__value_.__r.__words[0];
      std::string::size_type size = v2->__r_.__value_.__l.__size_;
      std::string::__init_copy_ctor_external(a2, v8, size);
    }
    else
    {
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
      a2->__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
    }
  }
  else
  {
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    int v4 = SHIBYTE(v2->__r_.__value_.__r.__words[2]);
    if (v4 >= 0) {
      std::string::size_type v5 = HIBYTE(v2->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v5 = v2->__r_.__value_.__l.__size_;
    }
    if (v4 < 0) {
      uint64_t v2 = (const std::string *)v2->__r_.__value_.__r.__words[0];
    }
    for (; v5; --v5)
    {
      int v7 = v2->__r_.__value_.__s.__data_[0];
      uint64_t v2 = (const std::string *)((char *)v2 + 1);
      std::string::value_type v6 = v7;
      if (v7 == 34) {
        std::string::push_back(a2, 92);
      }
      std::string::push_back(a2, v6);
    }
  }
}

void **std::vector<register_map_entry>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    size_t v3 = (char *)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        std::string::size_type v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }
        std::string::value_type v6 = (void *)*((void *)v3 - 6);
        if (v6)
        {
          *((void *)v3 - 5) = v6;
          operator delete(v6);
        }
        v3 -= 128;
      }
      while (v3 != v2);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

BOOL RNBRemote::InitializeRegisters(RNBRemote *this, int a2)
{
  int v2 = *((_DWORD *)this + 3);
  if (v2)
  {
    int v106 = *((_DWORD *)this + 3);
    if (DNBLogEnabledForAny(0x400000)) {
      _DNBLogThreaded("RNBRemote::%s() getting native registers from DNB interface", "InitializeRegisters");
    }
    uint64_t v4 = g_dynamic_register_map;
    uint64_t v5 = qword_100079828;
    if (a2)
    {
      uint64_t v6 = g_dynamic_register_map;
      if (qword_100079828 != g_dynamic_register_map)
      {
        do
        {
          int v7 = *(void **)(v5 - 24);
          if (v7)
          {
            *(void *)(v5 - 16) = v7;
            operator delete(v7);
          }
          uint64_t v8 = *(void **)(v5 - 48);
          if (v8)
          {
            *(void *)(v5 - 40) = v8;
            operator delete(v8);
          }
          v5 -= 128;
        }
        while (v5 != v4);
        uint64_t v6 = g_dynamic_register_map;
      }
      qword_100079828 = v4;
      g_reg_entries = 0;
      g_num_reg_entries = 0;
      uint64_t v5 = v4;
      uint64_t v4 = v6;
    }
    int v2 = v106;
    if (v4 == v5)
    {
      unint64_t v120 = 0;
      uint64_t v9 = DNBGetRegisterSetInfo(&v120);
      unint64_t v10 = v120;
      if (!v120 || !v9) {
        RNBRemote::InitializeRegisters();
      }
      int v11 = 0;
      unint64_t v12 = 0;
      int v110 = 0;
      v119[0] = 0;
      v119[1] = 0;
      int v118 = v119;
      uint64_t v107 = v9;
      do
      {
        uint64_t v13 = v9 + 24 * v12;
        uint64_t v15 = *(void *)(v13 + 8);
        unint64_t v14 = (void *)(v13 + 8);
        if (v15)
        {
          uint64_t v109 = (unint64_t *)(v9 + 24 * v12 + 16);
          if (*v109)
          {
            unint64_t v108 = v12;
            unint64_t v16 = 0;
            unsigned int v17 = 1;
            while (1)
            {
              *(_DWORD *)BOOL v114 = v110 + v17 - 1;
              *(_DWORD *)&v114[4] = v11;
              uint64_t v18 = *v14 + 72 * v16;
              *(_OWORD *)&v114[8] = *(_OWORD *)v18;
              long long v19 = *(_OWORD *)(v18 + 16);
              long long v20 = *(_OWORD *)(v18 + 32);
              long long v21 = *(_OWORD *)(v18 + 48);
              *(void *)&v114[72] = *(void *)(v18 + 64);
              *(_OWORD *)&v114[40] = v20;
              *(_OWORD *)&v114[56] = v21;
              *(_OWORD *)&v114[24] = v19;
              long long v115 = 0u;
              long long v116 = 0u;
              long long v117 = 0u;
              char v22 = *(const void **)&v114[16];
              size_t v23 = strlen(*(const char **)&v114[16]);
              if (v23 > 0x7FFFFFFFFFFFFFF7) {
LABEL_144:
              }
                abort();
              uint64_t v24 = (const void *)v23;
              if (v23 >= 0x17)
              {
                uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v23 | 7) != 0x17) {
                  uint64_t v26 = v23 | 7;
                }
                uint64_t v27 = v26 + 1;
                uint64_t v25 = (const void **)operator new(v26 + 1);
                __dst[1] = v24;
                unint64_t v113 = v27 | 0x8000000000000000;
                __dst[0] = v25;
              }
              else
              {
                HIBYTE(v113) = v23;
                uint64_t v25 = __dst;
                if (!v23) {
                  goto LABEL_32;
                }
              }
              memmove(v25, v22, (size_t)v24);
LABEL_32:
              *((unsigned char *)v24 + (void)v25) = 0;
              BOOL v121 = __dst;
              *((_DWORD *)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v118, __dst, (uint64_t)&std::piecewise_construct, (_OWORD **)&v121)+ 14) = v110 + v17 - 1;
              if (SHIBYTE(v113) < 0) {
                operator delete((void *)__dst[0]);
              }
              if (*(void *)&v114[64]) {
                int v28 = 0;
              }
              else {
                int v28 = *(_DWORD *)&v114[36];
              }
              uint64_t v29 = qword_100079828;
              if ((unint64_t)qword_100079828 >= unk_100079830)
              {
                uint64_t v41 = std::vector<register_map_entry>::__push_back_slow_path<register_map_entry const&>(&g_dynamic_register_map, (uint64_t)v114);
              }
              else
              {
                *(_OWORD *)qword_100079828 = *(_OWORD *)v114;
                long long v30 = *(_OWORD *)&v114[16];
                long long v31 = *(_OWORD *)&v114[32];
                long long v32 = *(_OWORD *)&v114[64];
                *(_OWORD *)(v29 + 48) = *(_OWORD *)&v114[48];
                *(_OWORD *)(v29 + 64) = v32;
                *(_OWORD *)(v29 + 16) = v30;
                *(_OWORD *)(v29 + 32) = v31;
                *(void *)(v29 + 88) = 0;
                *(void *)(v29 + 96) = 0;
                *(void *)(v29 + 80) = 0;
                uint64_t v33 = (const void *)v115;
                int64_t v34 = *((void *)&v115 + 1) - v115;
                if (*((void *)&v115 + 1) != (void)v115)
                {
                  if (v34 < 0) {
                    goto LABEL_144;
                  }
                  unsigned int v35 = (char *)operator new(*((void *)&v115 + 1) - v115);
                  *(void *)(v29 + 80) = v35;
                  *(void *)(v29 + 88) = v35;
                  unint64_t v36 = &v35[4 * (v34 >> 2)];
                  *(void *)(v29 + 96) = v36;
                  memcpy(v35, v33, v34);
                  *(void *)(v29 + 88) = v36;
                }
                *(void *)(v29 + 104) = 0;
                *(void *)(v29 + 112) = 0;
                *(void *)(v29 + 120) = 0;
                unint64_t v37 = (const void *)*((void *)&v116 + 1);
                int64_t v38 = v117 - *((void *)&v116 + 1);
                if ((void)v117 != *((void *)&v116 + 1))
                {
                  if (v38 < 0) {
                    goto LABEL_144;
                  }
                  __darwin_suseconds_t v39 = (char *)operator new(v117 - *((void *)&v116 + 1));
                  *(void *)(v29 + 104) = v39;
                  *(void *)(v29 + 112) = v39;
                  uint64_t v40 = &v39[4 * (v38 >> 2)];
                  *(void *)(v29 + 120) = v40;
                  memcpy(v39, v37, v38);
                  *(void *)(v29 + 112) = v40;
                }
                uint64_t v41 = v29 + 128;
              }
              qword_100079828 = v41;
              if (*((void *)&v116 + 1))
              {
                *(void *)&long long v117 = *((void *)&v116 + 1);
                operator delete(*((void **)&v116 + 1));
              }
              if ((void)v115)
              {
                *((void *)&v115 + 1) = v115;
                operator delete((void *)v115);
              }
              v11 += v28;
              unint64_t v16 = v17++;
              if (*v109 <= v16)
              {
                unint64_t v10 = v120;
                int v110 = v110 + v17 - 1;
                uint64_t v9 = v107;
                unint64_t v12 = v108;
                break;
              }
            }
          }
        }
        ++v12;
      }
      while (v12 < v10);
      uint64_t v42 = g_dynamic_register_map;
      uint64_t v111 = qword_100079828;
      if (g_dynamic_register_map != qword_100079828)
      {
LABEL_53:
        uint64_t v43 = *(const char ***)(v42 + 64);
        if (!v43) {
          goto LABEL_100;
        }
        uint64_t v44 = *v43;
        if (!*v43) {
          goto LABEL_96;
        }
        uint64_t v45 = 0;
        unsigned int v46 = -1;
        while (2)
        {
          size_t v47 = strlen(v44);
          if (v47 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_144;
          }
          size_t v48 = v47;
          if (v47 >= 0x17)
          {
            uint64_t v50 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v47 | 7) != 0x17) {
              uint64_t v50 = v47 | 7;
            }
            uint64_t v51 = v50 + 1;
            int32x4_t v49 = operator new(v50 + 1);
            *(void *)&v114[8] = v48;
            *(void *)&v114[16] = v51 | 0x8000000000000000;
            *(void *)BOOL v114 = v49;
          }
          else
          {
            v114[23] = v47;
            int32x4_t v49 = v114;
            if (!v47)
            {
LABEL_65:
              v49[v48] = 0;
              int64_t v52 = (char **)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>((uint64_t)&v118, (uint64_t)v114);
              std::string v53 = v52;
              if ((v114[23] & 0x80000000) != 0)
              {
                operator delete(*(void **)v114);
                if (v119 == v53) {
                  goto LABEL_56;
                }
              }
              else if (v119 == v52)
              {
                goto LABEL_56;
              }
              unint64_t v54 = *((unsigned int *)v53 + 14);
              int16x8_t v56 = *(char **)(v42 + 88);
              unint64_t v55 = *(void *)(v42 + 96);
              if ((unint64_t)v56 >= v55)
              {
                int16x8_t v58 = *(char **)(v42 + 80);
                uint64_t v59 = (v56 - v58) >> 2;
                unint64_t v60 = v59 + 1;
                if ((unint64_t)(v59 + 1) >> 62) {
                  goto LABEL_144;
                }
                uint64_t v61 = v55 - (void)v58;
                if (v61 >> 1 > v60) {
                  unint64_t v60 = v61 >> 1;
                }
                if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v62 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v62 = v60;
                }
                if (v62)
                {
                  if (v62 >> 62) {
LABEL_146:
                  }
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  int8x8_t v63 = operator new(4 * v62);
                }
                else
                {
                  int8x8_t v63 = 0;
                }
                int16x8_t v64 = &v63[4 * v59];
                *int16x8_t v64 = v54;
                int16x8_t v57 = v64 + 1;
                if (v56 != v58)
                {
                  unint64_t v65 = v56 - v58 - 4;
                  if (v65 < 0x2C) {
                    goto LABEL_149;
                  }
                  if ((unint64_t)(v58 - v63) < 0x20) {
                    goto LABEL_149;
                  }
                  uint64_t v66 = (v65 >> 2) + 1;
                  uint64_t v67 = 4 * (v66 & 0x7FFFFFFFFFFFFFF8);
                  int v68 = &v56[-v67];
                  int16x8_t v64 = (_DWORD *)((char *)v64 - v67);
                  int64_t v69 = &v63[4 * v59 - 16];
                  timeval v70 = v56 - 16;
                  uint64_t v71 = v66 & 0x7FFFFFFFFFFFFFF8;
                  do
                  {
                    long long v72 = *(_OWORD *)v70;
                    *(v69 - 1) = *((_OWORD *)v70 - 1);
                    *int64_t v69 = v72;
                    v69 -= 2;
                    v70 -= 32;
                    v71 -= 8;
                  }
                  while (v71);
                  int16x8_t v56 = v68;
                  if (v66 != (v66 & 0x7FFFFFFFFFFFFFF8))
                  {
LABEL_149:
                    do
                    {
                      int v73 = *((_DWORD *)v56 - 1);
                      v56 -= 4;
                      *--int16x8_t v64 = v73;
                    }
                    while (v56 != v58);
                  }
                }
                *(void *)(v42 + 80) = v64;
                *(void *)(v42 + 88) = v57;
                *(void *)(v42 + 96) = &v63[4 * v62];
                if (v58) {
                  operator delete(v58);
                }
              }
              else
              {
                *(_DWORD *)int16x8_t v56 = v54;
                int16x8_t v57 = v56 + 4;
              }
              *(void *)(v42 + 88) = v57;
              if (v54 < (qword_100079828 - g_dynamic_register_map) >> 7
                && v46 >= *(_DWORD *)(v42 + 40) + *(_DWORD *)(g_dynamic_register_map + (v54 << 7) + 4))
              {
                unsigned int v46 = *(_DWORD *)(v42 + 40) + *(_DWORD *)(g_dynamic_register_map + (v54 << 7) + 4);
              }
LABEL_56:
              ++v45;
              uint64_t v44 = *(const char **)(*(void *)(v42 + 64) + 8 * v45);
              if (v44) {
                continue;
              }
              if (v46 == -1)
              {
LABEL_96:
                if (DNBLogEnabled()) {
                  _DNBLogThreaded("no offset was calculated entry for register %s", *(const char **)(v42 + 16));
                }
                unsigned int v46 = -1;
              }
              *(_DWORD *)(v42 + 4) = v46;
LABEL_100:
              unint64_t v74 = *(const char ***)(v42 + 72);
              if (v74)
              {
                unint64_t v75 = *v74;
                if (*v74)
                {
                  uint64_t v76 = 0;
                  while (1)
                  {
                    size_t v78 = strlen(v75);
                    if (v78 > 0x7FFFFFFFFFFFFFF7) {
                      goto LABEL_144;
                    }
                    size_t v79 = v78;
                    if (v78 >= 0x17) {
                      break;
                    }
                    v114[23] = v78;
                    std::string::size_type v80 = v114;
                    if (v78) {
                      goto LABEL_113;
                    }
LABEL_114:
                    v80[v79] = 0;
                    long long v83 = (char **)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>((uint64_t)&v118, (uint64_t)v114);
                    char v84 = v83;
                    if ((v114[23] & 0x80000000) != 0)
                    {
                      operator delete(*(void **)v114);
                      if (v119 == v84) {
                        goto LABEL_105;
                      }
                    }
                    else if (v119 == v83)
                    {
                      goto LABEL_105;
                    }
                    int v85 = *((_DWORD *)v84 + 14);
                    int v87 = *(char **)(v42 + 112);
                    unint64_t v86 = *(void *)(v42 + 120);
                    if ((unint64_t)v87 < v86)
                    {
                      *(_DWORD *)int v87 = v85;
                      size_t v77 = v87 + 4;
                    }
                    else
                    {
                      std::string::size_type v88 = *(char **)(v42 + 104);
                      uint64_t v89 = (v87 - v88) >> 2;
                      unint64_t v90 = v89 + 1;
                      if ((unint64_t)(v89 + 1) >> 62) {
                        goto LABEL_144;
                      }
                      uint64_t v91 = v86 - (void)v88;
                      if (v91 >> 1 > v90) {
                        unint64_t v90 = v91 >> 1;
                      }
                      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFFCLL) {
                        unint64_t v92 = 0x3FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v92 = v90;
                      }
                      if (v92)
                      {
                        if (v92 >> 62) {
                          goto LABEL_146;
                        }
                        size_t v93 = operator new(4 * v92);
                      }
                      else
                      {
                        size_t v93 = 0;
                      }
                      int v94 = &v93[4 * v89];
                      *int v94 = v85;
                      size_t v77 = v94 + 1;
                      if (v87 != v88)
                      {
                        unint64_t v95 = v87 - v88 - 4;
                        if (v95 < 0x2C) {
                          goto LABEL_150;
                        }
                        if ((unint64_t)(v88 - v93) < 0x20) {
                          goto LABEL_150;
                        }
                        uint64_t v96 = (v95 >> 2) + 1;
                        uint64_t v97 = 4 * (v96 & 0x7FFFFFFFFFFFFFF8);
                        std::string::size_type v98 = &v87[-v97];
                        int v94 = (_DWORD *)((char *)v94 - v97);
                        uint64_t v99 = &v93[4 * v89 - 16];
                        std::string::size_type v100 = v87 - 16;
                        uint64_t v101 = v96 & 0x7FFFFFFFFFFFFFF8;
                        do
                        {
                          long long v102 = *(_OWORD *)v100;
                          *(v99 - 1) = *((_OWORD *)v100 - 1);
                          _OWORD *v99 = v102;
                          v99 -= 2;
                          v100 -= 32;
                          v101 -= 8;
                        }
                        while (v101);
                        int v87 = v98;
                        if (v96 != (v96 & 0x7FFFFFFFFFFFFFF8))
                        {
LABEL_150:
                          do
                          {
                            int v103 = *((_DWORD *)v87 - 1);
                            v87 -= 4;
                            *--int v94 = v103;
                          }
                          while (v87 != v88);
                        }
                      }
                      *(void *)(v42 + 104) = v94;
                      *(void *)(v42 + 112) = v77;
                      *(void *)(v42 + 120) = &v93[4 * v92];
                      if (v88) {
                        operator delete(v88);
                      }
                    }
                    *(void *)(v42 + 112) = v77;
LABEL_105:
                    ++v76;
                    unint64_t v75 = *(const char **)(*(void *)(v42 + 72) + 8 * v76);
                    if (!v75) {
                      goto LABEL_52;
                    }
                  }
                  uint64_t v81 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v78 | 7) != 0x17) {
                    uint64_t v81 = v78 | 7;
                  }
                  uint64_t v82 = v81 + 1;
                  std::string::size_type v80 = operator new(v81 + 1);
                  *(void *)&v114[8] = v79;
                  *(void *)&v114[16] = v82 | 0x8000000000000000;
                  *(void *)BOOL v114 = v80;
LABEL_113:
                  memmove(v80, v75, v79);
                  goto LABEL_114;
                }
              }
LABEL_52:
              v42 += 128;
              if (v42 != v111) {
                goto LABEL_53;
              }
              uint64_t v104 = g_dynamic_register_map;
              uint64_t v42 = qword_100079828;
              goto LABEL_142;
            }
          }
          break;
        }
        memmove(v49, v44, v48);
        goto LABEL_65;
      }
      uint64_t v104 = g_dynamic_register_map;
LABEL_142:
      g_reg_entries = v104;
      g_num_reg_entries = (v42 - v104) >> 7;
      std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy((uint64_t)&v118, v119[0]);
      int v2 = v106;
    }
  }
  return v2 != 0;
}

void binary_encode_string(unsigned __int8 *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  int v3 = (char)a1[23];
  if (v3 >= 0) {
    uint64_t v4 = a1[23];
  }
  else {
    uint64_t v4 = *((void *)a1 + 1);
  }
  if (v3 >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(unsigned __int8 **)a1;
  }
  for (; v4; --v4)
  {
    unsigned int v7 = *v5++;
    unsigned int v6 = v7;
    uint64_t v8 = (1 << v7) & 0x41800000000;
    BOOL v9 = v7 > 0x2A || v8 == 0;
    if (!v9 || v6 == 125)
    {
      std::string::push_back(a2, 125);
      LOBYTE(v6) = v6 ^ 0x20;
    }
    std::string::push_back(a2, v6);
  }
}

uint64_t RNBRemote::SendStopReplyPacketForThread(RNBRemote *this, uint64_t a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    char v132 = 3;
    LODWORD(v131[0]) = 3159365;
    uint64_t v15 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)v131);
    if ((v132 & 0x80000000) == 0) {
      return v15;
    }
    unint64_t v16 = (void *)v131[0];
LABEL_16:
    operator delete(v16);
    return v15;
  }
  uint64_t v4 = a2;
  if (!DNBThreadGetStopReason(*((_DWORD *)this + 3), a2, v131))
  {
    char v125 = 3;
    LODWORD(__p) = 3224901;
    uint64_t v15 = RNBRemote::SendPacket((uint64_t)this, (uint64_t)&__p);
    if ((v125 & 0x80000000) == 0) {
      return v15;
    }
    unint64_t v16 = __p;
    goto LABEL_16;
  }
  int v5 = v131[0];
  if (LODWORD(v131[0]) == 3)
  {
    RNBRemote::InitializeRegisters(this, 1);
    *((void *)this + 82) = -1;
    *(void *)&long long v6 = -1;
    *((void *)&v6 + 1) = -1;
    *(_OWORD *)((char *)this + 616) = v6;
    *(_OWORD *)((char *)this + 632) = v6;
    *((_WORD *)this + 324) = -1;
  }
  unint64_t v108 = __p;
  __darwin_time_t v109 = (__darwin_time_t)v7;
  *(void **)((char *)&__p + *((void *)__p - 3)) = v7;
  uint64_t v8 = (std::ios_base *)((char *)&__p + *((void *)__p - 3));
  std::ios_base::init(v8, &v124);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  long long v127 = 0u;
  long long v128 = 0u;
  int v129 = 16;
  LOBYTE(v114.tv_sec) = 84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
  int v9 = v133;
  int v111 = v3;
  if (DNBLogEnabledForAny(0x400000))
  {
    unint64_t v10 = (pthread_mutex_t *)*((void *)this + 61);
    if (v10) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v114, 0);
    int tv_sec = v114.tv_sec;
    __darwin_suseconds_t tv_usec = v114.tv_usec;
    uint64_t v13 = *((void *)this + 62);
    int v14 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v114;
    if (v10) {
      pthread_mutex_unlock(v10);
    }
    _DNBLogThreaded("%8d %s got signal signo = %u, exc_type = %u", tv_usec - v14 + 1000000 * (tv_sec - v13), "SendStopReplyPacketForThread", v9, v133);
    int v3 = v111;
  }
  unsigned int v17 = __p;
  uint64_t v18 = (char *)&__p + *((void *)__p - 3);
  if (*((_DWORD *)v18 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
    long long v19 = std::locale::use_facet((const std::locale *)&v114, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 32);
    std::locale::~locale((std::locale *)&v114);
    unsigned int v17 = __p;
  }
  *((_DWORD *)v18 + 36) = 48;
  *(_DWORD *)((char *)&__p + *(v17 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v17 - 3) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)&__p + *(v17 - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *(v17 - 3) + 8) & 0xFFFFFF4F | 0x80;
  *(void *)&v126[*(v17 - 3)] = 2;
  std::ostream::operator<<();
  *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"thread:", 7);
  long long v20 = (void *)std::ostream::operator<<();
  LOBYTE(v114.tv_sec) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)&v114, 1);
  uint64_t Name = (const char *)DNBThreadGetName(v3, v4);
  int v110 = this;
  if (Name)
  {
    char v22 = Name;
    if (*Name)
    {
      size_t v23 = strlen(Name);
      size_t v24 = strcspn(v22, "$#+-;:");
      *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
      if (v24 != v23)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"hexname:", 8);
        for (; v23; --v23)
        {
          unint64_t v54 = __p;
          unint64_t v55 = (char *)&__p + *((void *)__p - 3);
          if (*((_DWORD *)v55 + 36) == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)&__p + *((void *)__p - 3)));
            int16x8_t v56 = std::locale::use_facet((const std::locale *)&v114, &std::ctype<char>::id);
            ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 32);
            std::locale::~locale((std::locale *)&v114);
            unint64_t v54 = __p;
          }
          *((_DWORD *)v55 + 36) = 48;
          *(_DWORD *)((char *)&v124 + *(v54 - 3)) = *(_DWORD *)((unsigned char *)&v124 + *(v54 - 3)) & 0xFFFFFFB5 | 8;
          *(_DWORD *)((char *)&v124 + *(v54 - 3)) = *(_DWORD *)((unsigned char *)&v124 + *(v54 - 3)) & 0xFFFFFF4F | 0x80;
          *(void *)&v126[*(v54 - 3)] = 2;
          ++v22;
          std::ostream::operator<<();
        }
        LOBYTE(v114.tv_sec) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
        int v3 = v111;
        if (!*((unsigned char *)this + 783)) {
          goto LABEL_87;
        }
        goto LABEL_24;
      }
      uint64_t v25 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"name:", 5);
      size_t v26 = strlen(v22);
      uint64_t v27 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)v22, v26);
      LOBYTE(v114.tv_sec) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)&v114, 1);
    }
  }
  if (!*((unsigned char *)this + 783)) {
    goto LABEL_87;
  }
LABEL_24:
  uint64_t NumThreads = DNBProcessGetNumThreads(v3);
  if (!NumThreads) {
    goto LABEL_87;
  }
  unint64_t v29 = NumThreads;
  int v106 = v5;
  uint64_t v107 = v4;
  *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"threads:", 8);
  unint64_t v30 = 0;
  long long v31 = 0;
  long long v32 = 0;
  uint64_t v33 = 0;
  do
  {
    uint64_t ThreadAtIndex = DNBProcessGetThreadAtIndex(v3, v30);
    if (v30)
    {
      LOBYTE(v114.tv_sec) = 44;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
    }
    *(_DWORD *)((char *)&v124 + *((void *)__p - 3)) = *(_DWORD *)((unsigned char *)&v124 + *((void *)__p - 3)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    if (DNBThreadGetRegisterValueByID(v3, ThreadAtIndex, -1, 0, &v114))
    {
      unsigned int v35 = v117[0];
      if (v117[0] != (void *)-1)
      {
        if (v116 != 8)
        {
          if (v116 != 4) {
            goto LABEL_27;
          }
          unsigned int v35 = (void *)LODWORD(v117[0]);
        }
        if (v32 < v33)
        {
          *(void *)long long v32 = v35;
          v32 += 8;
          goto LABEL_27;
        }
        uint64_t v36 = (v32 - v31) >> 3;
        unint64_t v37 = v36 + 1;
        if ((unint64_t)(v36 + 1) >> 61) {
          abort();
        }
        if ((v33 - v31) >> 2 > v37) {
          unint64_t v37 = (v33 - v31) >> 2;
        }
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v37;
        }
        if (v38)
        {
          if (v38 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          __darwin_suseconds_t v39 = operator new(8 * v38);
        }
        else
        {
          __darwin_suseconds_t v39 = 0;
        }
        uint64_t v40 = &v39[8 * v36];
        *(void *)uint64_t v40 = v35;
        uint64_t v41 = v40 + 8;
        if (v32 == v31)
        {
          uint64_t v33 = &v39[8 * v38];
          if (!v31) {
            goto LABEL_52;
          }
          goto LABEL_51;
        }
        unint64_t v42 = v32 - v31 - 8;
        if (v42 < 0x168
          || (unint64_t v45 = (v32 - 8 - v31) & 0xFFFFFFFFFFFFFFF8, &v39[v32 - v31 - 8 - v45] > &v39[v32 - v31 - 8])
          || &v32[-v45 - 8] > v32 - 8
          || (unint64_t)(v31 - v39) < 0x20)
        {
          uint64_t v43 = v32;
        }
        else
        {
          uint64_t v46 = (v42 >> 3) + 1;
          uint64_t v47 = 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v43 = &v32[-v47];
          v40 -= v47;
          size_t v48 = &v39[8 * v36 - 16];
          int32x4_t v49 = v32 - 16;
          uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v51 = *(_OWORD *)v49;
            *(v48 - 1) = *((_OWORD *)v49 - 1);
            *size_t v48 = v51;
            v48 -= 2;
            v49 -= 32;
            v50 -= 4;
          }
          while (v50);
          if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_50:
            uint64_t v33 = &v39[8 * v38];
            if (!v31)
            {
LABEL_52:
              long long v32 = v41;
              long long v31 = v40;
              int v3 = v111;
              goto LABEL_27;
            }
LABEL_51:
            operator delete(v31);
            goto LABEL_52;
          }
        }
        do
        {
          uint64_t v44 = *((void *)v43 - 1);
          v43 -= 8;
          *((void *)v40 - 1) = v44;
          v40 -= 8;
        }
        while (v43 != v31);
        goto LABEL_50;
      }
    }
LABEL_27:
    ++v30;
  }
  while (v30 != v29);
  LOBYTE(v114.tv_sec) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
  if (v29 == (v32 - v31) >> 3)
  {
    *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"thread-pcs:", 11);
    *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    unint64_t v52 = v29 - 1;
    if (v29 != 1)
    {
      std::string v53 = v31 + 8;
      do
      {
        LOBYTE(v114.tv_sec) = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
        *(_DWORD *)((char *)&v124 + *((void *)__p - 3)) = *(_DWORD *)((unsigned char *)&v124 + *((void *)__p - 3)) & 0xFFFFFFB5 | 8;
        v53 += 8;
        std::ostream::operator<<();
        --v52;
      }
      while (v52);
    }
    LOBYTE(v114.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v114, 1);
    int v3 = v111;
LABEL_75:
    operator delete(v31);
  }
  else if (v31)
  {
    goto LABEL_75;
  }
  uint64_t v4 = v107;
  int v5 = v106;
  if (v29 >= 2)
  {
    RNBRemote::GetJSONThreadsInfo((uint64_t)this, 1, &v121);
    int16x8_t v57 = v121;
    if (v121)
    {
      *(_DWORD *)((char *)&__p + *((void *)__p - 3) + 8) = *(_DWORD *)((unsigned char *)&__p + *((void *)__p - 3) + 8) & 0xFFFFFFB5 | 8;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"jstopinfo:", 10);
      v114.int tv_sec = (__darwin_time_t)v108;
      *(__darwin_time_t *)((char *)&v114.tv_sec + *(v108 - 3)) = v109;
      int16x8_t v58 = (std::ios_base *)((char *)&v114 + *(void *)(v114.tv_sec - 24));
      std::ios_base::init(v58, &v114.tv_usec);
      v58[1].__vftable = 0;
      v58[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf();
      *(_OWORD *)long long v117 = 0u;
      long long v118 = 0u;
      int v119 = 16;
      ((void (*)(std::__shared_weak_count *, timeval *))v57->__on_zero_shared_weak)(v57, &v114);
      ((void (*)(std::__shared_weak_count *))v57->__get_deleter)(v57);
      std::stringbuf::str();
      append_hexified_string((uint64_t)&__p, (uint64_t *)&v112);
      if (v113 < 0) {
        operator delete(v112.__locale_);
      }
      LOBYTE(v112.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v112, 1);
      if (SBYTE7(v118) < 0) {
        operator delete(v117[0]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      int v3 = v111;
    }
    uint64_t v59 = v122;
    if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
    uint64_t v4 = v107;
    int v5 = v106;
  }
LABEL_87:
  if (!g_num_reg_entries) {
    RNBRemote::InitializeRegisters(this, 0);
  }
  if (g_reg_entries && g_num_reg_entries)
  {
    unint64_t v60 = 0;
    unsigned int v61 = 1;
    do
    {
      uint64_t v62 = g_reg_entries + (v60 << 7);
      int v63 = *(_DWORD *)(v62 + 8);
      if ((v63 & 0xFFFFFFFD) == 1
        && !*(void *)(v62 + 64)
        && DNBThreadGetRegisterValueByID(v3, v4, v63, *(_DWORD *)(g_reg_entries + (v60 << 7) + 12), &v114))
      {
        debugserver_regnum_with_fixed_width_hex_register_value((uint64_t *)&__p, v3, v4, g_reg_entries + (v60 << 7), &v114);
      }
      unint64_t v60 = v61++;
    }
    while (g_num_reg_entries > v60);
  }
  if (v5 == 3)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"reason:exec;", 12);
  }
  else if (LODWORD(v131[0]) == 4)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"reason:watchpoint;", 18);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"description:", 12);
    v114.int tv_sec = (__darwin_time_t)v108;
    *(__darwin_time_t *)((char *)&v114.tv_sec + *(v108 - 3)) = v109;
    int16x8_t v64 = (std::ios_base *)((char *)&v114 + *(void *)(v114.tv_sec - 24));
    std::ios_base::init(v64, &v114.tv_usec);
    v64[1].__vftable = 0;
    v64[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)long long v117 = 0u;
    long long v118 = 0u;
    int v119 = 16;
    unint64_t v65 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v65, (uint64_t)" ", 1);
    uint64_t v66 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)" ", 1);
    std::ostream::operator<<();
    std::stringbuf::str();
    append_hexified_string((uint64_t)&__p, (uint64_t *)&v112);
    if (v113 < 0) {
      operator delete(v112.__locale_);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)";", 1);
    uint64_t v67 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"watch_addr:", 11);
    *(_DWORD *)((char *)v67 + *(void *)(*v67 - 24) + 8) = *(_DWORD *)((unsigned char *)v67 + *(void *)(*v67 - 24) + 8) & 0xFFFFFFB5 | 8;
    int v68 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)";", 1);
    int64_t v69 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"me_watch_addr:", 14);
    *(_DWORD *)((char *)v69 + *(void *)(*v69 - 24) + 8) = *(_DWORD *)((unsigned char *)v69 + *(void *)(*v69 - 24) + 8) & 0xFFFFFFB5 | 8;
    timeval v70 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v70, (uint64_t)";", 1);
    uint64_t v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_hw_idx:", 10);
    *(_DWORD *)((char *)v71 + *(void *)(*v71 - 24) + 8) = *(_DWORD *)((unsigned char *)v71 + *(void *)(*v71 - 24) + 8) & 0xFFFFFFB5 | 8;
    long long v72 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v72, (uint64_t)";", 1);
    if (BYTE4(v135))
    {
      int v73 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_iss:", 11);
      *(_DWORD *)((char *)v73 + *(void *)(*v73 - 24) + 8) = *(_DWORD *)((unsigned char *)v73 + *(void *)(*v73 - 24) + 8) & 0xFFFFFFB5 | 8;
      unint64_t v74 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)";", 1);
      unint64_t v75 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_wpt:", 11);
      *(_DWORD *)((char *)v75 + *(void *)(*v75 - 24) + 8) = *(_DWORD *)((unsigned char *)v75 + *(void *)(*v75 - 24) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v76 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v76, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_wptv:", 12);
      size_t v77 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v77, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_wpf:", 11);
      size_t v78 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v78, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_fnp:", 11);
      size_t v79 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_vncr:", 12);
      std::string::size_type v80 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_fnv:", 11);
      uint64_t v81 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v81, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_cm:", 10);
      uint64_t v82 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v82, (uint64_t)";", 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_wnr:", 11);
      long long v83 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v83, (uint64_t)";", 1);
      char v84 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"wp_esr_dfsc:", 12);
      *(_DWORD *)((char *)v84 + *(void *)(*v84 - 24) + 8) = *(_DWORD *)((unsigned char *)v84 + *(void *)(*v84 - 24) + 8) & 0xFFFFFFB5 | 8;
      int v85 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v85, (uint64_t)";", 1);
    }
    if (SBYTE7(v118) < 0) {
      operator delete(v117[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else if (v133)
  {
    unint64_t v86 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"metype:", 7);
    *(_DWORD *)((char *)v86 + *(void *)(*v86 - 24) + 8) = *(_DWORD *)((unsigned char *)v86 + *(void *)(*v86 - 24) + 8) & 0xFFFFFFB5 | 8;
    int v87 = (void *)std::ostream::operator<<();
    LOBYTE(v114.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v87, (uint64_t)&v114, 1);
    std::string::size_type v88 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"mecount:", 8);
    *(_DWORD *)((char *)v88 + *(void *)(*v88 - 24) + 8) = *(_DWORD *)((unsigned char *)v88 + *(void *)(*v88 - 24) + 8) & 0xFFFFFFB5 | 8;
    uint64_t v89 = (void *)std::ostream::operator<<();
    LOBYTE(v114.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)&v114, 1);
    if (v134)
    {
      for (unint64_t i = 0; i < v134; ++i)
      {
        uint64_t v91 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"medata:", 7);
        *(_DWORD *)((char *)v91 + *(void *)(*v91 - 24) + 8) = *(_DWORD *)((unsigned char *)v91 + *(void *)(*v91 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 8;
        unint64_t v92 = (void *)std::ostream::operator<<();
        LOBYTE(v114.tv_sec) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v92, (uint64_t)&v114, 1);
      }
    }
  }
  *(void *)&v114.__darwin_suseconds_t tv_usec = 0;
  uint64_t v115 = 0;
  v114.int tv_sec = (__darwin_time_t)&v114.tv_usec;
  ReadStackMemory(v111, v4, (uint64_t **)&v114, 2u);
  if (v115)
  {
    p_int tv_sec = (void *)v114.tv_sec;
    if ((__darwin_suseconds_t *)v114.tv_sec != &v114.tv_usec)
    {
      do
      {
        int v94 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)"memory:", 7);
        LOBYTE(v112.__locale_) = 48;
        unint64_t v95 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v94, (uint64_t)&v112, 1);
        LOBYTE(v112.__locale_) = 120;
        uint64_t v96 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v95, (uint64_t)&v112, 1);
        uint64_t v97 = v96;
        uint64_t v98 = *v96;
        uint64_t v99 = (char *)v96 + *(void *)(*v96 - 24);
        if (*((_DWORD *)v99 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v96 + *(void *)(*v96 - 24)));
          std::string::size_type v100 = std::locale::use_facet(&v112, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v100->__vftable[2].~facet_0)(v100, 32);
          std::locale::~locale(&v112);
          uint64_t v98 = *v97;
        }
        *((_DWORD *)v99 + 36) = 48;
        *(_DWORD *)((char *)v97 + *(void *)(v98 - 24) + 8) = *(_DWORD *)((unsigned char *)v97 + *(void *)(v98 - 24) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)v97 + *(void *)(v98 - 24) + 8) = *(_DWORD *)((unsigned char *)v97 + *(void *)(v98 - 24) + 8) & 0xFFFFFF4F | 0x80;
        uint64_t v101 = (void *)std::ostream::operator<<();
        LOBYTE(v112.__locale_) = 61;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v101, (uint64_t)&v112, 1);
        append_hex_value((uint64_t)&__p, (uint64_t)(p_tv_sec + 5), p_tv_sec[7], 0);
        LOBYTE(v112.__locale_) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p, (uint64_t)&v112, 1);
        long long v102 = (timeval *)p_tv_sec[1];
        if (v102)
        {
          do
          {
            int v103 = v102;
            long long v102 = (timeval *)v102->tv_sec;
          }
          while (v102);
        }
        else
        {
          do
          {
            int v103 = (timeval *)p_tv_sec[2];
            BOOL v104 = v103->tv_sec == (void)p_tv_sec;
            p_int tv_sec = &v103->tv_sec;
          }
          while (!v104);
        }
        p_int tv_sec = &v103->tv_sec;
      }
      while (v103 != (timeval *)&v114.tv_usec);
    }
  }
  std::stringbuf::str();
  uint64_t v15 = RNBRemote::SendPacket((uint64_t)v110, (uint64_t)&v112);
  if (v113 < 0) {
    operator delete(v112.__locale_);
  }
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy((uint64_t)&v114, *(void **)&v114.tv_usec);
  if (SBYTE7(v128) < 0) {
    operator delete((void *)v127);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return v15;
}

std::string *get_identifier@<X0>(std::string *__str@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  int v4 = SHIBYTE(__str->__r_.__value_.__r.__words[2]);
  if (v4 < 0)
  {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
    if (!size) {
      goto LABEL_16;
    }
    long long v6 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__str->__r_.__value_.__s + 23)) {
      goto LABEL_14;
    }
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    long long v6 = __str;
  }
  unsigned int v7 = k_space_delimiters;
  size_t v8 = strlen(k_space_delimiters);
  int v9 = v6;
  if (v8)
  {
    size_t v10 = v8;
    int v9 = v6;
    while (memchr(v7, v9->__r_.__value_.__s.__data_[0], v10))
    {
      int v9 = (std::string *)((char *)v9 + 1);
      if (!--size)
      {
        std::string::size_type v11 = -1;
        goto LABEL_12;
      }
    }
  }
  std::string::size_type v11 = (char *)v9 - (char *)v6;
  if (v9 != v6)
  {
LABEL_12:
    std::string::erase(__str, 0, v11);
    LOBYTE(v4) = *((unsigned char *)&__str->__r_.__value_.__s + 23);
  }
  if ((v4 & 0x80) == 0)
  {
LABEL_14:
    std::string::size_type v12 = v4;
    if (!(_BYTE)v4) {
      goto LABEL_43;
    }
    goto LABEL_17;
  }
LABEL_16:
  std::string::size_type v12 = __str->__r_.__value_.__l.__size_;
  if (!v12)
  {
LABEL_43:
    std::string::size_type v16 = 0;
    goto LABEL_45;
  }
LABEL_17:
  if ((v4 & 0x80u) == 0) {
    uint64_t v13 = __str;
  }
  else {
    uint64_t v13 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  __darwin_ct_rune_t v14 = v13->__r_.__value_.__s.__data_[0];
  if (v14 < 0)
  {
    if (!__maskrune(v14, 0x100uLL)) {
      goto LABEL_24;
    }
  }
  else if ((_DefaultRuneLocale.__runetype[v14] & 0x100) == 0)
  {
LABEL_24:
    if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = __str;
    }
    else {
      uint64_t v15 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    if (v15->__r_.__value_.__s.__data_[0] != 95) {
      goto LABEL_43;
    }
  }
  std::string::size_type v16 = 1;
  if (v12 == 1) {
    goto LABEL_45;
  }
  do
  {
    if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v18 = __str;
    }
    else {
      uint64_t v18 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    __darwin_ct_rune_t v19 = v18->__r_.__value_.__s.__data_[v16];
    if (v19 < 0)
    {
      if (__maskrune(v19, 0x500uLL)) {
        goto LABEL_34;
      }
    }
    else if ((_DefaultRuneLocale.__runetype[v19] & 0x500) != 0)
    {
      goto LABEL_34;
    }
    if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v17 = __str;
    }
    else {
      unsigned int v17 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    if (v17->__r_.__value_.__s.__data_[v16] != 95) {
      goto LABEL_45;
    }
LABEL_34:
    ++v16;
  }
  while (v12 != v16);
  std::string::size_type v16 = v12;
LABEL_45:
  std::string::assign(a2, __str, 0, v16);

  return std::string::erase(__str, 0, v16);
}

BOOL std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1) {
LABEL_10:
    }
      abort();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

uint64_t set_logging(char *__s1)
{
  if (__s1)
  {
    int v1 = __s1;
    if (*__s1)
    {
      int v2 = 0;
      do
      {
        if (strncmp(v1, "bitmask=", 8uLL))
        {
          int v3 = strchr(v1, 59);
          if (v3) {
            int v1 = v3 + 1;
          }
          else {
            v1 += strlen(v1);
          }
          continue;
        }
        v1 += 8;
        while (1)
        {
          int v5 = *v1;
          if (v5 != 124) {
            break;
          }
          ++v1;
LABEL_17:
          if (!strncmp(v1, "LOG_VERBOSE", 0xBuLL))
          {
            size_t v4 = v1 + 11;
            v2 |= 1u;
          }
          else if (!strncmp(v1, "LOG_PROCESS", 0xBuLL))
          {
            size_t v4 = v1 + 11;
            v2 |= 2u;
          }
          else if (!strncmp(v1, "LOG_THREAD", 0xAuLL))
          {
            size_t v4 = v1 + 10;
            v2 |= 4u;
          }
          else if (!strncmp(v1, "LOG_EXCEPTIONS", 0xEuLL))
          {
            size_t v4 = v1 + 14;
            v2 |= 8u;
          }
          else if (!strncmp(v1, "LOG_SHLIB", 9uLL))
          {
            size_t v4 = v1 + 9;
            v2 |= 0x10u;
          }
          else if (!strncmp(v1, "LOG_MEMORY_DATA_SHORT", 0x15uLL))
          {
            size_t v4 = v1 + 21;
            v2 |= 0x40u;
          }
          else if (!strncmp(v1, "LOG_MEMORY_DATA_LONG", 0x14uLL))
          {
            size_t v4 = v1 + 20;
            v2 |= 0x80u;
          }
          else if (!strncmp(v1, "LOG_MEMORY_PROTECTIONS", 0x16uLL))
          {
            size_t v4 = v1 + 22;
            v2 |= 0x100u;
          }
          else if (!strncmp(v1, "LOG_MEMORY", 0xAuLL))
          {
            size_t v4 = v1 + 10;
            v2 |= 0x20u;
          }
          else if (!strncmp(v1, "LOG_BREAKPOINTS", 0xFuLL))
          {
            size_t v4 = v1 + 15;
            v2 |= 0x200u;
          }
          else if (!strncmp(v1, "LOG_EVENTS", 0xAuLL))
          {
            size_t v4 = v1 + 10;
            v2 |= 0x400u;
          }
          else if (!strncmp(v1, "LOG_WATCHPOINTS", 0xFuLL))
          {
            size_t v4 = v1 + 15;
            v2 |= 0x800u;
          }
          else if (!strncmp(v1, "LOG_STEP", 8uLL))
          {
            size_t v4 = v1 + 8;
            v2 |= 0x1000u;
          }
          else if (!strncmp(v1, "LOG_TASK", 8uLL))
          {
            size_t v4 = v1 + 8;
            v2 |= 0x2000u;
          }
          else if (!strncmp(v1, "LOG_ALL", 7uLL))
          {
            size_t v4 = v1 + 7;
            int v2 = -1;
          }
          else if (!strncmp(v1, "LOG_DEFAULT", 0xBuLL))
          {
            size_t v4 = v1 + 11;
            v2 |= 0x3A3Eu;
          }
          else if (!strncmp(v1, "LOG_NONE", 8uLL))
          {
            int v2 = 0;
            size_t v4 = v1 + 8;
          }
          else if (!strncmp(v1, "LOG_RNB_MINIMAL", 0xFuLL))
          {
            size_t v4 = v1 + 15;
            v2 |= 0x10000u;
          }
          else if (!strncmp(v1, "LOG_RNB_MEDIUM", 0xEuLL))
          {
            size_t v4 = v1 + 14;
            v2 |= 0x20000u;
          }
          else if (!strncmp(v1, "LOG_RNB_MAX", 0xBuLL))
          {
            size_t v4 = v1 + 11;
            v2 |= 0x40000u;
          }
          else if (!strncmp(v1, "LOG_RNB_COMM", 0xCuLL))
          {
            size_t v4 = v1 + 12;
            v2 |= 0x80000u;
          }
          else if (!strncmp(v1, "LOG_RNB_REMOTE", 0xEuLL))
          {
            size_t v4 = v1 + 14;
            v2 |= 0x100000u;
          }
          else if (!strncmp(v1, "LOG_RNB_EVENTS", 0xEuLL))
          {
            size_t v4 = v1 + 14;
            v2 |= 0x200000u;
          }
          else if (!strncmp(v1, "LOG_RNB_PROC", 0xCuLL))
          {
            size_t v4 = v1 + 12;
            v2 |= 0x400000u;
          }
          else if (!strncmp(v1, "LOG_RNB_PACKETS", 0xFuLL))
          {
            size_t v4 = v1 + 15;
            v2 |= 0x800000u;
          }
          else if (!strncmp(v1, "LOG_RNB_ALL", 0xBuLL))
          {
            size_t v4 = v1 + 11;
            v2 |= 0xFFFF0000;
          }
          else if (!strncmp(v1, "LOG_RNB_DEFAULT", 0xFuLL))
          {
            size_t v4 = v1 + 15;
            v2 |= 0xFFFF0000;
          }
          else if (!strncmp(v1, "LOG_DARWIN_LOG", 0xEuLL))
          {
            size_t v4 = v1 + 14;
            v2 |= 0x4000u;
          }
          else if (!strncmp(v1, "LOG_RNB_NONE", 0xCuLL))
          {
            int v2 = 0;
            size_t v4 = v1 + 12;
          }
          else
          {
            size_t v4 = strchr(v1, 124);
            if (!v4)
            {
              size_t v4 = strchr(v1, 59);
              if (!v4) {
                size_t v4 = &v1[strlen(v1)];
              }
            }
          }
          int v1 = v4;
          if (!v4) {
            return 0;
          }
        }
        if (!*v1) {
          continue;
        }
        if (v5 != 59) {
          goto LABEL_17;
        }
        if (!DNBLogGetLogCallback())
        {
          LogFunction = (void (*)(void *, char, const char *, va_list))OsLogger::GetLogFunction(0);
          if (!LogFunction) {
            LogFunction = ASLLogCallback;
          }
          DNBLogSetLogCallback(LogFunction, 0);
        }
        DNBLogSetLogMask(v2);
        ++v1;
      }
      while (*v1);
    }
  }
  return 0;
}

uint64_t append_hex_value(uint64_t result, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v4 = a3;
  long long v6 = (uint64_t *)result;
  if (a4)
  {
    if ((int)a3 >= 1)
    {
      uint64_t v7 = result + 8;
      unint64_t v8 = a3 + 1;
      do
      {
        uint64_t v9 = *v6;
        size_t v10 = (char *)v6 + *(void *)(*v6 - 24);
        if (*((_DWORD *)v10 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
          std::string::size_type v11 = std::locale::use_facet(&v16, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
          std::locale::~locale(&v16);
          uint64_t v9 = *v6;
        }
        *((_DWORD *)v10 + 36) = 48;
        *(_DWORD *)(v7 + *(void *)(v9 - 24)) = *(_DWORD *)(v7 + *(void *)(v9 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)(v7 + *(void *)(v9 - 24)) = *(_DWORD *)(v7 + *(void *)(v9 - 24)) & 0xFFFFFF4F | 0x80;
        *(uint64_t *)((char *)v6 + *(void *)(v9 - 24) + 24) = 2;
        uint64_t result = std::ostream::operator<<();
        --v8;
      }
      while (v8 > 1);
    }
  }
  else if (a3)
  {
    uint64_t v12 = result + 8;
    do
    {
      uint64_t v13 = *v6;
      __darwin_ct_rune_t v14 = (char *)v6 + *(void *)(*v6 - 24);
      if (*((_DWORD *)v14 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
        uint64_t v15 = std::locale::use_facet(&v16, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 32);
        std::locale::~locale(&v16);
        uint64_t v13 = *v6;
      }
      *((_DWORD *)v14 + 36) = 48;
      *(_DWORD *)(v12 + *(void *)(v13 - 24)) = *(_DWORD *)(v12 + *(void *)(v13 - 24)) & 0xFFFFFFB5 | 8;
      *(_DWORD *)(v12 + *(void *)(v13 - 24)) = *(_DWORD *)(v12 + *(void *)(v13 - 24)) & 0xFFFFFF4F | 0x80;
      *(uint64_t *)((char *)v6 + *(void *)(v13 - 24) + 24) = 2;
      ++a2;
      uint64_t result = std::ostream::operator<<();
      --v4;
    }
    while (v4);
  }
  return result;
}

void cstring_to_asciihex_string(const char *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  size_t v4 = strlen(a1);
  std::string::reserve(a2, 2 * v4);
  if (a1)
  {
    int v5 = *(unsigned __int8 *)a1;
    if (*a1)
    {
      long long v6 = a1 + 1;
      do
      {
        snprintf(__str, 5uLL, "%02x", v5);
        std::string::append(a2, __str);
        int v7 = *(unsigned __int8 *)v6++;
        int v5 = v7;
      }
      while (v7);
    }
  }
}

uint64_t append_hexified_string(uint64_t result, uint64_t *a2)
{
  int v2 = *((char *)a2 + 23);
  if (v2 >= 0) {
    uint64_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v3 = a2[1];
  }
  if (v2 >= 0) {
    size_t v4 = a2;
  }
  else {
    size_t v4 = (uint64_t *)*a2;
  }
  if (v3)
  {
    int v5 = (uint64_t *)result;
    uint64_t v6 = result + 24;
    uint64_t v7 = result + 8;
    do
    {
      uint64_t v8 = *v5;
      uint64_t v9 = (char *)v5 + *(void *)(*v5 - 24);
      if (*((_DWORD *)v9 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
        size_t v10 = std::locale::use_facet(&v11, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
        std::locale::~locale(&v11);
        uint64_t v8 = *v5;
      }
      *((_DWORD *)v9 + 36) = 48;
      *(_DWORD *)(v7 + *(void *)(v8 - 24)) = *(_DWORD *)(v7 + *(void *)(v8 - 24)) & 0xFFFFFFB5 | 8;
      *(_DWORD *)(v7 + *(void *)(v8 - 24)) = *(_DWORD *)(v7 + *(void *)(v8 - 24)) & 0xFFFFFF4F | 0x80;
      *(void *)(v6 + *(void *)(v8 - 24)) = 2;
      size_t v4 = (uint64_t *)((char *)v4 + 1);
      uint64_t result = std::ostream::operator<<();
      --v3;
    }
    while (v3);
  }
  return result;
}

void register_value_in_hex_fixed_width(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  if (a4)
  {
    int v5 = a5;
    if (a5
      || (int v5 = v17, DNBThreadGetRegisterValueByID(a2, a3, *(_DWORD *)(a4 + 8), *(_DWORD *)(a4 + 12), v17)))
    {
      uint64_t v8 = (uint64_t *)(v5 + 72);
      uint64_t v9 = *(unsigned int *)(a4 + 36);
LABEL_5:
      append_hex_value(a1, (uint64_t)v8, v9, 0);
      return;
    }
    size_t v10 = *(unsigned int *)(a4 + 36);
    if (v10)
    {
      if (v10 >= 0x17)
      {
        if ((v10 | 7) == 0x17) {
          uint64_t v12 = (v10 & 0xFFFFFFF8) + 8;
        }
        else {
          uint64_t v12 = v10 | 7;
        }
        std::locale v11 = (uint64_t *)operator new(v12 + 1);
        size_t v15 = v10;
        uint64_t v16 = v12 - 0x7FFFFFFFFFFFFFFFLL;
        __darwin_ct_rune_t v14 = v11;
      }
      else
      {
        HIBYTE(v16) = v10;
        std::locale v11 = (uint64_t *)&v14;
      }
      bzero(v11, v10);
      *((unsigned char *)v11 + v10) = 0;
      if (SHIBYTE(v16) < 0)
      {
        uint64_t v13 = v14;
        append_hex_value(a1, (uint64_t)v14, v15, 0);
        operator delete(v13);
        return;
      }
      uint64_t v9 = HIBYTE(v16);
      uint64_t v8 = (uint64_t *)&v14;
      goto LABEL_5;
    }
  }
}

void *std::basic_string<unsigned char>::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    char *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t *debugserver_regnum_with_fixed_width_hex_register_value(uint64_t *result, int a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  if (a4)
  {
    uint64_t v9 = result;
    uint64_t v10 = *result;
    std::locale v11 = (char *)result + *(void *)(*result - 24);
    if (*((_DWORD *)v11 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)result + *(void *)(*result - 24)));
      uint64_t v12 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
      std::locale::~locale(&v14);
      uint64_t v10 = *v9;
    }
    *((_DWORD *)v11 + 36) = 48;
    *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFF4F | 0x80;
    *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 24) = 2;
    uint64_t v13 = (void *)std::ostream::operator<<();
    char v15 = 58;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&v15, 1);
    register_value_in_hex_fixed_width((uint64_t)v9, a2, a3, a4, a5);
    char v16 = 59;
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)&v16, 1);
  }
  return result;
}

double RNBRemote::DispatchQueueOffsets::GetThreadQueueInfo(unsigned __int16 *a1, int a2, mach_vm_address_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  if (*(char *)(a5 + 23) < 0)
  {
    **(unsigned char **)a5 = 0;
    *(void *)(a5 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 23) = 0;
  }
  *a6 = 0;
  *a7 = 0;
  if (a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && *a1 != 0xFFFF)
  {
    uint64_t Pointer = DNBProcessMemoryReadPointer(a2, a3);
    *a4 = Pointer;
    if (Pointer)
    {
      *a6 = DNBProcessMemoryReadInteger(a2, Pointer + a1[7], a1[8], 0);
      *a7 = DNBProcessMemoryReadInteger(a2, *a4 + a1[5], a1[6], 0);
      if (*a1 < 4u)
      {
        DNBProcessMemoryReadCStringFixed(&v16);
        if ((*(char *)(a5 + 23) & 0x80000000) == 0)
        {
LABEL_13:
          double result = *(double *)&v16.__r_.__value_.__l.__data_;
          *(std::string *)a5 = v16;
          return result;
        }
      }
      else
      {
        mach_vm_address_t v15 = DNBProcessMemoryReadPointer(a2, *a4 + a1[1]);
        if (!v15) {
          return result;
        }
        DNBProcessMemoryReadCString(a2, v15, &v16);
        if ((*(char *)(a5 + 23) & 0x80000000) == 0) {
          goto LABEL_13;
        }
      }
      operator delete(*(void **)a5);
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t RNBRemote::GetJSONThreadsInfo@<X0>(uint64_t this@<X0>, int a2@<W1>, std::__shared_weak_count **a3@<X8>)
{
  if (*(_DWORD *)(this + 12))
  {
    uint64_t v5 = this;
    uint64_t v6 = (std::__shared_weak_count *)operator new(0x50uLL);
    size_t v7 = v6;
    v6->__shared_weak_owners_ = 0;
    v6->__shared_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_100068F48;
    size_t v8 = v6 + 1;
    LODWORD(v6[2].__vftable) = 2;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_100068DD8;
    v6[1].__shared_owners_ = (uint64_t)&v6[1];
    v6[2].__shared_owners_ = 0;
    v6[2].__shared_weak_owners_ = 0;
    v6[3].__vftable = 0;
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v7);
    }
    int v11 = *(_DWORD *)(v5 + 12);
    this = DNBProcessGetNumThreads(v11);
    uint64_t v10 = this;
    if (this)
    {
      unint64_t v9 = 0;
      do
      {
        unint64_t ThreadAtIndex = DNBProcessGetThreadAtIndex(v11, v9);
        this = DNBThreadGetStopReason(v11, ThreadAtIndex, v13);
        if (!a2 || this && v13[0]) {
          operator new();
        }
        ++v9;
      }
      while (v9 != v10);
    }
  }
  else
  {
    size_t v7 = 0;
    size_t v8 = 0;
  }
  *a3 = v8;
  a3[1] = v7;
  return this;
}

unint64_t ReadStackMemory(int a1, uint64_t a2, uint64_t **a3, unsigned int a4)
{
  unint64_t result = DNBThreadGetRegisterValueByID(a1, a2, -1, 2, v26);
  if (result)
  {
    int v8 = v27;
    mach_vm_address_t v9 = v27 == 4 ? v28 : v28;
    if (v9)
    {
      int v10 = 0;
      int v11 = a3 + 1;
      do
      {
        if (++v10 > a4) {
          break;
        }
        unint64_t v13 = (2 * v8);
        unint64_t v30 = v13;
        unint64_t result = DNBProcessMemoryRead(a1, v9, v13, (char *)&v29);
        if (result != v13) {
          break;
        }
        std::locale v14 = *v11;
        mach_vm_address_t v15 = a3 + 1;
        std::string v16 = a3 + 1;
        if (*v11)
        {
          unsigned int v17 = a3 + 1;
          uint64_t v18 = *v11;
          do
          {
            mach_vm_address_t v19 = v18[4];
            BOOL v20 = v19 >= v9;
            if (v19 >= v9) {
              long long v21 = (uint64_t **)v18;
            }
            else {
              long long v21 = (uint64_t **)(v18 + 1);
            }
            if (v20) {
              unsigned int v17 = (uint64_t **)v18;
            }
            uint64_t v18 = *v21;
          }
          while (*v21);
          if (v17 != v11 && v9 >= (unint64_t)v17[4]) {
            return result;
          }
          while (1)
          {
            while (1)
            {
              std::string v16 = v14;
              mach_vm_address_t v22 = v14[4];
              if (v9 >= v22) {
                break;
              }
              std::locale v14 = (uint64_t *)*v16;
              mach_vm_address_t v15 = (uint64_t **)v16;
              if (!*v16) {
                goto LABEL_31;
              }
            }
            if (v22 >= v9) {
              break;
            }
            std::locale v14 = (uint64_t *)v16[1];
            if (!v14)
            {
              mach_vm_address_t v15 = (uint64_t **)(v16 + 1);
              goto LABEL_31;
            }
          }
        }
        else
        {
LABEL_31:
          size_t v23 = v16;
          std::string v16 = operator new(0x40uLL);
          v16[4] = v9;
          v16[5] = 0;
          v16[6] = 0;
          v16[7] = 0;
          void *v16 = 0;
          v16[1] = 0;
          v16[2] = v23;
          const std::locale::facet *v15 = v16;
          size_t v24 = (uint64_t *)**a3;
          uint64_t v25 = v16;
          if (v24)
          {
            *a3 = v24;
            uint64_t v25 = *v15;
          }
          unint64_t result = (unint64_t)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a3[1], v25);
          a3[2] = (uint64_t *)((char *)a3[2] + 1);
        }
        *(_OWORD *)(v16 + 5) = v29;
        mach_vm_address_t v12 = v29;
        v16[7] = v30;
        int v8 = v27;
        if (v27 == 4) {
          mach_vm_address_t v9 = v12;
        }
        else {
          mach_vm_address_t v9 = v12;
        }
      }
      while (v9);
    }
  }
  return result;
}

void std::vector<unsigned char>::reserve(uint64_t a1, size_t __sz)
{
  int v2 = *(unsigned char **)a1;
  if (*(void *)(a1 + 16) - *(void *)a1 >= __sz) {
    return;
  }
  if ((__sz & 0x8000000000000000) != 0) {
    abort();
  }
  uint64_t v5 = *(unsigned char **)(a1 + 8);
  uint64_t v6 = operator new(__sz);
  unint64_t v7 = v5 - v2;
  int v8 = &v6[v5 - v2];
  mach_vm_address_t v9 = v8;
  if (v5 != v2)
  {
    if (v7 < 8)
    {
      int v10 = &v6[v5 - v2];
      goto LABEL_18;
    }
    int v10 = &v6[v5 - v2];
    if ((unint64_t)(v2 - v6) >= 0x20)
    {
      if (v7 < 0x20)
      {
        unint64_t v11 = 0;
        goto LABEL_13;
      }
      unint64_t v11 = v7 & 0xFFFFFFFFFFFFFFE0;
      mach_vm_address_t v12 = (long long *)(v5 - 16);
      unint64_t v13 = &v6[v5 - 16 - v2];
      unint64_t v14 = v7 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v15 = *v12;
        *(v13 - 1) = *(v12 - 1);
        *unint64_t v13 = v15;
        v13 -= 2;
        v12 -= 2;
        v14 -= 32;
      }
      while (v14);
      if (v7 == v11) {
        goto LABEL_20;
      }
      if ((v7 & 0x18) != 0)
      {
LABEL_13:
        int v10 = &v8[-(v7 & 0xFFFFFFFFFFFFFFF8)];
        std::string v16 = &v5[-v11 - 8];
        int64_t v17 = v16 - v2;
        unint64_t v18 = v11 - (v7 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          uint64_t v19 = *(void *)v16;
          v16 -= 8;
          *(void *)&v6[v17] = v19;
          v17 -= 8;
          v18 += 8;
        }
        while (v18);
        v5 -= v7 & 0xFFFFFFFFFFFFFFF8;
        if (v7 == (v7 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
        goto LABEL_18;
      }
      int v10 = &v8[-v11];
      v5 -= v11;
    }
LABEL_18:
    BOOL v20 = v10 - 1;
    do
    {
      char v21 = *--v5;
      *v20-- = v21;
    }
    while (v5 != v2);
LABEL_20:
    mach_vm_address_t v9 = v6;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v8;
  *(void *)(a1 + 16) = &v6[__sz];
  if (v2)
  {
    operator delete(v2);
  }
}

char *RNBRemote::ExtractThreadIDFromThreadSuffix(RNBRemote *this, char *__s1)
{
  if (*((unsigned char *)this + 782))
  {
    if (__s1)
    {
      unint64_t result = strstr(__s1, "thread:");
      if (result)
      {
        uint64_t v3 = result + 7;
        return (char *)strtoul(v3, 0, 16);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unint64_t result = (char *)*((void *)this + 68);
    if ((unint64_t)(result + 1) <= 1)
    {
      int v5 = *((_DWORD *)this + 3);
      return (char *)DNBProcessGetCurrentThread(v5);
    }
  }
  return result;
}

uint64_t GetProcessNameFrom_vAttach(char **a1, std::string *a2)
{
  int v2 = *a1;
  char v3 = **a1;
  if (!v3) {
    return 1;
  }
  while (1)
  {
    __str[0] = v3;
    __str[1] = v2[1];
    __str[2] = 0;
    *__error() = 0;
    int v6 = strtoul(__str, 0, 16);
    if (*__error() && v6 == 0) {
      break;
    }
    std::string::push_back(a2, v6);
    int v2 = *a1 + 2;
    *a1 = v2;
    char v3 = *v2;
    if (!*v2) {
      return 1;
    }
  }
  return 0;
}

BOOL RNBRemoteShouldCancelCallback(void *a1)
{
  uint64_t v1 = g_remoteSP;
  int v2 = (std::__shared_weak_count *)qword_1000796A0;
  if (qword_1000796A0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1000796A0 + 8), 1uLL, memory_order_relaxed);
  }
  if (v1)
  {
    BOOL v3 = *(_DWORD *)(v1 + 472) == -1;
    if (!v2) {
      return v3;
    }
  }
  else
  {
    BOOL v3 = 1;
    if (!v2) {
      return v3;
    }
  }
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return v3;
}

std::string *DNBError::SetErrorString(std::string *this, const char *a2)
{
  if (a2 && *a2) {
    return std::string::assign((std::string *)&this->__r_.__value_.__r.__words[1], a2);
  }
  if (this[1].__r_.__value_.__s.__data_[7] < 0)
  {
    *(unsigned char *)this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    this->__r_.__value_.__s.__data_[8] = 0;
    this[1].__r_.__value_.__s.__data_[7] = 0;
  }
  return this;
}

BOOL process_does_not_exist(int a1)
{
  int v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  DNBGetAllInfos(&v10);
  if (v11 == v10)
  {
    BOOL v4 = 1;
    if (!v10) {
      return v4;
    }
  }
  else
  {
    unint64_t v2 = (v11 - v10) / 648;
    if (v2 <= 1) {
      uint64_t v3 = 1;
    }
    else {
      uint64_t v3 = (v11 - v10) / 648;
    }
    if (*((_DWORD *)v10 + 10) == a1)
    {
      BOOL v4 = 0;
    }
    else
    {
      unint64_t v5 = 0;
      int v6 = v10 + 688;
      uint64_t v7 = v3 - 1;
      while (v7 != v5)
      {
        int v8 = *(_DWORD *)v6;
        v6 += 648;
        ++v5;
        if (v8 == a1)
        {
          BOOL v4 = v5 >= v2;
          goto LABEL_14;
        }
      }
      BOOL v4 = 1;
    }
  }
LABEL_14:
  unint64_t v11 = v10;
  operator delete(v10);
  return v4;
}

BOOL process_is_already_being_debugged(int a1)
{
  BOOL result = 0;
  if (DNBProcessIsBeingDebugged(a1))
  {
    int v2 = DNBGetParentProcessID(a1);
    if (v2 != getpid()) {
      return 1;
    }
  }
  return result;
}

uint64_t attach_failed_due_to_uid_mismatch(int a1, unsigned int *a2, unsigned int *a3)
{
  *(void *)int v8 = 0xE00000001;
  int v9 = 1;
  int v10 = a1;
  size_t v7 = 648;
  if (sysctl(v8, 4u, v11, &v7, 0, 0)) {
    return 0;
  }
  uint64_t result = geteuid();
  *a2 = result;
  if (result)
  {
    unsigned int v6 = v12;
    *a3 = v12;
    return *a2 != v6;
  }
  return result;
}

void *XMLElementStart(uint64_t *a1, int a2, const char *a3, char a4)
{
  if (a2)
  {
    uint64_t v8 = *a1;
    int v9 = (char *)a1 + *(void *)(*a1 - 24);
    if (*((_DWORD *)v9 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      int v10 = std::locale::use_facet(&v16, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v16);
      uint64_t v8 = *a1;
    }
    *((_DWORD *)v9 + 36) = 32;
    *(uint64_t *)((char *)a1 + *(void *)(v8 - 24) + 24) = a2;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&unk_10005A589, 0);
  }
  LOBYTE(v16.__locale_) = 60;
  unint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v16, 1);
  size_t v12 = strlen(a3);
  uint64_t result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)a3, v12);
  if ((a4 & 1) == 0)
  {
    LOBYTE(v16.__locale_) = 62;
    unint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v16, 1);
    std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
    long long v15 = std::locale::use_facet(&v16, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
    std::locale::~locale(&v16);
    std::ostream::put();
    return (void *)std::ostream::flush();
  }
  return result;
}

uint64_t XMLElementEnd(uint64_t *a1, int a2, const char *a3)
{
  if (a2)
  {
    uint64_t v6 = *a1;
    size_t v7 = (char *)a1 + *(void *)(*a1 - 24);
    if (*((_DWORD *)v7 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v8 = std::locale::use_facet(&v16, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
      std::locale::~locale(&v16);
      uint64_t v6 = *a1;
    }
    *((_DWORD *)v7 + 36) = 32;
    *(uint64_t *)((char *)a1 + *(void *)(v6 - 24) + 24) = a2;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&unk_10005A589, 0);
  }
  LOBYTE(v16.__locale_) = 60;
  int v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v16, 1);
  LOBYTE(v16.__locale_) = 47;
  int v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)&v16, 1);
  size_t v11 = strlen(a3);
  size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)a3, v11);
  LOBYTE(v16.__locale_) = 62;
  unint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)&v16, 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
  unint64_t v14 = std::locale::use_facet(&v16, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale(&v16);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t XMLAttributeString(uint64_t result, const char *a2, char *__s1, char *__s2)
{
  if (__s1)
  {
    uint64_t v6 = (void *)result;
    if (!__s2 || (uint64_t result = strcmp(__s1, __s2), result))
    {
      char v13 = 32;
      size_t v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)&v13, 1);
      size_t v8 = strlen(a2);
      int v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)a2, v8);
      int v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)"=\"", 2);
      size_t v11 = strlen(__s1);
      size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)__s1, v11);
      return (uint64_t)std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"\"", 1);
    }
  }
  return result;
}

void *XMLAttributeUnsignedDecimal(void *a1, const char *a2)
{
  char v12 = 32;
  uint64_t v3 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v12, 1);
  size_t v4 = strlen(a2);
  unint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)a2, v4);
  uint64_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)"=\"", 2);
  uint64_t v7 = *v6;
  *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(*v6 - 24) + 8) & 0xFFFFFFB5 | 2;
  size_t v8 = (char *)v6 + *(void *)(v7 - 24);
  if (*((_DWORD *)v8 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(v7 - 24)));
    int v9 = std::locale::use_facet(&v13, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
    std::locale::~locale(&v13);
  }
  *((_DWORD *)v8 + 36) = 32;
  int v10 = (void *)std::ostream::operator<<();
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"\"", 1);
}

uint64_t GenerateTargetXMLRegister(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v7 = *(unsigned __int16 *)(a5 + 32);
  if (v7 == 4)
  {
    int v9 = "vector";
    if (*(_DWORD *)(a5 + 8)) {
      size_t v8 = "vector";
    }
    else {
      size_t v8 = "general";
    }
  }
  else if (v7 == 3)
  {
    if (*(_DWORD *)(a5 + 8)) {
      size_t v8 = "float";
    }
    else {
      size_t v8 = "general";
    }
    int v9 = "ieee754";
  }
  else
  {
    size_t v8 = "general";
    if (v7 == 2) {
      int v9 = "sint";
    }
    else {
      int v9 = "uint";
    }
  }
  unsigned int v10 = *(unsigned __int16 *)(a5 + 34) - 1;
  if (v10 > 0xB)
  {
    std::locale v13 = "hex";
    char v12 = "int";
  }
  else
  {
    uint64_t v11 = (__int16)v10;
    char v12 = off_100069018[v11];
    std::locale v13 = off_100069078[v11];
  }
  XMLElementStart(a1, 2, "reg", 1);
  XMLAttributeString((uint64_t)a1, "name", *(char **)(a5 + 16), 0);
  XMLAttributeUnsignedDecimal(a1, "regnum");
  XMLAttributeUnsignedDecimal(a1, "offset");
  XMLAttributeUnsignedDecimal(a1, "bitsize");
  LOBYTE(v46.__locale_) = 32;
  unint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v46, 1);
  long long v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"group", 5);
  std::locale v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)"=\"", 2);
  size_t v17 = strlen(v8);
  unint64_t v18 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v8, v17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"\"", 1);
  XMLAttributeString((uint64_t)a1, "type", v12, "int");
  XMLAttributeString((uint64_t)a1, "altname", *(char **)(a5 + 24), 0);
  XMLAttributeString((uint64_t)a1, "encoding", v9, "uint");
  XMLAttributeString((uint64_t)a1, "format", v13, "hex");
  XMLAttributeUnsignedDecimal(a1, "group_id");
  if (*(_DWORD *)(a5 + 44) != -1) {
    XMLAttributeUnsignedDecimal(a1, "ehframe_regnum");
  }
  if (*(_DWORD *)(a5 + 48) != -1) {
    XMLAttributeUnsignedDecimal(a1, "dwarf_regnum");
  }
  uint64_t v19 = *(int *)(a5 + 52);
  if (v19 > 0xC) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = off_1000690D8[v19];
  }
  XMLAttributeString((uint64_t)a1, "generic", v20, 0);
  if (*(void *)(a5 + 80) == *(void *)(a5 + 88))
  {
    uint64_t v30 = *(void *)(a5 + 104);
    uint64_t v31 = *(void *)(a5 + 112);
    if (v30 == v31) {
      goto LABEL_52;
    }
  }
  else
  {
    *(std::locale::__imp **)((char *)&v46.__locale_ + *((void *)v46.__locale_ - 3)) = v21;
    mach_vm_address_t v22 = (std::ios_base *)((char *)&v46 + *((void *)v46.__locale_ - 3));
    std::ios_base::init(v22, v47);
    v22[1].__vftable = 0;
    v22[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)std::string __p = 0u;
    long long v49 = 0u;
    int v50 = 16;
    locale = v46.__locale_;
    *(_DWORD *)((char *)&v46 + *((void *)v46.__locale_ - 3) + 8) = *(_DWORD *)((char *)&v46
                                                                               + *((void *)v46.__locale_ - 3)
                                                                               + 8) & 0xFFFFFFB5 | 2;
    size_t v24 = (char *)&v46 + *((void *)locale - 3);
    if (*((_DWORD *)v24 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v46 + *((void *)locale - 3)));
      uint64_t v25 = std::locale::use_facet(&v44, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 32);
      std::locale::~locale(&v44);
    }
    *((_DWORD *)v24 + 36) = 32;
    uint64_t v26 = *(void *)(a5 + 80);
    uint64_t v27 = *(void *)(a5 + 88);
    if (v26 != v27)
    {
      uint64_t v28 = v26 + 4;
      std::ostream::operator<<();
      while (v28 != v27)
      {
        v28 += 4;
        LOBYTE(v44.__locale_) = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)&v44, 1);
        std::ostream::operator<<();
      }
    }
    std::stringbuf::str();
    if (v45 >= 0) {
      long long v29 = (char *)&v44;
    }
    else {
      long long v29 = (char *)v44.__locale_;
    }
    XMLAttributeString((uint64_t)a1, "value_regnums", v29, 0);
    if (v45 < 0) {
      operator delete(v44.__locale_);
    }
    if (SBYTE7(v49) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    uint64_t v30 = *(void *)(a5 + 104);
    uint64_t v31 = *(void *)(a5 + 112);
  }
  if (v30 != v31)
  {
    *(std::locale::__imp **)((char *)&v46.__locale_ + *((void *)v46.__locale_ - 3)) = v32;
    uint64_t v33 = (std::ios_base *)((char *)&v46 + *((void *)v46.__locale_ - 3));
    std::ios_base::init(v33, v47);
    v33[1].__vftable = 0;
    v33[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf();
    *(_OWORD *)std::string __p = 0u;
    long long v49 = 0u;
    int v50 = 16;
    int64_t v34 = v46.__locale_;
    *(_DWORD *)((char *)&v46 + *((void *)v46.__locale_ - 3) + 8) = *(_DWORD *)((char *)&v46
                                                                               + *((void *)v46.__locale_ - 3)
                                                                               + 8) & 0xFFFFFFB5 | 2;
    unsigned int v35 = (char *)&v46 + *((void *)v34 - 3);
    if (*((_DWORD *)v35 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v46 + *((void *)v34 - 3)));
      uint64_t v36 = std::locale::use_facet(&v44, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 32);
      std::locale::~locale(&v44);
    }
    *((_DWORD *)v35 + 36) = 32;
    uint64_t v37 = *(void *)(a5 + 104);
    uint64_t v38 = *(void *)(a5 + 112);
    if (v37 != v38)
    {
      uint64_t v39 = v37 + 4;
      std::ostream::operator<<();
      while (v39 != v38)
      {
        v39 += 4;
        LOBYTE(v44.__locale_) = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)&v44, 1);
        std::ostream::operator<<();
      }
    }
    std::stringbuf::str();
    if (v45 >= 0) {
      uint64_t v40 = (char *)&v44;
    }
    else {
      uint64_t v40 = (char *)v44.__locale_;
    }
    XMLAttributeString((uint64_t)a1, "invalidate_regnums", v40, 0);
    if (v45 < 0) {
      operator delete(v44.__locale_);
    }
    if (SBYTE7(v49) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
LABEL_52:
  LOBYTE(v46.__locale_) = 47;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v46, 1);
  LOBYTE(v46.__locale_) = 62;
  uint64_t v41 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v46, 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v41 + *(void *)(*v41 - 24)));
  unint64_t v42 = std::locale::use_facet(&v46, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v42->__vftable[2].~facet_0)(v42, 10);
  std::locale::~locale(&v46);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t GenerateTargetXMLRegisters(uint64_t *a1)
{
  unint64_t v31 = 0;
  uint64_t v2 = DNBGetRegisterSetInfo(&v31);
  uint64_t result = DNBGetRegisterCPUType();
  if (!result) {
    return result;
  }
  int v4 = result;
  LOBYTE(v25) = 60;
  unint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v25, 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)"feature", 7);
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v25 + (void)*(v25 - 3)) = v6;
  int v7 = (std::ios_base *)((char *)&v25 + (void)*(v25 - 3));
  std::ios_base::init(v7, &v26);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)uint64_t v27 = 0u;
  long long v28 = 0u;
  int v29 = 16;
  int v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v25, (uint64_t)"com.apple.debugserver.", 22);
  if (v4 <= 16777222)
  {
    if (v4 == 7)
    {
      unsigned int v10 = "i386";
      goto LABEL_14;
    }
    if (v4 == 12)
    {
      unsigned int v10 = "arm";
      goto LABEL_14;
    }
LABEL_13:
    unsigned int v10 = 0;
    goto LABEL_14;
  }
  if (v4 == 16777223)
  {
    unsigned int v10 = "x86_64";
    goto LABEL_14;
  }
  if (v4 == 33554444)
  {
    unsigned int v10 = "arm64_32";
    goto LABEL_14;
  }
  if (v4 != 16777228) {
    goto LABEL_13;
  }
  unsigned int v10 = "arm64";
LABEL_14:
  size_t v11 = strlen(v10);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  std::stringbuf::str();
  if (v24 >= 0) {
    char v12 = (char *)__p;
  }
  else {
    char v12 = (char *)__p[0];
  }
  XMLAttributeString((uint64_t)a1, "name", v12, 0);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  LOBYTE(__p[0]) = 62;
  std::locale v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)__p, 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
  unint64_t v14 = std::locale::use_facet((const std::locale *)__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  if (g_num_reg_entries)
  {
    unint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      GenerateTargetXMLRegister(a1, v18, v15, v16, g_reg_entries + (v17 << 7));
      unint64_t v17 = (v18 + 1);
      uint64_t v18 = v17;
    }
    while (g_num_reg_entries > v17);
  }
  XMLElementEnd(a1, 0, "feature");
  if (v31)
  {
    XMLElementStart(a1, 0, "groups", 0);
    if (v31 >= 2)
    {
      unsigned int v19 = 2;
      for (unint64_t i = 1; i < v31; unint64_t i = v19++)
      {
        XMLElementStart(a1, 2, "group", 1);
        XMLAttributeUnsignedDecimal(a1, "id");
        XMLAttributeString((uint64_t)a1, "name", *(char **)(v2 + 24 * i), 0);
        LOBYTE(__p[0]) = 47;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)__p, 1);
        LOBYTE(__p[0]) = 62;
        char v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)__p, 1);
        std::ios_base::getloc((const std::ios_base *)((char *)v21 + *(void *)(*v21 - 24)));
        mach_vm_address_t v22 = std::locale::use_facet((const std::locale *)__p, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10);
        std::locale::~locale((std::locale *)__p);
        std::ostream::put();
        std::ostream::flush();
      }
    }
    XMLElementEnd(a1, 0, "groups");
  }
  uint64_t v26 = v8;
  if (SBYTE7(v28) < 0) {
    operator delete(v27[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

uint64_t UpdateTargetXML(void)
{
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v9 + (void)*(v9 - 3)) = (void (__cdecl **)(std::ostringstream *__hidden))v0;
  uint64_t v1 = (std::ios_base *)((char *)&v9 + (void)*(v9 - 3));
  std::ios_base::init(v1, &v10);
  v1[1].__vftable = 0;
  v1[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)std::string __p = 0u;
  long long v12 = 0u;
  int v13 = 16;
  uint64_t v2 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v9, (uint64_t)"<?xml version=\"1.0\"?>\n<target version=\"1.0\">", 44);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  uint64_t v3 = std::locale::use_facet((const std::locale *)&v7, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale((std::locale *)&v7);
  std::ostream::put();
  std::ostream::flush();
  GenerateTargetXMLRegisters((uint64_t *)&v9);
  int v4 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v9, (uint64_t)"</target>", 9);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  unint64_t v5 = std::locale::use_facet((const std::locale *)&v7, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale((std::locale *)&v7);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  if (byte_10047986F < 0) {
    operator delete((void *)g_target_xml);
  }
  g_target_xml = v7;
  unk_100479868 = v8;
  if (SBYTE7(v12) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

uint64_t get_integer_value_for_key_name_from_json(std::string::value_type *__s, char *a2)
{
  *((unsigned char *)&v14.__r_.__value_.__s + 23) = 1;
  LOWORD(v14.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v14, __s);
  std::string::append(&v14, "\"");
  unsigned __int8 v3 = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
  {
    int v4 = strstr(a2, v14.__r_.__value_.__l.__data_);
    if (!v4)
    {
      unint64_t v12 = -1;
LABEL_24:
      operator delete(v14.__r_.__value_.__l.__data_);
      return v12;
    }
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
LABEL_6:
    for (unint64_t i = &v4[size + 1]; ; ++i)
    {
      uint64_t v7 = *((unsigned __int8 *)i - 1);
      if (v7 > 0x3A) {
        goto LABEL_16;
      }
      if (((1 << v7) & 0x100002600) == 0) {
        break;
      }
    }
    if (v7 != 58)
    {
LABEL_16:
      unint64_t v12 = -1;
      if ((v3 & 0x80) == 0) {
        return v12;
      }
      goto LABEL_24;
    }
    while (1)
    {
      unsigned int v8 = *(unsigned __int8 *)i;
      BOOL v9 = v8 > 0x20;
      uint64_t v10 = (1 << v8) & 0x100002600;
      if (v9 || v10 == 0) {
        break;
      }
      ++i;
    }
    *__error() = 0;
    unint64_t v12 = strtoul(i, 0, 10);
    if (*__error()) {
      unint64_t v12 = -1;
    }
    if ((*((unsigned char *)&v14.__r_.__value_.__s + 23) & 0x80) == 0) {
      return v12;
    }
    goto LABEL_24;
  }
  int v4 = strstr(a2, (const char *)&v14);
  if (v4)
  {
    std::string::size_type size = v3;
    goto LABEL_6;
  }
  return -1;
}

uint64_t get_BOOLean_value_for_key_name_from_json(std::string::value_type *__s, char *a2, BOOL *a3)
{
  *((unsigned char *)&v18.__r_.__value_.__s + 23) = 1;
  LOWORD(v18.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v18, __s);
  std::string::append(&v18, "\"");
  std::string::size_type v5 = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v6 = strstr(a2, v18.__r_.__value_.__l.__data_);
    if (!v6)
    {
      uint64_t v14 = 0;
LABEL_25:
      operator delete(v18.__r_.__value_.__l.__data_);
      return v14;
    }
    std::string::size_type size = v18.__r_.__value_.__l.__size_;
  }
  else
  {
    uint64_t v6 = strstr(a2, (const char *)&v18);
    if (!v6) {
      return 0;
    }
    std::string::size_type size = v5;
  }
  for (unint64_t i = &v6[size + 1]; ; ++i)
  {
    uint64_t v9 = *((unsigned __int8 *)i - 1);
    if (v9 > 0x3A) {
      goto LABEL_16;
    }
    if (((1 << v9) & 0x100002600) == 0) {
      break;
    }
  }
  if (v9 != 58)
  {
LABEL_16:
    uint64_t v14 = 0;
    goto LABEL_24;
  }
  while (1)
  {
    unsigned int v10 = *(unsigned __int8 *)i;
    BOOL v11 = v10 > 0x20;
    uint64_t v12 = (1 << v10) & 0x100002600;
    if (v11 || v12 == 0) {
      break;
    }
    ++i;
  }
  if (!strncmp(i, "true", 4uLL))
  {
    BOOL v16 = 1;
  }
  else
  {
    int v15 = strncmp(i, "false", 5uLL);
    uint64_t v14 = 0;
    if (v15) {
      goto LABEL_24;
    }
    BOOL v16 = 0;
  }
  *a3 = v16;
  uint64_t v14 = 1;
LABEL_24:
  if ((v5 & 0x80) != 0) {
    goto LABEL_25;
  }
  return v14;
}

uint64_t get_array_of_ints_value_for_key_name_from_json(std::string::value_type *__s, char *a2, uint64_t a3)
{
  *((unsigned char *)&v44.__r_.__value_.__s + 23) = 1;
  LOWORD(v44.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v44, __s);
  std::string::append(&v44, "\"");
  unsigned __int8 v5 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v6 = strstr(a2, v44.__r_.__value_.__l.__data_);
    if (!v6) {
      goto LABEL_65;
    }
    std::string::size_type size = v44.__r_.__value_.__l.__size_;
  }
  else
  {
    uint64_t v6 = strstr(a2, (const char *)&v44);
    if (!v6) {
      return 0;
    }
    std::string::size_type size = v5;
  }
  for (unint64_t i = &v6[size + 2]; ; ++i)
  {
    uint64_t v9 = *((unsigned __int8 *)i - 2);
    if (v9 > 0x3A) {
      break;
    }
    if (((1 << v9) & 0x100002600) == 0)
    {
      if (v9 != 58) {
        break;
      }
      while (1)
      {
        unsigned int v10 = *((unsigned __int8 *)i - 1);
        if (v10 > 0x20 || ((1 << v10) & 0x100002600) == 0) {
          break;
        }
        ++i;
      }
      if (v10 != 91) {
        break;
      }
      while (1)
      {
        uint64_t v12 = *(unsigned __int8 *)i;
        if (v12 > 0x20 || ((1 << v12) & 0x100002600) == 0) {
          break;
        }
        ++i;
      }
      if ((v12 & 0x80) == 0)
      {
        while ((_DefaultRuneLocale.__runetype[v12] & 0x400) != 0)
        {
          *__error() = 0;
          std::string __endptr = 0;
          unint64_t v15 = strtoul(i, &__endptr, 10);
          if (*__error()) {
            goto LABEL_65;
          }
          unint64_t v17 = *(unint64_t **)(a3 + 8);
          unint64_t v16 = *(void *)(a3 + 16);
          if ((unint64_t)v17 >= v16)
          {
            unsigned int v19 = *(unint64_t **)a3;
            uint64_t v20 = (uint64_t)v17 - *(void *)a3;
            uint64_t v21 = v20 >> 3;
            unint64_t v22 = (v20 >> 3) + 1;
            if (v22 >> 61) {
              abort();
            }
            uint64_t v23 = v16 - (void)v19;
            if (v23 >> 2 > v22) {
              unint64_t v22 = v23 >> 2;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
            }
            unint64_t v42 = v22;
            if (v22)
            {
              if (v22 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              char v24 = operator new(8 * v22);
            }
            else
            {
              char v24 = 0;
            }
            uint64_t v25 = (unint64_t *)&v24[8 * v21];
            *uint64_t v25 = v15;
            std::string v18 = v25 + 1;
            if (v17 != v19)
            {
              unint64_t v26 = (char *)v17 - (char *)v19 - 8;
              if (v26 < 0x58) {
                goto LABEL_75;
              }
              if ((unint64_t)((char *)v17 - v24 - v20) < 0x20) {
                goto LABEL_75;
              }
              uint64_t v27 = (v26 >> 3) + 1;
              uint64_t v28 = 8 * (v27 & 0x3FFFFFFFFFFFFFFCLL);
              int v29 = &v17[v28 / 0xFFFFFFFFFFFFFFF8];
              uint64_t v25 = (unint64_t *)((char *)v25 - v28);
              uint64_t v30 = &v24[8 * v21 - 16];
              unint64_t v31 = v17 - 2;
              uint64_t v32 = v27 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v33 = *(_OWORD *)v31;
                *(v30 - 1) = *((_OWORD *)v31 - 1);
                _OWORD *v30 = v33;
                v30 -= 2;
                v31 -= 4;
                v32 -= 4;
              }
              while (v32);
              unint64_t v17 = v29;
              if (v27 != (v27 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_75:
                do
                {
                  unint64_t v34 = *--v17;
                  *--uint64_t v25 = v34;
                }
                while (v17 != v19);
              }
            }
            *(void *)a3 = v25;
            *(void *)(a3 + 8) = v18;
            *(void *)(a3 + 16) = &v24[8 * v42];
            if (v19) {
              operator delete(v19);
            }
          }
          else
          {
            *unint64_t v17 = v15;
            std::string v18 = v17 + 1;
          }
          *(void *)(a3 + 8) = v18;
          unsigned int v35 = __endptr;
          if (__endptr == i || __endptr == 0) {
            goto LABEL_65;
          }
          unsigned int v37 = *__endptr;
          if (!*__endptr) {
            goto LABEL_65;
          }
          if (v37 <= 0x20)
          {
            do
            {
              if (((1 << v37) & 0x100002600) == 0) {
                break;
              }
              unsigned int v38 = *++v35;
              unsigned int v37 = v38;
            }
            while (v38 <= 0x20);
          }
          if (v37 == 44) {
            unint64_t i = v35 + 1;
          }
          else {
            unint64_t i = v35;
          }
          while (1)
          {
            unsigned int v39 = *(unsigned __int8 *)i;
            if (v39 > 0x20 || ((1 << v39) & 0x100002600) == 0) {
              break;
            }
            ++i;
          }
          if (v39 == 93) {
            break;
          }
          uint64_t v12 = *(unsigned __int8 *)i;
          uint64_t v14 = 1;
          if (*i < 0) {
            goto LABEL_66;
          }
        }
      }
      uint64_t v14 = 1;
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v14;
      }
      goto LABEL_67;
    }
  }
LABEL_65:
  uint64_t v14 = 0;
LABEL_66:
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
LABEL_67:
  }
    operator delete(v44.__r_.__value_.__l.__data_);
  return v14;
}

void JSONGenerator::Dictionary::AddIntegerItem(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v2, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v2 = *(std::string *)a2;
  }
  operator new();
}

void JSONGenerator::Dictionary::AddItem(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  uint64_t v5 = a3[1];
  *(void *)&long long v11 = *a3;
  *((void *)&v11 + 1) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = *(void *)(a1 + 40);
  if (v6 < *(void *)(a1 + 48))
  {
    long long v7 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(v6 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v6 = v7;
    memset(&__p, 0, sizeof(__p));
    *(_OWORD *)(v6 + 24) = v11;
    long long v11 = 0uLL;
    *(void *)(a1 + 40) = v6 + 40;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_12;
  }
  unsigned int v8 = std::vector<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>::__push_back_slow_path<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>((void **)(a1 + 32), (uint64_t)&__p);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  *(void *)(a1 + 40) = v8;
  if (!v9 || atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_12:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void JSONGenerator::Dictionary::AddStringItem(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v2, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v2 = *(std::string *)a2;
  }
  operator new();
}

void JSONGenerator::Dictionary::AddBooleanItem(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v2, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v2 = *(std::string *)a2;
  }
  operator new();
}

void JSONGenerator::Dictionary::AddBytesAsHexASCIIString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    if (a4)
    {
      uint64_t v5 = a3;
      *(void *)((char *)&v16[-1] + (void)*(v15 - 3)) = v6;
      long long v7 = (std::ios_base *)((char *)&v16[-1] + (void)*(v15 - 3));
      std::ios_base::init(v7, v16);
      v7[1].__vftable = 0;
      v7[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf();
      long long __p = 0u;
      long long v18 = 0u;
      int v19 = 16;
      while (1)
      {
        unsigned int v8 = v15;
        uint64_t v9 = (char *)&v16[-1] + (void)*(v15 - 3);
        if (*((_DWORD *)v9 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v16[-1] + (void)*(v15 - 3)));
          unsigned int v10 = std::locale::use_facet(v13, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
          std::locale::~locale(v13);
          unsigned int v8 = v15;
        }
        *((_DWORD *)v9 + 36) = 48;
        *(_DWORD *)((char *)v16 + (void)*(v8 - 3)) = *(_DWORD *)((unsigned char *)v16 + (void)*(v8 - 3)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)v16 + (void)*(v8 - 3)) = *(_DWORD *)((unsigned char *)v16 + (void)*(v8 - 3)) & 0xFFFFFF4F | 0x80;
        *(void *)((char *)&v16[2] + (void)*(v8 - 3)) = 2;
        ++v5;
        std::ostream::operator<<();
        if (!--v4)
        {
          if (*(char *)(a2 + 23) < 0) {
            std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
          }
          else {
            std::string v14 = *(std::string *)a2;
          }
          operator new();
        }
      }
    }
  }
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v12 = *(std::string *)a2;
  }
  operator new();
}

uint64_t RNBRemote::Packet::Packet(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *__s, const char *a8)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  size_t v11 = strlen(__s);
  if (v11 > 0x7FFFFFFFFFFFFFF7) {
LABEL_18:
  }
    abort();
  size_t v12 = v11;
  if (v11 >= 0x17)
  {
    uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v14 = v11 | 7;
    }
    uint64_t v15 = v14 + 1;
    int v13 = operator new(v14 + 1);
    *(void *)(a1 + 48) = v12;
    *(void *)(a1 + 56) = v15 | 0x8000000000000000;
    *(void *)(a1 + 40) = v13;
    goto LABEL_8;
  }
  int v13 = (void *)(a1 + 40);
  *(unsigned char *)(a1 + 63) = v11;
  if (v11) {
LABEL_8:
  }
    memmove(v13, __s, v12);
  *((unsigned char *)v13 + v12) = 0;
  size_t v16 = strlen(a8);
  if (v16 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_18;
  }
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    long long v18 = operator new(v19 + 1);
    *(void *)(a1 + 72) = v17;
    *(void *)(a1 + 80) = v20 | 0x8000000000000000;
    *(void *)(a1 + 64) = v18;
  }
  else
  {
    long long v18 = (void *)(a1 + 64);
    *(unsigned char *)(a1 + 87) = v16;
    if (!v16) {
      goto LABEL_17;
    }
  }
  memmove(v18, a8, v17);
LABEL_17:
  *((unsigned char *)v18 + v17) = 0;
  return a1;
}

void DNBTimer::DNBTimer(DNBTimer *this, int a2)
{
  *(void *)this = 0;
  if (a2) {
    operator new();
  }
  gettimeofday((timeval *)((char *)this + 8), 0);
}

void JSONGenerator::Dictionary::~Dictionary(JSONGenerator::Dictionary *this)
{
  JSONGenerator::Dictionary::~Dictionary(this);

  operator delete();
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;

  *(void *)this = off_100068D60;
  std::string v2 = *((void *)this + 4);
  if (v2)
  {
    unsigned __int8 v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        if (*(char *)(v3 - 17) < 0) {
          operator delete(*(void **)(v3 - 40));
        }
        v3 -= 40;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

uint64_t JSONGenerator::Object::IsValid(JSONGenerator::Object *this)
{
  return 1;
}

uint64_t JSONGenerator::Object::Clear(uint64_t this)
{
  *(_DWORD *)(this + 24) = -1;
  return this;
}

void *JSONGenerator::Dictionary::Dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"{", 1);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 != *(void *)(a1 + 40))
  {
    uint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\"", 1);
    uint64_t v6 = (const char *)v4;
    if (*(char *)(v4 + 23) < 0) {
      uint64_t v6 = *(const char **)v4;
    }
    size_t v7 = strlen(v6);
    unsigned int v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)v6, v7);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"\":", 2);
    (*(void (**)(void, void *))(**(void **)(v4 + 24) + 32))(*(void *)(v4 + 24), a2);
    for (uint64_t i = v4 + 40; i != *(void *)(a1 + 40); i += 40)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1);
      size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\"", 1);
      int v13 = (const char *)i;
      if (*(char *)(i + 23) < 0) {
        int v13 = *(const char **)i;
      }
      size_t v10 = strlen(v13);
      size_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, v10);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"\":", 2);
      (*(void (**)(void, void *))(**(void **)(i + 24) + 32))(*(void *)(i + 24), a2);
    }
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"}", 1);
}

void *JSONGenerator::Dictionary::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"{", 1);
  uint64_t v4 = *(unsigned __int8 **)(a1 + 32);
  if (v4 != *(unsigned __int8 **)(a1 + 40))
  {
    char v5 = 0;
    do
    {
      if (v5) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1);
      }
      uint64_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\"", 1);
      memset(&v21, 0, sizeof(v21));
      int v7 = (char)v4[23];
      if (v7 >= 0) {
        uint64_t v8 = v4[23];
      }
      else {
        uint64_t v8 = *((void *)v4 + 1);
      }
      if (v7 >= 0) {
        uint64_t v9 = v4;
      }
      else {
        uint64_t v9 = *(unsigned __int8 **)v4;
      }
      if (v8)
      {
        do
        {
          unsigned int v14 = *v9++;
          unsigned int v13 = v14;
          uint64_t v15 = (1 << v14) & 0x41800000000;
          BOOL v16 = v14 > 0x2A || v15 == 0;
          if (!v16 || v13 == 125)
          {
            std::string::push_back(&v21, 125);
            LOBYTE(v13) = v13 ^ 0x20;
          }
          std::string::push_back(&v21, v13);
          --v8;
        }
        while (v8);
        uint64_t v12 = HIBYTE(v21.__r_.__value_.__r.__words[2]);
        std::string::size_type size = v21.__r_.__value_.__l.__size_;
        std::string::size_type v11 = v21.__r_.__value_.__r.__words[0];
      }
      else
      {
        std::string::size_type size = 0;
        std::string::size_type v11 = 0;
        uint64_t v12 = 0;
      }
      if ((v12 & 0x80u) == 0) {
        size_t v17 = &v21;
      }
      else {
        size_t v17 = (std::string *)v11;
      }
      if ((v12 & 0x80u) == 0) {
        uint64_t v18 = v12;
      }
      else {
        uint64_t v18 = size;
      }
      uint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)v17, v18);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"\":", 2);
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v21.__r_.__value_.__l.__data_);
      }
      (*(void (**)(void, void *))(**((void **)v4 + 3) + 40))(*((void *)v4 + 3), a2);
      v4 += 40;
      char v5 = 1;
    }
    while (v4 != *(unsigned __int8 **)(a1 + 40));
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"}", 1);
  v21.__r_.__value_.__s.__data_[0] = 93;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v21, 1);
}

void std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void JSONGenerator::Array::~Array(JSONGenerator::Array *this)
{
  *(void *)this = off_100068DD8;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        char v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t vars8;

  *(void *)this = off_100068DD8;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        char v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  operator delete();
}

void *JSONGenerator::Array::Dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"[", 1);
  uint64_t v4 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    unint64_t v7 = v4 >> 4;
    if ((unint64_t)(v4 >> 4) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v4 >> 4;
    }
    do
    {
      (*(void (**)(void, void *))(**(void **)(*(void *)(a1 + 32) + v5) + 32))(*(void *)(*(void *)(a1 + 32) + v5), a2);
      if (++v6 < v7) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1);
      }
      v5 += 16;
    }
    while (v8 != v6);
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"]", 1);
}

void *JSONGenerator::Array::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"[", 1);
  uint64_t v4 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    unint64_t v7 = v4 >> 4;
    if ((unint64_t)(v4 >> 4) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v4 >> 4;
    }
    do
    {
      (*(void (**)(void, void *))(**(void **)(*(void *)(a1 + 32) + v5) + 40))(*(void *)(*(void *)(a1 + 32) + v5), a2);
      if (++v6 < v7) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1);
      }
      v5 += 16;
    }
    while (v8 != v6);
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"]", 1);
}

_OWORD *std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    abort();
  }
  uint64_t v7 = *(void *)(a1 + 16) - (void)v2;
  if (v7 >> 3 > v5) {
    unint64_t v5 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v5 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v9 = 16 * v5;
  size_t v10 = (char *)operator new(16 * v5);
  std::string::size_type v11 = &v10[16 * v4];
  long long v12 = *a2;
  *(_OWORD *)std::string::size_type v11 = *a2;
  if (*((void *)&v12 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 1uLL, memory_order_relaxed);
    uint64_t v2 = *(void **)a1;
    uint64_t v3 = *(void **)(a1 + 8);
  }
  unsigned int v13 = &v10[v9];
  unsigned int v14 = v11 + 16;
  if (v3 == v2)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v13;
  }
  else
  {
    do
    {
      long long v15 = *((_OWORD *)v3 - 1);
      v3 -= 2;
      *((_OWORD *)v11 - 1) = v15;
      v11 -= 16;
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    while (v3 != v2);
    uint64_t v2 = *(void **)a1;
    BOOL v16 = *(void **)(a1 + 8);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v14;
    for (*(void *)(a1 + 16) = v13; v16 != v2; v16 -= 2)
    {
      size_t v17 = (std::__shared_weak_count *)*(v16 - 1);
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

void JSONGenerator::Integer::~Integer(JSONGenerator::Integer *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t JSONGenerator::Integer::Dump()
{
  return std::ostream::operator<<();
}

uint64_t JSONGenerator::Integer::DumpBinaryEscaped(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

char *std::vector<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>::__push_back_slow_path<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x333333333333333) {
    unint64_t v5 = 0x666666666666666;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0x666666666666666) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v7 = 40 * v5;
  uint64_t v8 = (char *)operator new(40 * v5);
  uint64_t v9 = &v8[40 * v2];
  size_t v10 = &v8[v7];
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  *((void *)v9 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  std::string::size_type v11 = v9 + 40;
  long long v12 = (char *)*a1;
  unsigned int v13 = (char *)a1[1];
  if (v13 == *a1)
  {
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      long long v14 = *(_OWORD *)(v13 - 40);
      *((void *)v9 - 3) = *((void *)v13 - 3);
      *(_OWORD *)(v9 - 40) = v14;
      *((void *)v13 - 4) = 0;
      *((void *)v13 - 3) = 0;
      *((void *)v13 - 5) = 0;
      *((_OWORD *)v9 - 1) = *((_OWORD *)v13 - 1);
      v9 -= 40;
      *((void *)v13 - 2) = 0;
      *((void *)v13 - 1) = 0;
      v13 -= 40;
    }
    while (v13 != v12);
    unsigned int v13 = (char *)*a1;
    long long v15 = (char *)a1[1];
    *a1 = v9;
    a1[1] = v11;
    for (a1[2] = v10; v15 != v13; v15 -= 40)
    {
      BOOL v16 = (std::__shared_weak_count *)*((void *)v15 - 1);
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      if (*(v15 - 17) < 0) {
        operator delete(*((void **)v15 - 5));
      }
    }
  }
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void JSONGenerator::String::~String(void **this)
{
  *this = off_100068E58;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      return;
    }
  }
  else
  {
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      return;
    }
  }
  std::__shared_weak_count::__release_weak(v2);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *this = off_100068E58;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2)
    {
LABEL_4:
      operator delete();
    }
  }
  else
  {
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      goto LABEL_4;
    }
  }
  std::__shared_weak_count::__release_weak(v2);
  goto LABEL_4;
}

void *JSONGenerator::String::Dump(uint64_t a1, void *a2)
{
  char v9 = 34;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v9, 1);
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 55);
    if (!*(unsigned char *)(a1 + 55)) {
      goto LABEL_11;
    }
  }
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = a1 + 32;
    if (*(char *)(a1 + 55) < 0) {
      uint64_t v6 = *(void *)(a1 + 32);
    }
    int v7 = *(unsigned __int8 *)(v6 + v5);
    if (v7 == 34)
    {
      char v11 = 92;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v11, 1);
    }
    char v12 = v7;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v12, 1);
    ++v5;
  }
  while (v4 != v5);
LABEL_11:
  char v10 = 34;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v10, 1);
}

void *JSONGenerator::String::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  char v10 = 34;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v10, 1);
  if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 55);
    if (!*(unsigned char *)(a1 + 55)) {
      goto LABEL_17;
    }
    goto LABEL_5;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
LABEL_5:
    for (uint64_t i = 0; v4 != i; ++i)
    {
      uint64_t v7 = a1 + 32;
      if (*(char *)(a1 + 55) < 0) {
        uint64_t v7 = *(void *)(a1 + 32);
      }
      unsigned int v8 = *(unsigned __int8 *)(v7 + i);
      if (v8 > 0x29)
      {
        if (v8 != 42 && v8 != 125) {
          goto LABEL_16;
        }
      }
      else if (v8 - 35 >= 2)
      {
        if (v8 == 34)
        {
          char v12 = 92;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v12, 1);
        }
LABEL_16:
        char v15 = v8;
        uint64_t v6 = &v15;
        goto LABEL_7;
      }
      char v13 = 125;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v13, 1);
      char v14 = v8 ^ 0x20;
      uint64_t v6 = &v14;
LABEL_7:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v6, 1);
    }
  }
LABEL_17:
  char v11 = 34;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v11, 1);
}

void std::__shared_ptr_pointer<JSONGenerator::String *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::String>,std::allocator<JSONGenerator::String>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::String *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::String>,std::allocator<JSONGenerator::String>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void JSONGenerator::Boolean::~Boolean(JSONGenerator::Boolean *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *JSONGenerator::Boolean::Dump(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 28)) {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"true", 4);
  }
  else {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"false", 5);
  }
}

uint64_t JSONGenerator::Boolean::DumpBinaryEscaped(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

void std::__shared_ptr_pointer<JSONGenerator::Boolean *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Boolean>,std::allocator<JSONGenerator::Boolean>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Boolean *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Boolean>,std::allocator<JSONGenerator::Boolean>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  std::ostream::sentry::sentry();
  if (v13)
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = a2;
    }
    int v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      char v11 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v9, v8, v6, (char)v10)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  std::ostream::sentry::~sentry();
  return a1;
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        char v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v22 = v15 | 0x8000000000000000;
        __b[0] = v13;
      }
      else
      {
        HIBYTE(v22) = v12;
        char v13 = __b;
      }
      memset(v13, __c, v12);
      *((unsigned char *)v13 + v12) = 0;
      if (v22 >= 0) {
        BOOL v16 = __b;
      }
      else {
        BOOL v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0;
        }
      }
      else if (v17 != v12)
      {
        return 0;
      }
    }
    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0;
      return v6;
    }
    return 0;
  }
  return v6;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t std::deque<std::string>::~deque[abi:nn180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  unint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    std::string::size_type v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      unint64_t v2 = *(void ***)(a1 + 8);
      unint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *uint64_t v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
    goto LABEL_17;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 170;
LABEL_17:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(void **a1, uint64_t a2)
{
  uint64_t v2 = 0x2E8BA2E8BA2E8BA3 * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2E8BA2E8BA2E8BALL) {
    abort();
  }
  if (0x5D1745D1745D1746 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5D1745D1745D1746 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)) >= 0x1745D1745D1745DLL) {
    unint64_t v6 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2E8BA2E8BA2E8BALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v7 = (char *)operator new(88 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  unint64_t v9 = &v7[88 * v2];
  *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  unint64_t v10 = &v7[88 * v6];
  *((void *)v9 + 4) = *(void *)(a2 + 32);
  *(_OWORD *)(v9 + 40) = *(_OWORD *)(a2 + 40);
  *((void *)v9 + 7) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *((_OWORD *)v9 + 4) = *(_OWORD *)(a2 + 64);
  *((void *)v9 + 10) = *(void *)(a2 + 80);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  unint64_t v11 = v9 + 88;
  unint64_t v12 = (void **)*a1;
  uint64_t v13 = (void **)a1[1];
  if (v13 != *a1)
  {
    do
    {
      long long v14 = *(_OWORD *)(v13 - 11);
      long long v15 = *(_OWORD *)(v13 - 9);
      *((void *)v9 - 7) = *(v13 - 7);
      *(_OWORD *)(v9 - 72) = v15;
      *(_OWORD *)(v9 - 88) = v14;
      long long v16 = *((_OWORD *)v13 - 3);
      *((void *)v9 - 4) = *(v13 - 4);
      *((_OWORD *)v9 - 3) = v16;
      *(v13 - 5) = 0;
      *(v13 - 4) = 0;
      *(v13 - 6) = 0;
      long long v17 = *(_OWORD *)(v13 - 3);
      *((void *)v9 - 1) = *(v13 - 1);
      *(_OWORD *)(v9 - 24) = v17;
      v9 -= 88;
      *(v13 - 2) = 0;
      *(v13 - 1) = 0;
      *(v13 - 3) = 0;
      v13 -= 11;
    }
    while (v13 != v12);
    uint64_t v13 = (void **)*a1;
    uint64_t v18 = (void **)a1[1];
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
    while (1)
    {
      if (v18 == v13) {
        goto LABEL_22;
      }
      if (*((char *)v18 - 1) < 0)
      {
        operator delete(*(v18 - 3));
        if ((*((char *)v18 - 25) & 0x80000000) == 0) {
          goto LABEL_14;
        }
      }
      else if ((*((char *)v18 - 25) & 0x80000000) == 0)
      {
        goto LABEL_14;
      }
      operator delete(*(v18 - 6));
LABEL_14:
      v18 -= 11;
    }
  }
  *a1 = v9;
  a1[1] = v11;
  a1[2] = v10;
LABEL_22:
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void std::deque<std::string>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(void *)unint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        long long v33 = (char *)operator new(8 * v30);
        unint64_t v34 = &v33[8 * v31];
        unsigned int v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        unint64_t v5 = v34;
        if (!v36)
        {
          unint64_t v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            unint64_t v52 = &v33[8 * v31];
            unsigned int v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              uint64_t v53 = (v38 >> 3) + 1;
              uint64_t v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              unsigned int v39 = &v34[v54];
              v7 += v54;
              unint64_t v55 = (long long *)(v6 + 3);
              int16x8_t v56 = v52 + 16;
              uint64_t v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                *int16x8_t v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4;
              }
              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            unsigned int v39 = &v33[8 * v31];
          }
          do
          {
            uint64_t v59 = *(void *)v7;
            v7 += 8;
            *(void *)unsigned int v39 = v59;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_55;
      }
LABEL_65:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    long long v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unint64_t v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }
  uint64_t v18 = *(char **)(a1 + 8);
  long long v17 = *(char **)(a1 + 16);
  uint64_t v19 = v17 - v18;
  uint64_t v20 = (v17 - v18) >> 3;
  std::string v21 = *(char **)(a1 + 24);
  uint64_t v22 = (uint64_t)&v21[-*(void *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      int v68 = (char *)operator new(0xFF0uLL);
      std::__split_buffer<std::string *>::push_back((char **)a1, &v68);
      return;
    }
    int v68 = (char *)operator new(0xFF0uLL);
    std::__split_buffer<std::string *>::push_front((void **)a1, &v68);
    uint64_t v40 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_57;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        long long v33 = (char *)operator new(8 * v41);
        unint64_t v34 = &v33[8 * v42];
        unsigned int v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        unint64_t v5 = v34;
        if (!v36)
        {
          unint64_t v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            unint64_t v60 = &v33[8 * v42];
            std::locale v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              uint64_t v61 = (v45 >> 3) + 1;
              uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              std::locale v46 = &v34[v62];
              v7 += v62;
              int v63 = (long long *)(v40 + 3);
              int16x8_t v64 = v60 + 16;
              uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                *int16x8_t v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4;
              }
              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            std::locale v46 = &v33[8 * v42];
          }
          do
          {
            uint64_t v67 = *(void *)v7;
            v7 += 8;
            *(void *)std::locale v46 = v67;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_55:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          unint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_57;
      }
      goto LABEL_65;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v21 == *(char **)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  uint64_t v72 = a1 + 24;
  if (v24 >> 61) {
    goto LABEL_65;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = &v25[8 * v20];
  int v68 = v25;
  int64_t v69 = v26;
  uint64_t v27 = &v25[8 * v24];
  uint64_t v71 = v27;
  uint64_t v28 = operator new(0xFF0uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18) {
        unint64_t v47 = 1;
      }
      else {
        unint64_t v47 = v19 >> 2;
      }
      if (v47 >> 61) {
        goto LABEL_65;
      }
      size_t v48 = (char *)operator new(8 * v47);
      unint64_t v26 = &v48[8 * (v47 >> 2)];
      uint64_t v27 = &v48[8 * v47];
      int v68 = v48;
      int64_t v69 = v26;
      uint64_t v71 = v27;
      operator delete(v25);
      uint64_t v18 = *(char **)(a1 + 8);
      long long v17 = *(char **)(a1 + 16);
      uint64_t v25 = v48;
    }
    else
    {
      unint64_t v29 = v20 + 2;
      if (v20 >= -1) {
        unint64_t v29 = v20 + 1;
      }
      v26 -= 8 * (v29 >> 1);
      int64_t v69 = v26;
    }
  }
  *(void *)unint64_t v26 = v28;
  long long v49 = v26 + 8;
  timeval v70 = v26 + 8;
  if (v17 == v18)
  {
    long long v17 = v18;
  }
  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::string *>::push_front((void **)&v68, v17);
    }
    while (v17 != *(char **)(a1 + 8));
    uint64_t v25 = v68;
    unint64_t v26 = v69;
    uint64_t v18 = *(char **)(a1 + 16);
    long long v49 = v70;
    uint64_t v27 = v71;
  }
  int v50 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v26;
  int v68 = v50;
  int64_t v69 = v17;
  long long v51 = *(char **)(a1 + 24);
  *(void *)(a1 + 16) = v49;
  *(void *)(a1 + 24) = v27;
  timeval v70 = v18;
  uint64_t v71 = v51;
  if (v18 != v17) {
    timeval v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v50) {
    operator delete(v50);
  }
}

void std::__split_buffer<std::string *>::push_back(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_22;
  }
  unint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  if (v6 > *a1)
  {
    uint64_t v7 = (v6 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v6[-8 * v9];
    int64_t v12 = v4 - v6;
    if (v4 != v6)
    {
      memmove(&v6[-8 * v9], a1[1], v4 - v6);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_22;
  }
  unint64_t v14 = (v4 - v5) >> 2;
  if (v4 == v5) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  long long v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v6;
  BOOL v19 = v4 == v6;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      do
      {
LABEL_19:
        uint64_t v31 = *(void *)v6;
        v6 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v6) < 0x20) {
      goto LABEL_19;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    unint64_t v26 = &v6[v25];
    uint64_t v27 = (long long *)(v6 + 16);
    uint64_t v28 = v23 + 16;
    uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v30 = *v27;
      *(v28 - 1) = *(v27 - 1);
      *uint64_t v28 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 4;
    }
    while (v29);
    unint64_t v6 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }
LABEL_20:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v5)
  {
    operator delete(v5);
    unint64_t v4 = a1[2];
  }
LABEL_22:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::string *>::push_front(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 == *a1)
  {
    uint64_t v7 = a1[2];
    unint64_t v6 = a1[3];
    if (v7 >= v6)
    {
      uint64_t v13 = v6 - v4;
      BOOL v12 = v13 == 0;
      unint64_t v14 = v13 >> 2;
      if (v12) {
        unint64_t v14 = 1;
      }
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v15 = (v14 + 3) >> 2;
      uint64_t v16 = 8 * v14;
      long long v17 = (char *)operator new(8 * v14);
      unint64_t v5 = &v17[8 * v15];
      uint64_t v18 = v5;
      uint64_t v19 = v7 - v4;
      if (v7 != v4)
      {
        uint64_t v18 = &v5[v19 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v20 = v19 - 8;
        unint64_t v21 = &v17[8 * v15];
        uint64_t v22 = v4;
        if (v20 < 0x38) {
          goto LABEL_27;
        }
        uint64_t v23 = &v17[8 * v15];
        unint64_t v21 = v23;
        uint64_t v22 = v4;
        if ((unint64_t)(v23 - v4) < 0x20) {
          goto LABEL_27;
        }
        uint64_t v24 = (v20 >> 3) + 1;
        uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v21 = &v5[v25];
        uint64_t v22 = &v4[v25];
        unint64_t v26 = (long long *)(v4 + 16);
        uint64_t v27 = v23 + 16;
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v26;
          *(v27 - 1) = *(v26 - 1);
          _OWORD *v27 = v29;
          v26 += 2;
          v27 += 2;
          v28 -= 4;
        }
        while (v28);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_27:
          do
          {
            uint64_t v30 = *(void *)v22;
            v22 += 8;
            *(void *)unint64_t v21 = v30;
            v21 += 8;
          }
          while (v21 != v18);
        }
      }
      *a1 = v17;
      a1[1] = v5;
      a1[2] = v18;
      a1[3] = &v17[v16];
      if (v4)
      {
        operator delete(v4);
        unint64_t v5 = (char *)a1[1];
      }
    }
    else
    {
      uint64_t v8 = (v6 - v7) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v11 = &v7[8 * (v9 >> 1)];
      unint64_t v5 = &v11[-(v7 - v4)];
      if (v7 != v4)
      {
        memmove(&v11[-(v7 - v4)], v4, v7 - v4);
        unint64_t v4 = (char *)a1[2];
      }
      a1[1] = v5;
      a1[2] = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = (char *)a1[1];
  }
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *((char *)a2 + 23);
    if (v8 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    if (v8 >= 0) {
      uint64_t v10 = a2;
    }
    else {
      uint64_t v10 = *a2;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v6;
        unint64_t v14 = (const void *)v6[4];
        BOOL v12 = v6 + 4;
        uint64_t v13 = v14;
        int v15 = *((char *)v12 + 23);
        if (v15 >= 0) {
          size_t v16 = *((unsigned __int8 *)v12 + 23);
        }
        else {
          size_t v16 = v12[1];
        }
        if (v15 >= 0) {
          long long v17 = v12;
        }
        else {
          long long v17 = v13;
        }
        if (v16 >= v9) {
          size_t v18 = v9;
        }
        else {
          size_t v18 = v16;
        }
        int v19 = memcmp(v10, v17, v18);
        BOOL v20 = v9 < v16;
        if (v19) {
          BOOL v20 = v19 < 0;
        }
        if (!v20) {
          break;
        }
        unint64_t v6 = *v11;
        uint64_t v7 = v11;
        if (!*v11) {
          goto LABEL_27;
        }
      }
      int v21 = memcmp(v17, v10, v18);
      BOOL v22 = v16 < v9;
      if (v21) {
        BOOL v22 = v21 < 0;
      }
      if (!v22) {
        break;
      }
      unint64_t v6 = v11[1];
      if (!v6)
      {
        uint64_t v7 = v11 + 1;
        goto LABEL_27;
      }
    }
  }
  else
  {
    uint64_t v11 = a1 + 1;
LABEL_27:
    uint64_t v23 = (uint64_t *)v11;
    uint64_t v11 = (uint64_t **)operator new(0x40uLL);
    uint64_t v24 = *a4;
    uint64_t v25 = (uint64_t *)*((void *)*a4 + 2);
    *((_OWORD *)v11 + 2) = **a4;
    v11[6] = v25;
    void *v24 = 0;
    v24[1] = 0;
    v24[2] = 0;
    *((_DWORD *)v11 + 14) = 0;
    *uint64_t v11 = 0;
    v11[1] = 0;
    v11[2] = v23;
    *uint64_t v7 = (uint64_t *)v11;
    unint64_t v26 = (uint64_t *)**a1;
    uint64_t v27 = (uint64_t *)v11;
    if (v26)
    {
      *a1 = v26;
      uint64_t v27 = *v7;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v27);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v11;
}

uint64_t std::vector<register_map_entry>::__push_back_slow_path<register_map_entry const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 7;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 57) {
    abort();
  }
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 6 > v3) {
    unint64_t v3 = v7 >> 6;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFF80) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  if (v8)
  {
    if (v8 >> 57) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    size_t v9 = (char *)operator new(v8 << 7);
  }
  else
  {
    size_t v9 = 0;
  }
  uint64_t v10 = (uint64_t)&v9[128 * v2];
  uint64_t v11 = &v9[128 * v8];
  std::allocator<register_map_entry>::construct[abi:nn180100]<register_map_entry,register_map_entry const&>(v6, v10, a2);
  uint64_t v12 = v10 + 128;
  uint64_t v13 = (char *)*a1;
  unint64_t v14 = (char *)a1[1];
  if (v14 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = (uint64_t)v11;
  }
  else
  {
    do
    {
      *(_OWORD *)(v10 - 128) = *((_OWORD *)v14 - 8);
      long long v15 = *((_OWORD *)v14 - 7);
      long long v16 = *((_OWORD *)v14 - 6);
      long long v17 = *((_OWORD *)v14 - 4);
      *(_OWORD *)(v10 - 80) = *((_OWORD *)v14 - 5);
      *(_OWORD *)(v10 - 64) = v17;
      *(_OWORD *)(v10 - 112) = v15;
      *(_OWORD *)(v10 - 96) = v16;
      *(void *)(v10 - 40) = 0;
      *(void *)(v10 - 32) = 0;
      *(void *)(v10 - 48) = 0;
      *(_OWORD *)(v10 - 48) = *((_OWORD *)v14 - 3);
      *(void *)(v10 - 32) = *((void *)v14 - 4);
      *((void *)v14 - 6) = 0;
      *((void *)v14 - 5) = 0;
      *((void *)v14 - 4) = 0;
      *(void *)(v10 - 24) = 0;
      *(void *)(v10 - 16) = 0;
      *(void *)(v10 - 8) = 0;
      *(_OWORD *)(v10 - 24) = *(_OWORD *)(v14 - 24);
      *(void *)(v10 - 8) = *((void *)v14 - 1);
      v10 -= 128;
      *((void *)v14 - 3) = 0;
      *((void *)v14 - 2) = 0;
      *((void *)v14 - 1) = 0;
      v14 -= 128;
    }
    while (v14 != v13);
    unint64_t v14 = (char *)*a1;
    size_t v18 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v12;
    a1[2] = (uint64_t)v11;
    while (v18 != v14)
    {
      int v19 = (void *)*((void *)v18 - 3);
      if (v19)
      {
        *((void *)v18 - 2) = v19;
        operator delete(v19);
      }
      BOOL v20 = (void *)*((void *)v18 - 6);
      if (v20)
      {
        *((void *)v18 - 5) = v20;
        operator delete(v20);
      }
      v18 -= 128;
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void std::allocator<register_map_entry>::construct[abi:nn180100]<register_map_entry,register_map_entry const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  long long v5 = *(_OWORD *)(a3 + 16);
  long long v6 = *(_OWORD *)(a3 + 32);
  long long v7 = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 64) = v7;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v6;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 80) = 0;
  size_t v9 = *(unsigned char **)(a3 + 80);
  unint64_t v8 = *(unsigned char **)(a3 + 88);
  int64_t v10 = v8 - v9;
  if (v8 != v9)
  {
    if (v10 < 0) {
      goto LABEL_8;
    }
    uint64_t v11 = (char *)operator new(v8 - v9);
    *(void *)(a2 + 80) = v11;
    *(void *)(a2 + 88) = v11;
    uint64_t v12 = &v11[4 * (v10 >> 2)];
    *(void *)(a2 + 96) = v12;
    memcpy(v11, v9, v10);
    *(void *)(a2 + 88) = v12;
  }
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  unint64_t v14 = *(unsigned char **)(a3 + 104);
  uint64_t v13 = *(unsigned char **)(a3 + 112);
  int64_t v15 = v13 - v14;
  if (v13 == v14) {
    return;
  }
  if (v15 < 0) {
LABEL_8:
  }
    abort();
  long long v16 = (char *)operator new(v13 - v14);
  *(void *)(a2 + 104) = v16;
  *(void *)(a2 + 112) = v16;
  long long v17 = &v16[4 * (v15 >> 2)];
  *(void *)(a2 + 120) = v17;
  memcpy(v16, v14, v15);
  *(void *)(a2 + 112) = v17;
}

uint64_t std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v4 = *(char *)(a2 + 23);
  size_t v5 = v4 >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  long long v6 = v4 >= 0 ? (const void *)a2 : *(const void **)a2;
  uint64_t v7 = a1 + 8;
  do
  {
    int v8 = *(char *)(v3 + 55);
    if (v8 >= 0) {
      size_t v9 = *(unsigned __int8 *)(v3 + 55);
    }
    else {
      size_t v9 = *(void *)(v3 + 40);
    }
    if (v8 >= 0) {
      int64_t v10 = (const void *)(v3 + 32);
    }
    else {
      int64_t v10 = *(const void **)(v3 + 32);
    }
    if (v5 >= v9) {
      size_t v11 = v9;
    }
    else {
      size_t v11 = v5;
    }
    int v12 = memcmp(v10, v6, v11);
    BOOL v13 = v9 < v5;
    if (v12) {
      BOOL v13 = v12 < 0;
    }
    BOOL v14 = !v13;
    if (v13) {
      int64_t v15 = (uint64_t *)(v3 + 8);
    }
    else {
      int64_t v15 = (uint64_t *)v3;
    }
    if (v14) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v15;
  }
  while (*v15);
  if (v7 == v2) {
    return v2;
  }
  int v16 = *(char *)(v7 + 55);
  size_t v17 = v16 >= 0 ? *(unsigned __int8 *)(v7 + 55) : *(void *)(v7 + 40);
  size_t v18 = v16 >= 0 ? (const void *)(v7 + 32) : *(const void **)(v7 + 32);
  size_t v19 = v17 >= v5 ? v5 : v17;
  int v20 = memcmp(v6, v18, v19);
  BOOL v21 = v5 < v17;
  if (v20) {
    BOOL v21 = v20 < 0;
  }
  if (v21) {
    return v2;
  }
  return v7;
}

void std::stringbuf::__init_buf_ptrs[abi:nn180100](uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(unsigned char *)(a1 + 87);
  if (v3 < 0)
  {
    int v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
    int v6 = *(_DWORD *)(a1 + 96);
    if ((v6 & 8) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  int v4 = v2;
  unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
LABEL_3:
    *(void *)(a1 + 88) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }
LABEL_4:
  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 88) = (char *)v4 + v5;
    std::string::size_type v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    uint64_t v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 48) = v4;
    *(void *)(a1 + 56) = (char *)v4 + v8;
    if ((*(unsigned char *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        int v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 48) = v4;
      }
      if (v5) {
        *(void *)(a1 + 48) = (char *)v4 + v5;
      }
    }
  }
}

void std::__shared_ptr_emplace<JSONGenerator::Array>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100068F48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<JSONGenerator::Array>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100068F48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_emplace<JSONGenerator::Array>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_pointer<JSONGenerator::Dictionary *,std::shared_ptr<JSONGenerator::Dictionary>::__shared_ptr_default_delete<JSONGenerator::Dictionary,JSONGenerator::Dictionary>,std::allocator<JSONGenerator::Dictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Dictionary *,std::shared_ptr<JSONGenerator::Dictionary>::__shared_ptr_default_delete<JSONGenerator::Dictionary,JSONGenerator::Dictionary>,std::allocator<JSONGenerator::Dictionary>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<JSONGenerator::Array *,std::shared_ptr<JSONGenerator::Array>::__shared_ptr_default_delete<JSONGenerator::Array,JSONGenerator::Array>,std::allocator<JSONGenerator::Array>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Array *,std::shared_ptr<JSONGenerator::Array>::__shared_ptr_default_delete<JSONGenerator::Array,JSONGenerator::Array>,std::allocator<JSONGenerator::Array>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Integer>::__shared_ptr_default_delete<JSONGenerator::Integer,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Integer>::__shared_ptr_default_delete<JSONGenerator::Integer,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t prime = v16;
    }
    else {
      size_t prime = v15;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_41;
    }
    if (prime < v7)
    {
      unint64_t v18 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v19.i16[0] = vaddlv_u8(v19), v19.u32[0] > 1uLL))
      {
        unint64_t v18 = std::__next_prime(v18);
      }
      else
      {
        uint64_t v20 = 1 << -(char)__clz(v18 - 1);
        if (v18 >= 2) {
          unint64_t v18 = v20;
        }
      }
      if (prime <= v18) {
        size_t prime = v18;
      }
      if (prime < v7) {
LABEL_41:
      }
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v21 = *(void *)a1;
  BOOL v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *unint64_t v10 = *v22;
LABEL_55:
    *BOOL v22 = v10;
    goto LABEL_56;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v23 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v23 >= v7) {
        v23 %= v7;
      }
    }
    else
    {
      v23 &= v7 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_55;
  }
LABEL_56:
  ++*(void *)(a1 + 24);
  return v10;
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    unint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v13 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }
          else
          {
            v13 &= a2 - 1;
          }
          if (v13 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v13))
            {
              *(void *)(*(void *)a1 + 8 * v13) = v7;
              goto LABEL_19;
            }
            *unint64_t v7 = *v11;
            uint64_t v12 = 8 * v13;
            *unint64_t v11 = **(void **)(*(void *)a1 + v12);
            **(void **)(*(void *)a1 + v12) = v11;
            unint64_t v11 = v7;
          }
          unint64_t v13 = v8;
LABEL_19:
          unint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v13;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t _GLOBAL__sub_I_RNBRemote_cpp()
{
  byte_1000797BF = 6;
  strcpy((char *)&OS_LOG_EVENTS_KEY_NAME, "events");
  __cxa_atexit((void (*)(void *))&std::string::~string, &OS_LOG_EVENTS_KEY_NAME, (void *)&_mh_execute_header);
  byte_1000797D7 = 4;
  strcpy((char *)&JSON_ASYNC_TYPE_KEY_NAME, "type");
  __cxa_atexit((void (*)(void *))&std::string::~string, &JSON_ASYNC_TYPE_KEY_NAME, (void *)&_mh_execute_header);
  qword_100079828 = 0;
  unk_100079830 = 0;
  g_dynamic_register_map = 0;
  __cxa_atexit((void (*)(void *))std::vector<register_map_entry>::~vector[abi:nn180100], &g_dynamic_register_map, (void *)&_mh_execute_header);
  unk_100479868 = 0;
  g_target_xml = 0uLL;

  return __cxa_atexit((void (*)(void *))&std::string::~string, &g_target_xml, (void *)&_mh_execute_header);
}

uint64_t GetProcesses(__CFArray *a1, char a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  long long __p = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v3 = DNBGetAllInfos((char **)&__p);
  if (v3)
  {
    unint64_t v4 = v3;
    pid_t v5 = getpid();
    uid_t v6 = getuid();
    unint64_t v7 = 0;
    unsigned int v8 = 1;
    while (1)
    {
      uint8x8_t v9 = (char *)__p + 648 * v7;
      int v10 = *((_DWORD *)v9 + 10);
      if ((a2 & 1) != 0 || *((_DWORD *)v9 + 98) == v6)
      {
        BOOL v11 = v10 == v5 || v10 == 0;
        BOOL v12 = v11 || v9[36] == 5;
        if (!v12 && (v9[33] & 0x28) == 0) {
          break;
        }
      }
LABEL_4:
      unint64_t v7 = v8++;
      if (v4 <= v7) {
        goto LABEL_29;
      }
    }
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v24 = off_100069150;
    CFMutableDictionaryRef theDict = Mutable;
    int valuePtr = v10;
    CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    uint64_t v21 = off_100069170;
    CFTypeRef cf = v14;
    CFDictionarySetValue(theDict, @"pid", v14);
    CFDictionarySetValue(theDict, @"isFrontApp", kCFBooleanFalse);
    if (proc_pidpath(v10, buffer, 0x400u) < 1)
    {
      unint64_t v16 = v9 + 243;
      if (!v9[243]) {
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v15 = strrchr(buffer, 47);
      if (v15) {
        unint64_t v16 = v15 + 1;
      }
      else {
        unint64_t v16 = buffer;
      }
      CFString::CFString((CFString *)v19, buffer, 0x8000100u);
      if (v20) {
        CFDictionarySetValue(theDict, @"executablePath", v20);
      }
      CFString::~CFString((CFString *)v19);
      if (!*v16) {
        goto LABEL_23;
      }
    }
    CFString::CFString((CFString *)v19, v16, 0x8000100u);
    CFDictionarySetValue(theDict, @"displayName", v20);
    CFString::~CFString((CFString *)v19);
LABEL_23:
    CFArrayAppendValue(a1, theDict);
    uint64_t v21 = off_100069170;
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v24 = off_100069150;
    if (theDict) {
      CFRelease(theDict);
    }
    goto LABEL_4;
  }
LABEL_29:
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
  return 0;
}

void *CFReleaser<__CFNumber const*>::~CFReleaser(void *a1)
{
  *a1 = off_100069170;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void *CFReleaser<__CFDictionary *>::~CFReleaser(void *a1)
{
  *a1 = off_100069150;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

uint64_t ListApplications(std::string *a1)
{
  uint64_t v30 = off_100069190;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (getuid())
  {
    uint64_t v28 = off_1000691B0;
    CFStringRef theString1 = (CFStringRef)SBSCopyFrontmostApplicationDisplayIdentifier();
    CFArrayRef v2 = (const __CFArray *)SBSCopyApplicationDisplayIdentifiers();
    unint64_t v26 = off_1000691D0;
    CFArrayRef theArray = v2;
    if (v2)
    {
      unint64_t v18 = a1;
      CFIndex Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        CFIndex v4 = Count;
        for (CFIndex i = 0; i != v4; ++i)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
          unint64_t v7 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          uint64_t v24 = off_100069150;
          CFMutableDictionaryRef theDict = v7;
          int valuePtr = 0;
          if (SBSProcessIDForDisplayIdentifier() == 1)
          {
            CFNumberRef cf = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
            CFDictionarySetValue(theDict, @"pid", cf);
            if (cf) {
              CFRelease(cf);
            }
          }
          if (!theString1
            || !ValueAtIndex
            || (CFComparisonResult v8 = CFStringCompare(theString1, ValueAtIndex, 0), v9 = kCFBooleanTrue, v8))
          {
            CFBooleanRef v9 = kCFBooleanFalse;
          }
          CFDictionarySetValue(theDict, @"isFrontApp", v9);
          int v10 = (const void *)SBSCopyExecutablePathForDisplayIdentifier();
          CFTypeRef cfa = v10;
          if (v10) {
            CFDictionarySetValue(theDict, @"executablePath", v10);
          }
          BOOL v11 = (const void *)SBSCopyIconImagePathForDisplayIdentifier();
          CFTypeRef v20 = v11;
          if (v11) {
            CFDictionarySetValue(theDict, @"iconPath", v11);
          }
          BOOL v12 = (const void *)SBSCopyLocalizedApplicationNameForDisplayIdentifier();
          CFTypeRef v19 = v12;
          if (v12) {
            CFDictionarySetValue(theDict, @"displayName", v12);
          }
          CFArrayAppendValue(Mutable, theDict);
          if (v19) {
            CFRelease(v19);
          }
          if (v20) {
            CFRelease(v20);
          }
          if (cfa) {
            CFRelease(cfa);
          }
          uint64_t v24 = off_100069150;
          if (theDict) {
            CFRelease(theDict);
          }
        }
      }
      unint64_t v26 = off_1000691D0;
      a1 = v18;
      if (theArray) {
        CFRelease(theArray);
      }
    }
    uint64_t v28 = off_1000691B0;
    if (theString1) {
      CFRelease(theString1);
    }
  }
  else
  {
    GetProcesses(Mutable, 1);
  }
  CFStringRef XMLData = (const __CFString *)CFPropertyListCreateXMLData(kCFAllocatorDefault, Mutable);
  uint64_t v28 = off_1000691F0;
  CFStringRef theString1 = XMLData;
  if (XMLData)
  {
    int64_t Length = CFDataGetLength((CFDataRef)XMLData);
    BytePtr = CFDataGetBytePtr((CFDataRef)theString1);
    if (BytePtr && Length > 0)
    {
      std::string::assign(a1, (const std::string::value_type *)BytePtr, Length);
      uint64_t v16 = 0;
    }
    else
    {
      if (DNBLogEnabled()) {
        _DNBLogError("empty application property list.");
      }
      uint64_t v16 = 4294967294;
    }
  }
  else
  {
    if (DNBLogEnabled()) {
      _DNBLogError("serializing task list.");
    }
    uint64_t v16 = 4294967293;
  }
  uint64_t v28 = off_1000691F0;
  if (theString1) {
    CFRelease(theString1);
  }
  uint64_t v30 = off_100069190;
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v16;
}

void *CFReleaser<__CFString const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691B0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void *CFReleaser<__CFArray const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691D0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void *CFReleaser<__CFData const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691F0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void *CFReleaser<__CFArray *>::~CFReleaser(void *a1)
{
  *a1 = off_100069190;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void CFReleaser<__CFDictionary *>::~CFReleaser(void *a1)
{
  *a1 = off_100069150;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFReleaser<__CFNumber const*>::~CFReleaser(void *a1)
{
  *a1 = off_100069170;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFReleaser<__CFArray *>::~CFReleaser(void *a1)
{
  *a1 = off_100069190;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFReleaser<__CFString const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691B0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFReleaser<__CFArray const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691D0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFReleaser<__CFData const*>::~CFReleaser(void *a1)
{
  *a1 = off_1000691F0;
  CFArrayRef v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

uint64_t RNBSocket::Listen(RNBSocket *this, char *a2, unsigned __int16 Port, void (*a4)(const void *, unsigned __int16), const void *a5)
{
  CFBooleanRef v9 = (int *)this;
  RNBSocket::Disconnect(this);
  *(_OWORD *)uint64_t v97 = 0u;
  long long v98 = 0u;
  int v10 = kqueue();
  if ((v10 & 0x80000000) == 0)
  {
    long long v83 = a5;
    int v11 = strcmp(a2, "*");
    if (v11) {
      BOOL v12 = a2;
    }
    else {
      BOOL v12 = "localhost";
    }
    unint64_t v95 = 0;
    size_t v96 = 0;
    int v94 = (uint64_t *)&v95;
    lldb_private::SocketAddress::GetAddressInfo((lldb_private::SocketAddress *)v12, 0, 0, 1, 6, 0, (char **)&v92);
    CFNumberRef v14 = (long long *)v92;
    unint64_t v13 = v93;
    if (v92 != v93)
    {
      do
      {
        long long v15 = *v14;
        long long v16 = v14[1];
        long long v17 = v14[3];
        long long v100 = v14[2];
        long long v101 = v17;
        *(_OWORD *)&v99.int ident = v15;
        *(_OWORD *)&v99.int data = v16;
        long long v18 = v14[4];
        long long v19 = v14[5];
        long long v20 = v14[7];
        long long v104 = v14[6];
        long long v105 = v20;
        long long v102 = v18;
        long long v103 = v19;
        LODWORD(v86[0]) = 0;
        int Family = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v99);
        int v22 = socket(Family, 1, 6);
        LODWORD(v86[0]) = v22;
        if (v22 == -1) {
          goto LABEL_8;
        }
        *(_DWORD *)&v107.sa_len = 1;
        setsockopt(v22, 0xFFFF, 4, &v107, 4u);
        long long v111 = v102;
        long long v112 = v103;
        long long v113 = v104;
        long long v114 = v105;
        sockaddr v107 = *(sockaddr *)&v99.ident;
        long long v108 = *(_OWORD *)&v99.data;
        long long v109 = v100;
        long long v110 = v101;
        if (v11 && lldb_private::SocketAddress::IsLocalhost((lldb_private::SocketAddress *)&v107))
        {
          lldb_private::SocketAddress::SetPort((lldb_private::SocketAddress *)&v107, Port);
        }
        else
        {
          int v23 = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v107);
          lldb_private::SocketAddress::SetToAnyAddress((lldb_private::SocketAddress *)&v107, v23, Port);
        }
        int v24 = (int)v86[0];
        socklen_t Length = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v107);
        if (bind(v24, &v107, Length) == -1)
        {
          if (SLODWORD(v86[0]) >= 1) {
            goto LABEL_20;
          }
        }
        else
        {
          if (listen((int)v86[0], 5) != -1)
          {
            if (!Port)
            {
              v89[0] = 0;
              v89[0] = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v99);
              if (getsockname((int)v86[0], (sockaddr *)&v99, v89)) {
                Port = 0;
              }
              else {
                Port = lldb_private::SocketAddress::GetPort((lldb_private::SocketAddress *)&v99);
              }
            }
            *(void *)uint64_t v89 = v86;
            unint64_t v26 = std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v94, (int *)v86, (uint64_t)&std::piecewise_construct, (_DWORD **)v89);
            long long v28 = v100;
            long long v27 = v101;
            long long v29 = *(_OWORD *)&v99.data;
            *(_OWORD *)(v26 + 5) = *(_OWORD *)&v99.ident;
            long long v31 = v104;
            long long v30 = v105;
            long long v32 = v103;
            *(_OWORD *)(v26 + 13) = v102;
            *(_OWORD *)(v26 + 15) = v32;
            *(_OWORD *)(v26 + 17) = v31;
            *(_OWORD *)(v26 + 19) = v30;
            *(_OWORD *)(v26 + 7) = v29;
            *(_OWORD *)(v26 + 9) = v28;
            *(_OWORD *)(v26 + 11) = v27;
            goto LABEL_7;
          }
          if (SLODWORD(v86[0]) >= 1)
          {
LABEL_20:
            *__error() = 0;
            close((int)v86[0]);
            LODWORD(v86[0]) = -1;
          }
        }
LABEL_7:
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v107);
LABEL_8:
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v99);
        v14 += 8;
      }
      while (v14 != v13);
    }
    size_t v33 = v96;
    if (!v96)
    {
      LODWORD(v97[0]) = *__error();
      HIDWORD(v97[0]) = 2;
      if (SHIBYTE(v98) < 0)
      {
        *(unsigned char *)v97[1] = 0;
        *(void *)&long long v98 = 0;
      }
      else
      {
        LOBYTE(v97[1]) = 0;
        HIBYTE(v98) = 0;
      }
      DNBError::LogThreaded((DNBError *)v97, "::listen or ::bind failed");
      uint64_t v77 = 1;
      size_t v79 = (char *)v92;
      if (!v92) {
        goto LABEL_124;
      }
      goto LABEL_120;
    }
    if (a4)
    {
      a4(v83, Port);
      size_t v33 = v96;
      *(void *)uint64_t v89 = 0;
      unint64_t v90 = 0;
      uint64_t v91 = 0;
      if (!v96)
      {
LABEL_35:
        unint64_t v34 = v94;
        if (v94 != (uint64_t *)&v95)
        {
          uint64_t v35 = 0;
          p_filter = &v99.filter;
          do
          {
            long long v37 = *((_OWORD *)v34 + 8);
            long long v103 = *((_OWORD *)v34 + 7);
            long long v104 = v37;
            long long v105 = *((_OWORD *)v34 + 9);
            uint64_t v106 = v34[20];
            long long v38 = *((_OWORD *)v34 + 3);
            long long v39 = *((_OWORD *)v34 + 5);
            long long v40 = *((_OWORD *)v34 + 6);
            long long v100 = *((_OWORD *)v34 + 4);
            long long v101 = v39;
            long long v102 = v40;
            *(_OWORD *)&v99.int ident = *((_OWORD *)v34 + 2);
            *(_OWORD *)&v99.int data = v38;
            uint64_t v41 = *(void *)v89 + 32 * v35;
            *(void *)uint64_t v41 = SLODWORD(v99.ident);
            *(_DWORD *)(v41 + 8) = 0x1FFFF;
            *(void *)(v41 + 20) = 0;
            *(void *)(v41 + 12) = 0;
            *(_DWORD *)(v41 + 28) = 0;
            lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)p_filter);
            unint64_t v42 = (uint64_t *)v34[1];
            if (v42)
            {
              do
              {
                uint64_t v43 = v42;
                unint64_t v42 = (uint64_t *)*v42;
              }
              while (v42);
            }
            else
            {
              do
              {
                uint64_t v43 = (uint64_t *)v34[2];
                BOOL v44 = *v43 == (void)v34;
                unint64_t v34 = v43;
              }
              while (!v44);
            }
            ++v35;
            unint64_t v34 = v43;
          }
          while (v43 != (uint64_t *)&v95);
        }
        while (1)
        {
          *__error() = 0;
          unsigned int v45 = kevent(v10, *(const kevent **)v89, ((unint64_t)v90 - *(void *)v89) >> 5, &v99, 4, 0);
          if (v45 == -1)
          {
            if (*__error() != 35 && *__error() != 35 && *__error() != 4) {
              goto LABEL_91;
            }
          }
          else
          {
            if ((v45 & 0x80000000) == 0)
            {
              if (!v45) {
                goto LABEL_95;
              }
              uint64_t v46 = 0;
              char v47 = 0;
              uint64_t v48 = v45;
              while (2)
              {
                long long v49 = v95;
                if (v95)
                {
                  int v50 = *((_DWORD *)&v99.ident + 8 * v46);
                  long long v51 = (unsigned __int8 *)&v95;
                  do
                  {
                    unint64_t v52 = (unsigned __int8 *)v49;
                    uint64_t v53 = v51;
                    int v54 = *((_DWORD *)v49 + 8);
                    unint64_t v55 = (unsigned __int8 *)(v49 + 1);
                    if (v54 >= v50)
                    {
                      unint64_t v55 = v52;
                      long long v51 = v52;
                    }
                    long long v49 = *(void **)v55;
                  }
                  while (v49);
                  if (v51 != (unsigned __int8 *)&v95)
                  {
                    if (v54 < v50) {
                      unint64_t v52 = v53;
                    }
                    if (*((_DWORD *)v52 + 8) <= v50)
                    {
                      lldb_private::SocketAddress::SocketAddress((lldb_private::SocketAddress *)&v107);
                      Maxsocklen_t Length = 0;
                      Maxsocklen_t Length = lldb_private::SocketAddress::GetMaxLength(v56);
                      int v57 = accept(v50, &v107, &MaxLength);
                      *CFBooleanRef v9 = v57;
                      if (v57 == -1)
                      {
                        LODWORD(v97[0]) = *__error();
                        HIDWORD(v97[0]) = 2;
                        if (SHIBYTE(v98) < 0)
                        {
                          *(unsigned char *)v97[1] = 0;
                          *(void *)&long long v98 = 0;
                        }
                        else
                        {
                          LOBYTE(v97[1]) = 0;
                          HIBYTE(v98) = 0;
                        }
                        DNBError::LogThreaded((DNBError *)v97, "error: Socket accept failed.");
                      }
                      unint64_t v58 = (unint64_t)(v51 + 40);
                      if (lldb_private::SocketAddress::IsAnyAddr((lldb_private::SocketAddress *)(v51 + 40))
                        || lldb_private::SocketAddress::operator==(&v107.sa_len, v51 + 40))
                      {
                        char v47 = 1;
                      }
                      else
                      {
                        close(*v9);
                        uint64_t v59 = v9;
                        *CFBooleanRef v9 = -1;
                        unint64_t v60 = __stderrp;
                        lldb_private::SocketAddress::GetIPAddress((unint64_t)&v107, v86);
                        int v61 = v87;
                        uint64_t v62 = (void **)v86[0];
                        lldb_private::SocketAddress::GetIPAddress(v58, __p);
                        int v63 = v86;
                        if (v61 < 0) {
                          int v63 = v62;
                        }
                        int16x8_t v64 = __p;
                        if (v85 < 0) {
                          int16x8_t v64 = (void **)__p[0];
                        }
                        fprintf(v60, "error: rejecting incoming connection from %s (expecting %s)\n", (const char *)v63, (const char *)v64);
                        if (v85 < 0) {
                          operator delete(__p[0]);
                        }
                        CFBooleanRef v9 = v59;
                        if (v87 < 0) {
                          operator delete(v86[0]);
                        }
                        if (DNBLogEnabled())
                        {
                          lldb_private::SocketAddress::GetIPAddress((unint64_t)&v107, v86);
                          int v65 = v87;
                          long long v66 = (void **)v86[0];
                          lldb_private::SocketAddress::GetIPAddress(v58, __p);
                          uint64_t v67 = v86;
                          if (v65 < 0) {
                            uint64_t v67 = v66;
                          }
                          int v68 = __p;
                          if (v85 < 0) {
                            int v68 = (void **)__p[0];
                          }
                          _DNBLogThreaded("error: rejecting connection from %s (expecting %s)\n", (const char *)v67, (const char *)v68);
                          CFBooleanRef v9 = v59;
                          if (v85 < 0)
                          {
                            operator delete(__p[0]);
                            if ((v87 & 0x80000000) == 0) {
                              goto LABEL_86;
                            }
                          }
                          else if ((v87 & 0x80000000) == 0)
                          {
                            goto LABEL_86;
                          }
                          operator delete(v86[0]);
                        }
LABEL_86:
                        v97[0] = 0;
                        if (SHIBYTE(v98) < 0)
                        {
                          *(unsigned char *)v97[1] = 0;
                          *(void *)&long long v98 = 0;
                        }
                        else
                        {
                          LOBYTE(v97[1]) = 0;
                          HIBYTE(v98) = 0;
                        }
                      }
                      lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v107);
                    }
                  }
                }
                if (++v46 == v48) {
                  goto LABEL_96;
                }
                continue;
              }
            }
LABEL_91:
            LODWORD(v97[0]) = *__error();
            HIDWORD(v97[0]) = 1;
            if (SHIBYTE(v98) < 0)
            {
              *(unsigned char *)v97[1] = 0;
              *(void *)&long long v98 = 0;
            }
            else
            {
              LOBYTE(v97[1]) = 0;
              HIBYTE(v98) = 0;
            }
            DNBError::LogThreaded((DNBError *)v97, "error: kevent() failed.");
LABEL_95:
            char v47 = 0;
LABEL_96:
            if (LODWORD(v97[0]) || (v47 & 1) != 0)
            {
              int64_t v69 = v94;
              if (v94 != (uint64_t *)&v95)
              {
                do
                {
                  long long v70 = *((_OWORD *)v69 + 8);
                  long long v103 = *((_OWORD *)v69 + 7);
                  long long v104 = v70;
                  long long v105 = *((_OWORD *)v69 + 9);
                  uint64_t v106 = v69[20];
                  long long v71 = *((_OWORD *)v69 + 3);
                  long long v72 = *((_OWORD *)v69 + 5);
                  long long v73 = *((_OWORD *)v69 + 6);
                  long long v100 = *((_OWORD *)v69 + 4);
                  long long v101 = v72;
                  long long v102 = v73;
                  *(_OWORD *)&v99.int ident = *((_OWORD *)v69 + 2);
                  *(_OWORD *)&v99.int data = v71;
                  int ident = v99.ident;
                  if (SLODWORD(v99.ident) >= 1)
                  {
                    *__error() = 0;
                    close(ident);
                  }
                  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v99.filter);
                  unint64_t v75 = (uint64_t *)v69[1];
                  if (v75)
                  {
                    do
                    {
                      uint64_t v76 = v75;
                      unint64_t v75 = (uint64_t *)*v75;
                    }
                    while (v75);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v76 = (uint64_t *)v69[2];
                      BOOL v44 = *v76 == (void)v69;
                      int64_t v69 = v76;
                    }
                    while (!v44);
                  }
                  int64_t v69 = v76;
                }
                while (v76 != (uint64_t *)&v95);
              }
              uint64_t v77 = 1;
              if (!LODWORD(v97[0]))
              {
                int v78 = *v9;
                LODWORD(v99.ident) = 1;
                setsockopt(v78, 6, 1, &v99, 4u);
                uint64_t v77 = 0;
              }
              if (*(void *)v89)
              {
                unint64_t v90 = *(const kevent **)v89;
                operator delete(*(void **)v89);
              }
              size_t v79 = (char *)v92;
              if (!v92)
              {
LABEL_124:
                std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy((uint64_t)&v94, v95);
                if (SHIBYTE(v98) < 0) {
                  goto LABEL_125;
                }
                return v77;
              }
LABEL_120:
              std::string::size_type v80 = (char *)v93;
              uint64_t v81 = v79;
              if (v93 != (long long *)v79)
              {
                do
                  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v80 - 128));
                while (v80 != v79);
                uint64_t v81 = v92;
              }
              size_t v93 = (long long *)v79;
              operator delete(v81);
              goto LABEL_124;
            }
          }
        }
      }
    }
    else
    {
      *(void *)uint64_t v89 = 0;
      unint64_t v90 = 0;
      uint64_t v91 = 0;
    }
    std::vector<kevent>::__append((char **)v89, v33);
    goto LABEL_35;
  }
  LODWORD(v97[0]) = *__error();
  HIDWORD(v97[0]) = 1;
  if (SHIBYTE(v98) < 0)
  {
    *(unsigned char *)v97[1] = 0;
    *(void *)&long long v98 = 0;
  }
  else
  {
    LOBYTE(v97[1]) = 0;
    HIBYTE(v98) = 0;
  }
  DNBError::LogThreaded((DNBError *)v97, "error: failed to create kqueue.");
  uint64_t v77 = 1;
  if (SHIBYTE(v98) < 0) {
LABEL_125:
  }
    operator delete(v97[1]);
  return v77;
}

void sub_1000395F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,char a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,char a42)
{
  if (__p) {
    operator delete(__p);
  }
  std::vector<lldb_private::SocketAddress>::~vector[abi:ne180100](&a29);
  std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy((uint64_t)&a32, a33);
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(a1);
}

BOOL RNBSocket::Disconnect(RNBSocket *this)
{
  if (*((unsigned char *)this + 4))
  {
    if (*((unsigned char *)this + 5))
    {
      close(*(_DWORD *)this);
      sleep(0x1Eu);
      *(_DWORD *)this = -1;
      *((_WORD *)this + 2) = 0;
      BOOL v8 = DNBLogEnabled();
      BOOL result = 0;
      if (!v8) {
        return result;
      }
      _DNBLog(0, (uint64_t)"Shutting down secure socket proxy, SSP finish-callback didn't kill debugserver.", v2, v3, v4, v5, v6, v7, v11);
    }
    else
    {
      *((unsigned char *)this + 4) = 0;
      *(_DWORD *)this = -1;
      lockdown_disconnect();
    }
  }
  else if (*(int *)this >= 1)
  {
    *__error() = 0;
    int v10 = close(*(_DWORD *)this);
    *(_DWORD *)this = -1;
    return v10 != 0;
  }
  return 0;
}

void **std::vector<lldb_private::SocketAddress>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v2;
    if (v3 != v2)
    {
      do
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v3 - 128));
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t RNBSocket::Connect(RNBSocket *this, lldb_private::SocketAddress *a2, unsigned int a3)
{
  RNBSocket::Disconnect(this);
  lldb_private::SocketAddress::GetAddressInfo(a2, 0, 0, 1, 6, 0, &v23);
  uint64_t v6 = v23;
  uint64_t v7 = v24;
  uint64_t v8 = 1;
  if (v23 == v24)
  {
    if (v23) {
      goto LABEL_11;
    }
    return v8;
  }
  while (1)
  {
    sockaddr v9 = *(sockaddr *)v6;
    long long v10 = *((_OWORD *)v6 + 1);
    long long v11 = *((_OWORD *)v6 + 3);
    long long v28 = *((_OWORD *)v6 + 2);
    long long v29 = v11;
    sockaddr v26 = v9;
    long long v27 = v10;
    long long v12 = *((_OWORD *)v6 + 4);
    long long v13 = *((_OWORD *)v6 + 5);
    long long v14 = *((_OWORD *)v6 + 7);
    long long v32 = *((_OWORD *)v6 + 6);
    long long v33 = v14;
    long long v30 = v12;
    long long v31 = v13;
    int Family = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v26);
    int v16 = socket(Family, 1, 6);
    *(_DWORD *)this = v16;
    if (v16 != -1) {
      break;
    }
LABEL_4:
    lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v26);
    v6 += 128;
    if (v6 == v7)
    {
      uint64_t v8 = 1;
      goto LABEL_10;
    }
  }
  int v25 = 1;
  setsockopt(v16, 0xFFFF, 4, &v25, 4u);
  lldb_private::SocketAddress::SetPort((lldb_private::SocketAddress *)&v26, a3);
  int v17 = *(_DWORD *)this;
  socklen_t Length = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v26);
  if (connect(v17, &v26, Length) == -1)
  {
    RNBSocket::Disconnect(this);
    goto LABEL_4;
  }
  int v19 = *(_DWORD *)this;
  int v25 = 1;
  setsockopt(v19, 6, 1, &v25, 4u);
  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v26);
  uint64_t v8 = 0;
LABEL_10:
  uint64_t v6 = v23;
  if (v23)
  {
LABEL_11:
    long long v20 = v24;
    uint64_t v21 = v6;
    if (v24 != v6)
    {
      do
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v20 - 128));
      while (v20 != v6);
      uint64_t v21 = v23;
    }
    int v24 = v6;
    operator delete(v21);
  }
  return v8;
}

void sub_1000399BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t RNBSocket::useFD(RNBSocket *this, int a2)
{
  if (a2 < 0)
  {
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("Bad file descriptor passed in.");
    }
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)this = a2;
  }
  return result;
}

uint64_t RNBSocket::ConnectToService(RNBSocket *this, int a2)
{
  if (DNBLogEnabled()) {
    _DNBLog(0, (uint64_t)"Connecting to com.apple.%s service...", v4, v5, v6, v7, v8, v9, (uint64_t)"debugserver");
  }
  RNBSocket::Disconnect(this);
  if (secure_lockdown_checkin())
  {
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("::secure_lockdown_checkin(&m_fd, NULL, NULL) failed");
    }
    *(_DWORD *)this = -1;
    return 2;
  }
  if (a2)
  {
    lockdown_get_socket();
    *(_DWORD *)this = DVTSecureSocketProxy_Create();
    *((unsigned char *)this + 5) = 1;
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"Using secure socket proxy.", v11, v12, v13, v14, v15, v16, v18);
    }
    if (*(_DWORD *)this != -1) {
      goto LABEL_12;
    }
LABEL_14:
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("::lockdown_get_socket() failed");
    }
    return 2;
  }
  int socket = lockdown_get_socket();
  *(_DWORD *)this = socket;
  *((unsigned char *)this + 5) = 0;
  if (socket == -1) {
    goto LABEL_14;
  }
LABEL_12:
  uint64_t result = 0;
  *((unsigned char *)this + 4) = 1;
  return result;
}

void ___ZN9RNBSocket16ConnectToServiceEb_block_invoke()
{
  lockdown_disconnect();
  if (DNBLogEnabled())
  {
    _DNBLog(0, (uint64_t)"debugserver secure socket proxy finish-block shut down.", v0, v1, v2, v3, v4, v5, vars0);
    if (!DNBLogEnabled()) {
LABEL_3:
    }
      _exit(0);
  }
  else if (!DNBLogEnabled())
  {
    goto LABEL_3;
  }
  _DNBLog(0, (uint64_t)"debugserver expedited exit.", v6, v7, v8, v9, v10, v11, vars0);
  _exit(0);
}

uint64_t RNBSocket::OpenFile(RNBSocket *this, const char *a2)
{
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  int v4 = open(a2, 2);
  *(_DWORD *)this = v4;
  if (v4 == -1)
  {
    LODWORD(__p[0]) = *__error();
    HIDWORD(__p[0]) = 2;
    LOBYTE(__p[1]) = 0;
    HIBYTE(v7) = 0;
    DNBError::LogThreaded((DNBError *)__p, "can't open file '%s'", a2);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[1]);
    }
    return 2;
  }
  else
  {
    if (!tcgetattr(v4, &v8))
    {
      v8.c_lflag &= 0xFFFFFFFFFFFFFEF7;
      tcsetattr(*(_DWORD *)this, 0, &v8);
    }
    return 0;
  }
}

void sub_100039D7C(_Unwind_Exception *exception_object)
{
}

void sub_100039D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RNBSocket::Read(int *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  if (*a1 == -1) {
    return 1;
  }
  *(_OWORD *)long long __p = 0u;
  long long v15 = 0u;
  while (1)
  {
    *__error() = 0;
    int64_t v4 = read(*a1, __s, 0x400uLL);
    int64_t v5 = v4;
    if (v4 != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 35 && *__error() != 4) {
      goto LABEL_14;
    }
  }
  if (v4 > 0)
  {
    std::string::append((std::string *)a2, __s, v4);
    goto LABEL_15;
  }
LABEL_14:
  LODWORD(__p[0]) = *__error();
  HIDWORD(__p[0]) = 2;
  LOBYTE(__p[1]) = 0;
  HIBYTE(v15) = 0;
  if (LODWORD(__p[0])) {
    goto LABEL_16;
  }
LABEL_15:
  if (!DNBLogCheckLogBit(0x80000)) {
    goto LABEL_17;
  }
LABEL_16:
  DNBError::LogThreaded((DNBError *)__p, "::read(%i, %p, %llu) => %i", *a1, __s, 1024, v5);
LABEL_17:
  if ((unint64_t)(v5 + 1) >= 2)
  {
    while (1)
    {
      if (*(char *)(a2 + 23) < 0)
      {
        uint64_t v8 = *(void *)(a2 + 8);
        if (!v8) {
          break;
        }
      }
      else
      {
        if (!*(unsigned char *)(a2 + 23)) {
          break;
        }
        uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
      }
      uint64_t v9 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      __darwin_ct_rune_t v10 = *(char *)(v8 + v9 - 1);
      if (!(v10 < 0 ? __maskrune(v10, 0x4000uLL) : _DefaultRuneLocale.__runetype[v10] & 0x4000)) {
        break;
      }
      uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a2 + 8);
      }
      std::string::erase((std::string *)a2, v12 - 1, 0xFFFFFFFFFFFFFFFFLL);
    }
    if (DNBLogEnabledForAny(0x80000))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v13 = (const char *)a2;
      }
      else {
        uint64_t v13 = *(const char **)a2;
      }
      _DNBLogThreaded("read: %s", v13);
    }
    uint64_t v6 = 0;
    if (SHIBYTE(v15) < 0) {
      goto LABEL_22;
    }
  }
  else
  {
    if (v5) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = 2;
    }
    *a1 = -1;
    if (SHIBYTE(v15) < 0) {
LABEL_22:
    }
      operator delete(__p[1]);
  }
  return v6;
}

void sub_100039FF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RNBSocket::Write(RNBSocket *this, const void *a2, size_t a3)
{
  int v4 = *(_DWORD *)this;
  if (v4 == -1) {
    return 1;
  }
  *(_OWORD *)long long __p = 0u;
  long long v11 = 0u;
  ssize_t v7 = write(v4, a2, a3);
  if (v7 < 0
    && (LODWORD(__p[0]) = *__error(), HIDWORD(__p[0]) = 2, LOBYTE(__p[1]) = 0, HIBYTE(v11) = 0, LODWORD(__p[0]))
    || DNBLogCheckLogBit(0x80000))
  {
    DNBError::LogThreaded((DNBError *)__p, "::write(int socket = %i, buffer = %p, length = %llu) => %i", *(_DWORD *)this, a2, a3, v7);
  }
  uint64_t v8 = 1;
  if ((v7 & 0x8000000000000000) == 0 && v7 == a3)
  {
    if (DNBLogEnabledForAny(0x800000)) {
      _DNBLogThreaded("putpkt: %*s", a3, (const char *)a2);
    }
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("sent: %*s", a3, (const char *)a2);
    }
    uint64_t v8 = 0;
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[1]);
  }
  return v8;
}

void sub_10003A124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

uint64_t ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy(a1, a2[1]);
    lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(a2 + 5));
    operator delete(a2);
  }
}

uint64_t **std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  ssize_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        ssize_t v7 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= v8) {
        return v9;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        ssize_t v7 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_9:
    long long v11 = operator new(0xA8uLL);
    v11[8] = **a4;
    lldb_private::SocketAddress::SocketAddress((lldb_private::SocketAddress *)(v11 + 10));
    *(void *)long long v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    *ssize_t v7 = (uint64_t *)v11;
    uint64_t v12 = (uint64_t *)**a1;
    uint64_t v13 = (uint64_t *)v11;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return (uint64_t **)v11;
}

void sub_10003A298(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::vector<kevent>::__append(char **a1, unint64_t a2)
{
  int64_t v5 = a1[1];
  int v4 = a1[2];
  if (a2 <= (v4 - v5) >> 5)
  {
    if (a2)
    {
      uint64_t v12 = 32 * a2;
      bzero(a1[1], 32 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 5;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 59) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 4 > v8) {
      unint64_t v8 = v9 >> 4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 59) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      long long v11 = (char *)operator new(32 * v10);
    }
    else
    {
      long long v11 = 0;
    }
    uint64_t v13 = &v11[32 * v7];
    size_t v14 = 32 * a2;
    long long v15 = &v11[32 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        long long v17 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v13 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v13 - 1) = v17;
        v13 -= 32;
        v5 -= 32;
      }
      while (v5 != v6);
      int64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void std::vector<kevent>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_10003A478(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

char *SysSignal::Name(SysSignal *this)
{
  if ((this - 1) > 0x1E) {
    return 0;
  }
  else {
    return off_100069260[(int)this - 1];
  }
}

BOOL CFBundle::SetPath(CFBundle *this, const char *a2)
{
  int v4 = (const void *)*((void *)this + 1);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 1) = 0;
  }
  int64_t v5 = (const void *)*((void *)this + 3);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 3) = 0;
  }
  CFString::CFString((CFString *)&v12, 0);
  CFString::SetFileSystemRepresentation((CFString *)&v12, a2);
  if (filePath)
  {
    CFURLRef v6 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, filePath, kCFURLPOSIXPathStyle, 1u);
    CFURLRef v7 = (const __CFURL *)*((void *)this + 3);
    if (v7 != v6)
    {
      if (v7) {
        CFRelease(v7);
      }
      *((void *)this + 3) = v6;
    }
    if (v6)
    {
      CFBundleRef v8 = CFBundleCreate(kCFAllocatorDefault, v6);
      CFBundleRef v9 = (CFBundleRef)*((void *)this + 1);
      if (v9 != v8)
      {
        if (v9) {
          CFRelease(v9);
        }
        *((void *)this + 1) = v8;
      }
    }
  }
  BOOL v10 = *((void *)this + 1) != 0;
  CFString::~CFString((CFString *)&v12);
  return v10;
}

void CFBundle::CFBundle(CFBundle *this, const char *a2)
{
  *(void *)this = off_100069368;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = off_100068CA8;
  *((void *)this + 3) = 0;
  if (a2)
  {
    if (*a2) {
      CFBundle::SetPath(this, a2);
    }
  }
}

void CFBundle::~CFBundle(CFBundle *this)
{
  *(void *)this = off_100069368;
  *((void *)this + 2) = off_100068CA8;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 3) = 0;
  }
  *(void *)this = off_100069388;
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 1) = 0;
  }
}

{
  const void *v2;
  const void *v3;
  uint64_t vars8;

  *(void *)this = off_100069368;
  *((void *)this + 2) = off_100068CA8;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 3) = 0;
  }
  *(void *)this = off_100069388;
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 1) = 0;
  }

  operator delete();
}

__CFBundle *CFBundle::GetIdentifier(CFBundle *this)
{
  uint64_t result = (__CFBundle *)*((void *)this + 1);
  if (result) {
    return (__CFBundle *)CFBundleGetIdentifier(result);
  }
  return result;
}

__CFBundle *CFBundle::CopyExecutableURL(CFBundle *this)
{
  uint64_t result = (__CFBundle *)*((void *)this + 1);
  if (result) {
    return CFBundleCopyExecutableURL(result);
  }
  return result;
}

void *CFReleaser<__CFBundle *>::~CFReleaser(void *a1)
{
  *a1 = off_100069388;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

void CFReleaser<__CFBundle *>::~CFReleaser(void *a1)
{
  *a1 = off_100069388;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void CFString::CFString(CFString *this, const __CFString *a2)
{
  *(void *)this = off_1000693A8;
  *((void *)this + 1) = a2;
}

void CFString::CFString(CFString *this, const char *a2, CFStringEncoding a3)
{
  *(void *)this = off_1000693A8;
  *((void *)this + 1) = 0;
  if (a2)
  {
    if (*a2)
    {
      CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, a2, a3);
      CFStringRef v5 = (CFStringRef)*((void *)this + 1);
      if (v5 != v4)
      {
        if (v5) {
          CFRelease(v5);
        }
        *((void *)this + 1) = v4;
      }
    }
  }
}

void CFString::~CFString(CFString *this)
{
  *(void *)this = off_1000691B0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 1) = 0;
  }
}

{
  const void *v2;
  uint64_t vars8;

  *(void *)this = off_1000691B0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 1) = 0;
  }

  operator delete();
}

CFStringRef CFString::SetFileSystemRepresentation(CFString *this, const char *a2)
{
  if (a2 && *a2) {
    CFStringRef v3 = CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, a2);
  }
  else {
    CFStringRef v3 = 0;
  }
  CFStringRef v4 = (CFStringRef)*((void *)this + 1);
  if (v4 != v3)
  {
    if (v4) {
      CFRelease(v4);
    }
    *((void *)this + 1) = v3;
  }
  return v3;
}

uint64_t CFString::GlobPath(const char *a1, uint64_t a2)
{
  if (glob(a1, 2048, 0, &v4))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      **(unsigned char **)a2 = 0;
      *(void *)(a2 + 8) = 0;
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 23) = 0;
    }
  }
  else
  {
    std::string::assign((std::string *)a2, *(const std::string::value_type **)v4.gl_pathv);
    globfree(&v4);
  }
  if (*(char *)(a2 + 23) >= 0) {
    return a2;
  }
  else {
    return *(void *)a2;
  }
}

const __CFString *CFString::UTF8(const __CFString *result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  CFStringRef v3 = result;
  CFIndex Length = CFStringGetLength(result);
  int64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding < 1) {
    return 0;
  }
  std::string::resize((std::string *)a2, MaximumSizeForEncoding, 0);
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    CFIndex v6 = *(unsigned __int8 *)(a2 + 23);
    if (*(unsigned char *)(a2 + 23))
    {
      CFURLRef v7 = (char *)a2;
      goto LABEL_8;
    }
    return 0;
  }
  CFIndex v6 = *(void *)(a2 + 8);
  if (!v6) {
    return 0;
  }
  CFURLRef v7 = *(char **)a2;
LABEL_8:
  if (!CFStringGetCString(v3, v7, v6, 0x8000100u)) {
    return 0;
  }
  if (*(char *)(a2 + 23) >= 0) {
    CFBundleRef v8 = (const char *)a2;
  }
  else {
    CFBundleRef v8 = *(const char **)a2;
  }
  size_t v9 = strlen(v8);
  std::string::resize((std::string *)a2, v9, 0);
  if (*(char *)(a2 + 23) >= 0) {
    return (const __CFString *)a2;
  }
  else {
    return *(const __CFString **)a2;
  }
}

void Genealogy::Genealogy(Genealogy *this)
{
  *((void *)this + 11) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  *((void *)this + 10) = (char *)this + 88;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((unsigned char *)this + 128) = 0;
  *(void *)this = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_diagnostic_for_pid");
  *((void *)this + 1) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_processes");
  *((void *)this + 2) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_breadcrumbs");
  *((void *)this + 3) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_messages");
  *((void *)this + 4) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_activities");
  *((void *)this + 5) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_trace_get_type");
  *((void *)this + 6) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_trace_copy_formatted_message");
  *((void *)this + 7) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_for_thread");
  *((void *)this + 8) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_for_task_thread");
  *((void *)this + 9) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_messages_for_thread");
}

void Genealogy::GetGenealogyInfoForThread(Genealogy *this@<X0>, const MachThreadList *a2@<X3>, BOOL *a3@<X5>, uint64_t a4@<X1>, unint64_t a5@<X2>, int a6@<W4>, void *a7@<X8>)
{
  *a7 = 0;
  a7[1] = 0;
  if (!*((void *)this + 12) && !*((unsigned char *)this + 128)) {
    Genealogy::GetActivities(this, a4, a2, a6);
  }
  long long v11 = (void *)*((void *)this + 11);
  if (v11)
  {
    uint64_t v12 = (void *)((char *)this + 88);
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= a5;
      if (v13 >= a5) {
        long long v15 = v11;
      }
      else {
        long long v15 = v11 + 1;
      }
      if (v14) {
        uint64_t v12 = v11;
      }
      long long v11 = (void *)*v15;
    }
    while (*v15);
    if (v12 != (void *)((char *)this + 88) && v12[4] <= a5)
    {
      uint64_t v17 = v12[5];
      uint64_t v16 = v12[6];
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      *a7 = v17;
      a7[1] = v16;
    }
  }
  *a3 = *((unsigned char *)this + 128);
}

void Genealogy::GetActivities(Genealogy *this, uint64_t a2, const MachThreadList *a3, int a4)
{
  if (!*(void *)this
    || !*((void *)this + 1)
    || !*((void *)this + 2)
    || !*((void *)this + 3)
    || !*((void *)this + 4)
    || !*((void *)this + 5)
    || !*((void *)this + 6)
    || *(_OWORD *)((char *)this + 56) == 0)
  {
    return;
  }
  uint64_t v51 = 0;
  unint64_t v52 = &v51;
  uint64_t v53 = 0x2000000000;
  dispatch_semaphore_t v54 = 0;
  dispatch_semaphore_t v54 = dispatch_semaphore_create(0);
  v47[0] = 0;
  v47[1] = v47;
  v47[2] = 0x4002000000;
  v47[3] = __Block_byref_object_copy_;
  v47[4] = __Block_byref_object_dispose_;
  uint64_t v48 = 0;
  long long v49 = 0;
  uint64_t v50 = 0;
  uint64_t v39 = 0;
  long long v40 = &v39;
  uint64_t v41 = 0x4002000000;
  unint64_t v42 = __Block_byref_object_copy__10;
  uint64_t v43 = __Block_byref_object_dispose__11;
  BOOL v44 = 0;
  unsigned int v45 = 0;
  uint64_t v46 = 0;
  v35[0] = 0;
  v35[1] = v35;
  v35[2] = 0x4002000000;
  v35[3] = __Block_byref_object_copy__12;
  v35[4] = __Block_byref_object_dispose__13;
  long long __p = 0;
  long long v37 = 0;
  uint64_t v38 = 0;
  uint64_t v28 = 0;
  long long v29 = &v28;
  uint64_t v30 = 0x4002000000;
  long long v31 = __Block_byref_object_copy__14;
  v34[0] = 0;
  v34[1] = 0;
  long long v32 = __Block_byref_object_dispose__15;
  long long v33 = v34;
  CFBundleRef v8 = *(unsigned int (**)(uint64_t, void, uint64_t, void *))this;
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 1107296256;
  v25[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke;
  v25[3] = &__block_descriptor_tmp_34;
  v25[4] = v47;
  v25[5] = &v39;
  v25[9] = this;
  v25[10] = a3;
  int v26 = a2;
  int v27 = a4;
  v25[6] = v35;
  v25[7] = &v28;
  v25[8] = &v51;
  if (v8(a2, 0, 9, v25)
    && (dispatch_time_t v9 = dispatch_time(0, 500000000), dispatch_semaphore_wait((dispatch_semaphore_t)v52[3], v9)))
  {
    *((unsigned char *)this + 128) = 1;
  }
  else
  {
    BOOL v10 = (uint64_t *)v29[5];
    if (v10 != v29 + 6)
    {
      do
      {
        uint64_t v12 = v40[5];
        for (uint64_t i = v40[6]; v12 != i; v12 += 72)
        {
          if (*(void *)(v12 + 8) == v10[5]) {
            operator new();
          }
        }
        unint64_t v13 = (uint64_t *)v10[1];
        if (v13)
        {
          do
          {
            BOOL v14 = v13;
            unint64_t v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            BOOL v14 = (uint64_t *)v10[2];
            BOOL v15 = *v14 == (void)v10;
            BOOL v10 = v14;
          }
          while (!v15);
        }
        BOOL v10 = v14;
      }
      while (v14 != v29 + 6);
    }
  }
  _Block_object_dispose(&v28, 8);
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy((uint64_t)&v33, v34[0]);
  _Block_object_dispose(v35, 8);
  uint64_t v16 = (void **)__p;
  if (__p)
  {
    uint64_t v17 = v37;
    uint64_t v18 = __p;
    if (v37 != __p)
    {
      do
      {
        if (*((char *)v17 - 1) < 0) {
          operator delete(*(v17 - 3));
        }
        v17 -= 8;
      }
      while (v17 != v16);
      uint64_t v18 = __p;
    }
    long long v37 = v16;
    operator delete(v18);
  }
  _Block_object_dispose(&v39, 8);
  int v19 = (void **)v44;
  if (v44)
  {
    long long v20 = v45;
    uint64_t v21 = v44;
    if (v45 == v44)
    {
LABEL_44:
      unsigned int v45 = v19;
      operator delete(v21);
      goto LABEL_45;
    }
    while (1)
    {
      if (*((char *)v20 - 1) < 0)
      {
        operator delete(*(v20 - 3));
        if (*((char *)v20 - 25) < 0) {
LABEL_42:
        }
          operator delete(*(v20 - 6));
      }
      else if (*((char *)v20 - 25) < 0)
      {
        goto LABEL_42;
      }
      v20 -= 9;
      if (v20 == v19)
      {
        uint64_t v21 = v44;
        goto LABEL_44;
      }
    }
  }
LABEL_45:
  _Block_object_dispose(v47, 8);
  int v22 = v48;
  if (v48)
  {
    int v23 = v49;
    int v24 = v48;
    if (v49 != v48)
    {
      do
      {
        if (*((char *)v23 - 1) < 0) {
          operator delete(*(v23 - 3));
        }
        v23 -= 6;
      }
      while (v23 != v22);
      int v24 = v48;
    }
    long long v49 = v22;
    operator delete(v24);
  }
  _Block_object_dispose(&v51, 8);
}

void Genealogy::Clear(Genealogy *this)
{
  uint64_t v1 = (char *)this + 88;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy((uint64_t)this + 80, *((void **)this + 11));
  *((void *)v1 - 1) = v1;
  *(void *)uint64_t v1 = 0;
  *((void *)v1 + 1) = 0;
  v1[40] = 0;
}

__n128 __Block_byref_object_copy_(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    glob_t v4 = *(void **)(a1 + 40);
    if (v3 != v1)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 48;
      }
      while (v3 != v1);
      glob_t v4 = *(void **)(a1 + 40);
    }
    *(void *)(a1 + 48) = v1;
    operator delete(v4);
  }
}

__n128 __Block_byref_object_copy__10(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  glob_t v4 = *(void **)(a1 + 40);
  if (v3 != v1)
  {
    while (1)
    {
      if (*(char *)(v3 - 1) < 0)
      {
        operator delete(*(void **)(v3 - 24));
        if (*(char *)(v3 - 25) < 0) {
LABEL_9:
        }
          operator delete(*(void **)(v3 - 48));
      }
      else if (*(char *)(v3 - 25) < 0)
      {
        goto LABEL_9;
      }
      v3 -= 72;
      if (v3 == v1)
      {
        glob_t v4 = *(void **)(a1 + 40);
        break;
      }
    }
  }
  *(void *)(a1 + 48) = v1;

  operator delete(v4);
}

__n128 __Block_byref_object_copy__12(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    glob_t v4 = *(void **)(a1 + 40);
    if (v3 != v1)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 64;
      }
      while (v3 != v1);
      glob_t v4 = *(void **)(a1 + 40);
    }
    *(void *)(a1 + 48) = v1;
    operator delete(v4);
  }
}

void *__Block_byref_object_copy__14(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  glob_t v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    void *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

intptr_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3)
  {
    v8[0] = _NSConcreteStackBlock;
    long long v4 = *(_OWORD *)(a1 + 72);
    uint64_t v5 = *(void (**)(uint64_t, void *))(*(void *)(a1 + 72) + 8);
    v8[1] = 1107296256;
    int v8[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_32;
    long long v11 = v4;
    uint64_t v12 = *(void *)(a1 + 88);
    long long v6 = *(_OWORD *)(a1 + 48);
    long long v9 = *(_OWORD *)(a1 + 32);
    long long v10 = v6;
    v5(a2, v8);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 56))
  {
    uint64_t v3 = *(void *)(a1 + 64);
    long long v4 = *(void (**)(uint64_t, void *))(v3 + 16);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 1107296256;
    unint64_t v37[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_3;
    v37[3] = &__block_descriptor_tmp;
    v37[4] = *(void *)(a1 + 32);
    v4(a2, v37);
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 32);
    uint64_t v6 = *(void *)(a2 + 16);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 1107296256;
    v36[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_17;
    v36[3] = &__block_descriptor_tmp_21;
    v36[4] = *(void *)(a1 + 40);
    v5(v6, a2, v36);
    CFURLRef v7 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 24);
    uint64_t v8 = *(void *)(a2 + 8);
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 1107296256;
    v35[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_22;
    v35[3] = &__block_descriptor_tmp_26;
    v35[4] = *(void *)(a1 + 48);
    void v35[5] = v3;
    v7(v8, a2, v35);
    uint64_t v9 = MachThreadList::NumThreads(*(MachThreadList **)(a1 + 72));
    if (v9)
    {
      uint64_t v10 = v9;
      for (unint64_t i = 0; i != v10; ++i)
      {
        unint64_t v12 = MachThreadList::ThreadIDAtIndex(*(MachThreadList **)(a1 + 72), i);
        unint64_t v13 = *(uint64_t (**)(void, unint64_t))(v3 + 64);
        if (v13)
        {
          uint64_t v14 = v13(*(unsigned int *)(a1 + 84), v12);
          if (v14) {
            goto LABEL_12;
          }
        }
        else
        {
          BOOL v15 = *(uint64_t (**)(uint64_t, unint64_t))(v3 + 56);
          if (v15)
          {
            uint64_t v14 = v15(a2, v12);
            if (v14)
            {
LABEL_12:
              uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
              uint64_t v18 = (uint64_t **)(v16 + 48);
              uint64_t v17 = *(uint64_t **)(v16 + 48);
              if (v17)
              {
                while (1)
                {
                  while (1)
                  {
                    int v19 = (uint64_t **)v17;
                    unint64_t v20 = v17[4];
                    if (v12 >= v20) {
                      break;
                    }
                    uint64_t v17 = *v19;
                    uint64_t v18 = v19;
                    if (!*v19) {
                      goto LABEL_19;
                    }
                  }
                  if (v20 >= v12) {
                    break;
                  }
                  uint64_t v17 = v19[1];
                  if (!v17)
                  {
                    uint64_t v18 = v19 + 1;
                    goto LABEL_19;
                  }
                }
              }
              else
              {
                int v19 = (uint64_t **)(v16 + 48);
LABEL_19:
                uint64_t v21 = (uint64_t *)v19;
                int v19 = (uint64_t **)operator new(0x30uLL);
                v19[4] = (uint64_t *)v12;
                v19[5] = 0;
                *int v19 = 0;
                v19[1] = 0;
                v19[2] = v21;
                void *v18 = (uint64_t *)v19;
                uint64_t v22 = **(void **)(v16 + 40);
                int v23 = (uint64_t *)v19;
                if (v22)
                {
                  *(void *)(v16 + 40) = v22;
                  int v23 = *v18;
                }
                std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v16 + 48), v23);
                ++*(void *)(v16 + 56);
              }
              v19[5] = (uint64_t *)v14;
            }
          }
        }
      }
    }
    if (*(void *)(a2 + 16))
    {
      int v24 = *(void **)(*(void *)(a1 + 56) + 8);
      if (v24[7])
      {
        int v25 = (void *)v24[5];
        if (v25 != v24 + 6)
        {
          do
          {
            uint64_t v26 = v25[5];
            uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void))(v3 + 72))(a2, v26, v25[4]);
            uint64_t v28 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 24);
            v34[0] = _NSConcreteStackBlock;
            v34[1] = 1107296256;
            v34[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_27;
            v34[3] = &__block_descriptor_tmp_30;
            v34[5] = v3;
            v34[6] = v26;
            v34[4] = *(void *)(a1 + 48);
            v28(v27, a2, v34);
            long long v29 = (void *)v25[1];
            if (v29)
            {
              do
              {
                uint64_t v30 = v29;
                long long v29 = (void *)*v29;
              }
              while (v29);
            }
            else
            {
              do
              {
                uint64_t v30 = (void *)v25[2];
                BOOL v31 = *v30 == (void)v25;
                int v25 = v30;
              }
              while (!v31);
            }
            int v25 = v30;
          }
          while (v30 != (void *)(*(void *)(*(void *)(a1 + 56) + 8) + 48));
        }
      }
    }
  }
  return 1;
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_3(uint64_t a1, uint64_t a2)
{
  memset(&__p, 0, sizeof(__p));
  *(_DWORD *)long long v11 = *(_DWORD *)a2;
  *(_OWORD *)&v11[8] = *(_OWORD *)(a2 + 8);
  uint64_t v3 = *(const std::string::value_type **)(a2 + 24);
  if (v3) {
    std::string::assign(&__p, v3);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v5 = *(void *)(v4 + 48);
  if (v5 >= *(void *)(v4 + 56))
  {
    uint64_t v9 = std::vector<Genealogy::Breadcrumb>::__push_back_slow_path<Genealogy::Breadcrumb const&>(v4 + 40, (uint64_t)v11);
  }
  else
  {
    long long v6 = *(_OWORD *)v11;
    *(void *)(v5 + 16) = *(void *)&v11[16];
    *(_OWORD *)unint64_t v5 = v6;
    CFURLRef v7 = (std::string *)(v5 + 24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v7, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v8 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v5 + 40) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
    }
    uint64_t v9 = (char *)(v5 + 48);
  }
  *(void *)(v4 + 48) = v9;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 1;
}

void __copy_helper_block_8_32r(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32r(uint64_t a1)
{
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_17(uint64_t a1, long long *a2)
{
  memset(__p, 0, 32);
  *(_OWORD *)uint64_t v18 = 0u;
  long long v16 = *a2;
  uint64_t v5 = *((void *)a2 + 2);
  uint64_t v4 = (const std::string::value_type *)*((void *)a2 + 3);
  uint64_t v17 = v5;
  if (v4) {
    std::string::assign((std::string *)v18, v4);
  }
  long long v6 = (const std::string::value_type *)*((void *)a2 + 4);
  if (v6) {
    std::string::assign((std::string *)&__p[1], v6);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v8 = *(void *)(v7 + 48);
  if (v8 >= *(void *)(v7 + 56))
  {
    unint64_t v12 = std::vector<Genealogy::Activity>::__push_back_slow_path<Genealogy::Activity const&>((void **)(v7 + 40), (uint64_t)&v16);
  }
  else
  {
    long long v9 = v16;
    *(void *)(v8 + 16) = v17;
    *(_OWORD *)unint64_t v8 = v9;
    uint64_t v10 = (std::string *)(v8 + 24);
    if (SHIBYTE(__p[0]) < 0)
    {
      std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)v18[0], (std::string::size_type)v18[1]);
    }
    else
    {
      long long v11 = *(_OWORD *)v18;
      *(void **)(v8 + 40) = __p[0];
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
    }
    unint64_t v13 = (std::string *)(v8 + 48);
    if (SHIBYTE(__p[3]) < 0)
    {
      std::string::__init_copy_ctor_external(v13, (const std::string::value_type *)__p[1], (std::string::size_type)__p[2]);
    }
    else
    {
      long long v14 = *(_OWORD *)&__p[1];
      *(void **)(v8 + 64) = __p[3];
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
    }
    unint64_t v12 = (char *)(v8 + 72);
  }
  *(void *)(v7 + 48) = v12;
  if (SHIBYTE(__p[3]) < 0)
  {
    operator delete(__p[1]);
    if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
      return 1;
    }
LABEL_18:
    operator delete(v18[0]);
    return 1;
  }
  if (SHIBYTE(__p[0]) < 0) {
    goto LABEL_18;
  }
  return 1;
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_22(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  memset(&__p, 0, sizeof(__p));
  long long v14 = *((unint64_t *)a2 + 2);
  long long v15 = *a2;
  LOBYTE(v16) = (*(uint64_t (**)(long long *))(v4 + 40))(a2);
  if (*((void *)a2 + 5) && *((void *)a2 + 6)) {
    operator new();
  }
  uint64_t v5 = (const std::string::value_type *)(*(uint64_t (**)(long long *))(v4 + 48))(a2);
  if (v5) {
    std::string::assign(&__p, v5);
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v7 = *(void *)(v6 + 48);
  if (v7 >= *(void *)(v6 + 56))
  {
    unint64_t v12 = std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>(v6 + 40, (uint64_t)&v14);
  }
  else
  {
    long long v8 = v14;
    long long v9 = v15;
    *(void *)(v7 + 32) = v16;
    *(_OWORD *)unint64_t v7 = v8;
    *(_OWORD *)(v7 + 16) = v9;
    uint64_t v10 = (std::string *)(v7 + 40);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v10, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v11 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v7 + 56) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
    }
    unint64_t v12 = (char *)(v7 + 64);
  }
  *(void *)(v6 + 48) = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 1;
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_27(void *a1, long long *a2)
{
  uint64_t v4 = a1[5];
  memset(&__p, 0, sizeof(__p));
  *(void *)&long long v14 = *((void *)a2 + 2);
  long long v15 = *a2;
  LOBYTE(v16) = (*(uint64_t (**)(long long *))(v4 + 40))(a2);
  *((void *)&v14 + 1) = a1[6];
  if (*((void *)a2 + 5) && *((void *)a2 + 6)) {
    operator new();
  }
  uint64_t v5 = (const std::string::value_type *)(*(uint64_t (**)(long long *))(v4 + 48))(a2);
  if (v5) {
    std::string::assign(&__p, v5);
  }
  uint64_t v6 = *(void *)(a1[4] + 8);
  unint64_t v7 = *(void *)(v6 + 48);
  if (v7 >= *(void *)(v6 + 56))
  {
    unint64_t v12 = std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>(v6 + 40, (uint64_t)&v14);
  }
  else
  {
    long long v8 = v14;
    long long v9 = v15;
    *(void *)(v7 + 32) = v16;
    *(_OWORD *)unint64_t v7 = v8;
    *(_OWORD *)(v7 + 16) = v9;
    uint64_t v10 = (std::string *)(v7 + 40);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v10, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v11 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v7 + 56) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
    }
    unint64_t v12 = (char *)(v7 + 64);
  }
  *(void *)(v6 + 48) = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 1;
}

void __copy_helper_block_8_32r40r48r56r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 8);
  _Block_object_assign((void *)(a1 + 48), *(const void **)(a2 + 48), 8);
  uint64_t v4 = *(const void **)(a2 + 56);

  _Block_object_assign((void *)(a1 + 56), v4, 8);
}

void __destroy_helper_block_8_32r40r48r56r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 56), 8);
  _Block_object_dispose(*(const void **)(a1 + 48), 8);
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  uint64_t v2 = *(const void **)(a1 + 32);

  _Block_object_dispose(v2, 8);
}

void __copy_helper_block_8_32r40r48r56r64r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 8);
  _Block_object_assign((void *)(a1 + 48), *(const void **)(a2 + 48), 8);
  _Block_object_assign((void *)(a1 + 56), *(const void **)(a2 + 56), 8);
  uint64_t v4 = *(const void **)(a2 + 64);

  _Block_object_assign((void *)(a1 + 64), v4, 8);
}

void __destroy_helper_block_8_32r40r48r56r64r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 64), 8);
  _Block_object_dispose(*(const void **)(a1 + 56), 8);
  _Block_object_dispose(*(const void **)(a1 + 48), 8);
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  uint64_t v2 = *(const void **)(a1 + 32);

  _Block_object_dispose(v2, 8);
}

uint64_t Genealogy::GetProcessExecutableInfosAtIndex@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  if (a2)
  {
    uint64_t v3 = a2 - 1;
    uint64_t v4 = *(void *)(this + 104);
    if (a2 - 1 <= (unint64_t)((*(void *)(this + 112) - v4) >> 4))
    {
      long long v5 = *(_OWORD *)(v4 + 16 * v3);
      uint64_t v6 = *(void *)(v4 + 16 * v3 + 8);
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)a3 = v5;
    }
  }
  return this;
}

void std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy(a1, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(a2);
  }
}

char *std::vector<Genealogy::Breadcrumb>::__push_back_slow_path<Genealogy::Breadcrumb const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)a1;
  uint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    abort();
  }
  if (0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 4) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v8 = 0x555555555555555;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v9 = (char *)operator new(48 * v8);
  }
  else
  {
    long long v9 = 0;
  }
  uint64_t v10 = (std::string *)&v9[48 * v4];
  *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
  v10->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  long long v11 = v10 + 1;
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
    uint64_t v2 = *(void ***)a1;
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
    v10[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
  }
  unint64_t v12 = &v9[48 * v8];
  unint64_t v13 = (char *)&v10[2];
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 16) = v12;
  }
  else
  {
    do
    {
      long long v14 = *((_OWORD *)v3 - 3);
      v10[-2].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v3 - 4);
      *(_OWORD *)&v10[-2].__r_.__value_.__l.__data_ = v14;
      long long v15 = *(_OWORD *)(v3 - 3);
      v10[-1].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v3 - 1);
      *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = v15;
      v10 -= 2;
      *(v3 - 2) = 0;
      *(v3 - 1) = 0;
      *(v3 - 3) = 0;
      v3 -= 6;
    }
    while (v3 != v2);
    uint64_t v2 = *(void ***)a1;
    uint64_t v16 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 16) = v12;
    while (v16 != v2)
    {
      if (*((char *)v16 - 1) < 0) {
        operator delete(*(v16 - 3));
      }
      v16 -= 6;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

char *std::vector<Genealogy::Activity>::__push_back_slow_path<Genealogy::Activity const&>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39 * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  if (0x1C71C71C71C71C72 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x1C71C71C71C71C72 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0x8E38E38E38E38E39 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v6 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v7 = operator new(72 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  unint64_t v8 = (std::string *)&v7[9 * v2];
  *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
  v8->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  long long v9 = v8 + 1;
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
    v8[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
  }
  uint64_t v10 = (std::string *)&v7[9 * v2 + 6];
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 48);
    v7[9 * v2 + 8] = *(void *)(a2 + 64);
  }
  long long v11 = (char *)&v7[9 * v6];
  unint64_t v12 = (char *)&v8[3];
  unint64_t v13 = (void **)*a1;
  long long v14 = (void **)a1[1];
  if (v14 != *a1)
  {
    do
    {
      long long v15 = *(_OWORD *)(v14 - 9);
      v8[-3].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v14 - 7);
      *(_OWORD *)&v8[-3].__r_.__value_.__l.__data_ = v15;
      long long v16 = *((_OWORD *)v14 - 3);
      v8[-2].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v14 - 4);
      *(_OWORD *)&v8[-2].__r_.__value_.__l.__data_ = v16;
      *(v14 - 5) = 0;
      *(v14 - 4) = 0;
      *(v14 - 6) = 0;
      long long v17 = *(_OWORD *)(v14 - 3);
      v8[-1].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v14 - 1);
      *(_OWORD *)&v8[-1].__r_.__value_.__l.__data_ = v17;
      v8 -= 3;
      *(v14 - 2) = 0;
      *(v14 - 1) = 0;
      *(v14 - 3) = 0;
      v14 -= 9;
    }
    while (v14 != v13);
    long long v14 = (void **)*a1;
    uint64_t v18 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v12;
    a1[2] = v11;
    while (1)
    {
      if (v18 == v14) {
        goto LABEL_28;
      }
      if (*((char *)v18 - 1) < 0)
      {
        operator delete(*(v18 - 3));
        if ((*((char *)v18 - 25) & 0x80000000) == 0) {
          goto LABEL_20;
        }
      }
      else if ((*((char *)v18 - 25) & 0x80000000) == 0)
      {
        goto LABEL_20;
      }
      operator delete(*(v18 - 6));
LABEL_20:
      v18 -= 9;
    }
  }
  *a1 = v8;
  a1[1] = v12;
  a1[2] = v11;
LABEL_28:
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void std::__shared_ptr_pointer<Genealogy::ProcessExecutableInfo *,std::shared_ptr<Genealogy::ProcessExecutableInfo>::__shared_ptr_default_delete<Genealogy::ProcessExecutableInfo,Genealogy::ProcessExecutableInfo>,std::allocator<Genealogy::ProcessExecutableInfo>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t std::__shared_ptr_pointer<Genealogy::ProcessExecutableInfo *,std::shared_ptr<Genealogy::ProcessExecutableInfo>::__shared_ptr_default_delete<Genealogy::ProcessExecutableInfo,Genealogy::ProcessExecutableInfo>,std::allocator<Genealogy::ProcessExecutableInfo>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

char *std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void ***)a1;
  unint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 6;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 58) {
    abort();
  }
  uint64_t v8 = *(void *)(a1 + 16) - (void)v2;
  if (v8 >> 5 > v5) {
    unint64_t v5 = v8 >> 5;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v9 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 58) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v10 = (char *)operator new(v9 << 6);
  }
  else
  {
    uint64_t v10 = 0;
  }
  long long v11 = &v10[64 * v4];
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)long long v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((void *)v11 + 4) = *(void *)(a2 + 32);
  unint64_t v13 = (std::string *)(v11 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
    unint64_t v2 = *(void ***)a1;
    unint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 40);
    *((void *)v11 + 7) = *(void *)(a2 + 56);
  }
  long long v14 = &v10[64 * v9];
  long long v15 = v11 + 64;
  if (v3 == v2)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
  }
  else
  {
    do
    {
      long long v16 = *((_OWORD *)v3 - 4);
      long long v17 = *((_OWORD *)v3 - 3);
      *((void *)v11 - 4) = *(v3 - 4);
      *((_OWORD *)v11 - 4) = v16;
      *((_OWORD *)v11 - 3) = v17;
      long long v18 = *(_OWORD *)(v3 - 3);
      *((void *)v11 - 1) = *(v3 - 1);
      *(_OWORD *)(v11 - 24) = v18;
      v11 -= 64;
      *(v3 - 2) = 0;
      *(v3 - 1) = 0;
      *(v3 - 3) = 0;
      v3 -= 8;
    }
    while (v3 != v2);
    unint64_t v2 = *(void ***)a1;
    int v19 = *(void ***)(a1 + 8);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
    while (v19 != v2)
    {
      if (*((char *)v19 - 1) < 0) {
        operator delete(*(v19 - 3));
      }
      v19 -= 8;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v15;
}

void std::__shared_ptr_pointer<Genealogy::ThreadActivity *,std::shared_ptr<Genealogy::ThreadActivity>::__shared_ptr_default_delete<Genealogy::ThreadActivity,Genealogy::ThreadActivity>,std::allocator<Genealogy::ThreadActivity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

Genealogy::ThreadActivity *std::__shared_ptr_pointer<Genealogy::ThreadActivity *,std::shared_ptr<Genealogy::ThreadActivity>::__shared_ptr_default_delete<Genealogy::ThreadActivity,Genealogy::ThreadActivity>,std::allocator<Genealogy::ThreadActivity>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(Genealogy::ThreadActivity **)(a1 + 24);
  if (result)
  {
    Genealogy::ThreadActivity::~ThreadActivity(result);
    operator delete();
  }
  return result;
}

void Genealogy::ThreadActivity::~ThreadActivity(Genealogy::ThreadActivity *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 13);
    uint64_t v4 = (void *)*((void *)this + 12);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 48;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 12);
    }
    *((void *)this + 13) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *((void *)this + 9);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 10);
    unint64_t v7 = (void *)*((void *)this + 9);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0) {
          operator delete(*(void **)(v6 - 24));
        }
        v6 -= 64;
      }
      while (v6 != v5);
      unint64_t v7 = (void *)*((void *)this + 9);
    }
    *((void *)this + 10) = v5;
    operator delete(v7);
  }
  if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    if ((*((char *)this + 47) & 0x80000000) == 0) {
      return;
    }
LABEL_21:
    operator delete(*((void **)this + 3));
    return;
  }
  operator delete(*((void **)this + 6));
  if (*((char *)this + 47) < 0) {
    goto LABEL_21;
  }
}

uint64_t catch_mach_exception_raise_state(int a1, int a2, uint64_t a3, int a4)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    if ((a2 - 1) > 0xC) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = off_100069548[a2 - 1];
    }
    _DNBLogThreaded("::%s(exc_port = 0x%4.4x, exc_type = %d(%s), exc_int data = 0x%llx, exc_data_count = %d)", "catch_mach_exception_raise_state", a1, a2, v8, a3, a4);
  }
  return 5;
}

uint64_t catch_mach_exception_raise_state_identity(int a1, int a2, int a3, int a4, uint64_t *a5, int a6)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    if ((a4 - 1) > 0xC) {
      long long v12 = 0;
    }
    else {
      long long v12 = off_100069548[a4 - 1];
    }
    uint64_t v13 = 3135093469;
    if (a6)
    {
      uint64_t v14 = *a5;
      if (a6 != 1) {
        uint64_t v13 = a5[1];
      }
    }
    else
    {
      uint64_t v14 = 3135093469;
    }
    _DNBLogThreaded("::%s(exc_port = 0x%4.4x, thd_port = 0x%4.4x, tsk_port = 0x%4.4x, exc_type = %d(%s), exc_data[%d] = { 0x%llx, 0x%llx })", "catch_mach_exception_raise_state_identity", a1, a2, a3, a4, v12, a6, v14, v13);
  }
  return 5;
}

uint64_t catch_mach_exception_raise(int a1, unsigned int a2, unsigned int a3, unsigned int a4, uint64_t *a5, unsigned int a6)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    if (a4 - 1 > 0xC) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = off_100069548[a4 - 1];
    }
    uint64_t v15 = 3135093469;
    if (a6)
    {
      uint64_t v16 = *a5;
      if (a6 != 1) {
        uint64_t v15 = a5[1];
      }
    }
    else
    {
      uint64_t v16 = 3135093469;
    }
    _DNBLogThreaded("::%s(exc_port = 0x%4.4x, thd_port = 0x%4.4x, tsk_port = 0x%4.4x, exc_type = %d(%s), exc_data[%d] = { 0x%llx, 0x%llx })", "catch_mach_exception_raise", a1, a2, a3, a4, v14, a6, v16, v15);
  }
  long long v17 = (unsigned int *)g_message;
  *(_DWORD *)(g_message + 8) = 0;
  *((void *)v17 + 3) = *((void *)v17 + 2);
  if (*v17 == a3)
  {
    *long long v17 = a3;
    v17[1] = a2;
    v17[2] = a4;
    long long v18 = a5;
    unsigned int v19 = a6;
LABEL_13:
    MachException::Data::AppendExceptionData((MachException::Data *)v17, v18, v19);
    return 0;
  }
  if (MachTask::IsValid((MachTask *)*v17, v12, v13)) {
    return 5;
  }
  uint64_t result = 5;
  if (a4 == 5 && a6 == 2 && *a5 == 65539 && a5[1] == 5)
  {
    uint64_t v21 = g_message;
    *(_DWORD *)g_message = a3;
    *(_DWORD *)(v21 + 4) = a2;
    *(_DWORD *)(v21 + 8) = 5;
    long long v17 = (unsigned int *)v21;
    long long v18 = a5;
    unsigned int v19 = 2;
    goto LABEL_13;
  }
  return result;
}

void MachException::Data::AppendExceptionData(MachException::Data *this, uint64_t *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (char *)*((void *)this + 3);
    uint64_t v7 = a3;
    uint64_t v28 = a3;
    while (1)
    {
      uint64_t v9 = a2[v5];
      unint64_t v10 = *((void *)this + 4);
      if ((unint64_t)v6 >= v10) {
        break;
      }
      *(void *)uint64_t v6 = v9;
      uint64_t v8 = v6 + 8;
LABEL_4:
      *((void *)this + 3) = v8;
      ++v5;
      uint64_t v6 = v8;
      if (v5 == v7) {
        return;
      }
    }
    long long v11 = (char *)*((void *)this + 2);
    uint64_t v12 = (v6 - v11) >> 3;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 61) {
      abort();
    }
    uint64_t v14 = v10 - (void)v11;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v16 = operator new(8 * v15);
    }
    else
    {
      uint64_t v16 = 0;
    }
    long long v17 = (uint64_t *)&v16[8 * v12];
    *long long v17 = v9;
    uint64_t v8 = (char *)(v17 + 1);
    if (v6 == v11) {
      goto LABEL_29;
    }
    unint64_t v18 = v6 - v11 - 8;
    if (v18 < 0x168)
    {
      unsigned int v19 = v6;
      goto LABEL_28;
    }
    unint64_t v20 = (v6 - 8 - v11) & 0xFFFFFFFFFFFFFFF8;
    if (&v16[v6 - v11 - 8 - v20] > &v16[v6 - v11 - 8])
    {
      unsigned int v19 = v6;
    }
    else
    {
      if (&v6[-v20 - 8] <= v6 - 8)
      {
        if ((unint64_t)(v11 - v16) < 0x20)
        {
          unsigned int v19 = v6;
          goto LABEL_28;
        }
        uint64_t v21 = (v18 >> 3) + 1;
        uint64_t v22 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v19 = &v6[-v22];
        long long v17 = (uint64_t *)((char *)v17 - v22);
        int v23 = &v16[8 * v12 - 16];
        int v24 = v6 - 16;
        uint64_t v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v26 = *(_OWORD *)v24;
          *(v23 - 1) = *((_OWORD *)v24 - 1);
          *int v23 = v26;
          v23 -= 2;
          v24 -= 32;
          v25 -= 4;
        }
        while (v25);
        if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
LABEL_29:
        *((void *)this + 2) = v17;
        *((void *)this + 3) = v8;
        *((void *)this + 4) = &v16[8 * v15];
        if (v11) {
          operator delete(v11);
        }
        uint64_t v7 = v28;
        goto LABEL_4;
      }
      unsigned int v19 = v6;
    }
    do
    {
LABEL_28:
      uint64_t v27 = *((void *)v19 - 1);
      v19 -= 8;
      *--long long v17 = v27;
    }
    while (v19 != v11);
    goto LABEL_29;
  }
}

void MachException::Message::Dump(MachException::Message *this)
{
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("  exc_msg { bits = 0x%8.8x std::string::size_type size = 0x%8.8x remote-port = 0x%8.8x local-port = 0x%8.8x reserved = 0x%8.8x id = 0x%8.8x } ", *(_DWORD *)this, *((_DWORD *)this + 1), *((_DWORD *)this + 2), *((_DWORD *)this + 3), *((_DWORD *)this + 4), *((_DWORD *)this + 5));
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("reply_msg { bits = 0x%8.8x std::string::size_type size = 0x%8.8x remote-port = 0x%8.8x local-port = 0x%8.8x reserved = 0x%8.8x id = 0x%8.8x }", *((_DWORD *)this + 256), *((_DWORD *)this + 257), *((_DWORD *)this + 258), *((_DWORD *)this + 259), *((_DWORD *)this + 260), *((_DWORD *)this + 261));
  }

  MachException::Data::Dump((MachException::Message *)((char *)this + 2048));
}

void MachException::Data::Dump(MachException::Data *this)
{
  unsigned int v2 = *((_DWORD *)this + 2) - 1;
  if (v2 > 0xC) {
    uint64_t v3 = "???";
  }
  else {
    uint64_t v3 = off_100069548[v2];
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("    state { task_port = 0x%4.4x, thread_port =  0x%4.4x, exc_type = %i (%s) ...", *(_DWORD *)this, *((_DWORD *)this + 1), *((_DWORD *)this + 2), v3);
  }
  uint64_t v5 = *((void *)this + 2);
  uint64_t v4 = *((void *)this + 3);
  uint64_t v6 = v4 - v5;
  BOOL v7 = *((_DWORD *)this + 2) == 5 && v6 == 16;
  if (v7 && *(void *)v5 == 65539 && (int v8 = *(_DWORD *)(v5 + 8)) != 0)
  {
    uint64_t v9 = SysSignal::Name((SysSignal *)*(unsigned int *)(v5 + 8));
    if (DNBLogEnabledForAny(8))
    {
      unint64_t v10 = "unknown signal";
      if (v9) {
        unint64_t v10 = v9;
      }
      _DNBLogThreaded("            exc_data: EXC_SOFT_SIGNAL (%i (%s))", v8, v10);
    }
  }
  else if (v4 != v5)
  {
    uint64_t v11 = 0;
    unint64_t v12 = v6 >> 3;
    if (v12 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v12;
    }
    do
    {
      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("            exc_data[%llu]: 0x%llx", v11, *(void *)(*((void *)this + 2) + 8 * v11));
      }
      ++v11;
    }
    while (v13 != v11);
  }
}

uint64_t MachException::Data::GetStopInfo(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 336) = 0;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 1;
  }
  if (v2 == 6)
  {
    uint64_t v5 = *(void **)(a1 + 16);
    if (*v5 == 258 && *(void *)(a1 + 24) - (void)v5 >= 9uLL)
    {
      *(_DWORD *)a2 = 4;
      *(void *)(a2 + 264) = v5[1];
      *(void *)(a2 + 272) = -1;
      uint64_t v6 = *(void *)(a1 + 16);
      if ((unint64_t)(*(void *)(a1 + 24) - v6) >= 0x11) {
        *(_DWORD *)(a2 + 280) = *(void *)(v6 + 16);
      }
      return 1;
    }
  }
  *(_DWORD *)a2 = 2;
  *(_DWORD *)(a2 + 264) = v2;
  if ((*(_DWORD *)(a1 + 8) - 1) > 0xC) {
    int v7 = snprintf((char *)(a2 + 4), 0x100uLL, "%i");
  }
  else {
    int v7 = snprintf((char *)(a2 + 4), 0x100uLL, "%s");
  }
  unint64_t v8 = a2 + 260;
  uint64_t v9 = (char *)(a2 + v7 + 4);
  uint64_t v10 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  *(void *)(a2 + 272) = v10;
  if (*(_DWORD *)(a1 + 8) == 5
    && (uint64_t v11 = *(void *)(a1 + 16), *(void *)(a1 + 24) - v11 == 16)
    && *(void *)v11 == 65539
    && (int v12 = *(_DWORD *)(v11 + 8)) != 0)
  {
    if ((unint64_t)v9 < v8)
    {
      uint64_t v13 = SysSignal::Name((SysSignal *)*(unsigned int *)(v11 + 8));
      uint64_t v14 = "unknown signal";
      if (v13) {
        uint64_t v14 = v13;
      }
      snprintf(v9, v8 - (void)v9, " EXC_SOFT_SIGNAL( %i(%s))", v12, v14);
    }
  }
  else if ((unint64_t)v9 < v8)
  {
    unint64_t v15 = &v9[snprintf((char *)(a2 + v7 + 4), v8 - (void)v9, " data[%llu] = {", v10)];
    if ((unint64_t)v15 < v8)
    {
      unint64_t v16 = 0;
      do
      {
        unint64_t v17 = *(void *)(a2 + 272);
        if (v16 >= v17) {
          goto LABEL_27;
        }
        uint64_t v18 = *(void *)(*(void *)(a1 + 16) + 8 * v16++);
        if (v16 == v17) {
          uint64_t v19 = 125;
        }
        else {
          uint64_t v19 = 44;
        }
        v15 += snprintf(v15, v8 - (void)v15, "0x%llx%c", v18, v19);
      }
      while ((unint64_t)v15 < v8);
    }
  }
  unint64_t v17 = *(void *)(a2 + 272);
LABEL_27:
  if (v17)
  {
    unint64_t v20 = 0;
    do
    {
      *(void *)(a2 + 280 + 8 * v20) = *(void *)(*(void *)(a1 + 16) + 8 * v20);
      ++v20;
    }
    while (v20 < *(void *)(a2 + 272));
  }
  return 1;
}

uint64_t MachException::Message::Receive(mach_msg_header_t *this, mach_port_name_t a2, mach_msg_option_t a3, int a4, mach_port_name_t a5)
{
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  BOOL v10 = DNBLogCheckLogBit(8);
  BOOL v11 = v10;
  mach_msg_timeout_t v12 = a4 & (a3 << 23 >> 31);
  if ((a3 & 0x100) == 0 && v10 && DNBLogEnabled()) {
    _DNBLogThreaded("::mach_msg(msg->{bits = %#x, std::string::size_type size = %u remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_std::string::size_type size = 0, rcv_std::string::size_type size = %llu, rcv_name = %#x, timeout = %u, notify = %#x)", this->msgh_bits, this->msgh_size, this->msgh_remote_port, this->msgh_local_port, this->msgh_voucher_port, this->msgh_id, a3, 1024, a2, v12, a5);
  }
  uint64_t v13 = mach_msg(this, a3, 0, 0x400u, a2, v12, a5);
  v15[0] = v13;
  v15[1] = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v18) = 0;
  if (v11)
  {
    DNBError::LogThreaded((DNBError *)v15, "::mach_msg(msg->{bits = %#x, std::string::size_type size = %u remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_std::string::size_type size = %u, rcv_std::string::size_type size = %u, rcv_name = %#x, timeout = %u, notify = %#x)", this->msgh_bits, this->msgh_size, this->msgh_remote_port, this->msgh_local_port, this->msgh_voucher_port, this->msgh_id, a3, 0, 1024, a2, v12, a5);
    uint64_t v13 = v15[0];
    if (SHIBYTE(v18) < 0) {
      operator delete(__p);
    }
  }
  return v13;
}

BOOL MachException::Message::CatchExceptionRaise(MachException::Message *this, int a2)
{
  *((_DWORD *)this + 512) = a2;
  g_message = (uint64_t)this + 2048;
  int v2 = mach_exc_server(this, (uint64_t)this + 1024);
  if (!v2 && DNBLogCheckLogBit(8) && DNBLogEnabled()) {
    _DNBLogThreaded("mach_exc_server returned zero...");
  }
  BOOL result = v2 != 0;
  g_message = 0;
  return result;
}

uint64_t MachException::Message::Reply(MachException::Message *this, MachProcess *a2, int a3)
{
  long long v14 = 0u;
  long long v15 = 0u;
  if (*((_DWORD *)this + 514) != 5) {
    goto LABEL_20;
  }
  uint64_t v5 = *((void *)this + 258);
  if (*((void *)this + 259) - v5 != 16) {
    goto LABEL_20;
  }
  if (*(void *)v5 != 65539) {
    goto LABEL_20;
  }
  int v6 = *(_DWORD *)(v5 + 8);
  if (!v6) {
    goto LABEL_20;
  }
  int x = -1;
  mach_port_name_t v7 = *((_DWORD *)this + 512);
  if (*((_DWORD *)a2 + 30) == v7)
  {
    int v9 = *(_DWORD *)a2;
    int x = *(_DWORD *)a2;
  }
  else
  {
    *(void *)&long long v14 = pid_for_task(v7, &x) | 0x100000000;
    if (SHIBYTE(v15) < 0)
    {
      **((unsigned char **)&v14 + 1) = 0;
      *(void *)&long long v15 = 0;
    }
    else
    {
      BYTE8(v14) = 0;
      HIBYTE(v15) = 0;
    }
    int v9 = x;
    a3 = v6;
  }
  if (v9 == -1) {
    MachException::Message::Reply();
  }
  *__error() = 0;
  if (!ptrace(13, x, (caddr_t)*((unsigned int *)this + 513), a3))
  {
    *(void *)&long long v14 = 0;
    if ((SHIBYTE(v15) & 0x80000000) == 0) {
      goto LABEL_14;
    }
LABEL_16:
    **((unsigned char **)&v14 + 1) = 0;
    *(void *)&long long v15 = 0;
    goto LABEL_17;
  }
  LODWORD(v14) = *__error();
  DWORD1(v14) = 2;
  if (SHIBYTE(v15) < 0) {
    goto LABEL_16;
  }
LABEL_14:
  BYTE8(v14) = 0;
  HIBYTE(v15) = 0;
LABEL_17:
  if (DNBLogCheckLogBit(8) || v14) {
    DNBError::LogThreaded((DNBError *)&v14, "::ptrace (request = PT_THUPDATE, pid = 0x%4.4x, tid = 0x%4.4x, signal = %i)", x, *((_DWORD *)this + 513), a3);
  }
LABEL_20:
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("::mach_msg(msg->{bits = %#x, std::string::size_type size = %u, remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_std::string::size_type size = %u, rcv_std::string::size_type size = %u, rcv_name = %#x, timeout = %u, notify = %#x)", *((_DWORD *)this + 256), *((_DWORD *)this + 257), *((_DWORD *)this + 258), *((_DWORD *)this + 259), *((_DWORD *)this + 260), *((_DWORD *)this + 261), 65, *((_DWORD *)this + 257), 0, 0, 0, 0);
  }
  unsigned int v10 = mach_msg((mach_msg_header_t *)((char *)this + 1024), 65, *((_DWORD *)this + 257), 0, 0, 0, 0);
  *(void *)&long long v14 = v10 | 0x100000000;
  if (SHIBYTE(v15) < 0)
  {
    **((unsigned char **)&v14 + 1) = 0;
    *(void *)&long long v15 = 0;
    unsigned int v10 = v14;
    if (!v14) {
      goto LABEL_34;
    }
  }
  else
  {
    BYTE8(v14) = 0;
    HIBYTE(v15) = 0;
    if (!v10) {
      goto LABEL_34;
    }
  }
  if (v10 == 268435463)
  {
    if (DNBLogCheckLogBit(8)) {
      DNBError::LogThreaded((DNBError *)&v14, "::mach_msg() - send interrupted");
    }
  }
  else if (*((_DWORD *)this + 512) == *((_DWORD *)a2 + 30))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("error: mach_msg() returned an error when replying to a mach exception: error = %u", v14);
    }
  }
  else if (DNBLogCheckLogBit(8))
  {
    DNBError::LogThreaded((DNBError *)&v14, "::mach_msg() - failed (child of task)");
  }
LABEL_34:
  uint64_t v11 = v14;
  if (SHIBYTE(v15) < 0) {
    operator delete(*((void **)&v14 + 1));
  }
  return v11;
}

uint64_t MachException::PortInfo::Save(MachException::PortInfo *this, task_t a2)
{
  kern_return_t exception_ports;
  uint64_t v5;
  unsigned int v7;
  int v8;
  void *__p;
  uint64_t v10;
  uint64_t v11;

  if (DNBLogEnabledForAny(9)) {
    _DNBLogThreaded("MachException::PortInfo::Save(task = 0x%4.4x)", a2);
  }
  std::string __p = 0;
  unsigned int v10 = 0;
  uint64_t v11 = 0;
  *(_DWORD *)this = 7166;
  *((_DWORD *)this + 57) = 14;
  exception_ports = task_get_exception_ports(a2, 0x1BFEu, (exception_mask_array_t)this + 1, (mach_msg_type_number_t *)this + 57, (exception_handler_array_t)this + 15, (exception_behavior_array_t)this + 29, (exception_flavor_array_t)this + 43);
  mach_port_name_t v7 = exception_ports;
  unint64_t v8 = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v11) = 0;
  if (DNBLogCheckLogBit(8) || (uint64_t v5 = 0, exception_ports))
  {
    DNBError::LogThreaded((DNBError *)&v7, "::task_get_exception_ports(task = 0x%4.4x, mask = 0x%x, maskCnt => %u, ports, behaviors, flavors)", a2, *(_DWORD *)this, *((_DWORD *)this + 57));
    uint64_t v5 = v7;
    if (v7 == 4)
    {
      if (*(_DWORD *)this == 7166)
      {
        uint64_t v5 = 4;
LABEL_16:
        *(_DWORD *)this = 0;
        *((_DWORD *)this + 57) = 0;
LABEL_17:
        if (SHIBYTE(v11) < 0) {
          operator delete(__p);
        }
        return v5;
      }
      *(_DWORD *)this = 7166;
      *((_DWORD *)this + 57) = 14;
      mach_port_name_t v7 = task_get_exception_ports(a2, 0x1BFEu, (exception_mask_array_t)this + 1, (mach_msg_type_number_t *)this + 57, (exception_handler_array_t)this + 15, (exception_behavior_array_t)this + 29, (exception_flavor_array_t)this + 43);
      unint64_t v8 = 1;
      if (SHIBYTE(v11) < 0)
      {
        *(unsigned char *)std::string __p = 0;
        unsigned int v10 = 0;
      }
      else
      {
        LOBYTE(__p) = 0;
        HIBYTE(v11) = 0;
      }
      if (!DNBLogCheckLogBit(8) && !v7)
      {
        uint64_t v5 = 0;
        goto LABEL_17;
      }
      DNBError::LogThreaded((DNBError *)&v7, "::task_get_exception_ports(task = 0x%4.4x, mask = 0x%x, maskCnt => %u, ports, behaviors, flavors)", a2, *(_DWORD *)this, *((_DWORD *)this + 57));
      uint64_t v5 = v7;
    }
    if (!v5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  return v5;
}

uint64_t MachException::PortInfo::Restore(MachException::PortInfo *this, task_t a2)
{
  if (DNBLogEnabledForAny(9)) {
    _DNBLogThreaded("MachException::PortInfo::Restore( task = 0x%4.4x)", a2);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v10 = 0u;
  if (*((_DWORD *)this + 57))
  {
    uint64_t v4 = 0;
    while (1)
    {
      int v6 = (char *)this + 4 * v4;
      __p[0] = (void *)(task_set_exception_ports(a2, *((_DWORD *)v6 + 1), *((_DWORD *)v6 + 15), *((_DWORD *)v6 + 29), *((_DWORD *)v6 + 43)) | 0x100000000);
      if (SHIBYTE(v10) < 0)
      {
        *(unsigned char *)__p[1] = 0;
        *(void *)&long long v10 = 0;
      }
      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v10) = 0;
      }
      if (DNBLogCheckLogBit(8) || LODWORD(__p[0]))
      {
        DNBError::LogThreaded((DNBError *)__p, "::task_set_exception_ports(task = 0x%4.4x, exception_mask = 0x%8.8x, new_port = 0x%4.4x, behavior = 0x%8.8x, new_flavor = 0x%8.8x)", a2, *((_DWORD *)v6 + 1), *((_DWORD *)v6 + 15), *((_DWORD *)v6 + 29), *((_DWORD *)v6 + 43));
        uint64_t v5 = LODWORD(__p[0]);
        if (LODWORD(__p[0])) {
          break;
        }
      }
      if (++v4 >= (unint64_t)*((unsigned int *)this + 57))
      {
        uint64_t v5 = 0;
        break;
      }
    }
    int v7 = SHIBYTE(v10);
    *((_DWORD *)this + 57) = 0;
    if (v7 < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
    uint64_t v5 = 0;
    *((_DWORD *)this + 57) = 0;
  }
  return v5;
}

uint64_t MachException::ExceptionMask(MachException *this, const char *a2)
{
  {
    MachException::ExceptionMask(char const*)::prefix_len = 4;
  }
  if (strncmp((const char *)this, "EXC_", 4uLL)) {
    return 0;
  }
  uint64_t v4 = (char *)this + MachException::ExceptionMask(char const*)::prefix_len;
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (long long *)operator new(v8 + 1);
    *((void *)&__dst + 1) = v6;
    unint64_t v22 = v9 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_11;
  }
  HIBYTE(v22) = v5;
  p_dst = &__dst;
  if (v5) {
LABEL_11:
  }
    memcpy(p_dst, v4, v6);
  *((unsigned char *)p_dst + v6) = 0;
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    long long v10 = &__dst;
    switch(HIBYTE(v22))
    {
      case 8:
        break;
      case 9:
        goto LABEL_14;
      case 0xA:
        if ((void)__dst == 0x454343415F444142 && WORD4(__dst) == 21331) {
          goto LABEL_50;
        }
        goto LABEL_58;
      case 0xF:
        if ((void)__dst == 0x54534E495F444142 && *(void *)((char *)&__dst + 7) == 0x4E4F495443555254) {
          goto LABEL_65;
        }
        if (HIBYTE(v22) == 8) {
          goto LABEL_67;
        }
        if (HIBYTE(v22) == 9) {
          goto LABEL_14;
        }
        if (HIBYTE(v22) != 10) {
          goto LABEL_69;
        }
LABEL_58:
        if ((void)__dst == 0x54454D4854495241 && WORD4(__dst) == 17225) {
          goto LABEL_76;
        }
        if (HIBYTE(v22) == 8) {
          goto LABEL_67;
        }
        if (HIBYTE(v22) != 9) {
          goto LABEL_69;
        }
LABEL_14:
        if ((void)__dst == 0x4F4954414C554D45 && BYTE8(__dst) == 78) {
          goto LABEL_66;
        }
        if (HIBYTE(v22) != 8) {
          goto LABEL_69;
        }
LABEL_67:
        long long v10 = &__dst;
        break;
      default:
        goto LABEL_69;
    }
LABEL_68:
    if (*(void *)v10 == 0x4552415754464F53)
    {
      uint64_t v3 = 32;
      goto LABEL_88;
    }
    goto LABEL_69;
  }
  uint64_t v12 = *((void *)&__dst + 1);
  if (*((void *)&__dst + 1) == 10 && *(void *)__dst == 0x454343415F444142 && *(_WORD *)(__dst + 8) == 21331)
  {
LABEL_50:
    uint64_t v3 = 2;
    goto LABEL_88;
  }
  if (*((void *)&__dst + 1) == 15)
  {
    if (*(void *)__dst == 0x54534E495F444142 && *(void *)(__dst + 7) == 0x4E4F495443555254)
    {
LABEL_65:
      uint64_t v3 = 4;
      goto LABEL_88;
    }
    uint64_t v12 = *((void *)&__dst + 1);
  }
  if (v12 == 10)
  {
    if (*(void *)__dst == 0x54454D4854495241 && *(_WORD *)(__dst + 8) == 17225)
    {
LABEL_76:
      uint64_t v3 = 8;
      goto LABEL_88;
    }
    uint64_t v12 = *((void *)&__dst + 1);
  }
  if (v12 == 9)
  {
    if (*(void *)__dst == 0x4F4954414C554D45 && *(unsigned char *)(__dst + 8) == 78)
    {
LABEL_66:
      uint64_t v3 = 16;
      goto LABEL_88;
    }
    uint64_t v12 = *((void *)&__dst + 1);
  }
  if (v12 == 8)
  {
    long long v10 = (long long *)__dst;
    goto LABEL_68;
  }
LABEL_69:
  if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "BREAKPOINT"))
  {
    uint64_t v3 = 64;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "SYSCALL"))
  {
    uint64_t v3 = 128;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "MACH_SYSCALL"))
  {
    uint64_t v3 = 256;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "RPC_ALERT"))
  {
    uint64_t v3 = 512;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "CRASH"))
  {
    uint64_t v3 = 1024;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "RESOURCE"))
  {
    uint64_t v3 = 2048;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "GUARD"))
  {
    uint64_t v3 = 4096;
  }
  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "CORPSE_NOTIFY"))
  {
    uint64_t v3 = 0x2000;
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_88:
  if (SHIBYTE(v22) < 0) {
    operator delete((void *)__dst);
  }
  return v3;
}

void MachProcess::MachProcess(MachProcess *this)
{
  *(void *)this = 0;
  *(void *)((char *)this + 12) = -1;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 5) = -1;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  MachTask::MachTask((MachProcess *)((char *)this + 104), this);
  *((_DWORD *)this + 110) = 0;
  *((void *)this + 56) = 0;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 456), 2);
  *((_DWORD *)this + 137) = 0;
  *((void *)this + 70) = 0;
  *((void *)this + 65) = 0;
  *((void *)this + 67) = 0;
  *((void *)this + 66) = 0;
  *((unsigned char *)this + 544) = 0;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 568), 2);
  *((void *)this + 81) = 0;
  *(_OWORD *)((char *)this + 632) = 0u;
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 656), 0, 1);
  DNBThreadResumeActions::DNBThreadResumeActions((MachProcess *)((char *)this + 832));
  *((void *)this + 112) = 0;
  *((_OWORD *)this + 55) = 0u;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 904), 2);
  MachThreadList::MachThreadList((MachProcess *)((char *)this + 968));
  Genealogy::Genealogy((MachProcess *)((char *)this + 1080));
  *((_DWORD *)this + 304) = 1;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 1224), 2);
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 1288), 0, 31);
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 1464), 0, 31);
  DNBBreakpointList::DNBBreakpointList((MachProcess *)((char *)this + 1640));
  DNBBreakpointList::DNBBreakpointList((MachProcess *)((char *)this + 1664));
  *((void *)this + 225) = 0;
  *((unsigned char *)this + 1752) = 0;
  *(_OWORD *)((char *)this + 1688) = 0u;
  *(_OWORD *)((char *)this + 1704) = 0u;
  *(_OWORD *)((char *)this + 1720) = 0u;
  *(_OWORD *)((char *)this + 1736) = 0u;
  *((_OWORD *)this + 110) = 0u;
  *((_OWORD *)this + 111) = 0u;
  *((void *)this + 220) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_create");
  *((void *)this + 221) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_for_each_image");
  *((void *)this + 222) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_release");
  *((void *)this + 223) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_cache");
  *((void *)this + 224) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_platform");
  *((void *)this + 225) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_state");
  if (DNBLogEnabledForAny(3)) {
    _DNBLogThreaded("%s", "MachProcess::MachProcess()");
  }
}

void sub_10003E494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, void **a12, DNBThreadResumeActions *a13, PThreadEvent *a14, void **a15, PThreadMutex *a16, PThreadMutex *a17, MachTask *a18)
{
  DNBBreakpointList::~DNBBreakpointList(v22);
  PThreadEvent::~PThreadEvent(v21);
  PThreadEvent::~PThreadEvent(v20);
  PThreadMutex::~PThreadMutex(v19);
  Genealogy::~Genealogy(v26);
  MachThreadList::~MachThreadList(v25);
  PThreadMutex::~PThreadMutex(v24);
  std::vector<MachException::Message>::~vector[abi:ne180100]((void **)(v18 + 880));
  DNBThreadResumeActions::~DNBThreadResumeActions(a13);
  PThreadEvent::~PThreadEvent(a14);
  std::vector<std::string>::~vector[abi:ne180100](a15);
  PThreadMutex::~PThreadMutex((pthread_mutex_t *)a16);
  if (*(char *)(v18 + 543) < 0) {
    operator delete(*(void **)(v18 + 520));
  }
  PThreadMutex::~PThreadMutex((pthread_mutex_t *)a17);
  MachTask::~MachTask(a18);
  if (*(char *)(v18 + 103) < 0) {
    operator delete(*v23);
  }
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v18 + 48));
  if (*(char *)(v18 + 47) < 0) {
    operator delete(*a12);
  }
  _Unwind_Resume(a1);
}

void Genealogy::~Genealogy(Genealogy *this)
{
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 14);
    uint64_t v4 = (void *)*((void *)this + 13);
    if (v3 != v2)
    {
      do
      {
        size_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 13);
    }
    *((void *)this + 14) = v2;
    operator delete(v4);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy((uint64_t)this + 80, *((void **)this + 11));
}

void **std::vector<MachException::Message>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        size_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }
        v3 -= 2088;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void DNBThreadResumeActions::~DNBThreadResumeActions(DNBThreadResumeActions *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void MachProcess::~MachProcess(MachProcess *this)
{
  if (DNBLogEnabledForAny(3)) {
    _DNBLogThreaded("%s", "MachProcess::~MachProcess()");
  }
  MachProcess::Clear(this, 0);
  if (*((char *)this + 1743) < 0) {
    operator delete(*((void **)this + 215));
  }
  DNBBreakpointList::~DNBBreakpointList((MachProcess *)((char *)this + 1664));
  DNBBreakpointList::~DNBBreakpointList((MachProcess *)((char *)this + 1640));
  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 1464));
  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 1288));
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1224))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1224));
  }
  uint64_t v2 = *((void *)this + 148);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 149);
    uint64_t v4 = (void *)*((void *)this + 148);
    if (v3 != v2)
    {
      do
      {
        size_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 148);
    }
    *((void *)this + 149) = v2;
    operator delete(v4);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy((uint64_t)this + 1160, *((void **)this + 146));
  MachThreadList::~MachThreadList((MachProcess *)((char *)this + 968));
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 904))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 904));
  }
  uint64_t v6 = *((void *)this + 110);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 111);
    uint64_t v8 = (void *)*((void *)this + 110);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 24);
        if (v9)
        {
          *(void *)(v7 - 16) = v9;
          operator delete(v9);
        }
        v7 -= 2088;
      }
      while (v7 != v6);
      uint64_t v8 = (void *)*((void *)this + 110);
    }
    *((void *)this + 111) = v6;
    operator delete(v8);
  }
  long long v10 = (void *)*((void *)this + 107);
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 104);
  if (v11)
  {
    *((void *)this + 105) = v11;
    operator delete(v11);
  }
  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 656));
  uint64_t v12 = *((void *)this + 79);
  if (v12)
  {
    uint64_t v13 = *((void *)this + 80);
    long long v14 = (void *)*((void *)this + 79);
    if (v13 != v12)
    {
      do
      {
        if (*(char *)(v13 - 1) < 0) {
          operator delete(*(void **)(v13 - 24));
        }
        v13 -= 24;
      }
      while (v13 != v12);
      long long v14 = (void *)*((void *)this + 79);
    }
    *((void *)this + 80) = v12;
    operator delete(v14);
  }
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 568))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 568)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 568));
  }
  if (*((char *)this + 543) < 0) {
    operator delete(*((void **)this + 65));
  }
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  }
  MachTask::~MachTask((MachProcess *)((char *)this + 104));
  if (*((char *)this + 103) < 0) {
    operator delete(*((void **)this + 10));
  }
  uint64_t v15 = *((void *)this + 6);
  if (v15)
  {
    uint64_t v16 = *((void *)this + 7);
    uint64_t v17 = (void *)*((void *)this + 6);
    if (v16 != v15)
    {
      do
      {
        if (*(char *)(v16 - 1) < 0) {
          operator delete(*(void **)(v16 - 24));
        }
        v16 -= 24;
      }
      while (v16 != v15);
      uint64_t v17 = (void *)*((void *)this + 6);
    }
    *((void *)this + 7) = v15;
    operator delete(v17);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
}

void __clang_call_terminate(void *a1)
{
}

void MachProcess::Clear(MachProcess *this, char a2)
{
  MachTask::Clear((void *)this + 13);
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = 0;
  if ((a2 & 1) == 0)
  {
    int v4 = *((_DWORD *)this + 3);
    if ((v4 & 0x80000000) == 0)
    {
      close(v4);
      *((_DWORD *)this + 3) = -1;
    }
    int v5 = *((_DWORD *)this + 4);
    if ((v5 & 0x80000000) == 0)
    {
      close(v5);
      *((_DWORD *)this + 4) = -1;
    }
    int v6 = *((_DWORD *)this + 5);
    if ((v6 & 0x80000000) == 0)
    {
      close(v6);
      *((_DWORD *)this + 5) = -1;
    }
  }
  if (*((char *)this + 47) < 0)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
  }
  else
  {
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
  }
  uint64_t v7 = *((void *)this + 6);
  for (uint64_t i = *((void *)this + 7); i != v7; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  *((void *)this + 7) = v7;
  MachProcess::SetState((uint64_t)this, 1u);
  *((void *)this + 55) = 0;
  MachThreadList::Clear((MachProcess *)((char *)this + 968));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  uint64_t v9 = *((void *)this + 111);
  uint64_t v10 = *((void *)this + 110);
  while (v9 != v10)
  {
    uint64_t v11 = *(void **)(v9 - 24);
    if (v11)
    {
      *(void *)(v9 - 16) = v11;
      operator delete(v11);
    }
    v9 -= 2088;
  }
  *((void *)this + 111) = v10;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904));
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  if (*((void *)this + 70))
  {
    PThreadEvent::SetEvents((pthread_mutex_t *)((char *)this + 656), 1);
    pthread_join(*((pthread_t *)this + 70), 0);
    *((void *)this + 70) = 0;
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 656), 1);
  }
}

uint64_t MachProcess::GetState(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  uint64_t v3 = *((unsigned int *)this + 304);
  pthread_mutex_unlock(v2);
  return v3;
}

void PThreadMutex::Locker::~Locker(pthread_mutex_t **this)
{
  uint64_t v1 = *this;
  if (v1) {
    pthread_mutex_unlock(v1);
  }
}

uint64_t MachProcess::ThreadGetName(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetName((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::ThreadGetState(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetState((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetNumThreads(MachProcess *this)
{
  return MachThreadList::NumThreads((MachProcess *)((char *)this + 968));
}

uint64_t MachProcess::GetThreadAtIndex(MachProcess *this, unint64_t a2)
{
  return MachThreadList::ThreadIDAtIndex((MachProcess *)((char *)this + 968), a2);
}

BOOL MachProcess::SyncThreadState(MachProcess *this, uint64_t a2)
{
  kern_return_t v2;
  BOOL v3;
  std::__shared_weak_count *v4;
  thread_act_t *v6;
  std::__shared_weak_count *v7;

  MachThreadList::GetThreadByID((MachProcess *)((char *)this + 968), a2, &v6);
  if (!v6)
  {
    uint64_t v3 = 0;
    int v4 = v7;
    if (!v7) {
      return v3;
    }
    goto LABEL_7;
  }
  uint64_t v2 = thread_abort_safely(v6[4]);
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("thread = 0x%8.8x calling thread_abort_safely (tid) => %u (GetGPRState() for stop_count = %u)", v6[4], v2, *(_DWORD *)(*(void *)v6 + 444));
  }
  uint64_t v3 = v2 == 0;
  int v4 = v7;
  if (v7)
  {
LABEL_7:
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

void sub_10003EDCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void MachProcess::GetRequestedQoS(MachProcess *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
}

uint64_t MachProcess::GetPThreadT(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetPThreadT((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetDispatchQueueT(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetDispatchQueueT((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetTSDAddressForThread(MachProcess *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MachThreadList::GetTSDAddressForThread((MachProcess *)((char *)this + 968), a2, a3, a4, a5);
}

unint64_t MachProcess::GetDeploymentInfo(MachProcess *this, const load_command *a2, mach_vm_address_t a3, int a4)
{
  uint64_t Memory = 0;
  unsigned __int8 v8 = 0;
  switch(a2->cmd & 0x7FFFFFFF)
  {
    case '$':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 1;
      if (a4) {
        goto LABEL_26;
      }
      return v8 | (unint64_t)(Memory << 32);
    case '%':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 2;
      if (a4) {
        goto LABEL_26;
      }
      return v8 | (unint64_t)(Memory << 32);
    case '&':
    case '\'':
    case '(':
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '1':
      goto LABEL_25;
    case '/':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 3;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
    case '0':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 4;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
    case '2':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x18uLL, (char *)&__p);
      if (Memory)
      {
        DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
        if (Memory == 24)
        {
          unsigned __int8 v8 = v20;
          uint64_t Memory = HIWORD(v21);
          if (!a4) {
            return v8 | (unint64_t)(Memory << 32);
          }
        }
        else
        {
LABEL_24:
          uint64_t Memory = 0;
          unsigned __int8 v8 = 0;
LABEL_25:
          if (!a4) {
            return v8 | (unint64_t)(Memory << 32);
          }
        }
      }
      else
      {
LABEL_22:
        unsigned __int8 v8 = 0;
        if (!a4) {
          return v8 | (unint64_t)(Memory << 32);
        }
      }
LABEL_26:
      int v9 = *((_DWORD *)this + 2);
      if (v9)
      {
        if (v9 != 6) {
          return v8 | (unint64_t)(Memory << 32);
        }
LABEL_39:
        MachProcess::GetMacCatalystVersionString(&__p);
        if (v22 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        uint64_t v17 = 0;
        std::string __endptr = 0;
        uint64_t Memory = strtoul(p_p, &__endptr, 10);
        if (__endptr && *__endptr == 46)
        {
          strtoul(__endptr + 1, &v17, 10);
          if (!v17 || *v17 != 46)
          {
            if ((v22 & 0x80000000) == 0) {
              goto LABEL_50;
            }
            goto LABEL_49;
          }
          strtoul(v17 + 1, 0, 10);
          if (v22 < 0) {
LABEL_49:
          }
            operator delete(__p);
        }
        else if (v22 < 0)
        {
          goto LABEL_49;
        }
LABEL_50:
        unsigned __int8 v8 = 6;
        return v8 | (unint64_t)(Memory << 32);
      }
      uint64_t v10 = (uint64_t (*)(void, void, void **))*((void *)this + 220);
      if (v10 && (LODWORD(__p) = 0, (uint64_t v11 = v10(*((unsigned int *)this + 30), 0, &__p)) != 0))
      {
        uint64_t v12 = v11;
        uint64_t v13 = (uint64_t (*)(uint64_t))*((void *)this + 224);
        if (v13) {
          int v14 = v13(v11);
        }
        else {
          int v14 = 0;
        }
        (*((void (**)(uint64_t))this + 222))(v12);
      }
      else
      {
        int v14 = 0;
      }
      *((_DWORD *)this + 2) = v14;
      if (v14 == 6) {
        goto LABEL_39;
      }
      return v8 | (unint64_t)(Memory << 32);
    default:
      uint64_t Memory = 0;
      unsigned __int8 v8 = 0;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
  }
}

unint64_t MachProcess::ReadMemory(MachProcess *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  unint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, a3, a4);
  if (Memory) {
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a2, Memory, a4);
  }
  return Memory;
}

void MachProcess::GetMacCatalystVersionString(void *a1@<X8>)
{
  int v4 = (const char *)[[+[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", @"/System/Library/CoreServices/SystemVersion.plist") objectForKey:@"iOSSupportVersion"] UTF8String];
  if (!v4)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return;
  }
  int v5 = v4;
  size_t v6 = strlen(v4);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v8 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v8 = v6 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t v10 = operator new(v8 + 1);
    a1[1] = v7;
    a1[2] = v9 | 0x8000000000000000;
    *a1 = v10;
    a1 = v10;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v6;
    if (!v6) {
      goto LABEL_11;
    }
  }
  memmove(a1, v5, v7);
LABEL_11:
  *((unsigned char *)a1 + v7) = 0;
}

uint64_t MachProcess::GetMachOInformationFromMemory(uint64_t a1, int a2, mach_vm_address_t a3, int a4, uint64_t a5)
{
  uint64_t v8 = (MachTask *)(a1 + 104);
  if (a4 != 4)
  {
    unint64_t Memory = MachTask::ReadMemory((MachTask *)(a1 + 104), a3, 0x20uLL, v77);
    if (!Memory) {
      return 0;
    }
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), a3, Memory, v77);
    if (Memory != 32) {
      return 0;
    }
    int v10 = *(_DWORD *)v77;
    int v11 = *(_DWORD *)&v77[4];
    if ((*(_DWORD *)v77 + 17958194) >= 2 && *(_DWORD *)v77 != -805638658 && *(_DWORD *)v77 != -822415874) {
      return 0;
    }
    if (*(int *)&v77[4] <= 16777222)
    {
      if (*(_DWORD *)&v77[4] != 7 && *(_DWORD *)&v77[4] != 12) {
        return 0;
      }
    }
    else if (*(_DWORD *)&v77[4] != 16777223 && *(_DWORD *)&v77[4] != 16777228 && *(_DWORD *)&v77[4] != 33554444)
    {
      return 0;
    }
    mach_vm_address_t v13 = a3 + 32;
    goto LABEL_28;
  }
  unint64_t v9 = MachTask::ReadMemory((MachTask *)(a1 + 104), a3, 0x1CuLL, v77);
  if (!v9) {
    return 0;
  }
  DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), a3, v9, v77);
  if (v9 != 28) {
    return 0;
  }
  int v10 = *(_DWORD *)v77;
  int v11 = *(_DWORD *)&v77[4];
  if ((*(_DWORD *)v77 + 17958194) >= 2 && *(_DWORD *)v77 != -805638658 && *(_DWORD *)v77 != -822415874) {
    return 0;
  }
  if (*(int *)&v77[4] <= 16777222)
  {
    if (*(_DWORD *)&v77[4] != 7 && *(_DWORD *)&v77[4] != 12) {
      return 0;
    }
    goto LABEL_24;
  }
  if (*(_DWORD *)&v77[4] == 16777223 || *(_DWORD *)&v77[4] == 16777228 || *(_DWORD *)&v77[4] == 33554444)
  {
LABEL_24:
    mach_vm_address_t v13 = a3 + 28;
LABEL_28:
    *(_DWORD *)a5 = v10;
    *(_DWORD *)(a5 + 4) = v11;
    *(_DWORD *)(a5 + 8) = *(_DWORD *)&v77[8] & 0xFFFFFF;
    int v14 = *(_DWORD *)&v77[16];
    *(_OWORD *)(a5 + 12) = *(_OWORD *)&v77[12];
    if (!v14) {
      return 1;
    }
    unsigned int v15 = 0;
    int16x8_t v64 = (char **)(a5 + 32);
    int v65 = (void **)(a5 + 72);
    while (1)
    {
      unint64_t v17 = MachTask::ReadMemory(v8, v13, 8uLL, (char *)&v67);
      if (!v17) {
        return 0;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v17, (char *)&v67);
      if (v17 != 8) {
        return 0;
      }
      uint32_t cmd = v67.cmd;
      if (v67.cmd == 1) {
        break;
      }
LABEL_54:
      if (cmd == 25)
      {
        unint64_t v32 = MachTask::ReadMemory(v8, v13, 0x48uLL, (char *)&v68);
        if (!v32) {
          return 0;
        }
        DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v32, (char *)&v68);
        if (v32 != 72) {
          return 0;
        }
        memset(v77, 0, 24);
        char v76 = 0;
        *(_OWORD *)__s = *(_OWORD *)&v68.__r_.__value_.__r.__words[1];
        std::string::assign((std::string *)v77, __s);
        *(_OWORD *)&v77[24] = v69;
        long long v78 = v70;
        *(void *)&long long v33 = v71;
        *((void *)&v33 + 1) = v72;
        long long v79 = v33;
        *(void *)&long long v33 = v73;
        *((void *)&v33 + 1) = v74;
        long long v80 = v33;
        unint64_t v34 = *(void *)(a5 + 40);
        if (v34 >= *(void *)(a5 + 48))
        {
          BOOL v36 = std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>(v64, (uint64_t)v77);
        }
        else
        {
          if ((v77[23] & 0x80000000) != 0)
          {
            std::string::__init_copy_ctor_external(*(std::string **)(a5 + 40), *(const std::string::value_type **)v77, *(std::string::size_type *)&v77[8]);
          }
          else
          {
            long long v35 = *(_OWORD *)v77;
            *(void *)(v34 + 16) = *(void *)&v77[16];
            *(_OWORD *)unint64_t v34 = v35;
          }
          long long v37 = *(_OWORD *)&v77[24];
          long long v38 = v78;
          long long v39 = v79;
          *(_OWORD *)(v34 + 72) = v80;
          *(_OWORD *)(v34 + 56) = v39;
          *(_OWORD *)(v34 + 40) = v38;
          *(_OWORD *)(v34 + 24) = v37;
          BOOL v36 = (char *)(v34 + 88);
          *(void *)(a5 + 40) = v34 + 88;
        }
        *(void *)(a5 + 40) = v36;
        int v40 = v77[23];
        if ((v77[23] & 0x80000000) == 0)
        {
          if (v77[23] == 16)
          {
            uint64_t v41 = (uint64_t *)v77;
            goto LABEL_70;
          }
LABEL_76:
          uint32_t cmd = v67.cmd;
          goto LABEL_77;
        }
        if (*(void *)&v77[8] == 16)
        {
          uint64_t v41 = *(uint64_t **)v77;
LABEL_70:
          uint64_t v43 = *v41;
          uint64_t v42 = v41[1];
          if (v43 == 0x7274784563657845 && v42 == 0x646E657073755361)
          {
            *(unsigned char *)(a1 + 412) = 1;
            if ((v40 & 0x80000000) == 0) {
              goto LABEL_76;
            }
          }
          else if ((v77[23] & 0x80000000) == 0)
          {
            goto LABEL_76;
          }
        }
        operator delete(*(void **)v77);
        goto LABEL_76;
      }
LABEL_77:
      if (cmd == 27)
      {
        unint64_t v45 = MachTask::ReadMemory(v8, v13, 0x18uLL, v77);
        if (v45)
        {
          DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v45, v77);
          if (v45 == 24) {
            uuid_copy((unsigned __int8 *)(a5 + 56), &v77[8]);
          }
        }
      }
      unint64_t DeploymentInfo = MachProcess::GetDeploymentInfo((MachProcess *)a1, &v67, v13, *(_DWORD *)(a5 + 12) == 2);
      if (!(_BYTE)DeploymentInfo) {
        goto LABEL_30;
      }
      unint64_t v48 = v46;
      switch((char)DeploymentInfo)
      {
        case 1:
          v77[23] = 6;
          strcpy(v77, "macosx");
          char v49 = 1;
          break;
        case 2:
          v77[23] = 3;
          strcpy(v77, "ios");
          goto LABEL_102;
        case 3:
          v77[23] = 4;
          int v50 = 1936684660;
          goto LABEL_99;
        case 4:
          v77[23] = 7;
          strcpy(v77, "watchos");
          char v49 = 1;
          break;
        case 5:
          v77[23] = 8;
          strcpy(v77, "bridgeos");
          char v49 = 1;
          break;
        case 6:
          v77[23] = 11;
          strcpy(v77, "maccatalyst");
          goto LABEL_102;
        case 7:
          v77[23] = 12;
          strcpy(v77, "iossimulator");
          goto LABEL_102;
        case 8:
          v77[23] = 13;
          uint64_t v51 = "tvossimulator";
          goto LABEL_101;
        case 9:
          v77[23] = 16;
          strcpy(v77, "watchossimulator");
          goto LABEL_102;
        case 10:
          v77[23] = 9;
          strcpy(v77, "driverkit");
          goto LABEL_102;
        case 11:
          v77[23] = 4;
          int v50 = 1936683640;
LABEL_99:
          *(_DWORD *)uint64_t v77 = v50;
          char v49 = 1;
          v77[4] = 0;
          break;
        case 12:
          v77[23] = 13;
          uint64_t v51 = "xrossimulator";
LABEL_101:
          *(void *)uint64_t v77 = *(void *)v51;
          *(void *)&v77[5] = *(void *)(v51 + 5);
          v77[13] = 0;
LABEL_102:
          char v49 = 1;
          break;
        default:
          if (DNBLogEnabled()) {
            _DNBLogError("Unknown platform %u found for one binary", DeploymentInfo);
          }
          char v49 = 0;
          v77[0] = 0;
          break;
      }
      v77[24] = v49;
      if (a2 != 6)
      {
        int v52 = *(char *)(a5 + 95);
        if (v52 < 0)
        {
          if (*(void *)(a5 + 80) == 6)
          {
            uint64_t v53 = (unsigned __int16 *)*v65;
LABEL_109:
            int v54 = *(_DWORD *)v53;
            int v55 = v53[2];
            if (v54 == 1868783981 && v55 == 30835) {
              goto LABEL_141;
            }
          }
        }
        else
        {
          uint64_t v53 = (unsigned __int16 *)(a5 + 72);
          if (v52 == 6) {
            goto LABEL_109;
          }
        }
      }
      std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>((char *)&unk_10005A589, (uint64_t)v77, &v68);
      if (*(char *)(a5 + 95) < 0) {
        operator delete(*v65);
      }
      *(_OWORD *)int v65 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
      *(void *)(a5 + 88) = *((void *)&v68.__r_.__value_.__l + 2);
      std::string::assign((std::string *)(a5 + 96), (const std::string::value_type *)&unk_10005A589);
      std::to_string(&v68, HIDWORD(DeploymentInfo));
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v57 = &v68;
      }
      else {
        int v57 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v68.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v68.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v57, size);
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v68.__r_.__value_.__l.__data_);
      }
      std::string::append((std::string *)(a5 + 96), ".");
      std::to_string(&v68, v48);
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v59 = &v68;
      }
      else {
        uint64_t v59 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v60 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v60 = v68.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v59, v60);
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v68.__r_.__value_.__l.__data_);
        unint64_t v61 = HIDWORD(v48);
        if (HIDWORD(v48))
        {
LABEL_133:
          std::string::append((std::string *)(a5 + 96), ".");
          std::to_string(&v68, v61);
          if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v62 = &v68;
          }
          else {
            uint64_t v62 = (std::string *)v68.__r_.__value_.__r.__words[0];
          }
          if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v63 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v63 = v68.__r_.__value_.__l.__size_;
          }
          std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v62, v63);
          if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v68.__r_.__value_.__l.__data_);
          }
        }
      }
      else
      {
        unint64_t v61 = HIDWORD(v48);
        if (HIDWORD(v48)) {
          goto LABEL_133;
        }
      }
LABEL_141:
      if (v77[24])
      {
        if ((v77[23] & 0x80000000) != 0) {
          operator delete(*(void **)v77);
        }
      }
LABEL_30:
      v13 += v67.cmdsize;
      ++v15;
      uint64_t result = 1;
      if (v15 >= *(_DWORD *)(a5 + 16)) {
        return result;
      }
    }
    unint64_t v19 = MachTask::ReadMemory(v8, v13, 0x38uLL, (char *)&v68);
    if (!v19) {
      return 0;
    }
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v19, (char *)&v68);
    if (v19 != 56) {
      return 0;
    }
    memset(v77, 0, 24);
    char v76 = 0;
    *(_OWORD *)__s = *(_OWORD *)&v68.__r_.__value_.__r.__words[1];
    std::string::assign((std::string *)v77, __s);
    *(void *)&long long v20 = v69;
    *((void *)&v20 + 1) = DWORD1(v69);
    *(_OWORD *)&v77[24] = v20;
    *(void *)&long long v20 = DWORD2(v69);
    *((void *)&v20 + 1) = HIDWORD(v69);
    long long v78 = v20;
    *(void *)&long long v20 = (int)v70;
    *((void *)&v20 + 1) = SDWORD1(v70);
    long long v79 = v20;
    *(void *)&long long v20 = DWORD2(v70);
    *((void *)&v20 + 1) = HIDWORD(v70);
    long long v80 = v20;
    unint64_t v21 = *(void *)(a5 + 40);
    if (v21 >= *(void *)(a5 + 48))
    {
      int v23 = std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>(v64, (uint64_t)v77);
    }
    else
    {
      if ((v77[23] & 0x80000000) != 0)
      {
        std::string::__init_copy_ctor_external(*(std::string **)(a5 + 40), *(const std::string::value_type **)v77, *(std::string::size_type *)&v77[8]);
      }
      else
      {
        long long v22 = *(_OWORD *)v77;
        *(void *)(v21 + 16) = *(void *)&v77[16];
        *(_OWORD *)unint64_t v21 = v22;
      }
      long long v24 = *(_OWORD *)&v77[24];
      long long v25 = v78;
      long long v26 = v79;
      *(_OWORD *)(v21 + 72) = v80;
      *(_OWORD *)(v21 + 56) = v26;
      *(_OWORD *)(v21 + 40) = v25;
      *(_OWORD *)(v21 + 24) = v24;
      int v23 = (char *)(v21 + 88);
      *(void *)(a5 + 40) = v21 + 88;
    }
    *(void *)(a5 + 40) = v23;
    int v27 = v77[23];
    if ((v77[23] & 0x80000000) != 0)
    {
      if (*(void *)&v77[8] != 16) {
        goto LABEL_52;
      }
      uint64_t v28 = *(uint64_t **)v77;
    }
    else
    {
      if (v77[23] != 16) {
        goto LABEL_53;
      }
      uint64_t v28 = (uint64_t *)v77;
    }
    uint64_t v30 = *v28;
    uint64_t v29 = v28[1];
    if (v30 == 0x7274784563657845 && v29 == 0x646E657073755361)
    {
      *(unsigned char *)(a1 + 412) = 1;
      if ((v27 & 0x80000000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
    if ((v77[23] & 0x80000000) != 0) {
LABEL_52:
    }
      operator delete(*(void **)v77);
LABEL_53:
    uint32_t cmd = v67.cmd;
    goto LABEL_54;
  }
  return 0;
}

void sub_10003FD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40)
{
  *(void *)(v40 + 40) = v41;
  if (a39 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>(char *__s@<X1>, uint64_t a2@<X0>, std::string *a3@<X8>)
{
  uint64_t v3 = a3;
  if (!*(unsigned char *)(a2 + 24))
  {
    size_t v5 = strlen(__s);
    if (v5 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v6 = v5;
    if (v5 >= 0x17)
    {
      uint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v5 | 7) != 0x17) {
        uint64_t v9 = v5 | 7;
      }
      uint64_t v10 = v9 + 1;
      int v11 = (std::string *)operator new(v9 + 1);
      v3->__r_.__value_.__l.__size_ = v6;
      v3->__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      v3->__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
      uint64_t v3 = v11;
    }
    else
    {
      *((unsigned char *)&v3->__r_.__value_.__s + 23) = v5;
      if (!v5) {
        goto LABEL_15;
      }
    }
    memcpy(v3, __s, v6);
LABEL_15:
    v3->__r_.__value_.__s.__data_[v6] = 0;
    return;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    size_t v7 = *(const std::string::value_type **)a2;
    std::string::size_type v8 = *(void *)(a2 + 8);
    std::string::__init_copy_ctor_external(a3, v7, v8);
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
}

void MachProcess::FormatDynamicLibrariesIntoJSON()
{
}

void sub_100040EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (a19 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v19 - 144);
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v19 - 160);
  _Unwind_Resume(a1);
}

void ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke(uint64_t a1, uint64_t a2, const unsigned __int8 *a3, std::string::value_type *__s)
{
  memset(&v14, 0, sizeof(v14));
  uint64_t v15 = -1;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  std::string __p = 0;
  *(_OWORD *)unint64_t v21 = 0u;
  *(_OWORD *)long long v22 = 0u;
  long long v23 = 0u;
  char v24 = 0;
  std::string::assign(&v14, __s);
  uuid_copy(v20, a3);
  uint64_t v15 = a2;
  uint64_t v7 = *(void *)(a1 + 32);
  unint64_t v8 = *(void *)(v7 + 8);
  if (v8 >= *(void *)(v7 + 16))
  {
    uint64_t v10 = std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>((void **)v7, (uint64_t)&v14);
  }
  else
  {
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(*(std::string **)(v7 + 8), v14.__r_.__value_.__l.__data_, v14.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v9 = *(_OWORD *)&v14.__r_.__value_.__l.__data_;
      *(void *)(v8 + 16) = *((void *)&v14.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v8 = v9;
    }
    *(void *)(v8 + 24) = v15;
    MachProcess::mach_o_information::mach_o_information(v8 + 32, (uint64_t)&v16);
    *(unsigned char *)(v8 + 152) = v24;
    uint64_t v10 = (char *)(v8 + 160);
    *(void *)(v7 + 8) = v8 + 160;
  }
  *(void *)(v7 + 8) = v10;
  if (SHIBYTE(v23) < 0)
  {
    operator delete(v22[1]);
    if ((SHIBYTE(v22[0]) & 0x80000000) == 0)
    {
LABEL_9:
      int v11 = (void **)__p;
      if (__p) {
        goto LABEL_10;
      }
      goto LABEL_20;
    }
  }
  else if ((SHIBYTE(v22[0]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v21[0]);
  int v11 = (void **)__p;
  if (__p)
  {
LABEL_10:
    uint64_t v12 = v18;
    mach_vm_address_t v13 = v11;
    if (v18 != v11)
    {
      do
      {
        if (*((char *)v12 - 65) < 0) {
          operator delete(*(v12 - 11));
        }
        v12 -= 11;
      }
      while (v12 != v11);
      mach_vm_address_t v13 = __p;
    }
    uint64_t v18 = v11;
    operator delete(v13);
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_17;
    }
    return;
  }
LABEL_20:
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
LABEL_17:
  }
    operator delete(v14.__r_.__value_.__l.__data_);
}

void sub_100041380(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  MachProcess::binary_image_information::~binary_image_information((void **)va);
  _Unwind_Resume(a1);
}

void MachProcess::binary_image_information::~binary_image_information(void **this)
{
  if (*((char *)this + 151) < 0)
  {
    operator delete(this[16]);
    if ((*((char *)this + 127) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = (void **)this[8];
      if (!v2) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((*((char *)this + 127) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[13]);
  uint64_t v2 = (void **)this[8];
  if (!v2)
  {
LABEL_4:
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
LABEL_15:
    operator delete(*this);
    return;
  }
LABEL_8:
  uint64_t v3 = (void **)this[9];
  int v4 = v2;
  if (v3 != v2)
  {
    do
    {
      if (*((char *)v3 - 65) < 0) {
        operator delete(*(v3 - 11));
      }
      v3 -= 11;
    }
    while (v3 != v2);
    int v4 = (void **)this[8];
  }
  this[9] = v2;
  operator delete(v4);
  if (*((char *)this + 23) < 0) {
    goto LABEL_15;
  }
}

void MachProcess::GetAllLoadedLibrariesInfos(MachProcess *this, int a2, int a3)
{
  std::string __p = (void *)0xE00000001;
  LODWORD(v22) = 1;
  HIDWORD(v22) = a2;
  size_t v20 = 648;
  int v5 = sysctl((int *)&__p, 4u, v24, &v20, 0, 0);
  if ((p_p & 4) == 0 && v20 != 0 && v5 == 0) {
    int v8 = 4;
  }
  else {
    int v8 = 8;
  }
  std::string __p = 0;
  long long v22 = 0;
  uint64_t v23 = 0;
  long long v9 = (uint64_t (*)(void, void, size_t *))*((void *)this + 220);
  if (v9)
  {
    LODWORD(v20) = 0;
    uint64_t v10 = v9(*((unsigned int *)this + 30), 0, &v20);
    uint64_t v11 = v10;
    if (v10)
    {
      uint64_t v12 = (void (*)(uint64_t, void *))*((void *)this + 221);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke;
      v24[3] = &__block_descriptor_40_e19_v32__0Q8_16C_16r_24l;
      p_p = &__p;
      v12(v10, v24);
      (*((void (**)(uint64_t))this + 222))(v11);
    }
  }
  if (a3)
  {
    int v13 = *((_DWORD *)this + 2);
    if (!v13)
    {
      std::string v14 = (uint64_t (*)(void, void, void *))*((void *)this + 220);
      if (v14 && (LODWORD(v24[0]) = 0, v15 = v14(*((unsigned int *)this + 30), 0, v24), (uint64_t v16 = v15) != 0))
      {
        unint64_t v17 = (uint64_t (*)(uint64_t))*((void *)this + 224);
        if (v17) {
          int v13 = v17(v15);
        }
        else {
          int v13 = 0;
        }
        (*((void (**)(uint64_t))this + 222))(v16);
      }
      else
      {
        int v13 = 0;
      }
      *((_DWORD *)this + 2) = v13;
    }
    if (v22 != __p)
    {
      uint64_t v18 = 0;
      if ((unint64_t)((v22 - (unsigned char *)__p) / 160) <= 1) {
        uint64_t v19 = 1;
      }
      else {
        uint64_t v19 = (v22 - (unsigned char *)__p) / 160;
      }
      do
      {
        if (MachProcess::GetMachOInformationFromMemory((uint64_t)this, v13, *(void *)((char *)__p + v18 + 24), v8, (uint64_t)__p + v18 + 32))*((unsigned char *)__p + v18 + 152) = 1; {
        v18 += 160;
        }
        --v19;
      }
      while (v19);
    }
  }
  MachProcess::FormatDynamicLibrariesIntoJSON();
}

void sub_10004170C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<MachProcess::binary_image_information>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void **std::vector<MachProcess::binary_image_information>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    int v4 = *a1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 160;
        std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v2);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void MachProcess::GetLibrariesInfoForAddresses(uint64_t a1, int a2, void *a3)
{
  BOOL v44 = (void *)0xE00000001;
  LODWORD(v45) = 1;
  HIDWORD(v45) = a2;
  size_t v41 = 648;
  int v5 = sysctl((int *)&v44, 4u, &v47, &v41, 0, 0);
  if ((v51 & 4) == 0 && v41 != 0 && v5 == 0) {
    int v8 = 4;
  }
  else {
    int v8 = 8;
  }
  BOOL v44 = 0;
  unint64_t v45 = 0;
  uint64_t v46 = 0;
  long long v9 = *(uint64_t (**)(void, void, size_t *))(a1 + 1760);
  if (v9)
  {
    LODWORD(v41) = 0;
    uint64_t v10 = v9(*(unsigned int *)(a1 + 120), 0, &v41);
    uint64_t v11 = v10;
    if (v10)
    {
      uint64_t v12 = *(void (**)(uint64_t, void **))(a1 + 1768);
      char v47 = _NSConcreteStackBlock;
      uint64_t v48 = 3221225472;
      char v49 = ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke;
      uint64_t v50 = (uint64_t)&__block_descriptor_40_e19_v32__0Q8_16C_16r_24l;
      uint64_t v51 = &v44;
      v12(v10, &v47);
      (*(void (**)(uint64_t))(a1 + 1776))(v11);
    }
  }
  int v13 = *(_DWORD *)(a1 + 8);
  if (!v13)
  {
    std::string v14 = *(uint64_t (**)(void, void, void **))(a1 + 1760);
    if (v14 && (LODWORD(v47) = 0, v15 = v14(*(unsigned int *)(a1 + 120), 0, &v47), (uint64_t v16 = v15) != 0))
    {
      unint64_t v17 = *(uint64_t (**)(uint64_t))(a1 + 1792);
      if (v17) {
        int v13 = v17(v15);
      }
      else {
        int v13 = 0;
      }
      (*(void (**)(uint64_t))(a1 + 1776))(v16);
    }
    else
    {
      int v13 = 0;
    }
    *(_DWORD *)(a1 + 8) = v13;
  }
  size_t v41 = 0;
  uint64_t v42 = 0;
  unint64_t v43 = 0;
  uint64_t v18 = a3[1] - *a3;
  if (!v18) {
LABEL_70:
  }
    MachProcess::FormatDynamicLibrariesIntoJSON();
  int v38 = v8;
  uint64_t v39 = a1;
  uint64_t v19 = 0;
  size_t v20 = v44;
  uint64_t v40 = v45;
  unint64_t v21 = v18 >> 3;
  if ((unint64_t)(((unsigned char *)v45 - (unsigned char *)v44) / 160) <= 1) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = ((unsigned char *)v45 - (unsigned char *)v44) / 160;
  }
  if (v21 <= 1) {
    uint64_t v23 = 1;
  }
  else {
    uint64_t v23 = v21;
  }
LABEL_31:
  if (v40 == v20) {
    goto LABEL_46;
  }
  uint64_t v24 = 0;
  char v25 = 0;
  while (1)
  {
    long long v26 = (char *)v44 + 160 * v24;
    uint64_t v27 = v24;
    while (*((void *)v26 + 3) != *(void *)(*a3 + 8 * v19))
    {
      ++v27;
      v26 += 160;
      if (v22 == v27)
      {
        if (v25) {
          goto LABEL_30;
        }
LABEL_46:
        char v47 = 0;
        uint64_t v48 = 0;
        char v49 = 0;
        uint64_t v50 = -1;
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        int v52 = 0;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        std::string::value_type v58 = 0;
        uint64_t v50 = *(void *)(*a3 + 8 * v19);
        BOOL v31 = v42;
        if ((unint64_t)v42 >= v43)
        {
          unint64_t v32 = (std::string *)std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>((void **)&v41, (uint64_t)&v47);
        }
        else
        {
          v42->__r_.__value_.__r.__words[0] = 0;
          v31->__r_.__value_.__l.__size_ = 0;
          v31->__r_.__value_.__r.__words[2] = 0;
          v31[1].__r_.__value_.__r.__words[0] = v50;
          MachProcess::mach_o_information::mach_o_information((uint64_t)&v31[1].__r_.__value_.__l.__size_, (uint64_t)&v51);
          v31[6].__r_.__value_.__s.__data_[8] = v58;
          unint64_t v32 = (std::string *)((char *)v31 + 160);
        }
        uint64_t v42 = v32;
        if ((SHIBYTE(v57) & 0x80000000) == 0)
        {
          if ((SBYTE7(v56) & 0x80000000) == 0) {
            goto LABEL_51;
          }
LABEL_54:
          operator delete((void *)v55);
          long long v33 = (void **)v52;
          if (v52) {
            goto LABEL_55;
          }
LABEL_29:
          if ((SHIBYTE(v49) & 0x80000000) == 0) {
            goto LABEL_30;
          }
LABEL_62:
          operator delete(v47);
          goto LABEL_30;
        }
        operator delete(*((void **)&v56 + 1));
        if (SBYTE7(v56) < 0) {
          goto LABEL_54;
        }
LABEL_51:
        long long v33 = (void **)v52;
        if (!v52) {
          goto LABEL_29;
        }
LABEL_55:
        unint64_t v34 = v53;
        long long v35 = v33;
        if (v53 != v33)
        {
          do
          {
            if (*((char *)v34 - 65) < 0) {
              operator delete(*(v34 - 11));
            }
            v34 -= 11;
          }
          while (v34 != v33);
          long long v35 = v52;
        }
        uint64_t v53 = v33;
        operator delete(v35);
        if (SHIBYTE(v49) < 0) {
          goto LABEL_62;
        }
LABEL_30:
        if (++v19 == v23)
        {
          if (v42 != (std::string *)v41)
          {
            uint64_t v36 = 0;
            if ((unint64_t)((uint64_t)((uint64_t)v42 - v41) / 160) <= 1) {
              uint64_t v37 = 1;
            }
            else {
              uint64_t v37 = (uint64_t)((uint64_t)v42 - v41) / 160;
            }
            do
            {
              if (MachProcess::GetMachOInformationFromMemory(v39, v13, *(void *)(v41 + v36 + 24), v38, v41 + v36 + 32))*(unsigned char *)(v41 + v36 + 152) = 1; {
              v36 += 160;
              }
              --v37;
            }
            while (v37);
          }
          goto LABEL_70;
        }
        goto LABEL_31;
      }
    }
    uint64_t v28 = v42;
    if ((unint64_t)v42 >= v43)
    {
      uint64_t v30 = (std::string *)std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>((void **)&v41, (uint64_t)v26);
    }
    else
    {
      if (v26[23] < 0)
      {
        std::string::__init_copy_ctor_external(v42, *(const std::string::value_type **)v26, *((void *)v26 + 1));
      }
      else
      {
        long long v29 = *(_OWORD *)v26;
        v42->__r_.__value_.__r.__words[2] = *((void *)v26 + 2);
        *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v29;
      }
      v28[1].__r_.__value_.__r.__words[0] = *((void *)v26 + 3);
      MachProcess::mach_o_information::mach_o_information((uint64_t)&v28[1].__r_.__value_.__l.__size_, (uint64_t)(v26 + 32));
      v28[6].__r_.__value_.__s.__data_[8] = v26[152];
      uint64_t v30 = (std::string *)((char *)v28 + 160);
    }
    uint64_t v42 = v30;
    uint64_t v24 = v27 + 1;
    char v25 = 1;
    if (v22 - 1 == v27) {
      goto LABEL_30;
    }
  }
}

void sub_100041CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::vector<MachProcess::binary_image_information>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void MachProcess::GetSharedCacheInfo(MachProcess *this)
{
}

void sub_100042064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,char a42)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100]((uint64_t)&a42);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::GetCurrentThread(MachProcess *this)
{
  return MachThreadList::CurrentThreadID((MachProcess *)((char *)this + 968));
}

uint64_t MachProcess::SetCurrentThread(MachProcess *this, uint64_t a2)
{
  return MachThreadList::SetCurrentThread((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetThreadStoppedReason(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t ThreadStoppedReason = MachThreadList::GetThreadStoppedReason(a1 + 968, a2, (uint64_t)a3);
  if (ThreadStoppedReason)
  {
    if (*(unsigned char *)(a1 + 1752))
    {
      *a3 = 3;
    }
    else if (*a3 == 4)
    {
      MachProcess::RefineWatchpointStopInfo(a1, a2, (uint64_t)a3);
    }
  }
  return ThreadStoppedReason;
}

void MachProcess::RefineWatchpointStopInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = (DNBBreakpointList *)(a1 + 1664);
  NearestWatchpoint = DNBBreakpointList::FindNearestWatchpoint((DNBBreakpointList *)(a1 + 1664), *(void *)(a3 + 264));
  if (NearestWatchpoint)
  {
    uint64_t v7 = NearestWatchpoint;
    *(void *)(a3 + 272) = *((void *)NearestWatchpoint + 2);
    *(_DWORD *)(a3 + 280) = *((_DWORD *)NearestWatchpoint + 7);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("MachProcess::RefineWatchpointStopInfo mach exception addr 0x%llx moved in to nearest watchpoint, 0x%llx-0x%llx", *(void *)(a3 + 264), *((void *)v7 + 2), *((void *)v7 + 2) + *((unsigned int *)v7 + 1) - 1);
    }
  }
  else
  {
    *(void *)(a3 + 272) = *(void *)(a3 + 264);
  }
  *(unsigned char *)(a3 + 284) = 0;
  unint64_t v43 = 0;
  uint64_t v37 = a1 + 968;
  MachThreadList::GetThreadByID((MachThreadList *)(a1 + 968), a2, &v40);
  if (v40 && *(void *)(v40 + 184))
  {
    uint64_t RegisterSetInfo = DNBArchProtocol::GetRegisterSetInfo((DNBArchProtocol *)&v43, v8);
  }
  else
  {
    uint64_t RegisterSetInfo = 0;
    unint64_t v43 = 0;
  }
  long long v33 = v5;
  uint64_t v10 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  unint64_t v11 = v43;
  if (v43)
  {
    uint64_t v34 = a3;
    uint64_t v35 = RegisterSetInfo;
    unint64_t v12 = 0;
    char v13 = 0;
    unint64_t v38 = 0;
    char v14 = 0;
    uint64_t v36 = 0;
    do
    {
      uint64_t v15 = RegisterSetInfo + 24 * v12;
      uint64_t v17 = *(void *)(v15 + 8);
      uint64_t v16 = (void *)(v15 + 8);
      if (v17)
      {
        uint64_t v18 = RegisterSetInfo + 24 * v12;
        uint64_t v20 = *(void *)(v18 + 16);
        uint64_t v19 = (unint64_t *)(v18 + 16);
        if (v20)
        {
          unint64_t v21 = 0;
          unsigned int v22 = 1;
          do
          {
            uint64_t v23 = *(const char **)(*v16 + 72 * v21 + 8);
            if (!strcmp(v23, "esr"))
            {
              int RegisterValue = MachThreadList::GetRegisterValue(v37, a2);
              unint64_t v25 = v38;
              if (RegisterValue) {
                unint64_t v25 = v42;
              }
              unint64_t v38 = v25;
              if (RegisterValue) {
                char v13 = 1;
              }
              uint64_t v23 = *(const char **)(*v16 + 72 * v21 + 8);
            }
            if (!strcmp(v23, "far"))
            {
              int v26 = MachThreadList::GetRegisterValue(v37, a2);
              unint64_t v27 = v36;
              if (v26) {
                unint64_t v27 = v42;
              }
              uint64_t v36 = v27;
              if (v26) {
                char v14 = 1;
              }
            }
            unint64_t v21 = v22++;
          }
          while (*v19 > v21);
          unint64_t v11 = v43;
          uint64_t RegisterSetInfo = v35;
        }
      }
      ++v12;
    }
    while (v12 < v11);
    if (v13 && v14)
    {
      if (v36 != *(void *)(v34 + 264) && DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("MachProcess::RefineWatchpointStopInfo mach exception addr 0x%llx but FAR register has value 0x%llx", *(void *)(v34 + 264), v36);
      }
      if ((v38 & 0xFC000000) == 0xD0000000)
      {
        *(unsigned char *)(v34 + 284) = 1;
        *(_DWORD *)(v34 + 288) = v38 & 0xFFFFFF;
        *(_DWORD *)(v34 + 292) = (v38 >> 18) & 0x3F;
        uint64x2_t v28 = (uint64x2_t)vdupq_n_s64(v38);
        int16x8_t v29 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_100065DE0), (int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_100065DD0));
        *(int8x8_t *)v29.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v29), (int8x8_t)0x1000100010001);
        *(_DWORD *)(v34 + 296) = vmovn_s16(v29).u32[0];
        *(unsigned char *)(v34 + 300) = (v38 & 0x400) != 0;
        BOOL v30 = (v38 & 0x40) != 0;
        *(unsigned char *)(v34 + 301) = v30;
        *(unsigned char *)(v34 + 302) = v30;
        *(_DWORD *)(v34 + 304) = v38 & 0x3F;
        if (DNBLogEnabledForAny(2048)) {
          _DNBLogThreaded("ESR watchpoint fields parsed: iss = 0x%x, wpt = %u, wptv = %d, wpf = %d, fnp = %d, vncr = %d, fnv = %d, cm = %d, wnr = %d, dfsc = 0x%x", *(_DWORD *)(v34 + 288), *(_DWORD *)(v34 + 292), *(unsigned __int8 *)(v34 + 296), *(unsigned __int8 *)(v34 + 297), *(unsigned __int8 *)(v34 + 298), *(unsigned __int8 *)(v34 + 299), *(unsigned __int8 *)(v34 + 300), *(unsigned __int8 *)(v34 + 301), *(unsigned __int8 *)(v34 + 302), *(_DWORD *)(v34 + 304));
        }
        if (*(unsigned char *)(v34 + 296))
        {
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded("Watchpoint Valid field true, finding startaddr of watchpoint %d", *(_DWORD *)(v34 + 292));
          }
          int v31 = *(_DWORD *)(v34 + 292);
          *(_DWORD *)(v34 + 280) = v31;
          unint64_t v32 = DNBBreakpointList::FindByHardwareIndex(v33, v31);
          if (v32) {
            *(void *)(v34 + 272) = *((void *)v32 + 2);
          }
        }
      }
    }
  }
}

void sub_100042544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

char *MachProcess::GetThreadInfo(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetThreadInfo((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetCPUType(MachProcess *this)
{
  uint64_t result = *((unsigned int *)this + 1);
  if (!result)
  {
    int v3 = *(_DWORD *)this;
    if (*(_DWORD *)this)
    {
      long long v9 = 0u;
      long long v10 = 0u;
      *(_OWORD *)int v8 = 0u;
      size_t v7 = 12;
      if (sysctlnametomib("sysctl.proc_cputype", v8, &v7))
      {
        uint64_t result = 0;
      }
      else
      {
        size_t v4 = v7;
        v8[v7] = v3;
        size_t v7 = v4 + 1;
        unsigned int v6 = 0;
        size_t v5 = 4;
        if (sysctl(v8, v4 + 1, &v6, &v5, 0, 0)) {
          uint64_t result = 0;
        }
        else {
          uint64_t result = v6;
        }
      }
      *((_DWORD *)this + 1) = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t MachProcess::GetRegisterValue(uint64_t a1, uint64_t a2)
{
  return MachThreadList::GetRegisterValue(a1 + 968, a2);
}

uint64_t MachProcess::SetRegisterValue(uint64_t a1, uint64_t a2)
{
  return MachThreadList::SetRegisterValue(a1 + 968, a2);
}

uint64_t MachProcess::SetState(uint64_t a1, unsigned int a2)
{
  size_t v4 = (pthread_mutex_t *)(a1 + 1224);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1224));
  unsigned int v5 = *(_DWORD *)(a1 + 1216);
  if (v5 == 9)
  {
    if (DNBLogEnabledForAny(2))
    {
      DNBStateAsString(a2);
      _DNBLogThreaded("MachProcess::SetState(%s) ignoring new state since current state is exited");
    }
LABEL_7:
    int v6 = 0;
    goto LABEL_8;
  }
  if (v5 == a2)
  {
    if (DNBLogEnabledForAny(2))
    {
      DNBStateAsString(a2);
      _DNBLogThreaded("MachProcess::SetState(%s) ignoring redundant state change...");
    }
    goto LABEL_7;
  }
  if (a2 - 1 > 8) {
    int v6 = 1;
  }
  else {
    int v6 = dword_100065E60[a2 - 1];
  }
  if (DNBLogEnabledForAny(2))
  {
    unint64_t v11 = DNBStateAsString(a2);
    unint64_t v12 = DNBStateAsString(v5);
    _DNBLogThreaded("MachProcess::SetState(%s) upating state (previous state was %s), event_mask = 0x%8.8x", v11, v12, v6);
  }
  *(_DWORD *)(a1 + 1216) = a2;
  if (a2 == 4) {
    ++*(_DWORD *)(a1 + 444);
  }
LABEL_8:
  uint64_t result = pthread_mutex_unlock(v4);
  if (v6)
  {
    int v8 = (PThreadEvent *)(a1 + 1288);
    PThreadEvent::SetEvents((pthread_mutex_t *)(a1 + 1288), v6);
    long long v9 = (pthread_mutex_t *)(a1 + 1464);
    PThreadEvent::SetEvents(v9, v6);
    if (v6 == 2) {
      int v10 = 1;
    }
    else {
      int v10 = 2;
    }
    PThreadEvent::ResetEvents(v9, v10);
    return PThreadEvent::WaitForResetAck(v8, v6, 0);
  }
  return result;
}

void sub_1000427F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::STDIOThread(MachProcess *this, void *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s(arg = %p) thread starting...", "STDIOThread", this);
  }
  pthread_setname_np("stdio monitoring thread");
  *(_OWORD *)std::string __p = 0u;
  long long v21 = 0u;
  int v3 = *((_DWORD *)this + 4);
  if (v3 == *((_DWORD *)this + 5)) {
    int v4 = -1;
  }
  else {
    int v4 = *((_DWORD *)this + 5);
  }
  BOOL v5 = v3 >= 0;
  BOOL v6 = v4 >= 0;
  while ((v3 & 0x80000000) == 0 || (v4 & 0x80000000) == 0)
  {
    pthread_testcancel();
    memset(&v19, 0, sizeof(v19));
    if (v5 && __darwin_check_fd_set_overflow(v3, &v19, 0)) {
      v19.fds_bits[v3 >> 5] |= 1 << v3;
    }
    if (v6 && __darwin_check_fd_set_overflow(v4, &v19, 0)) {
      v19.fds_bits[v4 >> 5] |= 1 << v4;
    }
    if (v3 <= v4) {
      int v7 = v4;
    }
    else {
      int v7 = v3;
    }
    int v8 = select(v7 + 1, &v19, 0, 0, 0);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("select (nfds, &read_fds, NULL, NULL, NULL) => %d", v8);
    }
    if (v8 < 0)
    {
      unsigned int v11 = *__error();
      if (DNBLogCheckLogBit(2))
      {
        __p[0] = (void *)(v11 | 0x200000000);
        if (SHIBYTE(v21) < 0)
        {
          *(unsigned char *)__p[1] = 0;
          *(void *)&long long v21 = 0;
        }
        else
        {
          LOBYTE(__p[1]) = 0;
          HIBYTE(v21) = 0;
        }
        DNBError::LogThreadedIfError((DNBError *)__p, "select (nfds, &read_fds, NULL, NULL, NULL) => %d", v8);
      }
      if (v11 == 9) {
        goto LABEL_55;
      }
    }
    else if (v8)
    {
      v22[1023] = 0;
      if (v5
        && __darwin_check_fd_set_overflow(v3, &v19, 0)
        && ((v19.fds_bits[v3 >> 5] >> v3) & 1) != 0)
      {
        while (1)
        {
          std::string::size_type v9 = read(v3, v22, 0x3FFuLL);
          std::string::size_type v10 = v9;
          if ((v9 & 0x8000000000000000) != 0)
          {
            int v12 = *__error();
            if (DNBLogEnabledForAny(2))
            {
              char v13 = strerror(v12);
              _DNBLogThreaded("read (stdout_fd,) => %zd   errno: %d (%s)", v10, v12, v13);
            }
            goto LABEL_36;
          }
          if (!v9) {
            break;
          }
          MachProcess::AppendSTDOUT(this, v22, v9);
        }
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("read (stdout_fd,) => %zd  (reached EOF for child STDOUT)", 0);
        }
        int v3 = -1;
        if (v6) {
          goto LABEL_37;
        }
      }
      else
      {
LABEL_36:
        if (v6)
        {
LABEL_37:
          if (__darwin_check_fd_set_overflow(v4, &v19, 0)
            && ((v19.fds_bits[v4 >> 5] >> v4) & 1) != 0)
          {
            while (1)
            {
              std::string::size_type v14 = read(v4, v22, 0x3FFuLL);
              std::string::size_type v15 = v14;
              if ((v14 & 0x8000000000000000) != 0) {
                break;
              }
              if (!v14)
              {
                if (DNBLogEnabledForAny(2)) {
                  _DNBLogThreaded("read (stderr_fd,) => %zd  (reached EOF for child STDERR)", 0);
                }
                int v4 = -1;
                goto LABEL_51;
              }
              MachProcess::AppendSTDOUT(this, v22, v14);
            }
            int v16 = *__error();
            if (DNBLogEnabledForAny(2))
            {
              uint64_t v17 = strerror(v16);
              _DNBLogThreaded("read (stderr_fd,) => %zd   errno: %d (%s)", v15, v16, v17);
            }
          }
        }
      }
    }
LABEL_51:
    BOOL v5 = v3 >= 0;
    BOOL v6 = v4 >= 0;
  }
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (%p): thread exiting...", "STDIOThread", this);
  }
LABEL_55:
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[1]);
  }
  return 0;
}

void sub_100042BB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

pthread_mutex_t *MachProcess::SetEnableAsyncProfiling(pthread_mutex_t *result, int a2, int a3, int a4)
{
  int v4 = result;
  result[8].__opaque[24] = a2;
  *(_DWORD *)&result[8].__opaque[28] = a3;
  *(_DWORD *)&result[8].__opaque[32] = a4;
  uint64_t v5 = *(void *)&result[8].__opaque[40];
  if (a2)
  {
    if (!v5)
    {
      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded("MachProcess::%s()", "StartProfileThread");
      }
      return (pthread_mutex_t *)pthread_create((pthread_t *)&v4[8].__opaque[40], 0, (void *(__cdecl *)(void *))MachProcess::ProfileThread, v4);
    }
  }
  else if (v5)
  {
    PThreadEvent::SetEvents((pthread_mutex_t *)((char *)result + 656), 1);
    pthread_join(*(pthread_t *)&v4[8].__opaque[40], 0);
    *(void *)&v4[8].__opaque[40] = 0;
    return PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)v4 + 656), 1);
  }
  return result;
}

uint64_t MachProcess::ProfileThread(MachProcess *this, void *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s(arg = %p) thread starting...", "ProfileThread", this);
  }
  pthread_setname_np("performance profiling thread");
  while (*((unsigned char *)this + 544))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    int v3 = *((_DWORD *)this + 304);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
    if (v3 != 5)
    {
      if (v3 == 1 || v3 == 8) {
        return 0;
      }
      goto LABEL_17;
    }
    MachTask::GetProfileData((uint64_t)this + 104, *((_DWORD *)this + 138), v4, (void **)&__p);
    if (v13 < 0)
    {
      if (!*(void *)&__p.tv_usec) {
        goto LABEL_16;
      }
      int tv_sec = (const char *)__p.tv_sec;
    }
    else
    {
      if (!v13) {
        goto LABEL_17;
      }
      int tv_sec = (const char *)&__p;
    }
    MachProcess::SignalAsyncProfileData(this, tv_sec);
    if (v13 < 0) {
LABEL_16:
    }
      operator delete((void *)__p.tv_sec);
LABEL_17:
    unsigned int v6 = *((_DWORD *)this + 137);
    uint64_t v7 = v6 / 0xF4240;
    uint64_t v8 = v6 % 0xF4240;
    gettimeofday(&__p, 0);
    v11.int tv_sec = __p.tv_sec;
    v11.tv_nsec = 1000 * __p.tv_usec;
    if (v8 | v7)
    {
      uint64_t v9 = 1000 * __p.tv_usec + v8;
      v11.int tv_sec = __p.tv_sec + v7 + v9 / 1000000000;
      v11.tv_nsec = v9 % 1000000000;
    }
    if (PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 656), 1u, &v11)) {
      return 0;
    }
  }
  return 0;
}

void sub_100042E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::Resume(MachProcess *this, char **a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Resume ()");
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  unsigned int v4 = *((_DWORD *)this + 304);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
  if (v4 == 5)
  {
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"Resume() - task 0x%x is already running, ignoring...", v5, v6, v7, v8, v9, v10, *((unsigned int *)this + 30));
    }
    return 1;
  }
  if (v4 == 4)
  {
    if ((char **)((char *)this + 832) != a2) {
      std::vector<DNBThreadResumeAction>::__assign_with_size[abi:ne180100]<DNBThreadResumeAction*,DNBThreadResumeAction*>((void *)this + 104, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
    }
    std::vector<BOOL>::operator=((uint64_t)this + 856, (uint64_t)(a2 + 3));
    MachProcess::PrivateResume(this);
    return 1;
  }
  BOOL result = DNBLogEnabled();
  if (result)
  {
    uint64_t v12 = *((unsigned int *)this + 30);
    DNBStateAsString(v4);
    _DNBLog(0, (uint64_t)"Resume() - task 0x%x has state %s, can't continue...", v13, v14, v15, v16, v17, v18, v12);
    return 0;
  }
  return result;
}

uint64_t MachProcess::PrivateResume(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  int v3 = *((_DWORD *)this + 436);
  *((_DWORD *)this + 437) = v3;
  if (v3)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::PrivateResume() - task 0x%x resuming (with unhandled interrupt signal %i)...", *((_DWORD *)this + 30), *((_DWORD *)this + 437));
    }
  }
  else if (DNBLogEnabledForAny(2))
  {
    _DNBLogThreaded("MachProcess::PrivateResume() - task 0x%x resuming...", *((_DWORD *)this + 30));
  }
  MachProcess::ReplyToAllExceptions(this);
  MachThreadList::ProcessWillResume((MachProcess *)((char *)this + 968), this, (MachProcess *)((char *)this + 832));
  if (DNBThreadResumeActions::NumActionsWithState((uint64_t *)this + 104, 6)) {
    unsigned int v4 = 6;
  }
  else {
    unsigned int v4 = 5;
  }
  MachProcess::SetState((uint64_t)this, v4);
  MachTask::Resume((MachProcess *)((char *)this + 104), v5, v6);
  return pthread_mutex_unlock(v2);
}

void sub_100043078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::Kill(MachProcess *this, const timespec *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Kill ()");
  }
  unsigned int v3 = MachProcess::DoSIGSTOP(this, 1, 0, 0);
  if (DNBLogEnabledForAny(2))
  {
    unsigned int v4 = DNBStateAsString(v3);
    _DNBLogThreaded("MachProcess::Kill() DoSIGSTOP() state = %s", v4);
  }
  *__error() = 0;
  if (DNBLogEnabled()) {
    _DNBLog(0, (uint64_t)"Sending ptrace PT_KILL to terminate inferior process pid %d.", v5, v6, v7, v8, v9, v10, *(unsigned int *)this);
  }
  ptrace(8, *(_DWORD *)this, 0, 0);
  *(_OWORD *)uint64_t v34 = 0u;
  long long v35 = 0u;
  LODWORD(v34[0]) = *__error();
  HIDWORD(v34[0]) = 2;
  LOBYTE(v34[1]) = 0;
  HIBYTE(v35) = 0;
  BOOL v11 = DNBLogCheckLogBit(2);
  int v12 = (int)v34[0];
  if (LODWORD(v34[0])) {
    int v13 = 1;
  }
  else {
    int v13 = v11;
  }
  if (v13 == 1)
  {
    int v14 = *(_DWORD *)this;
    uint64_t v15 = (const char *)DNBError::AsString((DNBError *)v34);
    DNBError::LogThreaded((DNBError *)v34, "MachProcess::Kill() DoSIGSTOP() ::ptrace (PT_KILL, pid=%u, 0, 0) => 0x%8.8x (%s)", v14, v12, v15);
  }
  DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)__p, 5, 0);
  uint64_t v16 = (void *)*((void *)this + 104);
  if (v16)
  {
    *((void *)this + 105) = v16;
    operator delete(v16);
    *((void *)this + 104) = 0;
    *((void *)this + 105) = 0;
    *((void *)this + 106) = 0;
  }
  *((_OWORD *)this + 52) = *(_OWORD *)__p;
  *((void *)this + 106) = v31;
  __p[1] = 0;
  uint64_t v31 = 0;
  __p[0] = 0;
  uint64_t v17 = (void *)*((void *)this + 107);
  if (v17)
  {
    operator delete(v17);
    *((void *)this + 107) = 0;
    *((void *)this + 108) = 0;
    *((void *)this + 109) = 0;
    uint64_t v17 = __p[0];
  }
  *((void *)this + 107) = v32;
  *((_OWORD *)this + 54) = v33;
  long long v33 = 0uLL;
  uint64_t v32 = 0;
  if (v17)
  {
    __p[1] = v17;
    operator delete(v17);
  }
  MachProcess::PrivateResume(this);
  unsigned int v18 = 0;
  fd_set v19 = (pthread_mutex_t *)((char *)this + 1224);
  while (1)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    int v20 = *((_DWORD *)this + 304);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
    if (v20 == 9) {
      break;
    }
    usleep(0x2710u);
    BOOL v21 = v18 >= 0xF1B30;
    v18 += 10000;
    if (v21)
    {
      unsigned int v18 = 1000000;
      break;
    }
  }
  if (DNBLogEnabled())
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    unsigned int v22 = *((_DWORD *)this + 304);
    pthread_mutex_unlock(v19);
    DNBStateAsString(v22);
    _DNBLog(0, (uint64_t)"Waited %u ms for process to be reaped (state = %s)", v23, v24, v25, v26, v27, v28, v18 / 0x3E8uLL);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[1]);
  }
  return 1;
}

void sub_100043308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::DoSIGSTOP(MachProcess *this, int a2, int a3, unsigned int *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  unsigned int v9 = *((_DWORD *)this + 304);
  pthread_mutex_unlock(v8);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v10 = DNBStateAsString(v9);
    _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s", v10);
  }
  if (v9 - 5 >= 2)
  {
    if (a2)
    {
      if (DNBLogEnabledForAny(512)) {
        _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", 1);
      }
      DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
      DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", 1);
      }
      DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
      DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
    }
    unsigned int ThreadIndexForThreadStoppedWithSignal = MachThreadList::GetThreadIndexForThreadStoppedWithSignal((MachProcess *)((char *)this + 968), 17);
    if (a4) {
      *a4 = ThreadIndexForThreadStoppedWithSignal;
    }
    if (ThreadIndexForThreadStoppedWithSignal != -1)
    {
      pthread_mutex_lock(v8);
      uint64_t v12 = *((unsigned int *)this + 304);
      pthread_mutex_unlock(v8);
      return v12;
    }
    if (DNBLogEnabledForAny(2))
    {
      int v13 = DNBStateAsString(v9);
      _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s -- resuming process", v13);
    }
    if (a3) {
      int v14 = 5;
    }
    else {
      int v14 = 10;
    }
    DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)__p, v14, 0);
    uint64_t v15 = (void *)*((void *)this + 104);
    if (v15)
    {
      *((void *)this + 105) = v15;
      operator delete(v15);
    }
    *((_OWORD *)this + 52) = *(_OWORD *)__p;
    *((void *)this + 106) = v22;
    __p[1] = 0;
    uint64_t v22 = 0;
    __p[0] = 0;
    uint64_t v16 = (void *)*((void *)this + 107);
    if (v16)
    {
      operator delete(v16);
      uint64_t v16 = __p[0];
    }
    *((void *)this + 107) = v23;
    *((_OWORD *)this + 54) = v24;
    long long v24 = 0uLL;
    uint64_t v23 = 0;
    if (v16)
    {
      __p[1] = v16;
      operator delete(v16);
    }
    MachProcess::PrivateResume(this);
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 1288), 1);
    pthread_mutex_lock(v8);
    unsigned int v9 = *((_DWORD *)this + 304);
    pthread_mutex_unlock(v8);
    a2 = 0;
  }
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v17 = DNBStateAsString(v9);
    _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s -- sending SIGSTOP", v17);
  }
  gettimeofday((timeval *)__p, 0);
  v20.int tv_sec = (__darwin_time_t)__p[0] + SLODWORD(__p[1]) / 1000000 + 2;
  v20.tv_nsec = 1000 * LODWORD(__p[1]) % 1000000000;
  MachProcess::Signal(this, 17, &v20);
  if (a2)
  {
    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", 1);
    }
    DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", 1);
    }
    DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
  }
  unsigned int v18 = MachThreadList::GetThreadIndexForThreadStoppedWithSignal((MachProcess *)((char *)this + 968), 17);
  if (a4) {
    *a4 = v18;
  }
  pthread_mutex_lock(v8);
  uint64_t v12 = *((unsigned int *)this + 304);
  pthread_mutex_unlock(v8);
  return v12;
}

BOOL MachProcess::Interrupt(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  int v3 = *((_DWORD *)this + 304);
  pthread_mutex_unlock(v2);
  if ((v3 - 5) > 1)
  {
    BOOL result = DNBLogEnabledForAny(2);
    if (!result) {
      return result;
    }
    _DNBLogThreaded("MachProcess::Interrupt() - process already stopped, no interrupt sent");
    return 0;
  }
  if (*((_DWORD *)this + 436))
  {
    BOOL result = DNBLogEnabledForAny(2);
    if (!result) {
      return result;
    }
    _DNBLogThreaded("MachProcess::Interrupt() - previously sent an interrupt signal %i that hasn't been received yet, interrupt aborted");
    return 0;
  }
  *((_DWORD *)this + 436) = 17;
  if (MachProcess::Signal(this, 17, 0))
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::Interrupt() - sent %i signal to interrupt process", *((_DWORD *)this + 436));
    }
    return 1;
  }
  else
  {
    *((_DWORD *)this + 436) = 0;
    BOOL v5 = DNBLogEnabledForAny(2);
    BOOL result = 0;
    if (v5)
    {
      _DNBLogThreaded("MachProcess::Interrupt() - failed to send %i signal to interrupt process");
      return 0;
    }
  }
  return result;
}

BOOL MachProcess::Signal(MachProcess *this, int a2, const timespec *a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p)", a2, a3);
  }
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  int v7 = *((_DWORD *)this + 304);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
  if (kill(*(_DWORD *)this, a2))
  {
    v12[0] = *__error();
    v12[1] = 2;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    timeval __p = 0;
    DNBError::LogThreadedIfError((DNBError *)v12, "kill (pid = %d, signo = %i)", *(_DWORD *)this, a2);
    if (SHIBYTE(v15) < 0) {
      operator delete(__p);
    }
    return 0;
  }
  else
  {
    BOOL v9 = DNBLogEnabledForAny(2);
    if (a3 && (v7 - 5) <= 1)
    {
      if (v9) {
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) waiting for signal to stop process...", a2, a3);
      }
      PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 1464), 2u, a3);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
      unsigned int v10 = *((_DWORD *)this + 304);
      pthread_mutex_unlock(v6);
      if (DNBLogEnabledForAny(2))
      {
        BOOL v11 = DNBStateAsString(v10);
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) state = %s", a2, a3, v11);
      }
      return v10 - 7 < 0xFFFFFFFE;
    }
    else
    {
      if (v9) {
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) not waiting...", a2, a3);
      }
      return 1;
    }
  }
}

void sub_100043928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::SendEvent(MachProcess *this, char *a2, DNBError *a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::SendEvent (event = %s) to pid: %d", a2, *(_DWORD *)this);
  }
  if (!*(_DWORD *)this) {
    return 0;
  }

  return MachProcess::BoardServiceSendEvent(this, a2, a3);
}

BOOL MachProcess::BoardServiceSendEvent(MachProcess *this, char *a2, DNBError *a3)
{
  if (!a2 || !*a2)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("SendEvent called with NULL event data.");
    }
    std::string::assign((std::string *)((char *)a3 + 8), "SendEvent called with empty event data");
    return 0;
  }
  id v6 = objc_alloc_init((Class)NSAutoreleasePool);
  if (!strcmp(a2, "BackgroundApplication"))
  {
    int v9 = *((_DWORD *)this + 110);
    if ((v9 & 0x10) == 0)
    {
      uint64_t v10 = *(unsigned int *)this;
      if (v10)
      {
        if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v10])
        {
          int v11 = *((_DWORD *)this + 110) | 8;
        }
        else
        {
          unsigned int v17 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
          int v11 = *((_DWORD *)this + 110);
          if (v17) {
            v11 |= 4u;
          }
        }
        int v9 = v11 | 0x10;
        *((_DWORD *)this + 110) = v9;
      }
    }
    if ((v9 & 4) != 0)
    {
      int v18 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>(0, 0, (uint64_t)a3, 0);
      int v9 = *((_DWORD *)this + 110);
      if ((v9 & 0x10) != 0)
      {
LABEL_48:
        if ((v9 & 8) != 0) {
          int v18 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>(0, 0, (uint64_t)a3, 0);
        }
        BOOL v8 = v18 != 0;
        if (v18) {
          goto LABEL_65;
        }
        if (DNBLogEnabled())
        {
          DNBError::AsString(a3);
          _DNBLogError("Failed to background application, error: %s.");
        }
        goto LABEL_64;
      }
    }
    else
    {
      int v18 = 1;
      if ((v9 & 0x10) != 0) {
        goto LABEL_48;
      }
    }
    uint64_t v19 = *(unsigned int *)this;
    if (v19)
    {
      if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v19])
      {
        int v20 = *((_DWORD *)this + 110) | 8;
      }
      else
      {
        unsigned int v26 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v20 = *((_DWORD *)this + 110);
        if (v26) {
          v20 |= 4u;
        }
      }
      int v9 = v20 | 0x10;
      *((_DWORD *)this + 110) = v9;
    }
    goto LABEL_48;
  }
  int v7 = (void *)((char *)this + 1720);
  if (*((char *)this + 1743) < 0)
  {
    if (!*((void *)this + 216)) {
      goto LABEL_21;
    }
    int v7 = (void *)*v7;
  }
  else if (!*((unsigned char *)this + 1743))
  {
LABEL_21:
    if (DNBLogEnabled()) {
      _DNBLogError("Tried to send event \"%s\" to a process that has no bundle ID.", a2);
    }
    return 0;
  }
  uint64_t v12 = +[NSString stringWithUTF8String:v7];
  int v13 = (NSMutableDictionary *)+[NSMutableDictionary dictionary];
  int v14 = *((_DWORD *)this + 110);
  if ((v14 & 0x10) == 0)
  {
    uint64_t v15 = *(unsigned int *)this;
    if (v15)
    {
      if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v15])
      {
        int v16 = *((_DWORD *)this + 110) | 8;
      }
      else
      {
        unsigned int v21 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v16 = *((_DWORD *)this + 110);
        if (v21) {
          v16 |= 4u;
        }
      }
      int v14 = v16 | 0x10;
      *((_DWORD *)this + 110) = v14;
    }
  }
  if ((v14 & 4) != 0)
  {
    if ((BKSAddEventDataToOptions(v13, a2, a3) & 1) == 0) {
      goto LABEL_67;
    }
    char v22 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>(v12, v13, (uint64_t)a3, 0);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("Called BKSCallOpenApplicationFunction to send event.");
    }
  }
  else
  {
    char v22 = 1;
  }
  int v23 = *((_DWORD *)this + 110);
  if ((v23 & 0x10) == 0)
  {
    uint64_t v24 = *(unsigned int *)this;
    if (v24)
    {
      if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v24])
      {
        int v25 = *((_DWORD *)this + 110) | 8;
      }
      else
      {
        unsigned int v27 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v25 = *((_DWORD *)this + 110);
        if (v27) {
          v25 |= 4u;
        }
      }
      int v23 = v25 | 0x10;
      *((_DWORD *)this + 110) = v23;
    }
  }
  if ((v23 & 8) == 0) {
    goto LABEL_57;
  }
  if (FBSAddEventDataToOptions(v13, a2, a3))
  {
    char v22 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>(v12, v13, (uint64_t)a3, 0);
    if (DNBLogEnabledForAny(2))
    {
      _DNBLogThreaded("Called FBSCallOpenApplicationFunction to send event.");
      if (v22) {
        goto LABEL_58;
      }
LABEL_62:
      if (DNBLogEnabled())
      {
        DNBError::AsString(a3);
        _DNBLogError("Failed to send event: %s, error: %s.");
      }
LABEL_64:
      BOOL v8 = 0;
      goto LABEL_65;
    }
LABEL_57:
    if (v22)
    {
LABEL_58:
      BOOL v8 = 1;
LABEL_65:
      [v6 drain];
      return v8;
    }
    goto LABEL_62;
  }
LABEL_67:
  [v6 drain];
  return 0;
}

void MachProcess::DisableAllBreakpoints(MachProcess *this, int a2)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", a2);
  }
  DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
  if (a2)
  {
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
  }
}

void MachProcess::DisableAllWatchpoints(MachProcess *this, int a2)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", a2);
  }
  DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
  if (a2)
  {
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
  }
}

uint64_t MachProcess::Detach(MachProcess *this)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Detach()");
  }
  unsigned int v14 = -1;
  unsigned int v2 = MachProcess::DoSIGSTOP(this, 1, 1, &v14);
  if (DNBLogEnabledForAny(2))
  {
    int v3 = DNBStateAsString(v2);
    _DNBLogThreaded("MachProcess::Detach() DoSIGSTOP() returned %s", v3);
  }
  *((void *)this + 105) = *((void *)this + 104);
  *((void *)this + 108) = 0;
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  *(void *)&long long v10 = MachThreadList::ThreadIDAtIndex((MachProcess *)((char *)this + 968), v14);
  *((void *)&v10 + 1) = -4294967291;
  uint64_t v11 = -1;
  DNBThreadResumeActions::Append((char **)this + 104, &v10);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)this + 104, 5, 0);
  int v13 = (char *)this + 904;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  MachProcess::ReplyToAllExceptions(this);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904));
  MachTask::ShutDownExcecptionThread((MachProcess *)((char *)this + 104));
  *__error() = 0;
  int v4 = *(_DWORD *)this;
  int v5 = ptrace(11, *(_DWORD *)this, (caddr_t)1, 0);
  unsigned int v6 = *__error();
  long long v10 = v6 | 0x200000000uLL;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (DNBLogCheckLogBit(2) || v6 | v5) {
    DNBError::LogThreaded((DNBError *)&v10, "::ptrace (PT_DETACH, %u, (caddr_t)1, 0)", v4);
  }
  MachTask::Resume((MachProcess *)((char *)this + 104), v7, v8);
  MachTask::Clear((void *)this + 13);
  *((_DWORD *)this + 2) = 0;
  MachProcess::Clear(this, 1);
  MachProcess::SetState((uint64_t)this, 8u);
  if (SHIBYTE(v12) < 0) {
    operator delete(*((void **)&v10 + 1));
  }
  return 1;
}

void sub_1000440A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

void sub_1000440BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::ReplyToAllExceptions(MachProcess *this)
{
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 904);
  int v18 = (char *)this + 904;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  uint64_t v3 = *((void *)this + 110);
  uint64_t v4 = *((void *)this + 111);
  if (v3 != v4)
  {
    int v13 = v2;
    uint64_t v5 = 0;
    do
    {
      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("Replying to exception %u...", 625320909 * (v5 >> 3));
      }
      uint64_t ThreadIDByMachPortNumber = MachThreadList::GetThreadIDByMachPortNumber((MachProcess *)((char *)this + 968), *(_DWORD *)(v3 + v5 + 2052));
      if (ThreadIDByMachPortNumber
        && (ActionForThread = DNBThreadResumeActions::GetActionForThread((MachProcess *)((char *)this + 832), ThreadIDByMachPortNumber, 0)) != 0)
      {
        int v8 = *((_DWORD *)ActionForThread + 3);
        if (v8) {
          DNBThreadResumeActions::SetSignalHandledForThread((uint64_t)this + 832, ThreadIDByMachPortNumber);
        }
      }
      else
      {
        int v8 = 0;
      }
      int v14 = MachException::Message::Reply((MachException::Message *)(v3 + v5), this, v8);
      uint64_t v16 = 0;
      long long v15 = 0uLL;
      int v17 = 0;
      if (DNBLogCheckLogBit(8)) {
        DNBError::LogThreadedIfError((DNBError *)&v14, "Error replying to exception");
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(*(void **)((char *)&v15 + 4));
      }
      v5 += 2088;
    }
    while (v3 + v5 != v4);
    uint64_t v9 = *((void *)this + 111);
    uint64_t v10 = *((void *)this + 110);
    while (v9 != v10)
    {
      uint64_t v11 = *(void **)(v9 - 24);
      if (v11)
      {
        *(void *)(v9 - 16) = v11;
        operator delete(v11);
      }
      v9 -= 2088;
    }
    *((void *)this + 111) = v10;
    unsigned int v2 = v13;
  }
  return pthread_mutex_unlock(v2);
}

void sub_100044284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, pthread_mutex_t *a19)
{
}

unint64_t MachProcess::WriteMemory(MachProcess *this, unint64_t a2, unint64_t a3, char *a4)
{
  timeval __p = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t BreakpointsThatOverlapRange = DNBBreakpointList::FindBreakpointsThatOverlapRange((void *)this + 205, a2, a3, (uint64_t)&__p);
  if (!BreakpointsThatOverlapRange)
  {
    unint64_t v10 = MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, a3, a4);
    int v25 = __p;
    if (__p) {
      goto LABEL_29;
    }
    return v10;
  }
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v29 = a3;
  unint64_t v11 = a3 + a2;
  BOOL v30 = (MachProcess *)((char *)this + 104);
  do
  {
    uint64_t v12 = *((void *)__p + v9);
    if ((*(unsigned char *)(v12 + 24) & 5) != 1
      || *(_DWORD *)(v12 + 28) != -1
      || (unint64_t v13 = *(unsigned int *)(v12 + 4), !v13)
      || ((unint64_t v14 = *(void *)(v12 + 16), v15 = v14 + v13, v11 > v14) ? (v16 = v15 > a2) : (v16 = 0), !v16))
    {
      int v27 = 1859;
      uint64_t v28 = "intersects";
      goto LABEL_34;
    }
    if (v11 >= v15) {
      unint64_t v17 = v14 + v13;
    }
    else {
      unint64_t v17 = v11;
    }
    if (v14 <= a2) {
      unint64_t v18 = a2;
    }
    else {
      unint64_t v18 = *(void *)(v12 + 16);
    }
    BOOL v19 = a2 >= v14;
    unint64_t v20 = a2 - v14;
    if (v19) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = 0;
    }
    if (v18 >= v11)
    {
      int v27 = 1860;
      uint64_t v28 = "addr <= intersect_addr && intersect_addr < addr + size";
      goto LABEL_34;
    }
    if (v17 <= a2)
    {
      int v27 = 1862;
      uint64_t v28 = "addr < intersect_addr + intersect_size && intersect_addr + intersect_size <= addr + size";
      goto LABEL_34;
    }
    size_t v22 = v17 - v18;
    if (v21 + v17 - v18 > v13)
    {
      int v27 = 1863;
      uint64_t v28 = "opcode_offset + intersect_size <= bp->ByteSize()";
LABEL_34:
      __assert_rtn("WriteMemory", "MachProcess.mm", v27, v28);
    }
    unint64_t v23 = v18 - (v10 + a2);
    if (v18 > v10 + a2)
    {
      unint64_t v24 = MachTask::WriteMemory(v30, v10 + a2, v18 - (v10 + a2), &a4[v10]);
      v10 += v24;
      if (v24 != v23) {
        break;
      }
    }
    memcpy((void *)(v12 + v21 + 8), &a4[v10], v22);
    v10 += v22;
    ++v9;
  }
  while (BreakpointsThatOverlapRange != v9);
  if (v29 > v10) {
    v10 += MachTask::WriteMemory(v30, v10 + a2, v29 - v10, &a4[v10]);
  }
  int v25 = __p;
  if (__p)
  {
LABEL_29:
    uint64_t v32 = v25;
    operator delete(v25);
  }
  return v10;
}

void sub_1000444BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *MachProcess::CreateBreakpoint(uint64_t **this, unint64_t a2, uint64_t a3, int a4)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::CreateBreakpoint(addr = 0x%8.8llx, length = %llu, hardware = %i)", a2, a3, a4);
  }
  int v8 = DNBBreakpointList::FindByAddress((DNBBreakpointList *)(this + 205), a2);
  if (v8)
  {
    uint64_t v9 = v8;
    ++*(_DWORD *)v8;
  }
  else
  {
    uint64_t v9 = DNBBreakpointList::Add(this + 205, a2, a3, a4);
  }
  if (MachProcess::EnableBreakpoint((MachProcess *)this, a2))
  {
    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::CreateBreakpoint(addr = 0x%8.8llx, length = %llu) => %p", a2, a3, v9);
    }
  }
  else
  {
    if (!*(_DWORD *)v9 || (v10 = *(_DWORD *)v9 - 1, (*(_DWORD *)uint64_t v9 = v10) == 0)) {
      DNBBreakpointList::Remove((DNBBreakpointList *)(this + 205), a2);
    }
    return 0;
  }
  return v9;
}

uint64_t MachProcess::EnableBreakpoint(MachProcess *this, unint64_t a2)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::EnableBreakpoint(addr = 0x%8.8llx)", a2);
  }
  uint64_t result = (uint64_t)DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1640), a2);
  if (result)
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(result + 24))
    {
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): breakpoint already enabled.", a2);
      }
      return 1;
    }
    if ((*(unsigned char *)(result + 24) & 2) != 0)
    {
      int v6 = MachThreadList::EnableHardwareBreakpoint((uint64_t)this + 968, result);
      *(_DWORD *)(v5 + 28) = v6;
      if (v6 != -1)
      {
        *(unsigned char *)(v5 + 24) |= 1u;
        return 1;
      }
    }
    unint64_t v7 = *(unsigned int *)(v5 + 4);
    if (!v7) {
      MachProcess::EnableBreakpoint();
    }
    BreakpointOpcode = (char *)DNBArchProtocol::GetBreakpointOpcode((DNBArchProtocol *)*(unsigned int *)(v5 + 4));
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v7, (char *)(v5 + 8)) != v7)
    {
      uint64_t result = DNBLogEnabled();
      if (!result) {
        return result;
      }
      _DNBLogError("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to read memory at breakpoint address.");
      return 0;
    }
    if (MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, v7, BreakpointOpcode) != v7)
    {
      uint64_t result = DNBLogEnabled();
      if (!result) {
        return result;
      }
      _DNBLogError("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to write breakpoint opcode to memory.");
      return 0;
    }
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v7, __s2) == v7)
    {
      if (!memcmp(BreakpointOpcode, __s2, v7))
      {
        *(unsigned char *)(v5 + 24) |= 1u;
        MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
        if (DNBLogEnabledForAny(512)) {
          _DNBLogThreaded("MachProcess::EnableBreakpoint(addr = 0x%8.8llx) : SUCCESS.", a2);
        }
        return 1;
      }
      if (!DNBLogEnabled()) {
        return 0;
      }
      uint64_t v9 = "MachProcess::EnableBreakpoint(addr = 0x%8.8llx): breakpoint opcode verification failed.";
    }
    else
    {
      if (!DNBLogEnabled()) {
        return 0;
      }
      uint64_t v9 = "MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to read memory to verify breakpoint opcode.";
    }
    _DNBLogError(v9, a2);
    return 0;
  }
  return result;
}

char *MachProcess::CreateWatchpoint(uint64_t **this, unint64_t a2, uint64_t a3, int a4, int a5)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu, flags = 0x%8.8x, hardware = %i)", a2, a3, a4, a5);
  }
  int v10 = (DNBBreakpointList *)(this + 208);
  if (DNBBreakpointList::FindByAddress((DNBBreakpointList *)(this + 208), a2)) {
    return 0;
  }
  unint64_t v11 = DNBBreakpointList::Add(this + 208, a2, a3, a5);
  unsigned char v11[24] = (8 * (a4 & 3)) | v11[24] & 0xE7 | 4;
  int v12 = MachProcess::EnableWatchpoint((MachProcess *)this, a2);
  BOOL v13 = DNBLogEnabledForAny(2048);
  if (!v12)
  {
    if (v13) {
      _DNBLogThreaded("MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu) => FAILED", a2, a3);
    }
    DNBBreakpointList::Remove(v10, a2);
    return 0;
  }
  if (v13) {
    _DNBLogThreaded("MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu) => %p", a2, a3, v11);
  }
  return v11;
}

uint64_t MachProcess::EnableWatchpoint(MachProcess *this, unint64_t a2)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::EnableWatchpoint(addr = 0x%8.8llx)", a2);
  }
  uint64_t result = (uint64_t)DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1664), a2);
  if (result)
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(result + 24))
    {
      uint64_t v7 = *(void *)(result + 16);
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::EnableWatchpoint(addr = 0x%8.8llx): watchpoint already enabled.", v7);
      }
      return 1;
    }
    int v6 = MachThreadList::EnableHardwareWatchpoint((uint64_t)this + 968, result);
    *(_DWORD *)(v5 + 28) = v6;
    if (v6 != -1)
    {
      *(unsigned char *)(v5 + 24) |= 1u;
      return 1;
    }
    return 0;
  }
  return result;
}

BOOL MachProcess::DisableBreakpoint(MachProcess *this, unint64_t a2, int a3)
{
  int v6 = (MachProcess *)((char *)this + 1640);
  uint64_t v7 = DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1640), a2);
  if (!v7)
  {
    BOOL result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) invalid breakpoint address", a2, a3);
    return 0;
  }
  uint64_t v8 = (uint64_t)v7;
  if ((v7[24] & 1) == 0)
  {
    if (a3)
    {
      if (!*(_DWORD *)v7 || (v9 = *(_DWORD *)v7 - 1, (*(_DWORD *)uint64_t v7 = v9) == 0))
      {
        MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
        DNBBreakpointList::Remove(v6, a2);
        return 1;
      }
    }
    return 1;
  }
  if (a3)
  {
    if (*(_DWORD *)v7)
    {
      int v11 = *(_DWORD *)v7 - 1;
      *(_DWORD *)uint64_t v7 = v11;
      if (v11) {
        return 1;
      }
    }
  }
  if (DNBLogEnabledForAny(513)) {
    _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d)", a2, a3);
  }
  if (*(_DWORD *)(v8 + 28) == -1)
  {
    unint64_t v13 = *(unsigned int *)(v8 + 4);
    if (!v13) {
      MachProcess::DisableBreakpoint();
    }
    BreakpointOpcode = (const void *)DNBArchProtocol::GetBreakpointOpcode((DNBArchProtocol *)*(unsigned int *)(v8 + 4));
    ((void (*)(void))__chkstk_darwin)();
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v13, (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0)) != v13)
    {
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::DisableBreakpoint: unable to read memory at 0x%8.8llx", a2);
      }
      return 0;
    }
    char v15 = *(unsigned char *)(v8 + 24);
    uint64_t v20 = (uint64_t)&v20;
    if (v15)
    {
      if (!memcmp((char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0), BreakpointOpcode, v13))
      {
        unint64_t v16 = MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, v13, (char *)(v8 + 8));
        if (v16 != v13)
        {
          if (DNBLogEnabled()) {
            _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) memory write failed when restoring original opcode", a2, a3);
          }
          return 0;
        }
        int v17 = 1;
LABEL_32:
        __chkstk_darwin(v16);
        if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v13, (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0)) == v13)
        {
          if (!memcmp((const void *)(v8 + 8), (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0), v13))
          {
            *(_DWORD *)(v8 + 28) = -1;
            *(unsigned char *)(v8 + 24) &= ~1u;
            if (a3)
            {
              if (!*(_DWORD *)v8 || (v19 = *(_DWORD *)v8 - 1, (*(_DWORD *)uint64_t v8 = v19) == 0))
              {
                MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
                DNBBreakpointList::Remove(v6, a2);
              }
            }
            if (DNBLogEnabledForAny(512)) {
              _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) => success", a2, a3);
            }
            return 1;
          }
          BOOL v18 = DNBLogEnabled();
          if (v17)
          {
            if (v18) {
              _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) : failed to restore original opcode");
            }
          }
          else if (v18)
          {
            _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) : opcode changed");
          }
        }
        else if (DNBLogEnabled())
        {
          _DNBLogWarning("MachProcess::DisableBreakpoint: unable to disable breakpoint 0x%8.8llx", a2);
        }
        return 0;
      }
      unint64_t v16 = DNBLogEnabled();
      if (v16) {
        _DNBLogWarning("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) expected a breakpoint opcode but didn't find one.", a2, a3);
      }
    }
    else
    {
      unint64_t v16 = DNBLogEnabledForAny(513);
      if (v16) {
        _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) is not enabled", a2, a3);
      }
    }
    int v17 = 0;
    goto LABEL_32;
  }
  int v12 = (char *)this + 968;
  BOOL result = MachThreadList::DisableHardwareBreakpoint((uint64_t)v12, v8);
  if (result)
  {
    *(_DWORD *)(v8 + 28) = -1;
    *(unsigned char *)(v8 + 24) &= ~1u;
    if (a3)
    {
      MachThreadList::NotifyBreakpointChanged((uint64_t)v12);
      DNBBreakpointList::Remove(v6, a2);
    }
    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) (hardware) => success", a2, a3);
    }
    return 1;
  }
  return result;
}

BOOL MachProcess::DisableWatchpoint(MachProcess *this, unint64_t a2, int a3)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::%s(addr = 0x%8.8llx, remove = %d)", "DisableWatchpoint", a2, a3);
  }
  int v6 = DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1664), a2);
  if (!v6)
  {
    BOOL result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachProcess::DisableWatchpoint(addr = 0x%8.8llx, remove = %d) invalid watchpoint ID", a2, a3);
    return 0;
  }
  uint64_t v7 = (uint64_t)v6;
  if (!a3 || !*(_DWORD *)v6 || (v8 = *(_DWORD *)v6 - 1, (*(_DWORD *)int v6 = v8) == 0))
  {
    unint64_t v9 = *((void *)v6 + 2);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("MachProcess::DisableWatchpoint(addr = 0x%8.8llx, remove = %d)", v9, a3);
    }
    if (*(_DWORD *)(v7 + 28) != -1)
    {
      BOOL result = MachThreadList::DisableHardwareWatchpoint((uint64_t)this + 968, v7);
      if (!result) {
        return result;
      }
      *(_DWORD *)(v7 + 28) = -1;
      *(unsigned char *)(v7 + 24) &= ~1u;
      if (a3) {
        DNBBreakpointList::Remove((MachProcess *)((char *)this + 1664), v9);
      }
      if (DNBLogEnabledForAny(2048))
      {
        _DNBLogThreaded("MachProcess::Disablewatchpoint(addr = 0x%8.8llx, remove = %d) (hardware) => success", v9, a3);
        return 1;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

uint64_t MachProcess::GetNumSupportedHardwareWatchpoints(MachThread ***this)
{
  return MachThreadList::NumSupportedHardwareWatchpoints(this + 121);
}

uint64_t MachProcess::ExceptionMessageReceived(MachProcess *this, const MachException::Message *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  if (*((void *)this + 110) == *((void *)this + 111)) {
    MachTask::Suspend((MachProcess *)((char *)this + 104));
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachProcess::ExceptionMessageReceived()");
  }
  unint64_t v5 = *((void *)this + 111);
  if (v5 >= *((void *)this + 112))
  {
    int v12 = std::vector<MachException::Message>::__push_back_slow_path<MachException::Message const&>((void **)this + 110, a2);
  }
  else
  {
    memcpy(*((void **)this + 111), a2, 0x800uLL);
    int v6 = *((_DWORD *)a2 + 514);
    *(void *)(v5 + 2048) = *((void *)a2 + 256);
    *(_DWORD *)(v5 + 2056) = v6;
    *(void *)(v5 + 2064) = 0;
    *(void *)(v5 + 2080) = 0;
    *(void *)(v5 + 2072) = 0;
    uint64_t v7 = (unsigned char *)*((void *)a2 + 258);
    int v8 = (unsigned char *)*((void *)a2 + 259);
    int64_t v9 = v8 - v7;
    if (v8 != v7)
    {
      if (v9 < 0) {
        std::vector<kevent>::__throw_length_error[abi:ne180100]();
      }
      int v10 = (char *)operator new(v8 - v7);
      *(void *)(v5 + 2064) = v10;
      *(void *)(v5 + 2072) = v10;
      int v11 = &v10[8 * (v9 >> 3)];
      *(void *)(v5 + 2080) = v11;
      memcpy(v10, v7, v9);
      *(void *)(v5 + 2072) = v11;
    }
    int v12 = (void *)(v5 + 2088);
    *((void *)this + 111) = v5 + 2088;
  }
  *((void *)this + 111) = v12;
  return pthread_mutex_unlock(v4);
}

void sub_100045024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  int v6 = *v4;
  if (*v4)
  {
    *(void *)(v3 + 2072) = v6;
    operator delete(v6);
  }
  *(void *)(v2 + 888) = v3;
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::ExceptionMessageBundleComplete(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 904);
  unint64_t v42 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("%s: %llu exception messages.", "task_t MachProcess::ExceptionMessageBundleComplete()", 0x77A9AF922545A3CDLL * ((uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 3));
  }
  uint64_t v3 = *((void *)this + 110);
  uint64_t v4 = *((void *)this + 111);
  if (v3 == v4)
  {
    if (DNBLogEnabledForAny(8)) {
      _DNBLogThreaded("%s empty exception messages bundle (%llu exceptions).", "task_t MachProcess::ExceptionMessageBundleComplete()", 0x77A9AF922545A3CDLL * ((uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 3));
    }
    uint64_t v20 = *((unsigned int *)this + 30);
    goto LABEL_73;
  }
  *((unsigned char *)this + 1752) = 0;
  int v5 = *((_DWORD *)this + 30);
  if (!*(_DWORD *)this) {
    goto LABEL_59;
  }
  int v6 = 0;
  char v7 = 0;
  uint64_t v8 = (unsigned __int128)((v4 - v3) * (__int128)0x7D8C42B2836ED5D3) >> 64;
  unint64_t v9 = (v8 >> 10) + ((unint64_t)v8 >> 63);
  if (v9 <= 1) {
    unint64_t v9 = 1;
  }
  int v10 = (void *)(v3 + 2072);
  while (*((_DWORD *)v10 - 6) != v5)
  {
LABEL_16:
    v10 += 261;
    if (!--v9) {
      goto LABEL_37;
    }
  }
  ++v6;
  if (*((_DWORD *)v10 - 4) != 5 || (uint64_t v15 = *(v10 - 1), *v10 - v15 != 16) || *(void *)v15 != 65539)
  {
    int v11 = 0;
LABEL_9:
    int v12 = *((_DWORD *)this + 436);
    if (v12) {
      BOOL v13 = v11 == v12;
    }
    else {
      BOOL v13 = 0;
    }
    char v14 = v13;
    v7 |= v14;
    goto LABEL_16;
  }
  int v11 = *(_DWORD *)(v15 + 8);
  if (v11 != 5) {
    goto LABEL_9;
  }
  *(_OWORD *)timeval __p = 0u;
  long long v46 = 0u;
  uint64_t DYLDAllImageInfosAddress = MachTask::GetDYLDAllImageInfosAddress((MachProcess *)((char *)this + 104), (DNBError *)__p);
  if (SHIBYTE(v46) < 0) {
    operator delete(__p[1]);
  }
  if (DYLDAllImageInfosAddress != -1)
  {
    mach_vm_address_t v17 = DYLDAllImageInfosAddress + 4;
    LODWORD(v41.tv_sec) = 0;
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), v17, 4uLL, (char *)&v41) == 4)
    {
      if (!LODWORD(v41.tv_sec))
      {
        *((unsigned char *)this + 1752) = 1;
        *(_OWORD *)timeval __p = 0u;
        long long v46 = 0u;
        int v18 = *((_DWORD *)this + 30);
        unsigned int v19 = MachTask::TaskPortForProcessID((MachProcess *)((char *)this + 104), (DNBError *)__p, 1);
        if (v18 != v19 && DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("exec: task changed from 0x%4.4x to 0x%4.4x", v18, v19);
        }
        if (SHIBYTE(v46) < 0) {
          operator delete(__p[1]);
        }
      }
    }
    else if (DNBLogEnabled())
    {
      _DNBLog(0, (uint64_t)"error: failed to read all_image_infos.infoArrayCount from 0x%8.8llx", v21, v22, v23, v24, v25, v26, v17);
    }
  }
LABEL_37:
  if (*((unsigned char *)this + 1752))
  {
    int v27 = *(_DWORD *)this;
    long long v46 = 0u;
    long long v47 = 0u;
    *(_OWORD *)timeval __p = 0u;
    v41.__darwin_time_t tv_sec = 12;
    if (sysctlnametomib("sysctl.proc_cputype", (int *)__p, (size_t *)&v41))
    {
      uint64_t v28 = 0;
    }
    else
    {
      __darwin_time_t tv_sec = v41.tv_sec;
      *((_DWORD *)__p + v41.tv_sec) = v27;
      v41.__darwin_time_t tv_sec = tv_sec + 1;
      unsigned int v44 = 0;
      size_t v43 = 4;
      if (sysctl((int *)__p, tv_sec + 1, &v44, &v43, 0, 0)) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = (DNBArchProtocol *)v44;
      }
    }
    if (*((_DWORD *)this + 1) != v28)
    {
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"arch changed from 0x%8.8x to 0x%8.8x", v30, v31, v32, v33, v34, v35, *((unsigned int *)this + 1));
      }
      *((_DWORD *)this + 1) = v28;
      DNBArchProtocol::SetArchitecture(v28, 0);
    }
    MachThreadList::Clear((MachProcess *)((char *)this + 968));
    Genealogy::Clear((MachProcess *)((char *)this + 1080));
    DNBBreakpointList::DisableAll((MachProcess *)((char *)this + 1640));
    MachTask::ClearAllocations((MachProcess *)((char *)this + 104));
  }
  if (!*((_DWORD *)this + 436)) {
    goto LABEL_59;
  }
  if ((v7 & 1) == 0)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::ExceptionMessageBundleComplete(): didn't get signal %i after MachProcess::Interrupt()", *((_DWORD *)this + 436));
    }
    goto LABEL_59;
  }
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::ExceptionMessageBundleComplete(): process successfully interrupted with signal %i", *((_DWORD *)this + 436));
  }
  *((_DWORD *)this + 436) = 0;
  if (!*((_DWORD *)this + 437))
  {
LABEL_59:
    BOOL v36 = 0;
    goto LABEL_60;
  }
  BOOL v36 = v6 == 1;
  if (v6 == 1 && DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::ExceptionMessageBundleComplete(): auto resuming due to unhandled interrupt signal %i", *((_DWORD *)this + 437));
  }
  *((_DWORD *)this + 437) = 0;
LABEL_60:
  MachThreadList::ProcessDidStop((MachProcess *)((char *)this + 968), this);
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  uint64_t v37 = *((void *)this + 110);
  if (*((void *)this + 111) != v37)
  {
    unint64_t v38 = 0;
    uint64_t v39 = 2048;
    do
    {
      if (*(_DWORD *)(v37 + v39) == v5) {
        MachThreadList::NotifyException((MachProcess *)((char *)this + 968), (MachException::Data *)(v37 + v39));
      }
      if (DNBLogCheckLogBit(8)) {
        MachException::Message::Dump((MachException::Message *)(*((void *)this + 110) + v39 - 2048));
      }
      ++v38;
      uint64_t v37 = *((void *)this + 110);
      v39 += 2088;
    }
    while (v38 < 0x77A9AF922545A3CDLL * ((*((void *)this + 111) - v37) >> 3));
  }
  if (DNBLogCheckLogBit(4)) {
    MachThreadList::Dump((MachProcess *)((char *)this + 968));
  }
  LOBYTE(v43) = 0;
  if ((v36 | !MachThreadList::ShouldStop((MachProcess *)((char *)this + 968), (BOOL *)&v43)))
  {
    MachProcess::PrivateResume(this);
  }
  else
  {
    gettimeofday((timeval *)__p, 0);
    v41.__darwin_time_t tv_sec = (__darwin_time_t)__p[0] + SLODWORD(__p[1]) / 1000000 + 1;
    v41.tv_nsec = 1000 * LODWORD(__p[1]) % 1000000000;
    PThreadEvent::WaitForEventsToReset((pthread_mutex_t *)((char *)this + 1288), 1u, &v41);
    MachProcess::SetState((uint64_t)this, 4u);
  }
  uint64_t v2 = v42;
  uint64_t v20 = *((unsigned int *)this + 30);
  if (v42) {
LABEL_73:
  }
    pthread_mutex_unlock(v2);
  return v20;
}

void sub_1000455F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, pthread_mutex_t *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  PThreadMutex::Locker::~Locker(&a14);
  _Unwind_Resume(a1);
}

void MachProcess::SetExitInfo(MachProcess *this, const char *a2)
{
  if (a2 && *a2)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s(\"%s\")", "SetExitInfo", a2);
    }
    std::string::assign((std::string *)((char *)this + 80), a2);
  }
  else
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s(NULL)", "SetExitInfo");
    }
    if (*((char *)this + 103) < 0)
    {
      **((unsigned char **)this + 10) = 0;
      *((void *)this + 11) = 0;
    }
    else
    {
      *((unsigned char *)this + 80) = 0;
      *((unsigned char *)this + 103) = 0;
    }
  }
}

uint64_t MachProcess::AppendSTDOUT(MachProcess *this, char *a2, std::string::size_type a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (<%llu> %s) ...", "AppendSTDOUT", a3, a2);
  }
  int v6 = (pthread_mutex_t *)((char *)this + 456);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  std::string::append((std::string *)((char *)this + 520), a2, a3);
  char v7 = (pthread_mutex_t *)((char *)this + 1288);
  PThreadEvent::SetEvents(v7, 8);
  PThreadEvent::WaitForResetAck((PThreadEvent *)v7, 8, 0);
  return pthread_mutex_unlock(v6);
}

void sub_1000457CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

size_t MachProcess::GetAvailableSTDOUT(MachProcess *this, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (&%p[%llu]) ...", "GetAvailableSTDOUT", a2, a3);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  if ((*((char *)this + 543) & 0x80000000) == 0)
  {
    size_t v6 = *((unsigned __int8 *)this + 543);
    if (*((unsigned char *)this + 543)) {
      goto LABEL_5;
    }
LABEL_10:
    a3 = 0;
    goto LABEL_17;
  }
  size_t v6 = *((void *)this + 66);
  if (!v6) {
    goto LABEL_10;
  }
LABEL_5:
  char v7 = (char *)this + 520;
  if (v6 <= a3)
  {
    if ((*((unsigned char *)this + 543) & 0x80) != 0) {
      char v7 = *(char **)v7;
    }
    memcpy(a2, v7, v6);
    if (*((char *)this + 543) < 0)
    {
      **((unsigned char **)this + 65) = 0;
      *((void *)this + 66) = 0;
    }
    else
    {
      *((unsigned char *)this + 520) = 0;
      *((unsigned char *)this + 543) = 0;
    }
    a3 = v6;
  }
  else
  {
    uint64_t v8 = (char *)this + 520;
    if ((*((unsigned char *)this + 543) & 0x80) != 0) {
      uint64_t v8 = *(char **)v7;
    }
    memcpy(a2, v8, a3);
    std::string::erase((std::string *)((char *)this + 520), 0, a3);
  }
LABEL_17:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  return a3;
}

void sub_1000458FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

void MachProcess::GetDyldProcessState(MachProcess *this)
{
}

void sub_10004603C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v21 - 80);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::GetAvailableSTDERR(MachProcess *this, char *a2)
{
  return 0;
}

pthread_mutex_t *MachProcess::SignalAsyncProfileData(MachProcess *this, const char *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (%s) ...", "SignalAsyncProfileData", a2);
  }
  mach_vm_address_t v17 = (pthread_mutex_t *)((char *)this + 568);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 568));
  size_t v4 = strlen(a2);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = v5;
    unint64_t v16 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v16) = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_10:
  }
    memcpy(p_dst, a2, v5);
  *((unsigned char *)p_dst + v5) = 0;
  unint64_t v9 = *((void *)this + 80);
  if (v9 >= *((void *)this + 81))
  {
    int v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 79, (uint64_t)&__dst);
    int v12 = SHIBYTE(v16);
    *((void *)this + 80) = v11;
    if (v12 < 0) {
      operator delete((void *)__dst);
    }
  }
  else
  {
    long long v10 = __dst;
    *(void *)(v9 + 16) = v16;
    *(_OWORD *)unint64_t v9 = v10;
    *((void *)this + 80) = v9 + 24;
  }
  BOOL v13 = (pthread_mutex_t *)((char *)this + 1288);
  PThreadEvent::SetEvents(v13, 16);
  PThreadEvent::WaitForResetAck((PThreadEvent *)v13, 16, 0);
  BOOL result = v17;
  if (v17) {
    return (pthread_mutex_t *)pthread_mutex_unlock(v17);
  }
  return result;
}

void sub_1000463D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, pthread_mutex_t *a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  PThreadMutex::Locker::~Locker(&a17);
  _Unwind_Resume(a1);
}

size_t MachProcess::GetAsyncProfileData(MachProcess *this, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (&%p[%llu]) ...", "GetAsyncProfileData", a2, a3);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 568));
  size_t v6 = (unsigned char *)*((void *)this + 79);
  if (v6 == *((unsigned char **)this + 80)) {
    goto LABEL_11;
  }
  if (((char)v6[23] & 0x80000000) == 0)
  {
    size_t v7 = v6[23];
    if (v6[23]) {
      goto LABEL_6;
    }
LABEL_11:
    a3 = 0;
    goto LABEL_25;
  }
  size_t v7 = *((void *)v6 + 1);
  if (!v7) {
    goto LABEL_11;
  }
LABEL_6:
  if (v7 <= a3)
  {
    if ((v6[23] & 0x80) != 0) {
      size_t v6 = *(unsigned char **)v6;
    }
    memcpy(a2, v6, v7);
    uint64_t v8 = *((void *)this + 79);
    uint64_t v9 = v8 + 24;
    long long v10 = (char *)*((void *)this + 80);
    if ((char *)(v8 + 24) != v10)
    {
      int v11 = (char *)(v8 + 23);
      do
      {
        int v12 = (void **)(v11 - 23);
        if (*v11 < 0) {
          operator delete(*v12);
        }
        *(_OWORD *)int v12 = *(_OWORD *)(v11 + 1);
        *(void *)(v11 - 7) = *(void *)(v11 + 17);
        unsigned char v11[24] = 0;
        v11 += 24;
        *(v11 - 23) = 0;
        v8 += 24;
      }
      while (v11 + 1 != v10);
      uint64_t v9 = *((void *)this + 80);
    }
    while (v9 != v8)
    {
      if (*(char *)(v9 - 1) < 0) {
        operator delete(*(void **)(v9 - 24));
      }
      v9 -= 24;
    }
    *((void *)this + 80) = v8;
    a3 = v7;
  }
  else
  {
    if ((v6[23] & 0x80) != 0) {
      size_t v6 = *(unsigned char **)v6;
    }
    memcpy(a2, v6, a3);
    std::string::erase(*((std::string **)this + 79), 0, a3);
  }
LABEL_25:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 568));
  return a3;
}

void sub_100046598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::AttachForDebug(MachProcess *a1, uint64_t a2, int8x16_t **a3, char *a4, size_t a5)
{
  MachProcess::Clear(a1, 0);
  if (!a2) {
    return 0;
  }
  *(_OWORD *)timeval __p = 0u;
  long long v48 = 0u;
  if (getpgid(a2) < 0)
  {
    LODWORD(__p[0]) = *__error();
    HIDWORD(__p[0]) = 2;
    if (SHIBYTE(v48) < 0)
    {
      *(unsigned char *)__p[1] = 0;
      *(void *)&long long v48 = 0;
    }
    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v48) = 0;
    }
    uint64_t v30 = DNBError::AsString((DNBError *)__p);
    uint64_t v31 = "No such process";
    if (v30) {
      uint64_t v31 = (const char *)v30;
    }
    snprintf(a4, a5, "%s", v31);
    if (DNBLogEnabled()) {
      _DNBLogError("MachProcess::AttachForDebug pid %d does not exist", a2);
    }
    a2 = 0;
    char v29 = 0;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  MachProcess::SetState((uint64_t)a1, 2u);
  *(_DWORD *)a1 = a2;
  if (!MachTask::StartExceptionThread((uint64_t)a1 + 104, a3, (uint64_t)__p))
  {
    uint64_t v26 = DNBError::AsString((DNBError *)__p);
    int v27 = "unable to start the exception thread";
    if (v26) {
      int v27 = (const char *)v26;
    }
    snprintf(a4, a5, "%s", v27);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("error: failed to attach to pid %d", a2);
    }
    if (DNBLogEnabled())
    {
      pid_t v28 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) MachProcess::AttachForDebug failed to start exception thread attaching to pid %i: %s", v28, a2, a4);
    }
    a2 = 0;
    char v29 = 0;
    *(_DWORD *)a1 = 0;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (DNBLogEnabled())
  {
    uint64_t v10 = getpid();
    _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...", v11, v12, v13, v14, v15, v16, v10);
  }
  *__error() = 0;
  int v17 = ptrace(14, a2, 0, 0);
  unsigned int v18 = *__error();
  if (DNBLogEnabled())
  {
    uint64_t v19 = getpid();
    _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d", v20, v21, v22, v23, v24, v25, v19);
  }
  if (!v17)
  {
    __p[0] = 0;
    if (SHIBYTE(v48) < 0)
    {
      *(unsigned char *)__p[1] = 0;
      *(void *)&long long v48 = 0;
      if (LODWORD(__p[0])) {
        goto LABEL_34;
      }
    }
    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v48) = 0;
    }
LABEL_44:
    *((_DWORD *)a1 + 110) |= 1u;
    usleep(0x3D090u);
    if (DNBLogEnabled())
    {
      uint64_t v37 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) Done napping after ptrace(PT_ATTACHEXC)'ing", v38, v39, v40, v41, v42, v43, v37);
    }
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("successfully attached to pid %d", a2);
    }
    char v29 = 0;
    a2 = *(unsigned int *)a1;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  __p[0] = (void *)(v18 | 0x100000000);
  if (SHIBYTE(v48) < 0)
  {
    *(unsigned char *)__p[1] = 0;
    *(void *)&long long v48 = 0;
  }
  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v48) = 0;
  }
  if (DNBLogEnabled())
  {
    uint64_t v32 = (const char *)DNBError::AsString((DNBError *)__p);
    _DNBLogError("MachProcess::AttachForDebug failed to ptrace(PT_ATTACHEXC) pid %i: %s", a2, v32);
  }
  if (!LODWORD(__p[0])) {
    goto LABEL_44;
  }
LABEL_34:
  uint64_t v33 = (const char *)DNBError::AsString((DNBError *)__p);
  snprintf(a4, a5, "%s", v33);
  if (DNBLogEnabled())
  {
    pid_t v34 = getpid();
    _DNBLogError("[LaunchAttach] (%d) MachProcess::AttachForDebug error: failed to attach to pid %d", v34, a2);
  }
  *(void *)uint64_t v50 = 0xE00000001;
  int v51 = 1;
  int v52 = a2;
  size_t v49 = 648;
  if (!sysctl(v50, 4u, buffer, &v49, 0, 0) && (v55 & 8) != 0)
  {
    if (proc_pidinfo(a2, 13, 0, buffer, 64) == 64) {
      int v35 = v54;
    }
    else {
      int v35 = 0;
    }
    if (v35 == getpid())
    {
      BOOL v36 = (const char *)DNBError::AsString((DNBError *)__p);
      snprintf(a4, a5, "%s - Failed to attach to pid %d, AttachForDebug() unable to ptrace(PT_ATTACHEXC)", v36, *(_DWORD *)a1);
    }
    else
    {
      unsigned int v44 = (const char *)DNBError::AsString((DNBError *)__p);
      snprintf(a4, a5, "%s - process %d is already being debugged by pid %d", v44, a2, v35);
      if (DNBLogEnabled())
      {
        pid_t v45 = getpid();
        _DNBLogError("[LaunchAttach] (%d) MachProcess::AttachForDebug pid %d is already being debugged by pid %d", v45, a2, v35);
      }
    }
  }
  char v29 = 1;
  if (SHIBYTE(v48) < 0) {
LABEL_53:
  }
    operator delete(__p[1]);
LABEL_54:
  if (v29) {
    return 0;
  }
  return a2;
}

void sub_100046A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::ProcessIsBeingDebugged(MachProcess *this)
{
  *(void *)uint64_t v3 = 0xE00000001;
  int v4 = 1;
  int v5 = (int)this;
  size_t v2 = 648;
  return !sysctl(v3, 4u, v6, &v2, 0, 0) && (v6[33] & 8) != 0;
}

uint64_t MachProcess::GetParentProcessID(MachProcess *this)
{
  if (proc_pidinfo((int)this, 13, 0, buffer, 64) == 64) {
    return v3;
  }
  else {
    return 0;
  }
}

void MachProcess::GetGenealogyInfoForThread(MachProcess *this@<X0>, BOOL *a2@<X2>, unint64_t a3@<X1>, void *a4@<X8>)
{
}

uint64_t MachProcess::GetGenealogyImageInfo@<X0>(MachProcess *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return Genealogy::GetProcessExecutableInfosAtIndex((uint64_t)this + 1080, a2, a3);
}

uint64_t MachProcess::GetOSVersionNumbers(MachProcess *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  id v7 = objc_alloc_init((Class)NSAutoreleasePool);
  uint64_t v8 = +[NSProcessInfo processInfo];
  if (v8)
  {
    [(NSProcessInfo *)v8 operatingSystemVersion];
    if (!this) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (this) {
LABEL_3:
  }
    *(void *)this = 0;
LABEL_4:
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  [v7 drain];
  return 1;
}

const __CFString *MachProcess::PrepareForAttach(const char *a1, int a2, int a3, uint64_t a4)
{
  if (!a3) {
    return 0;
  }
  size_t v7 = strlen(a1);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v11 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v11 = v7 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v9 = (void **)operator new(v11 + 1);
    __dst[1] = v8;
    unint64_t v54 = v12 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v54) = v7;
  uint64_t v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memcpy(v9, a1, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  GetAppBundle(__dst, v55);
  if (SHIBYTE(v54) < 0) {
    operator delete(__dst[0]);
  }
  unint64_t v13 = v56;
  if ((v56 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)v55[1];
  }
  if (!v13)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::PrepareForAttach(): path '%s' doesn't contain .app, we can't tell springboard to wait for launch...", a1);
    }
LABEL_43:
    CFStringRef v10 = 0;
    if ((char)v56 < 0) {
      goto LABEL_57;
    }
    return v10;
  }
  if (a2 != 5 && a2) {
    goto LABEL_43;
  }
  if ((v56 & 0x80u) == 0) {
    uint64_t v14 = (const char *)v55;
  }
  else {
    uint64_t v14 = (const char *)v55[0];
  }
  CFStringRef v10 = CopyBundleIDForPath(v14, (DNBError *)a4);
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  CFString::UTF8(v10, (uint64_t)v51);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v15 = (const char *)v55;
    if ((v56 & 0x80u) != 0) {
      uint64_t v15 = (const char *)v55[0];
    }
    uint64_t v16 = (const char *)v51;
    if (v52 < 0) {
      uint64_t v16 = (const char *)v51[0];
    }
    _DNBLogThreaded("CopyBundleIDForPath (%s, err_str) returned @\"%s\"", v15, v16);
  }
  if (v10)
  {
    id v17 = objc_alloc_init((Class)NSAutoreleasePool);
    unsigned int v18 = [+[NSFileManager defaultManager] stringWithFileSystemRepresentation:"/dev/null" length:9];
    id v19 = +[NSMutableDictionary dictionary];
    id v20 = +[NSMutableDictionary dictionary];
    if (DNBLogEnabledForAny(2))
    {
      uint64_t v21 = (const char *)v51;
      if (v52 < 0) {
        uint64_t v21 = (const char *)v51[0];
      }
      _DNBLogThreaded("Calling BKSSystemService openApplication: @\"%s\",options include stdio path: \"%s\", BKSDebugOptionKeyDebugOnNextLaunch & BKSDebugOptionKeyWaitForDebugger)", v21, "/dev/null");
    }
    [v19 setObject:v18 forKey:FBSDebugOptionKeyStandardOutPath];
    [v19 setObject:v18 forKey:FBSDebugOptionKeyStandardErrorPath];
    uint64_t v22 = +[NSNumber numberWithBool:1];
    [v19 setObject:v22 forKey:FBSDebugOptionKeyWaitForDebugger];
    uint64_t v23 = +[NSNumber numberWithBool:1];
    [v19 setObject:v23 forKey:FBSDebugOptionKeyDebugOnNextLaunch];
    [v20 setObject:v19 forKey:FBSOpenApplicationOptionKeyDebuggingOptions];
    id v24 = objc_alloc_init((Class)FBSSystemService);
    id v25 = [v24 createClientPort];
    uint64_t v45 = 0;
    long long v46 = &v45;
    uint64_t v47 = 0x3052000000;
    long long v48 = __Block_byref_object_copy__0;
    size_t v49 = __Block_byref_object_dispose__0;
    dispatch_semaphore_t v50 = 0;
    dispatch_semaphore_t v50 = dispatch_semaphore_create(0);
    uint64_t v41 = 0;
    uint64_t v42 = &v41;
    uint64_t v43 = 0x2020000000;
    uint64_t v44 = 0;
    if (DNBLogEnabled())
    {
      uint64_t v26 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] START (%d) requesting FBS launch of app with bundle ID '%s'", v27, v28, v29, v30, v31, v32, v26);
    }
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 3254779904;
    v40[2] = ___ZN11MachProcess16PrepareForAttachEPKc19nub_launch_flavor_tbR8DNBError_block_invoke;
    v40[3] = &__block_descriptor_56_e8_32o40r48r_e17_v16__0__NSError_8l;
    v40[4] = v24;
    v40[5] = &v41;
    v40[6] = &v45;
    [v24 openApplication:v10 options:v20 clientPort:v25 withResult:v40];
    dispatch_time_t v33 = dispatch_time(0, 9000000000);
    if (dispatch_semaphore_wait((dispatch_semaphore_t)v46[5], v33))
    {
      if (DNBLogEnabled())
      {
        pid_t v34 = (const char *)v51;
        if (v52 < 0) {
          pid_t v34 = (const char *)v51[0];
        }
        _DNBLogError("timed out trying to launch %s.", v34);
      }
      std::string::assign((std::string *)(a4 + 8), "debugserver timed out waiting for openApplication to complete.");
      *(void *)a4 = 111;
      if (*(char *)(a4 + 31) < 0)
      {
        **(unsigned char **)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0;
      }
      else
      {
        *(unsigned char *)(a4 + 8) = 0;
        *(unsigned char *)(a4 + 31) = 0;
      }
    }
    else
    {
      uint64_t v35 = v42[3];
      if (v35)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v39 = 0;
        SetFBSError(v35, (uint64_t)__p, a4);
        if (SHIBYTE(v39) < 0) {
          operator delete(__p[0]);
        }
        if (DNBLogEnabled())
        {
          BOOL v36 = (const char *)v51;
          if (v52 < 0) {
            BOOL v36 = (const char *)v51[0];
          }
          _DNBLogError("unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld", v36, v42[3]);
        }
      }
    }
    dispatch_release((dispatch_object_t)v46[5]);
    [v17 drain];
    _Block_object_dispose(&v41, 8);
    _Block_object_dispose(&v45, 8);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("Successfully set DebugOnNextLaunch.");
    }
  }
  if (SHIBYTE(v52) < 0)
  {
    operator delete(v51[0]);
    if (((char)v56 & 0x80000000) == 0) {
      return v10;
    }
    goto LABEL_57;
  }
  if ((char)v56 < 0) {
LABEL_57:
  }
    operator delete(v55[0]);
  return v10;
}

void sub_10004717C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  if (*(char *)(v29 - 113) < 0) {
    operator delete(*(void **)(v29 - 136));
  }
  if (*(char *)(v29 - 65) < 0) {
    operator delete(*(void **)(v29 - 88));
  }
  _Unwind_Resume(a1);
}

void GetAppBundle(void **__src@<X0>, void *a2@<X8>)
{
  size_t v2 = __src;
  int v4 = *((char *)__src + 23);
  unint64_t v5 = *((unsigned __int8 *)__src + 23);
  if (v4 < 0)
  {
    size_t v6 = (char *)*__src;
    size_t v7 = (char *)__src[1];
    if (!v7) {
      goto LABEL_69;
    }
  }
  else
  {
    size_t v6 = (char *)__src;
    size_t v7 = (char *)*((unsigned __int8 *)__src + 23);
    if (!*((unsigned char *)__src + 23)) {
      goto LABEL_69;
    }
  }
  uint64_t v8 = &v7[(void)v6];
  uint64_t v9 = v6;
  CFStringRef v10 = &v7[(void)v6];
  while (2)
  {
    for (uint64_t i = v9 + 3; ; ++i)
    {
      uint64_t v9 = i - 2;
      if (*(i - 3) != 46)
      {
        if (v9 == v8) {
          goto LABEL_18;
        }
        continue;
      }
      if (v9 == v8) {
        goto LABEL_18;
      }
      if (*v9 == 97)
      {
        if (i - 1 == v8) {
          goto LABEL_18;
        }
        if (*(i - 1) == 112) {
          break;
        }
      }
    }
    if (i != v8)
    {
      if (*i == 112) {
        CFStringRef v10 = i - 3;
      }
      continue;
    }
    break;
  }
LABEL_18:
  if (v10 == v8) {
    goto LABEL_69;
  }
  size_t v12 = v10 - v6;
  if (v12 == -1) {
    goto LABEL_69;
  }
  if (v4 < 0)
  {
    if ((unsigned char *)v12 != (char *)__src[1] - 4) {
      goto LABEL_32;
    }
    size_t v2 = (void **)*__src;
    unint64_t v5 = (unint64_t)__src[1];
LABEL_25:
    if (v5 >= v12 + 4) {
      size_t v13 = v12 + 4;
    }
    else {
      size_t v13 = v5;
    }
    if (v13 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_81;
    }
    goto LABEL_29;
  }
  if (v12 == v5 - 4) {
    goto LABEL_25;
  }
  while (1)
  {
LABEL_32:
    uint64_t v14 = v2;
    if ((v5 & 0x80) != 0) {
      uint64_t v14 = (void **)*v2;
    }
    if (*((unsigned char *)v14 + v12 + 4) == 47) {
      break;
    }
    uint64_t v15 = v2;
    if ((char)v5 < 0)
    {
      uint64_t v15 = (void **)*v2;
      unint64_t v5 = (unint64_t)v2[1];
    }
    if (v5 >= v12) {
      size_t v16 = v12;
    }
    else {
      size_t v16 = v5;
    }
    if (v16 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v16 >= 0x17)
    {
      uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v18 = v16 | 7;
      }
      uint64_t v19 = v18 + 1;
      p_dst = (long long *)operator new(v18 + 1);
      *((void *)&__dst + 1) = v16;
      unint64_t v31 = v19 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v31) = v16;
      p_dst = &__dst;
      if (!v16) {
        goto LABEL_48;
      }
    }
    memmove(p_dst, v15, v16);
LABEL_48:
    *((unsigned char *)p_dst + v16) = 0;
    if (*((char *)v2 + 23) < 0) {
      operator delete(*v2);
    }
    *(_OWORD *)size_t v2 = __dst;
    v2[2] = (void *)v31;
    unint64_t v5 = *((unsigned __int8 *)v2 + 23);
    if (*((char *)v2 + 23) < 0)
    {
      id v20 = (char *)*v2;
      uint64_t v21 = (char *)v2[1];
      if (!v21) {
        goto LABEL_69;
      }
    }
    else
    {
      id v20 = (char *)v2;
      uint64_t v21 = (char *)*((unsigned __int8 *)v2 + 23);
      if (!*((unsigned char *)v2 + 23)) {
        goto LABEL_69;
      }
    }
    uint64_t v22 = &v21[(void)v20];
    uint64_t v23 = v20;
    id v24 = &v21[(void)v20];
    while (2)
    {
      for (j = v23 + 3; ; ++j)
      {
        uint64_t v23 = j - 2;
        if (*(j - 3) != 46)
        {
          if (v23 == v22) {
            goto LABEL_67;
          }
          continue;
        }
        if (v23 == v22) {
          goto LABEL_67;
        }
        if (*v23 == 97)
        {
          if (j - 1 == v22) {
            goto LABEL_67;
          }
          if (*(j - 1) == 112) {
            break;
          }
        }
      }
      if (j != v22)
      {
        if (*j == 112) {
          id v24 = j - 3;
        }
        continue;
      }
      break;
    }
LABEL_67:
    if (v24 != v22)
    {
      size_t v12 = v24 - v20;
      if (v12 != -1) {
        continue;
      }
    }
LABEL_69:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  if ((char)v5 < 0)
  {
    uint64_t v29 = v2;
    size_t v2 = (void **)*v2;
    unint64_t v5 = (unint64_t)v29[1];
  }
  if (v5 >= v12 + 4) {
    size_t v13 = v12 + 4;
  }
  else {
    size_t v13 = v5;
  }
  if (v13 > 0x7FFFFFFFFFFFFFF7) {
LABEL_81:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_29:
  if (v13 >= 0x17)
  {
    uint64_t v26 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v26 = v13 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v28 = operator new(v26 + 1);
    a2[1] = v13;
    a2[2] = v27 | 0x8000000000000000;
    *a2 = v28;
    a2 = v28;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v13;
    if (!v13) {
      goto LABEL_74;
    }
  }
  memmove(a2, v2, v13);
LABEL_74:
  *((unsigned char *)a2 + v13) = 0;
}

CFStringRef CopyBundleIDForPath(const char *a1, DNBError *a2)
{
  CFBundle::CFBundle((CFBundle *)v11, a1);
  CFStringRef Identifier = (const __CFString *)CFBundle::GetIdentifier((CFBundle *)v11);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  if (CFString::UTF8(Identifier, (uint64_t)__p))
  {
    if (DNBLogEnabledForAny(2))
    {
      unint64_t v5 = __p;
      if (v10 < 0) {
        unint64_t v5 = (void **)__p[0];
      }
      _DNBLogThreaded("%s() extracted CFBundleIdentifier: %s", "CopyBundleIDForPath", (const char *)v5);
    }
    CFRetain(Identifier);
    if ((SHIBYTE(v10) & 0x80000000) == 0) {
      goto LABEL_7;
    }
LABEL_30:
    operator delete(__p[0]);
    goto LABEL_7;
  }
  if (stat(a1, &v8) < 0)
  {
    *(_DWORD *)a2 = *__error();
    *((_DWORD *)a2 + 1) = 2;
    if (*((char *)a2 + 31) < 0)
    {
      **((unsigned char **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
    }
    else
    {
      *((unsigned char *)a2 + 8) = 0;
      *((unsigned char *)a2 + 31) = 0;
    }
    size_t v7 = (const char *)DNBError::AsString(a2);
    snprintf(__str, 0x400uLL, "%s: \"%s\"", v7, a1);
    if (__str[0])
    {
      std::string::assign((std::string *)((char *)a2 + 8), __str);
    }
    else if (*((char *)a2 + 31) < 0)
    {
      **((unsigned char **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
    }
    else
    {
      *((unsigned char *)a2 + 8) = 0;
      *((unsigned char *)a2 + 31) = 0;
    }
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s() error: %s", "CopyBundleIDForPath", __str);
    }
  }
  else
  {
    *(void *)a2 = 0xFFFFFFFFLL;
    if (*((char *)a2 + 31) < 0)
    {
      **((unsigned char **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
    }
    else
    {
      *((unsigned char *)a2 + 8) = 0;
      *((unsigned char *)a2 + 31) = 0;
    }
    snprintf(__str, 0x400uLL, "failed to extract CFBundleIdentifier from %s", a1);
    if (__str[0])
    {
      std::string::assign((std::string *)((char *)a2 + 8), __str);
    }
    else if (*((char *)a2 + 31) < 0)
    {
      **((unsigned char **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
    }
    else
    {
      *((unsigned char *)a2 + 8) = 0;
      *((unsigned char *)a2 + 31) = 0;
    }
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s() error: failed to extract CFBundleIdentifier from '%s'", "CopyBundleIDForPath", a1);
    }
  }
  CFStringRef Identifier = 0;
  if (SHIBYTE(v10) < 0) {
    goto LABEL_30;
  }
LABEL_7:
  CFBundle::~CFBundle((CFBundle *)v11);
  return Identifier;
}

void sub_1000477B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

intptr_t ___ZN11MachProcess16PrepareForAttachEPKc19nub_launch_flavor_tbR8DNBError_block_invoke(uint64_t a1, void *a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [a2 code];
  }

  unsigned int v3 = *(NSObject **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);

  return dispatch_semaphore_signal(v3);
}

void __copy_helper_block_e8_32o40r48r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 3);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 8);
  int v4 = *(const void **)(a2 + 48);

  _Block_object_assign((void *)(a1 + 48), v4, 8);
}

void __destroy_helper_block_e8_32o40r48r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 48), 8);
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  size_t v2 = *(const void **)(a1 + 32);

  _Block_object_dispose(v2, 3);
}

void SetFBSError(int a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 5;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
  }
  unint64_t v5 = (void *)FBSOpenApplicationErrorCodeToString();
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 17;
  strcpy((char *)&__s, "unknown FBS error");
  if (*(char *)(a2 + 23) < 0)
  {
    if (*(void *)(a2 + 8)) {
      goto LABEL_6;
    }
  }
  else if (*(unsigned char *)(a2 + 23))
  {
LABEL_6:
    std::string::operator=(&__s, (const std::string *)a2);
    goto LABEL_10;
  }
  if (v5) {
    std::string::assign(&__s, (const std::string::value_type *)[v5 UTF8String]);
  }
LABEL_10:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    if (!__s.__r_.__value_.__r.__words[0]) {
      goto LABEL_15;
    }
  }
  else
  {
    p_s = &__s;
  }
  if (p_s->__r_.__value_.__s.__data_[0])
  {
    std::string::assign((std::string *)(a3 + 8), (const std::string::value_type *)p_s);
    goto LABEL_17;
  }
LABEL_15:
  if ((*(char *)(a3 + 31) & 0x80000000) == 0)
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
LABEL_17:
    if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_18;
  }
  **(unsigned char **)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
LABEL_18:
  }
    operator delete(__s.__r_.__value_.__l.__data_);
}

void sub_100047A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void SetBKSError(int a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 4;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
  }
  unint64_t v5 = (void *)BKSOpenApplicationErrorCodeToString();
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 17;
  strcpy((char *)&__s, "unknown BKS error");
  if (*(char *)(a2 + 23) < 0)
  {
    if (*(void *)(a2 + 8)) {
      goto LABEL_6;
    }
  }
  else if (*(unsigned char *)(a2 + 23))
  {
LABEL_6:
    std::string::operator=(&__s, (const std::string *)a2);
    goto LABEL_10;
  }
  if (v5) {
    std::string::assign(&__s, (const std::string::value_type *)[v5 UTF8String]);
  }
LABEL_10:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    if (!__s.__r_.__value_.__r.__words[0]) {
      goto LABEL_15;
    }
  }
  else
  {
    p_s = &__s;
  }
  if (p_s->__r_.__value_.__s.__data_[0])
  {
    std::string::assign((std::string *)(a3 + 8), (const std::string::value_type *)p_s);
    goto LABEL_17;
  }
LABEL_15:
  if ((*(char *)(a3 + 31) & 0x80000000) == 0)
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
LABEL_17:
    if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_18;
  }
  **(unsigned char **)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
LABEL_18:
  }
    operator delete(__s.__r_.__value_.__l.__data_);
}

void sub_100047B60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id MachProcess::CheckForProcess(uint64_t a1, int a2)
{
  if (!a1) {
    return 0;
  }
  if (a2 == 5)
  {
    unsigned int v3 = (Class *)FBSSystemService_ptr;
    goto LABEL_7;
  }
  if (a2 != 4) {
    return 0;
  }
  unsigned int v3 = (Class *)BKSSystemService_ptr;
LABEL_7:
  id v5 = objc_alloc_init(*v3);
  id v6 = [v5 pidForApplication:a1];

  return v6;
}

void MachProcess::CleanupAfterAttach(MachProcess *this, int a2, DNBError *a3, DNBError *a4)
{
  if (this)
  {
    if (a2 == 4)
    {
      if ((a3 & 1) == 0) {
        MachProcess::BKSCleanupAfterAttach(this, a4, a3);
      }
    }
    else
    {
      if (a2 != 5) {
        return;
      }
      if ((a3 & 1) == 0) {
        MachProcess::FBSCleanupAfterAttach(this, a4, a3);
      }
    }
    CFRelease(this);
  }
}

id MachProcess::FBSCleanupAfterAttach(MachProcess *this, DNBError *a2, DNBError *a3)
{
  id v5 = objc_alloc_init((Class)NSAutoreleasePool);
  id v6 = +[NSMutableDictionary dictionary];
  size_t v7 = +[NSNumber numberWithBool:1];
  [v6 setObject:v7 forKey:FBSDebugOptionKeyCancelDebugOnNextLaunch];
  id v8 = +[NSMutableDictionary dictionary];
  [v8 setObject:v6 forKey:FBSOpenApplicationOptionKeyDebuggingOptions];
  if ((CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>(this, v8, (uint64_t)a2, 0) & 1) == 0&& DNBLogEnabled())
  {
    uint64_t v9 = (const char *)[(MachProcess *)this UTF8String];
    uint64_t v10 = (const char *)DNBError::AsString(a2);
    _DNBLogError("error trying to cancel debug on next launch for %s: %s", v9, v10);
  }

  return [v5 drain];
}

id MachProcess::BKSCleanupAfterAttach(MachProcess *this, DNBError *a2, DNBError *a3)
{
  id v5 = objc_alloc_init((Class)NSAutoreleasePool);
  id v6 = +[NSMutableDictionary dictionary];
  size_t v7 = +[NSNumber numberWithBool:1];
  [v6 setObject:v7 forKey:BKSDebugOptionKeyCancelDebugOnNextLaunch];
  id v8 = +[NSMutableDictionary dictionary];
  [v8 setObject:v6 forKey:BKSOpenApplicationOptionKeyDebuggingOptions];
  if ((CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>(this, v8, (uint64_t)a2, 0) & 1) == 0&& DNBLogEnabled())
  {
    uint64_t v9 = (const char *)[(MachProcess *)this UTF8String];
    uint64_t v10 = (const char *)DNBError::AsString(a2);
    _DNBLogError("error trying to cancel debug on next launch for %s: %s", v9, v10);
  }

  return [v5 drain];
}

const char **MachProcess::LaunchForDebug(unsigned int *a1, char *a2, void *a3, const char **a4, const char **a5, char *a6, char *a7, char *a8, char a9, unsigned int a10, int a11, char *a12, int8x16_t **a13, uint64_t a14)
{
  MachProcess::Clear((MachProcess *)a1, 0);
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s( path = '%s', argv = %p, envp = %p, launch_flavor = %u, disable_aslr = %d)", "LaunchForDebug", a2, a3, a4, a10, a11);
  }
  uint64_t v22 = (DNBArchProtocol *)MachProcess::SetState((uint64_t)a1, 3u);
  switch(a10)
  {
    case 1u:
      int CPUType = (DNBArchProtocol *)DNBArchProtocol::GetCPUType(v22);
      int CPUSubType = DNBArchProtocol::GetCPUSubType(CPUType);
      LODWORD(v106) = a11;
      LOBYTE(v105) = a9;
      unsigned int v28 = MachProcess::PosixSpawnChildForPTraceDebugging((MachProcess *)a2, (const char *)CPUType, CPUSubType, (char *const *)a3, a4, a5, a6, a7, a8, v105, a1, v106, (DNBError *)a14, v107);
      *a1 = v28;
      if (!v28) {
        goto LABEL_31;
      }
      goto LABEL_5;
    case 2u:
      unsigned int v51 = MachProcess::ForkChildForPTraceDebugging((MachProcess *)a2, (char *const *)a3, v23, (const char **)a1, v24, v25);
      *a1 = v51;
      if (!v51) {
        goto LABEL_31;
      }
      goto LABEL_5;
    case 4u:
      size_t v47 = strlen(a2);
      if (v47 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      long long v48 = (void *)v47;
      if (v47 >= 0x17)
      {
        uint64_t v80 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v47 | 7) != 0x17) {
          uint64_t v80 = v47 | 7;
        }
        uint64_t v81 = v80 + 1;
        size_t v49 = operator new(v80 + 1);
        __p[1] = v48;
        unint64_t v113 = v81 | 0x8000000000000000;
        __p[0] = v49;
        uint64_t v50 = a14;
      }
      else
      {
        HIBYTE(v113) = v47;
        size_t v49 = __p;
        uint64_t v50 = a14;
        if (!v47) {
          goto LABEL_58;
        }
      }
      memcpy(v49, a2, (size_t)v48);
LABEL_58:
      *((unsigned char *)v48 + (void)v49) = 0;
      GetAppBundle(__p, &__dst);
      if (SHIBYTE(v113) < 0)
      {
        operator delete(__p[0]);
        int v82 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0) {
          goto LABEL_60;
        }
      }
      else
      {
        int v82 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0)
        {
LABEL_60:
          if (!v82) {
            goto LABEL_75;
          }
          a1[110] |= 0x14u;
          p_dst = (const char *)&__dst;
          goto LABEL_74;
        }
      }
      if (!*((void *)&__dst + 1)) {
        goto LABEL_75;
      }
      a1[110] |= 0x14u;
      p_dst = (const char *)__dst;
LABEL_74:
      if (MachProcess::BoardServiceLaunchForDebug(a1, p_dst, (const char **)a3, (char **)a4, a9, a11 != 0, a12, a13, v50))goto LABEL_83; {
LABEL_75:
      }
      if (DNBLogEnabled())
      {
        int v94 = &__dst;
        if (v117 < 0) {
          int v94 = (long long *)__dst;
        }
        _DNBLog(0, (uint64_t)"Failed to launch '%s' with BKS", v88, v89, v90, v91, v92, v93, (uint64_t)v94);
      }
LABEL_90:
      char v95 = 1;
      if (SHIBYTE(v117) < 0) {
        goto LABEL_84;
      }
LABEL_91:
      if (v95) {
        goto LABEL_92;
      }
      return a4;
    case 5u:
      size_t v52 = strlen(a2);
      if (v52 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      uint64_t v53 = (void *)v52;
      if (v52 >= 0x17)
      {
        uint64_t v84 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v52 | 7) != 0x17) {
          uint64_t v84 = v52 | 7;
        }
        uint64_t v85 = v84 + 1;
        unint64_t v54 = operator new(v84 + 1);
        __src[1] = v53;
        unint64_t v115 = v85 | 0x8000000000000000;
        __src[0] = v54;
        uint64_t v55 = a14;
      }
      else
      {
        HIBYTE(v115) = v52;
        unint64_t v54 = __src;
        uint64_t v55 = a14;
        if (!v52) {
          goto LABEL_66;
        }
      }
      memcpy(v54, a2, (size_t)v53);
LABEL_66:
      *((unsigned char *)v53 + (void)v54) = 0;
      GetAppBundle(__src, &__dst);
      if (SHIBYTE(v115) < 0)
      {
        operator delete(__src[0]);
        int v86 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0) {
          goto LABEL_68;
        }
      }
      else
      {
        int v86 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0)
        {
LABEL_68:
          if (!v86) {
            goto LABEL_86;
          }
          a1[110] |= 0x18u;
          char v87 = (const char *)&__dst;
          goto LABEL_82;
        }
      }
      if (!*((void *)&__dst + 1)) {
        goto LABEL_86;
      }
      a1[110] |= 0x18u;
      char v87 = (const char *)__dst;
LABEL_82:
      if (!MachProcess::BoardServiceLaunchForDebug(a1, v87, (const char **)a3, (char **)a4, a9, a11 != 0, a12, a13, v55))
      {
LABEL_86:
        if (DNBLogEnabled())
        {
          long long v102 = &__dst;
          if (v117 < 0) {
            long long v102 = (long long *)__dst;
          }
          _DNBLog(0, (uint64_t)"Failed to launch '%s' with FBS", v96, v97, v98, v99, v100, v101, (uint64_t)v102);
        }
        goto LABEL_90;
      }
LABEL_83:
      char v95 = 0;
      a4 = (const char **)*a1;
      if ((SHIBYTE(v117) & 0x80000000) == 0) {
        goto LABEL_91;
      }
LABEL_84:
      operator delete((void *)__dst);
      if (v95)
      {
LABEL_92:
        if (!*a1)
        {
LABEL_31:
          if (!*(_DWORD *)a14)
          {
            *(void *)a14 = 0xFFFFFFFFLL;
            if (*(char *)(a14 + 31) < 0)
            {
              **(unsigned char **)(a14 + 8) = 0;
              *(void *)(a14 + 16) = 0;
            }
            else
            {
              *(unsigned char *)(a14 + 8) = 0;
              *(unsigned char *)(a14 + 31) = 0;
            }
          }
          return (const char **)*a1;
        }
LABEL_5:
        std::string::assign((std::string *)a1 + 1, a2);
        uint64_t v29 = (const char *)*a3;
        if (*a3)
        {
          uint64_t v30 = (const char **)(a3 + 1);
          do
          {
            size_t v33 = strlen(v29);
            if (v33 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            size_t v34 = v33;
            if (v33 >= 0x17)
            {
              uint64_t v36 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v33 | 7) != 0x17) {
                uint64_t v36 = v33 | 7;
              }
              uint64_t v37 = v36 + 1;
              uint64_t v35 = (long long *)operator new(v36 + 1);
              *((void *)&__dst + 1) = v34;
              int64_t v117 = v37 | 0x8000000000000000;
              *(void *)&long long __dst = v35;
            }
            else
            {
              HIBYTE(v117) = v33;
              uint64_t v35 = &__dst;
              if (!v33) {
                goto LABEL_17;
              }
            }
            memmove(v35, v29, v34);
LABEL_17:
            *((unsigned char *)v35 + v34) = 0;
            unint64_t v38 = *((void *)a1 + 7);
            if (v38 < *((void *)a1 + 8))
            {
              long long v31 = __dst;
              *(void *)(v38 + 16) = v117;
              *(_OWORD *)unint64_t v38 = v31;
              *((void *)a1 + 7) = v38 + 24;
            }
            else
            {
              uint64_t v39 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a1 + 6, (uint64_t)&__dst);
              int v40 = SHIBYTE(v117);
              *((void *)a1 + 7) = v39;
              if (v40 < 0) {
                operator delete((void *)__dst);
              }
            }
            uint64_t v32 = *v30++;
            uint64_t v29 = v32;
          }
          while (v32);
        }
        MachTask::StartExceptionThread((uint64_t)(a1 + 26), a13, a14);
        if (*(_DWORD *)a14)
        {
          if (!DNBError::AsString((DNBError *)a14)) {
            std::string::assign((std::string *)(a14 + 8), "unable to start the exception thread");
          }
          if (DNBLogEnabled()) {
            _DNBLog(0, (uint64_t)"Could not get inferior's Mach exception port, sending ptrace PT_KILL and exiting.", v41, v42, v43, v44, v45, v46, (uint64_t)v104);
          }
          ptrace(8, *a1, 0, 0);
          a4 = 0;
          *a1 = 0;
          return a4;
        }
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("MachProcess::%s()", "StartSTDIOThread");
        }
        pthread_create((pthread_t *)a1 + 56, 0, (void *(__cdecl *)(void *))MachProcess::STDIOThread, a1);
        if (a10 == 1)
        {
          MachProcess::SetState((uint64_t)a1, 2u);
          *__error() = 0;
          if (DNBLogEnabled())
          {
            uint64_t v62 = getpid();
            _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...", v63, v64, v65, v66, v67, v68, v62);
          }
          int v69 = ptrace(14, *a1, 0, 0);
          int v70 = *__error();
          if (DNBLogEnabled())
          {
            uint64_t v71 = getpid();
            _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d", v72, v73, v74, v75, v76, v77, v71);
          }
          if (v69)
          {
            MachProcess::SetState((uint64_t)a1, 9u);
            v108[0] = v70;
            v108[1] = 2;
            uint64_t v110 = 0;
            uint64_t v111 = 0;
            long long v109 = 0;
            if (DNBLogEnabledForAny(2))
            {
              unsigned int v78 = *a1;
              long long v79 = (const char *)DNBError::AsString((DNBError *)v108);
              _DNBLogThreaded("error: failed to attach to spawned pid %d (err = %i, errno = %i (%s))", v78, v69, v70, v79);
            }
            snprintf((char *)&__dst, 0x400uLL, "Failed to attach to pid %d, LaunchForDebug() unable to ptrace(PT_ATTACHEXC)", *a1);
            if ((_BYTE)__dst)
            {
              std::string::assign((std::string *)(a14 + 8), (const std::string::value_type *)&__dst);
            }
            else if (*(char *)(a14 + 31) < 0)
            {
              **(unsigned char **)(a14 + 8) = 0;
              *(void *)(a14 + 16) = 0;
            }
            else
            {
              *(unsigned char *)(a14 + 8) = 0;
              *(unsigned char *)(a14 + 31) = 0;
            }
            if (SHIBYTE(v111) < 0) {
              operator delete(v109);
            }
            return (const char **)*a1;
          }
          a1[110] |= 1u;
          if (DNBLogEnabledForAny(2)) {
            _DNBLogThreaded("successfully spawned pid %d", *a1);
          }
        }
        *(void *)a14 = 0;
        if (*(char *)(a14 + 31) < 0)
        {
          **(unsigned char **)(a14 + 8) = 0;
          *(void *)(a14 + 16) = 0;
        }
        else
        {
          *(unsigned char *)(a14 + 8) = 0;
          *(unsigned char *)(a14 + 31) = 0;
        }
        return (const char **)*a1;
      }
      return a4;
    default:
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"Failed to launch: invalid launch flavor: %d", v56, v57, v58, v59, v60, v61, a10);
      }
      *(void *)a14 = 0xFFFFFFFFLL;
      a4 = 0;
      if (*(char *)(a14 + 31) < 0)
      {
        **(unsigned char **)(a14 + 8) = 0;
        *(void *)(a14 + 16) = 0;
      }
      else
      {
        *(unsigned char *)(a14 + 8) = 0;
        *(unsigned char *)(a14 + 31) = 0;
      }
      return a4;
  }
}

void sub_10004869C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a25 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::ForkChildForPTraceDebugging(MachProcess *this, char *const *a2, const char **a3, const char **a4, MachProcess *a5, DNBError *a6)
{
  int v15 = 0;
  PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v14);
  uint64_t v9 = PseudoTerminal::Fork(&v14, &v15);
  uint64_t v10 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    if (!v9)
    {
      ptrace(0, 0, 0, 0);
      ptrace(12, 0, 0, 0);
      gid_t v13 = getgid();
      if (!setgid(v13))
      {
        setpgid(0, 0);
        sleep(1u);
        execv((const char *)this, a2);
      }
      exit(127);
    }
    setpgid(v9, v9);
    if (a4)
    {
      int v11 = v14;
      int v14 = -1;
      *((_DWORD *)a4 + 3) = v11;
      *((_DWORD *)a4 + 4) = v11;
      *((_DWORD *)a4 + 5) = v11;
    }
  }
  PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v14);
  return v10;
}

void sub_10004881C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

uint64_t MachProcess::BoardServiceLaunchForDebug(unsigned int *a1, const char *a2, const char **a3, char **a4, char a5, int a6, char *a7, int8x16_t **a8, uint64_t a9)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s( '%s', argv)", "BoardServiceLaunchForDebug", a2);
  }
  MachProcess::SetState((uint64_t)a1, 3u);
  unsigned int v17 = MachProcess::BoardServiceForkChildForPTraceDebugging((MachProcess *)a1, a2, a3, a4, a5, a6, a7, (DNBError *)a9);
  *a1 = v17;
  if (v17)
  {
    std::string::assign((std::string *)a1 + 1, a2);
    uint64_t v18 = *a3;
    if (*a3)
    {
      uint64_t v19 = a3 + 1;
      do
      {
        size_t v22 = strlen(v18);
        if (v22 >= 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        size_t v23 = v22;
        if (v22 >= 0x17)
        {
          uint64_t v25 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v22 | 7) != 0x17) {
            uint64_t v25 = v22 | 7;
          }
          uint64_t v26 = v25 + 1;
          p_dst = (long long *)operator new(v25 + 1);
          *((void *)&__dst + 1) = v23;
          unint64_t v67 = v26 | 0x8000000000000000;
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v67) = v22;
          p_dst = &__dst;
          if (!v22) {
            goto LABEL_16;
          }
        }
        memmove(p_dst, v18, v23);
LABEL_16:
        *((unsigned char *)p_dst + v23) = 0;
        unint64_t v27 = *((void *)a1 + 7);
        if (v27 < *((void *)a1 + 8))
        {
          long long v20 = __dst;
          *(void *)(v27 + 16) = v67;
          *(_OWORD *)unint64_t v27 = v20;
          *((void *)a1 + 7) = v27 + 24;
        }
        else
        {
          unsigned int v28 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a1 + 6, (uint64_t)&__dst);
          int v29 = SHIBYTE(v67);
          *((void *)a1 + 7) = v28;
          if (v29 < 0) {
            operator delete((void *)__dst);
          }
        }
        uint64_t v21 = *v19++;
        uint64_t v18 = v21;
      }
      while (v21);
    }
    MachTask::StartExceptionThread((uint64_t)(a1 + 26), a8, a9);
    if (*(_DWORD *)a9)
    {
      if (DNBError::AsString((DNBError *)a9))
      {
        if (!DNBLogEnabled())
        {
LABEL_23:
          ptrace(8, *a1, 0, 0);
          uint64_t result = 0;
          *a1 = 0;
          return result;
        }
      }
      else
      {
        std::string::assign((std::string *)(a9 + 8), "unable to start the exception thread");
        if (!DNBLogEnabled()) {
          goto LABEL_23;
        }
      }
      uint64_t v30 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] END (%d) Could not get inferior's Mach exception port, sending ptrace PT_KILL to pid %i and exiting.", v31, v32, v33, v34, v35, v36, v30);
      goto LABEL_23;
    }
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s()", "StartSTDIOThread");
    }
    pthread_create((pthread_t *)a1 + 56, 0, (void *(__cdecl *)(void *))MachProcess::STDIOThread, a1);
    MachProcess::SetState((uint64_t)a1, 2u);
    if (DNBLogEnabled())
    {
      uint64_t v38 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...", v39, v40, v41, v42, v43, v44, v38);
    }
    int v45 = ptrace(14, *a1, 0, 0);
    if (DNBLogEnabled())
    {
      uint64_t v46 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d", v47, v48, v49, v50, v51, v52, v46);
    }
    if (v45)
    {
      std::string::assign((std::string *)(a9 + 8), "Failed to attach to pid: BoardServiceLaunchForDebug() unable to ptrace(PT_ATTACHEXC)");
      MachProcess::SetState((uint64_t)a1, 9u);
      if (DNBLogEnabled())
      {
        uint64_t v65 = getpid();
        _DNBLog(0, (uint64_t)"[LaunchAttach] END (%d) error: failed to attach to pid %d", v53, v54, v55, v56, v57, v58, v65);
      }
    }
    else
    {
      a1[110] |= 1u;
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"[LaunchAttach] successfully attached to pid %d", v59, v60, v61, v62, v63, v64, *a1);
      }
    }
  }
  return *a1;
}

void sub_100048B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::PosixSpawnChildForPTraceDebugging(MachProcess *this, const char *a2, int a3, char *const *a4, const char **a5, const char **a6, char *a7, char *a8, char *a9, const char *a10, _DWORD *a11, MachProcess *a12, DNBError *a13, DNBError *a14)
{
  uint64_t v19 = a9;
  int v48 = a3;
  cpu_type_t v49 = (int)a2;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s(path='%s', argv=%p, envp=%p, working_dir=%s, stdin=%s, stdout=%s stderr=%s, no-stdio=%i)", "PosixSpawnChildForPTraceDebugging", (const char *)this, a4, a5, (const char *)a6, a7, a8, a9, a10);
  }
  posix_spawnattr_t v47 = 0;
  int v20 = posix_spawnattr_init(&v47);
  *(_DWORD *)a13 = v20;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((unsigned char **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0;
    if (!*(_DWORD *)a13) {
      goto LABEL_7;
    }
  }
  else
  {
    *((unsigned char *)a13 + 8) = 0;
    *((unsigned char *)a13 + 31) = 0;
    if (!v20)
    {
LABEL_7:
      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_9;
      }
    }
  }
  DNBError::LogThreaded(a13, "::posix_spawnattr_init(&attr)");
LABEL_9:
  if (*(_DWORD *)a13) {
    return 0;
  }
  if (a12) {
    __int16 v21 = 398;
  }
  else {
    __int16 v21 = 142;
  }
  sigset_t v45 = -1;
  sigset_t v46 = 0;
  posix_spawnattr_setsigmask(&v47, &v46);
  posix_spawnattr_setsigdefault(&v47, &v45);
  int v22 = posix_spawnattr_setflags(&v47, v21);
  *(_DWORD *)a13 = v22;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((unsigned char **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0;
    if (!*(_DWORD *)a13) {
      goto LABEL_17;
    }
  }
  else
  {
    *((unsigned char *)a13 + 8) = 0;
    *((unsigned char *)a13 + 31) = 0;
    if (!v22)
    {
LABEL_17:
      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_21;
      }
    }
  }
  size_t v23 = " | _POSIX_SPAWN_DISABLE_ASLR";
  if (!a12) {
    size_t v23 = (const char *)&unk_10005A589;
  }
  DNBError::LogThreaded(a13, "::posix_spawnattr_setflags(&attr, POSIX_SPAWN_START_SUSPENDED%s)", v23);
LABEL_21:
  if (*(_DWORD *)a13) {
    return 0;
  }
  if (v49)
  {
    v53[0] = 0;
    if (v48)
    {
      uint64_t v26 = (uint64_t (*)(posix_spawnattr_t *, uint64_t, cpu_type_t *, int *, size_t *))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "posix_spawnattr_setarchpref_np");
      if (v26)
      {
        int v27 = v26(&v47, 1, &v49, &v48, v53);
        *(_DWORD *)a13 = v27;
        *((_DWORD *)a13 + 1) = 1;
        if (*((char *)a13 + 31) < 0)
        {
          **((unsigned char **)a13 + 1) = 0;
          *((void *)a13 + 2) = 0;
          int v27 = *(_DWORD *)a13;
        }
        else
        {
          *((unsigned char *)a13 + 8) = 0;
          *((unsigned char *)a13 + 31) = 0;
        }
        if (!v27 && !DNBLogCheckLogBit(2)) {
          goto LABEL_41;
        }
        DNBError::LogThreaded(a13, "::posix_spawnattr_setarchpref_np(&attr, 1, cpu_type = 0x%8.8x, cpu_subtype = 0x%8.8x, count => %llu)", v49, v48, v53[0]);
        if (*(_DWORD *)a13 || v53[0] != 1) {
          return 0;
        }
        if (!v27) {
          goto LABEL_43;
        }
      }
    }
    int v28 = posix_spawnattr_setbinpref_np(&v47, 1uLL, &v49, v53);
    *(_DWORD *)a13 = v28;
    *((_DWORD *)a13 + 1) = 2;
    if (*((char *)a13 + 31) < 0)
    {
      **((unsigned char **)a13 + 1) = 0;
      *((void *)a13 + 2) = 0;
      if (!*(_DWORD *)a13) {
        goto LABEL_39;
      }
    }
    else
    {
      *((unsigned char *)a13 + 8) = 0;
      *((unsigned char *)a13 + 31) = 0;
      if (!v28)
      {
LABEL_39:
        if (DNBLogCheckLogBit(2)) {
          goto LABEL_40;
        }
LABEL_41:
        if (*(_DWORD *)a13 || v53[0] != 1) {
          return 0;
        }
        goto LABEL_43;
      }
    }
LABEL_40:
    DNBError::LogThreaded(a13, "::posix_spawnattr_setbinpref_np(&attr, 1, cpu_type = 0x%8.8x, count => %llu)", v49, v53[0]);
    goto LABEL_41;
  }
LABEL_43:
  PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v44);
  posix_spawn_file_actions_t v43 = 0;
  int v29 = posix_spawn_file_actions_init(&v43);
  int v30 = v29;
  *(_DWORD *)a13 = v29;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((unsigned char **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0;
    int v30 = *(_DWORD *)a13;
    if (*(_DWORD *)a13) {
      goto LABEL_48;
    }
  }
  else
  {
    *((unsigned char *)a13 + 8) = 0;
    *((unsigned char *)a13 + 31) = 0;
    if (v29) {
      goto LABEL_48;
    }
  }
  if (!DNBLogCheckLogBit(2))
  {
    pid_t v42 = 0;
    goto LABEL_59;
  }
LABEL_48:
  DNBError::LogThreaded(a13, "::posix_spawn_file_actions_init(&file_actions)");
  pid_t v42 = 0;
  if (!v30)
  {
LABEL_59:
    int AvailablePrimary = -1;
    if (!a7 && !a8 && !a9)
    {
      if (a10)
      {
        a8 = 0;
        uint64_t v19 = 0;
        int AvailablePrimary = -1;
        goto LABEL_70;
      }
      int AvailablePrimary = PseudoTerminal::OpenFirstAvailablePrimary((PseudoTerminal *)&v44, 131074);
      if (AvailablePrimary)
      {
        a8 = 0;
        uint64_t v19 = 0;
        goto LABEL_70;
      }
      uint64_t v19 = PseudoTerminal::SecondaryName((PseudoTerminal *)&v44);
      int AvailablePrimary = 0;
      a8 = v19;
      a7 = v19;
    }
    if ((a10 & 1) == 0 && a7 && *a7)
    {
LABEL_71:
      if ((a10 & 1) != 0 || !a8 || !*a8) {
        a8 = "/dev/null";
      }
      if ((a10 & 1) != 0 || !v19 || !*v19) {
        uint64_t v19 = "/dev/null";
      }
      int v32 = posix_spawn_file_actions_addopen(&v43, 0, a7, 0x20000, 0);
      *(_DWORD *)a13 = v32;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((unsigned char **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0;
        if (!*(_DWORD *)a13) {
          goto LABEL_83;
        }
      }
      else
      {
        *((unsigned char *)a13 + 8) = 0;
        *((unsigned char *)a13 + 31) = 0;
        if (!v32)
        {
LABEL_83:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_85;
          }
        }
      }
      DNBError::LogThreaded(a13, "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDIN_FILENO, path='%s')", a7);
LABEL_85:
      int v33 = posix_spawn_file_actions_addopen(&v43, 1, a8, 131585, 0x1A0u);
      *(_DWORD *)a13 = v33;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((unsigned char **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0;
        if (!*(_DWORD *)a13) {
          goto LABEL_89;
        }
      }
      else
      {
        *((unsigned char *)a13 + 8) = 0;
        *((unsigned char *)a13 + 31) = 0;
        if (!v33)
        {
LABEL_89:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_91;
          }
        }
      }
      DNBError::LogThreaded(a13, "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDOUT_FILENO, path='%s')", a8);
LABEL_91:
      int v34 = posix_spawn_file_actions_addopen(&v43, 2, v19, 131585, 0x1A0u);
      *(_DWORD *)a13 = v34;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((unsigned char **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0;
        if (!*(_DWORD *)a13) {
          goto LABEL_95;
        }
      }
      else
      {
        *((unsigned char *)a13 + 8) = 0;
        *((unsigned char *)a13 + 31) = 0;
        if (!v34)
        {
LABEL_95:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_97;
          }
        }
      }
      DNBError::LogThreaded(a13, "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDERR_FILENO, path='%s')", v19);
LABEL_97:
      if (a6) {
        chdir((const char *)a6);
      }
      int v35 = posix_spawnp(&v42, (const char *)this, &v43, &v47, a4, (char *const *)a5);
      *(_DWORD *)a13 = v35;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((unsigned char **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0;
        if (*(_DWORD *)a13) {
          goto LABEL_104;
        }
      }
      else
      {
        *((unsigned char *)a13 + 8) = 0;
        *((unsigned char *)a13 + 31) = 0;
        if (v35) {
          goto LABEL_104;
        }
      }
      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_105;
      }
LABEL_104:
      DNBError::LogThreaded(a13, "::posix_spawnp(pid => %i, path = '%s', file_actions = %p, attr = %p, argv = %p, envp = %p)", v42, (const char *)this, &v43, &v47, a4, a5);
      goto LABEL_105;
    }
LABEL_70:
    a7 = "/dev/null";
    goto LABEL_71;
  }
  if (a6) {
    chdir((const char *)a6);
  }
  int v31 = posix_spawnp(&v42, (const char *)this, 0, &v47, a4, (char *const *)a5);
  *(_DWORD *)a13 = v31;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((unsigned char **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0;
    if (!*(_DWORD *)a13) {
      goto LABEL_55;
    }
LABEL_56:
    DNBError::LogThreaded(a13, "::posix_spawnp(pid => %i, path = '%s', file_actions = %p, attr = %p, argv = %p, envp = %p)", v42, (const char *)this, 0, &v47, a4, a5);
    goto LABEL_57;
  }
  *((unsigned char *)a13 + 8) = 0;
  *((unsigned char *)a13 + 31) = 0;
  if (v31) {
    goto LABEL_56;
  }
LABEL_55:
  if (DNBLogCheckLogBit(2)) {
    goto LABEL_56;
  }
LABEL_57:
  int AvailablePrimary = -1;
LABEL_105:
  if (*(_DWORD *)a13) {
    pid_t v42 = 0;
  }
  if (a11 && !AvailablePrimary)
  {
    int v36 = v44;
    int v44 = -1;
    a11[3] = v36;
    a11[4] = v36;
    a11[5] = v36;
  }
  posix_spawnattr_destroy(&v47);
  pid_t v37 = v42;
  if (v42)
  {
    long long v54 = 0u;
    long long v55 = 0u;
    *(_OWORD *)uint64_t v53 = 0u;
    size_t v52 = 12;
    if (sysctlnametomib("sysctl.proc_cputype", (int *)v53, &v52))
    {
      uint64_t v38 = 0;
    }
    else
    {
      size_t v39 = v52;
      *((_DWORD *)v53 + v52) = v37;
      size_t v52 = v39 + 1;
      unsigned int v51 = 0;
      size_t v50 = 4;
      if (sysctl((int *)v53, v39 + 1, &v51, &v50, 0, 0)) {
        uint64_t v38 = 0;
      }
      else {
        uint64_t v38 = (DNBArchProtocol *)v51;
      }
    }
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s() pid=%i, cpu_type=0x%8.8x", "PosixSpawnChildForPTraceDebugging", v42, v38);
    }
    if (v38) {
      DNBArchProtocol::SetArchitecture(v38, 0);
    }
  }
  if (!v30)
  {
    *(_OWORD *)uint64_t v53 = 0u;
    long long v54 = 0u;
    v53[0] = posix_spawn_file_actions_destroy(&v43) | 0x200000000;
    LOBYTE(v53[1]) = 0;
    HIBYTE(v54) = 0;
    if (LODWORD(v53[0]) || DNBLogCheckLogBit(2))
    {
      DNBError::LogThreaded((DNBError *)v53, "::posix_spawn_file_actions_destroy(&file_actions)");
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53[1]);
      }
    }
  }
  uint64_t v24 = v42;
  PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v44);
  return v24;
}

void sub_1000493C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  if (*(char *)(v14 - 113) < 0) {
    operator delete(*(void **)(v14 - 136));
  }
  PseudoTerminal::~PseudoTerminal((PseudoTerminal *)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::BoardServiceForkChildForPTraceDebugging(MachProcess *this, const char *a2, const char **a3, char **a4, char a5, int a6, char *a7, DNBError *a8)
{
  if (*a3)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s( '%s', argv, %p)", "BoardServiceForkChildForPTraceDebugging", a2, this);
    }
    id v68 = objc_alloc_init((Class)NSAutoreleasePool);
    uint64_t v16 = 0;
    uint64_t v17 = -1;
    do
    {
      uint64_t v18 = a3[v16++];
      ++v17;
    }
    while (v18);
    int v67 = a6;
    std::string __s = a7;
    if (a3[1])
    {
      unint64_t v19 = v16 - 1;
      int v20 = +[NSMutableArray arrayWithCapacity:~(unint64_t)(v17 != 0) + v16];
      if (v19 >= 2)
      {
        for (uint64_t i = 1; i != v19; ++i)
        {
          if (!a3[i]) {
            break;
          }
          int v22 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
          if (!v22) {
            break;
          }
          [(NSMutableArray *)v20 addObject:v22];
        }
      }
    }
    else
    {
      int v20 = 0;
    }
    if (*a4)
    {
      id v24 = objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v25 = *a4;
      if (*a4)
      {
        uint64_t v26 = (const char **)(a4 + 1);
        do
        {
          int v28 = strchr(v25, 61);
          if (v28 && v28 != v25) {
            [v24 setObject:[NSString stringWithUTF8String:v28 + 1] forKey:[objc_alloc((Class)NSString) initWithBytes:*(v26 - 1) length:(int)v28 - (int)v25 encoding:4]];
          }
          int v27 = (char *)*v26++;
          uint64_t v25 = v27;
        }
        while (v27);
      }
    }
    else
    {
      id v24 = 0;
    }
    int v29 = +[NSFileManager defaultManager];
    PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v70);
    if ((a5 & 1) != 0 || PseudoTerminal::OpenFirstAvailablePrimary((PseudoTerminal *)&v70, 131074)) {
      goto LABEL_25;
    }
    int v35 = PseudoTerminal::SecondaryName((PseudoTerminal *)&v70);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s() successfully opened primary pty, secondary is %s", "BoardServiceForkChildForPTraceDebugging", v35);
    }
    if (!v35
      || !*v35
      || (chmod(v35, 0x1FFu),
          (int v30 = [(NSFileManager *)v29 stringWithFileSystemRepresentation:v35 length:strlen(v35)]) == 0))
    {
LABEL_25:
      int v30 = [(NSFileManager *)v29 stringWithFileSystemRepresentation:"/dev/null" length:9];
    }
    int v31 = (__CFString *)CopyBundleIDForPath(a2, a8);
    if (!v31)
    {
      [v68 drain];
      uint64_t v23 = 0;
LABEL_76:
      PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v70);
      return v23;
    }
    unsigned int v69 = 0;
    int v32 = *((_DWORD *)this + 110);
    if ((v32 & 0x10) == 0)
    {
      uint64_t v33 = *(unsigned int *)this;
      if (v33)
      {
        if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v33])
        {
          int v34 = *((_DWORD *)this + 110) | 8;
        }
        else
        {
          unsigned int v36 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
          int v34 = *((_DWORD *)this + 110);
          if (v36) {
            v34 |= 4u;
          }
        }
        int v32 = v34 | 0x10;
        *((_DWORD *)this + 110) = v32;
      }
    }
    if ((v32 & 4) != 0)
    {
      id v38 = +[NSMutableDictionary dictionary];
      size_t v39 = v38;
      if (v20) {
        [v38 setObject:v20 forKey:BKSDebugOptionKeyArguments];
      }
      if (v24) {
        [v39 setObject:v24 forKey:BKSDebugOptionKeyEnvironment];
      }
      [v39 setObject:v30 forKey:BKSDebugOptionKeyStandardOutPath];
      [v39 setObject:v30 forKey:BKSDebugOptionKeyStandardErrorPath];
      uint64_t v40 = +[NSNumber numberWithBool:1];
      [v39 setObject:v40 forKey:BKSDebugOptionKeyWaitForDebugger];
      if (v67)
      {
        uint64_t v41 = +[NSNumber numberWithBool:1];
        [v39 setObject:v41 forKey:BKSDebugOptionKeyDisableASLR];
      }
      pid_t v42 = (NSMutableDictionary *)+[NSMutableDictionary dictionary];
      [(NSMutableDictionary *)v42 setObject:v39 forKey:BKSOpenApplicationOptionKeyDebuggingOptions];
      posix_spawn_file_actions_t v43 = +[NSNumber numberWithBool:1];
      [(NSMutableDictionary *)v42 setObject:v43 forKey:BKSOpenApplicationOptionKeyUnlockDevice];
      *(_OWORD *)timeval __p = 0u;
      long long v72 = 0u;
      BKSAddEventDataToOptions(v42, __s, (DNBError *)__p);
      if (SHIBYTE(v72) < 0) {
        operator delete(__p[1]);
      }
      int v37 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>(v31, v42, (uint64_t)a8, &v69);
      int v32 = *((_DWORD *)this + 110);
      if ((v32 & 0x10) != 0) {
        goto LABEL_59;
      }
    }
    else
    {
      int v37 = 0;
      if ((v32 & 0x10) != 0)
      {
LABEL_59:
        if ((v32 & 8) != 0)
        {
          id v47 = +[NSMutableDictionary dictionary];
          int v48 = v47;
          if (v20) {
            [v47 setObject:v20 forKey:FBSDebugOptionKeyArguments];
          }
          if (v24) {
            [v48 setObject:v24 forKey:FBSDebugOptionKeyEnvironment];
          }
          [v48 setObject:v30 forKey:FBSDebugOptionKeyStandardOutPath];
          [v48 setObject:v30 forKey:FBSDebugOptionKeyStandardErrorPath];
          cpu_type_t v49 = +[NSNumber numberWithBool:1];
          [v48 setObject:v49 forKey:FBSDebugOptionKeyWaitForDebugger];
          if (v67)
          {
            size_t v50 = +[NSNumber numberWithBool:1];
            [v48 setObject:v50 forKey:FBSDebugOptionKeyDisableASLR];
          }
          unsigned int v51 = (NSMutableDictionary *)+[NSMutableDictionary dictionary];
          [(NSMutableDictionary *)v51 setObject:v48 forKey:FBSOpenApplicationOptionKeyDebuggingOptions];
          size_t v52 = +[NSNumber numberWithBool:1];
          [(NSMutableDictionary *)v51 setObject:v52 forKey:FBSOpenApplicationOptionKeyUnlockDevice];
          uint64_t v53 = +[NSNumber numberWithBool:1];
          [(NSMutableDictionary *)v51 setObject:v53 forKey:FBSOpenApplicationOptionKeyPromptUnlockDevice];
          id v54 = +[LSApplicationProxy applicationProxyForBundleURL:](LSApplicationProxy, "applicationProxyForBundleURL:", +[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", +[NSString stringWithUTF8String:a2], 1));
          if (v54)
          {
            if (DNBLogEnabled())
            {
              id v55 = [v54 sequenceNumber];
              [objc_msgSend(objc_msgSend(objc_msgSend(v54, "cacheGUID"), "UUIDString"), "UTF8String"];
              _DNBLog(0, (uint64_t)"Sending AppProxy info: sequence no: %lu, GUID: %s.", v56, v57, v58, v59, v60, v61, (uint64_t)v55);
            }
            uint64_t v62 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v54 sequenceNumber]);
            [(NSMutableDictionary *)v51 setObject:v62 forKey:FBSOpenApplicationOptionKeyLSSequenceNumber];
            id v63 = [objc_msgSend(v54, "cacheGUID") UUIDString];
            [(NSMutableDictionary *)v51 setObject:v63 forKey:FBSOpenApplicationOptionKeyLSCacheGUID];
          }
          *(_OWORD *)timeval __p = 0u;
          long long v72 = 0u;
          FBSAddEventDataToOptions(v51, __s, (DNBError *)__p);
          if (SHIBYTE(v72) < 0) {
            operator delete(__p[1]);
          }
          int v37 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>(v31, v51, (uint64_t)a8, &v69);
        }
        if (v37)
        {
          int v64 = v70;
          int v70 = -1;
          *((_DWORD *)this + 3) = v64;
          *((_DWORD *)this + 4) = v64;
          *((_DWORD *)this + 5) = v64;
          CFString::UTF8(v31, (uint64_t)this + 1720);
        }
        [v68 drain];
        uint64_t v23 = v69;
        goto LABEL_76;
      }
    }
    uint64_t v44 = *(unsigned int *)this;
    if (v44)
    {
      if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v44])
      {
        int v45 = *((_DWORD *)this + 110) | 8;
      }
      else
      {
        unsigned int v46 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v45 = *((_DWORD *)this + 110);
        if (v46) {
          v45 |= 4u;
        }
      }
      int v32 = v45 | 0x10;
      *((_DWORD *)this + 110) = v32;
    }
    goto LABEL_59;
  }
  return 0;
}

void sub_100049B48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

uint64_t MachProcess::ProcessUsingBackBoard(MachProcess *this)
{
  unsigned int v1 = *((_DWORD *)this + 110);
  if ((v1 & 0x10) == 0)
  {
    uint64_t v3 = *(unsigned int *)this;
    if (v3)
    {
      if ([objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v3])
      {
        int v4 = *((_DWORD *)this + 110) | 8;
      }
      else
      {
        unsigned int v5 = [objc_alloc_init((Class)BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v4 = *((_DWORD *)this + 110);
        if (v5) {
          v4 |= 4u;
        }
      }
      unsigned int v1 = v4 | 0x10;
      *((_DWORD *)this + 110) = v1;
    }
  }
  return (v1 >> 2) & 1;
}

uint64_t BKSAddEventDataToOptions(NSMutableDictionary *a1, char *__s, DNBError *a3)
{
  timeval __p = 0;
  int v32 = 0;
  uint64_t v33 = 0;
  SplitEventData(__s, (uint64_t)&__p);
  unsigned int v5 = (void **)__p;
  id v6 = v32;
  if (__p == v32)
  {
    char v7 = 0;
    if (__p) {
      goto LABEL_26;
    }
    return v7 & 1;
  }
  char v7 = 0;
  id v8 = (std::string *)((char *)a3 + 8);
  uint64_t v29 = BKSOpenApplicationOptionKeyActivateSuspended;
  uint64_t v9 = BKSActivateForEventOptionTypeBackgroundContentFetching;
  uint64_t v10 = BKSOpenApplicationOptionKeyActivateForEvent;
  do
  {
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v30, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }
    else
    {
      long long v11 = *(_OWORD *)v5;
      v30.__r_.__value_.__r.__words[2] = (std::string::size_type)v5[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v11;
    }
    if (!std::string::compare(&v30, "BackgroundContentFetching"))
    {
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"Setting ActivateForEvent key in options dictionary.", v13, v14, v15, v16, v17, v18, v28);
      }
      [(NSMutableDictionary *)a1 setObject:+[NSDictionary dictionaryWithObject:forKey:](NSDictionary, "dictionaryWithObject:forKey:", +[NSDictionary dictionary], v9) forKey:v10];
      char v7 = 1;
LABEL_17:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_3;
      }
LABEL_18:
      operator delete(v30.__r_.__value_.__l.__data_);
      goto LABEL_3;
    }
    if (std::string::compare(&v30, "ActivateSuspended"))
    {
      if (DNBLogEnabled())
      {
        size_t v12 = &v30;
        if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          size_t v12 = (std::string *)v30.__r_.__value_.__r.__words[0];
        }
        _DNBLogError("Unrecognized event type: %s.  Ignoring.", (const char *)v12);
      }
      std::string::assign(v8, "Unrecognized event data");
      goto LABEL_17;
    }
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"Setting ActivateSuspended key in options dictionary.", v19, v20, v21, v22, v23, v24, v28);
    }
    [(NSMutableDictionary *)a1 setObject:&__kCFBooleanTrue forKey:v29];
    char v7 = 1;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_18;
    }
LABEL_3:
    v5 += 3;
  }
  while (v5 != v6);
  unsigned int v5 = (void **)__p;
  if (!__p) {
    return v7 & 1;
  }
LABEL_26:
  uint64_t v25 = v32;
  uint64_t v26 = v5;
  if (v32 != v5)
  {
    do
    {
      if (*((char *)v25 - 1) < 0) {
        operator delete(*(v25 - 3));
      }
      v25 -= 3;
    }
    while (v25 != v5);
    uint64_t v26 = __p;
  }
  int v32 = v5;
  operator delete(v26);
  return v7 & 1;
}

void sub_100049E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17)
{
}

uint64_t FBSAddEventDataToOptions(NSMutableDictionary *a1, char *__s, DNBError *a3)
{
  timeval __p = 0;
  int v32 = 0;
  uint64_t v33 = 0;
  SplitEventData(__s, (uint64_t)&__p);
  unsigned int v5 = (void **)__p;
  id v6 = v32;
  if (__p == v32)
  {
    char v7 = 0;
    if (__p) {
      goto LABEL_26;
    }
    return v7 & 1;
  }
  char v7 = 0;
  id v8 = (std::string *)((char *)a3 + 8);
  uint64_t v29 = FBSOpenApplicationOptionKeyActivateSuspended;
  uint64_t v9 = FBSActivateForEventOptionTypeBackgroundContentFetching;
  uint64_t v10 = FBSOpenApplicationOptionKeyActivateForEvent;
  do
  {
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v30, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }
    else
    {
      long long v11 = *(_OWORD *)v5;
      v30.__r_.__value_.__r.__words[2] = (std::string::size_type)v5[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v11;
    }
    if (!std::string::compare(&v30, "BackgroundContentFetching"))
    {
      if (DNBLogEnabled()) {
        _DNBLog(0, (uint64_t)"Setting ActivateForEvent key in options dictionary.", v13, v14, v15, v16, v17, v18, v28);
      }
      [(NSMutableDictionary *)a1 setObject:+[NSDictionary dictionaryWithObject:forKey:](NSDictionary, "dictionaryWithObject:forKey:", +[NSDictionary dictionary], v9) forKey:v10];
      char v7 = 1;
LABEL_17:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_3;
      }
LABEL_18:
      operator delete(v30.__r_.__value_.__l.__data_);
      goto LABEL_3;
    }
    if (std::string::compare(&v30, "ActivateSuspended"))
    {
      if (DNBLogEnabled())
      {
        size_t v12 = &v30;
        if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          size_t v12 = (std::string *)v30.__r_.__value_.__r.__words[0];
        }
        _DNBLogError("Unrecognized event type: %s.  Ignoring.", (const char *)v12);
      }
      std::string::assign(v8, "Unrecognized event data.");
      goto LABEL_17;
    }
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"Setting ActivateSuspended key in options dictionary.", v19, v20, v21, v22, v23, v24, v28);
    }
    [(NSMutableDictionary *)a1 setObject:&__kCFBooleanTrue forKey:v29];
    char v7 = 1;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_18;
    }
LABEL_3:
    v5 += 3;
  }
  while (v5 != v6);
  unsigned int v5 = (void **)__p;
  if (!__p) {
    return v7 & 1;
  }
LABEL_26:
  uint64_t v25 = v32;
  uint64_t v26 = v5;
  if (v32 != v5)
  {
    do
    {
      if (*((char *)v25 - 1) < 0) {
        operator delete(*(v25 - 3));
      }
      v25 -= 3;
    }
    while (v25 != v5);
    uint64_t v26 = __p;
  }
  int v32 = v5;
  operator delete(v26);
  return v7 & 1;
}

void sub_10004A0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17)
{
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  std::ostream::sentry::sentry();
  if (v13)
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  std::ostream::sentry::~sentry();
  return a1;
}

void sub_10004A23C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  std::ostream::sentry::~sentry();
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x10004A21CLL);
}

void sub_10004A290(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        char v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v22 = v15 | 0x8000000000000000;
        __b[0] = v13;
      }
      else
      {
        HIBYTE(v22) = v12;
        char v13 = __b;
      }
      memset(v13, __c, v12);
      *((unsigned char *)v13 + v12) = 0;
      if (v22 >= 0) {
        uint64_t v16 = __b;
      }
      else {
        uint64_t v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0;
        }
      }
      else if (v17 != v12)
      {
        return 0;
      }
    }
    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0;
      return v6;
    }
    return 0;
  }
  return v6;
}

void sub_10004A478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::vector<BOOL>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *(void **)a1;
      if (v4 > v5 << 6)
      {
        if (v6)
        {
          operator delete(v6);
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
          unint64_t v4 = *(void *)(a2 + 8);
        }
        if ((v4 & 0x8000000000000000) != 0) {
          std::vector<kevent>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v7 = ((v4 - 1) >> 6) + 1;
        uint64_t v6 = operator new(8 * v7);
        *(void *)a1 = v6;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = v7;
        unint64_t v4 = *(void *)(a2 + 8);
      }
      memmove(v6, *(const void **)a2, (((v4 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8) + 8);
      unint64_t v4 = *(void *)(a2 + 8);
    }
    *(void *)(a1 + 8) = v4;
  }
  return a1;
}

void *std::vector<DNBThreadResumeAction>::__assign_with_size[abi:ne180100]<DNBThreadResumeAction*,DNBThreadResumeAction*>(void *result, char *__src, char *a3, size_t __sz)
{
  uint64_t v6 = __src;
  unint64_t v7 = result;
  uint64_t v8 = result[2];
  int v9 = (char *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *result) >> 3) < __sz)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_23;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= __sz) {
      uint64_t v11 = __sz;
    }
    unint64_t v12 = v10 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_23:
    }
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    uint64_t v13 = 3 * v12;
    uint64_t result = operator new(24 * v12);
    int v9 = (char *)result;
    *unint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  uint64_t v15 = (void **)(result + 1);
  uint64_t v16 = (unsigned char *)result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 3) >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    uint64_t v18 = (void *)*result;
LABEL_21:
    uint64_t result = memmove(v18, __src, v14);
    goto LABEL_22;
  }
  uint64_t v17 = &__src[8 * ((v16 - v9) >> 3)];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    int v9 = (char *)*v15;
  }
  size_t v14 = a3 - v17;
  if (v14)
  {
    uint64_t v18 = v9;
    __src = v17;
    goto LABEL_21;
  }
LABEL_22:
  const char *v15 = &v9[v14];
  return result;
}

uint64_t CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>(id a1, void *a2, uint64_t a3, _DWORD *a4)
{
  id v8 = objc_alloc_init((Class)BKSSystemService);
  int v9 = v8;
  if (!a1)
  {
    a1 = [v8 systemApplicationBundleIdentifier];
    if (!a1)
    {
      std::string::assign((std::string *)(a3 + 8), "No system application to message.");
      return 0;
    }
  }
  id v10 = [v9 createClientPort];
  uint64_t v53 = 0;
  id v54 = &v53;
  uint64_t v55 = 0x3052000000;
  uint64_t v56 = __Block_byref_object_copy__0;
  uint64_t v57 = __Block_byref_object_dispose__0;
  dispatch_semaphore_t v58 = 0;
  dispatch_semaphore_t v58 = dispatch_semaphore_create(0);
  uint64_t v49 = 0;
  size_t v50 = &v49;
  uint64_t v51 = 0x2020000000;
  int v52 = 0;
  uint64_t v42 = 0;
  posix_spawn_file_actions_t v43 = &v42;
  uint64_t v44 = 0x4812000000;
  int v45 = __Block_byref_object_copy__281;
  unsigned int v46 = __Block_byref_object_dispose__282;
  long long v47 = 0u;
  long long v48 = 0u;
  uint64_t v38 = 0;
  size_t v39 = &v38;
  uint64_t v40 = 0x2020000000;
  int v41 = 0;
  uint64_t v11 = (const char *)[a1 UTF8String];
  if (v11) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = "<Unknown Bundle ID>";
  }
  id v13 = [a2 description];
  if (DNBLogEnabled())
  {
    uint64_t v14 = getpid();
    [v13 UTF8String];
    _DNBLog(0, (uint64_t)"[LaunchAttach] START (%d) templated *Board launcher: app lunch request for '%s' - options:\n%s", v15, v16, v17, v18, v19, v20, v14);
  }
  v36[0] = _NSConcreteStackBlock;
  v36[1] = 3254779904;
  v36[2] = ___ZL37CallBoardSystemServiceOpenApplicationI16BKSSystemService27BKSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetBKSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke;
  v36[3] = &__block_descriptor_89_e8_32o40o48r56r64r72r_e17_v16__0__NSError_8l;
  BOOL v37 = a4 != 0;
  v36[6] = &v49;
  v36[7] = &v38;
  v36[4] = a1;
  void v36[5] = v9;
  v36[8] = &v42;
  v36[9] = &v53;
  v36[10] = v12;
  [v9 openApplication:a1 options:a2 clientPort:v10 withResult:v36];
  dispatch_time_t v21 = dispatch_time(0, 30000000000);
  intptr_t v22 = dispatch_semaphore_wait((dispatch_semaphore_t)v54[5], v21);
  dispatch_release((dispatch_object_t)v54[5]);
  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog(0, (uint64_t)"[LaunchAttach] END (%d) templated *Board launcher finished app lunch request for '%s'", v24, v25, v26, v27, v28, v29, v23);
  }
  if (v22)
  {
    if (DNBLogEnabled())
    {
      pid_t v30 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) timed out trying to send openApplication to %s.", v30, v12);
    }
    *(void *)a3 = 111;
    if (*(char *)(a3 + 31) < 0)
    {
      **(unsigned char **)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
    else
    {
      *(unsigned char *)(a3 + 8) = 0;
      *(unsigned char *)(a3 + 31) = 0;
    }
    std::string::assign((std::string *)(a3 + 8), "timed out trying to launch app");
  }
  else
  {
    int v31 = *((_DWORD *)v50 + 6);
    if (!v31)
    {
      if (a4)
      {
        *a4 = *((_DWORD *)v39 + 6);
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Out of completion handler, pid from block %d and passing out: %d", *((_DWORD *)v39 + 6), *a4);
        }
      }
      uint64_t v32 = 1;
      goto LABEL_21;
    }
    if (*((char *)v43 + 71) < 0) {
      std::string::__init_copy_ctor_external(&v35, (const std::string::value_type *)v43[6], v43[7]);
    }
    else {
      std::string v35 = *(std::string *)((unsigned char *)v43 + 2);
    }
    SetBKSError(v31, (uint64_t)&v35, a3);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (DNBLogEnabled())
    {
      pid_t v34 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld", v34, v12, *((unsigned int *)v50 + 6));
    }
  }
  uint64_t v32 = 0;
LABEL_21:
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  if (SHIBYTE(v48) < 0) {
    operator delete(*((void **)&v47 + 1));
  }
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  return v32;
}

void sub_10004AAC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Block_object_dispose((const void *)(v46 - 176), 8);
  _Block_object_dispose((const void *)(v46 - 144), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__281(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__282(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

intptr_t ___ZL37CallBoardSystemServiceOpenApplicationI16BKSSystemService27BKSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetBKSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke(uint64_t a1, void *a2)
{
  if (a2) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [a2 code];
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    unint64_t v4 = (const std::string::value_type *)[objc_msgSend(objc_msgSend(a2, "localizedDescription"), "UTF8String") UTF8String];
    if (v4)
    {
      std::string::assign((std::string *)(*(void *)(*(void *)(a1 + 64) + 8) + 48), v4);
      if (DNBLogEnabled())
      {
        pid_t v5 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error localizedDescription '%s'.", v5, v4);
      }
      uint64_t v6 = [+[NSString stringWithFormat:@"%@", a2] UTF8String];
      if (DNBLogEnabled())
      {
        pid_t v7 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error NSError object description: '%s'.", v7, v6);
      }
    }
    if (DNBLogEnabledForAny(2))
    {
      id v8 = "<unknown error>";
      if (v4) {
        id v8 = v4;
      }
      _DNBLogThreaded("In completion handler for send event, got error \"%s\"(%ld).", v8, *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    }
  }
  else if (*(unsigned char *)(a1 + 88))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [*(id *)(a1 + 40) pidForApplication:*(void *)(a1 + 32)];
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"[LaunchAttach] In completion handler, got pid for bundle id '%s', pid: %d.", v9, v10, v11, v12, v13, v14, *(void *)(a1 + 80));
    }
  }
  else if (DNBLogEnabled())
  {
    _DNBLog(0, (uint64_t)"[LaunchAttach] In completion handler, launch was successful, debugserver did not ask for the pid", v15, v16, v17, v18, v19, v20, v23);
  }

  dispatch_time_t v21 = *(NSObject **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);

  return dispatch_semaphore_signal(v21);
}

void __copy_helper_block_e8_32o40o48r56r64r72r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 3);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 3);
  _Block_object_assign((void *)(a1 + 48), *(const void **)(a2 + 48), 8);
  _Block_object_assign((void *)(a1 + 56), *(const void **)(a2 + 56), 8);
  _Block_object_assign((void *)(a1 + 64), *(const void **)(a2 + 64), 8);
  unint64_t v4 = *(const void **)(a2 + 72);

  _Block_object_assign((void *)(a1 + 72), v4, 8);
}

void __destroy_helper_block_e8_32o40o48r56r64r72r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 72), 8);
  _Block_object_dispose(*(const void **)(a1 + 64), 8);
  _Block_object_dispose(*(const void **)(a1 + 56), 8);
  _Block_object_dispose(*(const void **)(a1 + 48), 8);
  _Block_object_dispose(*(const void **)(a1 + 40), 3);
  size_t v2 = *(const void **)(a1 + 32);

  _Block_object_dispose(v2, 3);
}

uint64_t CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>(id a1, void *a2, uint64_t a3, _DWORD *a4)
{
  id v8 = objc_alloc_init((Class)FBSSystemService);
  uint64_t v9 = v8;
  if (!a1)
  {
    a1 = [v8 systemApplicationBundleIdentifier];
    if (!a1)
    {
      std::string::assign((std::string *)(a3 + 8), "No system application to message.");
      return 0;
    }
  }
  id v10 = [v9 createClientPort];
  uint64_t v53 = 0;
  id v54 = &v53;
  uint64_t v55 = 0x3052000000;
  uint64_t v56 = __Block_byref_object_copy__0;
  uint64_t v57 = __Block_byref_object_dispose__0;
  dispatch_semaphore_t v58 = 0;
  dispatch_semaphore_t v58 = dispatch_semaphore_create(0);
  uint64_t v49 = 0;
  size_t v50 = &v49;
  uint64_t v51 = 0x2020000000;
  uint64_t v52 = 0;
  uint64_t v42 = 0;
  posix_spawn_file_actions_t v43 = &v42;
  uint64_t v44 = 0x4812000000;
  int v45 = __Block_byref_object_copy__281;
  uint64_t v46 = __Block_byref_object_dispose__282;
  long long v47 = 0u;
  long long v48 = 0u;
  uint64_t v38 = 0;
  size_t v39 = &v38;
  uint64_t v40 = 0x2020000000;
  int v41 = 0;
  uint64_t v11 = (const char *)[a1 UTF8String];
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = "<Unknown Bundle ID>";
  }
  id v13 = [a2 description];
  if (DNBLogEnabled())
  {
    uint64_t v14 = getpid();
    [v13 UTF8String];
    _DNBLog(0, (uint64_t)"[LaunchAttach] START (%d) templated *Board launcher: app lunch request for '%s' - options:\n%s", v15, v16, v17, v18, v19, v20, v14);
  }
  v36[0] = _NSConcreteStackBlock;
  v36[1] = 3254779904;
  v36[2] = ___ZL37CallBoardSystemServiceOpenApplicationI16FBSSystemService27FBSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetFBSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke;
  v36[3] = &__block_descriptor_89_e8_32o40o48r56r64r72r_e17_v16__0__NSError_8l;
  BOOL v37 = a4 != 0;
  v36[6] = &v49;
  v36[7] = &v38;
  v36[4] = a1;
  void v36[5] = v9;
  v36[8] = &v42;
  v36[9] = &v53;
  v36[10] = v12;
  [v9 openApplication:a1 options:a2 clientPort:v10 withResult:v36];
  dispatch_time_t v21 = dispatch_time(0, 30000000000);
  intptr_t v22 = dispatch_semaphore_wait((dispatch_semaphore_t)v54[5], v21);
  dispatch_release((dispatch_object_t)v54[5]);
  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog(0, (uint64_t)"[LaunchAttach] END (%d) templated *Board launcher finished app lunch request for '%s'", v24, v25, v26, v27, v28, v29, v23);
  }
  if (v22)
  {
    if (DNBLogEnabled())
    {
      pid_t v30 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) timed out trying to send openApplication to %s.", v30, v12);
    }
    *(void *)a3 = 111;
    if (*(char *)(a3 + 31) < 0)
    {
      **(unsigned char **)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
    else
    {
      *(unsigned char *)(a3 + 8) = 0;
      *(unsigned char *)(a3 + 31) = 0;
    }
    std::string::assign((std::string *)(a3 + 8), "timed out trying to launch app");
  }
  else
  {
    uint64_t v31 = v50[3];
    if (!v31)
    {
      if (a4)
      {
        *a4 = *((_DWORD *)v39 + 6);
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Out of completion handler, pid from block %d and passing out: %d", *((_DWORD *)v39 + 6), *a4);
        }
      }
      uint64_t v32 = 1;
      goto LABEL_21;
    }
    if (*((char *)v43 + 71) < 0) {
      std::string::__init_copy_ctor_external(&v35, (const std::string::value_type *)v43[6], v43[7]);
    }
    else {
      std::string v35 = *(std::string *)((unsigned char *)v43 + 2);
    }
    SetFBSError(v31, (uint64_t)&v35, a3);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (DNBLogEnabled())
    {
      pid_t v34 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld", v34, v12, v50[3]);
    }
  }
  uint64_t v32 = 0;
LABEL_21:
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  if (SHIBYTE(v48) < 0) {
    operator delete(*((void **)&v47 + 1));
  }
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  return v32;
}

void sub_10004B1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Block_object_dispose((const void *)(v46 - 176), 8);
  _Block_object_dispose((const void *)(v46 - 144), 8);
  _Unwind_Resume(a1);
}

intptr_t ___ZL37CallBoardSystemServiceOpenApplicationI16FBSSystemService27FBSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetFBSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke(uint64_t a1, void *a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [a2 code];
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    unint64_t v4 = (const std::string::value_type *)[objc_msgSend(objc_msgSend(a2, "localizedDescription"), "UTF8String") UTF8String];
    if (v4)
    {
      std::string::assign((std::string *)(*(void *)(*(void *)(a1 + 64) + 8) + 48), v4);
      if (DNBLogEnabled())
      {
        pid_t v5 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error localizedDescription '%s'.", v5, v4);
      }
      uint64_t v6 = [+[NSString stringWithFormat:@"%@", a2] UTF8String];
      if (DNBLogEnabled())
      {
        pid_t v7 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error NSError object description: '%s'.", v7, v6);
      }
    }
    if (DNBLogEnabledForAny(2))
    {
      id v8 = "<unknown error>";
      if (v4) {
        id v8 = v4;
      }
      _DNBLogThreaded("In completion handler for send event, got error \"%s\"(%ld).", v8, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    }
  }
  else if (*(unsigned char *)(a1 + 88))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [*(id *)(a1 + 40) pidForApplication:*(void *)(a1 + 32)];
    if (DNBLogEnabled()) {
      _DNBLog(0, (uint64_t)"[LaunchAttach] In completion handler, got pid for bundle id '%s', pid: %d.", v9, v10, v11, v12, v13, v14, *(void *)(a1 + 80));
    }
  }
  else if (DNBLogEnabled())
  {
    _DNBLog(0, (uint64_t)"[LaunchAttach] In completion handler, launch was successful, debugserver did not ask for the pid", v15, v16, v17, v18, v19, v20, v23);
  }

  dispatch_time_t v21 = *(NSObject **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);

  return dispatch_semaphore_signal(v21);
}

void SplitEventData(char *__s, uint64_t a2)
{
  unint64_t v4 = *(void ***)a2;
  for (uint64_t i = *(void ***)(a2 + 8); i != v4; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  *(void *)(a2 + 8) = v4;
  if (!__s || !*__s) {
    return;
  }
  while (1)
  {
    pid_t v7 = strchr(__s, 58);
    if (!v7) {
      break;
    }
    id v8 = v7;
    size_t v9 = v7 - __s;
    if (v7 != __s)
    {
      if (v9 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_35;
      }
      if (v9 >= 0x17)
      {
        uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v9 | 7) != 0x17) {
          uint64_t v11 = v9 | 7;
        }
        uint64_t v12 = v11 + 1;
        p_dst = (long long *)operator new(v11 + 1);
        *((void *)&__dst + 1) = v9;
        unint64_t v26 = v12 | 0x8000000000000000;
        *(void *)&long long __dst = p_dst;
      }
      else
      {
        HIBYTE(v26) = (_BYTE)v7 - (_BYTE)__s;
        p_dst = &__dst;
      }
      memmove(p_dst, __s, v9);
      *((unsigned char *)p_dst + v9) = 0;
      unint64_t v13 = *(void *)(a2 + 8);
      if (v13 < *(void *)(a2 + 16))
      {
        long long v6 = __dst;
        *(void *)(v13 + 16) = v26;
        *(_OWORD *)unint64_t v13 = v6;
        *(void *)(a2 + 8) = v13 + 24;
      }
      else
      {
        uint64_t v14 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)&__dst);
        int v15 = SHIBYTE(v26);
        *(void *)(a2 + 8) = v14;
        if (v15 < 0) {
          operator delete((void *)__dst);
        }
      }
    }
    std::string __s = v8 + 1;
    if (!v8[1]) {
      return;
    }
  }
  size_t v16 = strlen(__s);
  if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_35:
  }
    std::string::__throw_length_error[abi:ne180100]();
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    uint64_t v18 = (long long *)operator new(v19 + 1);
    *((void *)&__dst + 1) = v17;
    unint64_t v26 = v20 | 0x8000000000000000;
    *(void *)&long long __dst = v18;
    goto LABEL_29;
  }
  HIBYTE(v26) = v16;
  uint64_t v18 = &__dst;
  if (v16) {
LABEL_29:
  }
    memmove(v18, __s, v17);
  *((unsigned char *)v18 + v17) = 0;
  unint64_t v21 = *(void *)(a2 + 8);
  if (v21 >= *(void *)(a2 + 16))
  {
    uint64_t v23 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)&__dst);
    int v24 = SHIBYTE(v26);
    *(void *)(a2 + 8) = v23;
    if (v24 < 0) {
      operator delete((void *)__dst);
    }
  }
  else
  {
    long long v22 = __dst;
    *(void *)(v21 + 16) = v26;
    *(_OWORD *)unint64_t v21 = v22;
    *(void *)(a2 + 8) = v21 + 24;
  }
}

void sub_10004B5FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>(char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v5 = 0x2E8BA2E8BA2E8BA3 * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x2E8BA2E8BA2E8BALL) {
    std::vector<kevent>::__throw_length_error[abi:ne180100]();
  }
  if (0x5D1745D1745D1746 * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x5D1745D1745D1746 * ((a1[2] - v3) >> 3);
  }
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3)) >= 0x1745D1745D1745DLL) {
    unint64_t v8 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0x2E8BA2E8BA2E8BALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    size_t v9 = (char *)operator new(88 * v8);
  }
  else
  {
    size_t v9 = 0;
  }
  uint64_t v10 = (std::string *)&v9[88 * v5];
  uint64_t v20 = &v9[88 * v8];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    uint64_t v3 = *a1;
    unint64_t v4 = a1[1];
    uint64_t v10 = (std::string *)&v9[88 * v5];
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v10->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  uint64_t v11 = &v9[88 * v5];
  *(_OWORD *)(v11 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v11 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 72);
  uint64_t v12 = v11 + 88;
  if (v4 == v3)
  {
    size_t v17 = v3;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v4 - 88);
      v10[-3].__r_.__value_.__r.__words[0] = *((void *)v4 - 9);
      *(_OWORD *)&v10[-4].__r_.__value_.__r.__words[1] = v13;
      *((void *)v4 - 10) = 0;
      *((void *)v4 - 9) = 0;
      *((void *)v4 - 11) = 0;
      long long v14 = *((_OWORD *)v4 - 4);
      long long v15 = *((_OWORD *)v4 - 3);
      long long v16 = *((_OWORD *)v4 - 1);
      *(_OWORD *)&v10[-2].__r_.__value_.__r.__words[2] = *((_OWORD *)v4 - 2);
      *(_OWORD *)&v10[-1].__r_.__value_.__r.__words[1] = v16;
      *(_OWORD *)&v10[-3].__r_.__value_.__r.__words[1] = v14;
      *(_OWORD *)&v10[-2].__r_.__value_.__l.__data_ = v15;
      uint64_t v10 = (std::string *)((char *)v10 - 88);
      v4 -= 88;
    }
    while (v4 != v3);
    size_t v17 = *a1;
    uint64_t v3 = a1[1];
  }
  *a1 = (char *)v10;
  a1[1] = v12;
  a1[2] = v20;
  if (v3 != v17)
  {
    uint64_t v18 = (void **)(v3 - 88);
    do
    {
      if (*((char *)v18 + 23) < 0) {
        operator delete(*v18);
      }
      v18 -= 11;
    }
    while (v18 + 11 != (void **)v17);
    uint64_t v3 = v17;
  }
  if (v3) {
    operator delete(v3);
  }
  return v12;
}

void sub_10004B82C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MachProcess::mach_o_segment>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<MachProcess::mach_o_segment>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  size_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v5 = v2 - 11;
      *(void *)(a1 + 16) = v2 - 11;
      if (*((char *)v2 - 65) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      size_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10004B9B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10004BAD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>(void **a1, uint64_t a2)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 5);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x199999999999999) {
    std::vector<kevent>::__throw_length_error[abi:ne180100]();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) > v4) {
    unint64_t v4 = 0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v6 = 0x199999999999999;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v27 = (uint64_t)(a1 + 2);
  if (v6)
  {
    if (v6 > 0x199999999999999) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    pid_t v7 = operator new(160 * v6);
  }
  else
  {
    pid_t v7 = 0;
  }
  unint64_t v8 = &v7[160 * v3];
  int v24 = v8;
  unint64_t v26 = &v7[160 * v6];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&v7[160 * v3], *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
    *((void *)v8 + 2) = *(void *)(a2 + 16);
  }
  size_t v9 = &v7[160 * v3];
  *((void *)v9 + 3) = *(void *)(a2 + 24);
  MachProcess::mach_o_information::mach_o_information((uint64_t)(v9 + 32), a2 + 32);
  v7[160 * v3 + 152] = *(unsigned char *)(a2 + 152);
  uint64_t v10 = &v7[160 * v3];
  uint64_t v25 = v10;
  uint64_t v11 = (char *)*a1;
  uint64_t v12 = (char *)a1[1];
  if (v12 == *a1)
  {
    long long v22 = (char *)a1[1];
  }
  else
  {
    uint64_t v13 = 0;
    do
    {
      long long v14 = &v12[v13];
      long long v15 = *(_OWORD *)&v12[v13 - 160];
      long long v16 = &v8[v13];
      *((void *)v16 - 18) = *(void *)&v12[v13 - 144];
      *((_OWORD *)v16 - 10) = v15;
      *((void *)v14 - 19) = 0;
      *((void *)v14 - 18) = 0;
      uint64_t v17 = *(void *)&v12[v13 - 136];
      *((void *)v14 - 20) = 0;
      *((void *)v16 - 17) = v17;
      long long v18 = *(_OWORD *)&v12[v13 - 128];
      long long v19 = *(_OWORD *)&v12[v13 - 112];
      *((void *)v16 - 11) = 0;
      *((void *)v16 - 10) = 0;
      *((_OWORD *)v16 - 8) = v18;
      *((_OWORD *)v16 - 7) = v19;
      *((void *)v16 - 12) = 0;
      *((_OWORD *)v16 - 6) = *(_OWORD *)&v12[v13 - 96];
      *((void *)v16 - 10) = *(void *)&v12[v13 - 80];
      *((void *)v14 - 12) = 0;
      *((void *)v14 - 11) = 0;
      *((void *)v14 - 10) = 0;
      *(_OWORD *)(v16 - 72) = *(_OWORD *)&v12[v13 - 72];
      long long v20 = *(_OWORD *)&v12[v13 - 56];
      *((void *)v16 - 5) = *(void *)&v12[v13 - 40];
      *(_OWORD *)(v16 - 56) = v20;
      *((void *)v14 - 6) = 0;
      *((void *)v14 - 5) = 0;
      *((void *)v14 - 7) = 0;
      long long v21 = *(_OWORD *)&v12[v13 - 32];
      *((void *)v16 - 2) = *(void *)&v12[v13 - 16];
      *((_OWORD *)v16 - 2) = v21;
      *((void *)v14 - 3) = 0;
      *((void *)v14 - 2) = 0;
      *((void *)v14 - 4) = 0;
      *(v16 - 8) = v12[v13 - 8];
      v13 -= 160;
    }
    while (&v12[v13] != v11);
    long long v22 = (char *)*a1;
    uint64_t v12 = (char *)a1[1];
    uint64_t v10 = &v24[v13];
  }
  *a1 = v10;
  a1[1] = v25 + 160;
  a1[2] = v26;
  if (v12 != v22)
  {
    do
    {
      v12 -= 160;
      std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](v27, (uint64_t)v12);
    }
    while (v12 != v22);
    uint64_t v12 = v22;
  }
  if (v12) {
    operator delete(v12);
  }
  return v25 + 160;
}

void sub_10004BD28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MachProcess::binary_image_information>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::mach_o_information::mach_o_information(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  std::vector<MachProcess::mach_o_segment>::__init_with_size[abi:ne180100]<MachProcess::mach_o_segment*,MachProcess::mach_o_segment*>((void *)(a1 + 32), *(void *)(a2 + 32), *(void *)(a2 + 40), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v5;
  }
  unint64_t v6 = (std::string *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return a1;
}

void sub_10004BE30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0)
  {
    operator delete(*v3);
    long long v5 = (void **)*v2;
    if (!*v2) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    long long v5 = (void **)*v2;
    if (!*v2) {
      goto LABEL_3;
    }
  }
  unint64_t v6 = *(void ***)(v1 + 40);
  long long v7 = v5;
  if (v6 != v5)
  {
    do
    {
      if (*((char *)v6 - 65) < 0) {
        operator delete(*(v6 - 11));
      }
      v6 -= 11;
    }
    while (v6 != v5);
    long long v7 = *v2;
  }
  *(void *)(v1 + 40) = v5;
  operator delete(v7);
  _Unwind_Resume(exception_object);
}

void std::vector<MachProcess::mach_o_segment>::__init_with_size[abi:ne180100]<MachProcess::mach_o_segment*,MachProcess::mach_o_segment*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x2E8BA2E8BA2E8BBLL) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = (char *)operator new(88 * a4);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[88 * a4];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v11 = (std::string *)&v8[v9];
        uint64_t v12 = a2 + v9;
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v12, *(void *)(v12 + 8));
        }
        else
        {
          *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)v12;
          v11->__r_.__value_.__r.__words[2] = *(void *)(v12 + 16);
        }
        uint64_t v10 = &v8[v9];
        *(_OWORD *)(v10 + 24) = *(_OWORD *)(a2 + v9 + 24);
        *(_OWORD *)(v10 + 40) = *(_OWORD *)(a2 + v9 + 40);
        *(_OWORD *)(v10 + 56) = *(_OWORD *)(a2 + v9 + 56);
        *(_OWORD *)(v10 + 72) = *(_OWORD *)(a2 + v9 + 72);
        v9 += 88;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    a1[1] = v8;
  }
}

void sub_10004BFC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void ***std::__exception_guard_exceptions<std::vector<MachProcess::mach_o_segment>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    size_t v2 = *a1;
    unint64_t v3 = (void **)**a1;
    if (v3)
    {
      long long v4 = (void **)v2[1];
      long long v5 = **a1;
      if (v4 != v3)
      {
        do
        {
          if (*((char *)v4 - 65) < 0) {
            operator delete(*(v4 - 11));
          }
          v4 -= 11;
        }
        while (v4 != v3);
        long long v5 = **a1;
      }
      v2[1] = v3;
      operator delete(v5);
    }
  }
  return a1;
}

uint64_t std::__split_buffer<MachProcess::binary_image_information>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(void *)(a1 + 16) = i - 160;
    std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](v4, i - 160);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 151) < 0)
  {
    operator delete(*(void **)(a2 + 128));
    if ((*(char *)(a2 + 127) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v3 = *(void ***)(a2 + 64);
      if (!v3) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((*(char *)(a2 + 127) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a2 + 104));
  uint64_t v3 = *(void ***)(a2 + 64);
  if (!v3)
  {
LABEL_4:
    if ((*(char *)(a2 + 23) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_15;
  }
LABEL_8:
  uint64_t v4 = *(void ***)(a2 + 72);
  long long v5 = v3;
  if (v4 != v3)
  {
    do
    {
      if (*((char *)v4 - 65) < 0) {
        operator delete(*(v4 - 11));
      }
      v4 -= 11;
    }
    while (v4 != v3);
    long long v5 = *(void ***)(a2 + 64);
  }
  *(void *)(a2 + 72) = v3;
  operator delete(v5);
  if (*(char *)(a2 + 23) < 0)
  {
LABEL_15:
    unint64_t v6 = *(void **)a2;
    operator delete(v6);
  }
}

void *std::vector<MachException::Message>::__push_back_slow_path<MachException::Message const&>(void **a1, void *a2)
{
  uint64_t v4 = (char *)*a1;
  uint64_t v3 = (char *)a1[1];
  uint64_t v5 = 0x77A9AF922545A3CDLL * ((v3 - (unsigned char *)*a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x1F6310ACA0DBB5) {
    std::vector<kevent>::__throw_length_error[abi:ne180100]();
  }
  if (0xEF535F244A8B479ALL * (((unsigned char *)a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0xEF535F244A8B479ALL * (((unsigned char *)a1[2] - v4) >> 3);
  }
  if ((unint64_t)(0x77A9AF922545A3CDLL * (((unsigned char *)a1[2] - v4) >> 3)) >= 0xFB18856506DDALL) {
    unint64_t v8 = 0x1F6310ACA0DBB5;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0x1F6310ACA0DBB5) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(2088 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[2088 * v5];
  uint64_t v11 = &v9[2088 * v8];
  memcpy(v10, a2, 0x80CuLL);
  *((void *)v10 + 258) = 0;
  *((void *)v10 + 260) = 0;
  *((void *)v10 + 259) = 0;
  uint64_t v12 = (unsigned char *)a2[258];
  uint64_t v13 = (unsigned char *)a2[259];
  int64_t v14 = v13 - v12;
  if (v13 != v12)
  {
    long long v15 = (char **)(v10 + 2072);
    if (v14 < 0) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    long long v16 = (char *)operator new(v13 - v12);
    *((void *)v10 + 258) = v16;
    const char *v15 = v16;
    uint64_t v17 = &v16[8 * (v14 >> 3)];
    *((void *)v10 + 260) = v17;
    memcpy(v16, v12, v14);
    const char *v15 = v17;
  }
  long long v18 = v10 + 2088;
  unint64_t v26 = v10 + 2088;
  if (v3 == v4)
  {
    uint64_t v23 = v3;
  }
  else
  {
    uint64_t v19 = 0;
    do
    {
      long long v20 = &v10[v19];
      long long v21 = &v3[v19];
      memcpy(&v10[v19 - 2088], &v3[v19 - 2088], 0x800uLL);
      int v22 = *(_DWORD *)&v3[v19 - 32];
      *((void *)v20 - 5) = *(void *)&v3[v19 - 40];
      *((_DWORD *)v20 - 8) = v22;
      *((void *)v20 - 2) = 0;
      *((void *)v20 - 1) = 0;
      *(_OWORD *)(v20 - 24) = *(_OWORD *)&v3[v19 - 24];
      *((void *)v20 - 1) = *(void *)&v3[v19 - 8];
      *((void *)v21 - 3) = 0;
      *((void *)v21 - 2) = 0;
      *((void *)v21 - 1) = 0;
      v19 -= 2088;
    }
    while (&v3[v19] != v4);
    uint64_t v23 = (char *)*a1;
    uint64_t v3 = (char *)a1[1];
    v10 += v19;
    long long v18 = v26;
  }
  *a1 = v10;
  a1[1] = v18;
  a1[2] = v11;
  if (v3 == v23)
  {
    if (v3) {
LABEL_21:
    }
      operator delete(v3);
  }
  else
  {
    do
    {
      uint64_t v25 = (void *)*((void *)v3 - 3);
      if (v25)
      {
        *((void *)v3 - 2) = v25;
        operator delete(v25);
      }
      v3 -= 2088;
    }
    while (v3 != v23);
    uint64_t v3 = v23;
    if (v23) {
      goto LABEL_21;
    }
  }
  return v18;
}

void sub_10004C408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v5 = *v2;
  if (*v2)
  {
    *uint64_t v3 = v5;
    operator delete(v5);
  }
  std::__split_buffer<MachException::Message>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<MachException::Message>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v4 = v2 - 2088;
        *(void *)(a1 + 16) = v2 - 2088;
        uint64_t v5 = *(void **)(v2 - 24);
        if (!v5) {
          break;
        }
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 2088;
    }
    while (v4 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void MachTask::MachTask(MachTask *this, MachProcess *a2)
{
  *(void *)this = off_100069640;
  *((void *)this + 1) = a2;
  *((_DWORD *)this + 4) = 0;
  MachVMMemory::MachVMMemory((MachTask *)((char *)this + 24));
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *(void *)((char *)this + 302) = 0;
  *((void *)this + 39) = (char *)this + 320;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
}

void *MachTask::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this + 37;
  if (this[37]) {
    this = (void *)MachTask::ShutDownExcecptionThread((MachTask *)this);
  }
  *((_DWORD *)v1 + 4) = 0;
  void *v2 = 0;
  *(void *)((char *)v2 + 6) = 0;
  return this;
}

void MachTask::~MachTask(MachTask *this)
{
  *(void *)this = off_100069640;
  if (*((void *)this + 37)) {
    MachTask::ShutDownExcecptionThread(this);
  }
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 37) = 0;
  *(void *)((char *)this + 302) = 0;
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy((uint64_t)this + 312, *((void **)this + 40));
  MachVMMemory::~MachVMMemory((void **)this + 3);
}

{
  uint64_t vars8;

  *(void *)this = off_100069640;
  if (*((void *)this + 37)) {
    MachTask::ShutDownExcecptionThread(this);
  }
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 37) = 0;
  *(void *)((char *)this + 302) = 0;
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy((uint64_t)this + 312, *((void **)this + 40));
  MachVMMemory::~MachVMMemory((void **)this + 3);

  operator delete();
}

uint64_t MachTask::Suspend(MachTask *this)
{
  *(_OWORD *)timeval __p = 0u;
  long long v7 = 0u;
  task_read_t v1 = *((_DWORD *)this + 4);
  __p[0] = (void *)(task_suspend(v1) | 0x100000000);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v7) = 0;
  BOOL v2 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 != 1) {
    return 0;
  }
  DNBError::LogThreaded((DNBError *)__p, "::task_suspend(target_task = 0x%4.4x)", v1);
  uint64_t v4 = LODWORD(__p[0]);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  return v4;
}

void sub_10004C708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::Resume(MachTask *this, uint64_t a2, task_basic_info *a3)
{
  int v3 = (MachTask *)*((unsigned int *)this + 4);
  if (!v3) {
    return 4;
  }
  *(_OWORD *)timeval __p = 0u;
  long long v13 = 0u;
  LODWORD(__p[0]) = MachTask::BasicInfo(v3, task_info_out, a3);
  HIDWORD(__p[0]) = 1;
  LOBYTE(__p[1]) = 0;
  HIBYTE(v13) = 0;
  if (LODWORD(__p[0])) {
    return LODWORD(__p[0]);
  }
  integer_t v6 = task_info_out[0];
  if (*((unsigned char *)this + 309) && task_info_out[0] == 2)
  {
    __p[0] = (void *)(task_resume((task_read_t)v3) | 0x100000000);
    if (SHIBYTE(v13) < 0)
    {
      *(unsigned char *)__p[1] = 0;
      *(void *)&long long v13 = 0;
    }
    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v13) = 0;
    }
    BOOL v7 = DNBLogCheckLogBit(0x2000);
    if (LODWORD(__p[0])) {
      int v8 = 1;
    }
    else {
      int v8 = v7;
    }
    if (v8 == 1) {
      DNBError::LogThreaded((DNBError *)__p, "::task_resume double-resume after exec-start-stopped(target_task = 0x%4.4x)", v3);
    }
    integer_t v6 = task_info_out[0];
  }
  *((unsigned char *)this + 309) = 0;
  if (v6 >= 1)
  {
    __p[0] = (void *)(task_resume((task_read_t)v3) | 0x100000000);
    if (SHIBYTE(v13) < 0)
    {
      *(unsigned char *)__p[1] = 0;
      *(void *)&long long v13 = 0;
    }
    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v13) = 0;
    }
    BOOL v9 = DNBLogCheckLogBit(0x2000);
    int v10 = LODWORD(__p[0]) || v9;
    if (v10 == 1) {
      DNBError::LogThreaded((DNBError *)__p, "::task_resume(target_task = 0x%4.4x)", v3);
    }
  }
  uint64_t v5 = LODWORD(__p[0]);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[1]);
  }
  return v5;
}

void sub_10004C888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::BasicInfo(MachTask *this, task_info_t task_info_out, task_basic_info *a3)
{
  if (!task_info_out) {
    return 4;
  }
  int v4 = (int)this;
  *(_OWORD *)timeval __p = 0u;
  long long v17 = 0u;
  mach_msg_type_number_t task_info_outCnt = 10;
  unsigned int v5 = task_info((task_name_t)this, 0x12u, task_info_out, &task_info_outCnt);
  __p[0] = (void *)(v5 | 0x100000000);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v17) = 0;
  BOOL v6 = DNBLogCheckLogBit(0x2000);
  if (v5) {
    int v7 = 1;
  }
  else {
    int v7 = v6;
  }
  if (v7 == 1) {
    DNBError::LogThreaded((DNBError *)__p, "::task_info(target_task = 0x%4.4x, flavor = TASK_BASIC_INFO, task_info_out => %p, task_info_outCnt => %u)", v4, task_info_out, task_info_outCnt);
  }
  if (DNBLogCheckLogBit(0x2000))
  {
    BOOL v8 = DNBLogCheckLogBit(1);
    if (!LODWORD(__p[0]) && v8)
    {
      int v10 = task_info_out[5];
      int v11 = task_info_out[6];
      if (DNBLogEnabled())
      {
        double v14 = (float)((float)((float)v11 / 1000000.0) + (float)v10);
        _DNBLogThreaded("task_basic_info = { suspend_count = %i, virtual_std::string::size_type size = 0x%8.8llx, resident_std::string::size_type size = 0x%8.8llx, user_time = %f, system_time = %f }", *task_info_out, *(void *)(task_info_out + 1), *(void *)(task_info_out + 3), v14, v14);
      }
    }
  }
  uint64_t v12 = LODWORD(__p[0]);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[1]);
  }
  return v12;
}

void sub_10004C9E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::ShutDownExcecptionThread(MachTask *this)
{
  *(_OWORD *)timeval __p = 0u;
  long long v14 = 0u;
  LODWORD(__p[0]) = MachException::PortInfo::Restore((MachTask *)((char *)this + 64), *((_DWORD *)this + 4));
  HIDWORD(__p[0]) = 1;
  LOBYTE(__p[1]) = 0;
  HIBYTE(v14) = 0;
  mach_port_name_t v2 = *((_DWORD *)this + 76);
  int v3 = (_opaque_pthread_t *)*((void *)this + 37);
  *((_DWORD *)this + 76) = 0;
  __p[0] = (void *)(pthread_cancel(v3) | 0x200000000);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v14) = 0;
  BOOL v4 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v5 = 1;
  }
  else {
    int v5 = v4;
  }
  if (v5 == 1) {
    DNBError::LogThreaded((DNBError *)__p, "::pthread_cancel(thread = %p)", *((const void **)this + 37));
  }
  __p[0] = (void *)(pthread_join(*((pthread_t *)this + 37), 0) | 0x200000000);
  if (SHIBYTE(v14) < 0)
  {
    *(unsigned char *)__p[1] = 0;
    *(void *)&long long v14 = 0;
  }
  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v14) = 0;
  }
  BOOL v6 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v7 = 1;
  }
  else {
    int v7 = v6;
  }
  if (v7 == 1) {
    DNBError::LogThreaded((DNBError *)__p, "::pthread_join(thread = %p, value_ptr = NULL)", *((const void **)this + 37));
  }
  mach_port_t v8 = mach_task_self_;
  __p[0] = (void *)(mach_port_deallocate(mach_task_self_, v2) | 0x100000000);
  if (SHIBYTE(v14) < 0)
  {
    *(unsigned char *)__p[1] = 0;
    *(void *)&long long v14 = 0;
  }
  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v14) = 0;
  }
  BOOL v9 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v10 = 1;
  }
  else {
    int v10 = v9;
  }
  if (v10 == 1)
  {
    DNBError::LogThreaded((DNBError *)__p, "::mach_port_deallocate(task = 0x%4.4x, name = 0x%4.4x)", v8, v2);
    uint64_t v11 = LODWORD(__p[0]);
  }
  else
  {
    uint64_t v11 = 0;
  }
  *((_WORD *)this + 154) = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  return v11;
}

void sub_10004CBAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t MachTask::ReadMemory(MachTask *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  task_name_t v5 = *((_DWORD *)this + 4);
  if (!v5) {
    return 0;
  }
  unint64_t v8 = MachVMMemory::Read((vm_size_t *)this + 3, v5, a2, a4, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded("MachTask::ReadMemory(addr = 0x%8.8llx, std::string::size_type size = %llu, buf = %p) => %llu bytes read", a2, a3, a4, v8);
  }
  if (DNBLogCheckLogBit(128) || (BOOL v9 = DNBLogCheckLogBit(64), a3 <= 8) && v9)
  {
    DNBDataRef::DNBDataRef((DNBDataRef *)v11, (const unsigned __int8 *)a4, v8, 0);
    DNBDataRef::Dump(v11, 0, v8, a2, 0, 0x10u, 0);
    DNBDataRef::~DNBDataRef((DNBDataRef *)v11);
  }
  return v8;
}

void sub_10004CCAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  DNBDataRef::~DNBDataRef((DNBDataRef *)va);
  _Unwind_Resume(a1);
}

unint64_t MachTask::WriteMemory(MachTask *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  task_name_t v5 = *((_DWORD *)this + 4);
  if (!v5) {
    return 0;
  }
  unint64_t v8 = MachVMMemory::Write((vm_size_t *)this + 3, v5, a2, a4, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded("MachTask::WriteMemory(addr = 0x%8.8llx, std::string::size_type size = %llu, buf = %p) => %llu bytes written", a2, a3, a4, v8);
  }
  if (DNBLogCheckLogBit(128) || (BOOL v9 = DNBLogCheckLogBit(64), a3 <= 8) && v9)
  {
    DNBDataRef::DNBDataRef((DNBDataRef *)v11, (const unsigned __int8 *)a4, v8, 0);
    DNBDataRef::Dump(v11, 0, v8, a2, 0, 0x10u, 0);
    DNBDataRef::~DNBDataRef((DNBDataRef *)v11);
  }
  return v8;
}

void sub_10004CD9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  DNBDataRef::~DNBDataRef((DNBDataRef *)va);
  _Unwind_Resume(a1);
}

uint64_t MachTask::GetMemoryRegionInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t MemoryRegionInfo = MachVMMemory::GetMemoryRegionInfo(a1 + 24, v4, a2, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded("MachTask::MemoryRegionInfo(addr = 0x%8.8llx) => %i  (start = 0x%8.8llx, std::string::size_type size = 0x%8.8llx, permissions = %u)", a2, MemoryRegionInfo, *(void *)a3, *(void *)(a3 + 8), *(_DWORD *)(a3 + 16));
  }
  return MemoryRegionInfo;
}

void MachTask::GetProfileData(uint64_t a1@<X0>, __int16 a2@<W1>, task_basic_info *a3@<X2>, void **a4@<X8>)
{
  __int16 v4 = a2;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if ((a2 & 1) == 0
    || ((buffer.tv_sec = 0x1900000006, size_t v105 = 4, MachTask::GetProfileData(DNBProfileDataScanType)::numCPU != -1)
     || !sysctl((int *)&buffer, 2u, &MachTask::GetProfileData(DNBProfileDataScanType)::numCPU, &v105, 0, 0))
    && (mach_port_t v7 = mach_host_self(),
        LODWORD(host_info_outCnt) = 4,
        !host_statistics(v7, 3, &host_info_out, (mach_msg_type_number_t *)&host_info_outCnt)))
  {
    unint64_t v8 = (MachTask *)*(unsigned int *)(a1 + 16);
    if (v8)
    {
      task_inspect_t target_task = *(_DWORD *)(a1 + 16);
      int pid = **(_DWORD **)(a1 + 8);
      if (!MachTask::BasicInfo(v8, (task_info_t)task_info_out, a3))
      {
        uint64_t v100 = a4;
        if ((v4 & 2) != 0) {
          gettimeofday(&buffer, 0);
        }
        long long v124 = 0;
        uint64_t v123 = 0;
        char v125 = 0;
        BOOL v121 = 0;
        unint64_t v120 = 0;
        unint64_t v122 = 0;
        long long v118 = 0;
        int64_t v117 = 0;
        int v119 = 0;
        __int16 v102 = v4;
        if ((v4 & 4) != 0)
        {
          thread_act_array_t act_list = 0;
          act_listCnt[0] = 0;
          if (!task_threads(target_task, &act_list, act_listCnt))
          {
            if (act_listCnt[0])
            {
              unint64_t v9 = 0;
              int v10 = 0;
              uint64_t v11 = 0;
              uint64_t v99 = 0;
              while (1)
              {
                thread_info_outCnt[0] = 6;
                if (thread_info(act_list[v11], 4u, (thread_info_t)&host_info_outCnt, thread_info_outCnt)) {
                  goto LABEL_18;
                }
                thread_info_outCnt[0] = 10;
                if (thread_info(act_list[v11], 3u, (thread_info_t)&v105, thread_info_outCnt)) {
                  goto LABEL_18;
                }
                if ((v107 & 2) == 0) {
                  break;
                }
LABEL_17:
                mach_port_deallocate(mach_task_self_, act_list[v11]);
LABEL_18:
                if (++v11 >= (unint64_t)act_listCnt[0])
                {
                  mach_vm_size_t v66 = 4 * act_listCnt[0];
                  __int16 v4 = v102;
                  goto LABEL_101;
                }
              }
              uint64_t GloballyUniqueThreadIDForMachPortID = MachThread::GetGloballyUniqueThreadIDForMachPortID((MachThread *)act_list[v11]);
              uint64_t v14 = GloballyUniqueThreadIDForMachPortID;
              long long v15 = v124;
              unint64_t v101 = v9;
              if (v124 >= v125)
              {
                long long v17 = (uint64_t *)v123;
                int64_t v18 = (char *)v124 - (unsigned char *)v123;
                uint64_t v19 = ((char *)v124 - (unsigned char *)v123) >> 3;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 61) {
                  goto LABEL_167;
                }
                uint64_t v21 = (char *)v125 - (unsigned char *)v123;
                if (((char *)v125 - (unsigned char *)v123) >> 2 > v20) {
                  unint64_t v20 = v21 >> 2;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22)
                {
                  if (v22 >> 61) {
                    goto LABEL_166;
                  }
                  uint64_t v23 = (char *)operator new(8 * v22);
                }
                else
                {
                  uint64_t v23 = 0;
                }
                int v24 = (uint64_t *)&v23[8 * v19];
                uint64_t *v24 = v14;
                long long v16 = v24 + 1;
                if (v15 != v17)
                {
                  unint64_t v25 = (char *)v15 - (char *)v17 - 8;
                  if (v25 < 0x58) {
                    goto LABEL_171;
                  }
                  if ((unint64_t)((char *)v15 - v23 - v18) < 0x20) {
                    goto LABEL_171;
                  }
                  uint64_t v26 = (v25 >> 3) + 1;
                  uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
                  uint64_t v28 = &v15[v27 / 0xFFFFFFFFFFFFFFF8];
                  int v24 = (uint64_t *)((char *)v24 - v27);
                  uint64_t v29 = &v23[8 * v19 - 16];
                  pid_t v30 = v15 - 2;
                  uint64_t v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v32 = *(_OWORD *)v30;
                    *((_OWORD *)v29 - 1) = *((_OWORD *)v30 - 1);
                    *(_OWORD *)uint64_t v29 = v32;
                    v29 -= 32;
                    v30 -= 4;
                    v31 -= 4;
                  }
                  while (v31);
                  long long v15 = v28;
                  if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_171:
                    do
                    {
                      uint64_t v33 = *--v15;
                      *--int v24 = v33;
                    }
                    while (v15 != v17);
                  }
                }
                uint64_t v123 = v24;
                char v125 = (uint64_t *)&v23[8 * v22];
                if (v17) {
                  operator delete(v17);
                }
              }
              else
              {
                *long long v124 = GloballyUniqueThreadIDForMachPortID;
                long long v16 = v15 + 1;
              }
              long long v124 = v16;
              if ((v102 & 8) != 0 && arg)
              {
                if (proc_pidinfo(pid, 5, arg, &buffer, 112) && LOBYTE(v134[0]))
                {
                  size_t v34 = strlen((const char *)v134);
                  if (v34 >= 0x7FFFFFFFFFFFFFF8) {
                    std::string::__throw_length_error[abi:ne180100]();
                  }
                  size_t v35 = v34;
                  if (v34 >= 0x17)
                  {
                    uint64_t v41 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v34 | 7) != 0x17) {
                      uint64_t v41 = v34 | 7;
                    }
                    uint64_t v42 = v41 + 1;
                    p_p = (long long *)operator new(v41 + 1);
                    *((void *)&__p + 1) = v35;
                    unint64_t v116 = v42 | 0x8000000000000000;
                    *(void *)&long long __p = p_p;
                  }
                  else
                  {
                    HIBYTE(v116) = v34;
                    p_p = &__p;
                    if (!v34) {
                      goto LABEL_64;
                    }
                  }
                  memcpy(p_p, v134, v35);
LABEL_64:
                  *((unsigned char *)p_p + v35) = 0;
                  posix_spawn_file_actions_t v43 = v121;
                  if ((unint64_t)v121 >= v122)
                  {
                    BOOL v121 = std::vector<std::string>::__push_back_slow_path<std::string>(&v120, (uint64_t)&__p);
                    if (SHIBYTE(v116) < 0) {
                      operator delete((void *)__p);
                    }
                  }
                  else
                  {
                    long long v44 = __p;
                    *((void *)v121 + 2) = v116;
                    _OWORD *v43 = v44;
                    BOOL v121 = (char *)v43 + 24;
                  }
                  int v10 = v118;
                  uint64_t v99 = v119;
                  unint64_t v9 = (unint64_t)v119;
                  goto LABEL_69;
                }
                HIBYTE(v116) = 0;
                LOBYTE(__p) = 0;
                size_t v39 = v121;
                if ((unint64_t)v121 >= v122)
                {
                  BOOL v121 = std::vector<std::string>::__push_back_slow_path<std::string>(&v120, (uint64_t)&__p);
                  if (SHIBYTE(v116) < 0) {
                    operator delete((void *)__p);
                  }
                }
                else
                {
                  long long v40 = __p;
                  *((void *)v121 + 2) = v116;
                  *size_t v39 = v40;
                  BOOL v121 = (char *)v39 + 24;
                }
                unint64_t v9 = (unint64_t)v99;
              }
              else
              {
                BYTE7(v132) = 0;
                LOBYTE(buffer.tv_sec) = 0;
                BOOL v37 = v121;
                if ((unint64_t)v121 >= v122)
                {
                  unint64_t v9 = v101;
                  BOOL v121 = std::vector<std::string>::__push_back_slow_path<std::string>(&v120, (uint64_t)&buffer);
                  if (SBYTE7(v132) < 0) {
                    operator delete((void *)buffer.tv_sec);
                  }
                }
                else
                {
                  timeval v38 = buffer;
                  *((void *)v121 + 2) = v132;
                  *BOOL v37 = v38;
                  BOOL v121 = (char *)v37 + 24;
                  unint64_t v9 = v101;
                }
              }
LABEL_69:
              uint64_t v45 = v106[0] + (uint64_t)(int)v105;
              int v46 = v106[1] + HIDWORD(v105);
              if (v106[1] + HIDWORD(v105) > 999999)
              {
                int v46 = v106[1] + HIDWORD(v105) - 1000000;
                ++v45;
              }
              uint64_t v47 = 1000000 * v45 + v46;
              if ((unint64_t)v10 < v9)
              {
                *(void *)int v10 = v47;
                uint64_t v12 = v10 + 8;
LABEL_16:
                long long v118 = v12;
                int v10 = v12;
                goto LABEL_17;
              }
              long long v48 = (char *)v117;
              int64_t v49 = v10 - (unsigned char *)v117;
              uint64_t v50 = (v10 - (unsigned char *)v117) >> 3;
              unint64_t v51 = v50 + 1;
              if ((unint64_t)(v50 + 1) >> 61) {
LABEL_167:
              }
                std::vector<kevent>::__throw_length_error[abi:ne180100]();
              if ((uint64_t)(v9 - (void)v117) >> 2 > v51) {
                unint64_t v51 = (uint64_t)(v9 - (void)v117) >> 2;
              }
              if (v9 - (unint64_t)v117 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v51;
              }
              if (v52)
              {
                if (v52 >> 61) {
LABEL_166:
                }
                  std::__throw_bad_array_new_length[abi:ne180100]();
                uint64_t v53 = operator new(8 * v52);
              }
              else
              {
                uint64_t v53 = 0;
              }
              id v54 = (uint64_t *)&v53[8 * v50];
              *id v54 = v47;
              uint64_t v12 = (char *)(v54 + 1);
              if (v10 != v48)
              {
                unint64_t v55 = v10 - v48 - 8;
                if (v55 >= 0x168)
                {
                  unint64_t v59 = (v10 - 8 - v48) & 0xFFFFFFFFFFFFFFF8;
                  if (&v53[v49 - 8 - v59] > &v53[v49 - 8])
                  {
                    uint64_t v56 = v10;
                  }
                  else if (&v10[-v59 - 8] > v10 - 8)
                  {
                    uint64_t v56 = v10;
                  }
                  else if ((unint64_t)(v10 - v53 - v49) >= 0x20)
                  {
                    uint64_t v60 = (v55 >> 3) + 1;
                    uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
                    uint64_t v56 = &v10[-v61];
                    id v54 = (uint64_t *)((char *)v54 - v61);
                    uint64_t v62 = &v53[8 * v50 - 16];
                    id v63 = v10 - 16;
                    uint64_t v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v65 = *(_OWORD *)v63;
                      *(v62 - 1) = *((_OWORD *)v63 - 1);
                      _OWORD *v62 = v65;
                      v62 -= 2;
                      v63 -= 32;
                      v64 -= 4;
                    }
                    while (v64);
                    if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_86;
                    }
                  }
                  else
                  {
                    uint64_t v56 = v10;
                  }
                }
                else
                {
                  uint64_t v56 = v10;
                }
                do
                {
                  uint64_t v57 = *((void *)v56 - 1);
                  v56 -= 8;
                  *--id v54 = v57;
                }
                while (v56 != v48);
              }
LABEL_86:
              dispatch_semaphore_t v58 = &v53[8 * v52];
              int64_t v117 = v54;
              int v119 = v58;
              uint64_t v99 = v58;
              if (v48) {
                operator delete(v48);
              }
              unint64_t v9 = (unint64_t)v58;
              goto LABEL_16;
            }
            mach_vm_size_t v66 = 0;
LABEL_101:
            mach_vm_deallocate(mach_task_self_, (mach_vm_address_t)act_list, v66);
          }
        }
        thread_act_array_t act_list = 0;
        *(void *)thread_info_outCnt = 0;
        *(void *)act_listCnt = 0;
        uint64_t v112 = 0;
        v110[0] = task_info_out[0];
        v110[1] = task_info_out[1];
        uint64_t v111 = v127;
        int CPUType = MachProcess::GetCPUType(*(MachProcess **)(a1 + 8));
        if (MachVMMemory::GetMemoryProfile((int)a1 + 24, v4, target_task, (int)v110, CPUType, pid, (host_info64_t)&__p, &act_list, act_listCnt, thread_info_outCnt, &v112))
        {
          std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v105);
          if (v4)
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"num_cpu:", 8);
            id v68 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)&buffer, 1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"host_user_ticks:", 16);
            unsigned int v69 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v69, (uint64_t)&buffer, 1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"host_sys_ticks:", 15);
            int v70 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v70, (uint64_t)&buffer, 1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"host_idle_ticks:", 16);
            uint64_t v71 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v71, (uint64_t)&buffer, 1);
          }
          if ((v4 & 2) != 0)
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"elapsed_usec:", 13);
            long long v72 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v72, (uint64_t)&buffer, 1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"task_used_usec:", 15);
            uint64_t v73 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)&buffer, 1);
          }
          if ((v4 & 4) != 0 && v124 != v123)
          {
            uint64_t v74 = 0;
            if ((unint64_t)(((char *)v124 - (unsigned char *)v123) >> 3) <= 1) {
              uint64_t v75 = 1;
            }
            else {
              uint64_t v75 = ((char *)v124 - (unsigned char *)v123) >> 3;
            }
            uint64_t v76 = "thread_used_usec:";
            do
            {
              uint64_t v77 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"thread_used_id:", 15);
              *(_DWORD *)((char *)v77 + *(void *)(*v77 - 24) + 8) = *(_DWORD *)((unsigned char *)v77
                                                                                  + *(void *)(*v77 - 24)
                                                                                  + 8) & 0xFFFFFFB5 | 8;
              unsigned int v78 = (void *)std::ostream::operator<<();
              *(_DWORD *)((char *)v78 + *(void *)(*v78 - 24) + 8) = *(_DWORD *)((unsigned char *)v78
                                                                                  + *(void *)(*v78 - 24)
                                                                                  + 8) & 0xFFFFFFB5 | 2;
              LOBYTE(buffer.tv_sec) = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v78, (uint64_t)&buffer, 1);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)v76, 17);
              long long v79 = (void *)std::ostream::operator<<();
              LOBYTE(buffer.tv_sec) = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v79, (uint64_t)&buffer, 1);
              if ((v4 & 8) == 0) {
                goto LABEL_115;
              }
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"thread_used_name:", 17);
              uint64_t v80 = v76;
              uint64_t v81 = (char *)v120 + 24 * v74;
              if (v81[23] < 0)
              {
                uint64_t v82 = *((void *)v81 + 1);
                if (v82)
                {
                  uint64_t v81 = *(char **)v81;
LABEL_122:
                  size_t v83 = v105;
                  uint64_t v84 = (char *)&v106[-2] + *(void *)(v105 - 24);
                  if (*((_DWORD *)v84 + 36) == -1)
                  {
                    std::ios_base::getloc((const std::ios_base *)((char *)&v106[-2] + *(void *)(v105 - 24)));
                    uint64_t v85 = std::locale::use_facet((const std::locale *)&buffer, &std::ctype<char>::id);
                    ((void (*)(const std::locale::facet *, uint64_t))v85->__vftable[2].~facet_0)(v85, 32);
                    std::locale::~locale((std::locale *)&buffer);
                    size_t v83 = v105;
                  }
                  *((_DWORD *)v84 + 36) = 48;
                  *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) = *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) & 0xFFFFFFB5 | 8;
                  *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) = *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) & 0xFFFFFF4F | 0x80;
                  *(void *)((char *)&v106[4] + *(void *)(v83 - 24)) = 2;
                  if (v82)
                  {
                    do
                    {
                      ++v81;
                      std::ostream::operator<<();
                      --v82;
                    }
                    while (v82);
                    size_t v83 = v105;
                  }
                  *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) = *(_DWORD *)((char *)v106 + *(void *)(v83 - 24)) & 0xFFFFFFB5 | 2;
                  int v86 = (const std::ios_base *)((char *)&v106[-2] + *(void *)(v83 - 24));
                  if (v86[1].__fmtflags_ == -1)
                  {
                    std::ios_base::getloc(v86);
                    char v87 = std::locale::use_facet((const std::locale *)&buffer, &std::ctype<char>::id);
                    ((void (*)(const std::locale::facet *, uint64_t))v87->__vftable[2].~facet_0)(v87, 32);
                    std::locale::~locale((std::locale *)&buffer);
                  }
                  v86[1].__fmtflags_ = 32;
                  __int16 v4 = v102;
                }
              }
              else
              {
                uint64_t v82 = v81[23];
                if (v81[23]) {
                  goto LABEL_122;
                }
              }
              LOBYTE(buffer.tv_sec) = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)&buffer, 1);
              uint64_t v76 = v80;
LABEL_115:
              ++v74;
            }
            while (v74 != v75);
          }
          if ((v4 & 0x20) != 0)
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"total:", 6);
            uint64_t v88 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v88, (uint64_t)&buffer, 1);
          }
          if ((v4 & 0x40) != 0)
          {
            {
              MachTask::GetProfileData(DNBProfileDataScanType)::pagestd::string::size_type size = vm_kernel_page_size;
            }
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"used:", 5);
            uint64_t v89 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v89, (uint64_t)&buffer, 1);
            if ((v4 & 0x100) != 0)
            {
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"anonymous:", 10);
              uint64_t v90 = (void *)std::ostream::operator<<();
              LOBYTE(buffer.tv_sec) = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)&buffer, 1);
            }
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"phys_footprint:", 15);
            uint64_t v91 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)&buffer, 1);
          }
          if (v4 < 0)
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"mem_cap:", 8);
            uint64_t v92 = (void *)std::ostream::operator<<();
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)&buffer, 1);
          }
          if ((v4 & 0x200) != 0 && !proc_pid_rusage(pid, 2, &host_info_outCnt))
          {
            mach_absolute_time();
            uint64_t v135 = 0;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            long long v133 = 0u;
            timeval buffer = (timeval)0;
            pm_sample_task_and_pid();
            *(_OWORD *)((char *)&v134[5] + 4) = v138;
            *(int8x16_t *)((char *)&v134[6] + 4) = vextq_s8(v139, v139, 8uLL);
            *(_OWORD *)((char *)&v134[16] + 8) = v141;
            *((void *)&v134[17] + 1) = v140;
            pm_energy_impact();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"energy:", 7);
            uint64_t v93 = (void *)std::ostream::operator<<();
            char v130 = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v93, (uint64_t)&v130, 1);
          }
          if ((v4 & 0x400) != 0)
          {
            LODWORD(buffer.tv_sec) = -1;
            LODWORD(host_info_outCnt) = -1;
            if (!proc_get_cpumon_params()
              && (buffer.tv_sec & 0x80000000) == 0
              && (host_info_outCnt & 0x80000000) == 0)
            {
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"cpu_cap_p:", 10);
              int v94 = (void *)std::ostream::operator<<();
              char v130 = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)&v130, 1);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"cpu_cap_t:", 10);
              char v95 = (void *)std::ostream::operator<<();
              char v130 = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)&v130, 1);
            }
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, (uint64_t)"--end--;", 8);
          std::stringbuf::str();
          if (*((char *)v100 + 23) < 0) {
            operator delete(*v100);
          }
          *(timeval *)uint64_t v100 = buffer;
          v100[2] = (void *)v132;
          if (v109 < 0) {
            operator delete(v108);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          std::ios::~ios();
        }
        if (v117) {
          operator delete(v117);
        }
        uint64_t v96 = (char *)v120;
        if (v120)
        {
          uint64_t v97 = v121;
          uint64_t v98 = v120;
          if (v121 != v120)
          {
            do
            {
              if (*(v97 - 1) < 0) {
                operator delete(*((void **)v97 - 3));
              }
              v97 -= 24;
            }
            while (v97 != v96);
            uint64_t v98 = v120;
          }
          BOOL v121 = v96;
          operator delete(v98);
        }
        if (v123) {
          operator delete(v123);
        }
      }
    }
  }
}

void sub_10004DF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *__p,uint64_t a63)
{
  if (a67 < 0) {
    operator delete(__p);
  }
  id v68 = (void *)STACK[0x240];
  if (STACK[0x240])
  {
    STACK[0x248] = (unint64_t)v68;
    operator delete(v68);
  }
  std::vector<std::string>::~vector[abi:ne180100]((void **)&STACK[0x258]);
  unsigned int v69 = (void *)STACK[0x270];
  if (STACK[0x270])
  {
    STACK[0x278] = (unint64_t)v69;
    operator delete(v69);
  }
  if (*(char *)(a16 + 23) < 0) {
    operator delete(*(void **)a16);
  }
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  *(void *)a1 = v3;
  *(void *)(a1 + *(void *)(v3 - 24)) = v2;
  __int16 v4 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v4, (void *)(a1 + 8));
  v4[1].__vftable = 0;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf();
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_10004E168(_Unwind_Exception *a1)
{
}

MachTask *MachTask::TaskPortForProcessID(MachTask *this, DNBError *a2, int a3)
{
  __n128 result = (MachTask *)*((unsigned int *)this + 4);
  if (result) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    BOOL v6 = (unsigned int *)*((void *)this + 1);
    if (v6)
    {
      __n128 result = MachTask::TaskPortForProcessID((MachTask *)*v6, (int)a2, (DNBError *)0xA, 0x2710u);
      *((_DWORD *)this + 4) = result;
    }
  }
  return result;
}

MachTask *MachTask::TaskPortForProcessID(MachTask *this, int a2, DNBError *a3, useconds_t a4)
{
  if (!this) {
    return 0;
  }
  unsigned int v5 = a3;
  *(_OWORD *)long long __p = 0u;
  long long v33 = 0u;
  mach_port_name_t v6 = mach_task_self_;
  mach_port_name_t v31 = 0;
  if (!a3)
  {
LABEL_26:
    BOOL v10 = 0;
    if ((SHIBYTE(v33) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  __int16 v4 = this;
  int v8 = 0;
  int v9 = (int)this;
  int v30 = (int)this;
  BOOL v10 = 1;
  while (1)
  {
    if (DNBLogEnabled())
    {
      uint64_t v11 = getpid();
      _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) about to task_for_pid(%d)", v12, v13, v14, v15, v16, v17, v11);
    }
    __p[0] = (void *)(task_for_pid(v6, (int)v4, &v31) | 0x100000000);
    if (SHIBYTE(v33) < 0)
    {
      *(unsigned char *)__p[1] = 0;
      *(void *)&long long v33 = 0;
    }
    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v33) = 0;
    }
    BOOL v18 = DNBLogCheckLogBit(0x2000);
    int v19 = (int)__p[0];
    int v20 = LODWORD(__p[0]) || v18;
    if (v20 != 1) {
      break;
    }
    if (DNBError::AsString((DNBError *)__p)) {
      uint64_t v21 = (const char *)DNBError::AsString((DNBError *)__p);
    }
    else {
      uint64_t v21 = "success";
    }
    snprintf(__str, 0x400uLL, "::task_for_pid(target_tport = 0x%4.4x, int pid = %d, &task) => err = 0x%8.8x (%s)", v6, v9, v19, v21);
    if (LODWORD(__p[0]))
    {
      if (__str[0])
      {
        std::string::assign((std::string *)&__p[1], __str);
      }
      else if (SHIBYTE(v33) < 0)
      {
        *(unsigned char *)__p[1] = 0;
        *(void *)&long long v33 = 0;
      }
      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v33) = 0;
      }
      if (DNBLogEnabled()) {
        _DNBLogError("[LaunchAttach] MachTask::TaskPortForProcessID task_for_pid(%d) failed: %s", v30, __str);
      }
    }
    DNBError::LogThreaded((DNBError *)__p, __str);
    if (!LODWORD(__p[0])) {
      break;
    }
    usleep(a4);
    BOOL v10 = ++v8 < v5;
    if (v5 == v8) {
      goto LABEL_26;
    }
  }
  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog(0, (uint64_t)"[LaunchAttach] (%d) successfully task_for_pid(%d)'ed", v24, v25, v26, v27, v28, v29, v23);
  }
  __int16 v4 = (MachTask *)v31;
  if (SHIBYTE(v33) < 0) {
LABEL_27:
  }
    operator delete(__p[1]);
LABEL_28:
  if (!v10) {
    return 0;
  }
  return v4;
}

void sub_10004E42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

MachTask *MachTask::IsValid(MachTask *this, unsigned int a2, task_basic_info *a3)
{
  if (this) {
    return (MachTask *)(MachTask::BasicInfo(this, task_info_out, a3) == 0);
  }
  return this;
}

BOOL MachTask::StartExceptionThread(uint64_t a1, int8x16_t **a2, uint64_t a3)
{
  kern_return_t v11;
  unsigned int *v12;
  BOOL result;
  kern_return_t inserted;
  _DWORD *v15;
  exception_mask_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  unint64_t v19;
  uint64_t v20;
  int8x16_t *v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t *v24;
  uint64_t v25;
  int8x16_t v26;
  __int32 v27;
  int v28;
  integer_t task_info_out[10];

  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s()", "StartExceptionThread");
  }
  int v8 = (MachTask *)*(unsigned int *)(a1 + 16);
  if (!v8
    && ((uint64_t v12 = *(unsigned int **)(a1 + 8)) == 0
     || (int v8 = MachTask::TaskPortForProcessID((MachTask *)*v12, v6, (DNBError *)0xA, 0x2710u),
         (*(_DWORD *)(a1 + 16) = v8) == 0))
    || MachTask::BasicInfo(v8, task_info_out, v7))
  {
    __n128 result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachTask::%s (): task invalid, exception thread start failed.", "StartExceptionThread");
    return 0;
  }
  mach_port_t v9 = mach_task_self_;
  BOOL v10 = (mach_port_name_t *)(a1 + 304);
  uint64_t v11 = mach_port_allocate(mach_task_self_, 1u, (mach_port_name_t *)(a1 + 304));
  *(_DWORD *)a3 = v11;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    if (*(_DWORD *)a3) {
      return 0;
    }
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
    if (v11) {
      return 0;
    }
  }
  inserted = mach_port_insert_right(v9, *v10, *v10, 0x14u);
  *(_DWORD *)a3 = inserted;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    if (!*(_DWORD *)a3) {
      goto LABEL_19;
    }
    return 0;
  }
  *(unsigned char *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 31) = 0;
  if (inserted) {
    return 0;
  }
LABEL_19:
  uint64_t v15 = (_DWORD *)(a1 + 64);
  MachException::PortInfo::Save((MachException::PortInfo *)(a1 + 64), *(_DWORD *)(a1 + 16));
  uint64_t v16 = *(_DWORD *)(a1 + 64);
  if (!v16)
  {
    std::string::assign((std::string *)(a3 + 8), "failed to get exception port info");
    return 0;
  }
  BOOL v18 = *a2;
  uint64_t v17 = a2[1];
  if (*a2 != v17)
  {
    int v19 = (char *)v17 - (char *)v18 - 4;
    if (v19 < 0x3C
      || v15 < (__int32 *)((char *)&v18->i32[1] + (v19 & 0xFFFFFFFFFFFFFFFCLL)) && (unint64_t)v18 < a1 + 68)
    {
      goto LABEL_41;
    }
    int v20 = (v19 >> 2) + 1;
    uint64_t v21 = (int8x16_t *)((char *)v18 + 4 * (v20 & 0x7FFFFFFFFFFFFFF8));
    v22.i64[0] = -1;
    v22.i64[1] = -1;
    v23.i32[1] = -1;
    v23.i64[1] = -1;
    v23.i32[0] = *(_DWORD *)(a1 + 64);
    uint64_t v24 = v18 + 1;
    uint64_t v25 = v20 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      uint64_t v23 = vbicq_s8(v23, v24[-1]);
      unint64_t v22 = vbicq_s8(v22, *v24);
      v24 += 2;
      v25 -= 8;
    }
    while (v25);
    uint64_t v26 = vandq_s8(v22, v23);
    *(int8x8_t *)v26.i8 = vand_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
    uint64_t v16 = v26.i32[0] & v26.i32[1];
    uint64_t *v15 = v26.i32[0] & v26.i32[1];
    BOOL v18 = v21;
    if (v20 != (v20 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_41:
      do
      {
        uint64_t v27 = v18->i32[0];
        BOOL v18 = (int8x16_t *)((char *)v18 + 4);
        v16 &= ~v27;
        uint64_t *v15 = v16;
      }
      while (v18 != v17);
    }
  }
  *(_DWORD *)a3 = task_set_exception_ports((task_t)v8, v16, *v10, -2147483647, 5);
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
  }
  if (DNBLogCheckLogBit(8) || *(_DWORD *)a3)
  {
    DNBError::LogThreaded((DNBError *)a3, "::task_set_exception_ports(task = 0x%4.4x, exception_mask = 0x%8.8x, new_port = 0x%4.4x, behavior = 0x%8.8x, new_flavor = 0x%8.8x)", v8, *v15, *v10, -2147483647, 5);
    if (*(_DWORD *)a3) {
      return 0;
    }
  }
  uint64_t v28 = pthread_create((pthread_t *)(a1 + 296), 0, (void *(__cdecl *)(void *))MachTask::ExceptionThread, (void *)a1);
  *(_DWORD *)a3 = v28;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(unsigned char **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v28 = *(_DWORD *)a3;
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 31) = 0;
  }
  return v28 == 0;
}

uint64_t MachTask::ExceptionThread(MachTask *this, void *a2)
{
  if (!this) {
    return 0;
  }
  uint64_t v3 = (MachProcess *)*((void *)this + 1);
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s(uint64_t arg = %p) starting thread...", "ExceptionThread", this);
  }
  pthread_setname_np("exception monitoring thread");
  int v21 = 0;
  __int16 v4 = pthread_self();
  if (!pthread_getschedparam(v4, &v21, &v22))
  {
    v22.sched_priority = 47;
    unsigned int v5 = pthread_self();
    pthread_setschedparam(v5, v21, &v22);
  }
  int v6 = (MachTask *)*((unsigned int *)this + 4);
  CFTypeRef cf = 0;
  if (MachProcess::ProcessUsingBackBoard(v3))
  {
    uint64_t v7 = BKSWatchdogAssertionCreateForPID();
    if (v7) {
      CFTypeRef cf = (CFTypeRef)v7;
    }
  }
  int v8 = 0;
  while ((*((_DWORD *)this + 76) - 1) <= 0xFFFFFFFD)
  {
    pthread_testcancel();
    long long __p = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    bzero(v24, 0x80CuLL);
    if (v8) {
      mach_msg_option_t v9 = 1282;
    }
    else {
      mach_msg_option_t v9 = 1026;
    }
    int v10 = MachException::Message::Receive(v24, *((_DWORD *)this + 76), v9, v8 != 0, 0);
    if (v10)
    {
      if (v10 == 268451843)
      {
        if (v8)
        {
          uint64_t v12 = (MachTask *)MachProcess::ExceptionMessageBundleComplete(v3);
          int v6 = v12;
          if (!v12 || MachTask::BasicInfo(v12, x, v13))
          {
            if (DNBLogEnabledForAny(8)) {
              _DNBLogThreaded("task has exited...");
            }
            MachProcess::SetState((uint64_t)v3, 9u);
            int v8 = 0;
            goto LABEL_44;
          }
          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("got a timeout, continuing...");
          }
          int v8 = 0;
        }
        goto LABEL_55;
      }
      if (v10 == 268451845)
      {
        if ((*((_DWORD *)this + 76) - 1) >= 0xFFFFFFFE)
        {
          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("thread cancelled...");
          }
          goto LABEL_44;
        }
        if (!v6 || MachTask::BasicInfo(v6, x, v11))
        {
          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("task has exited...");
          }
          MachProcess::SetState((uint64_t)v3, 9u);
          goto LABEL_44;
        }
        BOOL v18 = DNBLogEnabledForAny(8);
        uint64_t v15 = "interrupted, but task still valid, continuing...";
        if (!v18) {
          goto LABEL_55;
        }
LABEL_41:
        _DNBLogThreaded(v15);
      }
      else
      {
        BOOL v14 = DNBLogEnabledForAny(8);
        uint64_t v15 = "got some other error, do something about it??? nah, continuing for now...";
        if (v14) {
          goto LABEL_41;
        }
      }
LABEL_55:
      char v16 = 0;
      uint64_t v17 = __p;
      if (!__p) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    if (!MachException::Message::CatchExceptionRaise((MachException::Message *)v24, (int)v6)) {
      goto LABEL_55;
    }
    if (v25 != v6 && v25 && v26 && v27)
    {
      x[0] = -1;
      if (!pid_for_task(v25, x) && *(_DWORD *)v3 != x[0])
      {
        if (DNBLogEnabled()) {
          _DNBLogError("Got an exec mach message but the pid of the new task and the pid of the old task do not match, something is wrong.");
        }
LABEL_44:
        char v16 = 1;
        uint64_t v17 = __p;
        if (!__p) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("task port changed from 0x%4.4x to 0x%4.4x", v6, v25);
      }
      int v6 = (MachTask *)v25;
      *((_DWORD *)this + 4) = v25;
      *((unsigned char *)this + 309) = *((unsigned char *)this + 308);
      *((unsigned char *)this + 308) = 0;
    }
    MachProcess::ExceptionMessageReceived(v3, (const MachException::Message *)v24);
    char v16 = 0;
    ++v8;
    uint64_t v17 = __p;
    if (!__p) {
      goto LABEL_11;
    }
LABEL_10:
    uint64_t v29 = v17;
    operator delete(v17);
LABEL_11:
    if (v16) {
      break;
    }
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s (%p): thread exiting...", "ExceptionThread", this);
  }
  if (cf) {
    CFRelease(cf);
  }
  return 0;
}

void sub_10004EBA0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10004EBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  CFReleaser<BKSWatchdogAssertion *>::~CFReleaser((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *CFReleaser<BKSWatchdogAssertion *>::~CFReleaser(void *a1)
{
  *a1 = off_100069670;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  return a1;
}

uint64_t MachTask::GetDYLDAllImageInfosAddress(MachTask *this, DNBError *a2)
{
  kern_return_t v7;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[4];

  mach_msg_type_number_t task_info_outCnt = 4;
  task_name_t v4 = *((_DWORD *)this + 4);
  if (!v4)
  {
    unsigned int v5 = (unsigned int *)*((void *)this + 1);
    if (!v5)
    {
      task_name_t v4 = 0;
      if (*(_DWORD *)a2) {
        return -1;
      }
      goto LABEL_7;
    }
    task_name_t v4 = MachTask::TaskPortForProcessID((MachTask *)*v5, (int)a2, (DNBError *)0xA, 0x2710u);
    *((_DWORD *)this + 4) = v4;
  }
  if (*(_DWORD *)a2) {
    return -1;
  }
LABEL_7:
  uint64_t v7 = task_info(v4, 0x11u, task_info_out, &task_info_outCnt);
  *(_DWORD *)a2 = v7;
  *((_DWORD *)a2 + 1) = 1;
  if (*((char *)a2 + 31) < 0)
  {
    **((unsigned char **)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    uint64_t v7 = *(_DWORD *)a2;
  }
  else
  {
    *((unsigned char *)a2 + 8) = 0;
    *((unsigned char *)a2 + 31) = 0;
  }
  if (v7) {
    return -1;
  }
  else {
    return *(void *)task_info_out;
  }
}

mach_vm_address_t MachTask::AllocateMemory(MachTask *this, mach_vm_size_t size, unsigned int a3)
{
  vm_map_t v3 = *((_DWORD *)this + 4);
  if (!v3) {
    return -1;
  }
  mach_vm_address_t address = 0;
  if (mach_vm_allocate(v3, &address, size, 1)) {
    return -1;
  }
  if (mach_vm_protect(v3, address, size, 0, a3 & 4 | (__rbit32(a3) >> 30)))
  {
    mach_vm_deallocate(v3, address, size);
    return -1;
  }
  mach_vm_address_t v7 = address;
  mach_msg_option_t v9 = (uint64_t *)*((void *)this + 40);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v9;
        mach_vm_address_t v12 = v9[4];
        if (address >= v12) {
          break;
        }
        mach_msg_option_t v9 = *v11;
        int v10 = v11;
        if (!*v11) {
          goto LABEL_14;
        }
      }
      if (v12 >= address) {
        break;
      }
      mach_msg_option_t v9 = v11[1];
      if (!v9)
      {
        int v10 = v11 + 1;
        goto LABEL_14;
      }
    }
  }
  else
  {
    int v10 = (uint64_t **)((char *)this + 320);
    uint64_t v11 = (uint64_t **)((char *)this + 320);
LABEL_14:
    uint64_t v13 = (uint64_t *)operator new(0x30uLL);
    v13[4] = v7;
    v13[5] = size;
    *uint64_t v13 = 0;
    v13[1] = 0;
    std::locale v13[2] = (uint64_t)v11;
    *int v10 = v13;
    uint64_t v14 = **((void **)this + 39);
    if (v14)
    {
      *((void *)this + 39) = v14;
      uint64_t v15 = *v10;
    }
    else
    {
      uint64_t v15 = v13;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 40), v15);
    ++*((void *)this + 41);
    return address;
  }
  return v7;
}

BOOL MachTask::DeallocateMemory(MachTask *this, mach_vm_address_t a2)
{
  vm_map_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return 0;
  }
  vm_map_t v3 = (MachTask *)*((void *)this + 39);
  if (v3 == (MachTask *)((char *)this + 320)) {
    return 0;
  }
  unsigned int v5 = (uint64_t *)*((void *)this + 39);
  while (v5[4] != a2)
  {
    int v6 = (MachTask *)v5[1];
    if (v6)
    {
      do
      {
        mach_vm_address_t v7 = v6;
        int v6 = *(MachTask **)v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        mach_vm_address_t v7 = (MachTask *)v5[2];
        BOOL v8 = *(void *)v7 == (void)v5;
        unsigned int v5 = (uint64_t *)v7;
      }
      while (!v8);
    }
    unsigned int v5 = (uint64_t *)v7;
    if (v7 == (MachTask *)((char *)this + 320)) {
      return 0;
    }
  }
  int v10 = (uint64_t *)v5[1];
  if (v10)
  {
    do
    {
      uint64_t v11 = v10;
      int v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  else
  {
    mach_vm_address_t v12 = v5;
    do
    {
      uint64_t v11 = (uint64_t *)v12[2];
      BOOL v8 = *v11 == (void)v12;
      mach_vm_address_t v12 = v11;
    }
    while (!v8);
  }
  mach_vm_size_t v13 = v5[5];
  if (v3 == (MachTask *)v5) {
    *((void *)this + 39) = v11;
  }
  uint64_t v14 = (uint64_t *)*((void *)this + 40);
  --*((void *)this + 41);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v14, v5);
  operator delete(v5);
  if (!getenv("DEBUGSERVER_ZOMBIE_ALLOCATIONS")) {
    return mach_vm_deallocate(v2, a2, v13) == 0;
  }
  mach_vm_protect(v2, a2, v13, 0, 0);
  return 1;
}

void MachTask::ClearAllocations(MachTask *this)
{
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((void *)this + 39) = (char *)this + 320;
}

void CFReleaser<BKSWatchdogAssertion *>::~CFReleaser(void *a1)
{
  *a1 = off_100069670;
  vm_map_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }

  operator delete();
}

void MachThread::MachThread(MachThread *this, MachProcess *a2, char a3, uint64_t a4, int a5)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  int v7 = ++GetSequenceID(void)::g_nextID;
  *((_DWORD *)this + 4) = a5;
  *((_DWORD *)this + 5) = v7;
  *((_DWORD *)this + 6) = 1;
  PThreadMutex::PThreadMutex((MachThread *)((char *)this + 32), 2);
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 23) = DNBArchProtocol::Create();
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((unsigned char *)this + 368) = a3;
  *((void *)this + 47) = 0;
  uint64_t v12 = 0;
  uint64_t RegisterSetInfo = DNBArchProtocol::GetRegisterSetInfo((DNBArchProtocol *)&v12, v8);
  uint64_t v10 = v12;
  *((void *)this + 24) = RegisterSetInfo;
  *((void *)this + 25) = v10;
  *((void *)this + 47) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_pthread_qos_class_decode");
  thread_inspect_t v11 = *((_DWORD *)this + 4);
  if (!v11 || (mach_msg_type_number_t thread_info_outCnt = 10, thread_info(v11, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
  {
    *((void *)this + 16) = 0;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::MachThread(process = %p, tid = 0x%8.8llx, seq_id = %u)", this, *((void *)this + 1), *((_DWORD *)this + 5));
  }
}

void MachThread::~MachThread(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::~MachThread() for tid = 0x%8.8llx (%u)", *((void *)this + 1), *((_DWORD *)this + 5));
  }
  if (*((char *)this + 367) < 0) {
    operator delete(*((void **)this + 43));
  }
  uint64_t v2 = *((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  vm_map_t v3 = (void *)*((void *)this + 20);
  if (v3)
  {
    *((void *)this + 21) = v3;
    operator delete(v3);
  }
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32)))
  {
    if (!pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32))) {
      pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
    }
  }
}

void MachThread::Suspend(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "Suspend");
  }
  thread_read_t v2 = *((_DWORD *)this + 4);
  if (v2)
  {
    v3[0] = thread_suspend(v2);
    v3[1] = 1;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    long long __p = 0;
    if (v3[0])
    {
      DNBLogCheckLogBit(4);
    }
    else
    {
      ++*((_DWORD *)this + 34);
      if (!DNBLogCheckLogBit(4)) {
        return;
      }
    }
    DNBError::LogThreaded((DNBError *)v3, "::thread_suspend (%4.4x)", *((_DWORD *)this + 4));
    if (SHIBYTE(v6) < 0) {
      operator delete(__p);
    }
  }
}

BOOL MachThread::SetSuspendCountBeforeResume(MachThread *this, int a2)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "SetSuspendCountBeforeResume");
  }
  *(_OWORD *)long long __p = 0u;
  long long v10 = 0u;
  thread_inspect_t v4 = *((_DWORD *)this + 4);
  if (v4)
  {
    if (a2)
    {
      uint64_t v5 = (char *)this + 96;
      mach_msg_type_number_t thread_info_outCnt = 10;
      if (thread_info(v4, 3u, (thread_info_t)this + 24, &thread_info_outCnt))
      {
LABEL_6:
        *((void *)v5 + 4) = 0;
        *(_OWORD *)uint64_t v5 = 0u;
        *((_OWORD *)v5 + 1) = 0u;
        goto LABEL_22;
      }
      int v6 = *((_DWORD *)this + 32);
      *((_DWORD *)this + 34) -= v6;
      if (v6 >= 1)
      {
LABEL_10:
        uint64_t v5 = (char *)this + 96;
        do
        {
          __p[0] = (void *)(thread_resume(*((_DWORD *)this + 4)) | 0x100000000);
          if (SHIBYTE(v10) < 0)
          {
            *(unsigned char *)__p[1] = 0;
            *(void *)&long long v10 = 0;
          }
          else
          {
            LOBYTE(__p[1]) = 0;
            HIBYTE(v10) = 0;
          }
          if ((DNBLogCheckLogBit(4) || LODWORD(__p[0]))
            && (DNBError::LogThreaded((DNBError *)__p, "::thread_resume (%4.4x)", *((_DWORD *)this + 4)), LODWORD(__p[0])))
          {
            thread_inspect_t v7 = *((_DWORD *)this + 4);
            if (!v7) {
              goto LABEL_6;
            }
            mach_msg_type_number_t thread_info_outCnt = 10;
            if (thread_info(v7, 3u, (thread_info_t)this + 24, &thread_info_outCnt)) {
              goto LABEL_6;
            }
            int v6 = *((_DWORD *)this + 32);
          }
          else
          {
            --v6;
          }
        }
        while (v6 > 0);
      }
    }
    else
    {
      int v6 = *((_DWORD *)this + 34);
      *((_DWORD *)this + 34) = 0;
      if (v6 >= 1) {
        goto LABEL_10;
      }
    }
  }
LABEL_22:
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  return v4 != 0;
}

uint64_t MachThread::RestoreSuspendCountAfterStop(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "RestoreSuspendCountAfterStop");
  }
  *(_OWORD *)long long __p = 0u;
  long long v11 = 0u;
  if (!*((_DWORD *)this + 4)) {
    goto LABEL_29;
  }
  int v2 = *((_DWORD *)this + 34);
  if (v2 >= 1)
  {
    while (1)
    {
      __p[0] = (void *)(thread_resume(*((_DWORD *)this + 4)) | 0x100000000);
      if (SHIBYTE(v11) < 0)
      {
        *(unsigned char *)__p[1] = 0;
        *(void *)&long long v11 = 0;
      }
      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v11) = 0;
      }
      if (DNBLogCheckLogBit(4) || LODWORD(__p[0]))
      {
        DNBError::LogThreaded((DNBError *)__p, "::thread_resume (%4.4x)", *((_DWORD *)this + 4));
        if (LODWORD(__p[0])) {
          break;
        }
      }
      int v3 = *((_DWORD *)this + 34);
      BOOL v4 = __OFSUB__(v3--, 1);
      *((_DWORD *)this + 34) = v3;
      if ((v3 < 0) ^ v4 | (v3 == 0))
      {
        uint64_t v5 = 1;
        if ((SHIBYTE(v11) & 0x80000000) == 0) {
          return v5;
        }
        goto LABEL_31;
      }
    }
    thread_inspect_t v7 = *((_DWORD *)this + 4);
    if (v7 && (mach_msg_type_number_t thread_info_outCnt = 10, !thread_info(v7, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
    {
      int v8 = *((_DWORD *)this + 32);
    }
    else
    {
      int v8 = 0;
      *((void *)this + 16) = 0;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
    }
    uint64_t v5 = 0;
    *((_DWORD *)this + 34) = v8;
    if ((SHIBYTE(v11) & 0x80000000) == 0) {
      return v5;
    }
    goto LABEL_31;
  }
  uint64_t v5 = 1;
  if ((v2 & 0x80000000) == 0) {
    goto LABEL_30;
  }
  while (1)
  {
    unsigned int v6 = thread_suspend(*((_DWORD *)this + 4));
    __p[0] = (void *)(v6 | 0x100000000);
    if (SHIBYTE(v11) < 0) {
      break;
    }
    LOBYTE(__p[1]) = 0;
    HIBYTE(v11) = 0;
    if (v6) {
      goto LABEL_27;
    }
LABEL_21:
    ++*((_DWORD *)this + 34);
    if (DNBLogCheckLogBit(4)) {
      goto LABEL_28;
    }
    if ((*((_DWORD *)this + 34) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  *(unsigned char *)__p[1] = 0;
  *(void *)&long long v11 = 0;
  if (!LODWORD(__p[0])) {
    goto LABEL_21;
  }
LABEL_27:
  DNBLogCheckLogBit(4);
LABEL_28:
  DNBError::LogThreaded((DNBError *)__p, "::thread_suspend (%4.4x)", *((_DWORD *)this + 4));
LABEL_29:
  uint64_t v5 = 0;
LABEL_30:
  if (SHIBYTE(v11) < 0) {
LABEL_31:
  }
    operator delete(__p[1]);
  return v5;
}

char *MachThread::GetBasicInfoAsString(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return 0;
  }
  mach_msg_type_number_t thread_info_outCnt = 10;
  if (thread_info(v2, 3u, thread_info_out, &thread_info_outCnt)) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 1);
  int v3 = MachThread::GetBasicInfoAsString(void)const::g_basic_info_string;
  double v6 = (float)((float)((float)thread_info_out[1] / 1000000.0) + (float)thread_info_out[0]);
  snprintf(MachThread::GetBasicInfoAsString(void)const::g_basic_info_string, 0x400uLL, "Thread 0x%8.8llx: user=%f system=%f cpu=%d sleep_time=%d", v5, v6, v6, thread_info_out[4], thread_info_out[9]);
  return v3;
}

BOOL MachThread::IsUserReady(MachThread *this)
{
  int v2 = *((_DWORD *)this + 30);
  if (!v2)
  {
    thread_inspect_t v5 = *((_DWORD *)this + 4);
    if (!v5 || (mach_msg_type_number_t thread_info_outCnt = 10, thread_info(v5, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
    {
      *((void *)this + 16) = 0;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
      return (*(uint64_t (**)(void, void))(**((void **)this + 23) + 88))(*((void *)this + 23), 0) != 0;
    }
    int v2 = *((_DWORD *)this + 30);
  }
  unsigned int v3 = v2 - 1;
  if (v3 < 5 && ((0x17u >> v3) & 1) != 0) {
    return 1;
  }
  return (*(uint64_t (**)(void, void))(**((void **)this + 23) + 88))(*((void *)this + 23), 0) != 0;
}

void MachThread::Dump(MachThread *this, int a2)
{
  unsigned int v4 = *((_DWORD *)this + 30) - 1;
  if (v4 > 4)
  {
    thread_inspect_t v5 = "???";
    if (!DNBLogEnabled()) {
      return;
    }
    goto LABEL_5;
  }
  thread_inspect_t v5 = off_100069690[v4];
  if (DNBLogEnabled())
  {
LABEL_5:
    uint64_t v6 = *((void *)this + 1);
    int v7 = *((_DWORD *)this + 5);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 88))(*((void *)this + 23), -1);
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 104))(*((void *)this + 23), -1);
    _DNBLogThreaded("[%3u] #%3u tid: 0x%8.8llx, pc: 0x%16.16llx, sp: 0x%16.16llx, user: %d.%6.6d, system: %d.%6.6d, cpu: %2d, policy: %2d, run_state: %2d (%s), flags: %2d, suspend_count: %2d (current %2d), sleep_time: %d", a2, v7, v6, v8, v9, *((_DWORD *)this + 24), *((_DWORD *)this + 25), *((_DWORD *)this + 26), *((_DWORD *)this + 27), *((_DWORD *)this + 28), *((_DWORD *)this + 29), *((_DWORD *)this + 30), v5, *((_DWORD *)this + 31), *((_DWORD *)this + 32), *((_DWORD *)this + 34), *((_DWORD *)this + 33));
  }
}

uint64_t MachThread::ThreadWillResume(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 16) != -1) {
    (*(void (**)(void))(**(void **)(a1 + 184) + 96))(*(void *)(a1 + 184));
  }
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  *(_DWORD *)(a1 + 24) = v6;
  if (DNBLogEnabledForAny(4))
  {
    int v7 = DNBStateAsString(v6);
    _DNBLogThreaded("MachThread::SetState(%s) for tid = 0x%8.8llx", v7, *(void *)(a1 + 8));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  int v8 = *(_DWORD *)(a2 + 8);
  if ((v8 - 5) < 2)
  {
    if (DNBLogEnabledForAny(5)) {
      _DNBLogThreaded("MachThread::%s()", "Resume");
    }
    if (*(_DWORD *)(a1 + 16)) {
      MachThread::SetSuspendCountBeforeResume((MachThread *)a1, a3);
    }
  }
  else if (v8 == 10 || v8 == 4)
  {
    if (a3) {
      MachThread::ThreadWillResume();
    }
    MachThread::Suspend((MachThread *)a1);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 112))(*(void *)(a1 + 184));
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 168) = *(void *)(a1 + 160);
  return result;
}

BOOL MachThread::ShouldStop(MachThread *this, BOOL *a2)
{
  unsigned int v4 = (DNBBreakpointList *)(*(void *)this + 1640);
  unint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 88))(*((void *)this + 23), -1);
  if (DNBBreakpointList::FindByAddress(v4, v5)) {
    return 1;
  }
  if ((*(unsigned int (**)(void))(**((void **)this + 23) + 192))(*((void *)this + 23)))
  {
    BOOL result = 0;
    *a2 = 1;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    int v7 = *((_DWORD *)this + 6);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
    return v7 != 5 && *((_DWORD *)this + 36) && *((_DWORD *)this + 37) && *((_DWORD *)this + 38) != 0;
  }
  return result;
}

uint64_t MachThread::GetState(MachThread *this)
{
  int v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  uint64_t v3 = *((unsigned int *)this + 6);
  pthread_mutex_unlock(v2);
  return v3;
}

BOOL MachThread::IsStepping(MachThread *this)
{
  task_read_t v1 = this;
  int v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  LODWORD(v1) = *((_DWORD *)v1 + 6);
  pthread_mutex_unlock(v2);
  return v1 == 6;
}

uint64_t MachThread::ThreadDidStop(MachThread *this)
{
  (*(void (**)(void))(**((void **)this + 23) + 120))(*((void *)this + 23));
  MachThread::RestoreSuspendCountAfterStop(this);
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (v2 && (mach_msg_type_number_t thread_info_outCnt = 10, !thread_info(v2, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
  {
    if (*((int *)this + 32) >= 1)
    {
      uint64_t v3 = (pthread_mutex_t *)((char *)this + 32);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      unsigned int v4 = 10;
      *((_DWORD *)this + 6) = 10;
      if (!DNBLogEnabledForAny(4)) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }
  else
  {
    *((void *)this + 16) = 0;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  unsigned int v4 = 4;
  *((_DWORD *)this + 6) = 4;
  if (DNBLogEnabledForAny(4))
  {
LABEL_5:
    unint64_t v5 = DNBStateAsString(v4);
    _DNBLogThreaded("MachThread::SetState(%s) for tid = 0x%8.8llx", v5, *((void *)this + 1));
  }
LABEL_6:
  pthread_mutex_unlock(v3);
  return 1;
}

uint64_t MachThread::NotifyException(MachThread *this, MachException::Data *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 23) + 128))(*((void *)this + 23));
  unint64_t v5 = (MachThread *)((char *)this + 144);
  if (!*((_DWORD *)this + 36)
    || !*((_DWORD *)this + 37)
    || (int v6 = *((_DWORD *)this + 38)) == 0
    || v6 == 6
    || v6 == 5 && **((void **)this + 20) == 1)
  {
    uint64_t v7 = *(void *)a2;
    *((_DWORD *)this + 38) = *((_DWORD *)a2 + 2);
    *(void *)unint64_t v5 = v7;
    if (v5 != a2) {
      std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>((void *)this + 20, *((char **)a2 + 2), *((char **)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3);
    }
  }
  return v4;
}

unint64_t MachThread::GetRegisterInfo(MachThread *this, unint64_t a2, unint64_t a3)
{
  if (*((void *)this + 25) <= a2) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 24);
  if (*(void *)(v3 + 24 * a2 + 16) <= a3) {
    return 0;
  }
  else {
    return *(void *)(v3 + 24 * a2 + 8) + 72 * a3;
  }
}

uint64_t MachThread::GetRegisterValue(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 16))();
}

uint64_t MachThread::SetRegisterValue(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 24))();
}

uint64_t MachThread::GetRegisterContext(MachThread *this, void *a2)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 23) + 32))(*((void *)this + 23), a2);
}

uint64_t MachThread::SetRegisterContext(MachThread *this, const void *a2)
{
  return (*(uint64_t (**)(void, const void *))(**((void **)this + 23) + 40))(*((void *)this + 23), a2);
}

uint64_t MachThread::SaveRegisterState(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 48))();
}

uint64_t MachThread::RestoreRegisterState(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 56))();
}

uint64_t MachThread::EnableHardwareBreakpoint(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || (*(unsigned char *)(a2 + 24) & 4) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 184) + 152))(*(void *)(a1 + 184), *(void *)(a2 + 16), *(unsigned int *)(a2 + 4), a3);
  }
}

uint64_t MachThread::EnableHardwareWatchpoint(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && (unsigned int v3 = *(unsigned __int8 *)(a2 + 24), (v3 & 4) != 0)) {
    return (*(uint64_t (**)(void, void, void, void, void, uint64_t))(**(void **)(a1 + 184) + 160))(*(void *)(a1 + 184), *(void *)(a2 + 16), *(unsigned int *)(a2 + 4), (v3 >> 3) & 1, (v3 >> 4) & 1, a3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t MachThread::RollbackTransForHWP(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 208))();
}

uint64_t MachThread::FinishTransForHWP(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 216))();
}

uint64_t MachThread::DisableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(_DWORD *)(a2 + 28) == -1) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 168))();
  }
}

uint64_t MachThread::DisableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(_DWORD *)(a2 + 28) == -1) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 176))();
  }
}

uint64_t MachThread::NumSupportedHardwareWatchpoints(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 144))();
}

uint64_t MachThread::GetName(MachThread *this)
{
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (!thread_info(*((_DWORD *)this + 4), 4u, (thread_info_t)this + 52, &thread_info_outCnt)
    && proc_pidinfo(**(_DWORD **)this, 5, *((void *)this + 27), (char *)this + 232, 112)
    && *((unsigned char *)this + 280))
  {
    return (uint64_t)this + 280;
  }
  else
  {
    return 0;
  }
}

uint64_t MachThread::GetGloballyUniqueThreadIDForMachPortID(MachThread *this)
{
  unsigned int v1 = this;
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info((thread_inspect_t)this, 4u, thread_info_out, &thread_info_outCnt)) {
    return v1;
  }
  else {
    return *(void *)thread_info_out;
  }
}

uint64_t MachThread::GetPThreadT(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return -1;
  }
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info(v2, 4u, &thread_info_out, &thread_info_outCnt)) {
    return -1;
  }
  if (*((unsigned char *)this + 368))
  {
    *(void *)int v8 = 0;
    unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v11, 8uLL, v8);
    uint64_t v5 = *(void *)v8;
    if (*(void *)v8) {
      BOOL v6 = Memory == 8;
    }
    else {
      BOOL v6 = 0;
    }
  }
  else
  {
    *(_DWORD *)int v8 = 0;
    unint64_t v7 = MachProcess::ReadMemory(*(MachProcess **)this, v11, 4uLL, v8);
    uint64_t v5 = *(unsigned int *)v8;
    if (*(_DWORD *)v8) {
      BOOL v6 = v7 == 4;
    }
    else {
      BOOL v6 = 0;
    }
  }
  if (v6) {
    return v5;
  }
  else {
    return -1;
  }
}

uint64_t MachThread::GetTSDAddressForThread(MachThread *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t PThreadT = MachThread::GetPThreadT(this);
  if ((unint64_t)(a3 - 1) <= 0xFFFFFFFFFFFFFFFDLL) {
    return PThreadT + a3;
  }
  if (a4 != 4) {
    return -1;
  }
  unsigned int v17 = 0;
  mach_vm_address_t v10 = PThreadT + a2;
  unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v10, 4uLL, (char *)&v17);
  if (v17) {
    BOOL v12 = Memory == 4;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12) {
    uint64_t v13 = v17;
  }
  else {
    uint64_t v13 = -1;
  }
  *(void *)char v16 = 0;
  unint64_t v14 = MachProcess::ReadMemory(*(MachProcess **)this, v10, 8uLL, v16);
  if (*(void *)v16) {
    BOOL v15 = v14 == 8;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15) {
    return *(void *)v16;
  }
  else {
    return v13;
  }
}

uint64_t MachThread::GetDispatchQueueT(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return -1;
  }
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info(v2, 4u, thread_info_out, &thread_info_outCnt) || v11 + 1 < 2) {
    return -1;
  }
  if (*((unsigned char *)this + 368))
  {
    *(void *)int v8 = 0;
    unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v11, 8uLL, v8);
    uint64_t v5 = *(void *)v8;
    if (*(void *)v8) {
      BOOL v6 = Memory == 8;
    }
    else {
      BOOL v6 = 0;
    }
  }
  else
  {
    *(_DWORD *)int v8 = 0;
    unint64_t v7 = MachProcess::ReadMemory(*(MachProcess **)this, v11, 4uLL, v8);
    uint64_t v5 = *(unsigned int *)v8;
    if (*(_DWORD *)v8) {
      BOOL v6 = v7 == 4;
    }
    else {
      BOOL v6 = 0;
    }
  }
  if (v6) {
    return v5;
  }
  else {
    return -1;
  }
}

std::string *MachThread::GetRequestedQoS@<X0>(std::string *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_DWORD *)(a4 + 48) = -1;
  if (LODWORD(this->__r_.__value_.__r.__words[2]))
  {
    uint64_t v5 = this;
    if (this[15].__r_.__value_.__r.__words[2])
    {
      if (this[15].__r_.__value_.__s.__data_[8])
      {
        uint64_t v14 = 0;
        unint64_t Memory = MachProcess::ReadMemory((MachProcess *)this->__r_.__value_.__l.__data_, a2 + 8 * a3, 8uLL, (char *)&v14);
        uint64_t v7 = v14;
        BOOL v8 = Memory == 8;
      }
      else
      {
        unsigned int v13 = 0;
        unint64_t v9 = MachProcess::ReadMemory((MachProcess *)this->__r_.__value_.__l.__data_, a2 + 4 * a3, 4uLL, (char *)&v13);
        uint64_t v7 = v13;
        BOOL v8 = v9 == 4;
      }
      if (v8) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = 0;
      }
      this = (std::string *)((uint64_t (*)(uint64_t, void, void))v5[15].__r_.__value_.__r.__words[2])(v10, 0, 0);
      unint64_t v11 = "User Interactive";
      BOOL v12 = "QOS_CLASS_USER_INTERACTIVE";
      switch((int)this)
      {
        case 0:
          unint64_t v11 = "Unspecified";
          BOOL v12 = "QOS_CLASS_UNSPECIFIED";
          goto LABEL_15;
        case 9:
          unint64_t v11 = "Background";
          BOOL v12 = "QOS_CLASS_BACKGROUND";
          goto LABEL_15;
        case 17:
          unint64_t v11 = "Utility";
          BOOL v12 = "QOS_CLASS_UTILITY";
          goto LABEL_15;
        case 21:
          unint64_t v11 = "Default";
          BOOL v12 = "QOS_CLASS_DEFAULT";
          goto LABEL_15;
        case 25:
          unint64_t v11 = "User Initiated";
          BOOL v12 = "QOS_CLASS_USER_INITIATED";
          goto LABEL_15;
        case 33:
LABEL_15:
          *(_DWORD *)(a4 + 48) = this;
          std::string::assign((std::string *)a4, v12);
          this = std::string::assign((std::string *)(a4 + 24), v11);
          break;
        default:
          return this;
      }
    }
  }
  return this;
}

void *std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>(void *result, char *__src, char *a3, size_t __sz)
{
  BOOL v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 61) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 61) {
LABEL_22:
    }
      abort();
    uint64_t v13 = v12;
    BOOL result = operator new(8 * v12);
    unint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      BOOL result = memcpy(result, v6, v14);
    }
    BOOL v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  BOOL v15 = (void **)(result + 1);
  char v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    int v19 = (void *)*result;
LABEL_20:
    BOOL result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  BOOL v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    BOOL result = memmove((void *)*result, __src, v16 - v9);
    unint64_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    int v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  uint64_t *v15 = &v9[v14];
  return result;
}

void MachThreadList::MachThreadList(MachThreadList *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  PThreadMutex::PThreadMutex((MachThreadList *)((char *)this + 24), 2);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 0;
}

void MachThreadList::~MachThreadList(MachThreadList *this)
{
  thread_inspect_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 24)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
    unsigned int v3 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  else
  {
    unsigned int v3 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }
  uint64_t v4 = (char *)*((void *)this + 1);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      BOOL v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
      if (v6)
      {
        if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      v4 -= 16;
    }
    while (v4 != v3);
    uint64_t v5 = *(char **)this;
  }
  *((void *)this + 1) = v3;
  operator delete(v5);
}

uint64_t MachThreadList::GetState(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      uint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    BOOL v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t State = MachThread::GetState(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return State;
}

uint64_t MachThreadList::GetThreadByID@<X0>(MachThreadList *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  *a3 = 0;
  a3[1] = 0;
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    unint64_t v9 = (uint64_t *)(*(void *)this + 8);
    while (1)
    {
      uint64_t v10 = *(v9 - 1);
      if (*(void *)(v10 + 8) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_11;
      }
    }
    uint64_t v11 = *v9;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    *a3 = v10;
    a3[1] = v11;
  }
LABEL_11:

  return pthread_mutex_unlock(v6);
}

uint64_t MachThreadList::GetName(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t Name = MachThread::GetName(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return Name;
}

void MachThreadList::GetRequestedQoS(MachThreadList *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v11 = *((void *)this + 1) - *(void *)this;
  if (v11)
  {
    unint64_t v12 = v11 >> 4;
    if (v12 <= 1) {
      unint64_t v12 = 1;
    }
    uint64_t v13 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      size_t v14 = (std::string *)*(v13 - 1);
      if (v14->__r_.__value_.__l.__size_ == a2) {
        break;
      }
      v13 += 2;
      if (!--v12) {
        goto LABEL_7;
      }
    }
    BOOL v15 = *v13;
    if (*v13)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      pthread_mutex_unlock(v10);
      MachThread::GetRequestedQoS(v14, a3, a4, a5);
      if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    else
    {
      pthread_mutex_unlock(v10);
      MachThread::GetRequestedQoS(v14, a3, a4, a5);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v10);
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_DWORD *)(a5 + 48) = -1;
  }
}

uint64_t MachThreadList::GetPThreadT(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t PThreadT = MachThread::GetPThreadT(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return -1;
  }
  return PThreadT;
}

uint64_t MachThreadList::GetDispatchQueueT(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t DispatchQueueT = MachThread::GetDispatchQueueT(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return -1;
  }
  return DispatchQueueT;
}

uint64_t MachThreadList::GetTSDAddressForThread(MachThreadList *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v11 = *((void *)this + 1) - *(void *)this;
  if (v11)
  {
    unint64_t v12 = v11 >> 4;
    if (v12 <= 1) {
      unint64_t v12 = 1;
    }
    uint64_t v13 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      size_t v14 = (MachThread *)*(v13 - 1);
      if (*((void *)v14 + 1) == a2) {
        break;
      }
      v13 += 2;
      if (!--v12) {
        goto LABEL_7;
      }
    }
    unint64_t v17 = *v13;
    if (*v13) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v10);
    uint64_t TSDAddressForThread = MachThread::GetTSDAddressForThread(v14, a3, a4, a5);
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v10);
    return -1;
  }
  return TSDAddressForThread;
}

uint64_t MachThreadList::SetCurrentThread(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v10 = *v7;
    if (*v7)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      pthread_mutex_unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      pthread_mutex_unlock(v4);
    }
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 12);
    *((void *)this + 11) = v8;
    *((void *)this + 12) = v10;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return a2;
}

uint64_t MachThreadList::GetThreadStoppedReason(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v7 = *(void *)(a1 + 8) - *(void *)a1;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    unint64_t v9 = (std::__shared_weak_count **)(*(void *)a1 + 8);
    while (1)
    {
      uint64_t v10 = (uint64_t)*(v9 - 1);
      if (*(void *)(v10 + 8) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }
    uint64_t v13 = *v9;
    if (*v9) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v6);
    uint64_t StopInfo = MachException::Data::GetStopInfo(v10 + 144, a3);
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0;
  }
  return StopInfo;
}

BOOL MachThreadList::GetIdentifierInfo(MachThreadList *this, uint64_t a2, thread_identifier_info *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *(void *)this;
  uint64_t v8 = *((void *)this + 1) - *(void *)this;
  if (v8)
  {
    unint64_t v9 = v8 >> 4;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    while (*(void *)(*(void *)v7 + 8) != a2)
    {
      v7 += 16;
      if (!--v9) {
        goto LABEL_6;
      }
    }
    thread_inspect_t v10 = *(_DWORD *)(*(void *)v7 + 16);
  }
  else
  {
LABEL_6:
    thread_inspect_t v10 = 0;
  }
  pthread_mutex_unlock(v6);
  mach_msg_type_number_t thread_info_outCnt = 6;
  return thread_info(v10, 4u, (thread_info_t)a3, &thread_info_outCnt) == 0;
}

char *MachThreadList::GetThreadInfo(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      uint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    BasicInfoAsString = MachThread::GetBasicInfoAsString(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return BasicInfoAsString;
}

uint64_t MachThreadList::GetThreadIDByMachPortNumber(MachThreadList *this, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    if (v7 <= 1) {
      unint64_t v7 = 1;
    }
    while (*(_DWORD *)(*(void *)v5 + 16) != a2)
    {
      v5 += 16;
      if (!--v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(*(void *)v5 + 8);
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  pthread_mutex_unlock(v4);
  return v8;
}

uint64_t MachThreadList::GetRegisterValue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    unint64_t v7 = (std::__shared_weak_count **)(*(void *)a1 + 8);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t RegisterValue = MachThread::GetRegisterValue(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return RegisterValue;
}

uint64_t MachThreadList::SetRegisterValue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    unint64_t v7 = (std::__shared_weak_count **)(*(void *)a1 + 8);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::SetRegisterValue(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return v9;
}

uint64_t MachThreadList::GetRegisterContext(MachThreadList *this, uint64_t a2, void *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      thread_inspect_t v10 = (MachThread *)*(v9 - 1);
      if (*((void *)v10 + 1) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }
    uint64_t v13 = *v9;
    if (*v9) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v6);
    uint64_t RegisterContext = MachThread::GetRegisterContext(v10, a3);
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0;
  }
  return RegisterContext;
}

uint64_t MachThreadList::SetRegisterContext(MachThreadList *this, uint64_t a2, const void *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      thread_inspect_t v10 = (MachThread *)*(v9 - 1);
      if (*((void *)v10 + 1) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }
    uint64_t v13 = *v9;
    if (*v9) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v6);
    uint64_t v11 = MachThread::SetRegisterContext(v10, a3);
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0;
  }
  return v11;
}

uint64_t MachThreadList::SaveRegisterState(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::SaveRegisterState(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return v9;
}

uint64_t MachThreadList::RestoreRegisterState(MachThreadList *this, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v7;
    if (*v7) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::RestoreRegisterState(v8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0;
  }
  return v9;
}

uint64_t MachThreadList::NumThreads(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 4;
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t MachThreadList::ThreadIDAtIndex(MachThreadList *this, unint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  if (a2 >= (uint64_t)(*((void *)this + 1) - *(void *)this) >> 4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(*(void *)(*(void *)this + 16 * a2) + 8);
  }
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t MachThreadList::CurrentThreadID(MachThreadList *this)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  MachThreadList::CurrentThread((uint64_t *)this, &v4);
  if (v4)
  {
    uint64_t v1 = *(void *)(v4 + 8);
    thread_inspect_t v2 = v5;
    if (!v5) {
      return v1;
    }
  }
  else
  {
    uint64_t v1 = 0;
    thread_inspect_t v2 = v5;
    if (!v5) {
      return v1;
    }
  }
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return v1;
}

uint64_t MachThreadList::CurrentThread(uint64_t *a1, void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 3);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
  if (!a1[11])
  {
    uint64_t v9 = *a1;
    uint64_t v10 = a1[1];
    uint64_t v11 = v10 - *a1;
    if (v10 != *a1)
    {
      unint64_t v12 = 0;
      unint64_t v13 = v11 >> 4;
      unsigned int v14 = 1;
      while (1)
      {
        BOOL v15 = *(_DWORD **)(v9 + 16 * v12);
        if (v15[36])
        {
          if (v15[37] && v15[38]) {
            break;
          }
        }
        unint64_t v12 = v14++;
        if (v13 <= v12) {
          goto LABEL_2;
        }
      }
      uint64_t v16 = *(void *)(v9 + 16 * v12 + 8);
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v17 = (std::__shared_weak_count *)a1[12];
      a1[11] = (uint64_t)v15;
      a1[12] = v16;
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
LABEL_2:
  uint64_t v6 = a1[11];
  uint64_t v5 = a1[12];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  *a2 = v6;
  a2[1] = v5;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

  return pthread_mutex_unlock(v4);
}

uint64_t MachThreadList::NotifyException(MachThreadList *this, MachException::Data *a2)
{
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    if (v7 <= 1) {
      unint64_t v7 = 1;
    }
    unint64_t v8 = (std::__shared_weak_count **)(*(void *)this + 8);
    while (1)
    {
      uint64_t v9 = (MachThread *)*(v8 - 1);
      if (*((_DWORD *)v9 + 4) == v4) {
        break;
      }
      v8 += 2;
      if (!--v7) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = *v8;
    if (!*v8)
    {
      pthread_mutex_unlock(v5);
      MachThread::NotifyException(v9, a2);
      return 1;
    }
    uint64_t v10 = 1;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    pthread_mutex_unlock(v5);
    MachThread::NotifyException(v9, a2);
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      return 1;
    }
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(v5);
    return 0;
  }
  return v10;
}

uint64_t MachThreadList::Clear(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *((void *)this + 1);
  if (v4 != *(void *)this)
  {
    do
    {
      uint64_t v5 = *(std::__shared_weak_count **)(v4 - 8);
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      v4 -= 16;
    }
    while (v4 != v3);
  }
  *((void *)this + 1) = v3;

  return pthread_mutex_unlock(v2);
}

unint64_t MachThreadList::UpdateThreadList(uint64_t *a1, MachProcess *a2, int a3, uint64_t a4)
{
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("MachThreadList::UpdateThreadList (int pid = %4.4x, update = %u) process stop count = %u", *(_DWORD *)a2, a3, *((_DWORD *)a2 + 111));
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
  if (!*((_DWORD *)a2 + 111))
  {
    __p[0] = (void *)0xE00000001;
    int v8 = *(_DWORD *)a2;
    LODWORD(__p[1]) = 1;
    HIDWORD(__p[1]) = v8;
    v43[0] = 648;
    if (!sysctl((int *)__p, 4u, v48, v43, 0, 0) && v43[0] && (v52 & 4) != 0) {
      *((unsigned char *)a1 + 104) = 1;
    }
    if (*((unsigned char *)a1 + 104))
    {
      uint64_t v9 = 16777228;
    }
    else if (MachProcess::GetCPUType(a2) == 33554444)
    {
      uint64_t v9 = 33554444;
    }
    else
    {
      uint64_t v9 = 12;
    }
    DNBArchProtocol::SetArchitecture((DNBArchProtocol *)v9, 0);
  }
  uint64_t v11 = *a1;
  uint64_t v10 = a1[1];
  if (*a1 == v10 || a3 != 0)
  {
    thread_act_array_t act_list = 0;
    mach_msg_type_number_t act_listCnt = 0;
    task_inspect_t v13 = *((_DWORD *)a2 + 30);
    BOOL v14 = 1;
    v48[0] = task_threads(v13, &act_list, &act_listCnt);
    v48[1] = 1;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    int64_t v49 = 0;
    if (DNBLogCheckLogBit(4) || v48[0])
    {
      DNBError::LogThreaded((DNBError *)v48, "::task_threads(task = 0x%4.4x, thread_list => %p, thread_list_count => %u)", v13, act_list, act_listCnt);
      BOOL v14 = v48[0] == 0;
    }
    if (v14 && act_listCnt)
    {
      uint64_t v15 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      while (1)
      {
        unsigned int v16 = act_list[v15];
        unint64_t GloballyUniqueThreadIDForMachPortID = MachThread::GetGloballyUniqueThreadIDForMachPortID((MachThread *)v16);
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
        v43[0] = 0;
        v43[1] = 0;
        uint64_t v18 = a1[1] - *a1;
        if (v18)
        {
          unint64_t v19 = v18 >> 4;
          if (v19 <= 1) {
            unint64_t v19 = 1;
          }
          int v20 = (size_t *)(*a1 + 8);
          while (1)
          {
            size_t v21 = *(v20 - 1);
            if (*(void *)(v21 + 8) == GloballyUniqueThreadIDForMachPortID) {
              break;
            }
            v20 += 2;
            if (!--v19) {
              goto LABEL_35;
            }
          }
          size_t v22 = *v20;
          if (*v20) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
          }
          v43[0] = v21;
          v43[1] = v22;
        }
LABEL_35:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3));
        size_t v23 = v43[0];
        if (v43[0])
        {
          uint64_t v24 = (size_t *)__p[1];
          if (__p[1] < v47) {
            goto LABEL_51;
          }
        }
        else
        {
          mach_port_name_t v25 = operator new(0x198uLL);
          v25[1] = 0;
          v25[2] = 0;
          *mach_port_name_t v25 = off_1000696C8;
          int v26 = MachThread::MachThread((MachThread *)(v25 + 3), a2, *((unsigned char *)a1 + 104), GloballyUniqueThreadIDForMachPortID, v16);
          int v27 = (std::__shared_weak_count *)v43[1];
          v43[0] = (size_t)v26;
          v43[1] = (size_t)v25;
          if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
          if (!MachThread::IsUserReady((MachThread *)v43[0])) {
            goto LABEL_56;
          }
          if (a4)
          {
            uint64_t v28 = *(void **)(a4 + 8);
            if ((unint64_t)v28 >= *(void *)(a4 + 16))
            {
              uint64_t v30 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>(a4, (long long *)v43);
            }
            else
            {
              *uint64_t v28 = v43[0];
              size_t v29 = v43[1];
              v28[1] = v43[1];
              if (v29) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v30 = v28 + 2;
            }
            *(void *)(a4 + 8) = v30;
          }
          uint64_t v24 = (size_t *)__p[1];
          if (__p[1] < v47)
          {
            size_t v23 = v43[0];
LABEL_51:
            size_t *v24 = v23;
            size_t v31 = v43[1];
            v24[1] = v43[1];
            if (v31) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
            }
            long long v32 = v24 + 2;
            goto LABEL_55;
          }
        }
        long long v32 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>((uint64_t)__p, (long long *)v43);
LABEL_55:
        __p[1] = v32;
LABEL_56:
        long long v33 = (std::__shared_weak_count *)v43[1];
        if (v43[1] && !atomic_fetch_add((atomic_ullong *volatile)(v43[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
        if (++v15 >= (unint64_t)act_listCnt)
        {
          uint64_t v34 = (uint64_t)v47;
          long long v35 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)__p;
          *(_OWORD *)long long __p = v35;
          unsigned int v36 = (void *)a1[2];
          a1[2] = v34;
          uint64_t v47 = v36;
          BOOL v37 = (std::__shared_weak_count *)a1[12];
          a1[11] = 0;
          a1[12] = 0;
          if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
          vm_deallocate(mach_task_self_, (vm_address_t)act_list, 4 * act_listCnt);
          timeval v38 = (char *)__p[0];
          if (__p[0])
          {
            size_t v39 = (char *)__p[1];
            long long v40 = __p[0];
            if (__p[1] != __p[0])
            {
              do
              {
                uint64_t v41 = (std::__shared_weak_count *)*((void *)v39 - 1);
                if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                  std::__shared_weak_count::__release_weak(v41);
                }
                v39 -= 16;
              }
              while (v39 != v38);
              long long v40 = __p[0];
            }
            __p[1] = v38;
            operator delete(v40);
          }
          break;
        }
      }
    }
    if (SHIBYTE(v51) < 0) {
      operator delete(v49);
    }
    uint64_t v11 = *a1;
    uint64_t v10 = a1[1];
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3));
  return (unint64_t)(v10 - v11) >> 4;
}

uint64_t MachThreadList::Dump(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 - *(void *)this;
  if (v3 != *(void *)this)
  {
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    unint64_t v7 = v4 >> 4;
    do
    {
      MachThread::Dump(*(MachThread **)(*(void *)this + 16 * v5), v6++);
      uint64_t v5 = v6;
    }
    while (v7 > v6);
  }

  return pthread_mutex_unlock(v2);
}

uint64_t MachThreadList::ProcessWillResume(MachThreadList *this, MachProcess *a2, const DNBThreadResumeActions *a3)
{
  unsigned int v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  long long __p = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  if (*((void *)a3 + 1) == *(void *)a3
    || (uint64_t v7 = DNBThreadResumeActions::NumActionsWithState((uint64_t *)a3, 6),
        DNBThreadResumeActions::NumActionsWithState((uint64_t *)a3, 5) + v7 != 1))
  {
    MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, (uint64_t)&__p);
    uint64_t v11 = 0;
    long long v42 = xmmword_100065EB8;
    uint64_t v43 = -1;
  }
  else
  {
    uint64_t v8 = *((void *)a3 + 1) - *(void *)a3;
    if (v8)
    {
      unint64_t v9 = v8 / 24;
      if (v9 <= 1) {
        unint64_t v9 = 1;
      }
      uint64_t v10 = (_DWORD *)(*(void *)a3 + 8);
      while ((*v10 - 5) > 1)
      {
        v10 += 6;
        if (!--v9) {
          goto LABEL_9;
        }
      }
      uint64_t v11 = *((void *)v10 - 1);
    }
    else
    {
LABEL_9:
      uint64_t v11 = 0;
    }
    MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, (uint64_t)&__p);
    long long v42 = xmmword_100065EB8;
    uint64_t v43 = -1;
    DWORD2(v42) = 10;
  }
  task_inspect_t v13 = __p;
  unint64_t v12 = v45;
  unint64_t v14 = (v45 - (unsigned char *)__p) >> 4;
  uint64_t v15 = *((void *)this + 1);
  uint64_t v16 = v15 - *(void *)this;
  if (v15 == *(void *)this)
  {
    uint64_t v28 = (char *)__p;
    int v27 = v45;
  }
  else
  {
    uint64_t v41 = v6;
    uint64_t v17 = 0;
    unsigned int v18 = 0;
    unint64_t v19 = v16 >> 4;
    do
    {
      uint64_t v23 = *(void *)(*(void *)this + 16 * v17);
      if (v12 == v13)
      {
LABEL_21:
        ActionForThread = (long long *)DNBThreadResumeActions::GetActionForThread(a3, *(void *)(v23 + 8), 1);
        if (!ActionForThread) {
          MachThreadList::ProcessWillResume();
        }
        int v20 = ActionForThread;
        BOOL v22 = v11 == *(void *)(v23 + 8);
        uint64_t v21 = v23;
      }
      else
      {
        unint64_t v24 = 0;
        unsigned int v25 = 1;
        while (v23 != *((void *)__p + 2 * v24))
        {
          unint64_t v24 = v25++;
          if (v14 <= v24) {
            goto LABEL_21;
          }
        }
        int v20 = &v42;
        uint64_t v21 = v23;
        BOOL v22 = 0;
      }
      MachThread::ThreadWillResume(v21, (uint64_t)v20, v22);
      uint64_t v17 = ++v18;
    }
    while (v19 > v18);
    uint64_t v28 = (char *)__p;
    int v27 = v45;
    unsigned int v6 = v41;
  }
  if (v27 != v28 && v12 != v13)
  {
    unint64_t v30 = 0;
    unsigned int v31 = 1;
    do
    {
      if (DNBLogEnabledForAny(4))
      {
        long long v32 = (MachThread *)*((void *)__p + 2 * v30);
        uint64_t v33 = *((void *)v32 + 1);
        int v34 = *(_DWORD *)a2;
        int v35 = *((_DWORD *)a2 + 111);
        BOOL IsUserReady = MachThread::IsUserReady(v32);
        _DNBLogThreaded("MachThreadList::ProcessWillResume (int pid = %4.4x) stop-id=%u, resuming newly discovered thread: 0x%8.8llx, thread-is-user-ready=%i)", v34, v35, v33, IsUserReady);
      }
      unint64_t v30 = v31++;
    }
    while (v14 > v30);
    uint64_t v28 = (char *)__p;
  }
  if (v28)
  {
    BOOL v37 = v45;
    timeval v38 = v28;
    if (v45 != v28)
    {
      do
      {
        size_t v39 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
        v37 -= 16;
      }
      while (v37 != v28);
      timeval v38 = __p;
    }
    uint64_t v45 = v28;
    operator delete(v38);
  }
  return pthread_mutex_unlock(v6);
}

unint64_t MachThreadList::ProcessDidStop(MachThreadList *this, MachProcess *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  unint64_t updated = MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, 0);
  unint64_t v6 = updated;
  if (updated)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 16 * updated;
    do
    {
      MachThread::ThreadDidStop(*(MachThread **)(*(void *)this + v7));
      v7 += 16;
    }
    while (v8 != v7);
  }
  pthread_mutex_unlock(v4);
  return v6;
}

BOOL MachThreadList::ShouldStop(MachThreadList *this, BOOL *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = v5 - *(void *)this;
  if (v5 == *(void *)this)
  {
    BOOL ShouldStop = 0;
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v8 = v6 >> 4;
    unsigned int v9 = 1;
    do
    {
      BOOL ShouldStop = MachThread::ShouldStop(*(MachThread **)(*(void *)this + 16 * v7), a2);
      if (ShouldStop) {
        break;
      }
      unint64_t v7 = v9++;
    }
    while (v8 > v7);
  }
  pthread_mutex_unlock(v4);
  return ShouldStop;
}

uint64_t MachThreadList::NotifyBreakpointChanged(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));

  return pthread_mutex_unlock(v1);
}

uint64_t MachThreadList::DoHardwareBreakpointAction(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  unint64_t v8 = *(uint64_t **)a1;
  unint64_t v7 = *(uint64_t **)(a1 + 8);
  uint64_t v9 = (uint64_t)v7 - *(void *)a1;
  unint64_t v10 = v9 >> 4;
  if (v7 == *(uint64_t **)a1)
  {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
  else
  {
    switch(a3)
    {
      case 0:
        uint64_t v11 = MachThread::EnableHardwareWatchpoint(*v8, a2, 1);
        goto LABEL_9;
      case 1:
        uint64_t v13 = MachThread::DisableHardwareWatchpoint(*v8, a2);
        goto LABEL_13;
      case 2:
        uint64_t v11 = MachThread::EnableHardwareBreakpoint(*v8, a2, 1);
LABEL_9:
        uint64_t v12 = v11;
        if (v11 == -1) {
          goto LABEL_32;
        }
        if ((unint64_t)v9 >= 0x11)
        {
LABEL_14:
          unint64_t v14 = 1;
          while (2)
          {
            switch(a3)
            {
              case 0:
                uint64_t v16 = MachThread::EnableHardwareWatchpoint(*(void *)(*(void *)a1 + 16 * v14), a2, 0);
                goto LABEL_21;
              case 1:
                uint64_t v15 = MachThread::DisableHardwareWatchpoint(*(void *)(*(void *)a1 + 16 * v14), a2);
                goto LABEL_16;
              case 2:
                uint64_t v16 = MachThread::EnableHardwareBreakpoint(*(void *)(*(void *)a1 + 16 * v14), a2, 0);
LABEL_21:
                uint64_t v12 = v16;
                if (v16 != -1) {
                  goto LABEL_17;
                }
                if (v14)
                {
                  uint64_t v19 = 0;
                  do
                  {
                    MachThread::RollbackTransForHWP(*(MachThread **)(*(void *)a1 + v19));
                    v19 += 16;
                  }
                  while (16 * v14 != v19);
                }
                goto LABEL_31;
              case 3:
                uint64_t v15 = MachThread::DisableHardwareBreakpoint(*(void *)(*(void *)a1 + 16 * v14), a2);
LABEL_16:
                uint64_t v12 = v15;
                goto LABEL_17;
              default:
LABEL_17:
                unint64_t v14 = (v14 + 1);
                if (v10 > v14) {
                  continue;
                }
                goto LABEL_24;
            }
          }
        }
        break;
      case 3:
        uint64_t v13 = MachThread::DisableHardwareBreakpoint(*v8, a2);
LABEL_13:
        uint64_t v12 = v13;
        if ((unint64_t)v9 >= 0x11) {
          goto LABEL_14;
        }
        break;
      default:
LABEL_31:
        uint64_t v12 = 0xFFFFFFFFLL;
        goto LABEL_32;
    }
  }
LABEL_24:
  if (v7 != v8)
  {
    unint64_t v17 = 0;
    unsigned int v18 = 1;
    do
    {
      MachThread::FinishTransForHWP(*(MachThread **)(*(void *)a1 + 16 * v17));
      unint64_t v17 = v18++;
    }
    while (v10 > v17);
  }
LABEL_32:
  pthread_mutex_unlock(v6);
  return v12;
}

uint64_t MachThreadList::EnableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 0);
}

BOOL MachThreadList::DisableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 1) != -1;
}

uint64_t MachThreadList::EnableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 2);
}

BOOL MachThreadList::DisableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 3) != -1;
}

uint64_t MachThreadList::NumSupportedHardwareWatchpoints(MachThread ***this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)(this + 3);
  pthread_mutex_lock((pthread_mutex_t *)(this + 3));
  if (this[1] == *this) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = MachThread::NumSupportedHardwareWatchpoints(**this);
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t MachThreadList::GetThreadIndexForThreadStoppedWithSignal(MachThreadList *this, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = v6 >> 4;
    do
    {
      uint64_t v10 = *(void *)(v5 + 16 * v7);
      if (*(_DWORD *)(v10 + 152) == 5
        && (v12 = v10 + 160, uint64_t v11 = *(void *)(v10 + 160), *(void *)(v12 + 8) - v11 == 16)
        && *(void *)v11 == 65539)
      {
        if (*(_DWORD *)(v11 + 8) == a2) {
          goto LABEL_11;
        }
      }
      else if (!a2)
      {
        goto LABEL_11;
      }
      unint64_t v7 = (v8 + 1);
      uint64_t v8 = v7;
    }
    while (v9 > v7);
  }
  uint64_t v8 = 0xFFFFFFFFLL;
LABEL_11:
  pthread_mutex_unlock(v4);
  return v8;
}

void std::__shared_ptr_emplace<MachThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1000696C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MachThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1000696C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void std::__shared_ptr_emplace<MachThread>::__on_zero_shared(uint64_t a1)
{
}

void MachVMMemory::MachVMMemory(MachVMMemory *this)
{
  *(void *)this = -1;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
}

void MachVMMemory::~MachVMMemory(void **this)
{
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
}

uint64_t MachVMMemory::PageSize(vm_size_t *this, task_name_t target_task)
{
  kern_return_t v4;
  BOOL v5;
  mach_port_t v6;
  kern_return_t v7;
  integer_t task_info_out[3];
  int v9;
  mach_msg_type_number_t task_info_outCnt;

  uint64_t result = *this;
  if (result != -1) {
    return result;
  }
  if (target_task)
  {
    mach_msg_type_number_t task_info_outCnt = 93;
    uint64_t v4 = task_info(target_task, 0x16u, task_info_out, &task_info_outCnt);
    uint64_t v5 = DNBLogEnabledForAny(0x2000);
    if (!v4)
    {
      if (v5) {
        _DNBLogThreaded("MachVMMemory::PageSize task_info returned page size of 0x%x", v9);
      }
      uint64_t result = v9;
      *this = v9;
      return result;
    }
    if (v5) {
      _DNBLogThreaded("MachVMMemory::PageSize task_info call failed to get page size, TASK_VM_INFO %d, TASK_VM_INFO_COUNT %d, kern return %d", 22, 93, v4);
    }
  }
  uint64_t v6 = mach_host_self();
  unint64_t v7 = host_page_size(v6, this);
  *((_DWORD *)this + 2) = v7;
  *((_DWORD *)this + 3) = 1;
  if (*((char *)this + 39) < 0)
  {
    *(unsigned char *)this[2] = 0;
    this[3] = 0;
    if (*((_DWORD *)this + 2)) {
      goto LABEL_8;
    }
  }
  else
  {
    *((unsigned char *)this + 16) = 0;
    *((unsigned char *)this + 39) = 0;
    if (v7)
    {
LABEL_8:
      uint64_t result = 0;
      *this = 0;
      return result;
    }
  }
  return *this;
}

void get_dirty_pages(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  uint64_t v43 = a2;
  vm_map_read_t v42 = a1;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  __chkstk_darwin(a1);
  uint64_t v6 = (char *)&v39 - v5;
  uint64_t v41 = v7;
  unint64_t v8 = v7 + 4095;
  if (v8 >= 0x1000)
  {
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    mach_vm_size_t v11 = v4;
    uint64_t v12 = v8 >> 12;
    if (v8 >> 12 <= 1) {
      uint64_t v12 = 1;
    }
    uint64_t v39 = v12;
    mach_vm_size_t v40 = v11;
    uint64_t v45 = (char *)&v39 - v5;
    while (1)
    {
      mach_vm_size_t v13 = v41 - (v10 << 12);
      if (v13 >= v40) {
        mach_vm_size_t v13 = v40;
      }
      mach_vm_size_t dispositions_count = v13;
      mach_vm_offset_t v14 = v43 + vm_page_size * (v10 << 12);
      if (mach_vm_page_range_query(v42, v14, vm_page_size * v13, (mach_vm_address_t)v6, &dispositions_count)) {
        return;
      }
      uint64_t v44 = v10;
      mach_vm_size_t v15 = dispositions_count;
      if (dispositions_count) {
        break;
      }
LABEL_6:
      uint64_t v10 = v44 + 1;
      if (v44 + 1 == v39) {
        return;
      }
    }
    uint64_t v16 = 0;
    unint64_t v17 = *a3;
    vm_size_t v18 = vm_page_size;
    mach_vm_offset_t v46 = v14;
    while (1)
    {
      if ((*(_DWORD *)&v6[4 * v16] & 8) == 0) {
        goto LABEL_14;
      }
      mach_vm_offset_t v20 = v14 + v18 * v16;
      unint64_t v21 = (unint64_t)a3[2];
      if ((unint64_t)v9 >= v21) {
        break;
      }
      *(void *)unint64_t v9 = v20;
      uint64_t v19 = v9 + 8;
LABEL_13:
      a3[1] = v19;
      mach_vm_size_t v15 = dispositions_count;
      unint64_t v9 = v19;
LABEL_14:
      if (++v16 >= v15) {
        goto LABEL_6;
      }
    }
    uint64_t v22 = (v9 - v17) >> 3;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      abort();
    }
    uint64_t v24 = v21 - (void)v17;
    if (v24 >> 2 > v23) {
      unint64_t v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      vm_size_t v26 = v18;
      int v27 = operator new(8 * v25);
      vm_size_t v18 = v26;
    }
    else
    {
      int v27 = 0;
    }
    uint64_t v28 = (mach_vm_offset_t *)&v27[8 * v22];
    *uint64_t v28 = v20;
    uint64_t v19 = (char *)(v28 + 1);
    if (v9 == v17) {
      goto LABEL_40;
    }
    unint64_t v29 = v9 - v17 - 8;
    if (v29 < 0x168)
    {
      unint64_t v30 = v9;
      goto LABEL_39;
    }
    unint64_t v31 = (v9 - 8 - v17) & 0xFFFFFFFFFFFFFFF8;
    if (&v27[v9 - v17 - 8 - v31] > &v27[v9 - v17 - 8])
    {
      unint64_t v30 = v9;
    }
    else
    {
      if (&v9[-v31 - 8] <= v9 - 8)
      {
        if ((unint64_t)(v17 - v27) < 0x20)
        {
          unint64_t v30 = v9;
          goto LABEL_39;
        }
        uint64_t v32 = (v29 >> 3) + 1;
        uint64_t v33 = 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v30 = &v9[-v33];
        uint64_t v28 = (mach_vm_offset_t *)((char *)v28 - v33);
        int v34 = &v27[8 * v22 - 16];
        int v35 = v9 - 16;
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *(_OWORD *)v35;
          *(v34 - 1) = *((_OWORD *)v35 - 1);
          _OWORD *v34 = v37;
          v34 -= 2;
          v35 -= 32;
          v36 -= 4;
        }
        while (v36);
        if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_39;
        }
LABEL_40:
        *a3 = (char *)v28;
        a3[1] = v19;
        a3[2] = &v27[8 * v25];
        if (v17)
        {
          operator delete(v17);
          vm_size_t v18 = vm_page_size;
        }
        unint64_t v17 = (char *)v28;
        uint64_t v6 = v45;
        mach_vm_offset_t v14 = v46;
        goto LABEL_13;
      }
      unint64_t v30 = v9;
    }
    do
    {
LABEL_39:
      mach_vm_offset_t v38 = *((void *)v30 - 1);
      v30 -= 8;
      *--uint64_t v28 = v38;
    }
    while (v30 != v17);
    goto LABEL_40;
  }
}

uint64_t MachVMMemory::GetMemoryRegionInfo(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  MachVMRegion::MachVMRegion((MachVMRegion *)v15, a2);
  if (MachVMRegion::GetRegionForAddress((MachVMRegion *)v15, a3))
  {
    *(_OWORD *)a4 = v17;
    *(_DWORD *)(a4 + 16) = MachVMRegion::GetDNBPermissions((MachVMRegion *)v15);
    get_dirty_pages(a2, v17, (char **)&v13);
    int v7 = *(void **)(a4 + 24);
    if (v7)
    {
      *(void *)(a4 + 32) = v7;
      operator delete(v7);
    }
    *(_OWORD *)(a4 + 24) = v13;
    *(void *)(a4 + 40) = v14;
    MachVMRegion::GetMemoryTypes((MachVMRegion *)v15, (uint64_t)&v13);
    uint64_t v8 = *(void *)(a4 + 48);
    if (v8)
    {
      uint64_t v9 = *(void *)(a4 + 56);
      uint64_t v10 = *(void **)(a4 + 48);
      if (v9 != v8)
      {
        do
        {
          if (*(char *)(v9 - 1) < 0) {
            operator delete(*(void **)(v9 - 24));
          }
          v9 -= 24;
        }
        while (v9 != v8);
        uint64_t v10 = *(void **)(a4 + 48);
      }
      *(void *)(a4 + 56) = v8;
      operator delete(v10);
    }
    *(_OWORD *)(a4 + 48) = v13;
    *(void *)(a4 + 64) = v14;
  }
  else
  {
    *(void *)a4 = a3;
    if (v16 || (unint64_t v11 = v17 - a3, (unint64_t)v17 <= a3)) {
      unint64_t v11 = ~a3;
    }
    *(void *)(a4 + 8) = v11;
    *(_DWORD *)(a4 + 16) = 0;
  }
  MachVMRegion::~MachVMRegion((MachVMRegion *)v15);
  return 1;
}

uint64_t MachVMMemory::GetMemoryProfile(int a1, __int16 a2, task_name_t a3, int a4, int a5, int a6, host_info64_t host_info64_out, void *a8, void *a9, void *a10, void *a11)
{
  if ((a2 & 0x20) != 0)
  {
    if (GetPhysicalMemory(void)::calculated != 1)
    {
      v16[0] = 8;
      sysctlbyname("hw.memsize", &GetPhysicalMemory(void)::physical_memory, v16, 0, 0);
      GetPhysicalMemory(void)::calculated = 1;
    }
    *a8 = GetPhysicalMemory(void)::physical_memory;
  }
  if ((a2 & 0x40) == 0) {
    goto LABEL_8;
  }
  {
    MachVMMemory::GetMemoryProfile(DNBProfileDataScanType,unsigned int,task_basic_info,int,int,vm_statistics64 &,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &)::localHost = mach_host_self();
  }
  mach_msg_type_number_t host_info64_outCnt = 38;
  host_statistics64(MachVMMemory::GetMemoryProfile(DNBProfileDataScanType,unsigned int,task_basic_info,int,int,vm_statistics64 &,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &)::localHost, 4, host_info64_out, &host_info64_outCnt);
  mach_msg_type_number_t task_info_outCnt = 93;
  if (task_info(a3, 0x17u, (task_info_t)v16, &task_info_outCnt))
  {
LABEL_8:
    if ((a2 & 0x8000) == 0) {
      return 1;
    }
    goto LABEL_9;
  }
  if ((a2 & 0x100) != 0) {
    *a9 = v16[15] + v16[6] - v16[12];
  }
  *a10 = v16[18];
  if (a2 < 0)
  {
LABEL_9:
    v16[0] = 0;
    v16[1] = 0;
    if (!memorystatus_control()) {
      *a11 = SLODWORD(v16[0]);
    }
  }
  return 1;
}

unint64_t MachVMMemory::Read(vm_size_t *this, task_name_t target_task, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  unint64_t v5 = 0;
  if (a4 && a5)
  {
    int v7 = a4;
    unint64_t v5 = 0;
    unint64_t v11 = (DNBError *)(this + 1);
    do
    {
      mach_vm_size_t v14 = a5 - v5;
      unint64_t v15 = MachVMMemory::PageSize(this, target_task);
      if (v15 && v15 + a3 / v15 * v15 - a3 < v14) {
        mach_vm_size_t v14 = v15 + a3 / v15 * v15 - a3;
      }
      LODWORD(__n) = 0;
      __src = 0;
      *((_DWORD *)this + 2) = mach_vm_read(target_task, a3, v14, (vm_offset_t *)&__src, (mach_msg_type_number_t *)&__n);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(unsigned char *)this[2] = 0;
        this[3] = 0;
      }
      else
      {
        *((unsigned char *)this + 16) = 0;
        *((unsigned char *)this + 39) = 0;
      }
      if (DNBLogCheckLogBit(32)) {
        DNBError::LogThreaded(v11, "::mach_vm_read(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, data => %8.8p, dataCnt => %i)", target_task, a3, v14, __src, __n);
      }
      if (*(_DWORD *)v11) {
        break;
      }
      unsigned int v16 = __n;
      if (v14 != __n)
      {
        BOOL v17 = DNBLogCheckLogBit(32);
        unsigned int v16 = __n;
        if (v17)
        {
          DNBError::LogThreaded(v11, "::mach_vm_read(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, data => %8.8p, dataCnt=>%i) only read %u of %llu bytes", target_task, a3, v14, __src, __n, __n, v14);
          unsigned int v16 = __n;
        }
      }
      uint64_t v12 = __src;
      vm_size_t v13 = v16;
      memcpy(v7, __src, v16);
      vm_deallocate(mach_task_self_, (vm_address_t)v12, v13);
      v5 += __n;
      a3 += __n;
      v7 += __n;
    }
    while (v5 < a5);
  }
  return v5;
}

unint64_t MachVMMemory::Write(vm_size_t *this, task_name_t a2, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  MachVMRegion::MachVMRegion((MachVMRegion *)v16, a2);
  unint64_t v10 = 0;
  if (a5)
  {
    mach_vm_address_t v11 = a3;
    while (MachVMRegion::GetRegionForAddress((MachVMRegion *)v16, v11))
    {
      if (v17 > v11) {
        goto LABEL_18;
      }
      if (v18 + v17 <= v11) {
        goto LABEL_18;
      }
      mach_vm_address_t v12 = v18 + v17 - v11;
      if (!v12) {
        goto LABEL_18;
      }
      if (a5 - v10 >= v12) {
        mach_vm_size_t v13 = v18 + v17 - v11;
      }
      else {
        mach_vm_size_t v13 = a5 - v10;
      }
      if (!MachVMRegion::SetProtections((MachVMRegion *)v16, v11, v13, 3))
      {
        if (DNBLogEnabledForAny(256)) {
          _DNBLogThreaded("Failed to set read/write protections on region for address: [0x%8.8llx-0x%8.8llx)");
        }
        goto LABEL_18;
      }
      unint64_t v14 = MachVMMemory::WriteRegion(this, a2, v11, a4, v13);
      if (v14)
      {
        v10 += v14;
        v11 += v14;
        a4 += v14;
        if (v10 < a5) {
          continue;
        }
      }
      goto LABEL_18;
    }
    if (DNBLogEnabledForAny(256)) {
      _DNBLogThreaded("Failed to get region for address: 0x%8.8llx");
    }
  }
LABEL_18:
  MachVMRegion::~MachVMRegion((MachVMRegion *)v16);
  return v10;
}

unint64_t MachVMMemory::WriteRegion(vm_size_t *this, task_name_t target_task, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  unint64_t v5 = 0;
  if (a4 && a5)
  {
    int v7 = a4;
    unint64_t v5 = 0;
    mach_vm_address_t v11 = (DNBError *)(this + 1);
    do
    {
      unint64_t v12 = a5 - v5;
      unint64_t v13 = MachVMMemory::PageSize(this, target_task);
      if (v13 && v13 + a3 / v13 * v13 - a3 < v12) {
        unint64_t v12 = v13 + a3 / v13 * v13 - a3;
      }
      *((_DWORD *)this + 2) = mach_vm_write(target_task, a3, (vm_offset_t)v7, v12);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(unsigned char *)this[2] = 0;
        this[3] = 0;
      }
      else
      {
        *((unsigned char *)this + 16) = 0;
        *((unsigned char *)this + 39) = 0;
      }
      if (DNBLogCheckLogBit(32) || *(_DWORD *)v11) {
        DNBError::LogThreaded(v11, "::mach_vm_write(task = 0x%4.4x, addr = 0x%8.8llx, int data = %8.8p, dataCnt = %u)", target_task, a3, v7, v12);
      }
      vm_machine_attribute_val_t value = 6;
      *((_DWORD *)this + 2) = vm_machine_attribute(target_task, a3, v12, 1u, &value);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(unsigned char *)this[2] = 0;
        this[3] = 0;
      }
      else
      {
        *((unsigned char *)this + 16) = 0;
        *((unsigned char *)this + 39) = 0;
      }
      if (DNBLogCheckLogBit(32) || *(_DWORD *)v11)
      {
        DNBError::LogThreaded(v11, "::vm_machine_attribute(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %u, attr = MATTR_CACHE, mattr_value => MATTR_VAL_CACHE_FLUSH)", target_task, a3, v12);
        if (*(_DWORD *)v11) {
          break;
        }
      }
      v5 += v12;
      a3 += v12;
      v7 += v12;
    }
    while (v5 < a5);
  }
  return v5;
}

void MachVMRegion::MachVMRegion(MachVMRegion *this, int a2)
{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = -1;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = xmmword_100065ED0;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_100065ED0;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
}

void MachVMRegion::~MachVMRegion(MachVMRegion *this)
{
  MachVMRegion::RestoreProtections(this);
  *((void *)this + 1) = -1;
  *((void *)this + 2) = 0;
  if (*((char *)this + 47) < 0)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
    int v2 = *((char *)this + 47);
    *((_OWORD *)this + 3) = xmmword_100065ED0;
    *((_DWORD *)this + 16) = -1;
    *(_OWORD *)((char *)this + 68) = 0u;
    *(_OWORD *)((char *)this + 84) = 0u;
    *(_OWORD *)((char *)this + 100) = 0u;
    *((_DWORD *)this + 29) = 0;
    *(_OWORD *)((char *)this + 120) = xmmword_100065ED0;
    if (v2 < 0) {
      operator delete(*((void **)this + 3));
    }
  }
  else
  {
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
    *((_OWORD *)this + 3) = xmmword_100065ED0;
    *((_DWORD *)this + 16) = -1;
    *(_OWORD *)((char *)this + 68) = 0u;
    *(_OWORD *)((char *)this + 84) = 0u;
    *(_OWORD *)((char *)this + 100) = 0u;
    *((_DWORD *)this + 29) = 0;
    *(_OWORD *)((char *)this + 120) = xmmword_100065ED0;
  }
}

uint64_t MachVMRegion::RestoreProtections(MachVMRegion *this)
{
  vm_prot_t v2 = *((_DWORD *)this + 17);
  if (*((_DWORD *)this + 29) == v2 || (mach_vm_size_t v3 = *((void *)this + 16)) == 0)
  {
    *((void *)this + 2) = 0;
    if (*((char *)this + 47) < 0)
    {
      **((unsigned char **)this + 3) = 0;
      *((void *)this + 4) = 0;
    }
    else
    {
      *((unsigned char *)this + 24) = 0;
      *((unsigned char *)this + 47) = 0;
    }
  }
  else
  {
    *((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, *((void *)this + 15), v3, 0, v2);
    *((_DWORD *)this + 5) = 1;
    if (*((char *)this + 47) < 0)
    {
      **((unsigned char **)this + 3) = 0;
      *((void *)this + 4) = 0;
    }
    else
    {
      *((unsigned char *)this + 24) = 0;
      *((unsigned char *)this + 47) = 0;
    }
    if (DNBLogCheckLogBit(256) || *((_DWORD *)this + 4))
    {
      DNBError::LogThreaded((MachVMRegion *)((char *)this + 16), "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)", *(_DWORD *)this, *((void *)this + 15), *((void *)this + 16), 0, *((_DWORD *)this + 17));
      if (*((_DWORD *)this + 4)) {
        return 0;
      }
    }
    *(_OWORD *)((char *)this + 120) = xmmword_100065ED0;
    *((_DWORD *)this + 29) = *((_DWORD *)this + 17);
  }
  return 1;
}

BOOL MachVMRegion::SetProtections(MachVMRegion *this, mach_vm_address_t address, mach_vm_size_t a3, vm_prot_t new_protection)
{
  mach_vm_address_t v4 = *((void *)this + 6);
  if (v4 > address) {
    return 0;
  }
  uint64_t v7 = *((void *)this + 7);
  if (v7 + v4 <= address) {
    return 0;
  }
  if (v4 - address + v7 >= a3) {
    mach_vm_size_t v8 = a3;
  }
  else {
    mach_vm_size_t v8 = v4 - address + v7;
  }
  if (!v8)
  {
    BOOL result = DNBLogEnabledForAny(257);
    if (!result) {
      return result;
    }
    _DNBLogThreaded("%s: Zero size for task 0x%4.4x at address 0x%8.8llx) ", "SetProtections", *(_DWORD *)this, address);
    return 0;
  }
  if ((*((_DWORD *)this + 29) & 7) != new_protection)
  {
    *((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, address, v8, 0, new_protection);
    *((_DWORD *)this + 5) = 1;
    mach_vm_address_t v11 = (_DWORD *)((char *)this + 16);
    if (*((char *)this + 47) < 0)
    {
      **((unsigned char **)this + 3) = 0;
      *((void *)this + 4) = 0;
    }
    else
    {
      *((unsigned char *)this + 24) = 0;
      *((unsigned char *)this + 47) = 0;
    }
    if (DNBLogCheckLogBit(256)) {
      DNBError::LogThreaded((MachVMRegion *)((char *)this + 16), "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)", *(_DWORD *)this, address, v8, 0, new_protection);
    }
    if (!*v11
      || ((*((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, address, v8, 0, new_protection | 0x10),
           *((_DWORD *)this + 5) = 1,
           *((char *)this + 47) < 0)
        ? (**((unsigned char **)this + 3) = 0, *((void *)this + 4) = 0)
        : (*((unsigned char *)this + 24) = 0, *((unsigned char *)this + 47) = 0),
          !DNBLogCheckLogBit(256) && !*v11
       || (DNBError::LogThreaded((MachVMRegion *)((char *)this + 16), "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)", *(_DWORD *)this, address, v8, 0, new_protection | 0x10), !*((_DWORD *)this + 4))))
    {
      *((_DWORD *)this + 29) = new_protection;
      BOOL result = 1;
      *((void *)this + 15) = address;
      *((void *)this + 16) = v8;
      return result;
    }
    return 0;
  }
  if (DNBLogEnabledForAny(257)) {
    _DNBLogThreaded("MachVMRegion::%s: protections (%u) already sufficient for task 0x%4.4x at address 0x%8.8llx) ", "SetProtections", new_protection, *(_DWORD *)this, address);
  }
  return 1;
}

BOOL MachVMRegion::GetRegionForAddress(MachVMRegion *this, unint64_t a2)
{
  kern_return_t v5;
  kern_return_t v6;
  BOOL v7;
  unint64_t v8;
  mach_msg_type_number_t infoCnt;

  MachVMRegion::RestoreProtections(this);
  *((void *)this + 1) = -1;
  if (*((char *)this + 47) < 0)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
    BOOL v4 = *((char *)this + 47) < 0;
  }
  else
  {
    BOOL v4 = 0;
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
  }
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((_DWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_100065ED0;
  *((void *)this + 2) = 0;
  if (v4)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
  }
  else
  {
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
  }
  *((void *)this + 1) = a2;
  *((void *)this + 6) = a2;
  *((_DWORD *)this + 16) = 1024;
  infoCnt = 12;
  unint64_t v5 = mach_vm_region_recurse(*(_DWORD *)this, (mach_vm_address_t *)this + 6, (mach_vm_size_t *)this + 7, (natural_t *)this + 16, (vm_region_recurse_info_t)this + 17, &infoCnt);
  *((_DWORD *)this + 4) = v5;
  *((_DWORD *)this + 5) = 1;
  if (*((char *)this + 47) < 0)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
    uint64_t v6 = *((_DWORD *)this + 4);
  }
  else
  {
    uint64_t v6 = v5;
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
  }
  uint64_t v7 = DNBLogCheckLogBit(256);
  if (v7 || v6)
  {
    DNBError::LogThreaded((MachVMRegion *)((char *)this + 16), "::mach_vm_region_recurse(task = 0x%4.4x, address => 0x%8.8llx, size => %llu, nesting_depth => %d, info => %p, infoCnt => %d) addr = 0x%8.8llx ", *(_DWORD *)this, *((void *)this + 6), *((void *)this + 7), *((_DWORD *)this + 16), (char *)this + 68, infoCnt, a2);
    if (v6) {
      return 0;
    }
  }
  if (v7 && DNBLogEnabled()) {
    _DNBLogThreaded("info = { prot = %u, max_prot = %u, inheritance = 0x%8.8x, offset = 0x%8.8llx, user_tag = 0x%8.8x, ref_count = %u, shadow_depth = %u, ext_pager = %u, share_mode = %u, is_submap = %d, behavior = %d, object_id = 0x%8.8x, user_wired_count = 0x%4.4x }", *((_DWORD *)this + 17), *((_DWORD *)this + 18), *((_DWORD *)this + 19), *((void *)this + 10), *((_DWORD *)this + 22), *((_DWORD *)this + 23), *((unsigned __int16 *)this + 48), *((unsigned __int8 *)this + 98), *((unsigned __int8 *)this + 99), *((_DWORD *)this + 25), *((_DWORD *)this + 26), *((_DWORD *)this + 27), *((unsigned __int16 *)this + 56));
  }
  *((_DWORD *)this + 29) = *((_DWORD *)this + 17);
  mach_vm_size_t v8 = *((void *)this + 6);
  return v8 <= a2 && *((void *)this + 7) + v8 > a2;
}

uint64_t MachVMRegion::GetDNBPermissions(MachVMRegion *this)
{
  if (*((void *)this + 1) == -1 || *((void *)this + 6) == -1 || !*((void *)this + 7)) {
    return 0;
  }
  else {
    return *((_DWORD *)this + 17) & 4 | (__rbit32(*((_DWORD *)this + 17)) >> 30);
  }
}

void MachVMRegion::GetMemoryTypes(MachVMRegion *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  int v4 = *((_DWORD *)this + 22);
  if (v4 == 30)
  {
    if (*((_DWORD *)this + 17))
    {
      HIBYTE(v32) = 5;
      strcpy((char *)__p, "stack");
    }
    else
    {
      HIBYTE(v32) = 11;
      strcpy((char *)__p, "stack-guard");
    }
    unint64_t v5 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
    int v6 = SHIBYTE(v32);
    *(void *)(a2 + 8) = v5;
    if (v6 < 0) {
      operator delete(__p[0]);
    }
    int v4 = *((_DWORD *)this + 22);
  }
  if (v4 == 1)
  {
    if (*((_DWORD *)this + 17))
    {
      if (*((unsigned char *)this + 99) == 3)
      {
        HIBYTE(v32) = 15;
        uint64_t v7 = "malloc-reserved";
      }
      else
      {
        HIBYTE(v32) = 15;
        uint64_t v7 = "malloc-metadata";
      }
      __p[0] = *(void **)v7;
      *(void **)((char *)__p + 7) = *(void **)(v7 + 7);
      HIBYTE(__p[1]) = 0;
    }
    else
    {
      HIBYTE(v32) = 12;
      strcpy((char *)__p, "malloc-guard");
    }
    unint64_t v8 = *(void *)(a2 + 8);
    if (v8 >= *(void *)(a2 + 16))
    {
      unint64_t v10 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v11 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v10;
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v9 = *(_OWORD *)__p;
      *(void *)(v8 + 16) = v32;
      *(_OWORD *)unint64_t v8 = v9;
      *(void *)(a2 + 8) = v8 + 24;
    }
  }
  int v12 = *((_DWORD *)this + 22);
  if ((v12 - 2) < 8 || v12 == 11)
  {
    HIBYTE(v32) = 4;
    strcpy((char *)__p, "heap");
    unint64_t v14 = *(void *)(a2 + 8);
    if (v14 >= *(void *)(a2 + 16))
    {
      unsigned int v16 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v17 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v16;
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v15 = *(_OWORD *)__p;
      *(void *)(v14 + 16) = v32;
      *(_OWORD *)unint64_t v14 = v15;
      *(void *)(a2 + 8) = v14 + 24;
    }
    int v18 = *((_DWORD *)this + 22);
    if (v18 == 7)
    {
      HIBYTE(v32) = 11;
      strcpy((char *)__p, "malloc-tiny");
      unint64_t v19 = *(void *)(a2 + 8);
      if (v19 >= *(void *)(a2 + 16))
      {
        unint64_t v21 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
        int v22 = SHIBYTE(v32);
        *(void *)(a2 + 8) = v21;
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v20 = *(_OWORD *)__p;
        *(void *)(v19 + 16) = v32;
        *(_OWORD *)unint64_t v19 = v20;
        *(void *)(a2 + 8) = v19 + 24;
      }
      int v18 = *((_DWORD *)this + 22);
      if (v18 != 3)
      {
LABEL_30:
        if (v18 != 2) {
          return;
        }
        goto LABEL_42;
      }
    }
    else if (v18 != 3)
    {
      goto LABEL_30;
    }
    HIBYTE(v32) = 12;
    strcpy((char *)__p, "malloc-large");
    unint64_t v23 = *(void *)(a2 + 8);
    if (v23 >= *(void *)(a2 + 16))
    {
      unint64_t v25 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v26 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v25;
      if (v26 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v24 = *(_OWORD *)__p;
      *(void *)(v23 + 16) = v32;
      *(_OWORD *)unint64_t v23 = v24;
      *(void *)(a2 + 8) = v23 + 24;
    }
    if (*((_DWORD *)this + 22) != 2) {
      return;
    }
LABEL_42:
    HIBYTE(v32) = 12;
    strcpy((char *)__p, "malloc-small");
    unint64_t v27 = *(void *)(a2 + 8);
    if (v27 >= *(void *)(a2 + 16))
    {
      unint64_t v29 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v30 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v29;
      if (v30 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v28 = *(_OWORD *)__p;
      *(void *)(v27 + 16) = v32;
      *(_OWORD *)unint64_t v27 = v28;
      *(void *)(a2 + 8) = v27 + 24;
    }
  }
}

uint64_t OsLogger::GetLogFunction(OsLogger *this)
{
  return 0;
}

double DNBArchMachARM64::Initialize(DNBArchMachARM64 *this)
{
  v3[0] = unk_1000696F0;
  v3[1] = *(_OWORD *)&off_100069700;
  DNBArchProtocol::RegisterArchPlugin((unsigned int *)v3);
  v2[0] = unk_100069710;
  v2[1] = *(_OWORD *)&off_100069720;
  *(void *)&double result = DNBArchProtocol::RegisterArchPlugin((unsigned int *)v2).n128_u64[0];
  return result;
}

char *DNBArchMachARM64::Create(DNBArchMachARM64 *this, MachThread *a2)
{
  mach_vm_size_t v3 = (char *)operator new(0x1C80uLL, (std::align_val_t)0x40uLL);
  *((_DWORD *)v3 + 2) = 0;
  *(void *)mach_vm_size_t v3 = off_10006DD00;
  *((void *)v3 + 2) = this;
  *((void *)v3 + 829) = -1;
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  *(_OWORD *)(v3 + 6600) = v4;
  *(_OWORD *)(v3 + 6616) = v4;
  *(_OWORD *)(v3 + 7176) = 0u;
  *(_OWORD *)(v3 + 7192) = 0u;
  *(_OWORD *)(v3 + 7208) = 0u;
  *((_DWORD *)v3 + 1806) = -1;
  *((_WORD *)v3 + 3614) = 0;
  *((void *)v3 + 906) = 0;
  *((void *)v3 + 905) = 0;
  *((void *)v3 + 904) = v3 + 7240;
  std::vector<DNBArchMachARM64::disabled_watchpoint>::__append((void **)v3 + 897, 0x10uLL);
  uint64_t v5 = *((void *)v3 + 900);
  unint64_t v6 = *((void *)v3 + 901) - v5;
  if (v6 > 0xFF)
  {
    if (v6 != 256) {
      *((void *)v3 + 901) = v5 + 256;
    }
  }
  else
  {
    std::vector<DNBArchMachARM64::disabled_watchpoint>::__append((void **)v3 + 900, 16 - (v6 >> 4));
  }
  bzero(v3 + 6656, 0x208uLL);
  return v3;
}

char **DNBArchMachARM64::GetRegisterSetInfo(DNBArchMachARM64 *this, unint64_t *a2)
{
  if (!a2) {
    goto LABEL_6;
  }
  if (CPUHasAMX(void)::g_has_avx == -1)
  {
    CPUHasAMX(void)::g_has_avint x = (_get_cpu_capabilities() & 0x78000000) != 0;
    if (CPUHasAMX(void)::g_has_avx == 1) {
      goto LABEL_4;
    }
LABEL_6:
    double result = &DNBArchMachARM64::g_reg_sets;
    uint64_t v4 = 4;
    goto LABEL_7;
  }
  if (CPUHasAMX(void)::g_has_avx != 1) {
    goto LABEL_6;
  }
LABEL_4:
  double result = &DNBArchMachARM64::g_reg_sets_with_amx;
  uint64_t v4 = 5;
LABEL_7:
  *(void *)this = v4;
  return result;
}

void *DNBArchMachARM64::SoftwareBreakpointOpcode(DNBArchMachARM64 *this)
{
  return &g_arm64_breakpoint_opcode;
}

uint64_t DNBArchMachARM64::GetPC(DNBArchMachARM64 *this, uint64_t a2)
{
  if (!DNBArchMachARM64::GetGPRState(this, 0))
  {
    uint64_t v4 = *((void *)this + 40);
    unsigned int v7 = 0;
    if (DNBGetAddressingBits(&v7)) {
      uint64_t v5 = ~(-1 << v7);
    }
    else {
      uint64_t v5 = -1;
    }
    return v5 & v4;
  }
  return a2;
}

uint64_t DNBArchMachARM64::GetGPRState(DNBArchMachARM64 *this, char a2)
{
  kern_return_t v4;
  BOOL v5;
  char v6;
  uint64_t v7;
  BOOL v8;
  char v9;
  uint64_t v10;
  BOOL v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  long long v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  char v23;
  BOOL v24;
  uint64_t v25;
  natural_t out_state[68];
  mach_msg_type_number_t out_stateCnt;
  mach_msg_type_number_t old_stateCnt[3];

  if ((a2 & 1) == 0 && !*((_DWORD *)this + 1650)) {
    return 0;
  }
  old_stateCnt[0] = 68;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, (thread_state_t)this + 16, old_stateCnt);
  if (!state)
  {
    out_stateCnt = 68;
    uint64_t v4 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 1, 6, (thread_state_t)this + 16, old_stateCnt[0], out_state, &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("converted register values to debugserver's keys, return value %d, old count %d new count %d", v4, old_stateCnt[0], out_stateCnt);
    }
    memcpy((char *)this + 64, out_state, 4 * old_stateCnt[0]);
  }
  if (DNBLogEnabledForAny(4))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("thread_get_state signed regs \n   fp=%16.16llx\n   lr=%16.16llx\n   sp=%16.16llx\n   pc=%16.16llx", *((void *)this + 37), *((void *)this + 38), *((void *)this + 39), *((void *)this + 40));
    }
    unint64_t v25 = *((void *)this + 37);
    out_state[0] = 0;
    long long v24 = DNBGetAddressingBits(out_state);
    unint64_t v23 = out_state[0];
    int v22 = *((void *)this + 38);
    out_state[0] = 0;
    uint64_t v5 = DNBGetAddressingBits(out_state);
    unint64_t v6 = out_state[0];
    unsigned int v7 = *((void *)this + 39);
    out_state[0] = 0;
    unint64_t v8 = DNBGetAddressingBits(out_state);
    long long v9 = out_state[0];
    unint64_t v10 = *((void *)this + 40);
    out_state[0] = 0;
    int v11 = DNBGetAddressingBits(out_state);
    int v12 = out_state[0];
    if (DNBLogEnabled())
    {
      unint64_t v13 = -1;
      if (v11) {
        unint64_t v14 = ~(-1 << v12);
      }
      else {
        unint64_t v14 = -1;
      }
      long long v15 = v14 & v10;
      if (v8) {
        int v17 = ~(-1 << v9);
      }
      else {
        int v17 = -1;
      }
      int v18 = v17 & v7;
      if (v5) {
        unint64_t v19 = ~(-1 << v6);
      }
      else {
        unint64_t v19 = -1;
      }
      long long v20 = v19 & v22;
      if (v24) {
        unint64_t v13 = ~(-1 << v23);
      }
      unsigned int v16 = *(_OWORD *)((char *)this + 72);
      _DNBLogThreaded("thread_get_state(0x%4.4x, %u, &gpr, %u) => 0x%8.8x (count = %u) regs\n   x0=%16.16llx\n   x1=%16.16llx\n   x2=%16.16llx\n   x3=%16.16llx\n   x4=%16.16llx\n   x5=%16.16llx\n   x6=%16.16llx\n   x7=%16.16llx\n   x8=%16.16llx\n   x9=%16.16llx\n  x10=%16.16llx\n  x11=%16.16llx\n  x12=%16.16llx\n  x13=%16.16llx\n  x14=%16.16llx\n  x15=%16.16llx\n  x16=%16.16llx\n  x17=%16.16llx\n"
        "  x18=%16.16llx\n"
        "  x19=%16.16llx\n"
        "  x20=%16.16llx\n"
        "  x21=%16.16llx\n"
        "  x22=%16.16llx\n"
        "  x23=%16.16llx\n"
        "  x24=%16.16llx\n"
        "  x25=%16.16llx\n"
        "  x26=%16.16llx\n"
        "  x27=%16.16llx\n"
        "  x28=%16.16llx\n"
        "   fp=%16.16llx\n"
        "   lr=%16.16llx\n"
        "   sp=%16.16llx\n"
        "   pc=%16.16llx\n"
        " cpsr=%8.8x",
        *(_DWORD *)(*((void *)this + 2) + 16),
        1,
        68,
        state,
        old_stateCnt[0],
        *((void *)this + 8),
        (void)v16,
        *((void *)&v16 + 1),
        *((void *)this + 11),
        *((void *)this + 12),
        *((void *)this + 13),
        *((void *)this + 14),
        *((void *)this + 15),
        *((void *)this + 16),
        *((void *)this + 17),
        *((void *)this + 8),
        *((void *)this + 19),
        *((void *)this + 20),
        *((void *)this + 21),
        *((void *)this + 22),
        *((void *)this + 23),
        *((void *)this + 24),
        *((void *)this + 25),
        *((void *)this + 26),
        *((void *)this + 27),
        *((void *)this + 28),
        *((void *)this + 29),
        *((void *)this + 30),
        *((void *)this + 31),
        *((void *)this + 32),
        *((void *)this + 33),
        *((void *)this + 34),
        *((void *)this + 35),
        *((void *)this + 36),
        v13 & v25,
        v20,
        v18,
        v15,
        *((_DWORD *)this + 82));
    }
  }
  *((_DWORD *)this + 1650) = state;
  return state;
}

BOOL DNBArchMachARM64::SetPC(DNBArchMachARM64 *this, uint64_t a2)
{
  kern_return_t v7;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;

  GPRuint64_t State = DNBArchMachARM64::GetGPRState(this, 0);
  if (!GPRState)
  {
    int v5 = *((_DWORD *)this + 83);
    if (a2) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = 0;
    }
    *((void *)this + 40) = v6;
    *((_DWORD *)this + 83) = v5 & 0xFFFFFFFB;
    out_stateCnt = 68;
    memcpy(__dst, (char *)this + 64, 0x110uLL);
    unsigned int v7 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 2, 6, (thread_state_t)this + 16, 0x44u, __dst, &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v7, out_stateCnt);
    }
    GPRuint64_t State = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, __dst, 0x44u);
    *((_DWORD *)this + 1651) = GPRState;
    *((_DWORD *)this + 1650) = -1;
  }
  return GPRState == 0;
}

uint64_t DNBArchMachARM64::GetSP(DNBArchMachARM64 *this, uint64_t a2)
{
  if (!DNBArchMachARM64::GetGPRState(this, 0))
  {
    uint64_t v4 = *((void *)this + 39);
    unsigned int v7 = 0;
    if (DNBGetAddressingBits(&v7)) {
      uint64_t v5 = ~(-1 << v7);
    }
    else {
      uint64_t v5 = -1;
    }
    return v5 & v4;
  }
  return a2;
}

uint64_t DNBArchMachARM64::GetVFPState(DNBArchMachARM64 *this, char a2)
{
  if ((a2 & 1) == 0 && !*((_DWORD *)this + 1652)) {
    return 0;
  }
  mach_msg_type_number_t old_stateCnt = 132;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 17, (thread_state_t)this + 84, &old_stateCnt);
  if (DNBLogEnabledForAny(4) && DNBLogEnabled())
  {
    long long v4 = *((_OWORD *)this + 21);
    long long v5 = *((_OWORD *)this + 22);
    long long v6 = *((_OWORD *)this + 23);
    long long v7 = *((_OWORD *)this + 24);
    long long v8 = *((_OWORD *)this + 25);
    long long v9 = *((_OWORD *)this + 26);
    long long v10 = *((_OWORD *)this + 27);
    long long v11 = *((_OWORD *)this + 28);
    long long v12 = *((_OWORD *)this + 29);
    long long v13 = *((_OWORD *)this + 30);
    long long v14 = *((_OWORD *)this + 31);
    long long v15 = *((_OWORD *)this + 32);
    long long v16 = *((_OWORD *)this + 45);
    long long v17 = *((_OWORD *)this + 46);
    long long v18 = *((_OWORD *)this + 47);
    long long v19 = *((_OWORD *)this + 48);
    long long v20 = *((_OWORD *)this + 49);
    long long v21 = *((_OWORD *)this + 50);
    long long v22 = *((_OWORD *)this + 51);
    _DNBLogThreaded("thread_get_state(0x%4.4x, %u, &vfp, %u) => 0x%8.8x (count = %u) regs\n   q0  = 0x%16.16llx%16.16llx\n   q1  = 0x%16.16llx%16.16llx\n   q2  = 0x%16.16llx%16.16llx\n   q3  = 0x%16.16llx%16.16llx\n   q4  = 0x%16.16llx%16.16llx\n   q5  = 0x%16.16llx%16.16llx\n   q6  = 0x%16.16llx%16.16llx\n   q7  = 0x%16.16llx%16.16llx\n   q8  = 0x%16.16llx%16.16llx\n   q9  = 0x%16.16llx%16.16llx\n   q10 = 0x%16.16llx%16.16llx\n   q11 = 0x%16.16llx%16.16llx\n   q12 = 0x%16.16llx%16.16llx\n   q13 = 0x%16.16llx%16.16llx\n   q14 = 0x%16.16llx%16.16llx\n   q15 = 0x%16.16llx%16.16llx\n   q16 = 0x%16.16llx%16.16llx\n   q17 = 0x%16.16llx%16.16llx\n"
      "   q18 = 0x%16.16llx%16.16llx\n"
      "   q19 = 0x%16.16llx%16.16llx\n"
      "   q20 = 0x%16.16llx%16.16llx\n"
      "   q21 = 0x%16.16llx%16.16llx\n"
      "   q22 = 0x%16.16llx%16.16llx\n"
      "   q23 = 0x%16.16llx%16.16llx\n"
      "   q24 = 0x%16.16llx%16.16llx\n"
      "   q25 = 0x%16.16llx%16.16llx\n"
      "   q26 = 0x%16.16llx%16.16llx\n"
      "   q27 = 0x%16.16llx%16.16llx\n"
      "   q28 = 0x%16.16llx%16.16llx\n"
      "   q29 = 0x%16.16llx%16.16llx\n"
      "   q30 = 0x%16.16llx%16.16llx\n"
      "   q31 = 0x%16.16llx%16.16llx\n"
      "  fpsr = 0x%8.8x\n"
      "  fpcr = 0x%8.8x\n"
      "\n",
      *(_DWORD *)(*((void *)this + 2) + 16),
      2,
      132,
      state,
      old_stateCnt,
      (void)v4,
      *((void *)&v4 + 1),
      (void)v5,
      *((void *)&v5 + 1),
      (void)v6,
      *((void *)&v6 + 1),
      (void)v7,
      *((void *)&v7 + 1),
      (void)v8,
      *((void *)&v8 + 1),
      (void)v9,
      *((void *)&v9 + 1),
      (void)v10,
      *((void *)&v10 + 1),
      (void)v11,
      *((void *)&v11 + 1),
      (void)v12,
      *((void *)&v12 + 1),
      (void)v13,
      *((void *)&v13 + 1),
      (void)v14,
      *((void *)&v14 + 1),
      (void)v15,
      *((void *)&v15 + 1),
      *((void *)this + 66),
      *((void *)this + 67),
      *((void *)this + 68),
      *((void *)this + 69),
      *((void *)this + 70),
      *((void *)this + 71),
      *((void *)this + 72),
      *((void *)this + 73),
      *((void *)this + 74),
      *((void *)this + 75),
      *((void *)this + 76),
      *((void *)this + 77),
      *((void *)this + 78),
      *((void *)this + 79),
      *((void *)this + 80),
      *((void *)this + 81),
      *((void *)this + 82),
      *((void *)this + 83),
      *((void *)this + 84),
      *((void *)this + 85),
      *((void *)this + 86),
      *((void *)this + 87),
      *((void *)this + 88),
      *((void *)this + 89),
      (void)v16,
      *((void *)&v16 + 1),
      (void)v17,
      *((void *)&v17 + 1),
      (void)v18,
      *((void *)&v18 + 1),
      (void)v19,
      *((void *)&v19 + 1),
      (void)v20,
      *((void *)&v20 + 1),
      (void)v21,
      *((void *)&v21 + 1),
      (void)v22,
      *((void *)&v22 + 1),
      *((void *)this + 104),
      *((void *)this + 105),
      *((_DWORD *)this + 212),
      *((_DWORD *)this + 213));
  }
  *((_DWORD *)this + 1652) = state;
  return state;
}

void DNBArchMachARM64::ThreadWillResume(DNBArchMachARM64 *this)
{
  kern_return_t state;
  uint64_t v4;
  int v5;
  mach_msg_type_number_t old_stateCnt;

  vm_prot_t v2 = (char *)this + 7228;
  if (MachThread::IsStepping(*((MachThread **)this + 2))) {
    DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 1);
  }
  if (*v2 && (*((_DWORD *)this + 1806) & 0x80000000) == 0)
  {
    mach_msg_type_number_t old_stateCnt = 130;
    uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt);
    long long v4 = *((unsigned int *)this + 1806);
    if (state || (*((void *)this + v4 + 808) & 1) != 0)
    {
      (*(void (**)(DNBArchMachARM64 *, uint64_t, void))(*(void *)this + 176))(this, v4, 0);
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::ThreadWillResume() DisableHardwareWatchpoint(%d) called", *((_DWORD *)this + 1806));
      }
      long long v5 = DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 1);
      v2[1] = v5 == 0;
      if (v5)
      {
        char *v2 = 0;
        *((_DWORD *)this + 1806) = -1;
        if (DNBLogEnabledForAny(2048)) {
          _DNBLogThreaded("DNBArchMachARM64::ThreadWillResume() failed to enable single step");
        }
      }
      else if (DNBLogEnabledForAny(2048))
      {
        _DNBLogThreaded("DNBArchMachARM64::ThreadWillResume() succeeded to enable single step");
      }
    }
    else
    {
      char *v2 = 0;
      *((_DWORD *)this + 1806) = -1;
    }
  }
}

uint64_t DNBArchMachARM64::EnableHardwareSingleStep(natural_t *this, int a2)
{
  kern_return_t state;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  unsigned int GPRState;
  int v13;
  void *__p;
  uint64_t v15;
  uint64_t v16;
  mach_msg_type_number_t old_stateCnt;

  long long __p = 0;
  long long v15 = 0;
  long long v16 = 0;
  if (DNBLogEnabledForAny(4096)) {
    _DNBLogThreaded("%s( enable = %d)", "EnableHardwareSingleStep", a2);
  }
  GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, 0);
  long long v13 = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v16) = 0;
  if (GPRState)
  {
    DNBError::LogThreaded((DNBError *)&GPRState, "%s: failed to read the GPR registers");
    goto LABEL_8;
  }
  mach_msg_type_number_t old_stateCnt = 130;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, this + 1520, &old_stateCnt);
  GPRuint64_t State = state;
  long long v13 = 1;
  if (SHIBYTE(v16) < 0)
  {
    *(unsigned char *)long long __p = 0;
    long long v15 = 0;
    if (GPRState) {
      goto LABEL_7;
    }
LABEL_12:
    long long v7 = *((void *)this + 40);
    mach_msg_type_number_t old_stateCnt = 0;
    if (DNBGetAddressingBits(&old_stateCnt)) {
      long long v8 = ~(-1 << old_stateCnt);
    }
    else {
      long long v8 = -1;
    }
    long long v9 = v8 & v7;
    long long v10 = DNBLogEnabledForAny(4096);
    if (a2)
    {
      if (v10) {
        _DNBLogThreaded("%s: Setting MDSCR_EL1 Single Step bit at pc 0x%llx", "EnableHardwareSingleStep", v9);
      }
      long long v11 = *((void *)this + 824) | 1;
    }
    else
    {
      if (v10) {
        _DNBLogThreaded("%s: Clearing MDSCR_EL1 Single Step bit at pc 0x%llx", "EnableHardwareSingleStep", v9);
      }
      long long v11 = *((void *)this + 824) & 0xFFFFFFFELL;
    }
    *((void *)this + 824) = v11;
    long long v5 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, this + 1520, 0x82u);
    if (SHIBYTE(v16) < 0) {
      goto LABEL_9;
    }
    return v5;
  }
  LOBYTE(__p) = 0;
  HIBYTE(v16) = 0;
  if (!state) {
    goto LABEL_12;
  }
LABEL_7:
  DNBError::LogThreaded((DNBError *)&GPRState, "%s: failed to read the DBG registers");
LABEL_8:
  long long v5 = GPRState;
  if (SHIBYTE(v16) < 0) {
LABEL_9:
  }
    operator delete(__p);
  return v5;
}

uint64_t DNBArchMachARM64::NotifyException(DNBArchMachARM64 *this, MachException::Data *a2)
{
  if (*((_DWORD *)a2 + 2) != 6) {
    return 0;
  }
  mach_vm_size_t v3 = (void *)*((void *)a2 + 2);
  if (*((void *)a2 + 3) - (void)v3 != 16) {
    return 0;
  }
  if (*v3 == 1)
  {
    unint64_t v15 = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 88))(this, -1);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      mach_vm_address_t v16 = v15;
      if (!DNBBreakpointList::FindByAddress((DNBBreakpointList *)(**((void **)this + 2) + 1640), v15)
        && MachProcess::ReadMemory(**((MachProcess ***)this + 2), v16, 4uLL, (char *)&v39) == 4
        && v39 == -734134272)
      {
        (*(void (**)(DNBArchMachARM64 *, mach_vm_address_t))(*(void *)this + 96))(this, v16 + 4);
      }
    }
    return 0;
  }
  if (*v3 != 258) {
    return 0;
  }
  uint64_t v39 = v3[1];
  unsigned int v5 = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t *))(*(void *)this + 184))(this, &v39);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::NotifyException watchpoint %d was hit on address 0x%llx", v5, v39);
  }
  unsigned int v6 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this);
  if (v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = v6;
    long long v9 = (char *)this + 6464;
    long long v10 = LoHi;
    do
    {
      uint64_t v11 = *v10;
      if (v7 != v11 && v11 != 0 && v11 == v5)
      {
        mach_msg_type_number_t old_stateCnt = 130;
        if (!thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)&& v7 < (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this)&& (*v9 & 1) != 0&& *((void *)v9 - 16) != -1)
        {
          mach_msg_type_number_t old_stateCnt = 130;
          if (!thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)&& v7 < (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this)&& (*v9 & 1) != 0)
          {
            uint64_t v14 = *((void *)v9 - 16);
          }
          else
          {
            uint64_t v14 = -1;
          }
          uint64_t v39 = v14;
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded("DNBArchMachARM64::NotifyException It is a linked watchpoint; rewritten to index %d addr 0x%llx",
          }
              *v10,
              v39);
        }
      }
      ++v7;
      ++v10;
      v9 += 8;
    }
    while (v8 != v7);
  }
  if (v5 == -1) {
    return 1;
  }
  *((unsigned char *)this + 7228) = 1;
  *((_DWORD *)this + 1806) = v5;
  long long v18 = (char *)*((void *)a2 + 2);
  *((void *)v18 + 1) = v39;
  uint64_t v19 = v5;
  long long v21 = (char *)*((void *)a2 + 3);
  unint64_t v20 = *((void *)a2 + 4);
  if ((unint64_t)v21 >= v20)
  {
    uint64_t v23 = (v21 - v18) >> 3;
    unint64_t v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) >> 61) {
      abort();
    }
    uint64_t v25 = v20 - (void)v18;
    if (v25 >> 2 > v24) {
      unint64_t v24 = v25 >> 2;
    }
    if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26)
    {
      if (v26 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v27 = operator new(8 * v26);
    }
    else
    {
      unint64_t v27 = 0;
    }
    long long v28 = &v27[8 * v23];
    unint64_t v29 = &v27[8 * v26];
    *long long v28 = v19;
    long long v22 = v28 + 1;
    if (v21 == v18)
    {
      *((void *)a2 + 2) = v28;
      *((void *)a2 + 3) = v22;
      *((void *)a2 + 4) = v29;
    }
    else
    {
      unint64_t v30 = v21 - v18 - 8;
      if (v30 < 0x58) {
        goto LABEL_65;
      }
      if ((unint64_t)(v18 - v27) < 0x20) {
        goto LABEL_65;
      }
      uint64_t v31 = (v30 >> 3) + 1;
      uint64_t v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v33 = &v21[-v32];
      long long v28 = (void *)((char *)v28 - v32);
      int v34 = &v27[v21 - v18 - 16];
      int v35 = v21 - 16;
      uint64_t v36 = v31 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v37 = *(_OWORD *)v35;
        *(v34 - 1) = *((_OWORD *)v35 - 1);
        _OWORD *v34 = v37;
        v34 -= 2;
        v35 -= 32;
        v36 -= 4;
      }
      while (v36);
      long long v21 = v33;
      if (v31 != (v31 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_65:
        do
        {
          uint64_t v38 = *((void *)v21 - 1);
          v21 -= 8;
          *--long long v28 = v38;
        }
        while (v21 != v18);
      }
      *((void *)a2 + 2) = v28;
      *((void *)a2 + 3) = v22;
      *((void *)a2 + 4) = v29;
      if (!v18) {
        goto LABEL_59;
      }
    }
    operator delete(v18);
  }
  else
  {
    *(void *)long long v21 = v19;
    long long v22 = v21 + 8;
  }
LABEL_59:
  *((void *)a2 + 3) = v22;
  return 1;
}

BOOL DNBArchMachARM64::ThreadDidStop(DNBArchMachARM64 *this)
{
  vm_prot_t v2 = (_WORD *)((char *)this + 7228);
  *((_DWORD *)this + 1650) = -1;
  *((_DWORD *)this + 1652) = -1;
  *((_DWORD *)this + 1654) = -1;
  *((_DWORD *)this + 1658) = -1;
  *((_DWORD *)this + 1656) = -1;
  if (*((unsigned char *)this + 7229))
  {
    if (DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 0))
    {
      if (DNBLogEnabled()) {
        _DNBLogError("internal error detected: m_watchpoint_resume_step_enabled is true but unable to disable single step!");
      }
    }
    else if (!*(unsigned char *)v2 || (*((_DWORD *)this + 1806) & 0x80000000) != 0)
    {
      if (DNBLogEnabled()) {
        _DNBLogError("internal error detected: m_watchpoint_resume_step_enabled is true but (m_watchpoint_did_occur && m_watchpoint_hw_index >= 0) does not hold!");
      }
    }
    else
    {
      (*(void (**)(DNBArchMachARM64 *))(*(void *)this + 224))(this);
      _WORD *v2 = 0;
      *((_DWORD *)this + 1806) = -1;
    }
  }
  uint64_t v3 = 1;
  if (!DNBArchMachARM64::GetGPRState(this, 1) && MachThread::IsStepping(*((MachThread **)this + 2))) {
    return DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 0) == 0;
  }
  return v3;
}

uint64_t DNBArchMachARM64::NumSupportedHardwareWatchpoints(DNBArchMachARM64 *this)
{
  uint64_t result = DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints;
  if (DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints == -1)
  {
    DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints = 0;
    int v2 = 0;
    size_t v3 = 4;
    if (!sysctlbyname("hw.optional.watchpoint", &v2, &v3, 0, 0))
    {
      DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints = v2;
      if (DNBLogEnabledForAny(4)) {
        _DNBLogThreaded("hw.optional.watchpoint=%u", v2);
      }
    }
    return DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints;
  }
  return result;
}

uint64_t DNBArchMachARM64::NumSupportedHardwareBreakpoints(DNBArchMachARM64 *this)
{
  uint64_t result = DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints;
  if (DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints == -1)
  {
    DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints = 0;
    int v2 = 0;
    size_t v3 = 4;
    if (!sysctlbyname("hw.optional.breakpoint", &v2, &v3, 0, 0))
    {
      DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints = v2;
      if (DNBLogEnabledForAny(4)) {
        _DNBLogThreaded("hw.optional.breakpoint=%u", v2);
      }
    }
    return DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints;
  }
  return result;
}

uint64_t DNBArchMachARM64::EnableHardwareBreakpoint(DNBArchMachARM64 *this, unint64_t a2, uint64_t a3, int a4)
{
  kern_return_t v16;
  kern_return_t v17;
  kern_return_t v18;
  mach_msg_type_number_t old_stateCnt;

  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint(addr = 0x%8.8llx, std::string::size_type size = %zu)", a2, a3);
  }
  unsigned int v8 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 136))(this);
  unint64_t v9 = a2 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v10 = 103;
  if (a3 != 2)
  {
    unint64_t v9 = a2;
    uint64_t v10 = 0;
  }
  if (a3 == 4) {
    unint64_t v11 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  }
  else {
    unint64_t v11 = v9;
  }
  if (a3 == 4) {
    uint64_t v12 = 487;
  }
  else {
    uint64_t v12 = v10;
  }
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)) {
    return 0xFFFFFFFFLL;
  }
  if (!v8)
  {
LABEL_17:
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint(): All hardware resources (%u) are in use.", v8);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = 0;
  unint64_t v15 = (uint64_t *)((char *)this + 6208);
  while ((*(unsigned char *)v15 & 1) != 0)
  {
    --v14;
    ++v15;
    if (-(uint64_t)v8 == v14) {
      goto LABEL_17;
    }
  }
  *(v15 - 16) = v11;
  uint64_t *v15 = v12;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint() adding breakpoint on address 0x%llx with control register value 0x%x", *(v15 - 16), *v15);
  }
  mach_vm_address_t v16 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, 0x82u);
  if (a4)
  {
    long long v17 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120), 15, (thread_state_t)this + 1520, 0x82u);
    if (v17)
    {
      long long v18 = v17;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v18);
      }
    }
  }
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint() SetDBGState() => 0x%8.8x.", v16);
  }
  if (v16) {
    return 0xFFFFFFFFLL;
  }
  return -v14;
}

void DNBArchMachARM64::AlignRequestedWatchpoint(DNBArchMachARM64 *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (!a3)
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    return;
  }
  uint64_t v7 = 8;
  if (a3 > 8) {
    uint64_t v7 = a3;
  }
  uint64_t v8 = 1 << -(char)__clz(v7 - 1);
  unint64_t v9 = -v8 & a2;
  unint64_t v10 = v9 + v8;
  if (v9 + v8 >= a3 + a2)
  {
    uint64_t v19 = operator new(0x20uLL);
    a4[1] = v19 + 4;
    a4[2] = v19 + 4;
    *uint64_t v19 = v9;
    v19[1] = a2;
    v19[2] = v8;
    v19[3] = a3;
    *a4 = v19;
    return;
  }
  DNBArchMachARM64::AlignRequestedWatchpoint(v21, this, a2, v10 - a2);
  DNBArchMachARM64::AlignRequestedWatchpoint(v20, this, v9 + v8, a3 - (v10 - a2));
  uint64_t v12 = (void *)v21[0];
  long long v13 = (void *)v20[0];
  if (v21[1] - v21[0] == 32 && v20[1] - v20[0] == 32)
  {
    long long v14 = *(_OWORD *)(v21[0] + 16);
    long long v22 = *(_OWORD *)v21[0];
    long long v23 = v14;
    long long v15 = *(_OWORD *)(v20[0] + 16);
    long long v24 = *(_OWORD *)v20[0];
    long long v25 = v15;
    mach_vm_address_t v16 = operator new(0x40uLL);
    a4[1] = v16 + 4;
    a4[2] = v16 + 4;
    long long v17 = v23;
    _OWORD *v16 = v22;
    v16[1] = v17;
    long long v18 = v25;
    v16[2] = v24;
    v16[3] = v18;
    *a4 = v16;
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    if (!v13) {
      goto LABEL_12;
    }
  }
  operator delete(v13);
LABEL_12:
  if (v12) {
    operator delete(v12);
  }
}

uint64_t DNBArchMachARM64::EnableHardwareWatchpoint(DNBArchMachARM64 *this, unint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareWatchpoint(addr = 0x%8.8llx, std::string::size_type size = %zu, read = %u, write = %u)", a2, a3, a4, a5);
  }
  DNBArchMachARM64::AlignRequestedWatchpoint(this, a2, a3, &v51);
  BOOL v10 = DNBLogEnabledForAny(2048);
  uint64_t v12 = v51;
  unint64_t v11 = v52;
  if (v10) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareWatchpoint() using %zu hardware watchpoints", (v52 - v51) >> 5);
  }
  uint64_t v13 = a5;
  uint64_t v14 = 0xFFFFFFFFLL;
  if ((a4 | a5) != 1) {
    goto LABEL_51;
  }
  uint64_t v15 = v11 - v12;
  if (v11 == v12) {
    goto LABEL_51;
  }
  if (v15 == 32)
  {
    long long v16 = *((_OWORD *)v12 + 1);
    if (*((void *)v12 + 2) > 8uLL)
    {
      v49[0] = *(_OWORD *)v12;
      v49[1] = v16;
      uint64_t v14 = DNBArchMachARM64::SetMASKWatchpoint((uint64_t)this, v49, a4, a5, a6);
    }
    else
    {
      v50[0] = *(_OWORD *)v12;
      v50[1] = v16;
      uint64_t v14 = DNBArchMachARM64::SetBASWatchpoint((uint64_t)this, (uint64_t *)v50, a4, a5, a6);
    }
    goto LABEL_52;
  }
  uint64_t v17 = 0;
  long long v18 = 0;
  uint64_t v19 = 0;
  unint64_t v20 = 0;
  unint64_t v21 = v15 >> 5;
  unint64_t v44 = v21;
  uint64_t v45 = v12;
  if (v21 <= 1) {
    unint64_t v21 = 1;
  }
  unint64_t v48 = v21;
  uint64_t v22 = a4;
  do
  {
    int v23 = (*(uint64_t (**)(DNBArchMachARM64 *, void, void, uint64_t, uint64_t, uint64_t))(*(void *)this + 160))(this, *(void *)&v12[32 * v17 + 8], *(void *)&v12[32 * v17 + 24], v22, v13, a6);
    if (v23 == -1) {
      goto LABEL_14;
    }
    int v24 = v23;
    if (v20 < v19)
    {
      *(_DWORD *)unint64_t v20 = v23;
      v20 += 4;
      goto LABEL_14;
    }
    uint64_t v25 = (v20 - v18) >> 2;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 62) {
      abort();
    }
    if ((v19 - v18) >> 1 > v26) {
      unint64_t v26 = (v19 - v18) >> 1;
    }
    if ((unint64_t)(v19 - v18) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v26;
    }
    if (v27)
    {
      if (v27 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v28 = operator new(4 * v27);
    }
    else
    {
      long long v28 = 0;
    }
    unint64_t v29 = &v28[4 * v25];
    *(_DWORD *)unint64_t v29 = v24;
    unint64_t v30 = v29 + 4;
    if (v20 != v18)
    {
      unint64_t v31 = v20 - v18 - 4;
      if (v31 >= 0xBC
        && (unint64_t v32 = (v20 - 4 - v18) & 0xFFFFFFFFFFFFFFFCLL, &v28[v20 - v18 - 4 - v32] <= &v28[v20 - v18 - 4])
        && &v20[-v32 - 4] <= v20 - 4
        && (unint64_t)(v18 - v28) >= 0x20)
      {
        uint64_t v35 = (v31 >> 2) + 1;
        uint64_t v36 = 4 * (v35 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v33 = (unsigned int *)&v20[-v36];
        v29 -= v36;
        long long v37 = &v28[4 * v25 - 16];
        uint64_t v38 = v20 - 16;
        uint64_t v39 = v35 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v40 = *(_OWORD *)v38;
          *(v37 - 1) = *((_OWORD *)v38 - 1);
          *long long v37 = v40;
          v37 -= 2;
          v38 -= 32;
          v39 -= 8;
        }
        while (v39);
        uint64_t v22 = a4;
        if (v35 == (v35 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_34:
          uint64_t v19 = &v28[4 * v27];
          if (!v18) {
            goto LABEL_37;
          }
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v33 = (unsigned int *)v20;
        uint64_t v22 = a4;
      }
      do
      {
        int v34 = *--v33;
        *((_DWORD *)v29 - 1) = v34;
        v29 -= 4;
      }
      while (v33 != (unsigned int *)v18);
      goto LABEL_34;
    }
    uint64_t v22 = a4;
    uint64_t v19 = &v28[4 * v27];
    if (!v18)
    {
LABEL_37:
      unint64_t v20 = v30;
      goto LABEL_38;
    }
LABEL_35:
    unint64_t v20 = v30;
    operator delete(v18);
LABEL_38:
    long long v18 = v29;
    uint64_t v12 = v45;
    uint64_t v13 = a5;
LABEL_14:
    ++v17;
  }
  while (v17 != v48);
  if (v44 == (v20 - v18) >> 2)
  {
    LoHi[*(unsigned int *)v18] = *((_DWORD *)v18 + 1);
    uint64_t v14 = *(unsigned int *)v18;
    goto LABEL_50;
  }
  if (v18 != v20)
  {
    uint64_t v41 = v18;
    do
    {
      unsigned int v42 = *(_DWORD *)v41;
      v41 += 4;
      (*(void (**)(DNBArchMachARM64 *, void, uint64_t))(*(void *)this + 176))(this, v42, a6);
    }
    while (v41 != v20);
  }
  uint64_t v14 = 0xFFFFFFFFLL;
  if (v18) {
LABEL_50:
  }
    operator delete(v18);
LABEL_51:
  if (v12) {
LABEL_52:
  }
    operator delete(v12);
  return v14;
}

uint64_t DNBArchMachARM64::SetBASWatchpoint(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  kern_return_t v22;
  kern_return_t v23;
  kern_return_t v24;
  int v26;
  mach_msg_type_number_t old_stateCnt;

  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
  uint64_t v12 = *a2;
  uint64_t v11 = a2[1];
  uint64_t v13 = a2[3];
  uint64_t v14 = 0xFFFFFFFFLL;
  mach_msg_type_number_t old_stateCnt = 130;
  if (!thread_get_state(*(_DWORD *)(*(void *)(a1 + 16) + 16), 15, (thread_state_t)(a1 + 6080), &old_stateCnt))
  {
    unint64_t v26 = a5;
    if (v10)
    {
      uint64_t v15 = 0;
      while ((*(void *)(a1 + 6464 + 8 * v15) & 1) != 0)
      {
        if (v10 == ++v15) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      LODWORD(v15) = 0;
    }
    if (v15 == v10)
    {
LABEL_9:
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint(): All hardware resources (%u) are in use.", v10);
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v16 = v11 - v12;
      int v17 = ~(-1 << v13) << (v11 - v12);
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint() set hardware register %d to BAS watchpoint aligned start address 0x%llx, watch region start offset %lld, number of bytes %zu", v15, v12, v16, v13);
      }
      LoHi[v15] = 0;
      uint64_t v18 = a1 + 8 * v15;
      *(void *)(v18 + 6336) = v12;
      if (a3) {
        int v19 = 8;
      }
      else {
        int v19 = 0;
      }
      int v20 = v19 | (32 * v17);
      if (a4) {
        int v21 = 16;
      }
      else {
        int v21 = 0;
      }
      *(void *)(v18 + 6464) = v20 | v21 | 5u;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint() adding watchpoint on address 0x%llx with control register value 0x%x", *(void *)(v18 + 6336), *(void *)(v18 + 6464));
      }
      uint64_t v22 = thread_set_state(*(_DWORD *)(*(void *)(a1 + 16) + 16), 15, (thread_state_t)(a1 + 6080), 0x82u);
      if (v26)
      {
        int v23 = task_set_state(*(_DWORD *)(**(void **)(a1 + 16) + 120), 15, (thread_state_t)(a1 + 6080), 0x82u);
        if (v23)
        {
          int v24 = v23;
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v24);
          }
        }
      }
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint() SetDBGState() => 0x%8.8x.", v22);
      }
      if (v22) {
        return 0xFFFFFFFFLL;
      }
      else {
        return v15;
      }
    }
  }
  return v14;
}

uint64_t DNBArchMachARM64::SetMASKWatchpoint(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  kern_return_t v19;
  kern_return_t v20;
  kern_return_t v21;
  mach_msg_type_number_t old_stateCnt;

  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*(void *)(a1 + 16) + 16), 15, (thread_state_t)(a1 + 6080), &old_stateCnt)) {
    return 0xFFFFFFFFLL;
  }
  if (v10)
  {
    uint64_t v12 = 0;
    while ((*(void *)(a1 + 6464 + 8 * v12) & 1) != 0)
    {
      if (v10 == ++v12) {
        goto LABEL_11;
      }
    }
  }
  else
  {
    LODWORD(v12) = 0;
  }
  if (v12 == v10)
  {
LABEL_11:
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint(): All hardware resources (%u) are in use.", v10);
    }
    return 0xFFFFFFFFLL;
  }
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint() set hardware register %d to MASK watchpoint aligned start address 0x%llx, aligned size %zu", v12, *a2, a2[2]);
  }
  LoHi[v12] = 0;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)(a2[2] - 1));
  v13.i16[0] = vaddlv_u8(v13);
  uint64_t v14 = *a2;
  uint64_t v15 = a1 + 8 * v12;
  *(void *)(v15 + 6336) = v14;
  uint64_t v16 = 8;
  if (!a3) {
    uint64_t v16 = 0;
  }
  unint64_t v17 = v16 | ((unint64_t)v13.u32[0] << 24);
  uint64_t v18 = 16;
  if (!a4) {
    uint64_t v18 = 0;
  }
  *(void *)(v15 + 6464) = v17 | v18 | 0x1FE5;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint() adding watchpoint on address 0x%llx with control register value 0x%llx", *(void *)(v15 + 6336), *(void *)(v15 + 6464));
  }
  int v19 = thread_set_state(*(_DWORD *)(*(void *)(a1 + 16) + 16), 15, (thread_state_t)(a1 + 6080), 0x82u);
  if (a5)
  {
    int v20 = task_set_state(*(_DWORD *)(**(void **)(a1 + 16) + 120), 15, (thread_state_t)(a1 + 6080), 0x82u);
    if (v20)
    {
      int v21 = v20;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v21);
      }
    }
  }
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint() SetDBGState() => 0x%8.8x.", v19);
  }
  if (v19) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v12;
  }
}

uint64_t DNBArchMachARM64::ReenableHardwareWatchpoint(DNBArchMachARM64 *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if ((*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this) > a2
    && LoHi[v2])
  {
    uint64_t result = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 232))(this, v2);
    if (!result) {
      return result;
    }
    uint64_t v2 = LoHi[v2];
  }
  unsigned int v5 = *(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 232);

  return v5(this, v2);
}

BOOL DNBArchMachARM64::ReenableHardwareWatchpoint_helper(DNBArchMachARM64 *this, unsigned int a2)
{
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this) <= a2)
  {
    return 0;
  }
  uint64_t v4 = *((void *)this + 897) + 16 * a2;
  unsigned int v5 = (char *)this + 8 * a2;
  *((void *)v5 + 792) = *(void *)v4;
  *((void *)v5 + 808) = *(unsigned int *)(v4 + 8);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::ReenableHardwareWatchpoint_helper( %u) - WVR%u = 0x%8.8llx  WCR%u = 0x%8.8llx", a2, a2, *((void *)v5 + 792), a2, *((void *)v5 + 808));
  }
  return thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, 0x82u) == 0;
}

BOOL DNBArchMachARM64::DisableHardwareWatchpoint(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  unsigned int v4 = a2;
  if ((*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this) > a2 && LoHi[v4])
  {
    BOOL result = DNBArchMachARM64::DisableHardwareWatchpoint_helper(this, v4, a3);
    if (!result) {
      return result;
    }
    unsigned int v4 = LoHi[v4];
  }

  return DNBArchMachARM64::DisableHardwareWatchpoint_helper(this, v4, a3);
}

BOOL DNBArchMachARM64::DisableHardwareWatchpoint_helper(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  kern_return_t v9;
  kern_return_t v10;
  kern_return_t v11;
  mach_msg_type_number_t old_stateCnt;

  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this) <= a2)
  {
    return 0;
  }
  unsigned int v6 = (char *)this + 8 * a2;
  uint64_t v7 = *((void *)this + 897) + 16 * a2;
  *(void *)uint64_t v7 = *((void *)v6 + 792);
  uint64_t v8 = *((void *)v6 + 808);
  *(_DWORD *)(v7 + 8) = v8;
  *((void *)v6 + 808) = v8 & 0xFFFFFFFFFFFFFFFELL;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::DisableHardwareWatchpoint( %u) - WVR%u = 0x%8.8llx  WCR%u = 0x%8.8llx", a2, a2, *((void *)v6 + 792), a2, *((void *)v6 + 808));
  }
  unint64_t v9 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, 0x82u);
  if (a3)
  {
    int v10 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120), 15, (thread_state_t)this + 1520, 0x82u);
    if (v10)
    {
      uint64_t v11 = v10;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v11);
      }
    }
  }
  return v9 == 0;
}

BOOL DNBArchMachARM64::DisableHardwareBreakpoint(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  kern_return_t v10;
  kern_return_t v11;
  kern_return_t v12;
  mach_msg_type_number_t old_stateCnt;

  mach_msg_type_number_t old_stateCnt = 130;
  unsigned int v6 = (char *)this + 6080;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 136))(this) <= a2)
  {
    return 0;
  }
  uint64_t v7 = 8 * a2;
  uint64_t v8 = *((void *)this + 900) + 16 * a2;
  *(void *)uint64_t v8 = *(void *)&v6[v7];
  unint64_t v9 = (char *)this + v7;
  *(_DWORD *)(v8 + 8) = *(void *)((char *)this + v7 + 6208);
  *(void *)((char *)this + v7 + 6208) = 0;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::DisableHardwareBreakpoint( %u) - WVR%u = 0x%8.8llx  BCR%u = 0x%8.8llx", a2, a2, *(void *)&v6[8 * a2], a2, *((void *)v9 + 776));
  }
  int v10 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, 0x82u);
  if (a3)
  {
    uint64_t v11 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120), 15, (thread_state_t)this + 1520, 0x82u);
    if (v11)
    {
      uint64_t v12 = v11;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v12);
      }
    }
  }
  return v10 == 0;
}

uint64_t DNBArchMachARM64::GetHardwareWatchpointHit(DNBArchMachARM64 *this, unint64_t *a2)
{
  kern_return_t state;
  uint64_t v5;
  unsigned int v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  const char *v14;
  uint64_t v15;
  mach_msg_type_number_t old_stateCnt;

  mach_msg_type_number_t old_stateCnt = 130;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, &old_stateCnt);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::GetHardwareWatchpointHit() GetDBGState() => 0x%8.8x.", state);
  }
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::GetHardwareWatchpointHit() addr = 0x%llx", *a2);
  }
  if (state) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 144))(this);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (void *)((char *)this + 6464);
  unint64_t v9 = -(uint64_t)v7;
  int v10 = 792;
  while (1)
  {
    uint64_t v11 = *(v8 - 16);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u (addr = 0x%llx, WCR = 0x%llx)", v10 - 792, v11, *v8);
    }
    uint64_t v12 = *v8;
    if ((*v8 & 1) == 0) {
      goto LABEL_12;
    }
    uint8x8_t v13 = BYTE3(v12) & 0x1F;
    if (DNBLogEnabledForAny(2048))
    {
      uint64_t v14 = "is MASK watchpoint";
      if (!v13) {
        uint64_t v14 = "is BAS watchpoint";
      }
      _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u %s", v10 - 792, v14);
    }
    if (!v13) {
      break;
    }
    if ((unint64_t)(v11 << 15) >> (v13 + 15) == *a2 << 15 >> (v13 + 15))
    {
      unsigned int v5 = v10 - 792;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u matched MASK ignoring %u low bits", v10 - 792, BYTE3(v12) & 0x1F);
      }
      return v5;
    }
LABEL_12:
    ++v10;
    ++v8;
    if (v9 + v10 == 792) {
      return 0xFFFFFFFFLL;
    }
  }
  if (((*a2 ^ v11) & 0x1FFFFFFFFFFF8) != 0) {
    goto LABEL_12;
  }
  if ((v12 & 0x20) != 0)
  {
    uint64_t v15 = 0;
  }
  else if ((v12 & 0x40) != 0)
  {
    uint64_t v15 = 1;
  }
  else if ((v12 & 0x80) != 0)
  {
    uint64_t v15 = 2;
  }
  else if ((v12 & 0x100) != 0)
  {
    uint64_t v15 = 3;
  }
  else if ((v12 & 0x200) != 0)
  {
    uint64_t v15 = 4;
  }
  else if ((v12 & 0x400) != 0)
  {
    uint64_t v15 = 5;
  }
  else if ((v12 & 0x800) != 0)
  {
    uint64_t v15 = 6;
  }
  else
  {
    uint64_t v15 = 7;
    if ((v12 & 0x1000) == 0) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
  }
  if (((v12 >> 5 >> (*a2 & 7)) & 1) == 0) {
    goto LABEL_12;
  }
  *a2 = v15 + v11;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u matched BAS", v10 - 792);
  }
  return v10 - 792;
}

unint64_t DNBArchMachARM64::GetRegisterValue(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  if (a2 == -1)
  {
    if (a3 > 0xA) {
      return 0;
    }
    unsigned int v5 = dword_100065EE8[a3];
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = a2;
  }
  int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64))(a1, v7, 0);
  unint64_t result = 0;
  if (!v8)
  {
    unint64_t result = MachThread::GetRegisterInfo(*(MachThread **)(a1 + 16), v7, v5);
    if (result)
    {
      *(_OWORD *)a4 = *(_OWORD *)result;
      long long v10 = *(_OWORD *)(result + 16);
      long long v11 = *(_OWORD *)(result + 32);
      long long v12 = *(_OWORD *)(result + 48);
      *(void *)(a4 + 64) = *(void *)(result + 64);
      *(_OWORD *)(a4 + 32) = v11;
      *(_OWORD *)(a4 + 48) = v12;
      *(_OWORD *)(a4 + 16) = v10;
      switch((int)v7)
      {
        case 1:
          if (v5 <= 0x20)
          {
            switch(v5)
            {
              case 0x1Du:
                uint64_t v13 = *(void *)(a1 + 296);
                unsigned int v28 = 0;
                BOOL v14 = DNBGetAddressingBits(&v28);
                char v15 = v28;
                goto LABEL_40;
              case 0x1Eu:
                *(void *)(a4 + 72) = *(void *)(a1 + 304);
                goto LABEL_45;
              case 0x1Fu:
                uint64_t v13 = *(void *)(a1 + 312);
                unsigned int v27 = 0;
                BOOL v14 = DNBGetAddressingBits(&v27);
                char v15 = v27;
                goto LABEL_40;
              case 0x20u:
                uint64_t v13 = *(void *)(a1 + 320);
                unsigned int v26 = 0;
                BOOL v14 = DNBGetAddressingBits(&v26);
                char v15 = v26;
LABEL_40:
                uint64_t v24 = -1 << v15;
                if (v14) {
                  uint64_t v25 = ~v24;
                }
                else {
                  uint64_t v25 = -1;
                }
                uint64_t v16 = v25 & v13;
                break;
              default:
                uint64_t v16 = *(void *)(a1 + 8 * v5 + 64);
                goto LABEL_44;
            }
            goto LABEL_44;
          }
          if (v5 != 33) {
            return 0;
          }
          *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 328);
          goto LABEL_45;
        case 2:
          if (v5 <= 0x1F)
          {
            *(_OWORD *)(a4 + 72) = *(_OWORD *)(a1 + 16 * v5 + 336);
            goto LABEL_45;
          }
          if (v5 == 33)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 852);
            goto LABEL_45;
          }
          if (v5 == 32)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 848);
            goto LABEL_45;
          }
          if (v5 <= 0x41)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 16 * (v5 - 34) + 336);
            goto LABEL_45;
          }
          if (v5 > 0x61) {
            return 0;
          }
          uint64_t v16 = *(void *)(a1 + 16 * (v5 - 66) + 336);
          goto LABEL_44;
        case 3:
          if (v5 == 2)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 876);
            goto LABEL_45;
          }
          if (v5 == 1)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 872);
            goto LABEL_45;
          }
          if (v5) {
            return 0;
          }
          uint64_t v16 = *(void *)(a1 + 864);
          goto LABEL_44;
        case 4:
          if (v5 <= 7)
          {
            unint64_t v17 = (_OWORD *)(a1 + ((unint64_t)v5 << 6));
            long long v18 = v17[56];
            long long v19 = v17[57];
            long long v20 = v17[58];
            long long v21 = v17[59];
LABEL_30:
            *(_OWORD *)(a4 + 120) = v21;
            *(_OWORD *)(a4 + 104) = v20;
            *(_OWORD *)(a4 + 88) = v19;
            *(_OWORD *)(a4 + 72) = v18;
            goto LABEL_45;
          }
          if (v5 <= 0xF)
          {
            uint64_t v22 = (_OWORD *)(a1 + ((unint64_t)(v5 - 8) << 6));
            long long v18 = v22[88];
            long long v19 = v22[89];
            long long v20 = v22[90];
            long long v21 = v22[91];
            goto LABEL_30;
          }
          if (v5 <= 0x4F)
          {
            int v23 = (_OWORD *)(a1 + ((unint64_t)(v5 - 16) << 6));
            long long v18 = v23[120];
            long long v19 = v23[121];
            long long v20 = v23[122];
            long long v21 = v23[123];
            goto LABEL_30;
          }
          if (v5 != 80) {
            return 0;
          }
          uint64_t v16 = *(void *)(a1 + 6016);
LABEL_44:
          *(void *)(a4 + 72) = v16;
LABEL_45:
          unint64_t result = 1;
          break;
        default:
          return 0;
      }
    }
  }
  return result;
}

unint64_t DNBArchMachARM64::SetRegisterValue(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  if (a2 == -1)
  {
    if (a3 > 0xA) {
      return 0;
    }
    unsigned int v5 = dword_100065EE8[a3];
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = a2;
  }
  int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64))(a1, v7, 0);
  unint64_t result = 0;
  if (!v8)
  {
    unint64_t result = MachThread::GetRegisterInfo(*(MachThread **)(a1 + 16), v7, v5);
    if (result)
    {
      switch((int)v7)
      {
        case 1:
          if (v5 > 0x20)
          {
            if (v5 != 33) {
              return 0;
            }
            *(_DWORD *)(a1 + 328) = *(_DWORD *)(a4 + 72);
          }
          else
          {
            uint64_t v10 = *(void *)(a4 + 72);
            uint64_t v11 = v10;
            switch(v5)
            {
              case 0x1Du:
                *(void *)(a1 + 296) = v10;
                break;
              case 0x1Eu:
                int v24 = *(_DWORD *)(a1 + 332);
                if (v11)
                {
                  if ((v24 & 1) == 0) {
                    v24 &= ~2u;
                  }
                  uint64_t v25 = *(void *)(a4 + 72);
                }
                else
                {
                  uint64_t v25 = 0;
                }
                *(void *)(a1 + 304) = v25;
                unsigned int v28 = v24 & 0xFFFFFFF7;
                goto LABEL_51;
              case 0x1Fu:
                *(void *)(a1 + 312) = v10;
                break;
              case 0x20u:
                int v26 = *(_DWORD *)(a1 + 332);
                if (v11) {
                  uint64_t v27 = *(void *)(a4 + 72);
                }
                else {
                  uint64_t v27 = 0;
                }
                *(void *)(a1 + 320) = v27;
                unsigned int v28 = v26 & 0xFFFFFFFB;
LABEL_51:
                *(_DWORD *)(a1 + 332) = v28;
                break;
              default:
                *(void *)(a1 + 8 * v5 + 64) = v10;
                break;
            }
          }
          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
        case 2:
          if (v5 <= 0x1F)
          {
            *(_OWORD *)(a1 + 16 * v5 + 336) = *(_OWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
          }
          if (v5 == 33)
          {
            *(_DWORD *)(a1 + 852) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
          }
          if (v5 == 32)
          {
            *(_DWORD *)(a1 + 848) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
          }
          if (v5 <= 0x41)
          {
            *(_DWORD *)(a1 + 16 * (v5 - 34) + 336) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
          }
          if (v5 > 0x61) {
            return 0;
          }
          *(void *)(a1 + 16 * (v5 - 66) + 336) = *(void *)(a4 + 72);
          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
        case 3:
          if (v5 == 2)
          {
            *(_DWORD *)(a1 + 876) = *(_DWORD *)(a4 + 72);
          }
          else if (v5 == 1)
          {
            *(_DWORD *)(a1 + 872) = *(_DWORD *)(a4 + 72);
          }
          else
          {
            if (v5) {
              return 0;
            }
            *(void *)(a1 + 864) = *(void *)(a4 + 72);
          }
          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v7) == 0;
        case 4:
          if (v5 <= 7)
          {
            long long v12 = (_OWORD *)(a1 + ((unint64_t)v5 << 6));
            long long v13 = *(_OWORD *)(a4 + 72);
            long long v14 = *(_OWORD *)(a4 + 88);
            long long v15 = *(_OWORD *)(a4 + 120);
            v12[58] = *(_OWORD *)(a4 + 104);
            v12[59] = v15;
            v12[56] = v13;
            v12[57] = v14;
            return 1;
          }
          if (v5 <= 0xF)
          {
            uint64_t v16 = (_OWORD *)(a1 + ((unint64_t)(v5 - 8) << 6));
            long long v17 = *(_OWORD *)(a4 + 72);
            long long v18 = *(_OWORD *)(a4 + 88);
            long long v19 = *(_OWORD *)(a4 + 104);
            v16[91] = *(_OWORD *)(a4 + 120);
            v16[90] = v19;
            v16[89] = v18;
            v16[88] = v17;
            return 1;
          }
          if (v5 <= 0x4F)
          {
            long long v20 = (_OWORD *)(a1 + ((unint64_t)(v5 - 16) << 6));
            long long v21 = *(_OWORD *)(a4 + 72);
            long long v22 = *(_OWORD *)(a4 + 88);
            long long v23 = *(_OWORD *)(a4 + 104);
            v20[123] = *(_OWORD *)(a4 + 120);
            v20[122] = v23;
            v20[121] = v22;
            v20[120] = v21;
            return 1;
          }
          if (v5 != 80) {
            return 0;
          }
          *(void *)(a1 + 6016) = *(void *)(a4 + 72);
          unint64_t result = 1;
          break;
        default:
          return 0;
      }
    }
  }
  return result;
}

uint64_t DNBArchMachARM64::GetRegisterState(natural_t *this, int a2, char a3)
{
  kern_return_t state;
  uint64_t v8;
  thread_read_t v10;
  natural_t *v11;
  thread_state_flavor_t v12;
  mach_msg_type_number_t old_stateCnt;
  uint64_t vars8;

  switch(a2)
  {
    case 0:
      GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, a3);
      int v6 = DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, a3) | GPRState;
      if ((a3 & 1) != 0 || this[1656])
      {
        mach_msg_type_number_t old_stateCnt = 4;
        uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, this + 216, &old_stateCnt);
        this[1656] = state;
      }
      else
      {
        uint64_t state = 0;
      }
      mach_msg_type_number_t old_stateCnt = 130;
      int v8 = v6 | state | thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, this + 1520, &old_stateCnt);
      mach_msg_type_number_t old_stateCnt = 1296;
      thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 25, this + 224, &old_stateCnt);
      return v8;
    case 1:
      return DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, a3);
    case 2:
      return DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, a3);
    case 3:
      if ((a3 & 1) == 0 && !this[1656]) {
        return 0;
      }
      mach_msg_type_number_t old_stateCnt = 4;
      int v8 = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, this + 216, &old_stateCnt);
      this[1656] = v8;
      return v8;
    case 4:
      mach_msg_type_number_t old_stateCnt = 1296;
      uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16);
      uint64_t v11 = this + 224;
      long long v12 = 25;
      goto LABEL_17;
    case 5:
      mach_msg_type_number_t old_stateCnt = 130;
      uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16);
      uint64_t v11 = this + 1520;
      long long v12 = 15;
LABEL_17:
      int v8 = thread_get_state(v10, v12, v11, &old_stateCnt);
      break;
    default:
      int v8 = 4;
      break;
  }
  return v8;
}

uint64_t DNBArchMachARM64::SetRegisterState(DNBArchMachARM64 *this, uint64_t a2)
{
  kern_return_t v5;
  kern_return_t v6;
  kern_return_t v7;
  kern_return_t v8;
  kern_return_t v9;
  thread_act_t v10;
  natural_t *v11;
  thread_state_flavor_t v12;
  mach_msg_type_number_t v13;
  kern_return_t v14;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;
  uint64_t vars8;

  int v2 = a2;
  uint64_t result = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t, void))(*(void *)this + 64))(this, a2, 0);
  if (!result)
  {
    switch(v2)
    {
      case 0:
        out_stateCnt = 68;
        memcpy(__dst, (char *)this + 64, 0x110uLL);
        unsigned int v5 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 2, 6, (thread_state_t)this + 16, 0x44u, __dst, &out_stateCnt);
        if (DNBLogEnabledForAny(4)) {
          _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v5, out_stateCnt);
        }
        int v6 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, __dst, 0x44u);
        *((_DWORD *)this + 1651) = v6;
        *((_DWORD *)this + 1650) = -1;
        uint64_t v7 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 17, (thread_state_t)this + 84, 0x84u);
        *((_DWORD *)this + 1653) = v7;
        *((_DWORD *)this + 1652) = -1;
        int v8 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, (thread_state_t)this + 216, 4u);
        *((_DWORD *)this + 1657) = v8;
        *((_DWORD *)this + 1656) = -1;
        unint64_t v9 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 15, (thread_state_t)this + 1520, 0x82u);
        uint64_t result = v9 | thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 25, (thread_state_t)this + 224, 0x510u) | v6 | v7 | v8;
        break;
      case 1:
        out_stateCnt = 68;
        memcpy(__dst, (char *)this + 64, 0x110uLL);
        long long v14 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 2, 6, (thread_state_t)this + 16, 0x44u, __dst, &out_stateCnt);
        if (DNBLogEnabledForAny(4)) {
          _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v14, out_stateCnt);
        }
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, __dst, 0x44u);
        *((_DWORD *)this + 1651) = result;
        *((_DWORD *)this + 1650) = -1;
        break;
      case 2:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 17, (thread_state_t)this + 84, 0x84u);
        *((_DWORD *)this + 1653) = result;
        *((_DWORD *)this + 1652) = -1;
        break;
      case 3:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, (thread_state_t)this + 216, 4u);
        *((_DWORD *)this + 1657) = result;
        *((_DWORD *)this + 1656) = -1;
        break;
      case 4:
        uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16);
        uint64_t v11 = (natural_t *)((char *)this + 896);
        long long v12 = 25;
        long long v13 = 1296;
        goto LABEL_15;
      case 5:
        uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16);
        uint64_t v11 = (natural_t *)((char *)this + 6080);
        long long v12 = 15;
        long long v13 = 130;
LABEL_15:
        uint64_t result = thread_set_state(v10, v12, v11, v13);
        break;
      default:
        uint64_t result = 4;
        break;
    }
  }
  return result;
}

BOOL DNBArchMachARM64::RegisterSetStateIsValid(DNBArchMachARM64 *this, int a2)
{
  switch(a2)
  {
    case 0:
      int v2 = *((_DWORD *)this + 1652) | *((_DWORD *)this + 1650) | *((_DWORD *)this + 1656) | *((_DWORD *)this + 1658);
      break;
    case 1:
      int v2 = *((_DWORD *)this + 1650);
      break;
    case 2:
      int v2 = *((_DWORD *)this + 1652);
      break;
    case 3:
      int v2 = *((_DWORD *)this + 1656);
      break;
    case 4:
      int v2 = *((_DWORD *)this + 1654);
      break;
    default:
      int v2 = -1;
      break;
  }
  return v2 == 0;
}

uint64_t DNBArchMachARM64::GetRegisterContext(natural_t *this, char *a2, unint64_t a3)
{
  kern_return_t state;
  uint64_t v9;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_type_number_t v12;

  if (a2 && a3)
  {
    GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, 0);
    int v7 = DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, 0) | GPRState;
    if (this[1656])
    {
      mach_msg_type_number_t old_stateCnt = 4;
      uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, this + 216, &old_stateCnt);
      this[1656] = state;
      if (v7 | state) {
        return 0;
      }
    }
    else if (v7)
    {
      return 0;
    }
    long long v12 = 1296;
    thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16), 25, this + 224, &v12);
    memcpy(a2, this + 16, 0x110uLL);
    memcpy(a2 + 272, this + 84, 0x220uLL);
    memcpy(a2 + 816, this + 224, 0x1440uLL);
    if (a3 >> 4 <= 0x176) {
      DNBArchMachARM64::GetRegisterContext();
    }
  }
  unint64_t v9 = 6000;
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("DNBArchMachARM64::GetRegisterContext (buf = %p, len = %zu) => %zu", a2, a3, 0x1770uLL);
  }
  return v9;
}

uint64_t DNBArchMachARM64::SetRegisterContext(DNBArchMachARM64 *this, char *__src, unint64_t a3)
{
  kern_return_t v8;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;

  uint64_t v5 = 0;
  if (__src && a3)
  {
    int v7 = (char *)this + 64;
    memcpy((char *)this + 64, __src, 0x110uLL);
    memcpy((char *)this + 336, __src + 272, 0x220uLL);
    memcpy((char *)this + 896, __src + 816, 0x1440uLL);
    if (a3 >> 4 <= 0x176) {
      DNBArchMachARM64::SetRegisterContext();
    }
    out_stateCnt = 68;
    memcpy(__dst, v7, 0x110uLL);
    int v8 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 2, 6, (thread_state_t)v7, 0x44u, __dst, &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v8, out_stateCnt);
    }
    *((_DWORD *)this + 1651) = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, __dst, 0x44u);
    *((_DWORD *)this + 1650) = -1;
    *((_DWORD *)this + 1653) = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 17, (thread_state_t)this + 84, 0x84u);
    *((_DWORD *)this + 1652) = -1;
    *((_DWORD *)this + 1657) = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 7, (thread_state_t)this + 216, 4u);
    *((_DWORD *)this + 1656) = -1;
    thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 25, (thread_state_t)this + 224, 0x510u);
    uint64_t v5 = 6000;
  }
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("DNBArchMachARM64::SetRegisterContext (buf = %p, len = %zu) => %zu", __src, a3, v5);
  }
  return v5;
}

uint64_t DNBArchMachARM64::SaveRegisterState(DNBArchMachARM64 *this)
{
  kern_return_t v2;
  uint64_t v3;
  char *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  uint64_t *v11;

  int v2 = thread_abort_safely(*(_DWORD *)(*((void *)this + 2) + 16));
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("thread = 0x%4.4x calling thread_abort_safely (tid) => %u (SetGPRState() for stop_count = %u)", *(_DWORD *)(*((void *)this + 2) + 16), v2, *(_DWORD *)(**((void **)this + 2) + 444));
  }
  if (DNBArchMachARM64::GetGPRState(this, 1))
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::SaveRegisterState () error: GPR regs failed to read: %u ");
    }
    return 0xFFFFFFFFLL;
  }
  if (DNBArchMachARM64::GetVFPState(this, 1))
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::SaveRegisterState () error: %s regs failed to read: %u");
    }
    return 0xFFFFFFFFLL;
  }
  size_t v3 = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = v3;
  uint64_t v5 = (char *)*((void *)this + 905);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 16);
        if (v3 >= v8) {
          break;
        }
        uint64_t v5 = (char *)*v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_18;
        }
      }
      if (v8 >= v3) {
        break;
      }
      uint64_t v5 = (char *)v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_18;
      }
    }
  }
  else
  {
    int v6 = (uint64_t **)((char *)this + 7240);
    int v7 = (uint64_t **)((char *)this + 7240);
LABEL_18:
    unint64_t v9 = (char *)v7;
    int v7 = (uint64_t **)operator new(0x1800uLL, (std::align_val_t)0x40uLL);
    *((_DWORD *)v7 + 16) = v3;
    bzero(v7 + 16, 0x1780uLL);
    *int v7 = 0;
    v7[1] = 0;
    v7[2] = (uint64_t *)v9;
    *int v6 = (uint64_t *)v7;
    uint64_t v10 = **((void **)this + 904);
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *((void *)this + 904) = v10;
      uint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 905), v11);
    ++*((void *)this + 906);
  }
  memcpy(v7 + 16, (char *)this + 64, 0x1780uLL);
  return v3;
}

uint64_t DNBArchMachARM64::RestoreRegisterState(DNBArchMachARM64 *this, unsigned int a2)
{
  kern_return_t v10;
  kern_return_t v11;
  kern_return_t v12;
  char *v13;
  char *v14;
  char *v15;
  BOOL v16;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;

  int v2 = (char *)*((void *)this + 905);
  if (!v2) {
    return 0;
  }
  unsigned int v4 = (char *)this + 7240;
  do
  {
    unsigned int v5 = *((_DWORD *)v2 + 16);
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      int v7 = (char **)v2;
    }
    else {
      int v7 = (char **)(v2 + 8);
    }
    if (v6) {
      unsigned int v4 = v2;
    }
    int v2 = *v7;
  }
  while (*v7);
  if (v4 == (char *)this + 7240 || *((_DWORD *)v4 + 16) > a2) {
    return 0;
  }
  memcpy((char *)this + 64, v4 + 128, 0x110uLL);
  memcpy((char *)this + 336, v4 + 400, 0x210uLL);
  out_stateCnt = 68;
  memcpy(__dst, (char *)this + 64, 0x110uLL);
  uint64_t v10 = thread_convert_thread_state(*(_DWORD *)(*((void *)this + 2) + 16), 2, 6, (thread_state_t)this + 16, 0x44u, __dst, &out_stateCnt);
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v10, out_stateCnt);
  }
  uint64_t v11 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 6, __dst, 0x44u);
  *((_DWORD *)this + 1651) = v11;
  *((_DWORD *)this + 1650) = -1;
  if (v11)
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::RestoreRegisterState (save_id = %u) error: GPR regs failed to write: %u");
    }
    goto LABEL_22;
  }
  long long v12 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16), 17, (thread_state_t)this + 84, 0x84u);
  *((_DWORD *)this + 1653) = v12;
  *((_DWORD *)this + 1652) = -1;
  if (v12)
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::RestoreRegisterState (save_id = %u) error: %s regs failed to write: %u");
    }
LABEL_22:
    uint64_t v8 = 0;
    long long v13 = (char *)*((void *)v4 + 1);
    if (v13) {
      goto LABEL_23;
    }
LABEL_26:
    long long v15 = v4;
    do
    {
      long long v14 = (char *)*((void *)v15 + 2);
      uint64_t v16 = *(void *)v14 == (void)v15;
      long long v15 = v14;
    }
    while (!v16);
    goto LABEL_29;
  }
  uint64_t v8 = 1;
  long long v13 = (char *)*((void *)v4 + 1);
  if (!v13) {
    goto LABEL_26;
  }
  do
  {
LABEL_23:
    long long v14 = v13;
    long long v13 = *(char **)v13;
  }
  while (v13);
LABEL_29:
  if (*((char **)this + 904) == v4) {
    *((void *)this + 904) = v14;
  }
  --*((void *)this + 906);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 905), (uint64_t *)v4);
  operator delete(v4, (std::align_val_t)0x40uLL);
  return v8;
}

void DNBArchMachARM64::~DNBArchMachARM64(DNBArchMachARM64 *this)
{
  *(void *)this = off_10006DD00;
  std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy((uint64_t)this + 7232, *((void **)this + 905));
  int v2 = (void *)*((void *)this + 900);
  if (v2)
  {
    *((void *)this + 901) = v2;
    operator delete(v2);
  }
  size_t v3 = (void *)*((void *)this + 897);
  if (v3)
  {
    *((void *)this + 898) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = off_10006DD00;
  std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy((uint64_t)this + 7232, *((void **)this + 905));
  int v2 = (void *)*((void *)this + 900);
  if (v2)
  {
    *((void *)this + 901) = v2;
    operator delete(v2);
  }
  size_t v3 = (void *)*((void *)this + 897);
  if (v3)
  {
    *((void *)this + 898) = v3;
    operator delete(v3);
  }

  operator delete(this, (std::align_val_t)0x40uLL);
}

uint64_t DNBArchProtocol::StepNotComplete(DNBArchProtocol *this)
{
  return 0;
}

uint64_t DNBArchProtocol::StartTransForHWP(DNBArchProtocol *this)
{
  return 1;
}

uint64_t DNBArchProtocol::RollbackTransForHWP(DNBArchProtocol *this)
{
  return 1;
}

uint64_t DNBArchProtocol::FinishTransForHWP(DNBArchProtocol *this)
{
  return 1;
}

void std::vector<DNBArchMachARM64::disabled_watchpoint>::__append(void **a1, unint64_t a2)
{
  unsigned int v5 = (char *)a1[1];
  unsigned int v4 = a1[2];
  BOOL v6 = v5;
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      if (((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_36;
      }
      uint64_t v13 = ((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      BOOL v6 = &v5[16 * (v13 & 0x1FFFFFFFFFFFFFFELL)];
      long long v14 = v5 + 16;
      uint64_t v15 = v13 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *((void *)v14 - 2) = 0;
        *(void *)long long v14 = 0;
        *((_DWORD *)v14 - 2) = 0;
        *((_DWORD *)v14 + 2) = 0;
        v14 += 32;
        v15 -= 2;
      }
      while (v15);
      if (v13 != (v13 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_36:
        do
        {
          *(void *)BOOL v6 = 0;
          *((_DWORD *)v6 + 2) = 0;
          v6 += 16;
        }
        while (v6 != &v5[16 * a2]);
      }
      BOOL v6 = &v5[16 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    int v7 = (char *)*a1;
    uint64_t v8 = (v5 - (unsigned char *)*a1) >> 4;
    unint64_t v9 = v8 + a2;
    if ((v8 + a2) >> 60) {
      abort();
    }
    uint64_t v10 = v4 - v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v12 = (char *)operator new(16 * v11);
    }
    else
    {
      long long v12 = 0;
    }
    uint64_t v16 = &v12[16 * v8];
    long long v17 = &v16[16 * a2];
    long long v18 = v16;
    if (((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_37;
    }
    uint64_t v19 = ((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    long long v18 = &v16[16 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    long long v20 = v16 + 16;
    uint64_t v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *((void *)v20 - 2) = 0;
      *(void *)long long v20 = 0;
      *((_DWORD *)v20 - 2) = 0;
      *((_DWORD *)v20 + 2) = 0;
      v20 += 32;
      v21 -= 2;
    }
    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_37:
      do
      {
        *(void *)long long v18 = 0;
        *((_DWORD *)v18 + 2) = 0;
        v18 += 16;
      }
      while (v18 != v17);
    }
    long long v22 = &v12[16 * v11];
    if (v5 != v7)
    {
      do
      {
        uint64_t v23 = *((void *)v6 - 2);
        v6 -= 16;
        int v24 = *((_DWORD *)v6 + 2);
        *((void *)v16 - 2) = v23;
        v16 -= 16;
        *((_DWORD *)v16 + 2) = v24;
      }
      while (v6 != v7);
    }
    uint64_t v25 = *a1;
    *a1 = v16;
    a1[1] = v17;
    a1[2] = v22;
    if (v25)
    {
      operator delete(v25);
    }
  }
}

void std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy(a1, a2[1]);
    operator delete(a2, (std::align_val_t)0x40uLL);
  }
}

uint64_t mach_exc_server_routine(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 2411) >= 0xFFFFFFFA) {
    return (uint64_t)*(&catch_mach_exc_subsystem + 5 * (v1 - 2405) + 5);
  }
  else {
    return 0;
  }
}

uint64_t _Xmach_exception_raise(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0)
  {
    int v3 = -304;
    if (*(_DWORD *)(result + 24) != 2) {
      goto LABEL_3;
    }
    unsigned int v4 = *(_DWORD *)(result + 4);
    if (v4 < 0x44 || v4 > 0x54) {
      goto LABEL_3;
    }
    if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
    {
      int v3 = -300;
      goto LABEL_3;
    }
    unsigned int v5 = *(_DWORD *)(result + 64);
    if (v5 <= 2 && v5 <= (v4 - 68) >> 3 && v4 == 8 * v5 + 68)
    {
      uint64_t result = catch_mach_exception_raise(*(_DWORD *)(result + 12), *(_DWORD *)(result + 28), *(_DWORD *)(result + 40), *(_DWORD *)(result + 60), (uint64_t *)(result + 68), v5);
      *(_DWORD *)(a2 + 32) = result;
      goto LABEL_4;
    }
  }
  int v3 = -304;
LABEL_3:
  *(_DWORD *)(a2 + 32) = v3;
LABEL_4:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *_Xmach_exception_raise_state(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0) {
    goto LABEL_17;
  }
  unsigned int v3 = result[1];
  BOOL v4 = v3 < 0x30 || v3 > 0x1480;
  if (v4
    || (unsigned int v5 = result[9], v5 > 2)
    || ((unsigned int v6 = 2 * v5, v5 <= (v3 - 48) >> 3) ? (v7 = v3 >= 8 * v5 + 48) : (v7 = 0),
        !v7
     || (uint64_t v8 = &result[v6], v9 = v8[11], v9 > 0x510)
     || ((unsigned int v10 = v3 - v6 * 4, v9 <= (v10 - 48) >> 2) ? (v11 = v10 == 4 * v9 + 48) : (v11 = 0), !v11)))
  {
LABEL_17:
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v12 = NDR_record;
LABEL_18:
    *(NDR_record_t *)(a2 + 24) = v12;
    return result;
  }
  *(_DWORD *)(a2 + 40) = 1296;
  uint64_t v13 = v8 + 10;
  uint64_t result = (_DWORD *)catch_mach_exception_raise_state(result[3], result[8], (uint64_t)(result + 10), v5);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v12 = NDR_record;
  if (result) {
    goto LABEL_18;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  *(_DWORD *)(a2 + 36) = *v13;
  *(_DWORD *)(a2 + 4) = 4 * *(_DWORD *)(a2 + 40) + 44;
  return result;
}

uint64_t _Xmach_exception_raise_state_identity(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0) {
    goto LABEL_2;
  }
  int v3 = -304;
  if (*(_DWORD *)(result + 24) != 2) {
    goto LABEL_3;
  }
  unsigned int v5 = *(_DWORD *)(result + 4);
  if (v5 < 0x4C || v5 > 0x149C) {
    goto LABEL_3;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_3;
  }
  unsigned int v7 = *(_DWORD *)(result + 64);
  if (v7 > 2) {
    goto LABEL_2;
  }
  int v3 = -304;
  if (v7 > (v5 - 76) >> 3) {
    goto LABEL_3;
  }
  unsigned int v8 = 8 * v7;
  if (v5 < 8 * v7 + 76) {
    goto LABEL_3;
  }
  uint64_t v9 = result + v8;
  unsigned int v10 = *(_DWORD *)(v9 + 72);
  if (v10 > 0x510 || (unsigned int v11 = v5 - v8, v10 > (v11 - 76) >> 2) || v11 != 4 * v10 + 76)
  {
LABEL_2:
    int v3 = -304;
LABEL_3:
    *(_DWORD *)(a2 + 32) = v3;
    NDR_record_t v4 = NDR_record;
LABEL_4:
    *(NDR_record_t *)(a2 + 24) = v4;
    return result;
  }
  *(_DWORD *)(a2 + 40) = 1296;
  NDR_record_t v12 = (_DWORD *)(v9 + 68);
  uint64_t result = catch_mach_exception_raise_state_identity(*(_DWORD *)(result + 12), *(_DWORD *)(result + 28), *(_DWORD *)(result + 40), *(_DWORD *)(result + 60), (uint64_t *)(result + 68), v7);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v4 = NDR_record;
  if (result) {
    goto LABEL_4;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  *(_DWORD *)(a2 + 36) = *v12;
  *(_DWORD *)(a2 + 4) = 4 * *(_DWORD *)(a2 + 40) + 44;
  return result;
}

uint64_t mach_exc_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 2411) >= 0xFFFFFFFA
    && (unsigned int v5 = (void (*)(void))*(&catch_mach_exc_subsystem + 5 * (v4 - 2405) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

void PortWasBoundCallbackUnixSocket()
{
}

{
  perror("error: connect (socket, &saddr_un, saddr_un_len)");
  exit(1);
}

{
  perror("error: send (s, pid_str, pid_str_len, 0)");
  exit(1);
}

void DNBBreakpointList::RemoveTrapsFromBuffer()
{
  __assert_rtn("RemoveTrapsFromBuffer", "DNBBreakpoint.cpp", 187, "opcode_offset + intersect_size <= bp.ByteSize()");
}

{
  __assert_rtn("RemoveTrapsFromBuffer", "DNBBreakpoint.cpp", 186, "addr < intersect_addr + intersect_size && intersect_addr + intersect_size <= addr + size");
}

{
  __assert_rtn("RemoveTrapsFromBuffer", "DNBBreakpoint.cpp", 184, "addr <= intersect_addr && intersect_addr < addr + size");
}

void DNBProcessLaunch()
{
}

void DNBProcessAttach()
{
}

void DNBProcessAttach(char *a1, int a2, char *a3, int a4)
{
  snprintf(a1, 0x10uLL, "--fd=%d", a2);
  snprintf(a3, 0x10uLL, "--attach=%d", a4);
  execl("/Library/Apple/usr/libexec/oah/debugserver", "/Library/Apple/usr/libexec/oah/debugserver", "--native-regs", "--setsid", a1, "--handoff-attach-from-native", a3, 0);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v7 = *__error();
    unsigned int v8 = __error();
    uint64_t v9 = strerror(*v8);
    _DNBLogThreaded("Failed to launch debugserver for translated process: ", v7, v9);
  }
  __break(1u);
}

void DNBDataRef::GetMax64()
{
}

void DNBDataRef::Dump()
{
  __assert_rtn("GetPointer", "DNBDataRef.cpp", 146, "m_ptrSize != 0");
}

void PThreadMutex::PThreadMutex()
{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 96, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 94, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 92, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 90, "err == 0");
}

void PThreadEvent::PThreadEvent()
{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 83, "err == 0");
}

void RNBRemote::InitializeRegisters()
{
  __assert_rtn("InitializeRegisters", "RNBRemote.cpp", 1343, "num_reg_sets > 0 && reg_sets != NULL");
}

void MachException::Message::Reply()
{
  __assert_rtn("Reply", "MachException.cpp", 325, "state_pid != -1");
}

void MachProcess::EnableBreakpoint()
{
  __assert_rtn("EnableBreakpoint", "MachProcess.mm", 2252, "break_op_size != 0");
}

void MachProcess::DisableBreakpoint()
{
}

uint64_t std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void MachThread::ThreadWillResume()
{
  __assert_rtn("ThreadWillResume", "MachThread.cpp", 351, "others_stopped == false");
}

void MachThreadList::ProcessWillResume()
{
}

void DNBArchMachARM64::GetRegisterContext()
{
  __assert_rtn("GetRegisterContext", "DNBArchImplARM64.cpp", 3068, "bytes_written == size");
}

void DNBArchMachARM64::SetRegisterContext()
{
  __assert_rtn("SetRegisterContext", "DNBArchImplARM64.cpp", 3109, "bytes_written == size");
}

uint64_t BKSOpenApplicationErrorCodeToString()
{
  return _BKSOpenApplicationErrorCodeToString();
}

uint64_t BKSWatchdogAssertionCreateForPID()
{
  return _BKSWatchdogAssertionCreateForPID();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return _CFBundleCopyExecutableURL(bundle);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return _CFBundleGetIdentifier(bundle);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, propertyList);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return _CFStringCreateWithFileSystemRepresentation(alloc, buffer);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return _CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, maxBufLen);
}

uint64_t DVTSecureSocketProxy_Create()
{
  return _DVTSecureSocketProxy_Create();
}

uint64_t FBSOpenApplicationErrorCodeToString()
{
  return _FBSOpenApplicationErrorCodeToString();
}

uint64_t SBSCopyApplicationDisplayIdentifiers()
{
  return _SBSCopyApplicationDisplayIdentifiers();
}

uint64_t SBSCopyExecutablePathForDisplayIdentifier()
{
  return _SBSCopyExecutablePathForDisplayIdentifier();
}

uint64_t SBSCopyFrontmostApplicationDisplayIdentifier()
{
  return _SBSCopyFrontmostApplicationDisplayIdentifier();
}

uint64_t SBSCopyIconImagePathForDisplayIdentifier()
{
  return _SBSCopyIconImagePathForDisplayIdentifier();
}

uint64_t SBSCopyLocalizedApplicationNameForDisplayIdentifier()
{
  return _SBSCopyLocalizedApplicationNameForDisplayIdentifier();
}

uint64_t SBSProcessIDForDisplayIdentifier()
{
  return _SBSProcessIDForDisplayIdentifier();
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

char ***_NSGetEnviron(void)
{
  return __NSGetEnviron();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return std::string::find(this, __c, __pos);
}

std::string::size_type std::string::rfind(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return std::string::rfind(this, __c, __pos);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return std::string::compare(this, __s);
}

uint64_t std::stringbuf::str()
{
  return std::stringbuf::str();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return std::locale::use_facet(this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return std::ios_base::getloc(this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return std::logic_error::logic_error(this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return std::bad_array_new_length::bad_array_new_length(this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
}

size_t std::__next_prime(size_t __n)
{
  return std::__next_prime(__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return std::string::erase(this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return std::string::append(this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::append(this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return std::string::append(this, __n, __c);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return std::string::assign(this, __s);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::assign(this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n)
{
  return std::string::assign(this, __str, __pos, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return std::string::insert(this, __pos, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return std::string::basic_string(this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return std::string::operator=(this, __str);
}

std::string *__cdecl std::string::operator=(std::string *this, std::string::value_type __c)
{
  return std::string::operator=(this, __c);
}

uint64_t std::istream::~istream()
{
  return std::istream::~istream();
}

uint64_t std::istream::operator>>()
{
  return std::istream::operator>>();
}

uint64_t std::ostream::put()
{
  return std::ostream::put();
}

uint64_t std::ostream::flush()
{
  return std::ostream::flush();
}

uint64_t std::ostream::sentry::sentry()
{
  return std::ostream::sentry::sentry();
}

uint64_t std::ostream::sentry::~sentry()
{
  return std::ostream::sentry::~sentry();
}

uint64_t std::ostream::~ostream()
{
  return std::ostream::~ostream();
}

uint64_t std::ostream::operator<<()
{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

uint64_t std::streambuf::basic_streambuf()
{
  return std::streambuf::basic_streambuf();
}

uint64_t std::streambuf::~streambuf()
{
  return std::streambuf::~streambuf();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return std::ios::~ios();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return std::to_string(retstr, __val);
}

uint64_t std::operator+<char>()
{
  return std::operator+<char>();
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return ___cxa_allocate_exception(thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return ___cxa_atexit(lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return ___cxa_guard_acquire((uint64_t *)a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

int *__error(void)
{
  return ___error();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return ___tolower(a1);
}

void _exit(int a1)
{
}

uint64_t _get_cpu_capabilities()
{
  return __get_cpu_capabilities();
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return _accept(a1, a2, a3);
}

asl_object_t asl_new(uint32_t type)
{
  return _asl_new(type);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return _asl_set(obj, key, value);
}

int asl_vlog(asl_object_t obj, asl_object_t msg, int level, const char *format, va_list ap)
{
  return _asl_vlog(obj, msg, level, format, ap);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return _bind(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

int chdir(const char *a1)
{
  return _chdir(a1);
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

int close(int a1)
{
  return _close(a1);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return _compression_encode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, algorithm);
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  return _compression_encode_scratch_buffer_size(algorithm);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return _connect(a1, a2, a3);
}

void dispatch_release(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

int dup2(int a1, int a2)
{
  return _dup2(a1, a2);
}

int execl(const char *__path, const char *__arg0, ...)
{
  return _execl(__path, __arg0);
}

int execv(const char *__path, char *const *__argv)
{
  return _execv(__path, __argv);
}

void exit(int a1)
{
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

pid_t fork(void)
{
  return _fork();
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return _fputc(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return _getaddrinfo(a1, a2, a3, a4);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

gid_t getgid(void)
{
  return _getgid();
}

int getopt_long_only(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return _getopt_long_only(a1, a2, a3, a4, a5);
}

pid_t getpgid(pid_t a1)
{
  return _getpgid(a1);
}

pid_t getpid(void)
{
  return _getpid();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return _getpwuid(a1);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getsockname(a1, a2, a3);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uid_t getuid(void)
{
  return _getuid();
}

int glob(const char *a1, int a2, int (__cdecl *a3)(const char *, int), glob_t *a4)
{
  return _glob(a1, a2, a3, a4);
}

void globfree(glob_t *a1)
{
}

int grantpt(int a1)
{
  return _grantpt(a1);
}

kern_return_t host_page_size(host_t a1, vm_size_t *a2)
{
  return _host_page_size(a1, a2);
}

kern_return_t host_statistics(host_t host_priv, host_flavor_t flavor, host_info_t host_info_out, mach_msg_type_number_t *host_info_outCnt)
{
  return _host_statistics(host_priv, flavor, host_info_out, host_info_outCnt);
}

kern_return_t host_statistics64(host_t host_priv, host_flavor_t flavor, host_info64_t host_info64_out, mach_msg_type_number_t *host_info64_outCnt)
{
  return _host_statistics64(host_priv, flavor, host_info64_out, host_info64_outCnt);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return _inet_ntop(a1, a2, a3, a4);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

int isatty(int a1)
{
  return _isatty(a1);
}

int kevent(int kq, const kevent *changelist, int nchanges, kevent *eventlist, int nevents, const timespec *timeout)
{
  return _kevent(kq, changelist, nchanges, eventlist, nevents, timeout);
}

int kill(pid_t a1, int a2)
{
  return _kill(a1, a2);
}

int kqueue(void)
{
  return _kqueue();
}

int listen(int a1, int a2)
{
  return _listen(a1, a2);
}

uint64_t lockdown_disconnect()
{
  return _lockdown_disconnect();
}

uint64_t lockdown_get_socket()
{
  return _lockdown_get_socket();
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return _mach_error_string(error_value);
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return _mach_msg(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return _mach_port_allocate(task, right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return _mach_port_insert_right(task, name, poly, polyPoly);
}

mach_port_t mach_thread_self(void)
{
  return _mach_thread_self();
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return _mach_vm_allocate(target, address, size, flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return _mach_vm_deallocate(target, address, size);
}

kern_return_t mach_vm_page_range_query(vm_map_read_t target_map, mach_vm_offset_t address, mach_vm_size_t size, mach_vm_address_t dispositions, mach_vm_size_t *dispositions_count)
{
  return _mach_vm_page_range_query(target_map, address, size, dispositions, dispositions_count);
}

kern_return_t mach_vm_protect(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return _mach_vm_protect(target_task, address, size, set_maximum, new_protection);
}

kern_return_t mach_vm_read(vm_map_read_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt)
{
  return _mach_vm_read(target_task, address, size, data, dataCnt);
}

kern_return_t mach_vm_region_recurse(vm_map_read_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, natural_t *nesting_depth, vm_region_recurse_info_t info, mach_msg_type_number_t *infoCnt)
{
  return _mach_vm_region_recurse(target_task, address, size, nesting_depth, info, infoCnt);
}

kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt)
{
  return _mach_vm_write(target_task, address, data, dataCnt);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return _memchr(__s, __c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

uint64_t memorystatus_control()
{
  return _memorystatus_control();
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

{
}

{
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

void perror(const char *a1)
{
}

kern_return_t pid_for_task(mach_port_name_t t, int *x)
{
  return _pid_for_task(t, x);
}

uint64_t pm_energy_impact()
{
  return _pm_energy_impact();
}

uint64_t pm_sample_task_and_pid()
{
  return _pm_sample_task_and_pid();
}

int posix_openpt(int a1)
{
  return _posix_openpt(a1);
}

int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *a1, int a2, const char *a3, int a4, mode_t a5)
{
  return _posix_spawn_file_actions_addopen(a1, a2, a3, a4, a5);
}

int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_destroy(a1);
}

int posix_spawn_file_actions_init(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_init(a1);
}

int posix_spawnattr_destroy(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_destroy(a1);
}

int posix_spawnattr_init(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_init(a1);
}

int posix_spawnattr_setbinpref_np(posix_spawnattr_t *a1, size_t a2, cpu_type_t *a3, size_t *a4)
{
  return _posix_spawnattr_setbinpref_np(a1, a2, a3, a4);
}

int posix_spawnattr_setflags(posix_spawnattr_t *a1, __int16 a2)
{
  return _posix_spawnattr_setflags(a1, a2);
}

int posix_spawnattr_setsigdefault(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigdefault(a1, a2);
}

int posix_spawnattr_setsigmask(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigmask(a1, a2);
}

int posix_spawnp(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return _posix_spawnp(a1, a2, a3, a4, __argv, __envp);
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

uint64_t proc_get_cpumon_params()
{
  return _proc_get_cpumon_params();
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return _proc_pid_rusage(pid, flavor, buffer);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_pidpath(pid, buffer, buffersize);
}

uint64_t proc_set_wakemon_params()
{
  return _proc_set_wakemon_params();
}

int pthread_cancel(pthread_t a1)
{
  return _pthread_cancel(a1);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait(a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_detach(pthread_t a1)
{
  return _pthread_detach(a1);
}

int pthread_getschedparam(pthread_t a1, int *a2, sched_param *a3)
{
  return _pthread_getschedparam(a1, a2, a3);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_settype(a1, a2);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return _pthread_setschedparam(a1, a2, a3);
}

void pthread_testcancel(void)
{
}

int ptrace(int _request, pid_t _pid, caddr_t _addr, int _data)
{
  return _ptrace(_request, _pid, _addr, _data);
}

char *__cdecl ptsname(int a1)
{
  return _ptsname(a1);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return _realpath_DARWIN_EXTSN(a1, a2);
}

uint64_t secure_lockdown_checkin()
{
  return _secure_lockdown_checkin();
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return _select(a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return _send(a1, a2, a3, a4);
}

int setgid(gid_t a1)
{
  return _setgid(a1);
}

int setlinebuf(FILE *a1)
{
  return _setlinebuf(a1);
}

int setpgid(pid_t a1, pid_t a2)
{
  return _setpgid(a1, a2);
}

pid_t setsid(void)
{
  return _setsid();
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  return _sigprocmask(a1, a2, a3);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return _sscanf(a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  return _strcasestr(__big, __little);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return _strcat(__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return _strcspn(__s, __charset);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  return _strerror_r(__errnum, __strerrbuf, __buflen);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return _strstr(__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return _strtoull(__str, __endptr, __base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  return _sysctlnametomib(a1, a2, a3);
}

kern_return_t task_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return _task_for_pid(target_tport, pid, t);
}

kern_return_t task_get_exception_ports(task_t task, exception_mask_t exception_mask, exception_mask_array_t masks, mach_msg_type_number_t *masksCnt, exception_handler_array_t old_handlers, exception_behavior_array_t old_behaviors, exception_flavor_array_t old_flavors)
{
  return _task_get_exception_ports(task, exception_mask, masks, masksCnt, old_handlers, old_behaviors, old_flavors);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return _task_info(target_task, flavor, task_info_out, task_info_outCnt);
}

kern_return_t task_resume(task_read_t target_task)
{
  return _task_resume(target_task);
}

kern_return_t task_set_exception_ports(task_t task, exception_mask_t exception_mask, mach_port_t new_port, exception_behavior_t behavior, thread_state_flavor_t new_flavor)
{
  return _task_set_exception_ports(task, exception_mask, new_port, behavior, new_flavor);
}

kern_return_t task_set_state(task_t task, thread_state_flavor_t flavor, thread_state_t new_state, mach_msg_type_number_t new_stateCnt)
{
  return _task_set_state(task, flavor, new_state, new_stateCnt);
}

kern_return_t task_suspend(task_read_t target_task)
{
  return _task_suspend(target_task);
}

kern_return_t task_threads(task_inspect_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt)
{
  return _task_threads(target_task, act_list, act_listCnt);
}

int tcgetattr(int a1, termios *a2)
{
  return _tcgetattr(a1, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  return _tcsetattr(a1, a2, a3);
}

kern_return_t thread_abort_safely(thread_act_t target_act)
{
  return _thread_abort_safely(target_act);
}

kern_return_t thread_convert_thread_state(thread_act_t thread, int direction, thread_state_flavor_t flavor, thread_state_t in_state, mach_msg_type_number_t in_stateCnt, thread_state_t out_state, mach_msg_type_number_t *out_stateCnt)
{
  return _thread_convert_thread_state(thread, direction, flavor, in_state, in_stateCnt, out_state, out_stateCnt);
}

kern_return_t thread_get_state(thread_read_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt)
{
  return _thread_get_state(target_act, flavor, old_state, old_stateCnt);
}

kern_return_t thread_info(thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return _thread_info(target_act, flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_resume(thread_read_t target_act)
{
  return _thread_resume(target_act);
}

kern_return_t thread_set_state(thread_act_t target_act, thread_state_flavor_t flavor, thread_state_t new_state, mach_msg_type_number_t new_stateCnt)
{
  return _thread_set_state(target_act, flavor, new_state, new_stateCnt);
}

kern_return_t thread_suspend(thread_read_t target_act)
{
  return _thread_suspend(target_act);
}

int unlockpt(int a1)
{
  return _unlockpt(a1);
}

int unsetenv(const char *a1)
{
  return _unsetenv(a1);
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return _vfprintf(a1, a2, a3);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return _vm_deallocate(target_task, address, size);
}

kern_return_t vm_machine_attribute(vm_map_t target_task, vm_address_t address, vm_size_t size, vm_machine_attribute_t attribute, vm_machine_attribute_val_t *value)
{
  return _vm_machine_attribute(target_task, address, size, attribute, value);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return _waitpid(a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend_cacheGUID(void *a1, const char *a2, ...)
{
  return [a1 cacheGUID];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_createClientPort(void *a1, const char *a2, ...)
{
  return [a1 createClientPort];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_drain(void *a1, const char *a2, ...)
{
  return [a1 drain];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_operatingSystemVersion(void *a1, const char *a2, ...)
{
  return [a1 operatingSystemVersion];
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return [a1 processInfo];
}

id objc_msgSend_sequenceNumber(void *a1, const char *a2, ...)
{
  return [a1 sequenceNumber];
}

id objc_msgSend_systemApplicationBundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 systemApplicationBundleIdentifier];
}