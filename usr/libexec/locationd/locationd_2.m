void sub_100148AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10017FF2C(&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_100148B48(id *a1, void *a2)
{
  id v4 = a2;

  a1[2] = a2;
  v5 = (uint64_t (*)(id *))*((void *)*a1 + 3);

  return v5(a1);
}

id sub_100148BB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_100103E24(a1, a2);
  sub_1001382B4((void *)a1, (uint64_t)v5, a3, v9);
  sub_1000FF060(a1, (uint64_t)v5, v9);
  uint64_t v6 = v9[30];
  v7.n128_f64[0] = CFAbsoluteTimeGetCurrent();
  id result = (id)sub_1001005FC(a1, v5, 5, v6, 0, 0, v7);
  if (result) {
    return [*(id *)(a1 + 136) persist];
  }
  return result;
}

uint64_t sub_100148C40(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 v9 = 0;
  sub_100137F00(a1, a2, a3, &v9);
  id v5 = sub_100138248(a2, 0);
  uint64_t v6 = v9;
  v7.n128_f64[0] = CFAbsoluteTimeGetCurrent();

  return sub_1001005FC(a1, v5, 2, v6, 0, 0, v7);
}

void sub_100148CC0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = sub_100103E24(a1, a2);
  if ([a4 isAuthorizedForServiceTypeMask:a3])
  {
    if (![a4 registrationResult])
    {
      id v8 = [[objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v7) dictionary];
      int v9 = sub_1001083CC(v8);
      LODWORD(v8) = sub_1001C2654(v8);
      if ((a3 & ~sub_1001081BC(1, (int)[a4 inUseLevel], v9, (int)v8, 0, 0, 0)) != 0)
      {
        sub_1007B03B4(a1, (uint64_t)v7);
      }
    }
  }
}

void sub_100148DA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  LODWORD(v7) = [*(id *)(a1 + 112) transientAwareRegistrationResult];
  uint64_t v3 = sub_1001191C8(v2, (int *)&v7);
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v4 = v3;
    unsigned int v5 = [*(id *)(a1 + 112) isAuthorizedForServiceType:12] ^ 1;
    if (v4) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    v8[0] = @"kCLConnectionMessageStatusKey";
    v9[0] = +[NSNumber numberWithUnsignedInt:v4];
    v8[1] = @"kCLConnectionMessageCompensationKey";
    v9[1] = +[NSNumber numberWithBool:v6];
    v8[2] = @"kCLConnectionMessageAuthorizedForWidgetUpdatesKey";
    v9[2] = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(a1 + 112) authorizedForWidgetUpdates]);
    id v7 = +[NSDictionary dictionaryWithObjects:v9 forKeys:v8 count:3];
    sub_100149034(a1);
  }
}

id sub_100148ED8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = a1 + 1112;
  sub_100134750(__p, (char *)[[objc_msgSend(objc_msgSend(a2, "clientAnchor"), "UTF8String") UTF8String]);
  uint64_t v6 = (_DWORD *)sub_10012FFE0(v5, (const void **)__p);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if ((_DWORD *)(a1 + 1120) == v6)
  {
    BOOL v10 = 0;
    BOOL v11 = 0;
    BOOL v9 = 0;
    BOOL v8 = 0;
  }
  else
  {
    int v7 = v6[17];
    BOOL v8 = v6[14] != 0;
    BOOL v9 = v6[15] != 0;
    BOOL v10 = v6[16] != 0;
    BOOL v11 = v7 != 0;
  }
  [a3 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v8) forKeyedSubscript:@"PassiveServiceSession"];
  [a3 setObject:[NSNumber numberWithBool:v9] forKeyedSubscript:@"WhenInUseServiceSession"];
  [a3 setObject:[NSNumber numberWithBool:v10] forKeyedSubscript:@"AlwaysServiceSession"];
  return [a3 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v11) forKeyedSubscript:@"SessionWithOldLinking"];
}

void sub_100149018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100149034(uint64_t a1)
{
  sub_1000E9420(&off_1022ED860, &v2);
  uint64_t v4 = v2;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_1000EFC20(a1, (uint64_t)&v4);
  if (v5) {
    sub_1000DB0A0(v5);
  }
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_1001490B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_1000DB0A0(a13);
  }
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001490E0(id *a1, uint64_t a2, uint64_t a3)
{
  id v6 = objc_alloc_init((Class)NSAutoreleasePool);
  id v7 = sub_100103E24((uint64_t)a1, a2);
  id v8 = [v7 legacyClientKey];
  unsigned int v9 = sub_100122554((uint64_t)a1, (uint64_t)v7);
  id v10 = a1[135];
  if (v9)
  {
    if ([v10 objectForKeyedSubscript:v8])
    {
      [a1[135] removeObjectForKey:v8];
      [a1[134] setClientsAuthorizationMap:[a1[135] copy]];
    }
    sub_1007A00B8((uint64_t)a1, v7, (NSMutableDictionary *)[objc_msgSend(objc_msgSend(a1[17], "readonlyStoreAtKeyPath:", v7), "dictionary"));
    uint64_t v11 = 1;
  }
  else
  {
    unsigned int v12 = [v10[v8] isEqual:a3];
    if ((v12 & 1) == 0)
    {
      id v13 = a1[17];
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_100124A88;
      v15[3] = &unk_1022C90F8;
      v15[4] = v7;
      v15[5] = a3;
      v15[6] = v8;
      v15[7] = a1;
      [v13 iterateIdentitiesRelatedToKeyPath:v7 withBlock:v15];
      [a1[134] setClientsAuthorizationMap:[a1[135] copy]];
    }
    uint64_t v11 = v12 ^ 1;
  }

  return v11;
}

void sub_10014925C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10014933C(float *a1, double a2, double a3)
{
  *a1 = 0.0;
  if (a2 < -90.0 || a2 > 90.0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1022D6DA0);
    }
    v15 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      double v29 = a2;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#Warning Input latitude = %.9lf is out of possible range", buf, 0xCu);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022D6DA0);
      }
      v20 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLGeoidModel::getUndulationFromDefenseMappingAgency10by10Geoid(double, double, float &)", "%s\n");
      goto LABEL_53;
    }
  }
  else
  {
    double v5 = a3;
    if (a3 < -180.0)
    {
      unsigned int v6 = 0;
      do
        double v5 = v5 + 360.0;
      while (v5 < -180.0 && v6++ < 3);
    }
    if (v5 >= 180.0)
    {
      unsigned int v8 = 0;
      do
        double v5 = v5 + -360.0;
      while (v5 >= 180.0 && v8++ < 3);
    }
    float v10 = (v5 + 180.0) / 10.0;
    int v11 = vcvtms_s32_f32(v10);
    if (v11 < 0x24)
    {
      float v16 = (90.0 - a2) / 10.0;
      int v17 = vcvtms_s32_f32(v16);
      if (v17 < 0x13)
      {
        if (v11 == 35) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = (v11 + 1);
        }
        int v22 = v17 + 1;
        if (v17 == 18)
        {
          *a1 = -30.0;
        }
        else
        {
          uint64_t v23 = (36 * v17);
          BOOL result = sub_100149908(v23 + v11);
          if (!result) {
            return result;
          }
          char v24 = byte_101D55728[v23 + v11];
          uint64_t v25 = (36 * v22);
          BOOL result = sub_100149908(v25 + v11);
          if (!result) {
            return result;
          }
          char v27 = byte_101D55728[v25 + v11];
          BOOL result = sub_100149908(v21 + v23);
          if (!result) {
            return result;
          }
          char v26 = byte_101D55728[v21 + v23];
          BOOL result = sub_100149908(v21 + v25);
          if (!result) {
            return result;
          }
          *a1 = (float)((float)((float)((float)((float)((float)v22 - v16)
                                              * (float)((float)(v10 - (float)v11) * (float)v26))
                                      + (float)((float)((float)((float)(int)v21 - v10) * (float)v24)
                                              * (float)((float)v22 - v16)))
                              + (float)((float)((float)((float)(int)v21 - v10) * (float)v27) * (float)(v16 - (float)v17)))
                      + (float)((float)((float)(v10 - (float)v11) * (float)byte_101D55728[v21 + v25])
                              * (float)(v16 - (float)v17)))
              / (float)((float)((float)v22 - (float)v17) * (float)((float)(int)v21 - (float)v11));
        }
        return 1;
      }
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022D6DA0);
      }
      v18 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134217984;
        double v29 = a2;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "latitude %.9lf is not valid.", buf, 0xCu);
      }
      BOOL v19 = sub_10013D1A0(115, 0);
      BOOL result = 0;
      if (v19)
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419630 == -1)
        {
LABEL_38:
          v20 = (uint8_t *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLGeoidModel::getUndulationFromDefenseMappingAgency10by10Geoid(double, double, float &)", "%s\n");
LABEL_53:
          if (v20 != buf) {
            free(v20);
          }
          return 0;
        }
LABEL_56:
        dispatch_once(&qword_102419630, &stru_1022D6DA0);
        goto LABEL_38;
      }
    }
    else
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022D6DA0);
      }
      unsigned int v12 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134217984;
        double v29 = v5;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "longitude %.9lf is not valid.", buf, 0xCu);
      }
      BOOL v13 = sub_10013D1A0(115, 0);
      BOOL result = 0;
      if (v13)
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419630 == -1) {
          goto LABEL_38;
        }
        goto LABEL_56;
      }
    }
  }
  return result;
}

BOOL sub_100149908(unsigned int a1)
{
  if (a1 >= 0x2AC)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1022D6DA0);
    }
    uint64_t v2 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Bad index into kkDefenseMappingAgencyTenByTenGeoid.", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022D6DA0);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLGeoidModel::_static_check_dma_index(int)", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  return a1 < 0x2AC;
}

void sub_100149AAC(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4)
{
  if (*(unsigned char *)(a1 + 108)) {
    return;
  }
  unsigned int v8 = _os_activity_create((void *)&_mh_execute_header, "CL: notifyClientsWithData (Fallback)", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  os_activity_scope_enter(v8, &state);

  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102315130);
  }
  unsigned int v9 = qword_102419588;
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    float v10 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      float v10 = (void *)*v10;
    }
    int v11 = (std::__shared_weak_count *)*a2;
    *(_DWORD *)buf = 68289794;
    int v26 = 0;
    __int16 v27 = 2082;
    *(void *)v28 = "";
    *(_WORD *)&v28[8] = 2082;
    *(void *)&v28[10] = "activity";
    __int16 v29 = 2082;
    v30 = v10;
    __int16 v31 = 2050;
    v32 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"notifyClientsWithData\", \"event\":%{public, location:escape_only}s, \"name\":%{public, location:escape_only}s, \"notification\":%{public}lld}", buf, 0x30u);
  }
  uint64_t v12 = *(void *)(a1 + 64);
  if (!v12) {
    goto LABEL_18;
  }
  int v13 = *a2;
  char v14 = (uint64_t **)(a1 + 64);
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < v13;
    if (v15 >= v13) {
      int v17 = (uint64_t *)v12;
    }
    else {
      int v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      char v14 = (uint64_t **)v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 == (uint64_t **)(a1 + 64) || v13 < *((_DWORD *)v14 + 8))
  {
LABEL_18:
    v33 = v34;
    memset(v34, 0, sizeof(v34));
    v35 = 0;
    sub_101178DEC((uint64_t)buf, a2, (uint64_t)&v33);
    char v14 = sub_100448098((uint64_t **)(a1 + 56), (__n128 *)buf);
    if (v32) {
      sub_1000DB0A0(v32);
    }
    sub_1000F5BB0((uint64_t)&v27, *(void **)&v28[6]);
    if (v35) {
      sub_1000DB0A0(v35);
    }
    sub_1000F5BB0((uint64_t)&v33, v34[0]);
  }
  if (a4)
  {
    v18 = (char *)operator new(0xB8uLL);
    long long v19 = a3[1];
    *(_OWORD *)(v18 + 24) = *a3;
    *(_OWORD *)(v18 + 40) = v19;
    long long v20 = a3[4];
    *(_OWORD *)(v18 + 104) = a3[5];
    *(_OWORD *)(v18 + 88) = v20;
    long long v21 = a3[2];
    *(_OWORD *)(v18 + 72) = a3[3];
    *(_OWORD *)(v18 + 56) = v21;
    *(_OWORD *)(v18 + 164) = *(_OWORD *)((char *)a3 + 140);
    *(_OWORD *)(v18 + 152) = a3[8];
    long long v22 = a3[6];
    *(_OWORD *)(v18 + 136) = a3[7];
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = 0;
    *(void *)v18 = off_1023152A8;
    *(_OWORD *)(v18 + 120) = v22;
    uint64_t v23 = (std::__shared_weak_count *)v14[9];
    v14[8] = (uint64_t *)(v18 + 24);
    v14[9] = (uint64_t *)v18;
    if (!v23) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  uint64_t v23 = (std::__shared_weak_count *)v14[9];
  v14[8] = 0;
  v14[9] = 0;
  if (v23) {
LABEL_27:
  }
    sub_1000DB0A0(v23);
LABEL_28:
  if (v14[7]) {
    sub_10014AD24();
  }
  os_activity_scope_leave(&state);
}

void sub_10014A0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_10014A118(void *a1, int *a2, void *a3)
{
  if (!*((unsigned char *)a1 + 108))
  {
    double v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      unsigned int v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          unsigned int v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        v49 = v9;
        id v13 = sub_10014A72C(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184))(a1, a2, v13, v9 + 10);
        char v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          BOOL v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 8);
            long long v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                long long v22 = (uint64_t *)v17;
              }
              else {
                long long v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                long long v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              v48 = v19;
              sub_10014A508(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              __int16 v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  v32 = (uint64_t *)v27;
                }
                else {
                  v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  __int16 v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              v49 = v29;
              uint64_t v34 = v29[6];
              char v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 32);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    v39 = (uint64_t *)v36;
                  }
                  else {
                    v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 8))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 32);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      char v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      char v14 = v43;
                      v43 = (void *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      char v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              v48 = a1 + 11;
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_102315130);
              }
              char v24 = qword_102419588;
              if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  uint64_t v25 = (void *)*v16;
                }
                int v26 = *((_DWORD *)v14 + 8);
                *(_DWORD *)buf = 136446466;
                v55 = v25;
                __int16 v56 = 1026;
                int v57 = v26;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_10013D1A0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419580 != -1) {
                  dispatch_once(&qword_102419580, &stru_102315130);
                }
                v45 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  v45 = (void *)*v16;
                }
                int v46 = *((_DWORD *)v14 + 8);
                int v50 = 136446466;
                v51 = v45;
                __int16 v52 = 1026;
                int v53 = v46;
                v47 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 0, "void CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]", "%s\n", v47);
                if (v47 != (char *)buf) {
                  free(v47);
                }
              }
            }
          }
          while (v14 != v49 + 6);
        }
      }
    }
  }
}

unsigned char *sub_10014A508(unsigned char *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    id v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32);
    id v9 = sub_10014A72C(a4);
    uint64_t v10 = *(void *)a3 + 80;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40);
    char v14 = (int *)(*(void *)a2 + 32);
    uint64_t v12 = sub_10014A600(v11, v14, (uint64_t)&unk_101D0B290, &v14);
    BOOL result = (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192))(v7, v8, &v13, v9, v10, v12 + 5);
    if (result) {
      return [*(id *)(*(void *)a2 + 64) onNotification:*(unsigned int *)(*(void *)a3 + 32) withData:a4, v13];
    }
  }
  return result;
}

uint64_t **sub_10014A600(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  id v7 = a1 + 1;
  unsigned int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        id v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unsigned int v6 = *v9;
        id v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unsigned int v6 = v9[1];
      if (!v6)
      {
        id v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    id v9 = a1 + 1;
LABEL_10:
    BOOL v11 = (char *)operator new(0x58uLL);
    *((_DWORD *)v11 + 8) = **a4;
    *(_OWORD *)(v11 + 72) = 0u;
    *(_OWORD *)(v11 + 56) = 0u;
    int64x2_t v12 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(int64x2_t *)(v11 + 40) = v12;
    *((int64x2_t *)v11 + 4) = v12;
    sub_1000EDF90(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

id sub_10014A6DC(uint64_t a1, int a2, void *a3)
{
  id result = sub_10014A72C(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0, &v6, result, *(void *)(a1 + 32));
  }
  return result;
}

id sub_10014A72C(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return sub_10014A78C(a1);
}

id sub_10014A78C(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (v2)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102315278);
      }
      uint64_t v3 = qword_102418F98;
      if (os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218498;
        id v8 = v2;
        __int16 v9 = 2048;
        uint64_t v10 = 0;
        __int16 v11 = 2080;
        unint64_t v12 = 0x8000000101DAAE3CLL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102418F90 == -1)
      {
LABEL_20:
        int v6 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLLocationAwarenessProvider_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]", "%s\n", v6);
        if (v6 != (char *)buf) {
          free(v6);
        }
        return 0;
      }
    }
    else
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102315278);
      }
      double v5 = qword_102418F98;
      if (os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134218498;
        id v8 = v2;
        __int16 v9 = 2048;
        uint64_t v10 = 0;
        __int16 v11 = 2080;
        unint64_t v12 = 0x8000000101DAAE3CLL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102418F90 == -1) {
        goto LABEL_20;
      }
    }
    dispatch_once(&qword_102418F90, &stru_102315278);
    goto LABEL_20;
  }

  return [a1 cppObjectPtr];
}

void sub_10014AB4C(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_1022F1FF8);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    id v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLSignificantChangeManager::onAwarenessNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_1022F1FF8);
    }
    __int16 v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLSignificantChangeManager::onAwarenessNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_100161300(a4, v6, v7, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10014AD00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10014AD24()
{
}

uint64_t sub_10014B230@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v25 = a1 + 56;
  (*(void (**)(void))(v10 + 16))();
  __int16 v27 = 256;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  sub_10017C4A4(a4, a2[2]);
  sub_10019DAB0(*(uint64_t **)(a1 + 96), (uint64_t)v24);
  int v13 = (void *)*a2;
  char v11 = a2 + 1;
  unint64_t v12 = v13;
  if (v13 != v11)
  {
    while (1)
    {
      if (*((_DWORD *)v12 + 8))
      {
        sub_101AB5F7C();
        abort_report_np();
        __break(1u);
      }
      uint64_t v23 = *(void *)((char *)v12 + 36);
      uint64_t v14 = sub_10014C3D0(*(uint64_t **)(a1 + 96));
      if (!v15) {
        break;
      }
      if ((uint64_t)vabdd_f64(a5, *(double *)&v14) < a3) {
        goto LABEL_11;
      }
      char v16 = sub_10121EB74(*(uint64_t **)(a1 + 96), (int)&v23);
LABEL_12:
      *(_OWORD *)buf = *((_OWORD *)v12 + 2);
      uint64_t v33 = v12[6];
      if (*((char *)v12 + 79) < 0)
      {
        sub_1000DC48C(&__p, (void *)v12[7], v12[8]);
      }
      else
      {
        long long __p = *(_OWORD *)(v12 + 7);
        uint64_t v35 = v12[9];
      }
      char v36 = v16;
      sub_10014BB58(a4, (long long *)buf);
      if (SHIBYTE(v35) < 0) {
        operator delete((void *)__p);
      }
      __int16 v18 = (void *)v12[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          __int16 v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v12[2];
          BOOL v20 = *v19 == (void)v12;
          unint64_t v12 = v19;
        }
        while (!v20);
      }
      unint64_t v12 = v19;
      if (v19 == v11) {
        goto LABEL_28;
      }
    }
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1023273E8);
    }
    uint64_t v17 = qword_1024193B8;
    if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67174913;
      *(_DWORD *)&uint8_t buf[4] = v23;
      *(_WORD *)&buf[8] = 1025;
      *(_DWORD *)&buf[10] = HIDWORD(v23);
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "attempted to update timestamp for tile that does not exist, x, %{private}d, y, %{private}d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1023273E8);
      }
      int v28 = 67174913;
      int v29 = v23;
      __int16 v30 = 1025;
      int v31 = HIDWORD(v23);
      BOOL v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::vector<std::pair<TileId, BOOL>> CLWifiAccessPointLocationService::updateAccessTimestampsIfNecessary(const std::set<TileId> &, cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::seconds) const", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
LABEL_11:
    char v16 = 0;
    goto LABEL_12;
  }
LABEL_28:
  uint64_t result = sub_1001A8894(v24);
  if (HIBYTE(v27))
  {
    if ((_BYTE)v27) {
      return pthread_mutex_unlock(v26);
    }
    else {
      return (*(uint64_t (**)(uint64_t))(*(void *)v25 + 24))(v25);
    }
  }
  return result;
}

void sub_10014B5FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t buf,__int16 a28,__int16 a29,uint64_t a30,__int16 __p_4)
{
  sub_1001A8894(&a17);
  if (a2 == 3)
  {
    uint64_t v33 = __cxa_begin_catch(a1);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1023273E8);
    }
    uint64_t v34 = qword_1024193B8;
    if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = (*(uint64_t (**)(void *))(*(void *)v33 + 16))(v33);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"sqlite error updating access timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1023273E8);
      }
    }
    char v36 = qword_1024193B8;
    if (os_signpost_enabled((os_log_t)qword_1024193B8))
    {
      uint64_t v37 = (*(uint64_t (**)(void *))(*(void *)v33 + 16))(v33);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v37;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v36, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "sqlite error updating access timestamps", "{\"msg%{public}.0s\":\"sqlite error updating access timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
    }
  }
  else if (a2 == 2)
  {
    BOOL v38 = __cxa_begin_catch(a1);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1023273E8);
    }
    v39 = qword_1024193B8;
    if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v40 = (*(uint64_t (**)(void *))(*(void *)v38 + 16))(v38);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v40;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"no database connection while updating timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1023273E8);
      }
    }
    BOOL v41 = qword_1024193B8;
    if (os_signpost_enabled((os_log_t)qword_1024193B8))
    {
      uint64_t v42 = (*(uint64_t (**)(void *))(*(void *)v38 + 16))(v38);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v42;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "no database connection while updating timestamps", "{\"msg%{public}.0s\":\"no database connection while updating timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
    }
  }
  else
  {
    if (a2 != 1)
    {
      sub_10017C62C((void ***)&buf);
      sub_1019DB560((uint64_t)&a22);
      _Unwind_Resume(a1);
    }
    v43 = __cxa_begin_catch(a1);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1023273E8);
    }
    BOOL v44 = qword_1024193B8;
    if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v45 = (*(uint64_t (**)(void *))(*(void *)v43 + 16))(v43);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"runtime error while updating access timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1023273E8);
      }
    }
    int v46 = qword_1024193B8;
    if (os_signpost_enabled((os_log_t)qword_1024193B8))
    {
      uint64_t v47 = (*(uint64_t (**)(void *))(*(void *)v43 + 16))(v43);
      buf = 68289283;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v47;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v46, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "runtime error while updating access timestamps", "{\"msg%{public}.0s\":\"runtime error while updating access timestamps\", \"error\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x10014B544);
}

uint64_t sub_10014BB58(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) > 0x492492492492492) {
      sub_1001D7FD4();
    }
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x249249249249249) {
      unint64_t v14 = 0x492492492492492;
    }
    else {
      unint64_t v14 = v12;
    }
    v21[4] = v4;
    char v15 = (char *)sub_10017EA6C(v4, v14);
    char v16 = &v15[56 * v11];
    v21[0] = v15;
    v21[1] = v16;
    v21[3] = &v15[56 * v17];
    uint64_t v18 = *((void *)a2 + 2);
    *(_OWORD *)char v16 = *a2;
    *((void *)v16 + 2) = v18;
    uint64_t v19 = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = v19;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    v16[48] = *((unsigned char *)a2 + 48);
    v21[2] = v16 + 56;
    sub_10017C5B4(a1, v21);
    uint64_t v10 = a1[1];
    sub_10017F1CC((uint64_t)v21);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    *(unsigned char *)(v7 + 48) = *((unsigned char *)a2 + 48);
    uint64_t v10 = v7 + 56;
    a1[1] = v7 + 56;
  }
  a1[1] = v10;
  return v10 - 56;
}

void sub_10014BCC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10017F1CC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10014BCD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2 && sub_10014C3C0(v2))
  {
    *((unsigned char *)&v26.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&v26, "SELECT ");
    uint64_t v3 = std::string::append(&v26, "AccessTimestamp");
    long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    unint64_t v5 = std::string::append(&v27, " FROM ");
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    int v7 = *(char *)(a1 + 23);
    if (v7 >= 0) {
      long long v8 = (const std::string::value_type *)a1;
    }
    else {
      long long v8 = *(const std::string::value_type **)a1;
    }
    if (v7 >= 0) {
      std::string::size_type v9 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      std::string::size_type v9 = *(void *)(a1 + 8);
    }
    uint64_t v10 = std::string::append(&v28, v8, v9);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    unint64_t v12 = std::string::append(&v29, " WHERE ");
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v30, "TileX");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    char v16 = std::string::append(&v31, " = ? AND ");
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v32, "TileY");
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    BOOL v20 = std::string::append(&v35, " = ?");
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    int64_t v34 = v20->__r_.__value_.__r.__words[2];
    long long __p = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (v34 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = (long long *)__p;
    }
    sub_10014D518(*(void *)(a1 + 104), (uint64_t)p_p);
  }
  if (qword_1024193B0 != -1) {
    dispatch_once(&qword_1024193B0, &stru_1022C8300);
  }
  uint64_t v23 = qword_1024193B8;
  if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_INFO))
  {
    LOWORD(v35.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "not connected to wifi #tile header table", (uint8_t *)&v35, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v35, 0x65CuLL);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1022C8300);
    }
    LOWORD(__p) = 0;
    uint64_t v25 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<cl::chrono::CFAbsoluteTimeClock::time_point> CLWifiTileHeaderDatabase::selectAccessTimestampByTileXY(const WifiTileXY &)", "%s\n", (const char *)v25);
    if (v25 != &v35) {
      free(v25);
    }
  }
  return 0;
}

void sub_10014C2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  if (a44 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10014C3C0(uint64_t a1)
{
  return *(void *)(a1 + 8) != 0;
}

uint64_t sub_10014C3D0(uint64_t *a1)
{
  return sub_10014BCD4(*a1);
}

uint64_t sub_10014C3D8(uint64_t a1)
{
  uint64_t v2 = a1 + 64;
  if (sub_10014C3C0(a1 + 64))
  {
    sub_10010F274((uint64_t)&v31);
    uint64_t v3 = sub_100132EFC(&v32, (uint64_t)"SELECT ", 7);
    long long v4 = sub_100132EFC(v3, (uint64_t)"Timestamp", 9);
    unint64_t v5 = sub_100132EFC(v4, (uint64_t)", ", 2);
    long long v6 = sub_100132EFC(v5, (uint64_t)"Latitude", 8);
    int v7 = sub_100132EFC(v6, (uint64_t)", ", 2);
    long long v8 = sub_100132EFC(v7, (uint64_t)"Longitude", 9);
    std::string::size_type v9 = sub_100132EFC(v8, (uint64_t)", ", 2);
    uint64_t v10 = sub_100132EFC(v9, (uint64_t)"HorizontalAccuracy", 18);
    long long v11 = sub_100132EFC(v10, (uint64_t)", ", 2);
    unint64_t v12 = sub_100132EFC(v11, (uint64_t)"Altitude", 8);
    long long v13 = sub_100132EFC(v12, (uint64_t)", ", 2);
    unint64_t v14 = sub_100132EFC(v13, (uint64_t)"VerticalAccuracy", 16);
    long long v15 = sub_100132EFC(v14, (uint64_t)", ", 2);
    char v16 = sub_100132EFC(v15, (uint64_t)"Speed", 5);
    long long v17 = sub_100132EFC(v16, (uint64_t)", ", 2);
    uint64_t v18 = sub_100132EFC(v17, (uint64_t)"Course", 6);
    long long v19 = sub_100132EFC(v18, (uint64_t)", ", 2);
    BOOL v20 = sub_100132EFC(v19, (uint64_t)"Confidence", 10);
    long long v21 = sub_100132EFC(v20, (uint64_t)" FROM ", 6);
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16))(__p, a1);
    if ((v34 & 0x80u) == 0) {
      long long v22 = __p;
    }
    else {
      long long v22 = (void **)__p[0];
    }
    if ((v34 & 0x80u) == 0) {
      uint64_t v23 = v34;
    }
    else {
      uint64_t v23 = (uint64_t)__p[1];
    }
    char v24 = sub_100132EFC(v21, (uint64_t)v22, v23);
    uint64_t v25 = sub_100132EFC(v24, (uint64_t)" WHERE ", 7);
    std::string v26 = sub_100132EFC(v25, (uint64_t)"ROWID", 5);
    sub_100132EFC(v26, (uint64_t)"=?", 2);
    if ((char)v34 < 0) {
      operator delete(__p[0]);
    }
    std::stringbuf::str();
    if ((v34 & 0x80u) == 0) {
      std::string v27 = __p;
    }
    else {
      std::string v27 = (void **)__p[0];
    }
    sub_10014D518(v2, (uint64_t)v27);
  }
  if (qword_1024195E0 != -1) {
    dispatch_once(&qword_1024195E0, &stru_1022BF8F8);
  }
  std::string v28 = off_1024195E8;
  if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "#Warning Attempt to call getLocation() without a backing database in CLLocationDatabase!", (uint8_t *)__p, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1024195E0 != -1) {
      dispatch_once(&qword_1024195E0, &stru_1022BF8F8);
    }
    LOWORD(v31) = 0;
    std::string v30 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationDatabase::getLocation(const sqlite3_int64 &, CLDaemonLocation &) const", "%s\n", v30);
    if (v30 != (char *)__p) {
      free(v30);
    }
  }
  return 0;
}

void sub_10014CB34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  sub_101A129A8((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_10014CBAC(uint64_t a1)
{
  sub_10010F274((uint64_t)&v18);
  uint64_t v2 = sub_100132EFC(&v19, (uint64_t)"SELECT ", 7);
  size_t v3 = strlen("ROWID");
  long long v4 = sub_100132EFC(v2, (uint64_t)"ROWID", v3);
  unint64_t v5 = sub_100132EFC(v4, (uint64_t)" FROM ", 6);
  long long v6 = (const char *)(a1 + 232);
  if (*(char *)(a1 + 255) < 0) {
    long long v6 = *(const char **)v6;
  }
  size_t v7 = strlen(v6);
  long long v8 = sub_100132EFC(v5, (uint64_t)v6, v7);
  std::string::size_type v9 = sub_100132EFC(v8, (uint64_t)" WHERE ", 7);
  uint64_t v10 = sub_100132EFC(v9, (uint64_t)"MCC", 3);
  long long v11 = sub_100132EFC(v10, (uint64_t)"=? AND ", 7);
  unint64_t v12 = sub_100132EFC(v11, (uint64_t)"MNC", 3);
  long long v13 = sub_100132EFC(v12, (uint64_t)"=? AND ", 7);
  unint64_t v14 = sub_100132EFC(v13, (uint64_t)"TAC", 3);
  long long v15 = sub_100132EFC(v14, (uint64_t)"=? AND ", 7);
  char v16 = sub_100132EFC(v15, (uint64_t)"CI", 2);
  sub_100132EFC(v16, (uint64_t)"=?", 2);
  std::stringbuf::str();
  if (v21 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  sub_10014D518(a1 + 64, (uint64_t)p_p);
}

void sub_10014D124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
  }
  sub_101A129A8((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10014D19C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

BOOL sub_10014D1A4(sqlite3_stmt *a1, int a2, int a3)
{
  int v6 = sqlite3_bind_int(a1, a2, a3);
  int v11 = v6;
  if (v6)
  {
    if (qword_1024195E0 != -1) {
      dispatch_once(&qword_1024195E0, &stru_1022BE480);
    }
    size_t v7 = off_1024195E8;
    if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68290307;
      int v13 = 0;
      __int16 v14 = 2082;
      long long v15 = "";
      __int16 v16 = 1025;
      int v17 = a3;
      __int16 v18 = 1026;
      int v19 = a2;
      __int16 v20 = 1040;
      int v21 = 4;
      __int16 v22 = 2098;
      uint64_t v23 = &v11;
      __int16 v24 = 2081;
      uint64_t v25 = sqlite3_sql(a1);
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Could not bind\", \"value\":%{private}d, \"index\":%{public}d, \"rc\":%{public, location:SqliteResult}.*P, \"query\":%{private, location:escape_only}s}", buf, 0x38u);
      if (qword_1024195E0 != -1) {
        dispatch_once(&qword_1024195E0, &stru_1022BE480);
      }
    }
    long long v8 = off_1024195E8;
    if (os_signpost_enabled((os_log_t)off_1024195E8))
    {
      std::string::size_type v9 = sqlite3_sql(a1);
      *(_DWORD *)buf = 68290307;
      int v13 = 0;
      __int16 v14 = 2082;
      long long v15 = "";
      __int16 v16 = 1025;
      int v17 = a3;
      __int16 v18 = 1026;
      int v19 = a2;
      __int16 v20 = 1040;
      int v21 = 4;
      __int16 v22 = 2098;
      uint64_t v23 = &v11;
      __int16 v24 = 2081;
      uint64_t v25 = v9;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Could not bind", "{\"msg%{public}.0s\":\"Could not bind\", \"value\":%{private}d, \"index\":%{public}d, \"rc\":%{public, location:SqliteResult}.*P, \"query\":%{private, location:escape_only}s}", buf, 0x38u);
    }
  }
  return v6 == 0;
}

void sub_10014D3DC(uint64_t a1)
{
  sub_10014D48C(a1);

  operator delete();
}

void *sub_10014D414(void *a1)
{
  *a1 = off_102303570;
  sub_10014D460(a1[1]);
  return a1;
}

uint64_t sub_10014D460(uint64_t a1)
{
  return sub_10014D468(*(void *)(a1 + 16));
}

uint64_t sub_10014D468(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

void *sub_10014D48C(uint64_t a1)
{
  *(void *)a1 = off_102303590;
  int v2 = sqlite3_finalize(*(sqlite3_stmt **)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    sub_1005F93F0(*(void *)(a1 + 8), (uint64_t)"sqlite3_finalize()", v2, 0);
    sub_1005F7AF4(*(void *)(a1 + 8), v2);
  }

  return sub_10014D414((void *)a1);
}

void sub_10014D518(uint64_t a1, uint64_t a2)
{
}

void sub_10014D5F8()
{
}

#error "10014D7EC: call analysis failed (funcsize=115)"

sqlite3_stmt *sub_10014D824(sqlite3_stmt *result, char *__s)
{
  if (result)
  {
    size_t v3 = result;
    pzTail = 0;
    ppStmt = 0;
    int v4 = strlen(__s);
    int v11 = sqlite3_prepare_v2(v3, __s, v4, &ppStmt, (const char **)&pzTail);
    if (v11)
    {
      if (qword_1024195E0 != -1) {
        dispatch_once(&qword_1024195E0, &stru_1022BE480);
      }
      unint64_t v5 = off_1024195E8;
      if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_FAULT))
      {
        int v6 = sqlite3_errmsg(v3);
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v15 = 2082;
        __int16 v16 = "";
        __int16 v17 = 2081;
        __int16 v18 = __s;
        __int16 v19 = 1040;
        int v20 = 4;
        __int16 v21 = 2098;
        __int16 v22 = &v11;
        __int16 v23 = 2081;
        __int16 v24 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Could not prepare statement\", \"query\":%{private, location:escape_only}s, \"rc\":%{public, location:SqliteResult}.*P, \"errmsg\":%{private, location:escape_only}s}", buf, 0x36u);
        if (qword_1024195E0 != -1) {
          dispatch_once(&qword_1024195E0, &stru_1022BE480);
        }
      }
      size_t v7 = off_1024195E8;
      if (os_signpost_enabled((os_log_t)off_1024195E8))
      {
        long long v8 = sqlite3_errmsg(v3);
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v15 = 2082;
        __int16 v16 = "";
        __int16 v17 = 2081;
        __int16 v18 = __s;
        __int16 v19 = 1040;
        int v20 = 4;
        __int16 v21 = 2098;
        __int16 v22 = &v11;
        __int16 v23 = 2081;
        __int16 v24 = v8;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Could not prepare statement", "{\"msg%{public}.0s\":\"Could not prepare statement\", \"query\":%{private, location:escape_only}s, \"rc\":%{public, location:SqliteResult}.*P, \"errmsg\":%{private, location:escape_only}s}", buf, 0x36u);
      }
      std::string::size_type v9 = sqlite3_db_filename(v3, 0);
      if (v9) {
        uint64_t v10 = (char *)v9;
      }
      else {
        uint64_t v10 = "";
      }
      sub_100134750(buf, v10);
      sub_1005F9B94(v3, buf, 0, v11);
      if (SBYTE3(v18) < 0) {
        operator delete(*(void **)buf);
      }
      return 0;
    }
    else
    {
      return ppStmt;
    }
  }
  return result;
}

void sub_10014DA90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10014DAB4(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_102303570;
  a1[1] = a2;
  a1[2] = a3;
  sub_10014DB1C(a2);
  *a1 = off_102303590;
  return a1;
}

uint64_t sub_10014DB1C(uint64_t a1)
{
  return sub_10014DB24(*(void *)(a1 + 16));
}

uint64_t sub_10014DB24(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

BOOL sub_10014DB48(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 8) + 64) assertInside];
  pthread_t v2 = *(pthread_t *)(*(void *)(a1 + 8) + 80);
  return v2 == pthread_self();
}

char *sub_10014DB88@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[255] < 0) {
    return (char *)sub_1000DC48C((unsigned char *)a2, *((void **)result + 29), *((void *)result + 30));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 232);
  *(void *)(a2 + 16) = *((void *)result + 31);
  return result;
}

BOOL sub_10014DBB4(sqlite3_stmt *a1, int a2, sqlite3_int64 a3)
{
  int v6 = sqlite3_bind_int64(a1, a2, a3);
  int v11 = v6;
  if (v6)
  {
    if (qword_1024195E0 != -1) {
      dispatch_once(&qword_1024195E0, &stru_1022BE480);
    }
    size_t v7 = off_1024195E8;
    if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68290307;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2049;
      sqlite3_int64 v17 = a3;
      __int16 v18 = 1026;
      int v19 = a2;
      __int16 v20 = 1040;
      int v21 = 4;
      __int16 v22 = 2098;
      __int16 v23 = &v11;
      __int16 v24 = 2081;
      uint64_t v25 = sqlite3_sql(a1);
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Could not bind\", \"value\":%{private}lld, \"index\":%{public}d, \"rc\":%{public, location:SqliteResult}.*P, \"query\":%{private, location:escape_only}s}", buf, 0x3Cu);
      if (qword_1024195E0 != -1) {
        dispatch_once(&qword_1024195E0, &stru_1022BE480);
      }
    }
    long long v8 = off_1024195E8;
    if (os_signpost_enabled((os_log_t)off_1024195E8))
    {
      std::string::size_type v9 = sqlite3_sql(a1);
      *(_DWORD *)buf = 68290307;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2049;
      sqlite3_int64 v17 = a3;
      __int16 v18 = 1026;
      int v19 = a2;
      __int16 v20 = 1040;
      int v21 = 4;
      __int16 v22 = 2098;
      __int16 v23 = &v11;
      __int16 v24 = 2081;
      uint64_t v25 = v9;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Could not bind", "{\"msg%{public}.0s\":\"Could not bind\", \"value\":%{private}lld, \"index\":%{public}d, \"rc\":%{public, location:SqliteResult}.*P, \"query\":%{private, location:escape_only}s}", buf, 0x3Cu);
    }
  }
  return v6 == 0;
}

void sub_10014DDEC(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3 && sub_10014C3C0(v3))
  {
    *((unsigned char *)&v22.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&v22, "SELECT ");
    sub_10006116C((uint64_t)__p);
    if ((v21 & 0x80u) == 0) {
      int v4 = __p;
    }
    else {
      int v4 = (void **)__p[0];
    }
    if ((v21 & 0x80u) == 0) {
      std::string::size_type v5 = v21;
    }
    else {
      std::string::size_type v5 = (std::string::size_type)__p[1];
    }
    int v6 = std::string::append(&v22, (const std::string::value_type *)v4, v5);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    char v19 = 6;
    strcpy(__s, " FROM ");
    long long v8 = std::string::append(&v23, __s, 6uLL);
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v24.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    int v10 = *(char *)(a1 + 23);
    if (v10 >= 0) {
      int v11 = (const std::string::value_type *)a1;
    }
    else {
      int v11 = *(const std::string::value_type **)a1;
    }
    if (v10 >= 0) {
      std::string::size_type v12 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      std::string::size_type v12 = *(void *)(a1 + 8);
    }
    int v13 = std::string::append(&v24, v11, v12);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    int64_t v26 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)buf = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (v19 < 0) {
      operator delete(*(void **)__s);
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v23.__r_.__value_.__l.__data_);
    }
    if ((char)v21 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    if (v26 >= 0) {
      __int16 v15 = buf;
    }
    else {
      __int16 v15 = *(uint8_t **)buf;
    }
    sub_10014D518(*(void *)(a1 + 104), (uint64_t)v15);
  }
  if (qword_1024193B0 != -1) {
    dispatch_once(&qword_1024193B0, &stru_1022C8300);
  }
  __int16 v16 = qword_1024193B8;
  if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "not connected to wifi #tile header table", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1022C8300);
    }
    LOWORD(v24.__r_.__value_.__l.__data_) = 0;
    sqlite3_int64 v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLWifiTileHeaderEntry> CLWifiTileHeaderDatabase::selectAll()", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
}

void sub_10014E380(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10014E4B4(uint64_t result, int a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18)
{
  *(_DWORD *)uint64_t result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(double *)(result + 8) = a9;
  *(double *)(result + 16) = a10;
  *(double *)(result + 24) = a11;
  *(double *)(result + 32) = a12;
  *(double *)(result + 40) = a13;
  *(double *)(result + 48) = a14;
  *(double *)(result + 56) = a15;
  *(double *)(result + 64) = a16;
  *(void *)(result + 72) = a4;
  *(_DWORD *)(result + 80) = a5;
  *(void *)(result + 88) = a6;
  *(_DWORD *)(result + 96) = a7;
  *(void *)(result + 104) = a17;
  *(void *)(result + 112) = a18;
  *(_DWORD *)(result + 120) = a8;
  *(void *)(result + 132) = 0;
  *(void *)(result + 124) = 0;
  return result;
}

uint64_t sub_10014E4F0(uint64_t *a1, int *a2, int *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10, double *a11, uint64_t *a12, int *a13, uint64_t *a14, int *a15, uint64_t *a16, uint64_t *a17, int *a18)
{
  char v19 = (char *)*a1;
  unint64_t v20 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 4);
  unint64_t v21 = v20 + 1;
  if (v20 + 1 > 0x1C71C71C71C71C7) {
    sub_1001D7FD4();
  }
  std::string v29 = a17;
  std::string v28 = a18;
  std::string v30 = a16;
  uint64_t v31 = a13;
  uint64_t v33 = a11;
  uint64_t v32 = a12;
  uint64_t v34 = (uint64_t)(a1 + 2);
  unint64_t v35 = 0x8E38E38E38E38E39 * ((a1[2] - (uint64_t)v19) >> 4);
  if (2 * v35 > v21) {
    unint64_t v21 = 2 * v35;
  }
  if (v35 >= 0xE38E38E38E38E3) {
    unint64_t v36 = 0x1C71C71C71C71C7;
  }
  else {
    unint64_t v36 = v21;
  }
  if (v36)
  {
    v58 = a5;
    uint64_t v59 = a7;
    uint64_t v37 = a6;
    BOOL v38 = a4;
    int v57 = a8;
    v39 = a3;
    uint64_t v40 = a2;
    unint64_t v41 = v20;
    uint64_t v42 = sub_10014E7AC(v34, v36);
    std::string v30 = a16;
    a5 = v58;
    std::string v29 = a17;
    unint64_t v20 = v41;
    std::string v28 = a18;
    a2 = v40;
    uint64_t v33 = a11;
    uint64_t v32 = a12;
    a3 = v39;
    uint64_t v31 = a13;
    a8 = v57;
    a4 = v38;
    a6 = v37;
    a7 = v59;
    v43 = v42;
    uint64_t v34 = (uint64_t)(a1 + 2);
    uint64_t v45 = v44;
  }
  else
  {
    v43 = 0;
    uint64_t v45 = 0;
  }
  uint64_t v46 = (uint64_t)v43 + 144 * v20;
  sub_10014E730(v34, v46, a2, a3, a4, a5, a6, a7, a8, a9, a10, v33, v32, v31, a14, a15, v30, v29, v28);
  uint64_t v47 = v46 + 144;
  v49 = (char *)*a1;
  v48 = (char *)a1[1];
  if (v48 != (char *)*a1)
  {
    do
    {
      *(_OWORD *)(v46 - 144) = *((_OWORD *)v48 - 9);
      long long v50 = *((_OWORD *)v48 - 8);
      long long v51 = *((_OWORD *)v48 - 7);
      long long v52 = *((_OWORD *)v48 - 5);
      *(_OWORD *)(v46 - 96) = *((_OWORD *)v48 - 6);
      *(_OWORD *)(v46 - 80) = v52;
      *(_OWORD *)(v46 - 128) = v50;
      *(_OWORD *)(v46 - 112) = v51;
      long long v53 = *((_OWORD *)v48 - 4);
      long long v54 = *((_OWORD *)v48 - 3);
      long long v55 = *((_OWORD *)v48 - 2);
      *(_OWORD *)(v46 - 20) = *(_OWORD *)(v48 - 20);
      *(_OWORD *)(v46 - 48) = v54;
      *(_OWORD *)(v46 - 32) = v55;
      *(_OWORD *)(v46 - 64) = v53;
      v46 -= 144;
      v48 -= 144;
    }
    while (v48 != v49);
    v48 = (char *)*a1;
  }
  *a1 = v46;
  a1[1] = v47;
  a1[2] = (uint64_t)v43 + 144 * v45;
  if (v48) {
    operator delete(v48);
  }
  return v47;
}

void sub_10014E718(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10014E730(uint64_t a1, uint64_t a2, int *a3, int *a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10, double *a11, double *a12, uint64_t *a13, int *a14, uint64_t *a15, int *a16, uint64_t *a17, uint64_t *a18, int *a19)
{
  int v21 = *a3;
  int v22 = *a4;
  double v23 = *a5;
  double v24 = *a6;
  double v25 = *a7;
  double v26 = *a8;
  double v27 = *a9;
  double v28 = *a10;
  double v29 = *a11;
  double v30 = *a12;
  uint64_t v31 = *a13;
  int v32 = *a14;
  uint64_t v33 = *a15;
  int v34 = *a16;
  int v35 = *a19;
  uint64_t v37 = *a17;
  uint64_t v38 = *a18;
  return sub_10014E4B4(a2, v21, v22, v31, v32, v33, v34, v35, v23, v24, v25, v26, v27, v28, v29, v30, v37, v38);
}

void *sub_10014E7AC(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8) {
    sub_1001D7FA0();
  }
  return operator new(144 * a2);
}

void sub_10014E7F8(int *a1@<X0>, double **a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  v68[0] = 0;
  v68[1] = 0;
  v67 = v68;
  int v10 = *a2;
  int v11 = a2[1];
  while (v10 != v11)
  {
    sub_10014F62C(v10, (uint64_t)buf);
    sub_1000EDDFC((uint64_t **)&v67, (uint64_t)buf, (uint64_t)buf, (long long *)v10);
    if (SHIBYTE(v84) < 0) {
      operator delete((void *)__p);
    }
    v10 += 18;
  }
  uint64_t v64 = 0;
  unint64_t v65 = 0;
  unint64_t v66 = 0;
  uint64_t v61 = 0;
  unint64_t v62 = 0;
  unint64_t v63 = 0;
  uint64_t v58 = 0;
  unint64_t v59 = 0;
  unint64_t v60 = 0;
  v57[0] = 0;
  v57[1] = 0;
  double v12 = *(double *)(a3 + 20);
  __int16 v56 = v57;
  if (v12 <= 0.0 || a5 - *(double *)(a3 + 76) >= (double)((unint64_t)3600.0 >> 1))
  {
    if (*a1 <= 25)
    {
      unint64_t v20 = *a2;
      int v21 = a2[1];
      while (v20 != v21)
      {
        sub_10014F62C(v20, (uint64_t)buf);
        sub_101454AC0(&v61, (long long *)buf);
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)__p);
        }
        v20 += 18;
      }
    }
    else
    {
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1023273E8);
      }
      sqlite3_int64 v17 = qword_1024193B8;
      if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "invalid location provided and complete miss, will not return any tiles to search", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193B0 != -1) {
          dispatch_once(&qword_1024193B0, &stru_1023273E8);
        }
        *(_WORD *)v79 = 0;
        long long v50 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch(const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)", "%s\n", v50);
        if (v50 != buf) {
          free(v50);
        }
      }
    }
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_1023273C8);
    }
    __int16 v18 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v19 = *a1 > 25;
      *(_DWORD *)buf = 134349824;
      *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v65 - v64) >> 4);
      *(_WORD *)&buf[12] = 2050;
      *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - v61) >> 4);
      *(_WORD *)&buf[22] = 2050;
      *(void *)&long long __p = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - v58) >> 4);
      WORD4(__p) = 1026;
      *(_DWORD *)((char *)&__p + 10) = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, 0, completemiss, %{public}d", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1023273C8);
      }
      BOOL v46 = *a1 > 25;
      *(_DWORD *)v79 = 134349824;
      *(void *)&v79[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v65 - v64) >> 4);
      *(_WORD *)&v79[12] = 2050;
      *(void *)&v79[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - v61) >> 4);
      *(_WORD *)&v79[22] = 2050;
      *(void *)&long long v80 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - v58) >> 4);
      WORD4(v80) = 1026;
      *(_DWORD *)((char *)&v80 + 10) = v46;
      uint64_t v47 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch(const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)", "%s\n", v47);
      if (v47 != buf) {
        free(v47);
      }
    }
    sub_1000180B4(a4, &v64, &v61, &v58);
  }
  else
  {
    *(_DWORD *)buf = 0;
    sub_10014F674((uint64_t)v79, buf);
    sub_100146674((uint64_t)v79, -1, *(double *)(a3 + 4), *(double *)(a3 + 12), 0.05, 0.05);
    if (v68 != sub_100144248((uint64_t)&v67, (uint64_t)v79))
    {
      unint64_t v13 = v65;
      if (v65 >= v66)
      {
        uint64_t v22 = sub_10014F734(&v64, (long long *)v79);
      }
      else
      {
        long long v14 = *(_OWORD *)v79;
        *(void *)(v65 + 16) = *(void *)&v79[16];
        *(_OWORD *)unint64_t v13 = v14;
        __int16 v15 = (unsigned char *)(v13 + 24);
        if (SHIBYTE(v81) < 0)
        {
          sub_1000DC48C(v15, (void *)v80, *((unint64_t *)&v80 + 1));
        }
        else
        {
          long long v16 = v80;
          *(void *)(v13 + 40) = v81;
          *(_OWORD *)__int16 v15 = v16;
        }
        uint64_t v22 = v13 + 48;
      }
      unint64_t v65 = v22;
      sub_10014F464((uint64_t **)&v56, (uint64_t)v79, (uint64_t)v79);
    }
    long long v52 = *(_OWORD *)v79;
    uint64_t v53 = *(void *)&v79[16];
    if (SHIBYTE(v81) < 0)
    {
      sub_1000DC48C(&v54, (void *)v80, *((unint64_t *)&v80 + 1));
    }
    else
    {
      long long v54 = v80;
      uint64_t v55 = v81;
    }
    long long v51 = (char **)sub_100144248((uint64_t)&v67, (uint64_t)v79);
    uint64_t v24 = 8;
    double v25 = &byte_101DAF2D5;
    do
    {
      unsigned int v26 = *v25;
      unsigned int v27 = *(v25 - 1);
      *(_OWORD *)buf = v52;
      *(void *)&uint8_t buf[16] = v53;
      if (SHIBYTE(v55) < 0)
      {
        sub_1000DC48C(&__p, (void *)v54, *((unint64_t *)&v54 + 1));
      }
      else
      {
        long long __p = v54;
        uint64_t v84 = v55;
      }
      v23.i32[0] = 1028443341;
      sub_100143FCC((uint64_t)buf, v26, v27, 0.05, v23);
      if (v68 == sub_100144248((uint64_t)&v67, (uint64_t)buf))
      {
        unint64_t v32 = v59;
        if (v59 >= v60)
        {
          uint64_t v37 = sub_10014F734(&v58, (long long *)buf);
        }
        else
        {
          long long v33 = *(_OWORD *)buf;
          *(void *)(v59 + 16) = *(void *)&buf[16];
          *(_OWORD *)unint64_t v32 = v33;
          int v34 = (unsigned char *)(v32 + 24);
          if (SHIBYTE(v84) < 0)
          {
            sub_1000DC48C(v34, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long v35 = __p;
            *(void *)(v32 + 40) = v84;
            *(_OWORD *)int v34 = v35;
          }
          uint64_t v37 = v32 + 48;
        }
        unint64_t v59 = v37;
      }
      else if (v57 != sub_100144248((uint64_t)&v56, (uint64_t)&v52))
      {
        unint64_t v28 = v65;
        if (v65 >= v66)
        {
          uint64_t v36 = sub_10014F734(&v64, (long long *)buf);
        }
        else
        {
          long long v29 = *(_OWORD *)buf;
          *(void *)(v65 + 16) = *(void *)&buf[16];
          *(_OWORD *)unint64_t v28 = v29;
          double v30 = (unsigned char *)(v28 + 24);
          if (SHIBYTE(v84) < 0)
          {
            sub_1000DC48C(v30, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long v31 = __p;
            *(void *)(v28 + 40) = v84;
            *(_OWORD *)double v30 = v31;
          }
          uint64_t v36 = v28 + 48;
        }
        unint64_t v65 = v36;
        sub_10014F464((uint64_t **)&v56, (uint64_t)buf, (uint64_t)buf);
      }
      if (SHIBYTE(v84) < 0) {
        operator delete((void *)__p);
      }
      v25 += 2;
      --v24;
    }
    while (v24);
    if (*a1 <= 25)
    {
      uint64_t v38 = (uint64_t *)v67;
      if (v67 != v68)
      {
        do
        {
          if (v57 == sub_100144248((uint64_t)&v56, (uint64_t)(v38 + 4)))
          {
            sub_10014F464((uint64_t **)&v56, (uint64_t)(v38 + 4), (uint64_t)(v38 + 4));
            unint64_t v39 = v62;
            if (v62 >= v63)
            {
              uint64_t v40 = sub_10014F734(&v61, (long long *)v38 + 2);
            }
            else
            {
              sub_10014F6C0((uint64_t)&v61, (long long *)v38 + 2);
              uint64_t v40 = v39 + 48;
            }
            unint64_t v62 = v40;
          }
          unint64_t v41 = (char *)v38[1];
          if (v41)
          {
            do
            {
              uint64_t v42 = (char **)v41;
              unint64_t v41 = *(char **)v41;
            }
            while (v41);
          }
          else
          {
            do
            {
              uint64_t v42 = (char **)v38[2];
              BOOL v43 = *v42 == (char *)v38;
              uint64_t v38 = (uint64_t *)v42;
            }
            while (!v43);
          }
          uint64_t v38 = (uint64_t *)v42;
        }
        while (v42 != v68);
      }
    }
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_1023273C8);
    }
    uint64_t v44 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v45 = *a1 > 25;
      *(_DWORD *)buf = 134350080;
      *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v65 - v64) >> 4);
      *(_WORD *)&buf[12] = 2050;
      *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - v61) >> 4);
      *(_WORD *)&buf[22] = 2050;
      *(void *)&long long __p = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - v58) >> 4);
      WORD4(__p) = 1026;
      *(_DWORD *)((char *)&__p + 10) = v68 != v51;
      HIWORD(__p) = 1026;
      LODWORD(v84) = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, %{public}d, completemiss, %{public}d", buf, 0x2Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1023273C8);
      }
      BOOL v48 = *a1 > 25;
      int v69 = 134350080;
      unint64_t v70 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v65 - v64) >> 4);
      __int16 v71 = 2050;
      unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - v61) >> 4);
      __int16 v73 = 2050;
      unint64_t v74 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - v58) >> 4);
      __int16 v75 = 1026;
      BOOL v76 = v68 != v51;
      __int16 v77 = 1026;
      BOOL v78 = v48;
      v49 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch(const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)", "%s\n", v49);
      if (v49 != buf) {
        free(v49);
      }
    }
    sub_1000180B4(a4, &v64, &v61, &v58);
    if (SHIBYTE(v55) < 0) {
      operator delete((void *)v54);
    }
    if (SHIBYTE(v81) < 0) {
      operator delete((void *)v80);
    }
  }
  sub_10014F400((uint64_t)&v56, v57[0]);
  *(void *)buf = &v58;
  sub_10014FEE0((void ***)buf);
  *(void *)buf = &v61;
  sub_10014FEE0((void ***)buf);
  *(void *)buf = &v64;
  sub_10014FEE0((void ***)buf);
  sub_10014F400((uint64_t)&v67, v68[0]);
}

void sub_10014F2D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,char *a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char a35,char *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,char *a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  a53 = &a26;
  sub_10014FEE0((void ***)&a53);
  a53 = &a29;
  sub_10014FEE0((void ***)&a53);
  a53 = &a32;
  sub_10014FEE0((void ***)&a53);
  sub_10014F400((uint64_t)&a35, a36);
  _Unwind_Resume(a1);
}

void sub_10014F400(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_10014F400(a1, *(void *)a2);
    sub_10014F400(a1, *((void *)a2 + 1));
    if (a2[79] < 0) {
      operator delete(*((void **)a2 + 7));
    }
    operator delete(a2);
  }
}

uint64_t *sub_10014F464(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  std::string::size_type v5 = (uint64_t **)sub_10014F4E4((uint64_t)a1, &v8, a2);
  uint64_t result = *v5;
  if (!*v5)
  {
    sub_10014F578((uint64_t)a1, a3, (uint64_t)&v7);
    sub_1000EDF90(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void *sub_10014F4E4(uint64_t a1, void *a2, uint64_t a3)
{
  std::string::size_type v5 = (void *)(a1 + 8);
  int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        long long v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1001442C4(a3, (uint64_t)(v4 + 4))) {
          break;
        }
        int v4 = (void *)*v7;
        std::string::size_type v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1001442C4(v8, a3)) {
        break;
      }
      std::string::size_type v5 = v7 + 1;
      int v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    long long v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void *sub_10014F578@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  v6[2] = *(_OWORD *)a2;
  *((void *)v6 + 6) = *(void *)(a2 + 16);
  uint64_t result = (void *)v6 + 7;
  if (*(char *)(a2 + 47) < 0)
  {
    uint64_t result = sub_1000DC48C(result, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)(a2 + 24);
    result[2] = *(void *)(a2 + 40);
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_10014F610(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1008B4750(v3, v2);
  _Unwind_Resume(a1);
}

double sub_10014F62C@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  int v5 = 0;
  uint64_t v3 = sub_10014F674(a2, &v5);
  double result = *a1;
  *(double *)(v3 + 4) = *a1;
  *(void *)(v3 + 16) = -1;
  return result;
}

uint64_t sub_10014F674(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  *(void *)(a1 + 4) = -1;
  *(void *)(a1 + 16) = -1;
  sub_100134750((void *)(a1 + 24), "");
  return a1;
}

unsigned char *sub_10014F6C0(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = *a2;
  *(void *)(v3 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v3 = v4;
  double result = (unsigned char *)(v3 + 24);
  if (*((char *)a2 + 47) < 0)
  {
    double result = sub_1000DC48C(result, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(v3 + 40) = *((void *)a2 + 5);
    *(_OWORD *)double result = v6;
  }
  *(void *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_10014F72C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10014F734(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v20 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_10014F86C(v7, v9);
  }
  else {
    int v10 = 0;
  }
  int v11 = &v10[48 * v4];
  v17[0] = v10;
  v17[1] = v11;
  __int16 v18 = v11;
  BOOL v19 = &v10[48 * v9];
  long long v12 = *a2;
  *((void *)v11 + 2) = *((void *)a2 + 2);
  *(_OWORD *)int v11 = v12;
  unint64_t v13 = v11 + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1000DC48C(v13, *((void **)a2 + 3), *((void *)a2 + 4));
    int v11 = v18;
  }
  else
  {
    long long v14 = *(long long *)((char *)a2 + 24);
    *((void *)v11 + 5) = *((void *)a2 + 5);
    *(_OWORD *)unint64_t v13 = v14;
  }
  __int16 v18 = v11 + 48;
  sub_10014F8B4(a1, v17);
  uint64_t v15 = a1[1];
  sub_10014FA14((uint64_t)v17);
  return v15;
}

void sub_10014F858(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10014FA14((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_10014F86C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    sub_1001D7FA0();
  }
  return operator new(48 * a2);
}

uint64_t sub_10014F8B4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10014F92C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10014F92C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 48);
      *(void *)(v9 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v9 - 48) = v10;
      long long v11 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    *((void *)&v16 + 1) = v9;
  }
  char v14 = 1;
  sub_10014F9DC((uint64_t)v13);
  return a6;
}

uint64_t sub_10014F9DC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100436C9C(a1);
  }
  return a1;
}

uint64_t sub_10014FA14(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10014FA4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 48;
      *(void *)(a1 + 16) = v2 - 48;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_10014FAA4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v65 = a1 + 56;
  (*(void (**)(void))(v10 + 16))();
  __int16 v67 = 256;
  sub_100181F80(a1, v64);
  sub_10014E7F8((int *)(a1 + 72), v64, a2, v61, a5);
  sub_1000600EC((uint64_t)v60, v61[0], v61[1]);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  sub_10014B230(a1, v60, a3, &v58, a5);
  uint64_t v11 = v58;
  for (uint64_t i = v59; v11 != i; v11 += 56)
  {
    long long v13 = *(_OWORD *)v11;
    uint64_t v55 = *(void *)(v11 + 16);
    long long v54 = v13;
    if (*(char *)(v11 + 47) < 0)
    {
      sub_1000DC48C(&__p, *(void **)(v11 + 24), *(void *)(v11 + 32));
    }
    else
    {
      long long v14 = *(_OWORD *)(v11 + 24);
      uint64_t v57 = *(void *)(v11 + 40);
      long long __p = v14;
    }
    if (*(unsigned char *)(v11 + 48))
    {
      sub_1014526D0(a1, &v45);
      long long v16 = a4[1];
      unint64_t v15 = (unint64_t)a4[2];
      if ((unint64_t)v16 >= v15)
      {
        uint64_t v24 = *a4;
        unint64_t v25 = 0x8E38E38E38E38E39 * ((v16 - *a4) >> 4);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x1C71C71C71C71C7) {
          sub_1001D7FD4();
        }
        unint64_t v27 = 0x8E38E38E38E38E39 * ((uint64_t)(v15 - (void)v24) >> 4);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0xE38E38E38E38E3) {
          unint64_t v28 = 0x1C71C71C71C71C7;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          long long v29 = (char *)sub_10014E7AC((uint64_t)(a4 + 2), v28);
          uint64_t v24 = *a4;
          long long v16 = a4[1];
        }
        else
        {
          long long v29 = 0;
        }
        double v30 = &v29[144 * v25];
        *(_OWORD *)double v30 = v45;
        long long v31 = v46;
        long long v32 = v47;
        long long v33 = v49;
        *((_OWORD *)v30 + 3) = v48;
        *((_OWORD *)v30 + 4) = v33;
        *((_OWORD *)v30 + 1) = v31;
        *((_OWORD *)v30 + 2) = v32;
        long long v34 = v50;
        long long v35 = v51;
        long long v36 = v53;
        *((_OWORD *)v30 + 7) = v52;
        *((_OWORD *)v30 + 8) = v36;
        *((_OWORD *)v30 + 5) = v34;
        *((_OWORD *)v30 + 6) = v35;
        if (v16 == v24)
        {
          uint64_t v44 = &v29[144 * v25];
        }
        else
        {
          uint64_t v37 = &v29[144 * v25];
          do
          {
            *((_OWORD *)v37 - 9) = *((_OWORD *)v16 - 9);
            long long v38 = *((_OWORD *)v16 - 8);
            long long v39 = *((_OWORD *)v16 - 7);
            long long v40 = *((_OWORD *)v16 - 5);
            *((_OWORD *)v37 - 6) = *((_OWORD *)v16 - 6);
            *((_OWORD *)v37 - 5) = v40;
            *((_OWORD *)v37 - 8) = v38;
            *((_OWORD *)v37 - 7) = v39;
            long long v41 = *((_OWORD *)v16 - 4);
            long long v42 = *((_OWORD *)v16 - 3);
            long long v43 = *((_OWORD *)v16 - 2);
            uint64_t v44 = v37 - 144;
            *(_OWORD *)(v37 - 20) = *(_OWORD *)(v16 - 20);
            *((_OWORD *)v37 - 3) = v42;
            *((_OWORD *)v37 - 2) = v43;
            *((_OWORD *)v37 - 4) = v41;
            v16 -= 144;
            v37 -= 144;
          }
          while (v16 != v24);
        }
        float32x2_t v23 = v30 + 144;
        *a4 = v44;
        a4[1] = v30 + 144;
        a4[2] = &v29[144 * v28];
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        *(_OWORD *)long long v16 = v45;
        long long v17 = v46;
        long long v18 = v47;
        long long v19 = v49;
        *((_OWORD *)v16 + 3) = v48;
        *((_OWORD *)v16 + 4) = v19;
        *((_OWORD *)v16 + 1) = v17;
        *((_OWORD *)v16 + 2) = v18;
        long long v20 = v50;
        long long v21 = v51;
        long long v22 = v53;
        *((_OWORD *)v16 + 7) = v52;
        *((_OWORD *)v16 + 8) = v22;
        *((_OWORD *)v16 + 5) = v20;
        *((_OWORD *)v16 + 6) = v21;
        float32x2_t v23 = v16 + 144;
      }
      a4[1] = v23;
    }
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)__p);
    }
  }
  *(void *)&long long v45 = &v58;
  sub_10017C62C((void ***)&v45);
  sub_10014F400((uint64_t)v60, (char *)v60[1]);
  *(void *)&long long v45 = &v63;
  sub_10014FEE0((void ***)&v45);
  *(void *)&long long v45 = &v62;
  sub_10014FEE0((void ***)&v45);
  *(void *)&long long v45 = v61;
  sub_10014FEE0((void ***)&v45);
  if (v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }
  if (HIBYTE(v67))
  {
    if ((_BYTE)v67) {
      pthread_mutex_unlock(v66);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v65 + 24))(v65);
    }
  }
}

void sub_10014FE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,char a41,char *a42)
{
  long long v45 = *(void **)v42;
  if (*(void *)v42)
  {
    *(void *)(v42 + 8) = v45;
    operator delete(v45);
  }
  sub_10014F400((uint64_t)&a41, a42);
  sub_101450C04((void **)(v43 - 224));
  long long v46 = *(void **)(v43 - 152);
  if (v46)
  {
    *(void *)(v43 - 144) = v46;
    operator delete(v46);
  }
  sub_1019DB560(v43 - 128);
  _Unwind_Resume(a1);
}

void sub_10014FEE0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10014FF34((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_10014FF34(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void sub_10014FF84(uint64_t a1, char *a2)
{
  sub_10015907C(a1);
  if (*(char *)(a1 + 161) < *a2)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    unint64_t v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      int v5 = *a2;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)long long v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&v22[6] = "";
      __int16 v23 = 1026;
      int v24 = v5;
      __int16 v25 = 2050;
      double v26 = sub_100151E24(a1);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Starting all location providers up to threshold\", \"threshold\":%{public}d, \"desiredAccuracy\":\"%{public}f\"}", buf, 0x22u);
    }
    int v6 = *a2;
    if (v6 <= 2)
    {
      uint64_t v7 = (void *)(a1 + 248);
      while (1)
      {
        uint64_t v8 = *(void **)(a1 + 240);
        if (v8 != v7)
        {
          char v9 = 0;
          do
          {
            int v10 = *((char *)v8 + 900);
            if (v10 <= *(char *)(a1 + 161) || v10 > (char)v6)
            {
              if (qword_102419380 != -1) {
                dispatch_once(&qword_102419380, &stru_1022C17A0);
              }
              uint64_t v11 = qword_102419388;
              if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
              {
                long long v12 = v8 + 6;
                if (*((char *)v8 + 71) < 0) {
                  long long v12 = (void *)*v12;
                }
                int v13 = *(char *)(a1 + 160);
                int v14 = *(char *)(a1 + 161);
                *(_DWORD *)buf = 136446722;
                *(void *)long long v22 = v12;
                *(_WORD *)&v22[8] = 1026;
                *(_DWORD *)&v22[10] = v13;
                __int16 v23 = 1026;
                int v24 = v14;
                _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Not starting location provider,%{public}s,fRequiredLocationGranularity,%{public}d,fActiveLocationGranularity,%{public}d", buf, 0x18u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419380 != -1) {
                  dispatch_once(&qword_102419380, &stru_1022C17A0);
                }
                long long v18 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocation(const Granularity &)", "%s\n", v18);
                if (v18 != (char *)buf) {
                  free(v18);
                }
              }
            }
            else
            {
              sub_100150F38(a1, *((_DWORD *)v8 + 10));
              char v9 = 1;
            }
            unint64_t v15 = (void *)v8[1];
            if (v15)
            {
              do
              {
                long long v16 = v15;
                unint64_t v15 = (void *)*v15;
              }
              while (v15);
            }
            else
            {
              do
              {
                long long v16 = (void *)v8[2];
                BOOL v17 = *v16 == (void)v8;
                uint64_t v8 = v16;
              }
              while (!v17);
            }
            uint64_t v8 = v16;
          }
          while (v16 != v7);
          if (v9) {
            break;
          }
        }
        int v6 = (char)(v6 + 1);
        if (v6 >= 3) {
          goto LABEL_36;
        }
      }
      sub_10001F5E4(a1);
      if (v6 == 2)
      {
        sub_10039711C(a1 + 768);
        LOBYTE(v6) = 2;
      }
    }
LABEL_36:
    int v19 = *(unsigned __int8 *)(a1 + 161);
    if (v19 != 2)
    {
      if (v19 == 255 || ([*(id *)(a1 + 656) nextFireDelay], v20 < 15.0)) {
        [*(id *)(a1 + 656) setNextFireDelay:15.0];
      }
    }
    *(unsigned char *)(a1 + 161) = v6;
  }
}

void sub_10015035C(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  int v10 = a2;
  uint64_t v7 = sub_10016BA10();
  sub_10016BC44((uint64_t)v11);
  sub_10016BE74(v7, v11[0].i64);
  int v12 = 14;
  v11[0].i32[0] = 14;
  v11[0].i32[1] = sub_10016A9AC(&v12);
  uint64_t v8 = sub_10016AB88();
  int v12 = 4;
  sub_100166814(v8, (unsigned int *)&v12, v11, (int *)(a1 + 5124), &v10, a3, a4);
  sub_10015040C(a1, *(_DWORD *)(a1 + 324), v9, (unsigned int *)a3, a4);
}

void sub_10015040C(uint64_t a1, int a2, uint64_t a3, unsigned int *a4, uint64_t a5)
{
  int v44 = a2;
  sub_1000EF97C((uint64_t)v33, a5);
  uint64_t v9 = *a4;
  if (v9 <= 0x27)
  {
    if (((1 << v9) & 0x8000000019) != 0)
    {
      sub_100150A68(a1, a5);
      long long v45 = &v44;
      int v10 = sub_100151D38((uint64_t **)(a1 + 240), &v44, (uint64_t)&unk_101D0B290, &v45);
      long long v11 = *(_OWORD *)(a5 + 16);
      *((_OWORD *)v10 + 6) = *(_OWORD *)a5;
      *((_OWORD *)v10 + 7) = v11;
      long long v12 = *(_OWORD *)(a5 + 32);
      long long v13 = *(_OWORD *)(a5 + 48);
      long long v14 = *(_OWORD *)(a5 + 80);
      *((_OWORD *)v10 + 10) = *(_OWORD *)(a5 + 64);
      *((_OWORD *)v10 + 11) = v14;
      *((_OWORD *)v10 + 8) = v12;
      *((_OWORD *)v10 + 9) = v13;
      long long v15 = *(_OWORD *)(a5 + 96);
      long long v16 = *(_OWORD *)(a5 + 112);
      long long v17 = *(_OWORD *)(a5 + 128);
      *(_OWORD *)((char *)v10 + 236) = *(_OWORD *)(a5 + 140);
      *((_OWORD *)v10 + 13) = v16;
      *((_OWORD *)v10 + 14) = v17;
      *((_OWORD *)v10 + 12) = v15;
      long long v45 = &v44;
      long long v18 = sub_100151D38((uint64_t **)(a1 + 240), &v44, (uint64_t)&unk_101D0B290, &v45);
      memcpy(v18 + 32, (const void *)(a5 + 160), 0x201uLL);
      int v19 = *(uint64_t **)(a5 + 680);
      double v20 = *(uint64_t **)(a5 + 688);
      if (v20) {
        atomic_fetch_add_explicit(v20 + 1, 1uLL, memory_order_relaxed);
      }
      v18[97] = v19;
      long long v21 = (std::__shared_weak_count *)v18[98];
      v18[98] = v20;
      if (v21) {
        sub_1000DB0A0(v21);
      }
      long long v22 = *(_OWORD *)(a5 + 696);
      long long v23 = *(_OWORD *)(a5 + 728);
      *(_OWORD *)(v18 + 101) = *(_OWORD *)(a5 + 712);
      *(_OWORD *)(v18 + 103) = v23;
      *(_OWORD *)(v18 + 99) = v22;
      long long v24 = *(_OWORD *)(a5 + 744);
      long long v25 = *(_OWORD *)(a5 + 760);
      long long v26 = *(_OWORD *)(a5 + 776);
      *(uint64_t **)((char *)v18 + 885) = *(uint64_t **)(a5 + 789);
      *(_OWORD *)(v18 + 107) = v25;
      *(_OWORD *)(v18 + 109) = v26;
      *(_OWORD *)(v18 + 105) = v24;
      sub_1001520D8(a1);
      sub_100150720(a1 + 2000, a5);
    }
    else if (v9 == 9)
    {
      sub_10002BA90(a1, a2);
    }
    else if (v9 == 22)
    {
      uint64_t v27 = *(void *)(a1 + 288);
      if (v27)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 456))(v27, a5);
        (*(void (**)(void, unsigned char *))(**(void **)(a1 + 288) + 464))(*(void *)(a1 + 288), v33);
      }
      double v28 = -1.0;
      if (sub_10067CAF0(a1, v35) && *(void *)(a1 + 1608))
      {
        unsigned int v29 = +[CLLocationDerivedSpeedEstimator isSupportedForDerivedSpeedEstimate];
        double v30 = -1.0;
        double v31 = -1.0;
        if (v29)
        {
          [*(id *)(a1 + 1608) currentEstimate];
          double v28 = v32;
        }
      }
      else
      {
        double v30 = -1.0;
        double v31 = -1.0;
      }
      double v39 = v28;
      double v40 = v30;
      double v41 = v31;
      LODWORD(v45) = 22;
      (*(void (**)(uint64_t, int **, unsigned char *, void, uint64_t, void))(*(void *)a1 + 152))(a1, &v45, v33, 0, 0xFFFFFFFFLL, 0);
    }
  }

  if (v42) {
    sub_1000DB0A0(v42);
  }
  if (v38 < 0) {
    operator delete(__p);
  }
  if (v36) {
    sub_1000DB0A0(v36);
  }
  if (v34) {
    sub_1000DB0A0(v34);
  }
}

void sub_100150704(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100458658((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100150720(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0xFFFFFFF7) != 1)
  {
    if (v3 != 3) {
      return;
    }
    if (*(unsigned char *)(a2 + 516))
    {
      *(void *)(a1 + 3064) = *(void *)(a2 + 504);
      goto LABEL_9;
    }
LABEL_8:
    sub_1000B0168(a1, a2);
    goto LABEL_9;
  }
  if (!*(unsigned char *)(a2 + 516))
  {
    a1 += 1528;
    goto LABEL_8;
  }
  *(void *)(a1 + 3072) = *(void *)(a2 + 504);
LABEL_9:
  if (qword_102419630 != -1) {
    dispatch_once(&qword_102419630, &stru_102303600);
  }
  unint64_t v4 = qword_102419638;
  if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = sub_10016BA10();
    *(_DWORD *)buf = 0;
    double v6 = sub_10016BA54(v5, buf);
    if (*(unsigned char *)(a2 + 516)) {
      uint64_t v7 = "not saved";
    }
    else {
      uint64_t v7 = "saved";
    }
    uint64_t v8 = sub_10003E9A4(*(_DWORD *)(a2 + 96));
    uint64_t v9 = *(void *)(a2 + 76);
    uint64_t v10 = *(void *)(a2 + 504);
    uint64_t v11 = *(void *)(a2 + 4);
    uint64_t v12 = *(void *)(a2 + 12);
    uint64_t v13 = sub_10016BA10();
    double v14 = sub_10018202C(v13);
    *(_DWORD *)buf = 134219779;
    double v18 = v6;
    __int16 v19 = 2080;
    double v20 = v7;
    __int16 v21 = 2080;
    long long v22 = v8;
    __int16 v23 = 2048;
    uint64_t v24 = v9;
    __int16 v25 = 2048;
    uint64_t v26 = v10;
    __int16 v27 = 2049;
    uint64_t v28 = v11;
    __int16 v29 = 2049;
    uint64_t v30 = v12;
    __int16 v31 = 2050;
    double v32 = v14;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "%.1lf,DeadReckoning,%s,%s,time,%.1lf,machCont,%.1lf,%{private}.8lf,%{private}.8lf,propagation_us,%{public}.3f", buf, 0x52u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_102303600);
    }
    sub_1005BFA38();
    sub_10003E9A4(*(_DWORD *)(a2 + 96));
    uint64_t v15 = sub_10016BA10();
    sub_10018202C(v15);
    long long v16 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void PropagationDataHistory::saveData(const CLLocationProvider_Type::NotificationData &)", "%s\n", v16);
    if (v16 != (char *)buf) {
      free(v16);
    }
  }
}

uint64_t sub_100150A68(uint64_t a1, uint64_t a2)
{
  if (qword_102419650 != -1) {
    dispatch_once(&qword_102419650, &stru_1022C1840);
  }
  unint64_t v4 = qword_102419658;
  if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v19 = *(void *)(a2 + 4);
    uint64_t v21 = *(void *)(a2 + 12);
    uint64_t v23 = *(void *)(a2 + 20);
    unsigned int v5 = *(_DWORD *)(a2 + 96);
    double v20 = sub_10003E9A4(v5);
    uint64_t v22 = *(void *)(a2 + 44);
    uint64_t v24 = *(void *)(a2 + 60);
    int v25 = *(_DWORD *)(a2 + 84);
    uint64_t v26 = *(void *)(a2 + 88);
    uint64_t v27 = *(void *)(a2 + 76);
    uint64_t v6 = sub_10016BA10();
    *(_DWORD *)buf = 0;
    double v7 = sub_10016BA54(v6, buf) - *(double *)(a2 + 76);
    uint64_t v8 = *(void *)(a2 + 28);
    uint64_t v9 = *(void *)(a2 + 36);
    uint64_t v10 = *(void *)(a2 + 52);
    uint64_t v11 = *(void *)(a2 + 68);
    uint64_t v12 = *(void *)(a2 + 184);
    int v18 = *(_DWORD *)(a2 + 128);
    uint64_t v13 = sub_10016BA10();
    double v14 = sub_10018202C(v13);
    *(_DWORD *)buf = 136320002;
    __int16 v29 = "CL-unfiltered";
    __int16 v30 = 1024;
    int v31 = 0;
    __int16 v32 = 2048;
    uint64_t v33 = v19;
    __int16 v34 = 2048;
    uint64_t v35 = v21;
    __int16 v36 = 2048;
    uint64_t v37 = v23;
    __int16 v38 = 1024;
    unsigned int v39 = v5;
    __int16 v40 = 2080;
    double v41 = v20;
    __int16 v42 = 2048;
    uint64_t v43 = v22;
    __int16 v44 = 2048;
    uint64_t v45 = v24;
    __int16 v46 = 1024;
    int v47 = v25;
    __int16 v48 = 2048;
    uint64_t v49 = v26;
    __int16 v50 = 2048;
    uint64_t v51 = v27;
    __int16 v52 = 2048;
    double v53 = v7;
    __int16 v54 = 2048;
    uint64_t v55 = v8;
    __int16 v56 = 2048;
    uint64_t v57 = v9;
    __int16 v58 = 2048;
    uint64_t v59 = v10;
    __int16 v60 = 2048;
    uint64_t v61 = v11;
    __int16 v62 = 2048;
    uint64_t v63 = v12;
    __int16 v64 = 1024;
    int v65 = v18;
    __int16 v66 = 2050;
    double v67 = v14;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d,propagation_us,%{public}.3f", buf, 0xBAu);
  }
  if (sub_10013D1A0(117, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419650 != -1) {
      dispatch_once(&qword_102419650, &stru_1022C1840);
    }
    sub_10003E9A4(*(_DWORD *)(a2 + 96));
    sub_1005BFA38();
    uint64_t v16 = sub_10016BA10();
    sub_10018202C(v16);
    long long v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("LOCATION", 1, 0, 2, "void CLLocationController::notifyUnfilteredLocation(const CLLocationProvider_Type::NotificationData &)", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
  *(_DWORD *)buf = 10;
  return (*(uint64_t (**)(uint64_t, uint8_t *, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, buf, a2, 1, 0xFFFFFFFFLL, 0);
}

void sub_100150F38(uint64_t a1, int a2)
{
  int v45 = a2;
  double v4 = sub_100151E24(a1);
  if (a2)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    unsigned int v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(void *)buf = &v45;
      uint64_t v6 = sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5];
      *(void *)buf = &v45;
      double v7 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      uint64_t v8 = v7 + 6;
      if (*((char *)v7 + 71) < 0) {
        uint64_t v8 = (void *)*v8;
      }
      *(_DWORD *)buf = 134349570;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v52 = 2050;
      double v53 = v4;
      __int16 v54 = 2082;
      uint64_t v55 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLIENT:startLocation,registerForNotification,start reg info,client,%{public}p,desiredAccuracy,%{public}.1lf,name,%{public}s", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(void *)__int16 v46 = &v45;
      int v31 = sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)v46)[5];
      *(void *)__int16 v46 = &v45;
      __int16 v32 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)v46);
      uint64_t v33 = v32 + 6;
      if (*((char *)v32 + 71) < 0) {
        uint64_t v33 = (void *)*v33;
      }
      *(_DWORD *)__int16 v46 = 134349570;
      *(void *)&v46[4] = v31;
      __int16 v47 = 2050;
      double v48 = v4;
      __int16 v49 = 2082;
      __int16 v50 = v33;
      __int16 v34 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v34);
      if (v34 != buf) {
        free(v34);
      }
    }
    uint64_t v9 = (uint64_t **)(a1 + 240);
    *(void *)buf = &v45;
    if (*((unsigned char *)sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 903)
      || (*(void *)buf = &v45,
          *((double *)sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 113) > 0.0))
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022C1820);
      }
      uint64_t v10 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning, starting already active provider", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        *(_WORD *)__int16 v46 = 0;
        uint64_t v35 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v35);
        if (v35 != buf) {
          free(v35);
        }
      }
    }
    if (!*(unsigned char *)(a1 + 664))
    {
      if (v45 == *(_DWORD *)(a1 + 328)) {
        sub_1001266F8(a1, 0);
      }
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022C1820);
      }
      long long v17 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)buf = &v45;
        int v18 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        uint64_t v19 = v18 + 6;
        if (*((char *)v18 + 71) < 0) {
          uint64_t v19 = (void *)*v19;
        }
        float v20 = sub_100151E24(a1);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v19;
        __int16 v52 = 2050;
        double v53 = v20;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "@ClxProvider, start, %{public}s, desiredAccuracy, %{public}.1f", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        *(void *)__int16 v46 = &v45;
        unsigned int v39 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)v46);
        __int16 v40 = v39 + 6;
        if (*((char *)v39 + 71) < 0) {
          __int16 v40 = (void *)*v40;
        }
        float v41 = sub_100151E24(a1);
        *(_DWORD *)__int16 v46 = 136446466;
        *(void *)&v46[4] = v40;
        __int16 v47 = 2050;
        double v48 = v41;
        __int16 v42 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v42);
        if (v42 != buf) {
          free(v42);
        }
      }
      if (v45 == *(_DWORD *)(a1 + 320))
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        uint64_t v21 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "WlpReg, 1, loccontroller", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022C1820);
          }
          *(_WORD *)__int16 v46 = 0;
          uint64_t v43 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v43);
          if (v43 != buf) {
            free(v43);
          }
        }
      }
      if (v45 == *(_DWORD *)(a1 + 324))
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        uint64_t v22 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "UclpReg, 1, loccontroller", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022C1820);
          }
          *(_WORD *)__int16 v46 = 0;
          __int16 v44 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v44);
          if (v44 != buf) {
            free(v44);
          }
        }
      }
      *(void *)buf = &v45;
      sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      sub_10012F770();
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v11 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(void *)buf = &v45;
      uint64_t v12 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      uint64_t v13 = v12 + 6;
      if (*((char *)v12 + 71) < 0) {
        uint64_t v13 = (void *)*v13;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "registering location provider,%{public}s,as a bystander only", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(void *)__int16 v46 = &v45;
      __int16 v36 = sub_100151D38((uint64_t **)(a1 + 240), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)v46);
      uint64_t v37 = v36 + 6;
      if (*((char *)v36 + 71) < 0) {
        uint64_t v37 = (void *)*v37;
      }
      *(_DWORD *)__int16 v46 = 136446210;
      *(void *)&v46[4] = v37;
      __int16 v38 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v38);
      if (v38 != buf) {
        free(v38);
      }
    }
    *(void *)buf = &v45;
    double v14 = sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5];
    [(id)v14[2] register:v14[1] forNotification:4 registrationInfo:0];
    if (v45 == *(_DWORD *)(a1 + 328))
    {
      *(void *)buf = &v45;
      uint64_t v23 = sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      [(id)v23[5][2] register:v23[5][1] forNotification:26 registrationInfo:0];
      *(void *)buf = &v45;
      uint64_t v24 = sub_1000FEE0C((uint64_t **)(a1 + 264), &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      [(id)v24[5][2] register:v24[5][1] forNotification:18 registrationInfo:0];
      uint64_t v25 = *(void *)(a1 + 312);
      if (v25) {
        sub_100EDF5C8(v25);
      }
    }
    if (v45 == *(_DWORD *)(a1 + 336))
    {
      uint64_t v26 = (uint64_t **)(a1 + 264);
      *(void *)buf = &v45;
      uint64_t v27 = sub_1000FEE0C(v26, &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      [(id)v27[5][2] register:v27[5][1] forNotification:20 registrationInfo:0];
      *(void *)buf = &v45;
      uint64_t v28 = sub_1000FEE0C(v26, &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      [(id)v28[5][2] register:v28[5][1] forNotification:21 registrationInfo:0];
    }
    *(void *)buf = &v45;
    *((unsigned char *)sub_100151D38(v9, &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 902) = 0;
    *(void *)buf = &v45;
    *((unsigned char *)sub_100151D38(v9, &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 903) = 1;
    uint64_t v29 = sub_10016BA10();
    *(_DWORD *)buf = 1;
    double v30 = sub_10016BA54(v29, buf);
    *(void *)buf = &v45;
    *((double *)sub_100151D38(v9, &v45, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 113) = v30;
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v15 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "LocationController,#Warning,startLocation when provider is None", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(_WORD *)__int16 v46 = 0;
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::startLocationProvider(LocationProvider)", "%s\n", v16);
      if (v16 != buf) {
        free(v16);
      }
    }
  }
}

uint64_t **sub_100151D38(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  double v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v12 = (uint64_t *)operator new(0x390uLL);
    v14[1] = v7;
    *((_DWORD *)v12 + 8) = **a4;
    sub_100682948((uint64_t)(v12 + 5));
    char v15 = 1;
    sub_1000EDF90(a1, (uint64_t)v9, v8, v12);
    v14[0] = 0;
    sub_1006829F0((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

float sub_100151E24(uint64_t a1)
{
  *(_DWORD *)buf = 0;
  int v2 = sub_1001072EC(a1, (int *)buf, 1);
  *(_DWORD *)buf = 1;
  int v3 = sub_1001072EC(a1, (int *)buf, 1);
  *(_DWORD *)buf = 2;
  int v4 = sub_1001072EC(a1, (int *)buf, 1);
  float v5 = 1000.0;
  if (!v4) {
    float v5 = -1.0;
  }
  if (v3) {
    float v5 = 100.0;
  }
  if (v2) {
    float v6 = 1.0;
  }
  else {
    float v6 = v5;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  double v7 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67240960;
    BOOL v11 = v2 != 0;
    __int16 v12 = 1026;
    BOOL v13 = v3 != 0;
    __int16 v14 = 1026;
    BOOL v15 = v4 != 0;
    __int16 v16 = 2050;
    double v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "CLIENT:hasClients,%{public}d,hasFineClients,%{public}d,hasCoarseClients,%{public}d,desiredAccuracy,%{public}.1lf", buf, 0x1Eu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "float CLLocationController::getDesiredAccuracy()", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return v6;
}

BOOL sub_1001520D8(uint64_t a1)
{
  __chkstk_darwin(a1);
  uint64_t v2 = v1;
  int v4 = v3;
  uint64_t v6 = v5;
  if (!sub_100158B1C(v5, *(_DWORD *)(v1 + 96))) {
    return 0;
  }
  char v230 = 0;
  sub_1000EF97C((uint64_t)v208, v2);
  if (*(unsigned char *)(v6 + 671)
    || *(unsigned char *)(v6 + 672)
    || !(*(unsigned int (**)(void, _OWORD *))(**(void **)(v6 + 288) + 440))(*(void *)(v6 + 288), v208))
  {
    int v11 = 1;
    goto LABEL_14;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  double v7 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    int v8 = *(_DWORD *)(v2 + 96);
    uint64_t v9 = *(void *)(v2 + 4);
    uint64_t v10 = *(void *)(v2 + 12);
    *(_DWORD *)buf = 67240705;
    *(_DWORD *)&uint8_t buf[4] = v8;
    *(_WORD *)&uint8_t buf[8] = 2049;
    *(void *)&buf[10] = v9;
    *(_WORD *)&buf[18] = 2049;
    *(void *)&buf[20] = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "location rejected by IM,locationType,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf", buf, 0x1Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    int v145 = *(_DWORD *)(v2 + 96);
    uint64_t v146 = *(void *)(v2 + 4);
    uint64_t v147 = *(void *)(v2 + 12);
    *(_DWORD *)v255 = 67240705;
    *(_DWORD *)&v255[4] = v145;
    *(_WORD *)&v255[8] = 2049;
    *(void *)&v255[10] = v146;
    *(_WORD *)&v255[18] = 2049;
    *(void *)&v255[20] = v147;
    v148 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v148);
    if (v148 != buf) {
      free(v148);
    }
  }
  if (*(unsigned char *)(v6 + 665))
  {
    int v11 = 0;
    goto LABEL_14;
  }
  int v11 = 0;
  BOOL v12 = 0;
  if (!*(unsigned char *)(v6 + 296))
  {
LABEL_14:
    sub_100155140(v6, (uint64_t)v208);
    if (v11) {
      sub_1001585B4(v6, (uint64_t)v208);
    }
    if (!*(unsigned char *)(v6 + 296))
    {
      LODWORD(v212[0]) = *(_DWORD *)(v2 + 128);
      *(void *)((char *)&v208[1] + 4) = *(void *)(v2 + 20);
    }
    uint64_t v13 = *(void *)(v6 + 304);
    if (v13)
    {
      uint64_t v14 = sub_10016BA10();
      *(_DWORD *)buf = 1;
      double v15 = sub_10016BA54(v14, buf);
      sub_1001549DC(v13, (uint64_t)v208, v15);
    }
    long long v207 = *(_OWORD *)((char *)v208 + 4);
    if ((*(unsigned int (**)(void, _OWORD *))(**(void **)(v6 + 288) + 376))(*(void *)(v6 + 288), v208))
    {
      (*(void (**)(void, uint64_t))(**(void **)(v6 + 288) + 400))(*(void *)(v6 + 288), v2);
      int v16 = (*(uint64_t (**)(void, _OWORD *, uint64_t *))(**(void **)(v6 + 288) + 368))(*(void *)(v6 + 288), v208, &v213);
      if (qword_102419650 != -1) {
        dispatch_once(&qword_102419650, &stru_1022C1840);
      }
      double v17 = qword_102419658;
      if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
      {
        int v186 = v16;
        uint64_t v18 = *(void *)((char *)v208 + 4);
        uint64_t v19 = *(void *)((char *)v208 + 12);
        uint64_t v20 = *(void *)((char *)&v208[1] + 4);
        int v21 = v210;
        uint64_t v22 = sub_10003E9A4(v210);
        *(_DWORD *)buf = 136319235;
        *(void *)&uint8_t buf[4] = "CL-trackrun";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v18;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v19;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v20;
        *(_WORD *)&buf[48] = 1026;
        *(_DWORD *)&buf[50] = v21;
        *(_WORD *)&buf[54] = 2082;
        *(void *)&buf[56] = v22;
        *(_WORD *)&buf[64] = 2050;
        *(void *)&buf[66] = *(void *)((char *)v209 + 12);
        *(_WORD *)&buf[74] = 2050;
        *(void *)&buf[76] = *(void *)((char *)&v209[1] + 12);
        *(_WORD *)&buf[84] = 1025;
        *(_DWORD *)&buf[86] = v214;
        *(_WORD *)&buf[90] = 1025;
        *(_DWORD *)&buf[92] = v215;
        *(_WORD *)&buf[96] = 1025;
        *(_DWORD *)&buf[98] = v218;
        *(_WORD *)&buf[102] = 1025;
        *(_DWORD *)&buf[104] = v217;
        *(_WORD *)&buf[108] = 1025;
        *(_DWORD *)&buf[110] = v219;
        *(_WORD *)&buf[114] = 1025;
        *(_DWORD *)&buf[116] = v220;
        *(_WORD *)&buf[120] = 2049;
        *(void *)&buf[122] = v221;
        *(_WORD *)&buf[130] = 2049;
        *(void *)&buf[132] = v216;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%{public}d,%{public}s,course,%{public}.1f,timestamp,%{public}.3f,lapCount,%{private}d,laneNumber,%{private}d,laneCount,%{private}d,estimatedLaneNumber,%{private}d,estimatedLaneConfidence,%{private}d,trackProximity,%{private}d,distanceToTrackMeters,%{private}.1lf,trackId,%{private}llu", buf, 0x8Cu);
        int v16 = v186;
      }
      if (sub_10013D1A0(117, 2))
      {
        bzero(buf, 0x65CuLL);
        int v187 = v16;
        if (qword_102419650 != -1) {
          dispatch_once(&qword_102419650, &stru_1022C1840);
        }
        uint64_t v23 = *(void *)((char *)v208 + 4);
        uint64_t v24 = *(void *)((char *)v208 + 12);
        uint64_t v25 = *(void *)((char *)&v208[1] + 4);
        int v26 = v210;
        uint64_t v27 = sub_10003E9A4(v210);
        *(_DWORD *)v255 = 136319235;
        *(void *)&v255[4] = "CL-trackrun";
        *(_WORD *)&v255[12] = 1024;
        *(_DWORD *)&v255[14] = 1;
        *(_WORD *)&v255[18] = 2048;
        *(void *)&v255[20] = v23;
        *(_WORD *)&v255[28] = 2048;
        *(void *)&v255[30] = v24;
        *(_WORD *)&v255[38] = 2048;
        *(void *)&v255[40] = v25;
        *(_WORD *)&v255[48] = 1026;
        *(_DWORD *)&v255[50] = v26;
        *(_WORD *)&v255[54] = 2082;
        *(void *)&v255[56] = v27;
        *(_WORD *)&v255[64] = 2050;
        *(void *)&v255[66] = *(void *)((char *)v209 + 12);
        *(_WORD *)&v255[74] = 2050;
        *(void *)&v255[76] = *(void *)((char *)&v209[1] + 12);
        *(_WORD *)&v255[84] = 1025;
        *(_DWORD *)&v255[86] = v214;
        *(_WORD *)&v255[90] = 1025;
        *(_DWORD *)&v255[92] = v215;
        *(_WORD *)v256 = 1025;
        *(_DWORD *)&v256[2] = v218;
        *(_WORD *)&v256[6] = 1025;
        *(_DWORD *)&v256[8] = v217;
        *(_WORD *)&v256[12] = 1025;
        *(_DWORD *)&v256[14] = v219;
        *(_WORD *)&v256[18] = 1025;
        *(_DWORD *)&v256[20] = v220;
        *(_WORD *)&v256[24] = 2049;
        *(void *)&v256[26] = v221;
        *(_WORD *)&v256[34] = 2049;
        *(void *)&v256[36] = v216;
        uint64_t v28 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("LOCATION", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v28);
        int v16 = v187;
        if (v28 != buf) {
          free(v28);
        }
      }
    }
    else
    {
      int v16 = 0;
    }
    sub_100158CF0((int *)v6, (uint64_t)v208);
    uint64_t v29 = sub_10016BA10();
    *(_DWORD *)buf = 0;
    double v30 = sub_10016BA54(v29, buf);
    int v31 = sub_1001596CC(v6, v4, (uint64_t)v208, v30);
    char v230 = v31;
    *(_DWORD *)v203 = 0xFFFF;
    *(_OWORD *)&v203[4] = 0uLL;
    *(_OWORD *)&v203[20] = xmmword_101D1C320;
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)&v203[36] = _Q0;
    *(_OWORD *)&v203[52] = _Q0;
    long long v188 = _Q0;
    *(_OWORD *)&v203[68] = _Q0;
    *(_DWORD *)&v203[84] = 0;
    long long v204 = 0uLL;
    *(void *)&v203[88] = 0xBFF0000000000000;
    *(void *)((char *)&v205 + 4) = 0xBFF0000000000000;
    LODWORD(v205) = 0;
    HIDWORD(v205) = 0x7FFFFFFF;
    memset(v206, 0, 25);
    if (v4 == 7)
    {
      int v38 = *(unsigned char *)(v6 + 673) ? 0 : v31;
      if (v38 == 1)
      {
        long long v204 = v210;
        long long v205 = v211;
        *(_OWORD *)v206 = v212[0];
        *(_OWORD *)&v206[12] = *(_OWORD *)((char *)v212 + 12);
        *(_OWORD *)&v203[32] = v208[2];
        *(_OWORD *)&v203[48] = v209[0];
        *(_OWORD *)&v203[64] = v209[1];
        *(_OWORD *)&v203[80] = v209[2];
        int v39 = 1;
        *(_OWORD *)v203 = v208[0];
        *(_OWORD *)&v203[16] = v208[1];
        goto LABEL_46;
      }
    }
    if (*(unsigned char *)(v6 + 296)) {
      int v40 = v31;
    }
    else {
      int v40 = 0;
    }
    if (v40 == 1)
    {
      int v41 = sub_10067B7E4(v6, (uint64_t)v203, (uint64_t)v208, v32, &v230);
    }
    else
    {
      if (*(unsigned char *)(v6 + 296))
      {
        int v39 = 0;
        goto LABEL_46;
      }
      int v41 = sub_100157490(v6, (uint64_t)v203, (uint64_t)v208, &v230);
    }
    int v39 = v41;
LABEL_46:
    __int16 v42 = *(void **)(v6 + 1608);
    if (v42)
    {
      if ([v42 feedLocation:v2])
      {
        double v43 = -1.0;
        if (*(void *)(v6 + 1608))
        {
          unsigned int v44 = +[CLLocationDerivedSpeedEstimator isSupportedForDerivedSpeedEstimate];
          double v45 = -1.0;
          double v46 = -1.0;
          if (v44)
          {
            [*(id *)(v6 + 1608) currentEstimate];
            double v43 = v47;
          }
        }
        else
        {
          double v45 = -1.0;
          double v46 = -1.0;
        }
        unint64_t v226 = *(void *)&v43;
        *(double *)&long long v227 = v45;
        *((double *)&v227 + 1) = v46;
        if (v230) {
          goto LABEL_57;
        }
        if (!*(unsigned char *)(v6 + 665))
        {
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          v101 = qword_102419388;
          if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning not notifying location with location derived speed", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419380 != -1) {
              dispatch_once(&qword_102419380, &stru_1022C17A0);
            }
            *(_WORD *)v255 = 0;
            v102 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v102);
            if (v102 != buf) {
              free(v102);
            }
          }
        }
      }
      else
      {
        unint64_t v226 = 0xBFF0000000000000;
        long long v227 = v188;
      }
    }
    if (!v230 && !*(unsigned char *)(v6 + 665))
    {
LABEL_160:
      sub_10015907C(v6);
      if (v230) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = *(unsigned char *)(v6 + 665) != 0;
      }
      goto LABEL_163;
    }
LABEL_57:
    sub_1000EF97C((uint64_t)v255, (uint64_t)v208);
    if (*(unsigned char *)(v6 + 666)) {
      int v48 = v39;
    }
    else {
      int v48 = 0;
    }
    if (v48 == 1)
    {
      if (*(double *)&v203[20] <= 0.0)
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        __int16 v49 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "Notifying using location KF,but no location available", buf, 2u);
        }
        if (sub_10013D1A0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          *(_WORD *)v231 = 0;
          v144 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v144);
          if (v144 != buf) {
            free(v144);
          }
        }
      }
      else
      {
        *(_OWORD *)v256 = v204;
        *(_OWORD *)&v256[16] = v205;
        *(_OWORD *)&v256[32] = *(_OWORD *)v206;
        *(_OWORD *)&v256[44] = *(_OWORD *)&v206[12];
        *(_OWORD *)&v255[32] = *(_OWORD *)&v203[32];
        *(_OWORD *)&v255[48] = *(_OWORD *)&v203[48];
        *(_OWORD *)&v255[64] = *(_OWORD *)&v203[64];
        *(_OWORD *)&v255[80] = *(_OWORD *)&v203[80];
        *(_OWORD *)v255 = *(_OWORD *)v203;
        *(_OWORD *)&v255[16] = *(_OWORD *)&v203[16];
      }
    }
    if (*(double *)(v6 + 224) >= 0.0) {
      *(void *)&v255[20] = *(void *)(v6 + 224);
    }
    if (v16) {
      long long v50 = v207;
    }
    else {
      long long v50 = *(_OWORD *)&v255[4];
    }
    *(_OWORD *)&v256[4] = v50;
    *(_DWORD *)&v256[40] = *(_DWORD *)&v256[36];
    *(void *)&v256[20] = *(void *)&v255[60];
    *(_DWORD *)&v256[44] = (*(uint64_t (**)(void))(**(void **)(v6 + 288) + 328))(*(void *)(v6 + 288));
    uint64_t v264 = *(void *)&v255[20];
    uint64_t v265 = *(void *)&v255[28];
    uint64_t v266 = *(void *)&v255[36];
    uint64_t v267 = *(void *)&v255[68];
    __int16 v268 = 0;
    long long v269 = *(_OWORD *)&v255[4];
    uint64_t v270 = *(void *)&v255[20];
    int v271 = *(_DWORD *)&v256[36];
    uint64_t v272 = *(void *)&v255[28];
    uint64_t v273 = *(void *)&v255[36];
    uint64_t v274 = *(void *)&v255[60];
    uint64_t v275 = *(void *)&v255[68];
    if ((*(unsigned int (**)(void))(**(void **)(v6 + 288) + 336))())
    {
      (*(void (**)(void, unsigned char *, unsigned char *))(**(void **)(v6 + 288) + 344))(*(void *)(v6 + 288), v255, v257);
      char v184 = (*(uint64_t (**)(void, unsigned char *, unsigned char *))(**(void **)(v6 + 288) + 360))(*(void *)(v6 + 288), v255, v257);
      if (qword_102419650 != -1) {
        dispatch_once(&qword_102419650, &stru_1022C1840);
      }
      uint64_t v51 = qword_102419658;
      if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v169 = *(void *)&v255[4];
        uint64_t v177 = *(void *)&v255[12];
        uint64_t v181 = *(void *)&v255[20];
        int v52 = *(_DWORD *)v256;
        v173 = sub_10003E9A4(*(unsigned int *)v256);
        uint64_t v151 = *(void *)&v255[44];
        uint64_t v153 = *(void *)&v255[60];
        int v157 = *(_DWORD *)&v255[84];
        uint64_t v161 = *(void *)&v255[88];
        uint64_t v165 = *(void *)&v255[76];
        uint64_t v53 = sub_10016BA10();
        *(_DWORD *)v231 = 0;
        double v54 = sub_10016BA54(v53, v231);
        double v55 = *(double *)&v255[76];
        uint64_t v56 = *(void *)&v255[28];
        uint64_t v57 = *(void *)&v255[36];
        uint64_t v58 = *(void *)&v255[52];
        uint64_t v59 = *(void *)&v255[68];
        uint64_t v60 = v258;
        int v61 = *(_DWORD *)&v256[32];
        int v149 = v268;
        uint64_t v62 = sub_10016BA10();
        double v63 = sub_10018202C(v62);
        *(_DWORD *)buf = 136321026;
        *(void *)&uint8_t buf[4] = "CL-viofused";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v169;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v177;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v181;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = v52;
        *(_WORD *)&buf[54] = 2080;
        *(void *)&buf[56] = v173;
        *(_WORD *)&buf[64] = 2048;
        *(void *)&buf[66] = v151;
        *(_WORD *)&buf[74] = 2048;
        *(void *)&buf[76] = v153;
        *(_WORD *)&buf[84] = 1024;
        *(_DWORD *)&buf[86] = v157;
        *(_WORD *)&buf[90] = 2048;
        *(void *)&buf[92] = v161;
        *(_WORD *)&buf[100] = 2048;
        *(void *)&buf[102] = v165;
        *(_WORD *)&buf[110] = 2048;
        *(double *)&buf[112] = v54 - v55;
        *(_WORD *)&buf[120] = 2048;
        *(void *)&buf[122] = v56;
        *(_WORD *)&buf[130] = 2048;
        *(void *)&buf[132] = v57;
        *(_WORD *)&buf[140] = 2048;
        *(void *)&buf[142] = v58;
        *(_WORD *)&buf[150] = 2048;
        *(void *)&buf[152] = v59;
        __int16 v283 = 2048;
        uint64_t v284 = v60;
        __int16 v285 = 1024;
        int v286 = v61;
        __int16 v287 = 1024;
        *(_DWORD *)v288 = v184 & 1;
        *(_WORD *)&v288[4] = 1024;
        *(_DWORD *)&v288[6] = v184 & 4;
        __int16 v289 = 1024;
        int v290 = v184 & 2;
        __int16 v291 = 1024;
        int v292 = v149;
        __int16 v293 = 2048;
        double v294 = v63;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d,isLocationFused,%d,isLocationPropagated,%d,isCourseFused,%d,isCoordinateFused,%d,propagation_us,%.3f", buf, 0xD2u);
      }
      if (sub_10013D1A0(117, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419650 != -1) {
          dispatch_once(&qword_102419650, &stru_1022C1840);
        }
        uint64_t v171 = *(void *)&v255[4];
        uint64_t v175 = *(void *)&v255[12];
        uint64_t v179 = *(void *)&v255[20];
        int v104 = *(_DWORD *)v256;
        v105 = sub_10003E9A4(*(unsigned int *)v256);
        uint64_t v106 = *(void *)&v255[44];
        uint64_t v107 = *(void *)&v255[60];
        int v159 = *(_DWORD *)&v255[84];
        uint64_t v163 = *(void *)&v255[88];
        uint64_t v167 = *(void *)&v255[76];
        double v108 = sub_1005BFA38();
        double v109 = *(double *)&v255[76];
        uint64_t v110 = *(void *)&v255[28];
        uint64_t v111 = *(void *)&v255[36];
        uint64_t v112 = *(void *)&v255[52];
        uint64_t v113 = *(void *)&v255[68];
        uint64_t v150 = v258;
        int v152 = *(_DWORD *)&v256[32];
        int v155 = v268;
        uint64_t v114 = sub_10016BA10();
        double v115 = sub_10018202C(v114);
        *(_DWORD *)v231 = 136321026;
        *(void *)&v231[4] = "CL-viofused";
        __int16 v232 = 1024;
        *(_DWORD *)v233 = 1;
        *(_WORD *)&v233[4] = 2048;
        *(void *)&v233[6] = v171;
        *(_WORD *)&v233[14] = 2048;
        *(void *)&v233[16] = v175;
        *(_WORD *)&v233[24] = 2048;
        *(void *)&v233[26] = v179;
        *(_WORD *)&v233[34] = 1024;
        *(_DWORD *)&v233[36] = v104;
        *(_WORD *)&v233[40] = 2080;
        *(void *)&v233[42] = v105;
        *(_WORD *)&v233[50] = 2048;
        *(void *)&v233[52] = v106;
        *(_WORD *)&v233[60] = 2048;
        *(void *)&v233[62] = v107;
        *(_WORD *)&v233[70] = 1024;
        *(_DWORD *)&v233[72] = v159;
        *(_WORD *)v234 = 2048;
        *(void *)&v234[2] = v163;
        *(_WORD *)v235 = 2048;
        *(void *)&v235[2] = v167;
        *(_WORD *)v236 = 2048;
        *(double *)&v236[2] = v108 - v109;
        *(_WORD *)&v236[10] = 2048;
        *(void *)&v236[12] = v110;
        __int16 v237 = 2048;
        uint64_t v238 = v111;
        __int16 v239 = 2048;
        uint64_t v240 = v112;
        __int16 v241 = 2048;
        uint64_t v242 = v113;
        __int16 v243 = 2048;
        uint64_t v244 = v150;
        __int16 v245 = 1024;
        int v246 = v152;
        __int16 v247 = 1024;
        *(_DWORD *)v248 = v184 & 1;
        *(_WORD *)&v248[4] = 1024;
        *(_DWORD *)&v248[6] = v184 & 4;
        __int16 v249 = 1024;
        int v250 = v184 & 2;
        __int16 v251 = 1024;
        int v252 = v155;
        __int16 v253 = 2048;
        double v254 = v115;
        v116 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("LOCATION", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v116);
        if (v116 != buf) {
          free(v116);
        }
      }
    }
    if (*(unsigned char *)(v6 + 667)
      && (*(unsigned char *)(v6 + 668) || *(unsigned char *)(v6 + 669))
      && (*(unsigned int (**)(void, unsigned char *, unsigned char *))(**(void **)(v6 + 288) + 192))(*(void *)(v6 + 288), v255, v257))
    {
      if (qword_102419650 != -1) {
        dispatch_once(&qword_102419650, &stru_1022C1840);
      }
      __int16 v64 = qword_102419658;
      if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v174 = *(void *)&v255[4];
        uint64_t v182 = *(void *)&v255[12];
        uint64_t v185 = *(void *)&v255[20];
        int v65 = *(_DWORD *)v256;
        v178 = sub_10003E9A4(*(unsigned int *)v256);
        uint64_t v154 = *(void *)&v255[44];
        uint64_t v158 = *(void *)&v255[60];
        int v162 = *(_DWORD *)&v255[84];
        uint64_t v166 = *(void *)&v255[88];
        uint64_t v170 = *(void *)&v255[76];
        uint64_t v66 = sub_10016BA10();
        *(_DWORD *)v231 = 0;
        double v67 = sub_10016BA54(v66, v231);
        double v68 = *(double *)&v255[76];
        uint64_t v69 = *(void *)&v255[28];
        uint64_t v70 = *(void *)&v255[36];
        uint64_t v71 = *(void *)&v255[52];
        uint64_t v72 = *(void *)&v255[68];
        uint64_t v73 = v258;
        int v74 = *(_DWORD *)&v256[32];
        uint64_t v75 = sub_10016BA10();
        double v76 = sub_10018202C(v75);
        *(_DWORD *)buf = 136320002;
        *(void *)&uint8_t buf[4] = "CL-mapmatched";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v174;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v182;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v185;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = v65;
        *(_WORD *)&buf[54] = 2080;
        *(void *)&buf[56] = v178;
        *(_WORD *)&buf[64] = 2048;
        *(void *)&buf[66] = v154;
        *(_WORD *)&buf[74] = 2048;
        *(void *)&buf[76] = v158;
        *(_WORD *)&buf[84] = 1024;
        *(_DWORD *)&buf[86] = v162;
        *(_WORD *)&buf[90] = 2048;
        *(void *)&buf[92] = v166;
        *(_WORD *)&buf[100] = 2048;
        *(void *)&buf[102] = v170;
        *(_WORD *)&buf[110] = 2048;
        *(double *)&buf[112] = v67 - v68;
        *(_WORD *)&buf[120] = 2048;
        *(void *)&buf[122] = v69;
        *(_WORD *)&buf[130] = 2048;
        *(void *)&buf[132] = v70;
        *(_WORD *)&buf[140] = 2048;
        *(void *)&buf[142] = v71;
        *(_WORD *)&buf[150] = 2048;
        *(void *)&buf[152] = v72;
        __int16 v283 = 2048;
        uint64_t v284 = v73;
        __int16 v285 = 1024;
        int v286 = v74;
        __int16 v287 = 2048;
        *(double *)v288 = v76;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d,propagation_us,%.3f", buf, 0xBAu);
      }
      if (sub_10013D1A0(117, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419650 != -1) {
          dispatch_once(&qword_102419650, &stru_1022C1840);
        }
        uint64_t v176 = *(void *)&v255[4];
        uint64_t v180 = *(void *)&v255[12];
        uint64_t v183 = *(void *)&v255[20];
        int v131 = *(_DWORD *)v256;
        v132 = sub_10003E9A4(*(unsigned int *)v256);
        uint64_t v133 = *(void *)&v255[44];
        uint64_t v134 = *(void *)&v255[60];
        int v164 = *(_DWORD *)&v255[84];
        uint64_t v168 = *(void *)&v255[88];
        uint64_t v172 = *(void *)&v255[76];
        double v135 = sub_1005BFA38();
        double v136 = *(double *)&v255[76];
        uint64_t v137 = *(void *)&v255[28];
        uint64_t v138 = *(void *)&v255[36];
        uint64_t v139 = *(void *)&v255[52];
        uint64_t v140 = *(void *)&v255[68];
        uint64_t v156 = v258;
        int v160 = *(_DWORD *)&v256[32];
        uint64_t v141 = sub_10016BA10();
        double v142 = sub_10018202C(v141);
        *(_DWORD *)v231 = 136320002;
        *(void *)&v231[4] = "CL-mapmatched";
        __int16 v232 = 1024;
        *(_DWORD *)v233 = 1;
        *(_WORD *)&v233[4] = 2048;
        *(void *)&v233[6] = v176;
        *(_WORD *)&v233[14] = 2048;
        *(void *)&v233[16] = v180;
        *(_WORD *)&v233[24] = 2048;
        *(void *)&v233[26] = v183;
        *(_WORD *)&v233[34] = 1024;
        *(_DWORD *)&v233[36] = v131;
        *(_WORD *)&v233[40] = 2080;
        *(void *)&v233[42] = v132;
        *(_WORD *)&v233[50] = 2048;
        *(void *)&v233[52] = v133;
        *(_WORD *)&v233[60] = 2048;
        *(void *)&v233[62] = v134;
        *(_WORD *)&v233[70] = 1024;
        *(_DWORD *)&v233[72] = v164;
        *(_WORD *)v234 = 2048;
        *(void *)&v234[2] = v168;
        *(_WORD *)v235 = 2048;
        *(void *)&v235[2] = v172;
        *(_WORD *)v236 = 2048;
        *(double *)&v236[2] = v135 - v136;
        *(_WORD *)&v236[10] = 2048;
        *(void *)&v236[12] = v137;
        __int16 v237 = 2048;
        uint64_t v238 = v138;
        __int16 v239 = 2048;
        uint64_t v240 = v139;
        __int16 v241 = 2048;
        uint64_t v242 = v140;
        __int16 v243 = 2048;
        uint64_t v244 = v156;
        __int16 v245 = 1024;
        int v246 = v160;
        __int16 v247 = 2048;
        *(double *)v248 = v142;
        v143 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("LOCATION", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v143);
        if (v143 != buf) {
          free(v143);
        }
      }
    }
    if ((*(unsigned int (**)(void))(**(void **)(v6 + 288) + 336))(*(void *)(v6 + 288))) {
      (*(void (**)(void, unsigned char *, unsigned char *))(**(void **)(v6 + 288) + 352))(*(void *)(v6 + 288), v255, v257);
    }
    if (*(_DWORD *)v256 <= 8u && ((1 << v256[0]) & 0x1D0) != 0)
    {
      *(_OWORD *)&v255[44] = v188;
      *(_OWORD *)&v255[60] = v188;
    }
    if (sub_1001A5368(v6, (uint64_t)v255, (uint64_t)v257))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      __int16 v77 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        uint64_t v78 = *(void *)&v255[4];
        uint64_t v79 = *(void *)&v255[12];
        uint64_t v80 = *(void *)&v255[20];
        int v81 = *(_DWORD *)v256;
        v82 = sub_10003E9A4(*(unsigned int *)v256);
        *(_DWORD *)buf = 134286083;
        *(void *)&uint8_t buf[4] = v78;
        *(_WORD *)&unsigned char buf[12] = 2049;
        *(void *)&buf[14] = v79;
        *(_WORD *)&buf[22] = 2050;
        *(void *)&unsigned char buf[24] = v80;
        *(_WORD *)&buf[32] = 1026;
        *(_DWORD *)&buf[34] = v81;
        *(_WORD *)&buf[38] = 2082;
        *(void *)&buf[40] = v82;
        *(_WORD *)&buf[48] = 2049;
        *(void *)&buf[50] = *(void *)&v255[28];
        *(_WORD *)&buf[58] = 2050;
        *(void *)&buf[60] = *(void *)&v255[36];
        *(_WORD *)&buf[68] = 2050;
        *(void *)&buf[70] = v262;
        *(_WORD *)&buf[78] = 2050;
        *(void *)&buf[80] = v263;
        *(_WORD *)&buf[88] = 2049;
        *(double *)&buf[90] = v260;
        *(_WORD *)&buf[98] = 1026;
        *(_DWORD *)&buf[100] = v259;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_INFO, "DEM,query,%{private}.7f,%{private}.7f,HorUnc,%{public}.2lf,Type,%{public}d,%{public}s,Alt,%{private}.2f,AltUnc,%{public}.2f,GroundAlt,%{public}.2lf,GroundAltUnc,%{public}.2lf,Undulation,%{private}.3lf,UndulationModel,%{public}d,", buf, 0x68u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        uint64_t v117 = *(void *)&v255[4];
        uint64_t v118 = *(void *)&v255[12];
        uint64_t v119 = *(void *)&v255[20];
        int v120 = *(_DWORD *)v256;
        v121 = sub_10003E9A4(*(unsigned int *)v256);
        *(_DWORD *)v231 = 134286083;
        *(void *)&v231[4] = v117;
        __int16 v232 = 2049;
        *(void *)v233 = v118;
        *(_WORD *)&v233[8] = 2050;
        *(void *)&v233[10] = v119;
        *(_WORD *)&v233[18] = 1026;
        *(_DWORD *)&v233[20] = v120;
        *(_WORD *)&v233[24] = 2082;
        *(void *)&v233[26] = v121;
        *(_WORD *)&v233[34] = 2049;
        *(void *)&v233[36] = *(void *)&v255[28];
        *(_WORD *)&v233[44] = 2050;
        *(void *)&v233[46] = *(void *)&v255[36];
        *(_WORD *)&v233[54] = 2050;
        *(void *)&v233[56] = v262;
        *(_WORD *)&v233[64] = 2050;
        *(void *)&v233[66] = v263;
        *(_WORD *)&v233[74] = 2049;
        *(double *)v234 = v260;
        *(_WORD *)&v234[8] = 1026;
        *(_DWORD *)v235 = v259;
        v122 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v122);
        if (v122 != buf) {
          free(v122);
        }
      }
    }
    if ((*(unsigned int (**)(void, unsigned char *, unsigned char *))(**(void **)(v6 + 288) + 224))(*(void *)(v6 + 288), v255, v257))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      v83 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        uint64_t v84 = *(void *)&v255[4];
        uint64_t v85 = *(void *)&v255[12];
        uint64_t v86 = *(void *)&v255[20];
        int v87 = *(_DWORD *)v256;
        v88 = sub_10003E9A4(*(unsigned int *)v256);
        *(_DWORD *)buf = 134285571;
        *(void *)&uint8_t buf[4] = v84;
        *(_WORD *)&unsigned char buf[12] = 2049;
        *(void *)&buf[14] = v85;
        *(_WORD *)&buf[22] = 2050;
        *(void *)&unsigned char buf[24] = v86;
        *(_WORD *)&buf[32] = 1026;
        *(_DWORD *)&buf[34] = v87;
        *(_WORD *)&buf[38] = 2082;
        *(void *)&buf[40] = v88;
        *(_WORD *)&buf[48] = 2049;
        *(void *)&buf[50] = *(void *)&v255[28];
        *(_WORD *)&buf[58] = 2050;
        *(void *)&buf[60] = *(void *)&v255[36];
        *(_WORD *)&buf[68] = 2050;
        *(double *)&buf[70] = v260;
        *(_WORD *)&buf[78] = 1026;
        *(_DWORD *)&buf[80] = v259;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_INFO, "BaroAlt,%{private}.7f,%{private}.7f,HorUnc,%{public}.2lf,Type,%{public}d,%{public}s,Alt,%{private}.2f,AltUnc,%{public}.2f,undulation,%{public}.3f,undulationModel,%{public}d", buf, 0x54u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        uint64_t v123 = *(void *)&v255[4];
        uint64_t v124 = *(void *)&v255[12];
        uint64_t v125 = *(void *)&v255[20];
        int v126 = *(_DWORD *)v256;
        v127 = sub_10003E9A4(*(unsigned int *)v256);
        *(_DWORD *)v231 = 134285571;
        *(void *)&v231[4] = v123;
        __int16 v232 = 2049;
        *(void *)v233 = v124;
        *(_WORD *)&v233[8] = 2050;
        *(void *)&v233[10] = v125;
        *(_WORD *)&v233[18] = 1026;
        *(_DWORD *)&v233[20] = v126;
        *(_WORD *)&v233[24] = 2082;
        *(void *)&v233[26] = v127;
        *(_WORD *)&v233[34] = 2049;
        *(void *)&v233[36] = *(void *)&v255[28];
        *(_WORD *)&v233[44] = 2050;
        *(void *)&v233[46] = *(void *)&v255[36];
        *(_WORD *)&v233[54] = 2050;
        *(double *)&v233[56] = v260;
        *(_WORD *)&v233[64] = 1026;
        *(_DWORD *)&v233[66] = v259;
        v128 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v128);
        if (v128 != buf) {
          free(v128);
        }
      }
    }
    uint64_t v201 = 0;
    uint64_t v202 = 0;
    if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(v6 + 288) + 232))(*(void *)(v6 + 288), &v201))
    {
      id v89 = [[objc_msgSend(*(id *)(v6 + 32), "vendor") proxyForService:@"CLGnssProvider"];
      if (v89) {
        [v89 setBarometricAltitudeAWDData:v201, v202];
      }
    }
    *(void *)&v256[48] = 0;
    if ((v259 - 1) <= 1) {
      *(double *)&v256[48] = *(double *)&v255[28] + v260;
    }
    double v90 = *(double *)&v255[20];
    if (*(double *)&v255[20] >= 0.0 && *(double *)&v255[20] != *(double *)(v6 + 224))
    {
      if (*(double *)&v255[20] < 1.0) {
        double v90 = 1.0;
      }
      *(double *)&v255[20] = v90;
    }
    double v91 = *(double *)&v255[36];
    if (*(double *)&v255[36] >= 0.0)
    {
      if (*(double *)&v255[36] < 3.0) {
        double v91 = 3.0;
      }
      *(double *)&v255[36] = v91;
    }
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_1022C1820);
    }
    v92 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134286593;
      *(void *)&uint8_t buf[4] = *(void *)&v255[4];
      *(_WORD *)&unsigned char buf[12] = 2049;
      *(void *)&buf[14] = *(void *)&v255[12];
      *(_WORD *)&buf[22] = 2050;
      *(void *)&unsigned char buf[24] = *(void *)&v255[20];
      *(_WORD *)&buf[32] = 2049;
      *(void *)&buf[34] = *(void *)&v255[44];
      *(_WORD *)&buf[42] = 2049;
      *(void *)&buf[44] = *(void *)&v255[60];
      *(_WORD *)&buf[52] = 1026;
      *(_DWORD *)&buf[54] = *(_DWORD *)v256;
      *(_WORD *)&buf[58] = 2049;
      *(void *)&buf[60] = *(void *)&v255[28];
      *(_WORD *)&buf[68] = 2050;
      *(void *)&buf[70] = *(void *)&v255[36];
      *(_WORD *)&buf[78] = 2049;
      *(void *)&buf[80] = *(void *)&v256[48];
      *(_WORD *)&buf[88] = 2050;
      *(void *)&buf[90] = *(void *)&v255[52];
      *(_WORD *)&buf[98] = 2050;
      *(void *)&buf[100] = *(void *)&v255[68];
      *(_WORD *)&buf[108] = 1025;
      *(_DWORD *)&buf[110] = *(_DWORD *)&v256[44];
      *(_WORD *)&buf[114] = 2050;
      *(void *)&buf[116] = *(void *)&v255[76];
      _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "@ClxClient, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f, ellipsoidalAlt, %{private}.1f, speedUnc, %{public}.1f, courseUnc, %{public}.1f, signalEnv, %{private}d, timestamp, %{public}.3f", buf, 0x7Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022C1820);
      }
      *(_DWORD *)v231 = 134286593;
      *(void *)&v231[4] = *(void *)&v255[4];
      __int16 v232 = 2049;
      *(void *)v233 = *(void *)&v255[12];
      *(_WORD *)&v233[8] = 2050;
      *(void *)&v233[10] = *(void *)&v255[20];
      *(_WORD *)&v233[18] = 2049;
      *(void *)&v233[20] = *(void *)&v255[44];
      *(_WORD *)&v233[28] = 2049;
      *(void *)&v233[30] = *(void *)&v255[60];
      *(_WORD *)&v233[38] = 1026;
      *(_DWORD *)&v233[40] = *(_DWORD *)v256;
      *(_WORD *)&v233[44] = 2049;
      *(void *)&v233[46] = *(void *)&v255[28];
      *(_WORD *)&v233[54] = 2050;
      *(void *)&v233[56] = *(void *)&v255[36];
      *(_WORD *)&v233[64] = 2049;
      *(void *)&v233[66] = *(void *)&v256[48];
      *(_WORD *)&v233[74] = 2050;
      *(void *)v234 = *(void *)&v255[52];
      *(_WORD *)&v234[8] = 2050;
      *(void *)v235 = *(void *)&v255[68];
      *(_WORD *)&v235[8] = 1025;
      *(_DWORD *)v236 = *(_DWORD *)&v256[44];
      *(_WORD *)&v236[4] = 2050;
      *(void *)&v236[6] = *(void *)&v255[76];
      v103 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v103);
      if (v103 != buf) {
        free(v103);
      }
    }
    if (sub_1000EF668(*(double *)&v255[4], *(double *)&v255[12]))
    {
      v95 = sub_10003E9A4(*(unsigned int *)v256);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022C1820);
      }
      v96 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136380931;
        *(void *)&uint8_t buf[4] = "client, null";
        *(_WORD *)&unsigned char buf[12] = 2081;
        *(void *)&buf[14] = v95;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEBUG, "ClxMetric, islands, %{private}s, %{private}s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        *(_DWORD *)v231 = 136380931;
        *(void *)&v231[4] = "client, null";
        __int16 v232 = 2081;
        *(void *)v233 = v95;
        v129 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v129);
        if (v129 != buf) {
          free(v129);
        }
      }
      v196 = _NSConcreteStackBlock;
      uint64_t v197 = 3221225472;
      v198 = sub_10067BEE4;
      v199 = &unk_1022A6368;
      v200 = v95;
      AnalyticsSendEventLazy();
    }
    v94.n128_u64[0] = *(void *)&v255[4];
    v93.n128_u64[0] = -1.0;
    if (*(double *)&v255[4] == -1.0)
    {
      v94.n128_u64[0] = *(void *)&v255[12];
      if (*(double *)&v255[12] == -1.0)
      {
        v97 = sub_10003E9A4(*(unsigned int *)v256);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        v98 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136380931;
          *(void *)&uint8_t buf[4] = "client, sentinel";
          *(_WORD *)&unsigned char buf[12] = 2081;
          *(void *)&buf[14] = v97;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEBUG, "ClxMetric, islands, %{private}s, %{private}s", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022C1820);
          }
          *(_DWORD *)v231 = 136380931;
          *(void *)&v231[4] = "client, sentinel";
          __int16 v232 = 2081;
          *(void *)v233 = v97;
          v130 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::notifyLocation(LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v130);
          if (v130 != buf) {
            free(v130);
          }
        }
        v191 = _NSConcreteStackBlock;
        uint64_t v192 = 3221225472;
        v193 = sub_10067BF90;
        v194 = &unk_1022A6368;
        v195 = v97;
        AnalyticsSendEventLazy();
      }
    }
    *(_DWORD *)buf = 39;
    (*(void (**)(uint64_t, unsigned char *, unsigned char *, uint64_t, uint64_t, void, __n128, __n128))(*(void *)v6 + 152))(v6, buf, v255, 1, 0xFFFFFFFFLL, 0, v93, v94);
    if (_os_feature_enabled_impl())
    {
      sub_1001A2B30(v6 + 352, (uint64_t)v255, buf);
      *(_OWORD *)v256 = *(_OWORD *)&buf[96];
      *(_OWORD *)&v256[16] = *(_OWORD *)&buf[112];
      *(_OWORD *)&v256[32] = *(_OWORD *)&buf[128];
      *(_OWORD *)&v256[44] = *(_OWORD *)&buf[140];
      *(_OWORD *)&v255[32] = *(_OWORD *)&buf[32];
      *(_OWORD *)&v255[48] = *(_OWORD *)&buf[48];
      *(_OWORD *)&v255[64] = *(_OWORD *)&buf[64];
      *(_OWORD *)&v255[80] = *(_OWORD *)&buf[80];
      *(_OWORD *)v255 = *(_OWORD *)buf;
      *(_OWORD *)&v255[16] = *(_OWORD *)&buf[16];
    }
    *(_DWORD *)buf = 0;
    (*(void (**)(uint64_t, unsigned char *, unsigned char *, uint64_t, uint64_t, void))(*(void *)v6 + 152))(v6, buf, v255, 1, 0xFFFFFFFFLL, 0);
    *(void *)v231 = 0xBFF0000000000000;
    char v190 = 0;
    (*(void (**)(void, unsigned char *, char *, unsigned char *))(**(void **)(v6 + 288) + 288))(*(void *)(v6 + 288), v255, &v190, v231);
    if (v190)
    {
      sub_1000DB3D4((uint64_t)buf);
      uint64_t v297 = *(void *)v231;
      uint64_t v298 = *(void *)&v255[76];
      int v189 = 20;
      (*(void (**)(uint64_t, int *, unsigned char *, uint64_t, uint64_t, void))(*(void *)v6 + 152))(v6, &v189, buf, 1, 0xFFFFFFFFLL, 0);

      if (v301) {
        sub_1000DB0A0(v301);
      }
      if (v300 < 0) {
        operator delete(__p);
      }
      if (v296) {
        sub_1000DB0A0(v296);
      }
      if (v295) {
        sub_1000DB0A0(v295);
      }
    }
    uint64_t v99 = *(void *)(v6 + 312);
    if (v99) {
      sub_1001A95D8(v99, (uint64_t)v255, v261);
    }
    sub_1000428F0(v6 + 5200, (uint64_t)v255);

    if (v280) {
      sub_1000DB0A0(v280);
    }
    if (v279 < 0) {
      operator delete(v278);
    }
    if (v277) {
      sub_1000DB0A0(v277);
    }
    if (v276) {
      sub_1000DB0A0(v276);
    }
    goto LABEL_160;
  }
LABEL_163:

  if (v228) {
    sub_1000DB0A0(v228);
  }
  if (v225 < 0) {
    operator delete(v224);
  }
  if (v223) {
    sub_1000DB0A0(v223);
  }
  if (v222) {
    sub_1000DB0A0(v222);
  }
  return v12;
}

void sub_100154650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

BOOL sub_100154728(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 3576);
  return v1 && *(unsigned char *)(v1 + 128) != 0;
}

void sub_100154748(double *a1, double a2)
{
  if (sub_1000E6DB4((uint64_t)(a1 + 1)) && sub_1000E6DB4((uint64_t)(a1 + 22)))
  {
    double v4 = a1[42];
    if (*a1 > v4 || v4 + 2.0 < a2)
    {
      sub_100B3FCF8((uint64_t)a1);
    }
  }
}

void sub_1001547CC(uint64_t a1, uint64_t a2, double a3)
{
  if (*(double *)(a2 + 20) < 30.0)
  {
    uint64_t v6 = (_OWORD *)(a1 + 8);
    if (sub_1000E6DB4(a1 + 8) & 1) != 0 || (sub_1000E6DB4(a1 + 176))
    {
      if ((sub_1000E6DB4(a1 + 176) & 1) == 0)
      {
        double v7 = *(double *)(a2 + 76) - *(double *)(a1 + 84);
        if (v7 <= 110.0 || v7 > 300.0)
        {
          if (v7 > 300.0)
          {
            long long v22 = *(_OWORD *)(a2 + 16);
            *uint64_t v6 = *(_OWORD *)a2;
            *(_OWORD *)(a1 + 24) = v22;
            long long v23 = *(_OWORD *)(a2 + 32);
            long long v24 = *(_OWORD *)(a2 + 48);
            long long v25 = *(_OWORD *)(a2 + 80);
            *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
            *(_OWORD *)(a1 + 88) = v25;
            *(_OWORD *)(a1 + 40) = v23;
            *(_OWORD *)(a1 + 56) = v24;
            long long v26 = *(_OWORD *)(a2 + 96);
            long long v27 = *(_OWORD *)(a2 + 112);
            long long v28 = *(_OWORD *)(a2 + 128);
            long long v29 = *(_OWORD *)(a2 + 140);
            *(_DWORD *)(a1 + 176) = 0xFFFF;
            *(_OWORD *)(a1 + 148) = v29;
            *(_OWORD *)(a1 + 120) = v27;
            *(_OWORD *)(a1 + 136) = v28;
            *(_OWORD *)(a1 + 104) = v26;
            *(double *)(a1 + 168) = a3;
            *(void *)(a1 + 180) = 0;
            *(void *)(a1 + 188) = 0;
            *(_OWORD *)(a1 + 196) = xmmword_101D1C320;
            __asm { FMOV            V0.2D, #-1.0 }
            *(_OWORD *)(a1 + 212) = _Q0;
            *(_OWORD *)(a1 + 228) = _Q0;
            *(_OWORD *)(a1 + 244) = _Q0;
            *(_DWORD *)(a1 + 260) = 0;
            *(_DWORD *)(a1 + 288) = 0;
            *(void *)(a1 + 264) = 0xBFF0000000000000;
            *(void *)(a1 + 272) = 0;
            *(void *)(a1 + 280) = 0;
            *(void *)(a1 + 292) = 0xBFF0000000000000;
            *(_DWORD *)(a1 + 300) = 0x7FFFFFFF;
            *(unsigned char *)(a1 + 328) = 0;
            *(void *)(a1 + 312) = 0;
            *(void *)(a1 + 320) = 0;
            *(void *)(a1 + 304) = 0;
            *(_DWORD *)(a1 + 472) = 0;
            *(_OWORD *)(a1 + 440) = 0u;
            *(_OWORD *)(a1 + 456) = 0u;
            *(_OWORD *)(a1 + 424) = 0u;
            *(_OWORD *)(a1 + 408) = 0u;
            *(_OWORD *)(a1 + 392) = 0u;
            *(double *)(a1 + 368) = a3;
            *(double *)(a1 + 384) = a3;
            *(void *)(a1 + 344) = 0;
            *(void *)(a1 + 352) = 0;
          }
        }
        else
        {
          long long v8 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)(a1 + 176) = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 192) = v8;
          long long v9 = *(_OWORD *)(a2 + 32);
          long long v10 = *(_OWORD *)(a2 + 48);
          long long v11 = *(_OWORD *)(a2 + 80);
          *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 64);
          *(_OWORD *)(a1 + 256) = v11;
          *(_OWORD *)(a1 + 208) = v9;
          *(_OWORD *)(a1 + 224) = v10;
          long long v12 = *(_OWORD *)(a2 + 96);
          long long v13 = *(_OWORD *)(a2 + 112);
          long long v14 = *(_OWORD *)(a2 + 128);
          *(_OWORD *)(a1 + 316) = *(_OWORD *)(a2 + 140);
          *(_OWORD *)(a1 + 288) = v13;
          *(_OWORD *)(a1 + 304) = v14;
          *(_OWORD *)(a1 + 272) = v12;
          *(double *)(a1 + 336) = a3;
        }
      }
    }
    else
    {
      long long v15 = *(_OWORD *)(a2 + 16);
      *uint64_t v6 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 24) = v15;
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      long long v18 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 88) = v18;
      *(_OWORD *)(a1 + 40) = v16;
      *(_OWORD *)(a1 + 56) = v17;
      long long v19 = *(_OWORD *)(a2 + 96);
      long long v20 = *(_OWORD *)(a2 + 112);
      long long v21 = *(_OWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 148) = *(_OWORD *)(a2 + 140);
      *(_OWORD *)(a1 + 120) = v20;
      *(_OWORD *)(a1 + 136) = v21;
      *(_OWORD *)(a1 + 104) = v19;
      *(double *)(a1 + 168) = a3;
      *(_DWORD *)(a1 + 472) = 0;
      *(_OWORD *)(a1 + 440) = 0u;
      *(_OWORD *)(a1 + 456) = 0u;
      *(_OWORD *)(a1 + 408) = 0u;
      *(_OWORD *)(a1 + 424) = 0u;
      *(_OWORD *)(a1 + 392) = 0u;
      *(double *)(a1 + 368) = a3;
      *(double *)(a1 + 384) = a3;
      *(void *)(a1 + 344) = 0;
      *(void *)(a1 + 352) = 0;
    }
  }

  sub_100154748((double *)a1, a3);
}

void sub_1001549DC(uint64_t a1, uint64_t a2, double a3)
{
}

uint64_t sub_1001549E4()
{
  return 0;
}

uint64_t sub_1001549EC(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 3155))
  {
    if (!*(void *)(a1 + 3184)) {
      *(void *)(a1 + 3184) = objc_alloc_init(CLNanoRegistry);
    }
    sub_100103240();
    if (sub_10016CCBC()) {
      __int16 v4 = (unsigned __int16)[*(id *)(a1 + 3184) isAFire6OrOlderWatchPaired] ^ 1;
    }
    else {
      __int16 v4 = 0;
    }
    *(_WORD *)(a1 + 3154) = v4 | 0x100;
    (*(void (**)(uint64_t))(*(void *)a1 + 432))(a1);
    if (qword_102418FB0 != -1) {
      dispatch_once(&qword_102418FB0, &stru_1022CF428);
    }
    uint64_t v5 = qword_102418FB8;
    if (os_log_type_enabled((os_log_t)qword_102418FB8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 3155)) {
        BOOL v6 = *(unsigned char *)(a1 + 3154) != 0;
      }
      else {
        BOOL v6 = 1;
      }
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#cltr,fIsPhoneThatDoesNotNeedTrackRunProcessing,%{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FB0 != -1) {
        dispatch_once(&qword_102418FB0, &stru_1022CF428);
      }
      if (*(unsigned char *)(a1 + 3155)) {
        BOOL v23 = *(unsigned char *)(a1 + 3154) != 0;
      }
      else {
        BOOL v23 = 1;
      }
      int v31 = 67240192;
      LODWORD(v32) = v23;
      long long v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::isTrackRunControllerEnabled(const CLDaemonLocation &)", "%s\n", v24);
      if (v24 != buf) {
        free(v24);
      }
    }
  }
  if (*(unsigned char *)(a1 + 3217))
  {
LABEL_26:
    if (qword_102418FB0 != -1) {
      dispatch_once(&qword_102418FB0, &stru_1022CF428);
    }
    long long v10 = qword_102418FB8;
    if (os_log_type_enabled((os_log_t)qword_102418FB8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void *)(a1 + 3160);
      *(_DWORD *)buf = 134349056;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#cltr,Not querying for region support due to backoff timer in effect,current,%{public}.0f", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FB0 != -1) {
        dispatch_once(&qword_102418FB0, &stru_1022CF428);
      }
      uint64_t v21 = *(void *)(a1 + 3160);
      int v31 = 134349056;
      uint64_t v32 = v21;
      long long v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::isTrackRunControllerEnabled(const CLDaemonLocation &)", "%s\n", v22);
      if (v22 != buf) {
        free(v22);
      }
    }
    goto LABEL_31;
  }
  if (*(unsigned char *)(a1 + 3153)
    && (uint64_t v7 = sub_10016BA10(), *(_DWORD *)buf = 1, sub_10016BA54(v7, buf) - *(double *)(a1 + 3176) <= 86400.0)
    || (*(_DWORD *)(a2 + 96) - 6) < 3
    || ((v8 = *(double *)(a2 + 20), v8 > 0.0) ? (BOOL v9 = v8 < 100.0) : (BOOL v9 = 0), !v9 || *(unsigned char *)(a1 + 3216)))
  {
    if (!*(unsigned char *)(a1 + 3217)) {
      goto LABEL_31;
    }
    goto LABEL_26;
  }
  if (qword_102418FB0 != -1) {
    dispatch_once(&qword_102418FB0, &stru_1022CF428);
  }
  long long v13 = qword_102418FB8;
  if (os_log_type_enabled((os_log_t)qword_102418FB8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a2 + 4);
    uint64_t v15 = *(void *)(a2 + 12);
    uint64_t v16 = *(void *)(a2 + 20);
    *(_DWORD *)buf = 134284033;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2049;
    *(void *)&buf[14] = v15;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v38 = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#cltr,Querying for region support,ll,%{private}.7lf,%{private}.7lf,hunc,%.1lf", buf, 0x20u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FB0 != -1) {
      dispatch_once(&qword_102418FB0, &stru_1022CF428);
    }
    uint64_t v25 = *(void *)(a2 + 4);
    uint64_t v26 = *(void *)(a2 + 12);
    uint64_t v27 = *(void *)(a2 + 20);
    int v31 = 134284033;
    uint64_t v32 = v25;
    __int16 v33 = 2049;
    uint64_t v34 = v26;
    __int16 v35 = 2048;
    uint64_t v36 = v27;
    long long v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::isTrackRunControllerEnabled(const CLDaemonLocation &)", "%s\n", v28);
    if (v28 != buf) {
      free(v28);
    }
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000;
  uint64_t v38 = 0;
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472;
  v30[2] = sub_1008A7440;
  v30[3] = &unk_1022CF360;
  v30[4] = buf;
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_1008A7604;
  v29[3] = &unk_1022CF3B0;
  v29[4] = buf;
  v29[5] = a1;
  if (!*(void *)(a1 + 3168))
  {
    id v17 = objc_alloc_init((Class)GEOMapFeatureAccess);
    *(void *)(a1 + 3168) = v17;
    if (v17)
    {
      [v17 setAllowNetworkTileLoad:1];
      [*(id *)(a1 + 3168) setAllowStaleData:1];
      [*(id *)(a1 + 3168) setAllowOfflineData:1];
    }
  }
  double v18 = *(double *)(a2 + 4);
  double v19 = *(double *)(a2 + 12);
  *(unsigned char *)(a1 + 3216) = 1;
  uint64_t v20 = sub_10016BA10();
  int v31 = 1;
  *(double *)(a1 + 3176) = sub_10016BA54(v20, &v31);
  sub_100DEE0E4(a1 + 3232);
  [*(id *)(a1 + 3168) findRunningTrackFlagsNear:v30 radius:v29 handler:v18 completionHandler:v19];
  _Block_object_dispose(buf, 8);
LABEL_31:
  uint64_t result = *(void *)(a1 + 3200);
  if (result)
  {
    uint64_t result = sub_100155114(result);
    if (result) {
      return sub_101490138();
    }
  }
  return result;
}

void sub_1001550F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

BOOL sub_100155114(uint64_t a1)
{
  return *(unsigned char *)(a1 + 34) && *(void *)(a1 + 104) && *(void *)(a1 + 96) != a1 + 56;
}

void sub_100155140(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 96);
  if ((v4 & 0xFFFFFFFE) == 0xA)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    unint64_t v28 = 0;
  }
  else
  {
    if ((v4 & 0xFFFFFFF7) != 1 || *(unsigned char *)(a1 + 5080) == 0)
    {
      int v6 = 0;
      goto LABEL_25;
    }
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    float v7 = *(double *)(a2 + 36);
    LODWORD(v23) = 188;
    *(float *)long long v24 = v7;
    int v25 = 4;
    uint64_t v27 = (_DWORD *)sub_100682D34(&v26, &v23);
    sub_100118010((uint64_t)v24);
  }
  int v6 = sub_10067C108(a1);
  if (v6)
  {
    sub_10067C3A4(a1, (_DWORD *)(a1 + 320), a2);
    long long v29 = (_DWORD *)(a1 + 320);
    float v8 = *(double *)((char *)sub_100151D38((uint64_t **)(a1 + 240), (int *)(a1 + 320), (uint64_t)&unk_101D0B290, &v29)
                   + 132);
    LODWORD(v23) = 186;
    *(float *)long long v24 = v8;
    int v25 = 4;
    BOOL v9 = v27;
    if ((unint64_t)v27 >= v28)
    {
      long long v10 = (_DWORD *)sub_100682D34(&v26, &v23);
    }
    else
    {
      *uint64_t v27 = 186;
      long long v10 = v9 + 10;
      sub_10011885C((uint64_t)(v9 + 2), (uint64_t)v24);
    }
    uint64_t v27 = v10;
    sub_100118010((uint64_t)v24);
    long long v29 = (_DWORD *)(a1 + 320);
    int v13 = *((_DWORD *)sub_100151D38((uint64_t **)(a1 + 240), (int *)(a1 + 320), (uint64_t)&unk_101D0B290, &v29) + 48);
    LODWORD(v23) = 184;
    v24[0] = v13;
    int v25 = 0;
    long long v12 = v27;
    if ((unint64_t)v27 < v28) {
      goto LABEL_16;
    }
LABEL_17:
    uint64_t v14 = (_DWORD *)sub_100682D34(&v26, &v23);
    goto LABEL_18;
  }
  int v11 = *(_DWORD *)(a2 + 96);
  LODWORD(v23) = 184;
  v24[0] = v11;
  int v25 = 0;
  long long v12 = v27;
  if ((unint64_t)v27 >= v28) {
    goto LABEL_17;
  }
LABEL_16:
  *long long v12 = 184;
  uint64_t v14 = v12 + 10;
  sub_10011885C((uint64_t)(v12 + 2), (uint64_t)v24);
LABEL_18:
  uint64_t v27 = v14;
  sub_100118010((uint64_t)v24);
  float v15 = *(double *)(a2 + 36);
  LODWORD(v23) = 185;
  *(float *)long long v24 = v15;
  int v25 = 4;
  uint64_t v16 = v27;
  if ((unint64_t)v27 >= v28)
  {
    id v17 = (_DWORD *)sub_100682D34(&v26, &v23);
  }
  else
  {
    *uint64_t v27 = 185;
    id v17 = v16 + 10;
    sub_10011885C((uint64_t)(v16 + 2), (uint64_t)v24);
  }
  uint64_t v27 = v17;
  sub_100118010((uint64_t)v24);
  LODWORD(v29) = 0;
  BOOL v18 = sub_1001A0BB0((float64_t *)(a2 + 4), (double *)(a2 + 12), &v29);
  LODWORD(v23) = 189;
  v24[0] = v18;
  int v25 = 0;
  double v19 = v27;
  if ((unint64_t)v27 >= v28)
  {
    uint64_t v20 = (_DWORD *)sub_100682D34(&v26, &v23);
  }
  else
  {
    *uint64_t v27 = 189;
    uint64_t v20 = v19 + 10;
    sub_10011885C((uint64_t)(v19 + 2), (uint64_t)v24);
  }
  uint64_t v27 = v20;
  sub_100118010((uint64_t)v24);
  uint64_t v21 = *(void **)(a1 + 5096);
  memset(v22, 0, sizeof(v22));
  sub_100682C20(v22, v26, (uint64_t)v27, 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v27 - v26) >> 3));
  [v21 setMeasurements:sub_10067C03C(v22)];
  BOOL v23 = (void **)v22;
  sub_100682B1C(&v23);
  BOOL v23 = (void **)&v26;
  sub_100682B1C(&v23);
LABEL_25:
  sub_100155518(a1, a2, v6);
}

void sub_1001554A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_100118010(v18);
  a13 = (void **)&a18;
  sub_100682B1C(&a13);
  _Unwind_Resume(a1);
}

void sub_100155518(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 1960;
  unsigned int v6 = *(_DWORD *)(a2 + 96);
  BOOL v7 = (v6 & 0xFFFFFFF7) == 1 && *(unsigned char *)(a1 + 5080) != 0;
  BOOL v8 = v6 == 4 || v6 == 11;
  if (!v8 && !v7 && (v6 > 0xA || ((1 << v6) & 0x5C0) == 0)) {
    return;
  }
  *(void *)(a1 + 1944) = 0xBFF0000000000000;
  *(void *)(a1 + 1960) = 0;
  *(void *)(a1 + 1952) = 0;
  *(void *)(a1 + 1968) = 0xBFF0000000000000;
  *(void *)(a1 + 1984) = 0;
  *(void *)(a1 + 1976) = 0;
  *(void *)(a1 + 1992) = 0xBFF0000000000000;
  uint64_t v9 = sub_10016BA10();
  *(_DWORD *)buf = 1;
  *(double *)(a1 + 1944) = sub_10016BA54(v9, buf);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)(a2 + 28);
  uint64_t v57 = 0;
  *(void *)uint64_t v58 = 0;
  *(_OWORD *)&v58[8] = xmmword_101D1C320;
  int v59 = -1;
  __int16 v60 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  uint64_t v63 = 0;
  *(unsigned char *)(a1 + 1936) = 0;
  if (!(*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 288) + 240))(*(void *)(a1 + 288), &v57))return; {
  double v10 = *(double *)(a2 + 36);
  }
  if (v10 <= 0.0 || (!v7 | a3) != 1 || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    double v11 = *(double *)&v58[8];
    BOOL v13 = *(double *)&v58[8] > 0.0 && (*(void *)&v58[8] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    double v14 = 20.0;
LABEL_24:
    if (v11 >= v14) {
      BOOL v13 = 0;
    }
    BOOL v53 = v13;
    goto LABEL_27;
  }
  if (v10 >= *((double *)sub_1000DBFA0() + 44))
  {
    double v11 = *(double *)&v58[8];
    BOOL v13 = *(double *)&v58[8] > 0.0 && (*(void *)&v58[8] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    if (*(double *)&v58[8] >= 20.0) {
      BOOL v13 = 0;
    }
    double v14 = *(double *)(a2 + 36);
    goto LABEL_24;
  }
  BOOL v53 = 0;
LABEL_27:
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  float v15 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v16 = *(_DWORD *)(a2 + 96);
    uint64_t v17 = *(void *)(a2 + 504);
    uint64_t v18 = *(void *)(a2 + 28);
    uint64_t v19 = *(void *)(a2 + 36);
    float v20 = *(float *)(a2 + 476);
    int v21 = *(_DWORD *)(a2 + 472);
    uint64_t v22 = v57;
    long long v43 = *(_OWORD *)v58;
    uint64_t v44 = *(void *)&v58[16];
    int v46 = v59;
    int v48 = *(unsigned __int8 *)(v5 + 3120);
    uint64_t v50 = *(void *)(a2 + 704);
    uint64_t v52 = *(void *)(a2 + 712);
    uint64_t v23 = sub_10016BA10();
    double v24 = sub_10018202C(v23);
    *(_DWORD *)buf = 67244289;
    *(_DWORD *)&uint8_t buf[4] = v53;
    *(_WORD *)v98 = 1026;
    *(_DWORD *)&v98[2] = v16;
    __int16 v99 = 2050;
    uint64_t v100 = v17;
    __int16 v101 = 2049;
    *(void *)v102 = v18;
    *(_WORD *)&v102[8] = 2050;
    uint64_t v103 = v19;
    __int16 v104 = 2050;
    double v105 = v20;
    __int16 v106 = 1026;
    int v107 = v21;
    __int16 v108 = 2050;
    uint64_t v109 = v22;
    __int16 v110 = 2049;
    uint64_t v111 = v43;
    *(_WORD *)uint64_t v112 = 2050;
    *(void *)&v112[2] = *((void *)&v43 + 1);
    *(_WORD *)&v112[10] = 2050;
    uint64_t v113 = v44;
    __int16 v114 = 1026;
    int v115 = v46;
    __int16 v116 = 1026;
    int v117 = v48;
    *(_WORD *)uint64_t v118 = 2049;
    *(void *)&v118[2] = v50;
    *(_WORD *)&v118[10] = 2050;
    uint64_t v119 = v52;
    __int16 v120 = 1026;
    int v121 = a3;
    __int16 v122 = 2050;
    double v123 = v24;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "BaroAlt,updateAltIfApprprt,success,%{public}d,type,%{public}d,locMachContTime,%{public}lf,altPrior,%{private}.3lf,altUncPrior,%{public}.3lf,undulationPrior,%{public}.3lf,undulationModelPrior,%{public}d,baroAltApplicableTime,%{public}lf,baroAltVal,%{private}.3lf, baroAltUnc,%{public}.3lf,undulation,%{public}.3lf, undulationModel,%{public}d,emergency,%{public}d,rawAlt,%{private}.3lf,rawAltUnc,%{public}.3lf,isOverridenByWiFiZ,%{public}d,propagation_us,%{public}.3f", buf, 0x94u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    int v31 = *(_DWORD *)(a2 + 96);
    uint64_t v32 = *(char **)(a2 + 504);
    uint64_t v33 = *(void *)(a2 + 28);
    uint64_t v34 = *(void *)(a2 + 36);
    float v35 = *(float *)(a2 + 476);
    int v36 = *(_DWORD *)(a2 + 472);
    uint64_t v37 = v57;
    long long v38 = *(_OWORD *)v58;
    uint64_t v45 = *(void *)&v58[16];
    int v47 = v59;
    int v39 = *(unsigned __int8 *)(v5 + 3120);
    uint64_t v49 = *(void *)(a2 + 704);
    uint64_t v51 = *(void *)(a2 + 712);
    uint64_t v40 = sub_10016BA10();
    double v41 = sub_10018202C(v40);
    LODWORD(v66) = 67244289;
    HIDWORD(v66) = v53;
    LOWORD(v67) = 1026;
    *(_DWORD *)((char *)&v67 + 2) = v31;
    HIWORD(v67) = 2050;
    double v68 = v32;
    __int16 v69 = 2049;
    uint64_t v70 = v33;
    __int16 v71 = 2050;
    uint64_t v72 = v34;
    __int16 v73 = 2050;
    double v74 = v35;
    __int16 v75 = 1026;
    int v76 = v36;
    __int16 v77 = 2050;
    uint64_t v78 = v37;
    __int16 v79 = 2049;
    uint64_t v80 = v38;
    __int16 v81 = 2050;
    uint64_t v82 = *((void *)&v38 + 1);
    __int16 v83 = 2050;
    uint64_t v84 = v45;
    __int16 v85 = 1026;
    int v86 = v47;
    __int16 v87 = 1026;
    int v88 = v39;
    __int16 v89 = 2049;
    uint64_t v90 = v49;
    __int16 v91 = 2050;
    uint64_t v92 = v51;
    __int16 v93 = 1026;
    int v94 = a3;
    __int16 v95 = 2050;
    double v96 = v41;
    __int16 v42 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::updateAltitudeWithBaroIfAppropriate(CLLocationProvider_Type::NotificationData &, const BOOL)", "%s\n", v42);
    if (v42 != (char *)buf) {
      free(v42);
    }
  }
  if (v53)
  {
    *(_OWORD *)(a2 + 704) = *(_OWORD *)(a2 + 28);
    *(double *)(a2 + 720) = *(float *)(a2 + 476);
    *(_DWORD *)(a2 + 728) = *(_DWORD *)(a2 + 472);
    *(_OWORD *)(a2 + 28) = *(_OWORD *)v58;
    float v25 = *(double *)&v58[16];
    *(float *)(a2 + 476) = v25;
    *(_DWORD *)(a2 + 472) = v59;
    *(unsigned char *)(a1 + 1936) = 1;
    int v56 = 0;
    BOOL v26 = sub_1001A0BB0((float64_t *)(a2 + 4), (double *)(a2 + 12), &v56);
    *(_DWORD *)buf = 184;
    *(_DWORD *)v98 = 100;
    float v27 = *(double *)(a2 + 36);
    *(_DWORD *)&v102[6] = 0;
    HIDWORD(v103) = 185;
    *(float *)((char *)&v105 + 2) = v27;
    LODWORD(v111) = 4;
    *(_DWORD *)uint64_t v112 = 187;
    *(float *)&v112[8] = v27;
    *(_DWORD *)uint64_t v118 = 4;
    *(_DWORD *)&v118[8] = 189;
    HIDWORD(v119) = v26;
    int v124 = 0;
    double v67 = 0;
    double v68 = 0;
    uint64_t v66 = 0;
    __int16 v64 = (void **)&v66;
    char v65 = 0;
    uint64_t v66 = (char *)operator new(0xA0uLL);
    double v67 = v66;
    double v68 = v66 + 160;
    double v67 = (unsigned char *)sub_100682A48((uint64_t)&v68, (uint64_t)buf, (uint64_t)&v125, (uint64_t)v66);
    for (uint64_t i = 128; i != -32; i -= 40)
      sub_100118010((uint64_t)&buf[i]);
    long long v29 = *(void **)(a1 + 5096);
    memset(v55, 0, sizeof(v55));
    sub_100682C20(v55, (uint64_t)v66, (uint64_t)v67, 0xCCCCCCCCCCCCCCCDLL * ((v67 - v66) >> 3));
    [v29 setMeasurements:sub_10067C03C(v55)];
    *(void *)buf = v55;
    sub_100682B1C((void ***)buf);
    *(void *)buf = &v66;
    sub_100682B1C((void ***)buf);
  }
}

void sub_100155C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void **a55)
{
  a55 = (void **)&a35;
  sub_100682B1C(&a55);
  _Unwind_Resume(a1);
}

BOOL sub_100155C74(uint64_t a1, _OWORD *a2)
{
  return *(unsigned char *)(a1 + 3528) && (uint64_t v2 = *(void *)(a1 + 3520)) != 0 && sub_100155C94(v2, a2, 0);
}

BOOL sub_100155C94(uint64_t a1, _OWORD *a2, int a3)
{
  double v6 = sub_10016C458();
  double v35 = v6;
  if (*(void *)a1)
  {
    double v7 = v6;
    if (fabs(sub_1000A4F34(v6, *(double *)(a1 + 8), 315360000.0)) > 3.0)
    {
      sub_1001572A0(a1, a1 + 2384, v7);
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = 236;
      if (!*(unsigned char *)(a1 + 237)) {
        uint64_t v9 = 360;
      }
      buf[0] = *(unsigned char *)(a1 + v9);
      sub_1001560C0(v8, &v35, a1 + 1576, (void *)(a1 + 1488), (void *)(a1 + 1496), (void *)(a1 + 1504), (void *)(a1 + 1224), buf, (void *)(a1 + 432), (void *)(a1 + 1240), (void *)(a1 + 448));
      uint64_t v10 = 268;
      if (!*(unsigned char *)(a1 + 269)) {
        uint64_t v10 = 372;
      }
      sub_1001563CC(*(void *)a1, a1 + 1576, (double *)(a1 + 2024), a1 + 8, (float32x2_t *)(a1 + 1248), a1 + 3512, a1 + 3544, a1 + 3576, (double *)(a1 + 472), (double *)(a1 + 480), (double *)(a1 + 488), a1 + 1224, a1 + 2384, *(unsigned char *)(a1 + v10), 0);
    }
  }
  double v11 = (double *)(a1 + 8);
  double v12 = *(double *)(a1 + 24);
  BOOL v14 = (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
     && (v12 > 0.0 ? (BOOL v13 = v12 < 30.0) : (BOOL v13 = 0), v13 && *(void *)a1)
     && sub_1000A4F34(v35, *v11, 315360000.0) < 3.0;
  double v15 = *(double *)(a1 + 2144);
  if (v15 > 0.0)
  {
    double v16 = *(double *)(a1 + 2136);
    if (v16 > *(double *)(a1 + 48))
    {
      *(void *)(a1 + 56) = *(void *)(a1 + 2120);
      *(double *)(a1 + 64) = v15;
      *(double *)(a1 + 48) = v16;
    }
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102345560);
  }
  uint64_t v17 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    uint64_t v18 = *(void *)(a1 + 8);
    uint64_t v19 = *(void *)(a1 + 16);
    uint64_t v20 = *(void *)(a1 + 24);
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 64);
    uint64_t v23 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 134351104;
    double v55 = v35;
    __int16 v56 = 1026;
    BOOL v57 = v14;
    __int16 v58 = 2050;
    uint64_t v59 = v18;
    __int16 v60 = 2050;
    uint64_t v61 = v19;
    __int16 v62 = 2050;
    uint64_t v63 = v20;
    __int16 v64 = 2050;
    uint64_t v65 = v22;
    __int16 v66 = 2050;
    uint64_t v67 = v21;
    __int16 v68 = 2050;
    uint64_t v69 = v23;
    __int16 v70 = 1026;
    int v71 = a3;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "BaroAlt,query of calibrated baro alt,time,%{public}.3lf,isYieldingRPA,%{public}d,applicableTime,%{public}.3lf,altitude,%{public}.3lf,altitudeUnc,%{public}.3lf,bias_pa,%{public}.3lf,biasUnc_m,%{public}.3lf,biasTimestampCFAbs_s,%{public}.3lf,internal,%{public}d", buf, 0x54u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102345560);
    }
    uint64_t v28 = *(void *)(a1 + 8);
    uint64_t v29 = *(void *)(a1 + 16);
    uint64_t v30 = *(void *)(a1 + 24);
    uint64_t v32 = *(void *)(a1 + 56);
    uint64_t v31 = *(void *)(a1 + 64);
    uint64_t v33 = *(void *)(a1 + 48);
    int v36 = 134351104;
    double v37 = v35;
    __int16 v38 = 1026;
    BOOL v39 = v14;
    __int16 v40 = 2050;
    uint64_t v41 = v28;
    __int16 v42 = 2050;
    uint64_t v43 = v29;
    __int16 v44 = 2050;
    uint64_t v45 = v30;
    __int16 v46 = 2050;
    uint64_t v47 = v32;
    __int16 v48 = 2050;
    uint64_t v49 = v31;
    __int16 v50 = 2050;
    uint64_t v51 = v33;
    __int16 v52 = 1026;
    int v53 = a3;
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeter::getCalibratedBaroAltitude(CLBarometricAltimeterCore::AltitudeUpdateData &, const BOOL)", "%s\n", v34);
    if (v34 != (char *)buf) {
      free(v34);
    }
  }
  *a2 = *(_OWORD *)v11;
  long long v24 = *(_OWORD *)(a1 + 24);
  long long v25 = *(_OWORD *)(a1 + 40);
  long long v26 = *(_OWORD *)(a1 + 72);
  a2[3] = *(_OWORD *)(a1 + 56);
  a2[4] = v26;
  a2[1] = v24;
  a2[2] = v25;
  return v14;
}

void sub_1001560C0(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, unsigned char *a8, void *a9, void *a10, void *a11)
{
  *(void *)(a3 + 64) = *a2;
  uint64_t v17 = a3 + 64;
  *(double *)(a3 + 72) = sub_1000A4CE8(a1, (double *)(a3 + 64));
  *(void *)(v17 + 16) = *a4;
  *(void *)(v17 + 32) = *a5;
  *(void *)(v17 + 40) = *a6;
  *(unsigned char *)(v17 + 48) = *a8;
  *(void *)(v17 + 104) = *a10;
  *(void *)(v17 + 120) = *a7;
  *(void *)(v17 + 192) = *a11;
  *(void *)(v17 + 200) = *a9;
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102343F08);
  }
  uint64_t v18 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v19 = *(void *)(a3 + 72);
    uint64_t v20 = *(void *)(a3 + 80);
    uint64_t v21 = *(void *)(a3 + 96);
    uint64_t v22 = *(void *)(a3 + 104);
    int v23 = *(unsigned __int8 *)(a3 + 112);
    uint64_t v24 = *(void *)(a3 + 168);
    uint64_t v25 = *(void *)(a3 + 184);
    uint64_t v26 = *(void *)(a3 + 256);
    uint64_t v27 = *(void *)(a3 + 264);
    uint64_t v28 = *(void *)(a3 + 64);
    *(_DWORD *)buf = 134285825;
    uint64_t v31 = v28;
    __int16 v32 = 2049;
    uint64_t v33 = v20;
    __int16 v34 = 2049;
    uint64_t v35 = v21;
    __int16 v36 = 2049;
    uint64_t v37 = v22;
    __int16 v38 = 1025;
    int v39 = v23;
    __int16 v40 = 2049;
    uint64_t v41 = v24;
    __int16 v42 = 2049;
    uint64_t v43 = v25;
    __int16 v44 = 2049;
    uint64_t v45 = v26;
    __int16 v46 = 2049;
    uint64_t v47 = v27;
    __int16 v48 = 2049;
    uint64_t v49 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "BaroAlt,MMKF,fillInput,machContTime_s,%{private}.3lf,refPressure_time_s,%{private}.3lf,refPressure_pa,%{private}.3lf,refPressure_unc_pa,%{private}.3lf,isReferencePressureAllowed,%{private}d,lastSignificantRelativeAlt_m,%{private}.2lf,timeOfLastOdometerData_s,%{private}.3lf,timeOfLastAltitudeData_s,%{private}.3lf,lastAltitudeDataPressure_pa,%{private}.3lf,cfAbsTime_s,%{private}.3lf", buf, 0x62u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLBarometricAltimeterCore::fillInputToCalibrateBaroAlt(const CFTimeInterval &, CLBaroAltEstimatorInput &, const double &, const double &, const double &, const CFTimeInterval &, const BOOL &, const double &, const double &, const CFTimeInterval &)", "%s\n", v29);
    if (v29 != (char *)buf) {
      free(v29);
    }
  }
}

BOOL sub_1001563CC(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, float32x2_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, double *a9, double *a10, double *a11, uint64_t a12, uint64_t a13, char a14, unsigned __int8 a15)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102343F08);
  }
  uint64_t v22 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 67109120;
    HIDWORD(buf[0]) = a15;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "BaroAlt,queried,internal,%d", (uint8_t *)buf, 8u);
  }
  uint64_t v23 = sub_10013D1A0(115, 2);
  if (v23)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    int v97 = 67109120;
    LODWORD(v98) = a15;
    int v71 = (char *)_os_log_send_and_compose_impl();
    uint64_t v23 = sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeterCore::calcCalibratedBaroAltitude(CLBaroAltEstimatorInput &, CLBaroAltEstimatorOutput &, AltitudeUpdateData &, CalibratedPressureCollectionDataBase &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, double &, double &, CFTimeInterval &, const CFTimeInterval &, const CLDaemonLocation &, const BOOL, const BOOL)", "%s\n", v71);
    if (v71 != (char *)buf) {
      free(v71);
    }
  }
  if (*a10 > 0.0 || *a3 > 0.0)
  {
    double v95 = -1.0;
    double v96 = 0.0;
    double v93 = 0.0;
    uint64_t v94 = 0;
    uint64_t v91 = 0;
    double v92 = -1.0;
    if (*(unsigned char *)(a2 + 112))
    {
      if (sub_10187C33C(v23, (double *)a2)) {
        int v26 = sub_101883734(a1, a2, (uint64_t)a3, &v96, &v95, &v94);
      }
      else {
        int v26 = 0;
      }
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      uint64_t v27 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf[0]) = 67109120;
        HIDWORD(buf[0]) = v26;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "BaroAlt,calibrated,refPressure,success,%d", (uint8_t *)buf, 8u);
      }
      uint64_t v23 = sub_10013D1A0(115, 2);
      if (v23)
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        int v97 = 67109120;
        LODWORD(v98) = v26;
        __int16 v73 = (char *)_os_log_send_and_compose_impl();
        uint64_t v23 = sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeterCore::calcCalibratedBaroAltitude(CLBaroAltEstimatorInput &, CLBaroAltEstimatorOutput &, AltitudeUpdateData &, CalibratedPressureCollectionDataBase &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, double &, double &, CFTimeInterval &, const CFTimeInterval &, const CLDaemonLocation &, const BOOL, const BOOL)", "%s\n", v73);
        if (v73 != (char *)buf) {
          free(v73);
        }
      }
      if (v26)
      {
        float v28 = *(double *)(a2 + 264);
        a5->f32[0] = v28;
        a5->i32[1] = 1075838976;
        if (*(unsigned char *)(a1 + 668))
        {
          *(void *)uint64_t v138 = 0;
          memset(buf, 0, sizeof(buf));
          uint64_t v23 = sub_10187F7DC(a1, buf);
          if (v23)
          {
            float64x2_t v29 = (float64x2_t)vdupq_n_s64(0x402800A915379FA9uLL);
            float64x2_t v30 = vmulq_f64(*(float64x2_t *)&buf[1], v29);
            v29.f64[0] = a5->f32[0];
            *(void *)&v31.f64[0] = *(_OWORD *)&vsubq_f64(v29, *(float64x2_t *)&buf[1]);
            v31.f64[1] = v30.f64[1];
            float32x2_t v32 = vcvt_f32_f64(v31);
          }
          else
          {
            float32x2_t v32 = (float32x2_t)0xBF80000000000000;
          }
          a5[1] = v32;
          double v33 = v95;
        }
        else
        {
          double v33 = v95;
          float32_t v34 = v95 * 12.00129;
          a5[1].f32[1] = v34;
          float32_t v35 = v28 - a3[1];
          a5[1].f32[0] = v35;
        }
        float32_t v36 = v96;
        float32_t v37 = v33;
        a5[5].f32[1] = v36;
        a5[6].f32[0] = v37;
        ++*(_DWORD *)(a6 + 16);
        ++*(_DWORD *)(a7 + 16);
        ++*(_DWORD *)(a8 + 16);
      }
    }
    BOOL v38 = sub_101883374(v23, a2, a9, a10, &v93, &v92, &v91, a11);
    int v39 = &qword_102419000;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    __int16 v40 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf[0]) = 67109120;
      HIDWORD(buf[0]) = v38;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "BaroAlt,calibrated,dem,success,%d", (uint8_t *)buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      int v97 = 67109120;
      LODWORD(v98) = v38;
      uint64_t v72 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeterCore::calcCalibratedBaroAltitude(CLBaroAltEstimatorInput &, CLBaroAltEstimatorOutput &, AltitudeUpdateData &, CalibratedPressureCollectionDataBase &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, double &, double &, CFTimeInterval &, const CFTimeInterval &, const CLDaemonLocation &, const BOOL, const BOOL)", "%s\n", v72);
      if (v72 != (char *)buf) {
        free(v72);
      }
      int v39 = &qword_102419000;
    }
    if (v38)
    {
      ++*(_DWORD *)(a6 + 12);
      ++*(_DWORD *)(a7 + 12);
      ++*(_DWORD *)(a8 + 12);
    }
    double v41 = v95;
    if (a14 && v95 > 0.0)
    {
      double v42 = v96;
      uint64_t v43 = v94;
      uint64_t v44 = a4;
      *(unsigned char *)(a4 + 36) = 1;
      double v45 = v41;
    }
    else
    {
      double v45 = v92;
      uint64_t v44 = a4;
      if (v92 <= 0.0)
      {
        if (v39[112] != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        __int16 v70 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_INFO, "BaroAlt,#Warning,no yield,no valid calibrated altitude is available", (uint8_t *)buf, 2u);
        }
        BOOL result = sub_10013D1A0(115, 2);
        if (result)
        {
          bzero(buf, 0x65CuLL);
          if (v39[112] != -1) {
            dispatch_once(&qword_102419380, &stru_102343F08);
          }
          LOWORD(v97) = 0;
          goto LABEL_108;
        }
        return result;
      }
      double v42 = v93;
      uint64_t v43 = v91;
      *(unsigned char *)(a4 + 37) = 1;
    }
    sub_10019C870(a1, a2, a13);
    int v46 = *(_DWORD *)(a1 + 152);
    if ((v46 - 1) > 0xFFFFFFFD || (double v47 = *(double *)(a1 + 144), fabs(v47) <= 2.22044605e-16))
    {
      if (v39[112] != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      __int16 v64 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        uint64_t v65 = *(void *)(a1 + 144);
        int v66 = *(_DWORD *)(a1 + 152);
        LODWORD(buf[0]) = 134349312;
        *(void *)((char *)buf + 4) = v65;
        WORD2(buf[1]) = 1026;
        *(_DWORD *)((char *)&buf[1] + 6) = v66;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_INFO, "BaroAlt,#Warning,no yield,no undulation knowledge,und,%{public}.lf,undModel%{public}d", (uint8_t *)buf, 0x12u);
      }
      BOOL result = sub_10013D1A0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (v39[112] != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        double v67 = *(double *)(a1 + 144);
        int v68 = *(_DWORD *)(a1 + 152);
        int v97 = 134349312;
        double v98 = v67;
        __int16 v99 = 1026;
        LODWORD(v100) = v68;
        goto LABEL_108;
      }
    }
    else
    {
      *(double *)(v44 + 8) = v42 - v47;
      *(double *)(v44 + 16) = v45;
      *(double *)(v44 + 24) = v47;
      *(_DWORD *)(v44 + 32) = v46;
      *(void *)uint64_t v44 = v43;
      if (v39[112] != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      __int16 v48 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        double v49 = *(double *)(a2 + 64);
        uint64_t v50 = *(void *)(a2 + 72);
        double v51 = *a9;
        double v52 = *a10;
        double v53 = -1.0;
        if ((*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && fabs(v49) > 2.22044605e-16)
        {
          double v54 = *a11;
          if ((*(void *)a11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && fabs(v54) > 2.22044605e-16) {
            double v53 = vabdd_f64(v49, v54);
          }
        }
        uint64_t v56 = *(void *)(a2 + 256);
        uint64_t v55 = *(void *)(a2 + 264);
        uint64_t v57 = *(void *)(v44 + 8);
        uint64_t v58 = *(void *)(v44 + 16);
        uint64_t v59 = *(void *)(v44 + 24);
        int v60 = *(_DWORD *)(v44 + 32);
        uint64_t v61 = *(void *)(a13 + 4);
        uint64_t v62 = *(void *)(a13 + 12);
        LODWORD(buf[0]) = 134353921;
        *(double *)((char *)buf + 4) = v49;
        WORD2(buf[1]) = 2050;
        *(void *)((char *)&buf[1] + 6) = v50;
        HIWORD(buf[2]) = 2049;
        *(double *)&buf[3] = v51;
        *(_WORD *)uint64_t v138 = 2050;
        *(double *)&v138[2] = v52;
        __int16 v139 = 2050;
        double v140 = v53;
        __int16 v141 = 2050;
        uint64_t v142 = v55;
        __int16 v143 = 2050;
        uint64_t v144 = v56;
        __int16 v145 = 2049;
        uint64_t v146 = v57;
        __int16 v147 = 2050;
        uint64_t v148 = v58;
        __int16 v149 = 2050;
        uint64_t v150 = v43;
        __int16 v151 = 2049;
        double v152 = v96;
        __int16 v153 = 2050;
        double v154 = v41;
        __int16 v155 = 2049;
        double v156 = v93;
        __int16 v157 = 2050;
        double v158 = v92;
        __int16 v159 = 2049;
        uint64_t v160 = v59;
        __int16 v161 = 1026;
        int v162 = v60;
        __int16 v163 = 2049;
        uint64_t v164 = v94;
        __int16 v165 = 2049;
        uint64_t v166 = v91;
        __int16 v167 = 2049;
        uint64_t v168 = v61;
        __int16 v169 = 2049;
        uint64_t v170 = v62;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_INFO, "BaroAlt,calibrated,time,%{public}.3lf,cfAbsTime,%{public}.3lf,baseAlt,%{private}.3lf,unc,%{public}.3lf,timeSinceBaseAlt,%{public}.3lf,pressure,%{public}.3lf,fTimeOfLastCMAltitudeData,%{public}.3lf,calibratedAlt,%{private}.3lf,calAltUnc,%{public}.3lf,applicableTime,%{public}.3lf,calibratedAltReferencePressure,%{private}.3lf,calAltUncReferencePressure,%{public}.3lf,calibratedAltDEM,%{private}.3lf,calAltUncDEM,%{public}.3lf,undulation,%{private}.3lf,undulationModel,%{public}d,refPresAltWgs84AppMachContTime,%{private}.3lf,demCalibAltWgs84AppMachContTime,%{private}.3lf,lat,%{private}.8lf,lon,%{private}.8lf", (uint8_t *)buf, 0xC6u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (v39[112] != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        double v74 = *(double *)(a2 + 64);
        uint64_t v75 = *(void *)(a2 + 72);
        double v76 = *a9;
        double v77 = *a10;
        double v78 = -1.0;
        if ((*(void *)&v74 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && fabs(v74) > 2.22044605e-16)
        {
          double v79 = *a11;
          if ((*(void *)a11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && fabs(v79) > 2.22044605e-16) {
            double v78 = vabdd_f64(v74, v79);
          }
        }
        uint64_t v81 = *(void *)(a2 + 256);
        uint64_t v80 = *(void *)(a2 + 264);
        uint64_t v44 = a4;
        uint64_t v82 = *(void *)(a4 + 8);
        uint64_t v83 = *(void *)(a4 + 16);
        uint64_t v84 = *(void *)(a4 + 24);
        int v85 = *(_DWORD *)(a4 + 32);
        uint64_t v86 = *(void *)(a13 + 4);
        uint64_t v87 = *(void *)(a13 + 12);
        int v97 = 134353921;
        double v98 = v74;
        __int16 v99 = 2050;
        uint64_t v100 = v75;
        __int16 v101 = 2049;
        double v102 = v76;
        __int16 v103 = 2050;
        double v104 = v77;
        __int16 v105 = 2050;
        double v106 = v78;
        __int16 v107 = 2050;
        uint64_t v108 = v80;
        __int16 v109 = 2050;
        uint64_t v110 = v81;
        __int16 v111 = 2049;
        uint64_t v112 = v82;
        __int16 v113 = 2050;
        uint64_t v114 = v83;
        __int16 v115 = 2050;
        uint64_t v116 = v43;
        __int16 v117 = 2049;
        double v118 = v96;
        __int16 v119 = 2050;
        double v120 = v95;
        __int16 v121 = 2049;
        double v122 = v93;
        __int16 v123 = 2050;
        double v124 = v92;
        __int16 v125 = 2049;
        uint64_t v126 = v84;
        __int16 v127 = 1026;
        int v128 = v85;
        __int16 v129 = 2049;
        uint64_t v130 = v94;
        __int16 v131 = 2049;
        uint64_t v132 = v91;
        __int16 v133 = 2049;
        uint64_t v134 = v86;
        __int16 v135 = 2049;
        uint64_t v136 = v87;
        int v88 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeterCore::calcCalibratedBaroAltitude(CLBaroAltEstimatorInput &, CLBaroAltEstimatorOutput &, AltitudeUpdateData &, CalibratedPressureCollectionDataBase &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, double &, double &, CFTimeInterval &, const CFTimeInterval &, const CLDaemonLocation &, const BOOL, const BOOL)", "%s\n", v88);
        if (v88 != (char *)buf) {
          free(v88);
        }
      }
      if (*(double *)(v44 + 16) > 0.0)
      {
        double v63 = *(double *)(v44 + 8);
        if (v63 > -450.0 && v63 < 8850.0) {
          return 1;
        }
      }
      if (v39[112] != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      uint64_t v69 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_INFO, "BaroAlt,invalid calibrated altitude", (uint8_t *)buf, 2u);
      }
      BOOL result = sub_10013D1A0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (v39[112] != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        LOWORD(v97) = 0;
        goto LABEL_108;
      }
    }
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    uint64_t v24 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "BaroAlt,#Warning,not yet calibrated", (uint8_t *)buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      LOWORD(v97) = 0;
LABEL_108:
      __int16 v89 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeterCore::calcCalibratedBaroAltitude(CLBaroAltEstimatorInput &, CLBaroAltEstimatorOutput &, AltitudeUpdateData &, CalibratedPressureCollectionDataBase &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, BarometricAltitudeCalibrationAnalyticsData &, double &, double &, CFTimeInterval &, const CFTimeInterval &, const CLDaemonLocation &, const BOOL, const BOOL)", "%s\n", v89);
      if (v89 != (char *)buf) {
        free(v89);
      }
      return 0;
    }
  }
  return result;
}

void sub_1001572A0(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3 = 236;
  if (!*(unsigned char *)(a1 + 237)) {
    uint64_t v3 = 360;
  }
  if (*(unsigned char *)(a1 + v3)
    && *(unsigned char *)(a1 + 2156)
    && *(void *)a1
    && sub_1000A4F34(a3, *(double *)(a1 + 1552), 315360000.0) >= 120.0)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102345560);
    }
    double v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "BaroAlt,query ref pressure during a e911 call", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102345560);
      }
      double v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLBarometricAltimeter::queryReferencePressureIfInEmergencyCall(const CFTimeInterval, const CLDaemonLocation &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    sub_101919CC8(a1, a2);
  }
}

BOOL sub_100157490(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v5 = *a4;
  *a4 = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 128) = 0;
  *(unsigned char *)(a2 + 152) = 0;
  *(_DWORD *)a2 = 0xFFFF;
  *(void *)(a2 + 12) = 0;
  *(void *)(a2 + 4) = 0;
  *(_OWORD *)(a2 + 20) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 36) = _Q0;
  *(_OWORD *)(a2 + 52) = _Q0;
  *(_OWORD *)(a2 + 68) = _Q0;
  *(_DWORD *)(a2 + 84) = 0;
  *(void *)(a2 + 88) = 0xBFF0000000000000;
  *(void *)(a2 + 116) = 0xBFF0000000000000;
  *(_DWORD *)(a2 + 124) = 0x7FFFFFFF;
  unsigned int v11 = *(_DWORD *)(a3 + 96);
  if (!v11)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    float64x2_t v29 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "#Warning, LCFusion, not notifying clients when provider type is Unknown", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(_WORD *)__int16 v145 = 0;
      goto LABEL_77;
    }
    return result;
  }
  int v15 = sub_100158594(a1, v11);
  int v144 = v15;
  uint64_t v17 = a1 + 248;
  uint64_t v16 = *(void *)(a1 + 248);
  if (!v16) {
    goto LABEL_12;
  }
  uint64_t v18 = a1 + 248;
  uint64_t v19 = *(void *)(a1 + 248);
  do
  {
    int v20 = *(_DWORD *)(v19 + 32);
    BOOL v21 = v20 < v15;
    if (v20 >= v15) {
      uint64_t v22 = (uint64_t *)v19;
    }
    else {
      uint64_t v22 = (uint64_t *)(v19 + 8);
    }
    if (!v21) {
      uint64_t v18 = v19;
    }
    uint64_t v19 = *v22;
  }
  while (*v22);
  if (v18 == v17 || v15 < *(_DWORD *)(v18 + 32)) {
LABEL_12:
  }
    uint64_t v18 = a1 + 248;
  int v142 = v5;
  uint64_t v23 = (int *)(a1 + 232);
  if (!v16)
  {
    int v24 = *v23;
LABEL_33:
    uint64_t v25 = a1 + 248;
    goto LABEL_34;
  }
  int v24 = *v23;
  uint64_t v25 = a1 + 248;
  do
  {
    int v26 = *(_DWORD *)(v16 + 32);
    BOOL v27 = v26 < v24;
    if (v26 >= v24) {
      float v28 = (uint64_t *)v16;
    }
    else {
      float v28 = (uint64_t *)(v16 + 8);
    }
    if (!v27) {
      uint64_t v25 = v16;
    }
    uint64_t v16 = *v28;
  }
  while (*v28);
  if (v25 == v17 || v24 < *(_DWORD *)(v25 + 32)) {
    goto LABEL_33;
  }
LABEL_34:
  BOOL v31 = 0;
  if (!v24 || v15 == v24)
  {
LABEL_49:
    char v39 = v142;
    (*(void (**)(void, BOOL))(**(void **)(a1 + 288) + 448))(*(void *)(a1 + 288), v142 != 0);
    int v40 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 288) + 136))(*(void *)(a1 + 288), a3);
    int v41 = v40;
    if (!*(unsigned char *)(a1 + 674) || v18 == v17 || *(unsigned char *)(v18 + 903))
    {
      if ((v31 | v40 ^ 1))
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        double v42 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
        {
          uint64_t v43 = *(void *)(a3 + 76);
          unsigned int v44 = *(_DWORD *)(a3 + 96);
          double v45 = sub_10003E9A4(v44);
          uint64_t v46 = *(void *)(a3 + 4);
          uint64_t v47 = *(void *)(a3 + 12);
          uint64_t v48 = *(void *)(a3 + 20);
          *(_DWORD *)buf = 134350339;
          *(void *)&void buf[4] = v43;
          __int16 v179 = 1026;
          *(_DWORD *)uint64_t v180 = v44;
          *(_WORD *)&v180[4] = 2082;
          *(void *)&v180[6] = v45;
          *(_WORD *)&v180[14] = 2049;
          *(void *)&v180[16] = v46;
          *(_WORD *)&v180[24] = 2049;
          *(void *)&v180[26] = v47;
          *(_WORD *)&v180[34] = 2050;
          *(void *)&v180[36] = v48;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_INFO, "location rejected by LCFusion,iosTime,%{public}.3f,type,%{public}d,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f", buf, 0x3Au);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          uint64_t v98 = *(void *)(a3 + 76);
          unsigned int v99 = *(_DWORD *)(a3 + 96);
          uint64_t v100 = sub_10003E9A4(v99);
          uint64_t v101 = *(void *)(a3 + 4);
          uint64_t v102 = *(void *)(a3 + 12);
          uint64_t v103 = *(void *)(a3 + 20);
          *(_DWORD *)__int16 v145 = 134350339;
          *(void *)&v145[4] = v98;
          __int16 v146 = 1026;
          *(_DWORD *)__int16 v147 = v99;
          *(_WORD *)&v147[4] = 2082;
          *(void *)&v147[6] = v100;
          *(_WORD *)&v147[14] = 2049;
          *(void *)&v147[16] = v101;
          *(_WORD *)&v147[24] = 2049;
          *(void *)&v147[26] = v102;
          *(_WORD *)&v147[34] = 2050;
          *(void *)&v147[36] = v103;
          double v104 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::updateFusionLCLocationFilter(CLDaemonLocation &, const CLLocationProvider_Type::NotificationData &, BOOL &)", "%s\n", v104);
          if (v104 != buf) {
            free(v104);
          }
        }
        char v49 = 0;
        char v39 = v142;
      }
      else
      {
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 288) + 144))(*(void *)(a1 + 288), a2);
        char v49 = 1;
      }
      *a4 = v49;
      if (!*(unsigned char *)(a1 + 666)) {
        char v49 = v39;
      }
      *a4 = v49;
      if (v41)
      {
        if (qword_102419650 != -1) {
          dispatch_once(&qword_102419650, &stru_1022C1840);
        }
        uint64_t v50 = qword_102419658;
        if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v51 = *(void *)(a2 + 4);
          uint64_t v123 = *(void *)(a2 + 12);
          uint64_t v127 = *(void *)(a2 + 20);
          unsigned int v52 = *(_DWORD *)(a2 + 96);
          __int16 v125 = sub_10003E9A4(v52);
          uint64_t v133 = *(void *)(a2 + 44);
          uint64_t v135 = *(void *)(a2 + 60);
          int v137 = *(_DWORD *)(a2 + 84);
          uint64_t v140 = *(void *)(a2 + 88);
          uint64_t v143 = *(void *)(a2 + 76);
          uint64_t v53 = sub_10016BA10();
          *(_DWORD *)buf = 0;
          double v54 = sub_10016BA54(v53, buf) - *(double *)(a2 + 76);
          uint64_t v55 = *(void *)(a2 + 28);
          uint64_t v56 = *(void *)(a2 + 36);
          uint64_t v57 = *(void *)(a2 + 52);
          uint64_t v58 = *(void *)(a2 + 68);
          uint64_t v59 = *(void *)(a3 + 184);
          int v124 = *(_DWORD *)(a2 + 128);
          int v129 = *(_DWORD *)(a2 + 132);
          int v131 = *(_DWORD *)(a2 + 136);
          uint64_t v60 = sub_10016BA10();
          double v61 = sub_10018202C(v60);
          *(_DWORD *)buf = 136320515;
          *(void *)&void buf[4] = "CL-filtered";
          __int16 v179 = 1024;
          *(_DWORD *)uint64_t v180 = 0;
          *(_WORD *)&v180[4] = 2048;
          *(void *)&v180[6] = v51;
          *(_WORD *)&v180[14] = 2048;
          *(void *)&v180[16] = v123;
          *(_WORD *)&v180[24] = 2048;
          *(void *)&v180[26] = v127;
          *(_WORD *)&v180[34] = 1026;
          *(_DWORD *)&v180[36] = v52;
          *(_WORD *)&v180[40] = 2082;
          *(void *)&v180[42] = v125;
          __int16 v181 = 2050;
          uint64_t v182 = v133;
          __int16 v183 = 2050;
          uint64_t v184 = v135;
          __int16 v185 = 1026;
          int v186 = v137;
          __int16 v187 = 2050;
          uint64_t v188 = v140;
          __int16 v189 = 2050;
          uint64_t v190 = v143;
          __int16 v191 = 2050;
          double v192 = v54;
          __int16 v193 = 2049;
          uint64_t v194 = v55;
          __int16 v195 = 2050;
          uint64_t v196 = v56;
          __int16 v197 = 2050;
          uint64_t v198 = v57;
          __int16 v199 = 2050;
          uint64_t v200 = v58;
          __int16 v201 = 2050;
          uint64_t v202 = v59;
          __int16 v203 = 1026;
          int v204 = v124;
          __int16 v205 = 1026;
          int v206 = v129;
          __int16 v207 = 1026;
          int v208 = v131;
          __int16 v209 = 2050;
          double v210 = v61;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%{public}d,%{public}s,Speed,%{public}.2f,Course,%{public}.2f,Confidence,%{public}d,Lifespan,%{public}.3f,LocationTimestamp,%{public}.3f,Age,%{public}.3f,Altitude,%{private}.3f,AltitudeAccuracy,%{public}.3f,SpeedAccuracy,%{public}.3f,CourseAccuracy,%{public}.1f,timestampGps,%{public}.3lf,integrity,%{public}d,referenceFrame,%{public}d,rawReferenceFrame,%{public}d,propagation_us,%{public}.3f", buf, 0xC6u);
        }
        if (sub_10013D1A0(117, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419650 != -1) {
            dispatch_once(&qword_102419650, &stru_1022C1840);
          }
          uint64_t v105 = *(void *)(a2 + 4);
          uint64_t v106 = *(void *)(a2 + 12);
          uint64_t v107 = *(void *)(a2 + 20);
          unsigned int v108 = *(_DWORD *)(a2 + 96);
          __int16 v109 = sub_10003E9A4(v108);
          uint64_t v110 = *(void *)(a2 + 44);
          uint64_t v111 = *(void *)(a2 + 60);
          int v112 = *(_DWORD *)(a2 + 84);
          uint64_t v130 = *(void *)(a2 + 88);
          double v134 = *(double *)(a2 + 76);
          double v113 = sub_1005BFA38() - v134;
          uint64_t v126 = *(void *)(a2 + 28);
          uint64_t v128 = *(void *)(a2 + 36);
          uint64_t v132 = *(void *)(a2 + 52);
          uint64_t v136 = *(void *)(a2 + 68);
          uint64_t v114 = *(void *)(a3 + 184);
          int v115 = *(_DWORD *)(a2 + 128);
          int v116 = *(_DWORD *)(a2 + 132);
          int v117 = *(_DWORD *)(a2 + 136);
          int v138 = v115;
          int v141 = v116;
          uint64_t v118 = sub_10016BA10();
          *(_DWORD *)__int16 v145 = 136320515;
          *(void *)&v145[4] = "CL-filtered";
          __int16 v146 = 1024;
          *(_DWORD *)__int16 v147 = 0;
          *(_WORD *)&v147[4] = 2048;
          *(void *)&v147[6] = v105;
          *(_WORD *)&v147[14] = 2048;
          *(void *)&v147[16] = v106;
          *(_WORD *)&v147[24] = 2048;
          *(void *)&v147[26] = v107;
          *(_WORD *)&v147[34] = 1026;
          *(_DWORD *)&v147[36] = v108;
          *(_WORD *)&v147[40] = 2082;
          *(void *)&v147[42] = v109;
          __int16 v148 = 2050;
          uint64_t v149 = v110;
          __int16 v150 = 2050;
          uint64_t v151 = v111;
          __int16 v152 = 1026;
          int v153 = v112;
          __int16 v154 = 2050;
          uint64_t v155 = v130;
          __int16 v156 = 2050;
          double v157 = v134;
          __int16 v158 = 2050;
          double v159 = v113;
          __int16 v160 = 2049;
          uint64_t v161 = v126;
          __int16 v162 = 2050;
          uint64_t v163 = v128;
          __int16 v164 = 2050;
          uint64_t v165 = v132;
          __int16 v166 = 2050;
          uint64_t v167 = v136;
          __int16 v168 = 2050;
          uint64_t v169 = v114;
          __int16 v170 = 1026;
          int v171 = v138;
          __int16 v172 = 1026;
          int v173 = v141;
          __int16 v174 = 1026;
          int v175 = v117;
          __int16 v176 = 2050;
          double v177 = sub_10018202C(v118);
          __int16 v119 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("LOCATION", 1, 0, 2, "BOOL CLLocationController::updateFusionLCLocationFilter(CLDaemonLocation &, const CLLocationProvider_Type::NotificationData &, BOOL &)", "%s\n", v119);
          if (v119 != buf) {
            free(v119);
          }
        }
        return 1;
      }
      return 0;
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v62 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v63 = *(unsigned __int8 *)(a1 + 674);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&void buf[4] = v63;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEBUG, "#Warning, LCFusion, not notifying clients when device is sleeping,%d", buf, 8u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      int v64 = *(unsigned __int8 *)(a1 + 674);
      *(_DWORD *)__int16 v145 = 67109120;
      *(_DWORD *)&v145[4] = v64;
LABEL_77:
      uint64_t v65 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::updateFusionLCLocationFilter(CLDaemonLocation &, const CLLocationProvider_Type::NotificationData &, BOOL &)", "%s\n", v65);
      if (v65 != buf) {
        free(v65);
      }
      return 0;
    }
    return result;
  }
  if (*(unsigned char *)(v18 + 903))
  {
    BOOL v31 = 0;
    goto LABEL_49;
  }
  __int16 v139 = (uint64_t **)(a1 + 240);
  int v32 = *(char *)(v18 + 900);
  if (v32 <= *(char *)(v25 + 900))
  {
    uint64_t v33 = sub_10016BA10();
    *(_DWORD *)buf = 0;
    double v34 = sub_10016BA54(v33, buf) - *(double *)(v25 + 172);
    double v35 = *(double *)(v25 + 184);
    BOOL v31 = v34 < v35;
    if (v34 < v35)
    {
      if (v144 != 1)
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        double v79 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
        {
          *(void *)buf = &v144;
          uint64_t v80 = sub_100151D38(v139, &v144, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
          uint64_t v81 = v80 + 6;
          if (*((char *)v80 + 71) < 0) {
            uint64_t v81 = (void *)*v81;
          }
          uint64_t v82 = *(void *)(v18 + 100);
          uint64_t v83 = *(void *)(v18 + 108);
          *(void *)buf = a1 + 232;
          uint64_t v84 = sub_100151D38(v139, v23, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
          int v85 = v84 + 6;
          if (*((char *)v84 + 71) < 0) {
            int v85 = (void *)*v85;
          }
          uint64_t v86 = *(void *)(v18 + 172);
          uint64_t v87 = sub_10016BA10();
          double v88 = sub_10018202C(v87);
          *(_DWORD *)buf = 136447491;
          *(void *)&void buf[4] = v81;
          __int16 v179 = 2049;
          *(void *)uint64_t v180 = v82;
          *(_WORD *)&v180[8] = 2049;
          *(void *)&v180[10] = v83;
          *(_WORD *)&v180[18] = 2082;
          *(void *)&v180[20] = v85;
          *(_WORD *)&v180[28] = 2050;
          *(void *)&v180[30] = v86;
          *(_WORD *)&v180[38] = 2050;
          *(double *)&v180[40] = v88;
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEBUG, "LCFusion,got non-active location provider,%{public}s,lat,%{private}.7f,lon,%{private}.7f,ignoring,in favor of,%{public}s,mct,%{public}.3f,propagation_us,%{public}.3f", buf, 0x3Eu);
        }
        BOOL result = sub_10013D1A0(115, 2);
        if (result)
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          *(void *)__int16 v145 = &v144;
          __int16 v89 = sub_100151D38(v139, &v144, (uint64_t)&unk_101D0B290, (_DWORD **)v145);
          uint64_t v90 = v89 + 6;
          if (*((char *)v89 + 71) < 0) {
            uint64_t v90 = (void *)*v90;
          }
          uint64_t v91 = *(void *)(v18 + 100);
          uint64_t v92 = *(void *)(v18 + 108);
          *(void *)__int16 v145 = a1 + 232;
          double v93 = sub_100151D38(v139, v23, (uint64_t)&unk_101D0B290, (_DWORD **)v145);
          uint64_t v94 = v93 + 6;
          if (*((char *)v93 + 71) < 0) {
            uint64_t v94 = (void *)*v94;
          }
          uint64_t v95 = *(void *)(v18 + 172);
          uint64_t v96 = sub_10016BA10();
          double v97 = sub_10018202C(v96);
          *(_DWORD *)__int16 v145 = 136447491;
          *(void *)&v145[4] = v90;
          __int16 v146 = 2049;
          *(void *)__int16 v147 = v91;
          *(_WORD *)&v147[8] = 2049;
          *(void *)&v147[10] = v92;
          *(_WORD *)&v147[18] = 2082;
          *(void *)&v147[20] = v94;
          *(_WORD *)&v147[28] = 2050;
          *(void *)&v147[30] = v95;
          *(_WORD *)&v147[38] = 2050;
          *(double *)&v147[40] = v97;
          goto LABEL_77;
        }
        return result;
      }
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      float32_t v36 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v37 = *(void *)(v18 + 100);
        uint64_t v38 = *(void *)(v18 + 108);
        *(_DWORD *)buf = 134283777;
        *(void *)&void buf[4] = v37;
        __int16 v179 = 2049;
        *(void *)uint64_t v180 = v38;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "LCFusion, got non-active wifi lat,%{private}.7f,lon,%{private}.7f, Consuming in LCFusion ", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        uint64_t v120 = *(void *)(v18 + 100);
        uint64_t v121 = *(void *)(v18 + 108);
        *(_DWORD *)__int16 v145 = 134283777;
        *(void *)&v145[4] = v120;
        __int16 v146 = 2049;
        *(void *)__int16 v147 = v121;
        double v122 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::updateFusionLCLocationFilter(CLDaemonLocation &, const CLLocationProvider_Type::NotificationData &, BOOL &)", "%s\n", v122);
        if (v122 != buf) {
          free(v122);
        }
      }
    }
    LOBYTE(v32) = *(unsigned char *)(v18 + 900);
  }
  else
  {
    BOOL v31 = 0;
  }
  if ((char)v32 > 0) {
    goto LABEL_49;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  int v66 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v67 = *(void *)(v18 + 100);
    uint64_t v68 = *(void *)(v18 + 108);
    *(void *)buf = &v144;
    uint64_t v69 = sub_100151D38(v139, &v144, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    __int16 v70 = v69 + 6;
    if (*((char *)v69 + 71) < 0) {
      __int16 v70 = (void *)*v70;
    }
    uint64_t v71 = sub_10016BA10();
    double v72 = sub_10018202C(v71);
    *(_DWORD *)buf = 134284291;
    *(void *)&void buf[4] = v67;
    __int16 v179 = 2049;
    *(void *)uint64_t v180 = v68;
    *(_WORD *)&v180[8] = 2082;
    *(void *)&v180[10] = v70;
    *(_WORD *)&v180[18] = 2050;
    *(double *)&v180[20] = v72;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEBUG, "LCFusion Got,lat,%{private}.7f,lon,%{private}.7f,for non-active location provider,%{public}s,ignoring coarse granularity,propagation_us,%{public}.3f", buf, 0x2Au);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v73 = *(void *)(v18 + 100);
    uint64_t v74 = *(void *)(v18 + 108);
    *(void *)__int16 v145 = &v144;
    uint64_t v75 = sub_100151D38(v139, &v144, (uint64_t)&unk_101D0B290, (_DWORD **)v145);
    double v76 = v75 + 6;
    if (*((char *)v75 + 71) < 0) {
      double v76 = (void *)*v76;
    }
    uint64_t v77 = sub_10016BA10();
    double v78 = sub_10018202C(v77);
    *(_DWORD *)__int16 v145 = 134284291;
    *(void *)&v145[4] = v73;
    __int16 v146 = 2049;
    *(void *)__int16 v147 = v74;
    *(_WORD *)&v147[8] = 2082;
    *(void *)&v147[10] = v76;
    *(_WORD *)&v147[18] = 2050;
    *(double *)&v147[20] = v78;
    goto LABEL_77;
  }
  return result;
}

uint64_t sub_100158594(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xE) {
    return 1;
  }
  else {
    return dword_101D27BAC[a2];
  }
}

uint64_t sub_1001585B4(uint64_t a1, uint64_t a2)
{
  if (qword_102419650 != -1) {
    dispatch_once(&qword_102419650, &stru_1022C1840);
  }
  int v4 = qword_102419658;
  if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a2 + 4);
    uint64_t v21 = *(void *)(a2 + 12);
    uint64_t v23 = *(void *)(a2 + 20);
    unsigned int v6 = *(_DWORD *)(a2 + 96);
    uint64_t v22 = sub_10003E9A4(v6);
    uint64_t v26 = *(void *)(a2 + 44);
    uint64_t v28 = *(void *)(a2 + 60);
    int v29 = *(_DWORD *)(a2 + 84);
    uint64_t v30 = *(void *)(a2 + 88);
    uint64_t v31 = *(void *)(a2 + 76);
    uint64_t v7 = sub_10016BA10();
    *(_DWORD *)buf = 0;
    double v8 = sub_10016BA54(v7, buf) - *(double *)(a2 + 76);
    uint64_t v9 = *(void *)(a2 + 28);
    uint64_t v10 = *(void *)(a2 + 36);
    uint64_t v11 = *(void *)(a2 + 52);
    uint64_t v19 = *(void *)(a2 + 68);
    uint64_t v20 = *(void *)(a2 + 184);
    double v12 = *(float *)(a2 + 476);
    int v24 = *(_DWORD *)(a2 + 472);
    int v13 = *(_DWORD *)(a2 + 128);
    int v25 = *(_DWORD *)(a2 + 132);
    int v27 = *(_DWORD *)(a2 + 136);
    uint64_t v14 = sub_10016BA10();
    double v15 = sub_10018202C(v14);
    *(_DWORD *)buf = 136321027;
    uint64_t v33 = "CL-prefiltered";
    __int16 v34 = 1024;
    int v35 = 0;
    __int16 v36 = 2048;
    uint64_t v37 = v5;
    __int16 v38 = 2048;
    uint64_t v39 = v21;
    __int16 v40 = 2048;
    uint64_t v41 = v23;
    __int16 v42 = 1026;
    unsigned int v43 = v6;
    __int16 v44 = 2082;
    double v45 = v22;
    __int16 v46 = 2050;
    uint64_t v47 = v26;
    __int16 v48 = 2050;
    uint64_t v49 = v28;
    __int16 v50 = 1026;
    int v51 = v29;
    __int16 v52 = 2050;
    uint64_t v53 = v30;
    __int16 v54 = 2050;
    uint64_t v55 = v31;
    __int16 v56 = 2050;
    double v57 = v8;
    __int16 v58 = 2049;
    uint64_t v59 = v9;
    __int16 v60 = 2050;
    uint64_t v61 = v10;
    __int16 v62 = 2050;
    uint64_t v63 = v11;
    __int16 v64 = 2050;
    uint64_t v65 = v19;
    __int16 v66 = 2050;
    uint64_t v67 = v20;
    __int16 v68 = 1026;
    int v69 = v13;
    __int16 v70 = 2049;
    double v71 = v12;
    __int16 v72 = 1026;
    int v73 = v24;
    __int16 v74 = 1024;
    int v75 = v25;
    __int16 v76 = 1024;
    int v77 = v27;
    __int16 v78 = 2050;
    double v79 = v15;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%{public}d,%{public}s,Speed,%{public}.2f,Course,%{public}.2f,Confidence,%{public}d,Lifespan,%{public}.3f,LocationTimestamp,%{public}.3f,Age,%{public}.3f,Altitude,%{private}.3f,AltitudeAccuracy,%{public}.3f,SpeedAccuracy,%{public}.3f,CourseAccuracy,%{public}.1f,timestampGps,%{public}.3lf,integrity,%{public}d,undulation,%{private}.3lf,undulationModel,%{public}d,referenceFrame,%d,rawReferenceFrame,%d,propagation_us,%{public}.3f", buf, 0xD6u);
  }
  if (sub_10013D1A0(117, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419650 != -1) {
      dispatch_once(&qword_102419650, &stru_1022C1840);
    }
    sub_10003E9A4(*(_DWORD *)(a2 + 96));
    sub_1005BFA38();
    uint64_t v17 = sub_10016BA10();
    sub_10018202C(v17);
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("LOCATION", 1, 0, 2, "void CLLocationController::notifyPrefilteredLocation(const CLLocationProvider_Type::NotificationData &)", "%s\n", v18);
    if (v18 != (char *)buf) {
      free(v18);
    }
  }
  *(_DWORD *)buf = 33;
  return (*(uint64_t (**)(uint64_t, uint8_t *, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, buf, a2, 1, 0xFFFFFFFFLL, 0);
}

uint64_t sub_100158B1C(uint64_t a1, int a2)
{
  if (a2 - 1) < 0xB && ((0x7EFu >> (a2 - 1))) {
    return 1;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  uint64_t v3 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67240192;
    int v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "unsupported location type,%{public}d", buf, 8u);
  }
  BOOL v4 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v4)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLLocationController::isLocationTypeSupported(CLLocationType)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

int *sub_100158CF0(int *result, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 96) & 0xFFFFFFF7) == 1)
  {
    uint64_t v3 = result;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    BOOL v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(void *)(a2 + 76);
      uint64_t v6 = *(void *)(a2 + 160);
      uint64_t v7 = *(void *)(a2 + 168);
      uint64_t v9 = *(void *)(a2 + 176);
      uint64_t v8 = *(void *)(a2 + 184);
      uint64_t v10 = *(void *)(a2 + 4);
      uint64_t v11 = *(void *)(a2 + 12);
      uint64_t v12 = *(void *)(a2 + 20);
      uint64_t v13 = *(void *)(a2 + 28);
      uint64_t v14 = *(void *)(a2 + 36);
      uint64_t v15 = *(void *)(a2 + 44);
      uint64_t v16 = *(void *)(a2 + 52);
      uint64_t v17 = *(void *)(a2 + 60);
      uint64_t v18 = *(void *)(a2 + 68);
      *(_DWORD *)buf = 134352385;
      uint64_t v21 = v5;
      __int16 v22 = 2050;
      uint64_t v23 = v8;
      __int16 v24 = 2050;
      uint64_t v25 = v6;
      __int16 v26 = 2050;
      uint64_t v27 = v7;
      __int16 v28 = 2050;
      uint64_t v29 = v9;
      __int16 v30 = 2049;
      uint64_t v31 = v10;
      __int16 v32 = 2049;
      uint64_t v33 = v11;
      __int16 v34 = 2050;
      uint64_t v35 = v12;
      __int16 v36 = 2049;
      uint64_t v37 = v13;
      __int16 v38 = 2050;
      uint64_t v39 = v14;
      __int16 v40 = 2050;
      uint64_t v41 = v15;
      __int16 v42 = 2050;
      uint64_t v43 = v16;
      __int16 v44 = 2050;
      uint64_t v45 = v17;
      __int16 v46 = 2050;
      uint64_t v47 = v18;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "GPSODOM,timestamp,%{public}.3lf,timestampGps,%{public}.3lf,odometer,%{public}.3lf,deltaDist,%{public}.3lf,deltaDistUnc,%{public}.3lf,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.1lf,alt,%{private}.3lf,vunc,%{public}.1lf,speed,%{public}.3lf,sunc,%{public}.3lf,course,%{public}.3lf,cunc,%{public}.3lf", buf, 0x8Eu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::gpsOdometerHelper(const CLLocationProvider_Type::NotificationData &)", "%s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
    uint64_t result = *(int **)(a2 + 800);
    if (result && (uint64_t result = (int *)sub_1010FB9FC(result), (unint64_t)result > 1)
      || *(double *)(a2 + 160) >= 0.0 && *(double *)(a2 + 168) >= 0.0 && *(double *)(a2 + 176) >= 0.0)
    {
      *(_DWORD *)buf = 23;
      return (int *)(*(uint64_t (**)(int *, uint8_t *, uint64_t, uint64_t, uint64_t, void))(*(void *)v3 + 152))(v3, buf, a2, 1, 0xFFFFFFFFLL, 0);
    }
  }
  return result;
}

void sub_10015907C(uint64_t a1)
{
  uint64_t v2 = sub_10016BA10();
  *(_DWORD *)long long __p = 0;
  double v3 = sub_10016BA54(v2, __p);
  if (v3 - *(double *)(a1 + 1928) >= 900.0)
  {
    *(double *)(a1 + 1928) = v3;
    sub_100103240();
    sub_10073B6FC((uint64_t)__p);
    if (v49[9] >= 0) {
      BOOL v4 = __p;
    }
    else {
      BOOL v4 = *(char **)__p;
    }
    sub_100134750(&v39, v4);
    if ((v49[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    std::string::size_type size = HIBYTE(v39.__r_.__value_.__r.__words[2]);
    if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v39.__r_.__value_.__l.__size_;
    }
    if (!size) {
      std::string::assign(&v39, "Local");
    }
    uint64_t v6 = &qword_102419000;
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_1022C1820);
    }
    uint64_t v7 = &qword_102419000;
    uint64_t v8 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100103240();
      uint64_t v9 = v40;
      sub_10073ADA8((uint64_t)v40);
      if (v42[9] < 0) {
        uint64_t v9 = *(unsigned char **)v40;
      }
      uint64_t v10 = sub_100103240();
      sub_10073B1A4(v10, (uint64_t)v37);
      if (v38 >= 0) {
        uint64_t v11 = v37;
      }
      else {
        uint64_t v11 = (void **)v37[0];
      }
      uint64_t v12 = &v39;
      if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v12 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long __p = 136446979;
      *(void *)&__p[4] = v9;
      __int16 v48 = 2081;
      *(void *)uint64_t v49 = v11;
      *(_WORD *)&v49[8] = 2082;
      *(void *)&v49[10] = v12;
      *(_WORD *)&v49[18] = 1026;
      *(_DWORD *)&v49[20] = 10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "@ClxVersion, Timer, os, %{public}s, model, %{private}s, build, %{public}s, triage, %{public}d", __p, 0x26u);
      if (v38 < 0) {
        operator delete(v37[0]);
      }
      if ((v42[9] & 0x80000000) != 0) {
        operator delete(*(void **)v40);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022C1820);
      }
      sub_100103240();
      __int16 v30 = v37;
      sub_10073ADA8((uint64_t)v37);
      if (v38 < 0) {
        __int16 v30 = (void **)v37[0];
      }
      uint64_t v31 = sub_100103240();
      sub_10073B1A4(v31, (uint64_t)v35);
      if (v36 >= 0) {
        __int16 v32 = v35;
      }
      else {
        __int16 v32 = (void **)v35[0];
      }
      uint64_t v33 = &v39;
      if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v33 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int16 v40 = 136446979;
      *(void *)&v40[4] = v30;
      __int16 v41 = 2081;
      *(void *)__int16 v42 = v32;
      *(_WORD *)&v42[8] = 2082;
      *(void *)&v42[10] = v33;
      *(_WORD *)&v42[18] = 1026;
      *(_DWORD *)&v42[20] = 10;
      __int16 v34 = (char *)_os_log_send_and_compose_impl();
      if (v36 < 0) {
        operator delete(v35[0]);
      }
      if (v38 < 0) {
        operator delete(v37[0]);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::checkStateLogging()", "%s\n", v34);
      if (v34 != __p) {
        free(v34);
      }
    }
    for (uint64_t i = 0; i != 312; i += 24)
    {
      uint64_t v14 = a1 + i;
      double v15 = *(double *)(a1 + i + 1632);
      if (v3 - v15 > 900.0)
      {
        if (v15 >= 1.0) {
          double v16 = v3 - v15;
        }
        else {
          double v16 = -1.0;
        }
        if (v6[116] != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022C1820);
        }
        uint64_t v17 = v7[117];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = v6;
          uint64_t v19 = *(void *)(v14 + 1616);
          int v20 = *(unsigned __int8 *)(a1 + i + 1624);
          uint64_t v21 = *(void *)(v14 + 1632);
          uint64_t v22 = sub_10016BA10();
          double v23 = sub_10018202C(v22);
          *(_DWORD *)long long __p = 136447490;
          *(void *)&__p[4] = v19;
          __int16 v48 = 1026;
          *(_DWORD *)uint64_t v49 = v20;
          *(_WORD *)&v49[4] = 2050;
          *(void *)&v49[6] = v21;
          *(_WORD *)&v49[14] = 2050;
          *(double *)&v49[16] = v16;
          __int16 v50 = 2050;
          double v51 = v3;
          __int16 v52 = 2050;
          double v53 = v23;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "@ClxSnapshot, %{public}s, %{public}d, last, %{public}.1f, delta, %{public}.1f, now, %{public}.3f, propagation_us, %{public}.3f", __p, 0x3Au);
          uint64_t v6 = v18;
          uint64_t v7 = &qword_102419000;
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (v6[116] != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022C1820);
          }
          uint64_t v24 = *(void *)(v14 + 1616);
          int v25 = *(unsigned __int8 *)(a1 + i + 1624);
          uint64_t v26 = *(void *)(v14 + 1632);
          uint64_t v27 = sub_10016BA10();
          double v28 = sub_10018202C(v27);
          *(_DWORD *)__int16 v40 = 136447490;
          *(void *)&v40[4] = v24;
          __int16 v41 = 1026;
          *(_DWORD *)__int16 v42 = v25;
          *(_WORD *)&v42[4] = 2050;
          *(void *)&v42[6] = v26;
          *(_WORD *)&v42[14] = 2050;
          *(double *)&v42[16] = v16;
          __int16 v43 = 2050;
          double v44 = v3;
          __int16 v45 = 2050;
          double v46 = v28;
          uint64_t v29 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::checkStateLogging()", "%s\n", v29);
          uint64_t v7 = &qword_102419000;
          if (v29 != __p) {
            free(v29);
          }
        }
      }
    }
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v39.__r_.__value_.__l.__data_);
    }
  }
}

void sub_10015964C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001596CC(uint64_t a1, int a2, uint64_t a3, double a4)
{
  int v232 = a2;
  if (!a2)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    __int16 v32 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "LocationController,#Warning, not notifying clients when provider is None", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    *(_WORD *)v233 = 0;
    goto LABEL_294;
  }
  uint64_t v9 = a1 + 248;
  uint64_t v8 = *(void *)(a1 + 248);
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v10 = a1 + 248;
  uint64_t v11 = *(void *)(a1 + 248);
  do
  {
    int v12 = *(_DWORD *)(v11 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      uint64_t v14 = (uint64_t *)v11;
    }
    else {
      uint64_t v14 = (uint64_t *)(v11 + 8);
    }
    if (!v13) {
      uint64_t v10 = v11;
    }
    uint64_t v11 = *v14;
  }
  while (*v14);
  if (v10 == v9 || *(_DWORD *)(v10 + 32) > a2) {
LABEL_12:
  }
    uint64_t v10 = a1 + 248;
  double v15 = (int *)(a1 + 232);
  if (!v8) {
    goto LABEL_23;
  }
  int v16 = *v15;
  uint64_t v17 = a1 + 248;
  uint64_t v18 = *(void *)(a1 + 248);
  do
  {
    int v19 = *(_DWORD *)(v18 + 32);
    BOOL v20 = v19 < v16;
    if (v19 >= v16) {
      uint64_t v21 = (uint64_t *)v18;
    }
    else {
      uint64_t v21 = (uint64_t *)(v18 + 8);
    }
    if (!v20) {
      uint64_t v17 = v18;
    }
    uint64_t v18 = *v21;
  }
  while (*v21);
  if (v17 == v9 || v16 < *(_DWORD *)(v17 + 32)) {
LABEL_23:
  }
    uint64_t v17 = a1 + 248;
  if (!v8) {
    goto LABEL_34;
  }
  int v22 = *(_DWORD *)(a1 + 236);
  uint64_t v23 = a1 + 248;
  do
  {
    int v24 = *(_DWORD *)(v8 + 32);
    BOOL v25 = v24 < v22;
    if (v24 >= v22) {
      uint64_t v26 = (uint64_t *)v8;
    }
    else {
      uint64_t v26 = (uint64_t *)(v8 + 8);
    }
    if (!v25) {
      uint64_t v23 = v8;
    }
    uint64_t v8 = *v26;
  }
  while (*v26);
  if (v23 == v9 || v22 < *(_DWORD *)(v23 + 32)) {
LABEL_34:
  }
    uint64_t v23 = a1 + 248;
  if (objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLDaemonStatus"), "syncgetIsSleeping")&& !*(unsigned char *)(v10 + 903))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    __int16 v43 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "LocationController,#Warning, not notifying clients when device is sleeping", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    *(_WORD *)v233 = 0;
    goto LABEL_294;
  }
  if (a2 == 4 && sub_10067B51C(a1, v10, v17, a4))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v27 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "LocationController,#Warning, not notifying clients in WiFi to GPS transition", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    *(_WORD *)v233 = 0;
LABEL_294:
    uint64_t v140 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v140);
    if (v140 == buf) {
      return 0;
    }
LABEL_295:
    free(v140);
    return 0;
  }
  char v230 = (uint64_t **)(v9 - 8);
  double v28 = *(double *)(a1 + 680);
  double v29 = sub_10015BFE0(v10 + 96, v28);
  double v30 = sub_10015BFE0(v23 + 96, v28);
  uint64_t v225 = v17 + 96;
  double v31 = sub_10015BFE0(v17 + 96, v28);
  BOOL v229 = *(_DWORD *)(a1 + 336) == a2 && *(_DWORD *)(v10 + 228) == 2;
  if (*v15 && *v15 != a2 && !*(unsigned char *)(v10 + 903))
  {
    int v33 = *(char *)(v10 + 900);
    if (v33 <= *(char *)(v17 + 900) && a4 - *(double *)(v17 + 172) < *(double *)(v17 + 184))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      __int16 v34 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v35 = *(void *)(v10 + 100);
        char v36 = *(const char **)(v10 + 108);
        *(void *)buf = &v232;
        uint64_t v37 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        char v38 = v37 + 6;
        if (*((char *)v37 + 71) < 0) {
          char v38 = (void *)*v38;
        }
        *(_DWORD *)buf = 134284035;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&unsigned char buf[12] = 2049;
        double v254 = v36;
        __int16 v255 = 2082;
        v256 = v38;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "Got,lat,%{private}.7f,lon,%{private}.7f,for non-active location provider,%{public}s,ignoring", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      uint64_t v39 = *(void *)(v10 + 100);
      __int16 v40 = *(const char **)(v10 + 108);
      *(void *)v233 = &v232;
      __int16 v41 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      __int16 v42 = v41 + 6;
      if (*((char *)v41 + 71) < 0) {
        __int16 v42 = (void *)*v42;
      }
LABEL_232:
      *(_DWORD *)v233 = 134284035;
      *(void *)&v233[4] = v39;
      *(_WORD *)&v233[12] = 2049;
      v234 = v40;
      __int16 v235 = 2082;
      v236 = v42;
      uint64_t v140 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v140);
      if (v140 == buf) {
        return 0;
      }
      goto LABEL_295;
    }
    if (v33 <= 0)
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      double v134 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v135 = *(void *)(v10 + 100);
        uint64_t v136 = *(const char **)(v10 + 108);
        *(void *)buf = &v232;
        int v137 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        int v138 = v137 + 6;
        if (*((char *)v137 + 71) < 0) {
          int v138 = (void *)*v138;
        }
        *(_DWORD *)buf = 134284035;
        *(void *)&uint8_t buf[4] = v135;
        *(_WORD *)&unsigned char buf[12] = 2049;
        double v254 = v136;
        __int16 v255 = 2082;
        v256 = v138;
        _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEBUG, "Got,lat,%{private}.7f,lon,%{private}.7f,for non-active location provider,%{public}s,ignoring", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      uint64_t v39 = *(void *)(v10 + 100);
      __int16 v40 = *(const char **)(v10 + 108);
      *(void *)v233 = &v232;
      __int16 v139 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      __int16 v42 = v139 + 6;
      if (*((char *)v139 + 71) < 0) {
        __int16 v42 = (void *)*v42;
      }
      goto LABEL_232;
    }
  }
  uint64_t v226 = v10 + 96;
  uint64_t v228 = a3;
  v231 = (int *)(a1 + 236);
  double v46 = *(double *)(v10 + 172);
  if (a4 - v46 < 0.0)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v47 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = *(void *)(v10 + 100);
      uint64_t v49 = *(const char **)(v10 + 108);
      *(void *)buf = &v232;
      __int16 v50 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      double v51 = v50 + 6;
      if (*((char *)v50 + 71) < 0) {
        double v51 = (void *)*v51;
      }
      double v52 = a4 - *(double *)(v10 + 172);
      *(_DWORD *)buf = 134284547;
      *(void *)&uint8_t buf[4] = v48;
      *(_WORD *)&unsigned char buf[12] = 2049;
      double v254 = v49;
      __int16 v255 = 2082;
      v256 = v51;
      __int16 v257 = 2050;
      double v258 = v52;
      __int16 v259 = 2050;
      *(double *)float v260 = a4;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning,Got future,lat,%{private}.7f,lon,%{private}.7f,from provider,%{public}s,age,%{public}.3fs,correcting to,%{public}.3fs", buf, 0x34u);
      double v15 = (int *)(a1 + 232);
      a3 = v228;
    }
    if (sub_10013D1A0(115, 2))
    {
      v223 = v15;
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      uint64_t v167 = *(void *)(v10 + 100);
      __int16 v168 = *(const char **)(v10 + 108);
      *(void *)v233 = &v232;
      uint64_t v169 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      __int16 v170 = v169 + 6;
      if (*((char *)v169 + 71) < 0) {
        __int16 v170 = (void *)*v170;
      }
      double v171 = a4 - *(double *)(v10 + 172);
      *(_DWORD *)v233 = 134284547;
      *(void *)&v233[4] = v167;
      *(_WORD *)&v233[12] = 2049;
      v234 = v168;
      __int16 v235 = 2082;
      v236 = v170;
      __int16 v237 = 2050;
      double v238 = v171;
      __int16 v239 = 2050;
      *(double *)uint64_t v240 = a4;
      __int16 v172 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v172);
      if (v172 != buf) {
        free(v172);
      }
      double v15 = v223;
      a3 = v228;
    }
    *(double *)(v10 + 172) = a4;
    double v46 = a4;
  }
  double v53 = *(double *)(v10 + 184);
  if (v53 >= 0.0 && vabdd_f64(a4, v46) > v53)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    __int16 v54 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(void *)buf = &v232;
      uint64_t v55 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      __int16 v56 = v55 + 6;
      if (*((char *)v55 + 71) < 0) {
        __int16 v56 = (void *)*v56;
      }
      double v57 = *(const char **)(v10 + 100);
      __int16 v58 = *(void **)(v10 + 108);
      double v59 = a4 - *(double *)(v10 + 172);
      uint64_t v60 = *(void *)(v10 + 184);
      *(_DWORD *)buf = 136447235;
      *(void *)&uint8_t buf[4] = v56;
      *(_WORD *)&unsigned char buf[12] = 2049;
      double v254 = v57;
      __int16 v255 = 2049;
      v256 = v58;
      __int16 v257 = 2050;
      double v258 = v59;
      __int16 v259 = 2050;
      *(void *)float v260 = v60;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "expiredLocation,provider,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,age,%{public}.3fs,lifespan,%{public}.1fs,(not throwing away)", buf, 0x34u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(void *)v233 = &v232;
      uint64_t v180 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      __int16 v181 = v180 + 6;
      if (*((char *)v180 + 71) < 0) {
        __int16 v181 = (void *)*v181;
      }
      uint64_t v182 = *(const char **)(v10 + 100);
      __int16 v183 = *(void **)(v10 + 108);
      double v184 = a4 - *(double *)(v10 + 172);
      uint64_t v185 = *(void *)(v10 + 184);
      *(_DWORD *)v233 = 136447235;
      *(void *)&v233[4] = v181;
      *(_WORD *)&v233[12] = 2049;
      v234 = v182;
      __int16 v235 = 2049;
      v236 = v183;
      __int16 v237 = 2050;
      double v238 = v184;
      __int16 v239 = 2050;
      *(void *)uint64_t v240 = v185;
      int v186 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v186);
      if (v186 != buf) {
        free(v186);
      }
      a3 = v228;
    }
  }
  if (*(unsigned char *)(v10 + 903))
  {
    uint64_t v61 = (_DWORD *)(a1 + 236);
    if (!*v231
      || *v231 != v232 && *(_DWORD *)(v23 + 180) <= *(_DWORD *)(v10 + 180)
      || (double v62 = *(double *)(v23 + 184), v62 >= 0.0) && v62 + *(double *)(v23 + 172) < a4)
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      uint64_t v63 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        *(void *)buf = &v232;
        __int16 v64 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        uint64_t v65 = v64 + 6;
        if (*((char *)v64 + 71) < 0) {
          uint64_t v65 = (void *)*v65;
        }
        int v66 = *(_DWORD *)(a3 + 84);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v65;
        *(_WORD *)&unsigned char buf[12] = 1026;
        LODWORD(v254) = v66;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEBUG, "current most confident provider,%{public}s,conf,%{public}d", buf, 0x12u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        *(void *)v233 = &v232;
        int v173 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
        __int16 v174 = v173 + 6;
        if (*((char *)v173 + 71) < 0) {
          __int16 v174 = (void *)*v174;
        }
        int v175 = *(_DWORD *)(v228 + 84);
        *(_DWORD *)v233 = 136446466;
        *(void *)&v233[4] = v174;
        *(_WORD *)&v233[12] = 1026;
        LODWORD(v234) = v175;
        __int16 v176 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v176);
        if (v176 != buf) {
          free(v176);
        }
        uint64_t v61 = (_DWORD *)(a1 + 236);
      }
      *uint64_t v61 = v232;
      uint64_t v23 = v10;
    }
  }
  else
  {
    uint64_t v61 = (_DWORD *)(a1 + 236);
  }
  if (!*v15) {
    goto LABEL_155;
  }
  int v67 = *(_DWORD *)(a1 + 336);
  BOOL v68 = v229;
  if (v232 != v67) {
    BOOL v68 = 0;
  }
  if (v68) {
    goto LABEL_155;
  }
  if (v232 != *v15)
  {
    double v69 = *(double *)(v17 + 184);
    if (v69 < 0.0 || a4 - *(double *)(v17 + 172) <= v69)
    {
      if (*(_DWORD *)(v10 + 180) <= *(_DWORD *)(v17 + 180))
      {
        sub_1000F1268((double *)(a1 + 120), v226, v225);
        double v84 = v115;
        if (v29 >= v31)
        {
          int v85 = v15;
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          uint64_t v143 = qword_102419388;
          if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
          {
            *(void *)buf = &v232;
            int v144 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            __int16 v145 = v144 + 6;
            if (*((char *)v144 + 71) < 0) {
              __int16 v145 = (void *)*v145;
            }
            __int16 v146 = *(const char **)(v10 + 100);
            __int16 v147 = *(void **)(v10 + 108);
            int v148 = *(_DWORD *)(v10 + 180);
            *(void *)buf = v85;
            uint64_t v149 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            __int16 v150 = v149 + 6;
            if (*((char *)v149 + 71) < 0) {
              __int16 v150 = (void *)*v150;
            }
            uint64_t v151 = *(void *)(v17 + 100);
            uint64_t v152 = *(void *)(v17 + 108);
            int v153 = *(_DWORD *)(v17 + 180);
            *(_DWORD *)buf = 136317699;
            *(void *)&uint8_t buf[4] = v145;
            *(_WORD *)&unsigned char buf[12] = 2049;
            double v254 = v146;
            __int16 v255 = 2049;
            v256 = v147;
            __int16 v257 = 2050;
            double v258 = v29;
            __int16 v259 = 1026;
            *(_DWORD *)float v260 = v148;
            *(_WORD *)&v260[4] = 2082;
            *(void *)&v260[6] = v150;
            __int16 v261 = 2049;
            uint64_t v262 = v151;
            __int16 v263 = 2049;
            uint64_t v264 = v152;
            __int16 v265 = 2050;
            double v266 = v31;
            __int16 v267 = 1026;
            int v268 = v153;
            __int16 v269 = 2050;
            double v270 = v84;
            _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEBUG, "new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser than current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding", buf, 0x68u);
          }
          if (!sub_10013D1A0(115, 2)) {
            goto LABEL_275;
          }
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          *(void *)v233 = &v232;
          __int16 v154 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
          uint64_t v128 = v154 + 6;
          if (*((char *)v154 + 71) < 0) {
            uint64_t v128 = (void *)*v128;
          }
          int v129 = *(const char **)(v10 + 100);
          uint64_t v130 = *(void **)(v10 + 108);
          int v131 = *(_DWORD *)(v10 + 180);
          *(void *)v233 = v85;
          uint64_t v155 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
          uint64_t v133 = v155 + 6;
          if (*((char *)v155 + 71) < 0) {
            uint64_t v133 = (void *)*v133;
          }
        }
        else
        {
          uint64_t v44 = 1;
          if (v115 < 5000.0 || v115 < v31 * 4.0) {
            goto LABEL_156;
          }
          int v85 = v15;
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          int v116 = qword_102419388;
          if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)buf = &v232;
            int v117 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            uint64_t v118 = v117 + 6;
            if (*((char *)v117 + 71) < 0) {
              uint64_t v118 = (void *)*v118;
            }
            __int16 v119 = *(const char **)(v10 + 100);
            uint64_t v120 = *(void **)(v10 + 108);
            int v121 = *(_DWORD *)(v10 + 180);
            *(void *)buf = v85;
            double v122 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            uint64_t v123 = v122 + 6;
            if (*((char *)v122 + 71) < 0) {
              uint64_t v123 = (void *)*v123;
            }
            uint64_t v124 = *(void *)(v17 + 100);
            uint64_t v125 = *(void *)(v17 + 108);
            int v126 = *(_DWORD *)(v17 + 180);
            *(_DWORD *)buf = 136317699;
            *(void *)&uint8_t buf[4] = v118;
            *(_WORD *)&unsigned char buf[12] = 2049;
            double v254 = v119;
            __int16 v255 = 2049;
            v256 = v120;
            __int16 v257 = 2050;
            double v258 = v29;
            __int16 v259 = 1026;
            *(_DWORD *)float v260 = v121;
            *(_WORD *)&v260[4] = 2082;
            *(void *)&v260[6] = v123;
            __int16 v261 = 2049;
            uint64_t v262 = v124;
            __int16 v263 = 2049;
            uint64_t v264 = v125;
            __int16 v265 = 2050;
            double v266 = v31;
            __int16 v267 = 1026;
            int v268 = v126;
            __int16 v269 = 2050;
            double v270 = v84;
            _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning,new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding", buf, 0x68u);
          }
          if (!sub_10013D1A0(115, 2)) {
            goto LABEL_275;
          }
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          *(void *)v233 = &v232;
          uint64_t v127 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
          uint64_t v128 = v127 + 6;
          if (*((char *)v127 + 71) < 0) {
            uint64_t v128 = (void *)*v128;
          }
          int v129 = *(const char **)(v10 + 100);
          uint64_t v130 = *(void **)(v10 + 108);
          int v131 = *(_DWORD *)(v10 + 180);
          *(void *)v233 = v85;
          uint64_t v132 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
          uint64_t v133 = v132 + 6;
          if (*((char *)v132 + 71) < 0) {
            uint64_t v133 = (void *)*v133;
          }
        }
      }
      else
      {
        if (v232 == v67) {
          goto LABEL_155;
        }
        sub_1000F1268((double *)(a1 + 120), v226, v225);
        if (v29 <= v31) {
          goto LABEL_155;
        }
        double v84 = v83;
        if (v83 > 5000.0 && v83 > v29 * 4.0 && *(_DWORD *)(v10 + 180) - *(_DWORD *)(v17 + 180) >= 5)
        {
          int v85 = v15;
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          uint64_t v86 = qword_102419388;
          if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)buf = &v232;
            uint64_t v87 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            double v88 = v87 + 6;
            if (*((char *)v87 + 71) < 0) {
              double v88 = (void *)*v88;
            }
            __int16 v89 = *(const char **)(v10 + 100);
            uint64_t v90 = *(void **)(v10 + 108);
            int v91 = *(_DWORD *)(v10 + 180);
            *(void *)buf = v85;
            uint64_t v92 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            double v93 = v92 + 6;
            if (*((char *)v92 + 71) < 0) {
              double v93 = (void *)*v93;
            }
            uint64_t v94 = *(void *)(v17 + 100);
            uint64_t v95 = *(void *)(v17 + 108);
            int v96 = *(_DWORD *)(v17 + 180);
            *(_DWORD *)buf = 136448771;
            *(void *)&uint8_t buf[4] = v88;
            *(_WORD *)&unsigned char buf[12] = 2049;
            double v254 = v89;
            __int16 v255 = 2049;
            v256 = v90;
            __int16 v257 = 2050;
            double v258 = v29;
            __int16 v259 = 1026;
            *(_DWORD *)float v260 = v91;
            *(_WORD *)&v260[4] = 2082;
            *(void *)&v260[6] = v93;
            __int16 v261 = 2049;
            uint64_t v262 = v94;
            __int16 v263 = 2049;
            uint64_t v264 = v95;
            __int16 v265 = 2050;
            double v266 = v31;
            __int16 v267 = 1026;
            int v268 = v96;
            __int16 v269 = 2050;
            double v270 = v84;
            _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,notifying", buf, 0x68u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419380 != -1) {
              dispatch_once(&qword_102419380, &stru_1022C17A0);
            }
            *(void *)v233 = &v232;
            v212 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
            uint64_t v213 = v212 + 6;
            if (*((char *)v212 + 71) < 0) {
              uint64_t v213 = (void *)*v213;
            }
            int v214 = *(const char **)(v10 + 100);
            int v215 = *(void **)(v10 + 108);
            int v216 = *(_DWORD *)(v10 + 180);
            *(void *)v233 = v85;
            int v217 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
            int v218 = v217 + 6;
            if (*((char *)v217 + 71) < 0) {
              int v218 = (void *)*v218;
            }
            uint64_t v219 = *(void *)(v17 + 100);
            uint64_t v220 = *(void *)(v17 + 108);
            int v221 = *(_DWORD *)(v17 + 180);
            *(_DWORD *)v233 = 136448771;
            *(void *)&v233[4] = v213;
            *(_WORD *)&v233[12] = 2049;
            v234 = v214;
            __int16 v235 = 2049;
            v236 = v215;
            __int16 v237 = 2050;
            double v238 = v29;
            __int16 v239 = 1026;
            *(_DWORD *)uint64_t v240 = v216;
            *(_WORD *)&v240[4] = 2082;
            *(void *)&v240[6] = v218;
            __int16 v241 = 2049;
            uint64_t v242 = v219;
            __int16 v243 = 2049;
            uint64_t v244 = v220;
            __int16 v245 = 2050;
            double v246 = v31;
            __int16 v247 = 1026;
            int v248 = v221;
            __int16 v249 = 2050;
            double v250 = v84;
            v222 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v222);
            if (v222 != buf) {
              free(v222);
            }
          }
          uint64_t v44 = 1;
          goto LABEL_276;
        }
        int v85 = v15;
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        __int16 v156 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
        {
          *(void *)buf = &v232;
          double v157 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
          __int16 v158 = v157 + 6;
          if (*((char *)v157 + 71) < 0) {
            __int16 v158 = (void *)*v158;
          }
          double v159 = *(const char **)(v10 + 100);
          __int16 v160 = *(void **)(v10 + 108);
          int v161 = *(_DWORD *)(v10 + 180);
          *(void *)buf = v85;
          __int16 v162 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
          uint64_t v163 = v162 + 6;
          if (*((char *)v162 + 71) < 0) {
            uint64_t v163 = (void *)*v163;
          }
          uint64_t v164 = *(void *)(v17 + 100);
          uint64_t v165 = *(void *)(v17 + 108);
          int v166 = *(_DWORD *)(v17 + 180);
          *(_DWORD *)buf = 136317699;
          *(void *)&uint8_t buf[4] = v158;
          *(_WORD *)&unsigned char buf[12] = 2049;
          double v254 = v159;
          __int16 v255 = 2049;
          v256 = v160;
          __int16 v257 = 2050;
          double v258 = v29;
          __int16 v259 = 1026;
          *(_DWORD *)float v260 = v161;
          *(_WORD *)&v260[4] = 2082;
          *(void *)&v260[6] = v163;
          __int16 v261 = 2049;
          uint64_t v262 = v164;
          __int16 v263 = 2049;
          uint64_t v264 = v165;
          __int16 v265 = 2050;
          double v266 = v31;
          __int16 v267 = 1026;
          int v268 = v166;
          __int16 v269 = 2050;
          double v270 = v84;
          _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEBUG, "new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser and agrees with current,%{public}s, lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding", buf, 0x68u);
        }
        if (!sub_10013D1A0(115, 2))
        {
LABEL_275:
          uint64_t v44 = 0;
LABEL_276:
          double v15 = v85;
          goto LABEL_156;
        }
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        *(void *)v233 = &v232;
        int v206 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
        uint64_t v128 = v206 + 6;
        if (*((char *)v206 + 71) < 0) {
          uint64_t v128 = (void *)*v128;
        }
        int v129 = *(const char **)(v10 + 100);
        uint64_t v130 = *(void **)(v10 + 108);
        int v131 = *(_DWORD *)(v10 + 180);
        *(void *)v233 = v85;
        __int16 v207 = sub_100151D38(v230, v85, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
        uint64_t v133 = v207 + 6;
        if (*((char *)v207 + 71) < 0) {
          uint64_t v133 = (void *)*v133;
        }
      }
      uint64_t v208 = *(void *)(v17 + 100);
      uint64_t v209 = *(void *)(v17 + 108);
      int v210 = *(_DWORD *)(v17 + 180);
      *(_DWORD *)v233 = 136317699;
      *(void *)&v233[4] = v128;
      *(_WORD *)&v233[12] = 2049;
      v234 = v129;
      __int16 v235 = 2049;
      v236 = v130;
      __int16 v237 = 2050;
      double v238 = v29;
      __int16 v239 = 1026;
      *(_DWORD *)uint64_t v240 = v131;
      *(_WORD *)&v240[4] = 2082;
      *(void *)&v240[6] = v133;
      __int16 v241 = 2049;
      uint64_t v242 = v208;
      __int16 v243 = 2049;
      uint64_t v244 = v209;
      __int16 v245 = 2050;
      double v246 = v31;
      __int16 v247 = 1026;
      int v248 = v210;
      __int16 v249 = 2050;
      double v250 = v84;
      long long v211 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v211);
      if (v211 != buf) {
        free(v211);
      }
      goto LABEL_275;
    }
  }
  if (v232 == *v61)
  {
LABEL_155:
    uint64_t v44 = 1;
    goto LABEL_156;
  }
  sub_1000F1268((double *)(a1 + 120), v226, v23 + 96);
  double v71 = v70;
  uint64_t v44 = 1;
  if (v70 > 5000.0
    && v70 > v29 * 4.0
    && v70 > v30 * 4.0
    && v70 > (*(double *)(v10 + 172) - *(double *)(v23 + 172)) * 50.0
    && *(_DWORD *)(v23 + 180) - *(_DWORD *)(v10 + 180) >= 5)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    __int16 v72 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)buf = &v232;
      int v73 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      __int16 v74 = v73 + 6;
      if (*((char *)v73 + 71) < 0) {
        __int16 v74 = (void *)*v74;
      }
      int v75 = *(const char **)(v10 + 100);
      __int16 v76 = *(void **)(v10 + 108);
      int v227 = *(_DWORD *)(v10 + 180);
      *(void *)buf = a1 + 236;
      int v77 = sub_100151D38(v230, v231, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      __int16 v78 = v77 + 6;
      if (*((char *)v77 + 71) < 0) {
        __int16 v78 = (void *)*v78;
      }
      uint64_t v79 = *(void *)(v23 + 100);
      uint64_t v80 = *(void *)(v23 + 108);
      int v81 = *(_DWORD *)(v23 + 180);
      double v82 = a4 - *(double *)(v23 + 172);
      *(_DWORD *)buf = 136449027;
      *(void *)&uint8_t buf[4] = v74;
      *(_WORD *)&unsigned char buf[12] = 2049;
      double v254 = v75;
      __int16 v255 = 2049;
      v256 = v76;
      __int16 v257 = 2050;
      double v258 = v29;
      __int16 v259 = 1026;
      *(_DWORD *)float v260 = v227;
      *(_WORD *)&v260[4] = 2082;
      *(void *)&v260[6] = v78;
      __int16 v261 = 2049;
      uint64_t v262 = v79;
      __int16 v263 = 2049;
      uint64_t v264 = v80;
      __int16 v265 = 2050;
      double v266 = v30;
      __int16 v267 = 1026;
      int v268 = v81;
      __int16 v269 = 2050;
      double v270 = v82;
      __int16 v271 = 2050;
      double v272 = v71;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with confident,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,age,%{public}.3f,distance,%{public}.2f,discarding", buf, 0x72u);
    }
    if (sub_10013D1A0(115, 2))
    {
      v224 = v15;
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(void *)v233 = &v232;
      __int16 v193 = sub_100151D38(v230, &v232, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      uint64_t v194 = v193 + 6;
      if (*((char *)v193 + 71) < 0) {
        uint64_t v194 = (void *)*v194;
      }
      __int16 v195 = *(const char **)(v10 + 100);
      uint64_t v196 = *(void **)(v10 + 108);
      int v197 = *(_DWORD *)(v10 + 180);
      *(void *)v233 = a1 + 236;
      uint64_t v198 = sub_100151D38(v230, v231, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      __int16 v199 = v198 + 6;
      if (*((char *)v198 + 71) < 0) {
        __int16 v199 = (void *)*v199;
      }
      uint64_t v200 = *(void *)(v23 + 100);
      uint64_t v201 = *(void *)(v23 + 108);
      int v202 = *(_DWORD *)(v23 + 180);
      double v203 = a4 - *(double *)(v23 + 172);
      *(_DWORD *)v233 = 136449027;
      *(void *)&v233[4] = v194;
      *(_WORD *)&v233[12] = 2049;
      v234 = v195;
      __int16 v235 = 2049;
      v236 = v196;
      __int16 v237 = 2050;
      double v238 = v29;
      __int16 v239 = 1026;
      *(_DWORD *)uint64_t v240 = v197;
      *(_WORD *)&v240[4] = 2082;
      *(void *)&v240[6] = v199;
      __int16 v241 = 2049;
      uint64_t v242 = v200;
      __int16 v243 = 2049;
      uint64_t v244 = v201;
      __int16 v245 = 2050;
      double v246 = v30;
      __int16 v247 = 1026;
      int v248 = v202;
      __int16 v249 = 2050;
      double v250 = v203;
      __int16 v251 = 2050;
      double v252 = v71;
      int v204 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v204);
      if (v204 != buf) {
        free(v204);
      }
      uint64_t v44 = 0;
      double v15 = v224;
    }
    else
    {
      uint64_t v44 = 0;
    }
  }
LABEL_156:
  if (!*(unsigned char *)(v10 + 903)) {
    return v44;
  }
  *(unsigned char *)(v10 + 902) = 0;
  double v97 = *(double *)(v10 + 184);
  if (v97 < 0.0)
  {
    uint64_t v98 = *(void **)(a1 + 656);
    double v99 = 1.79769313e308;
LABEL_163:
    [v98 setNextFireDelay:v99];
    goto LABEL_164;
  }
  if (v17 == v9 || v97 > *(double *)(v17 + 184) - (a4 - *(double *)(v17 + 172)))
  {
    [*(id *)(a1 + 656) nextFireDelay];
    if (v100 != 1.79769313e308)
    {
      uint64_t v98 = *(void **)(a1 + 656);
      double v99 = *(double *)(v10 + 184) + 15.0;
      goto LABEL_163;
    }
  }
LABEL_164:
  int v101 = *(char *)(v10 + 900);
  int v102 = *(char *)(a1 + 160);
  if (v101 >= v102)
  {
    uint64_t v103 = v15;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    double v104 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(void *)buf = v103;
      uint64_t v105 = sub_100151D38(v230, v103, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      uint64_t v106 = v105 + 6;
      if (*((char *)v105 + 71) < 0) {
        uint64_t v106 = (void *)*v106;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v106;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEBUG, "reached the granularity, stopping all providers finer than current,%{public}s ", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(void *)v233 = v103;
      double v177 = sub_100151D38(v230, v103, (uint64_t)&unk_101D0B290, (_DWORD **)v233);
      v178 = v177 + 6;
      if (*((char *)v177 + 71) < 0) {
        v178 = (void *)*v178;
      }
      *(_DWORD *)v233 = 136446210;
      *(void *)&v233[4] = v178;
      __int16 v179 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v179);
      if (v179 != buf) {
        free(v179);
      }
    }
    sub_1001A5708(a1, (unsigned char *)(v10 + 900));
    LOBYTE(v101) = *(unsigned char *)(v10 + 900);
    LOBYTE(v102) = *(unsigned char *)(a1 + 160);
    double v15 = v103;
  }
  if ((char)v101 > (char)v102 || !*(unsigned char *)(a1 + 216))
  {
LABEL_185:
    if (!v44) {
      return v44;
    }
    goto LABEL_186;
  }
  if (v232 == *(_DWORD *)(a1 + 336))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v107 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v108 = *(unsigned __int8 *)(v228 + 516);
      *(_DWORD *)buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v229;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v108;
      _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "got accessory,stopping everything less preferred,isShifted,%{public}d,isPropagatedSolution,%{public}d\n", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      int v188 = *(unsigned __int8 *)(v228 + 516);
      *(_DWORD *)v233 = 67240448;
      *(_DWORD *)&v233[4] = v229;
      *(_WORD *)&v233[8] = 1026;
      *(_DWORD *)&v233[10] = v188;
      __int16 v189 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v189);
      if (v189 != buf) {
        free(v189);
      }
    }
    buf[0] = 5;
    if (*(unsigned char *)(v228 + 516)) {
      char v109 = 1;
    }
    else {
      char v109 = v229;
    }
    sub_100008AC4(a1, buf, v109);
    goto LABEL_185;
  }
  if (!v44) {
    return v44;
  }
  if (v232 == *(_DWORD *)(a1 + 328) && *(_DWORD *)(v10 + 192) == 9)
  {
    int v112 = v15;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    double v113 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEBUG, "stopping all providers below coarse gps", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(_WORD *)v233 = 0;
      __int16 v205 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v205);
      if (v205 != buf) {
        free(v205);
      }
    }
    buf[0] = 0;
    uint64_t v114 = buf;
  }
  else
  {
    int v112 = v15;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    int v141 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEBUG, "stopping all providers below newIter", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      *(_WORD *)v233 = 0;
      double v192 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v192);
      if (v192 != buf) {
        free(v192);
      }
    }
    uint64_t v114 = (unsigned char *)(v10 + 901);
  }
  sub_100008AC4(a1, v114, 0);
  double v15 = v112;
LABEL_186:
  if (*v15 != v232)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v110 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      if (v10 == v9)
      {
        uint64_t v111 = "(none)";
      }
      else
      {
        uint64_t v111 = (const char *)(v10 + 48);
        if (*(char *)(v10 + 71) < 0) {
          uint64_t v111 = *(const char **)v111;
        }
      }
      if (v17 == v9)
      {
        int v142 = "(none)";
      }
      else
      {
        int v142 = (const char *)(v17 + 48);
        if (*(char *)(v17 + 71) < 0) {
          int v142 = *(const char **)v142;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = v111;
      *(_WORD *)&unsigned char buf[12] = 2082;
      double v254 = v142;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEBUG, "changing to provider,%{public}s,from,%{public}s", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      if (v10 == v9)
      {
        __int16 v187 = "(none)";
      }
      else
      {
        __int16 v187 = (const char *)(v10 + 48);
        if (*(char *)(v10 + 71) < 0) {
          __int16 v187 = *(const char **)v187;
        }
      }
      if (v17 == v9)
      {
        uint64_t v190 = "(none)";
      }
      else
      {
        uint64_t v190 = (const char *)(v17 + 48);
        if (*(char *)(v17 + 71) < 0) {
          uint64_t v190 = *(const char **)v190;
        }
      }
      *(_DWORD *)v233 = 136446466;
      *(void *)&v233[4] = v187;
      *(_WORD *)&v233[12] = 2082;
      v234 = v190;
      __int16 v191 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationController::shouldNotify(CFAbsoluteTime, LocationProvider, const CLLocationProvider_Type::NotificationData &)", "%s\n", v191);
      if (v191 != buf) {
        free(v191);
      }
    }
    int *v15 = v232;
  }
  return 1;
}

double sub_10015BFE0(uint64_t a1, double a2)
{
  int v2 = *(_DWORD *)(a1 + 128);
  double v3 = *(double *)(a1 + 20);
  int v4 = *(_DWORD *)(a1 + 96);
  if (v4 == 10 && v2 == 75 && v3 > 0.0)
  {
    double result = v3 * a2;
    double v6 = 0.038;
    goto LABEL_9;
  }
  if (v4 == 11 && v2 == 75 && v3 > 0.0)
  {
    double result = v3 * a2;
    double v6 = 0.042;
LABEL_9:
    if (result <= v6) {
      return v6;
    }
    return result;
  }
  double result = 20.0;
  if (v3 >= 20.0 || v3 <= 0.0 || v4 != 4) {
    return *(double *)(a1 + 20);
  }
  return result;
}

uint64_t sub_10015D8A4(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  double v6 = (void *)sub_100054C14(a1, a2, a3, a4, a5);
  *double v6 = off_1022B3C88;
  v6[6] = 0;
  v6[7] = 0;
  *(unsigned char *)(a1 + 64) = +[CLFenceManagerAdapter isSupported];
  *(unsigned char *)(a1 + 65) = 0;
  sub_1000E9354(a1 + 72);
  sub_100134750(&__p, (char *)[objc_msgSend(*(id *)(a1 + 24), "legacyClientKey") UTF8String]);
  if (*(void *)sub_1001ABCA8(a1)) {
    sub_10015DBD8();
  }
  if (*(unsigned char *)(a1 + 64))
  {
    sub_1001ABD68(a1);
    sub_10015DBD8();
  }
  if (v9 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_10015DB00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10013F3C4(v16);
  uint64_t v19 = *(void *)(v15 + 56);
  *(void *)(v15 + 56) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *v17;
  *uint64_t v17 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  sub_100029A7C(v15);
  _Unwind_Resume(a1);
}

void sub_10015DBD8()
{
}

void sub_10015DCA8()
{
}

void sub_10015DCCC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  double v6 = *(double *)a2;
  *(void *)(a1 + 2224) = *(void *)a2;
  if (*(double *)(a1 + 2232) == 0.0) {
    *(double *)(a1 + 2232) = v6;
  }
  long long v111 = 0u;
  long long v112 = 0u;
  double v110 = v6;
  LODWORD(v111) = *(_DWORD *)(a2 + 52);
  *((void *)&v111 + 1) = *(void *)(a2 + 40);
  *(void *)&long long v112 = *(void *)(a2 + 32);
  BYTE8(v112) = *(unsigned char *)(a2 + 48);
  sub_10017DA48((void *)(a1 + 2248), (uint64_t)&v110);
  *(void *)(a1 + 2376) = *(void *)(a1 + 2368);
  unsigned int v7 = *(unsigned __int16 *)(a1 + 26);
  if (*(_DWORD *)(a1 + 28) == v7)
  {
    sub_100176E04(a1, *(double *)(a1 + 24 + 24 * *(unsigned __int16 *)(a1 + 24) + 8));
    unsigned int v7 = *(unsigned __int16 *)(a1 + 26);
  }
  int v108 = 0;
  uint64_t v107 = 0;
  uint64_t v109 = 0;
  int v33 = a3;
  if (v7)
  {
    unint64_t v8 = *(unsigned __int16 *)(a1 + 24) + (unint64_t)v7 - 1;
    unint64_t v9 = *(unsigned int *)(a1 + 28);
    if (v8 < v9) {
      unint64_t v9 = 0;
    }
    double v10 = *(double *)(a1 + 24 + 24 * (v8 - v9) + 8);
  }
  else
  {
    double v10 = 0.0;
  }
  uint64_t v11 = (void *)(*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 2392) + 24) + 32))(*(void *)(*(void *)(a1 + 2392) + 24));
  sub_100186918(v11, (char **)&v107, v10, *(double *)a2);
  int v12 = v107;
  BOOL v13 = v108;
  if (v107 != v108)
  {
    uint64_t v14 = (unsigned __int16 *)(a1 + 24);
    uint64_t v15 = v94;
    uint64_t v16 = a1 + 32;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v36 = _Q0;
    __int16 v34 = v108;
    do
    {
      *((void *)&v104 + 1) = v12[3];
      int v105 = *((_DWORD *)v12 + 54);
      *(void *)&long long v104 = *v12;
      long long v37 = xmmword_101D1C570;
      __int16 v46 = 0;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      memset(v45, 0, sizeof(v45));
      unint64_t v47 = 0xBFF0000000000000;
      int v48 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      uint64_t v69 = 0;
      unint64_t v49 = 0xBFF0000000000000;
      unint64_t v70 = 0xBFF0000000000000;
      uint64_t v71 = 0;
      unint64_t v72 = 0xBFF0000000000000;
      int v83 = 0;
      uint64_t v84 = 0;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      int v78 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      memset(v82, 0, sizeof(v82));
      unint64_t v85 = 0xBFF0000000000000;
      uint64_t v86 = 0;
      uint64_t v87 = 0;
      uint64_t v88 = 0x80000000800000;
      uint64_t v89 = 0;
      uint64_t v90 = 0;
      long long v91 = xmmword_101D1E260;
      uint64_t v92 = 0x80000000800000;
      unint64_t v93 = 0xBFF0000000000000;
      v15[1] = 0;
      v15[2] = 0;
      void *v15 = 0;
      int v22 = v15;
      v94[3] = 0xBFF0000000000000;
      memset(&v94[4], 0, 24);
      v94[7] = 0xBFF0000000000000;
      long long v95 = 0u;
      long long v96 = 0u;
      uint64_t v97 = 0;
      unint64_t v98 = 0xBFF0000000000000;
      uint64_t v99 = 0x600000006;
      long long __p = 0;
      int v101 = 0;
      uint64_t v102 = 0;
      long long v103 = v36;
      uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 2392) + 24) + 16))(*(void *)(*(void *)(a1 + 2392) + 24));
      sub_1001865E0(v23, &v37, *(double *)v12);
      int v106 = DWORD2(v38);
      sub_1001886E4((unsigned __int16 *)(a1 + 24), &v104);
      if (*(_DWORD *)(a1 + 28) == *(unsigned __int16 *)(a1 + 26))
      {
        for (uint64_t i = 2160; i != 2224; i += 8)
        {
          if ((sub_10015E344(*(uint64_t **)(a1 + i), (unsigned __int16 *)(a1 + 24)) & 1) != 0
            && *(double *)(v16 + 24 * *v14) >= v25)
          {
            uint64_t v26 = *(void *)(a1 + i);
            if (*(void *)(v26 + 72)) {
              sub_10015E508(v26 + 48, v25);
            }
          }
        }
        double v27 = *(double *)(a1 + 2296);
        double v28 = *(double *)(v16 + 24 * *(unsigned __int16 *)(a1 + 24));
        if (v27 > v28 && *(void *)(a1 + 2368) == *(void *)(a1 + 2376))
        {
          *(void *)buf = *(void *)(a1 + 2336);
          v118[0] = v27;
          sub_1001771A4((double *)a1, (double *)buf, v28);
        }
        int v35 = *(unsigned __int8 *)(a1 + 16);
        if (qword_1024194F0 != -1) {
          dispatch_once(&qword_1024194F0, &stru_1023268F0);
        }
        double v29 = qword_1024194F8;
        if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_INFO))
        {
          uint64_t v30 = *(void *)(v16 + 24 * *v14);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v35;
          LOWORD(v118[0]) = 2048;
          *(void *)((char *)v118 + 2) = v30;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "DaylightEstimator,state,%d,startTime,%f", buf, 0x12u);
        }
        BOOL v13 = v34;
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024194F0 != -1) {
            dispatch_once(&qword_1024194F0, &stru_1023268F0);
          }
          uint64_t v31 = *(void *)(v16 + 24 * *v14);
          int v113 = 67109376;
          int v114 = v35;
          __int16 v115 = 2048;
          uint64_t v116 = v31;
          __int16 v32 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLDaylightEstimator::Result> CLDaylightEstimator::update(const CLOutdoor_Type::OutdoorUpdate &)", "%s\n", v32);
          if (v32 != (char *)buf) {
            free(v32);
          }
          BOOL v13 = v34;
        }
      }
      if (__p)
      {
        int v101 = __p;
        operator delete(__p);
      }
      if ((void)v96)
      {
        *((void *)&v96 + 1) = v96;
        operator delete((void *)v96);
      }
      *(void *)buf = v22;
      sub_1000D7F78((void ***)buf);
      uint64_t v15 = v22;
      v12 += 40;
    }
    while (v12 != v13);
  }
  *int v33 = 0;
  v33[1] = 0;
  v33[2] = 0;
  sub_10017C680(v33, *(const void **)(a1 + 2368), *(void *)(a1 + 2376), (uint64_t)(*(void *)(a1 + 2376) - *(void *)(a1 + 2368)) >> 4);
  if (v107)
  {
    int v108 = v107;
    operator delete(v107);
  }
}

void sub_10015E300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_100AD787C((uint64_t)&a29);
  uint64_t v30 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v30;
    operator delete(v30);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10015E344(uint64_t *a1, unsigned __int16 *a2)
{
  if (*a1 >= (unint64_t)a2[1]) {
    uint64_t v2 = a2[1];
  }
  else {
    uint64_t v2 = *a1;
  }
  if (!v2) {
    return 0;
  }
  int v5 = 0;
  unint64_t v6 = 0;
  uint64_t v7 = 1;
  double v8 = -1.0;
  while (1)
  {
    uint64_t v9 = sub_10015E6B0(a2, v6);
    uint64_t v10 = a1[5];
    if (!v10) {
      sub_10015E48C();
    }
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v9))
    {
      if (v8 == -1.0) {
        double v8 = v11;
      }
      if (++v5 >= *((_DWORD *)a1 + 2)) {
        break;
      }
    }
    if (v2 == ++v6) {
      return 0;
    }
  }
  return v7;
}

BOOL sub_10015E434(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 16) || *(_DWORD *)(a2 + 20) == 128;
}

uint64_t sub_10015E468(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)(a2 + 20) == 128;
  }
  int v3 = v2;
  return v3 ^ 1u;
}

void sub_10015E48C()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = &off_10229E350;
}

BOOL sub_10015E4D8(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) == 1;
}

BOOL sub_10015E4F0(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) != 1;
}

uint64_t sub_10015E508(uint64_t a1, double a2)
{
  double v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10015E48C();
  }
  return (*(uint64_t (**)(uint64_t, double *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_10015E55C(uint64_t result, double a2, double a3)
{
  if (*(_WORD *)(result + 26))
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(result + 24);
    double v8 = (int32x2_t *)(result + 2452);
    do
    {
      double result = sub_10015E6B0(v7, v6);
      if (*(double *)result >= a2)
      {
        double result = sub_10015E6B0(v7, v6);
        if (*(double *)result <= a3)
        {
          if (*(_DWORD *)(sub_10015E6B0(v7, v6) + 16)) {
            int v9 = *(_DWORD *)(v5 + 2444) + 1;
          }
          else {
            int v9 = *(_DWORD *)(v5 + 2444);
          }
          *(_DWORD *)(v5 + 2444) = v9;
          ++*(_DWORD *)(v5 + 2440);
          unsigned int v10 = *(_DWORD *)(sub_10015E6B0(v7, v6) + 20);
          *double v8 = vsub_s32(*v8, vceq_s32(vdup_n_s32(v10), (int32x2_t)0x100000080));
          int v11 = 1;
          if (v10 != 256 && v10 != 512) {
            int v11 = v10 == 4096;
          }
          *(_DWORD *)(v5 + 2448) += v11;
          double result = sub_10015E6B0(v7, v6);
          int v12 = *(double *)result >= *(double *)(v5 + 2352) && *(double *)result <= *(double *)(v5 + 2360);
          *(_DWORD *)(v5 + 2460) += v12;
        }
      }
      ++v6;
    }
    while (v6 < *(unsigned __int16 *)(v5 + 26));
  }
  return result;
}

uint64_t sub_10015E6B0(unsigned __int16 *a1, unint64_t a2)
{
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1023272B0);
    }
    uint64_t v7 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1023272B0);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "const T &CMQueue<CLDaylightEstimator::StepsAndActivity>::operator[](const size_t) const [T = CLDaylightEstimator::StepsAndActivity]", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[12 * (v4 - v5) + 4];
}

void sub_10015E8B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v11 = [[CLOSTransaction alloc] initWithDescription:"CLTilesManager::traverseAllTilesSets"];
  for (unsigned int i = 0; i != 13; ++i)
  {
    if ((i & 0x7FFFFFF7) - 1 <= 1)
    {
      uint64_t v7 = sub_10015EB2C(a1, i);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230D000);
      }
      int v8 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = v7 + 8;
        if (*(char *)(v7 + 31) < 0) {
          uint64_t v9 = *(void *)(v7 + 8);
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v13 = a2;
        __int16 v14 = 2080;
        uint64_t v15 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "TILE: performing, sAction, %s, tilesSet, %s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_10230D000);
        }
        unsigned int v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLTilesManager::traverseAllTilesSets(const char *, CLTileManagerTraverseTilesSetBlock)", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
      }
      (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v7);
    }
  }
}

uint64_t sub_10015EB2C(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0xFFFFFFF7) - 1 >= 2)
  {
    sub_101A9E488();
LABEL_5:
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10230CFE0);
    }
    unint64_t v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      unsigned int v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TileMgr, invalid tileType, %{public}d, #CloneMe", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10230CFE0);
      }
      int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLTilesSet &CLTilesManager::getTilesSet(CLTilesManager_Type::TileType)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230D000);
    }
    unint64_t v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230D000);
      }
    }
    unint64_t v6 = qword_102419388;
    if (os_signpost_enabled((os_log_t)qword_102419388))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230D000);
      }
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  unsigned int v2 = a2;
  uint64_t result = sub_10015F2DC((void *)(a1 + 504), a2);
  if (!result) {
    goto LABEL_5;
  }
  return result;
}

uint64_t sub_10015EF24(unsigned int a1, void *a2)
{
  uint64_t result = sub_10015F2DC(a2, a1);
  if (!result)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10231A310);
    }
    unint64_t v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      unsigned int v10 = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TileMgr, invalid tileType, %{public}d, #CloneMe", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10231A310);
      }
      int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "static CLTilesSet &CLTilesManagerUtility::getTilesSet(CLTilesManager_Type::TileType, CLTilesSetCollection *)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10231A330);
    }
    unint64_t v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10231A330);
      }
    }
    unint64_t v6 = qword_102419388;
    if (os_signpost_enabled((os_log_t)qword_102419388))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10231A330);
      }
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      unsigned int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "assert";
      __int16 v15 = 2081;
      uint64_t v16 = "false";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  return result;
}

uint64_t sub_10015F2DC(void *a1, unsigned int a2)
{
  if (a2 >= 0xD) {
    sub_101AAE4B4();
  }
  if (a2 >= (unint64_t)((uint64_t)(a1[1] - *a1) >> 3))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10231FE88);
    }
    unint64_t v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v6;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      int v22 = "index < fTileSets.size()";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Index out of bounds\", \"index\":%{private}d, \"size\":%{private}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x36u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10231FE88);
      }
    }
    uint64_t v7 = qword_102419388;
    if (os_signpost_enabled((os_log_t)qword_102419388))
    {
      uint64_t v8 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v8;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      int v22 = "index < fTileSets.size()";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Index out of bounds", "{\"msg%{public}.0s\":\"Index out of bounds\", \"index\":%{private}d, \"size\":%{private}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x36u);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10231FE88);
      }
    }
    uint64_t v9 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v10;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      int v22 = "index < fTileSets.size()";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Index out of bounds\", \"index\":%{private}d, \"size\":%{private}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x36u);
    }
    abort_report_np();
  }
  return *(void *)(*a1 + 8 * a2);
}

void sub_10015F5DC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 == 1)
  {
    sub_100103240();
    int v6 = sub_10015F760();
    int v5 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    int v6 = 1;
  }
  if (v5 == 2)
  {
    sub_100103240();
    v6 &= sub_10015F760();
    int v5 = *(_DWORD *)(a2 + 4);
  }
  if ((*(_DWORD *)(a2 + 148) & 0x80000000) == 0 && v5 != 9 && v6 != 0)
  {
    __int16 v14 = 0;
    unint64_t v15 = 0xBFF0000000000000;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    __int16 v18 = 1;
    int v16 = *(_DWORD *)(a2 + 148);
    char v13 = *(unsigned char *)(a2 + 177);
    unsigned int v8 = *(_DWORD *)(a2 + 4);
    uint64_t v9 = *(void *)(a1 + 40);
    double v10 = *(double *)(v9 + 4);
    double v11 = *(double *)(v9 + 12);
    sub_100134750(&__p, "");
    sub_1001392EC(v4, v8, -1, &__p, (uint64_t)&v13, v10, v11, *(double *)(a1 + 48));
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_10015F6EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10015F708()
{
  if ((sub_1000FFFBC() & 1) != 0
    || (sub_1000FFF30() & 1) != 0
    || sub_100119A30()
    || sub_1000FFC30() && !sub_100119998())
  {
    return 1;
  }

  return sub_10073C6AC();
}

void sub_10015FB88(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  long long v7 = *(_OWORD *)(a2 + 112);
  long long v97 = *(_OWORD *)(a2 + 96);
  long long v98 = v7;
  v99[0] = *(_OWORD *)(a2 + 128);
  *(_OWORD *)((char *)v99 + 12) = *(_OWORD *)(a2 + 140);
  long long v8 = *(_OWORD *)(a2 + 48);
  long long v94 = *(_OWORD *)(a2 + 32);
  long long v95 = v8;
  long long v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)long long v96 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v96[16] = v9;
  long long v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v93 = *(_OWORD *)a2;
  *(_OWORD *)&v93[16] = v10;
  sub_1001B1B04((uint64_t)v93);
  sub_1001AFB78(a1 + 904, (long long *)v93);
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_1022F7C40);
  }
  double v11 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
  {
    sub_1000AB340((uint64_t)v93);
    int v12 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    int v13 = *(unsigned __int8 *)(a1 + 612);
    int v14 = *(unsigned __int8 *)(a1 + 728);
    int v15 = *(unsigned __int8 *)(a1 + 730);
    *(_DWORD *)buf = 136381443;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 1025;
    *(_DWORD *)&unsigned char buf[14] = v13;
    *(_WORD *)&buf[18] = 1025;
    *(_DWORD *)&buf[20] = v14;
    *(_WORD *)&unsigned char buf[24] = 1025;
    *(_DWORD *)&buf[26] = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Fence: handleLocation, location, %{private}s, services, %{private}d, airplane, %{private}d, connected, %{private}d", buf, 0x1Eu);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    sub_1000AB340((uint64_t)v93);
    if (v92 >= 0) {
      long long v63 = &v90;
    }
    else {
      long long v63 = v90;
    }
    int v64 = *(unsigned __int8 *)(a1 + 612);
    int v65 = *(unsigned __int8 *)(a1 + 728);
    int v66 = *(unsigned __int8 *)(a1 + 730);
    *(_DWORD *)std::string __p = 136381443;
    *(void *)&__p[4] = v63;
    *(_WORD *)&unsigned char __p[12] = 1025;
    *(_DWORD *)&__p[14] = v64;
    *(_WORD *)&__p[18] = 1025;
    *(_DWORD *)&__p[20] = v65;
    LOWORD(v101) = 1025;
    *(_DWORD *)((char *)&v101 + 2) = v66;
    long long v67 = (char *)_os_log_send_and_compose_impl();
    if (v92 < 0) {
      operator delete(v90);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v67);
    if (v67 != buf) {
      free(v67);
    }
  }
  if (!*(unsigned char *)(a1 + 612) || *(unsigned char *)(a1 + 730) && !*(unsigned char *)(a1 + 731))
  {
    (*(void (**)(void))(**(void **)(a1 + 1768) + 344))(*(void *)(a1 + 1768));
    (*(void (**)(void))(**(void **)(a1 + 1768) + 280))(*(void *)(a1 + 1768));
    return;
  }
  sub_1001B1A94((void *)(a1 + 1312), a2);
  if ((sub_1001BC804(a1, (uint64_t)v93, a4) & 1) == 0)
  {
    *(void *)(a1 + 672) = *(void *)(a2 + 76);
    if (!*(void *)(a1 + 256) || sub_1001ABEB0((uint64_t)v93))
    {
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      int v16 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v17 = *(void *)(a1 + 256);
        __int16 v18 = sub_10003E9A4(v97);
        *(_DWORD *)buf = 134349315;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2081;
        *(void *)&unsigned char buf[14] = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Fence: cancelLocationWatchdog, num fences, %{public}lu, location type, %{private}s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        }
        uint64_t v70 = *(void *)(a1 + 256);
        uint64_t v71 = sub_10003E9A4(v97);
        *(_DWORD *)std::string __p = 134349315;
        *(void *)&__p[4] = v70;
        *(_WORD *)&unsigned char __p[12] = 2081;
        *(void *)&__p[14] = v71;
        unint64_t v72 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v72);
        if (v72 != buf) {
          free(v72);
        }
      }
      (*(void (**)(void))(**(void **)(a1 + 1768) + 344))(*(void *)(a1 + 1768));
      (*(void (**)(void))(**(void **)(a1 + 1768) + 280))(*(void *)(a1 + 1768));
      *(void *)(a1 + 684) = 0;
    }
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    __int16 v19 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134284289;
      *(void *)&uint8_t buf[4] = *(void *)&v93[4];
      *(_WORD *)&unsigned char buf[12] = 2049;
      *(void *)&unsigned char buf[14] = *(void *)&v93[12];
      *(_WORD *)&buf[22] = 2049;
      *(void *)&unsigned char buf[24] = *(void *)&v93[20];
      LOWORD(v105) = 2049;
      *(void *)((char *)&v105 + 2) = *(void *)&v96[12];
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Fence: Handling location, %{private}+.8f, %{private}+.8f, acc, %{private}.2f, timestamp, %{private}.1lf\n", buf, 0x2Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      *(_DWORD *)std::string __p = 134284289;
      *(void *)&__p[4] = *(void *)&v93[4];
      *(_WORD *)&unsigned char __p[12] = 2049;
      *(void *)&__p[14] = *(void *)&v93[12];
      *(_WORD *)&__p[22] = 2049;
      uint64_t v101 = *(void *)&v93[20];
      __int16 v102 = 2049;
      uint64_t v103 = *(void *)&v96[12];
      long long v68 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v68);
      if (v68 != buf) {
        free(v68);
      }
    }
    int v20 = *(unsigned __int8 *)(a1 + 623);
    sub_1000F1268((double *)(a1 + 1776), a1 + 448, (uint64_t)v93);
    double v22 = v21;
    BOOL v85 = sub_100163620((uint64_t)v93);
    unsigned int v23 = v97;
    BOOL v83 = sub_1001ABF10((uint64_t)v93);
    BOOL v82 = sub_100163620(a1 + 448);
    int v24 = *(_DWORD *)(a1 + 544);
    BOOL v25 = v24 == 4 || v24 == 11;
    char v26 = v25;
    char v81 = v26;
    if (v83) {
      *(double *)(a1 + 880) = a4;
    }
    if (v23 == 11 || v23 == 4) {
      *(double *)(a1 + 888) = a4;
    }
    int v27 = v85;
    if (v23 == 10) {
      int v27 = 1;
    }
    char v80 = v27;
    if (v27 == 1) {
      *(double *)(a1 + 896) = a4;
    }
    int v84 = v97;
    if (vabdd_f64(a4, *(double *)(a1 + 524)) >= *((double *)sub_100044B44() + 27)
      || v22 >= *((double *)sub_100044B44() + 28))
    {
      BOOL v29 = 1;
    }
    else
    {
      double v28 = *(double *)(a1 + 468);
      if (v28 < *((double *)sub_100044B44() + 29))
      {
        BOOL v79 = 0;
LABEL_49:
        double v89 = 5000000.0;
        if (*sub_10016363C() && *(double *)&v93[20] <= 250.0)
        {
          uint64_t v30 = *(void *)(a1 + 208);
          if (v30
            && *(double *)&v96[12] <= *(double *)(*(void *)(*(void *)(a1 + 176)
                                                            + 8 * ((v30 + *(void *)(a1 + 200) - 1) / 0x1AuLL))
                                                + 156 * ((v30 + *(void *)(a1 + 200) - 1) % 0x1AuLL)
                                                + 76)
                                    + 10.0)
          {
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            uint64_t v31 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "not caching location newer than threshold", buf, 2u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193C0 != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              *(_WORD *)std::string __p = 0;
              long long v74 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v74);
              if (v74 != buf) {
                free(v74);
              }
            }
          }
          else
          {
            sub_10017DEF8((void *)(a1 + 168), (uint64_t)v93);
          }
          unint64_t v32 = *(void *)(a1 + 208);
          if (v32 >= *((int *)sub_10016363C() + 12))
          {
            do
            {
              *(int64x2_t *)(a1 + 200) = vaddq_s64(*(int64x2_t *)(a1 + 200), (int64x2_t)xmmword_101D0A740);
              sub_10041F9E4(a1 + 168, 1);
              unint64_t v33 = *(void *)(a1 + 208);
            }
            while (v33 >= *((int *)sub_10016363C() + 12));
          }
        }
        sub_100182574((void *)(a1 + 48), &v90);
        __int16 v34 = v90;
        if (v90)
        {
          ++*((_DWORD *)v90 + 13);
          if ((v97 - 6) > 2)
          {
            if (v97 == 11 || v97 == 4)
            {
              ++v34[25];
            }
            else if ((v97 & 0xFFFFFFF7) == 1)
            {
              ++v34[26];
            }
          }
          else
          {
            ++v34[24];
          }
        }
        int v35 = *(void **)(a1 + 240);
        BOOL v87 = v20 != 0;
        if (v35 != (void *)(a1 + 248))
        {
          int v36 = 0;
          int v86 = 0;
          char v37 = (v24 != 10) & ~(v82 | v81);
          if (v24 == 13) {
            char v37 = 0;
          }
          char v38 = v37 | v80 ^ 1 | v79;
          double v39 = 5000000.0;
          while (1)
          {
            if (*((unsigned char *)v35 + 284))
            {
              if (!*(unsigned char *)(a1 + 730)) {
                goto LABEL_79;
              }
              if (v35[33] == v35[32])
              {
                if (_os_feature_enabled_impl()) {
                  goto LABEL_100;
                }
                uint64_t v40 = 64;
              }
              else
              {
                uint64_t v40 = 8;
              }
              if ((v35[24] & v40) != 0)
              {
LABEL_79:
                long long v109 = v97;
                long long v110 = v98;
                v111[0] = v99[0];
                *(_OWORD *)((char *)v111 + 12) = *(_OWORD *)((char *)v99 + 12);
                long long v105 = v94;
                long long v106 = v95;
                long long v107 = *(_OWORD *)v96;
                long long v108 = *(_OWORD *)&v96[16];
                *(_OWORD *)buf = *(_OWORD *)v93;
                *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)&v93[16];
                if (*((_DWORD *)v35 + 53) == 2) {
                  sub_100DC90C0(a1, (uint64_t)(v35 + 4), (uint64_t)buf);
                }
                double v41 = sub_1001ABE28((uint64_t)buf, (uint64_t)(v35 + 4), (double *)(a1 + 1776));
                double v89 = fmin(v41, v89);
                int v42 = *((_DWORD *)v35 + 70);
                double v43 = fmin(v41, v39);
                if (v42) {
                  double v39 = v43;
                }
                if (v42 == -1
                  || (v42 != 1 || !v85 && (v23 > 0xB || ((1 << v23) & 0xC10) == 0) && v84 != 13 || v41 < 50000.0)
                  && ((v38 & 1) != 0 || *(_DWORD *)(a1 + 684) || sub_10018252C((void *)(a1 + 48))))
                {
                  if ((v35[24] & 0x20) == 0)
                  {
                    BOOL v44 = v41 <= 25000.0 || *((_DWORD *)v35 + 70) == -1;
                    int v45 = v86;
                    if (v44) {
                      int v45 = v86 + 1;
                    }
                    int v86 = v45;
                  }
                  long long v46 = v98;
                  *(_OWORD *)(a1 + 544) = v97;
                  *(_OWORD *)(a1 + 560) = v46;
                  *(_OWORD *)(a1 + 576) = v99[0];
                  *(_OWORD *)(a1 + 588) = *(_OWORD *)((char *)v99 + 12);
                  long long v47 = v95;
                  *(_OWORD *)(a1 + 480) = v94;
                  *(_OWORD *)(a1 + 496) = v47;
                  long long v48 = *(_OWORD *)&v96[16];
                  *(_OWORD *)(a1 + 512) = *(_OWORD *)v96;
                  *(_OWORD *)(a1 + 528) = v48;
                  long long v49 = *(_OWORD *)&v93[16];
                  *(_OWORD *)(a1 + 448) = *(_OWORD *)v93;
                  *(_OWORD *)(a1 + 464) = v49;
                  sub_1001BCE30(a1, (uint64_t)v93, a3, (unsigned __int8 *)v35 + 32);
                  ++v36;
                  BOOL v87 = 1;
                }
              }
            }
LABEL_100:
            long long v50 = (void *)v35[1];
            if (v50)
            {
              do
              {
                long long v51 = v50;
                long long v50 = (void *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                long long v51 = (void *)v35[2];
                BOOL v25 = *v51 == (void)v35;
                int v35 = v51;
              }
              while (!v25);
            }
            int v35 = v51;
            if (v51 == (void *)(a1 + 248)) {
              goto LABEL_110;
            }
          }
        }
        int v86 = 0;
        int v36 = 0;
        double v39 = 5000000.0;
LABEL_110:
        sub_1001BB78C(a1, a4);
        if (v84 == 13 || v23 == 11 || v23 == 4)
        {
          *(void *)(a1 + 696) = 0;
        }
        else if (v83 && *(void *)(a1 + 256))
        {
          double v55 = *(double *)(a1 + 648);
          if ((*(unsigned int (**)(void))(**(void **)(a1 + 1768) + 16))(*(void *)(a1 + 1768)))
          {
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            long long v56 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v57 = *(void *)(a1 + 256);
              *(_DWORD *)buf = 134349056;
              *(void *)&uint8_t buf[4] = v57;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEBUG, "request a scan to comfirm cell location, fences, %{public}lu", buf, 0xCu);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193C0 != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              uint64_t v75 = *(void *)(a1 + 256);
              *(_DWORD *)std::string __p = 134349056;
              *(void *)&__p[4] = v75;
              long long v76 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v76);
              if (v76 != buf) {
                free(v76);
              }
            }
            if (*(double *)&v93[20] > 1400.0 && v86)
            {
              if (qword_1024193C0 != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              long long v58 = qword_1024193C8;
              if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 67240449;
                *(_DWORD *)&uint8_t buf[4] = v86;
                *(_WORD *)&uint8_t buf[8] = 2049;
                *(double *)&buf[10] = v89;
                _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEBUG, "Fence: requesting a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf", buf, 0x12u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1024193C0 != -1) {
                  dispatch_once(&qword_1024193C0, &stru_1022F7C40);
                }
                *(_DWORD *)std::string __p = 67240449;
                *(_DWORD *)&__p[4] = v86;
                *(_WORD *)&__p[8] = 2049;
                *(double *)&__p[10] = v89;
                int v78 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v78);
                if (v78 != buf) {
                  free(v78);
                }
              }
              (*(void (**)(uint64_t, const char *, void, double))(*(void *)a1 + 96))(a1, "handleLocation.cell2wifi", 0, a4);
              goto LABEL_119;
            }
          }
          else if (v39 <= 25000.0)
          {
            char v61 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 400))(*(void *)(a1 + 1768));
            if (vabdd_f64(a4, v55) <= 756.0) {
              char v62 = 1;
            }
            else {
              char v62 = v61;
            }
            if ((v62 & 1) == 0 && sub_1001BAE50(a1))
            {
              *(double *)(a1 + 648) = a4;
              *(void *)(a1 + 684) = 0x300000001;
              (*(void (**)(void, void *))(**(void **)(a1 + 1768) + 240))(*(void *)(a1 + 1768), &unk_101D8E2D8);
            }
          }
          else
          {
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            long long v60 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 134283521;
              *(double *)&uint8_t buf[4] = v39;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEBUG, "cancelLocationWatchdog, wifi off, minDistance, %{private}lf", buf, 0xCu);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193C0 != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              *(_DWORD *)std::string __p = 134283521;
              *(double *)&__p[4] = v39;
              long long v77 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v77);
              if (v77 != buf) {
                free(v77);
              }
            }
            (*(void (**)(void))(**(void **)(a1 + 1768) + 280))(*(void *)(a1 + 1768));
            *(void *)(a1 + 684) = 0;
          }
        }
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        }
        long long v52 = qword_1024193C8;
        if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67240449;
          *(_DWORD *)&uint8_t buf[4] = v86;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v89;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "Fence: avoid a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf", buf, 0x12u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193C0 != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          *(_DWORD *)std::string __p = 67240449;
          *(_DWORD *)&__p[4] = v86;
          *(_WORD *)&__p[8] = 2049;
          *(double *)&__p[10] = v89;
          uint64_t v69 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v69);
          if (v69 != buf) {
            free(v69);
          }
        }
LABEL_119:
        if (sub_1000FC450())
        {
          sub_1000E9354(buf);
          *(_DWORD *)std::string __p = *(void *)(a1 + 256);
          sub_1000EA838((uint64_t)buf, "fenceUpdate", __p);
          sub_10016332C((uint64_t)buf, "horizontalAccuracy", &v93[20]);
          *(_DWORD *)std::string __p = v36;
          sub_1000EA838((uint64_t)buf, "numOfDispatchedChecks", __p);
          sub_10016332C((uint64_t)buf, "minDistanceToFence", &v89);
          sub_1000FC45C((uint64_t)buf, (uint64_t)"locationd");
          sub_10013F3C4(buf);
        }
        if (v87)
        {
          if (qword_1024193C0 != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          long long v53 = qword_1024193C8;
          if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEBUG, "Fence: Dispatch continuous engagement", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            *(_WORD *)std::string __p = 0;
            long long v73 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocation(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v73);
            if (v73 != buf) {
              free(v73);
            }
          }
          double v54 = v89 - *(double *)&v93[20];
          if (v89 - *(double *)&v93[20] < 0.0) {
            double v54 = 0.0;
          }
          *(double *)(a1 + 736) = v54;
          *(void *)(a1 + 744) = *(void *)&v96[12];
          sub_1001BA5A0(a1, a4);
          (*(void (**)(void))(**(void **)(a1 + 1768) + 120))(*(void *)(a1 + 1768));
        }
        if (!v36 && *(_DWORD *)(a1 + 684) && sub_1001AF7CC(a1 + 904, a4)) {
          sub_100F5F9BC(a1 + 1312);
        }
        if (v91) {
          sub_1000DB0A0(v91);
        }
        return;
      }
      double v59 = *(double *)&v93[20];
      BOOL v29 = v59 < *((double *)sub_100044B44() + 29);
    }
    BOOL v79 = v29;
    goto LABEL_49;
  }
}

void sub_1001612A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a25) {
    sub_1000DB0A0(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_100161300(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_1022F2018);
  }
  int v6 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t buf = 68289539;
    __int16 v14 = 2082;
    int v15 = "";
    __int16 v16 = 1040;
    int v17 = 156;
    __int16 v18 = 2097;
    __int16 v19 = a4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#SLC Got location\", \"location\":%{private, location:CLClientLocation}.*P}", (uint8_t *)&buf, 0x22u);
  }
  long long v7 = a4[7];
  v11[6] = a4[6];
  v11[7] = v7;
  v12[0] = a4[8];
  *(_OWORD *)((char *)v12 + 12) = *(_OWORD *)((char *)a4 + 140);
  long long v8 = a4[3];
  int32x4_t v11[2] = a4[2];
  v11[3] = v8;
  long long v9 = a4[5];
  v11[4] = a4[4];
  v11[5] = v9;
  long long v10 = a4[1];
  v11[0] = *a4;
  v11[1] = v10;
  sub_10016144C(a1, (uint64_t)v11);
}

void sub_10016144C(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 357))
  {
    long long v8 = (double *)(a2 + 20);
    double v9 = *(double *)(a2 + 20);
    if (v9 < 0.0)
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022F2018);
      }
      long long v10 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#SLC Significant location change got invalid location!\"}", buf, 0x12u);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022F2018);
        }
      }
      double v11 = qword_102419538;
      if (os_signpost_enabled((os_log_t)qword_102419538))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#SLC Significant location change got invalid location!", "{\"msg%{public}.0s\":\"#SLC Significant location change got invalid location!\"}", buf, 0x12u);
      }
      return;
    }
    int v12 = *(_DWORD *)(a2 + 96);
    if (v9 >= 20000.0 || (v12 - 9) >= 0xFFFFFFFE)
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022F2018);
      }
      uint64_t v14 = qword_102419538;
      if (!os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
        return;
      }
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      uint64_t v4 = "{\"msg%{public}.0s\":\"#SLC Ignoring inaccurate location\"}";
      goto LABEL_28;
    }
    if (v12 > 8)
    {
      if (v12 == 13)
      {
        if (v9 < 250.0) {
          goto LABEL_42;
        }
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022F2018);
        }
        uint64_t v14 = qword_102419538;
        if (!os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
          return;
        }
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        uint64_t v4 = "{\"msg%{public}.0s\":\"#SLC Ignoring inaccurate LoiOverride location\"}";
        goto LABEL_28;
      }
      if (v12 != 9) {
        goto LABEL_42;
      }
    }
    else if (v12 != 1)
    {
LABEL_35:
      if (v12 == 4 && v9 >= 250.0)
      {
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022F2018);
        }
        uint64_t v14 = qword_102419538;
        if (!os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
          return;
        }
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        uint64_t v4 = "{\"msg%{public}.0s\":\"#SLC Ignoring inaccurate WIFI location\"}";
        goto LABEL_28;
      }
LABEL_42:
      if (!*(unsigned char *)(a1 + 356))
      {
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022F2018);
        }
        int v20 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)uint64_t buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#Warning #SLC Significant location change monitoring not active; not handling\"}",
            buf,
            0x12u);
        }
        sub_1000DB3D4((uint64_t)buf);
        long long v21 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)int v186 = *(_OWORD *)(a2 + 96);
        *(_OWORD *)&v186[16] = v21;
        v187[0] = *(_OWORD *)(a2 + 128);
        *(_OWORD *)((char *)v187 + 12) = *(_OWORD *)(a2 + 140);
        long long v22 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)&unsigned char buf[32] = *(_OWORD *)(a2 + 32);
        *(_OWORD *)&buf[48] = v22;
        long long v23 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)uint64_t v185 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)&v185[16] = v23;
        long long v24 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)uint64_t buf = *(_OWORD *)a2;
        *(_OWORD *)&uint8_t buf[16] = v24;
        int v172 = 0;
        (*(void (**)(uint64_t, int *, unsigned char *))(*(void *)a1 + 136))(a1, &v172, buf);
        sub_100458658((uint64_t)buf);
        return;
      }
      unsigned int v16 = v12 - 6;
      double v17 = 1000.0;
      if (v9 >= 1000.0 || v16 >= 3)
      {
        __int16 v19 = (double *)(a2 + 88);
        if (*(double *)(a2 + 88) >= 0.0) {
          goto LABEL_67;
        }
        if (v9 <= 0.0)
        {
          *__int16 v19 = 0.0;
LABEL_67:
          double v171 = 0.0;
          double Current = CFAbsoluteTimeGetCurrent();
          BOOL v27 = *v8 >= 0.0 && Current - *(double *)(a2 + 76) < 10.0;
          double v28 = Current - *(double *)(a1 + 408);
          double v170 = v28;
          BOOL v29 = (_OWORD *)(a1 + 200);
          double v30 = *(double *)(a1 + 220);
          BOOL v31 = v30 < 0.0;
          if (v30 < 0.0)
          {
            if (qword_102419530 != -1) {
              dispatch_once(&qword_102419530, &stru_1022F2018);
            }
            unint64_t v32 = qword_102419538;
            if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "#SLC got first location, sending SLC notification", buf, 2u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419530 != -1) {
                dispatch_once(&qword_102419530, &stru_1022F2018);
              }
              LOWORD(v172) = 0;
              uint64_t v143 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v143);
              if (v143 != buf) {
                free(v143);
              }
            }
            long long v33 = *(_OWORD *)(a2 + 16);
            *BOOL v29 = *(_OWORD *)a2;
            *(_OWORD *)(a1 + 216) = v33;
            long long v34 = *(_OWORD *)(a2 + 32);
            long long v35 = *(_OWORD *)(a2 + 48);
            long long v36 = *(_OWORD *)(a2 + 80);
            *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 64);
            *(_OWORD *)(a1 + 280) = v36;
            *(_OWORD *)(a1 + 232) = v34;
            *(_OWORD *)(a1 + 248) = v35;
            long long v37 = *(_OWORD *)(a2 + 96);
            long long v38 = *(_OWORD *)(a2 + 112);
            long long v39 = *(_OWORD *)(a2 + 128);
            *(_OWORD *)(a1 + 340) = *(_OWORD *)(a2 + 140);
            *(_OWORD *)(a1 + 312) = v38;
            *(_OWORD *)(a1 + 328) = v39;
            *(_OWORD *)(a1 + 296) = v37;
            *(void *)(a1 + 408) = 0;
            double v40 = 0.0;
            if (v27) {
              goto LABEL_78;
            }
            int v42 = 1;
          }
          else
          {
            sub_1000F1268((double *)(a1 + 120), a2, a1 + 200);
            double v40 = v43;
            double v171 = v43;
            BOOL v44 = (double *)(a1 + 276);
            double v45 = *(double *)(a1 + 276);
            double v46 = *(double *)(a2 + 76);
            if (qword_102419530 != -1)
            {
              double v169 = *(double *)(a2 + 76);
              dispatch_once(&qword_102419530, &stru_1022F2018);
              double v46 = v169;
            }
            double v47 = vabdd_f64(v45, v46);
            long long v48 = qword_102419538;
            if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint64_t buf = 134218496;
              *(double *)&uint8_t buf[4] = v40;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(double *)&unsigned char buf[14] = v47;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&unsigned char buf[24] = 0x3FD5555555555555;
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, "#SLC handleSignificantLocationChange, distance, %.1lf, timeDelta, %.1lf, maxFactor, %.1lf", buf, 0x20u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419530 != -1) {
                dispatch_once(&qword_102419530, &stru_1022F2018);
              }
              int v172 = 134218496;
              int v173 = *(const char **)&v40;
              __int16 v174 = 2048;
              *(double *)int v175 = v47;
              *(_WORD *)&v175[8] = 2048;
              *(void *)&v175[10] = 0x3FD5555555555555;
              int v144 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v144);
              if (v144 != buf) {
                free(v144);
              }
            }
            if (v27)
            {
              if (v40 < 500.0 || (double v49 = *v8, v40 < *v8))
              {
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                long long v50 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v51 = *(void *)(a2 + 4);
                  uint64_t v52 = *(void *)(a2 + 12);
                  uint64_t v53 = *(void *)(a2 + 20);
                  uint64_t v54 = *(void *)(a1 + 204);
                  uint64_t v55 = *(void *)(a1 + 212);
                  uint64_t v56 = *(void *)(a1 + 220);
                  *(_DWORD *)uint64_t buf = 134219520;
                  *(void *)&uint8_t buf[4] = v51;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&unsigned char buf[14] = v52;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v53;
                  *(_WORD *)&unsigned char buf[32] = 2048;
                  *(double *)&buf[34] = v40;
                  *(_WORD *)&buf[42] = 2048;
                  *(void *)&buf[44] = v54;
                  *(_WORD *)&buf[52] = 2048;
                  *(void *)&buf[54] = v55;
                  *(_WORD *)&buf[62] = 2048;
                  *(void *)uint64_t v185 = v56;
                  _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "#SLC <%+.8f,%+.8f> acc %.2f moved only %.2fm from previous significant location <%+.8f,%+.8f> acc %.2f, discarding", buf, 0x48u);
                }
                if (!sub_10013D1A0(115, 2)) {
                  goto LABEL_97;
                }
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                uint64_t v163 = *(const char **)(a2 + 4);
                uint64_t v164 = *(void *)(a2 + 12);
                uint64_t v165 = *(void *)(a2 + 20);
                uint64_t v166 = *(void *)(a1 + 204);
                uint64_t v167 = *(void *)(a1 + 212);
                uint64_t v168 = *(void *)(a1 + 220);
                int v172 = 134219520;
                int v173 = v163;
                __int16 v174 = 2048;
                *(void *)int v175 = v164;
                *(_WORD *)&v175[8] = 2048;
                *(void *)&v175[10] = v165;
                *(_WORD *)&v175[18] = 2048;
                *(double *)&v175[20] = v40;
                *(_WORD *)&v175[28] = 2048;
                *(void *)&v175[30] = v166;
                *(_WORD *)&v175[38] = 2048;
                *(void *)&v175[40] = v167;
                *(_WORD *)&v175[48] = 2048;
                *(void *)__int16 v176 = v168;
                uint64_t v101 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v101);
LABEL_209:
                if (v101 != buf) {
                  free(v101);
                }
LABEL_97:
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                uint64_t v57 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)uint64_t buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEBUG, "#SLC no location change", buf, 2u);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_102419530 != -1) {
                    dispatch_once(&qword_102419530, &stru_1022F2018);
                  }
                  LOWORD(v172) = 0;
                  __int16 v162 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v162);
                  if (v162 != buf) {
                    free(v162);
                  }
                }
                int v42 = 0;
                BOOL v31 = 0;
LABEL_115:
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                int v64 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)uint64_t buf = 68289795;
                  *(_DWORD *)&uint8_t buf[4] = 0;
                  *(_WORD *)&uint8_t buf[8] = 2082;
                  *(void *)&buf[10] = "";
                  *(_WORD *)&buf[18] = 1026;
                  *(_DWORD *)&buf[20] = v42;
                  *(_WORD *)&unsigned char buf[24] = 2049;
                  *(double *)&buf[26] = v40;
                  *(_WORD *)&buf[34] = 2050;
                  *(double *)&buf[36] = v28;
                  _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#SLC Location inspection complete\", \"isSignificantlocationchange\":%{public}hhd, \"distance\":\"%{private}f\", \"secondsSinceLastSLC_s\":\"%{public}.09f\"}", buf, 0x2Cu);
                }
                if (sub_1000FC450())
                {
                  sub_1000E9354(buf);
                  int v172 = v42;
                  sub_1000EA838((uint64_t)buf, "slcUpdate", &v172);
                  sub_10016332C((uint64_t)buf, "distance", &v171);
                  sub_10016332C((uint64_t)buf, "hAcc", v8);
                  sub_10016332C((uint64_t)buf, "secondsSinceLastSLC", &v170);
                  sub_1000FC45C((uint64_t)buf, (uint64_t)"locationd");
                  sub_10013F3C4(buf);
                }
                if (v31)
                {
                  if (qword_102419650 != -1) {
                    dispatch_once(&qword_102419650, &stru_1022F2038);
                  }
                  int v65 = qword_102419658;
                  if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v66 = *(void *)(a2 + 4);
                    uint64_t v67 = *(void *)(a2 + 12);
                    uint64_t v68 = *(void *)(a2 + 20);
                    uint64_t v69 = *(void *)(a2 + 88);
                    int v70 = *(_DWORD *)(a2 + 96);
                    uint64_t v71 = *(void *)(a1 + 204);
                    uint64_t v72 = *(void *)(a1 + 212);
                    uint64_t v73 = *(void *)(a1 + 220);
                    double v74 = *(double *)(a2 + 76) - *(double *)(a1 + 276);
                    *(_DWORD *)uint64_t buf = 136317954;
                    *(void *)&uint8_t buf[4] = "SignificantChange";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&unsigned char buf[14] = 1;
                    *(_WORD *)&buf[18] = 2048;
                    *(void *)&buf[20] = v66;
                    *(_WORD *)&buf[28] = 2048;
                    *(void *)&buf[30] = v67;
                    *(_WORD *)&buf[38] = 2048;
                    *(void *)&buf[40] = v68;
                    *(_WORD *)&buf[48] = 2048;
                    *(void *)&buf[50] = v69;
                    *(_WORD *)&buf[58] = 1024;
                    *(_DWORD *)&buf[60] = v70;
                    *(_WORD *)uint64_t v185 = 2048;
                    *(void *)&v185[2] = v71;
                    *(_WORD *)&v185[10] = 2048;
                    *(void *)&v185[12] = v72;
                    *(_WORD *)&v185[20] = 2048;
                    *(void *)&v185[22] = v73;
                    *(_WORD *)&v185[30] = 2048;
                    *(double *)int v186 = v171;
                    *(_WORD *)&v186[8] = 2048;
                    *(double *)&v186[10] = v74;
                    _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Lifespan,%.2f,LocationType,%d,PrevLocation,%+.8f,%+.8f,%.2f,Distance,%.2f,DeltaTime,%.3f,", buf, 0x72u);
                  }
                  if (sub_10013D1A0(117, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_102419650 != -1) {
                      dispatch_once(&qword_102419650, &stru_1022F2038);
                    }
                    uint64_t v146 = *(void *)(a2 + 4);
                    uint64_t v147 = *(void *)(a2 + 12);
                    uint64_t v148 = *(void *)(a2 + 20);
                    uint64_t v149 = *(void *)(a2 + 88);
                    int v150 = *(_DWORD *)(a2 + 96);
                    uint64_t v151 = *(void *)(a1 + 204);
                    uint64_t v152 = *(void *)(a1 + 212);
                    uint64_t v153 = *(void *)(a1 + 220);
                    double v154 = *(double *)(a2 + 76) - *(double *)(a1 + 276);
                    int v172 = 136317954;
                    int v173 = "SignificantChange";
                    __int16 v174 = 1024;
                    *(_DWORD *)int v175 = 1;
                    *(_WORD *)&v175[4] = 2048;
                    *(void *)&v175[6] = v146;
                    *(_WORD *)&v175[14] = 2048;
                    *(void *)&v175[16] = v147;
                    *(_WORD *)&v175[24] = 2048;
                    *(void *)&v175[26] = v148;
                    *(_WORD *)&v175[34] = 2048;
                    *(void *)&v175[36] = v149;
                    *(_WORD *)&v175[44] = 1024;
                    *(_DWORD *)&v175[46] = v150;
                    *(_WORD *)__int16 v176 = 2048;
                    *(void *)&v176[2] = v151;
                    *(_WORD *)double v177 = 2048;
                    *(void *)&v177[2] = v152;
                    __int16 v178 = 2048;
                    uint64_t v179 = v153;
                    __int16 v180 = 2048;
                    double v181 = v171;
                    __int16 v182 = 2048;
                    double v183 = v154;
                    uint64_t v155 = (char *)_os_log_send_and_compose_impl();
                    sub_1004BA5E4("LOCATION", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v155);
                    if (v155 != buf) {
                      free(v155);
                    }
                  }
                  *(double *)(a1 + 184) = v171;
                  *(double *)(a1 + 192) = *(double *)(a2 + 76) - *(double *)(a1 + 276);
                  long long v75 = *(_OWORD *)(a2 + 140);
                  long long v77 = *(_OWORD *)(a2 + 112);
                  long long v76 = *(_OWORD *)(a2 + 128);
                  *(_OWORD *)(a1 + 296) = *(_OWORD *)(a2 + 96);
                  *(_OWORD *)(a1 + 312) = v77;
                  *(_OWORD *)(a1 + 328) = v76;
                  *(_OWORD *)(a1 + 340) = v75;
                  long long v79 = *(_OWORD *)(a2 + 32);
                  long long v78 = *(_OWORD *)(a2 + 48);
                  long long v80 = *(_OWORD *)(a2 + 80);
                  *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 64);
                  *(_OWORD *)(a1 + 280) = v80;
                  *(_OWORD *)(a1 + 232) = v79;
                  *(_OWORD *)(a1 + 248) = v78;
                  long long v81 = *(_OWORD *)(a2 + 16);
                  *BOOL v29 = *(_OWORD *)a2;
                  *(_OWORD *)(a1 + 216) = v81;
                  *(double *)(a1 + 276) = Current;
                  *(double *)(a1 + 408) = Current;
                  sub_100CF4544(a1);
                }
                return;
              }
              if (*(_DWORD *)(a1 + 296) == *(_DWORD *)(a2 + 96))
              {
                double v82 = *v44;
              }
              else
              {
                double v83 = *(double *)(a1 + 288);
                double v82 = *v44;
                if (v83 >= 0.0 && v83 + v82 > Current)
                {
                  if (qword_102419530 != -1) {
                    dispatch_once(&qword_102419530, &stru_1022F2018);
                  }
                  int v84 = qword_102419538;
                  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v85 = *(void *)(a1 + 204);
                    uint64_t v86 = *(void *)(a1 + 212);
                    uint64_t v87 = *(void *)(a1 + 220);
                    double v88 = *v44;
                    uint64_t v89 = *(void *)(a1 + 288);
                    uint64_t v90 = *(void *)(a2 + 4);
                    uint64_t v91 = *(void *)(a2 + 12);
                    uint64_t v92 = *(void *)(a2 + 20);
                    *(_DWORD *)uint64_t buf = 134219776;
                    *(void *)&uint8_t buf[4] = v85;
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&unsigned char buf[14] = v86;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&unsigned char buf[24] = v87;
                    *(_WORD *)&unsigned char buf[32] = 2048;
                    *(double *)&buf[34] = v88;
                    *(_WORD *)&buf[42] = 2048;
                    *(void *)&buf[44] = v89;
                    *(_WORD *)&buf[52] = 2048;
                    *(void *)&buf[54] = v90;
                    *(_WORD *)&buf[62] = 2048;
                    *(void *)uint64_t v185 = v91;
                    *(_WORD *)&v185[8] = 2048;
                    *(void *)&v185[10] = v92;
                    _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEBUG, "#SLC Lifespan of previous significant location <%+.8f,%+.8f> acc %.2f has not expired (timestamp %.2f, lifespan %.2f), discarding <%+.8f,%+.8f> acc %.2f", buf, 0x52u);
                  }
                  if (!sub_10013D1A0(115, 2)) {
                    goto LABEL_97;
                  }
                  bzero(buf, 0x65CuLL);
                  if (qword_102419530 != -1) {
                    dispatch_once(&qword_102419530, &stru_1022F2018);
                  }
                  unint64_t v93 = *(const char **)(a1 + 204);
                  uint64_t v94 = *(void *)(a1 + 212);
                  uint64_t v95 = *(void *)(a1 + 220);
                  double v96 = *v44;
                  uint64_t v97 = *(void *)(a1 + 288);
                  uint64_t v98 = *(void *)(a2 + 4);
                  uint64_t v99 = *(void *)(a2 + 12);
                  uint64_t v100 = *(void *)(a2 + 20);
                  int v172 = 134219776;
                  int v173 = v93;
                  __int16 v174 = 2048;
                  *(void *)int v175 = v94;
                  *(_WORD *)&v175[8] = 2048;
                  *(void *)&v175[10] = v95;
                  *(_WORD *)&v175[18] = 2048;
                  *(double *)&v175[20] = v96;
                  *(_WORD *)&v175[28] = 2048;
                  *(void *)&v175[30] = v97;
                  *(_WORD *)&v175[38] = 2048;
                  *(void *)&v175[40] = v98;
                  *(_WORD *)&v175[48] = 2048;
                  *(void *)__int16 v176 = v99;
                  *(_WORD *)&v176[8] = 2048;
                  *(void *)double v177 = v100;
                  uint64_t v101 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v101);
                  goto LABEL_209;
                }
              }
              if (vabdd_f64(Current, v82) < 10.0 && *(double *)(a1 + 220) <= v49)
              {
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                uint64_t v130 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
                {
                  double v131 = *v44;
                  uint64_t v132 = *(void *)(a1 + 204);
                  uint64_t v133 = *(void *)(a1 + 212);
                  uint64_t v134 = *(void *)(a2 + 4);
                  uint64_t v135 = *(void *)(a2 + 12);
                  uint64_t v136 = *(void *)(a2 + 20);
                  *(_DWORD *)uint64_t buf = 134219520;
                  *(double *)&uint8_t buf[4] = v131;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&unsigned char buf[14] = v132;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v133;
                  *(_WORD *)&unsigned char buf[32] = 2048;
                  *(void *)&buf[34] = 0x4024000000000000;
                  *(_WORD *)&buf[42] = 2048;
                  *(void *)&buf[44] = v134;
                  *(_WORD *)&buf[52] = 2048;
                  *(void *)&buf[54] = v135;
                  *(_WORD *)&buf[62] = 2048;
                  *(void *)uint64_t v185 = v136;
                  _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEBUG, "#SLC Timestamp %.2f of previous significant location <%+.8f,%+.8f> is less than %.2f seconds ago; di"
                    "scarding <%+.8f,%+.8f> acc %.2f",
                    buf,
                    0x48u);
                }
                if (!sub_10013D1A0(115, 2)) {
                  goto LABEL_97;
                }
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                double v137 = *v44;
                uint64_t v138 = *(void *)(a1 + 204);
                uint64_t v139 = *(void *)(a1 + 212);
                uint64_t v140 = *(void *)(a2 + 4);
                uint64_t v141 = *(void *)(a2 + 12);
                uint64_t v142 = *(void *)(a2 + 20);
                int v172 = 134219520;
                int v173 = *(const char **)&v137;
                __int16 v174 = 2048;
                *(void *)int v175 = v138;
                *(_WORD *)&v175[8] = 2048;
                *(void *)&v175[10] = v139;
                *(_WORD *)&v175[18] = 2048;
                *(void *)&v175[20] = 0x4024000000000000;
                *(_WORD *)&v175[28] = 2048;
                *(void *)&v175[30] = v140;
                *(_WORD *)&v175[38] = 2048;
                *(void *)&v175[40] = v141;
                *(_WORD *)&v175[48] = 2048;
                *(void *)__int16 v176 = v142;
                uint64_t v101 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v101);
                goto LABEL_209;
              }
              if (v47 * 340.0 < v40 && v40 > v49 + *(double *)(a1 + 220))
              {
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                __int16 v102 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v103 = *(void *)(a2 + 4);
                  uint64_t v104 = *(void *)(a2 + 12);
                  uint64_t v105 = *(void *)(a2 + 20);
                  uint64_t v106 = *(void *)(a1 + 204);
                  uint64_t v107 = *(void *)(a1 + 212);
                  uint64_t v108 = *(void *)(a1 + 220);
                  *(_DWORD *)uint64_t buf = 134219776;
                  *(void *)&uint8_t buf[4] = v103;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&unsigned char buf[14] = v104;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v105;
                  *(_WORD *)&unsigned char buf[32] = 2048;
                  *(double *)&buf[34] = v40;
                  *(_WORD *)&buf[42] = 2048;
                  *(void *)&buf[44] = v106;
                  *(_WORD *)&buf[52] = 2048;
                  *(void *)&buf[54] = v107;
                  *(_WORD *)&buf[62] = 2048;
                  *(void *)uint64_t v185 = v108;
                  *(_WORD *)&v185[8] = 2048;
                  *(double *)&v185[10] = v47;
                  _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#Warning #SLC Location <%+.8f,%+.8f> acc %.2f is too far (distance %.2f) from previous location <%+.8f,%+.8f> acc %.2f from %.3fs ago, discarding", buf, 0x52u);
                }
                if (!sub_10013D1A0(115, 2)) {
                  goto LABEL_97;
                }
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                long long v109 = *(const char **)(a2 + 4);
                uint64_t v110 = *(void *)(a2 + 12);
                uint64_t v111 = *(void *)(a2 + 20);
                uint64_t v112 = *(void *)(a1 + 204);
                uint64_t v113 = *(void *)(a1 + 212);
                uint64_t v114 = *(void *)(a1 + 220);
                int v172 = 134219776;
                int v173 = v109;
                __int16 v174 = 2048;
                *(void *)int v175 = v110;
                *(_WORD *)&v175[8] = 2048;
                *(void *)&v175[10] = v111;
                *(_WORD *)&v175[18] = 2048;
                *(double *)&v175[20] = v40;
                *(_WORD *)&v175[28] = 2048;
                *(void *)&v175[30] = v112;
                *(_WORD *)&v175[38] = 2048;
                *(void *)&v175[40] = v113;
                *(_WORD *)&v175[48] = 2048;
                *(void *)__int16 v176 = v114;
                *(_WORD *)&v176[8] = 2048;
                *(double *)double v177 = v47;
                uint64_t v101 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v101);
                goto LABEL_209;
              }
              if (v28 <= 300.0)
              {
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                int v117 = qword_102419538;
                if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v118 = *(void *)(a1 + 204);
                  uint64_t v119 = *(void *)(a1 + 212);
                  uint64_t v120 = *(void *)(a1 + 220);
                  uint64_t v121 = *(void *)(a2 + 4);
                  uint64_t v122 = *(void *)(a2 + 12);
                  uint64_t v123 = *(void *)(a2 + 20);
                  *(_DWORD *)uint64_t buf = 134219520;
                  *(double *)&uint8_t buf[4] = v28;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&unsigned char buf[14] = v118;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v119;
                  *(_WORD *)&unsigned char buf[32] = 2048;
                  *(void *)&buf[34] = v120;
                  *(_WORD *)&buf[42] = 2048;
                  *(void *)&buf[44] = v121;
                  *(_WORD *)&buf[52] = 2048;
                  *(void *)&buf[54] = v122;
                  *(_WORD *)&buf[62] = 2048;
                  *(void *)uint64_t v185 = v123;
                  _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEBUG, "#SLC avoiding too frequent SLC notificaitons, age, %.1f, prev location, <%+.8f,%+.8f>, acc, %.2lf, new location, <%+.8f,%+.8f>, acc, %.2f", buf, 0x48u);
                }
                if (!sub_10013D1A0(115, 2)) {
                  goto LABEL_97;
                }
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                uint64_t v124 = *(void *)(a1 + 204);
                uint64_t v125 = *(void *)(a1 + 212);
                uint64_t v126 = *(void *)(a1 + 220);
                uint64_t v127 = *(void *)(a2 + 4);
                uint64_t v128 = *(void *)(a2 + 12);
                uint64_t v129 = *(void *)(a2 + 20);
                int v172 = 134219520;
                int v173 = *(const char **)&v28;
                __int16 v174 = 2048;
                *(void *)int v175 = v124;
                *(_WORD *)&v175[8] = 2048;
                *(void *)&v175[10] = v125;
                *(_WORD *)&v175[18] = 2048;
                *(void *)&v175[20] = v126;
                *(_WORD *)&v175[28] = 2048;
                *(void *)&v175[30] = v127;
                *(_WORD *)&v175[38] = 2048;
                *(void *)&v175[40] = v128;
                *(_WORD *)&v175[48] = 2048;
                *(void *)__int16 v176 = v129;
                uint64_t v101 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v101);
                goto LABEL_209;
              }
              if (qword_102419530 != -1) {
                dispatch_once(&qword_102419530, &stru_1022F2018);
              }
              __int16 v115 = qword_102419538;
              if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)uint64_t buf = 134217984;
                *(double *)&uint8_t buf[4] = v40;
                _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEBUG, "#SLC issue notificaiton, distance, %.1lf", buf, 0xCu);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                int v172 = 134217984;
                int v173 = *(const char **)&v40;
                uint64_t v116 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v116);
                if (v116 != buf) {
                  free(v116);
                }
              }
LABEL_78:
              if (qword_102419530 != -1) {
                dispatch_once(&qword_102419530, &stru_1022F2018);
              }
              double v41 = qword_102419538;
              if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "#SLC reporting a location change", buf, 2u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419530 != -1) {
                  dispatch_once(&qword_102419530, &stru_1022F2018);
                }
                LOWORD(v172) = 0;
                __int16 v156 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v156);
                if (v156 != buf) {
                  free(v156);
                }
              }
              *(void *)(a1 + 408) = 0;
              int v42 = 1;
              BOOL v31 = 1;
              goto LABEL_115;
            }
            if (qword_102419530 != -1) {
              dispatch_once(&qword_102419530, &stru_1022F2018);
            }
            long long v58 = qword_102419538;
            if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v59 = *(void *)(a2 + 4);
              uint64_t v60 = *(void *)(a2 + 12);
              uint64_t v61 = *(void *)(a2 + 20);
              uint64_t v62 = *(void *)(a2 + 76);
              *(_DWORD *)uint64_t buf = 134218752;
              *(void *)&uint8_t buf[4] = v59;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&unsigned char buf[14] = v60;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v61;
              *(_WORD *)&unsigned char buf[32] = 2048;
              *(void *)&buf[34] = v62;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEBUG, "#SLC <%+.8f,%+.8f> acc %.2f timestamp %.2f is stale, discarding", buf, 0x2Au);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419530 != -1) {
                dispatch_once(&qword_102419530, &stru_1022F2018);
              }
              double v157 = *(const char **)(a2 + 4);
              uint64_t v158 = *(void *)(a2 + 12);
              uint64_t v159 = *(void *)(a2 + 20);
              uint64_t v160 = *(void *)(a2 + 76);
              int v172 = 134218752;
              int v173 = v157;
              __int16 v174 = 2048;
              *(void *)int v175 = v158;
              *(_WORD *)&v175[8] = 2048;
              *(void *)&v175[10] = v159;
              *(_WORD *)&v175[18] = 2048;
              *(void *)&v175[20] = v160;
              int v161 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v161);
              if (v161 != buf) {
                free(v161);
              }
            }
            int v42 = 0;
          }
          if (qword_102419530 != -1) {
            dispatch_once(&qword_102419530, &stru_1022F2018);
          }
          long long v63 = qword_102419538;
          if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEBUG, "#SLC new location is not useful", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419530 != -1) {
              dispatch_once(&qword_102419530, &stru_1022F2018);
            }
            LOWORD(v172) = 0;
            __int16 v145 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)", "%s\n", v145);
            if (v145 != buf) {
              free(v145);
            }
          }
          goto LABEL_115;
        }
        double v17 = *(double *)(a2 + 20);
      }
      else
      {
        __int16 v19 = (double *)(a2 + 88);
        double v25 = *(double *)(a2 + 88);
        *(void *)(a2 + 20) = 0x408F400000000000;
        if (v25 >= 0.0) {
          goto LABEL_67;
        }
      }
      *__int16 v19 = v17 / 250.0;
      goto LABEL_67;
    }
    if (v9 < 30.0) {
      goto LABEL_35;
    }
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022F2018);
    }
    uint64_t v14 = qword_102419538;
    if (!os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
      return;
    }
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    uint64_t v4 = "{\"msg%{public}.0s\":\"#SLC Ignoring inaccurate GPS location\"}";
LABEL_28:
    int v5 = v14;
    os_log_type_t v6 = OS_LOG_TYPE_INFO;
    goto LABEL_9;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_1022F2018);
  }
  unsigned int v2 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning #SLC Currently sending significant location changes read from defaults.\"}", buf, 0x12u);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022F2018);
    }
  }
  uint64_t v3 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    uint64_t v4 = "{\"msg%{public}.0s\":\"#Warning #SLC Delete 'SpoofSignificantLocationChange' from defaults to continue monitori"
         "ng SLC updates.\"}";
    int v5 = v3;
    os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v5, v6, v4, buf, 0x12u);
  }
}

void sub_1001632FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

BOOL sub_10016332C(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_100163398(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_100163398(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1022B6AC8);
    }
    BOOL v6 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      sub_1000FECE0(a2, (uint64_t)__p);
      long long v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022B6AC8);
      }
      sub_1000FECE0(a2, (uint64_t)buf);
      if (v12 >= 0) {
        double v9 = buf;
      }
      else {
        double v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      uint64_t v14 = v9;
      long long v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const double &)", "%s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_100163620(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  unsigned int v2 = v1 & 0xFFFFFFF7;
  unsigned int v3 = v1 & 0xFFFFFFFE;
  return v2 == 1 || v3 == 2;
}

char *sub_10016363C()
{
  return &byte_1024762C8;
}

void sub_100163648(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(CLDaemonStatsFetchLocationSystemStateAdapter);
  CFNumberRef v5 = dispatch_group_create();
  v25[0] = 0;
  v25[1] = v25;
  v25[2] = 0x4812000000;
  v25[3] = sub_10017797C;
  v25[4] = nullsub_53;
  v25[5] = "";
  int v26 = 0;
  char v27 = 0;
  int v28 = 1000;
  char v29 = 0;
  uint64_t v30 = 0;
  v23[0] = 0;
  v23[1] = v23;
  v23[2] = 0x3812000000;
  v23[3] = sub_10071BEBC;
  v23[4] = sub_10071BECC;
  dispatch_group_t v24 = v5;
  dispatch_group_enter(v5);
  id v6 = [[[a1 vendor] proxyForService:@"CLTelephonyService"];
  [v6 registerDelegate:v4 inSilo:[a1 silo]];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100178AC4;
  uint64_t v22[3] = &unk_1022C5E58;
  v22[4] = v25;
  v22[5] = v23;
  [v6 fetchIsCellAvailableWithReply:v22];
  id v7 = [objc_msgSend(a1, "vendor") proxyForService:@"CLWifiService"];
  [v7 registerDelegate:v4 inSilo:[a1 silo]];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_100178A98;
  v21[3] = &unk_1022C5E58;
  v21[4] = v25;
  void v21[5] = v23;
  [v7 fetchIsWifiAvailableWithReply:v21];
  id v8 = [[objc_msgSend(a1, "vendor") proxyForService:@"CLDataProtectionManager"];
  [v8 registerDelegate:v4 inSilo:[a1 silo]];
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_100178A80;
  v20[3] = &unk_1022C5E80;
  v20[4] = v25;
  v20[5] = v23;
  [v8 fetchDataAvailabilityWithReply:v20];
  id v9 = [objc_msgSend(a1, "vendor") proxyForService:@"CLDaemonStatus"];
  [v9 registerDelegate:v4 inSilo:[a1 silo]];
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_100178A70;
  v19[3] = &unk_1022C5E58;
  v19[4] = v25;
  v19[5] = v23;
  [v9 fetchIsAirplaneModeEnabledWithReply:v19];
  id v10 = [[[a1 vendor] proxyForService:@"CLAccessoryLocationProvider"];
  [v10 registerDelegate:v4 inSilo:[a1 silo]];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_100178A60;
  v18[3] = &unk_1022C5E58;
  v18[4] = v25;
  v18[5] = v23;
  [v10 fetchIsAccessoryConnectedWithReply:v18];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_100178A50;
  v17[3] = &unk_1022C5E80;
  v17[4] = v25;
  v17[5] = v23;
  [v9 fetchReachabilityWithReply:v17];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_100178A40;
  v16[3] = &unk_1022C5E58;
  v16[4] = v25;
  v16[5] = v23;
  [v9 fetchIsBatteryConnectedWithReply:v16];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_100178A20;
  v15[3] = &unk_1022C5EA8;
  v15[4] = v25;
  v15[5] = v23;
  [v9 fetchWirelessModemClientCountWithReply:v15];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_100178A04;
  v14[3] = &unk_1022C5E58;
  v14[4] = v25;
  v14[5] = v23;
  [v7 fetchIsAssociatedWithReply:v14];
  id v11 = [[[a1 vendor] proxyForService:@"CLBluetoothService"];
  [v11 registerDelegate:v4 inSilo:[a1 silo]];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100178AA8;
  void v13[3] = &unk_1022C5E58;
  v13[4] = v25;
  v13[5] = v23;
  [v11 fetchHasConnectedDevicesWithReply:v13];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002CAAC;
  block[3] = &unk_1022C5ED0;
  block[6] = v25;
  block[4] = v5;
  block[5] = a2;
  dispatch_group_notify(v5, (dispatch_queue_t)[objc_msgSend(objc_msgSend(a1, "silo"), "queue")], block);
  _Block_object_dispose(v23, 8);
  if (v24) {
    dispatch_group_leave(v24);
  }
  _Block_object_dispose(v25, 8);
}

void sub_100163C20(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 232), 8);
  unsigned int v3 = *(NSObject **)(v1 - 184);
  if (v3) {
    dispatch_group_leave(v3);
  }
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100163CA8(uint64_t a1, uint64_t a2, char a3)
{
  if (a2)
  {
    int v6 = sub_1001647E0((unsigned int *)a1);
    if ((sub_100164354(v6) & 1) == 0) {
      sub_101A5EE6C();
    }
    *(_DWORD *)(a2 + 92) |= 1u;
    *(_DWORD *)(a2 + 8) = v6;
    unsigned int v7 = sub_10016460C((int *)(a1 + 4));
    if (!sub_100165F14(v7)) {
      sub_101A5EE40();
    }
    *(_DWORD *)(a2 + 92) |= 2u;
    *(_DWORD *)(a2 + 12) = v7;
    unsigned int v8 = sub_1001C0B54((int *)(a1 + 12));
    if (!sub_10016E644(v8)) {
      sub_101A5EE14();
    }
    *(_DWORD *)(a2 + 92) |= 4u;
    *(_DWORD *)(a2 + 16) = v8;
    unsigned int v9 = sub_10016460C((int *)(a1 + 16));
    if (!sub_100165F14(v9)) {
      sub_101A5EDE8();
    }
    int v10 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + 20) = v9;
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 32);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 36);
    char v11 = *(unsigned char *)(a1 + 48);
    *(_DWORD *)(a2 + 92) = v10 | 0xB8;
    *(unsigned char *)(a2 + 29) = v11;
    unsigned int v12 = sub_1001C0980((int *)(a1 + 52));
    if (!sub_100165F14(v12)) {
      sub_101A5EDBC();
    }
    *(_DWORD *)(a2 + 92) |= 0x100u;
    *(_DWORD *)(a2 + 48) = v12;
    unsigned int v13 = sub_1001C07AC((int *)(a1 + 100));
    if (!sub_1001A4C58(v13)) {
      sub_101A5ED38();
    }
    int v14 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + 76) = v13;
    uint64_t v15 = *(void *)(a1 + 56);
    *(_DWORD *)(a2 + 92) = v14 | 0x8200;
    *(void *)(a2 + 40) = v15;
    int v16 = sub_1001647E0((unsigned int *)(a1 + 88));
    if ((sub_100164354(v16) & 1) == 0) {
      sub_101A5ED90();
    }
    *(_DWORD *)(a2 + 92) |= 0x800u;
    *(_DWORD *)(a2 + 52) = v16;
    unsigned int v17 = sub_10016460C((int *)(a1 + 92));
    if (!sub_100165F14(v17)) {
      sub_101A5ED64();
    }
    int v18 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + 72) = v17;
    *(_DWORD *)(a2 + 92) = v18 | 0x5000;
    uint64_t v19 = *(void *)(a2 + 80);
    if (!v19) {
      operator new();
    }
    if ((sub_1001C1658((double *)(a1 + 80), v19, 1) & 1) == 0)
    {
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      int v20 = qword_1024194C8;
      if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Error: Failed to convert CLMotionActivity start CF time to protobuf", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024194C0 != -1) {
          dispatch_once(&qword_1024194C0, &stru_102327520);
        }
        double v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)", "%s\n", v25);
        if (v25 != (char *)buf) {
          free(v25);
        }
      }
      (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
    }
    if ((a3 & 1) == 0)
    {
      *(_DWORD *)(a2 + 92) |= 0x2000u;
      uint64_t v21 = *(void *)(a2 + 64);
      if (!v21) {
        operator new();
      }
      if ((sub_1001C0DB4((double *)(a1 + 40), v21, 1) & 1) == 0)
      {
        if (qword_1024194C0 != -1) {
          dispatch_once(&qword_1024194C0, &stru_102327520);
        }
        long long v22 = qword_1024194C8;
        if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Error: Failed to convert CLMotionActivity mach timestamp to protobuf", buf, 2u);
        }
        if (sub_10013D1A0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024194C0 != -1) {
            dispatch_once(&qword_1024194C0, &stru_102327520);
          }
          int v26 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)", "%s\n", v26);
          if (v26 != (char *)buf) {
            free(v26);
          }
        }
        (*(void (**)(uint64_t))(*(void *)v21 + 32))(v21);
      }
    }
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    long long v23 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "pActivity,Invalid pointer", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      dispatch_group_t v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)", "%s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
  }
}

void sub_10016431C()
{
}

uint64_t sub_100164354(int a1)
{
  uint64_t result = 1;
  if (a1 <= 11804)
  {
    if (a1 > 2009)
    {
      if (((a1 - 2010) > 0x3D || ((1 << (a1 + 38)) & 0x2488004000005401) == 0)
        && ((a1 - 2101) > 0x31 || ((1 << (a1 - 53)) & 0x2000000000011) == 0)
        && (a1 - 3015) >= 2)
      {
        return 0;
      }
      return result;
    }
    if (a1 < 0xC) {
      return result;
    }
    unsigned int v4 = a1 - 41;
    if (v4 <= 0x3B)
    {
      uint64_t v5 = 1 << v4;
      uint64_t v6 = 0x800000003F08801;
      goto LABEL_33;
    }
    return 0;
  }
  if (a1 <= 15651)
  {
    if (a1 > 15329)
    {
      if ((a1 - 15562) <= 0x3A && ((1 << (a1 + 54)) & 0x401000040000001) != 0
        || (a1 - 15330) <= 0x1E && ((1 << (a1 + 30)) & 0x40100001) != 0)
      {
        return result;
      }
      int v3 = 15460;
    }
    else if (a1 <= 15054)
    {
      if (a1 == 11805 || a1 == 12150) {
        return result;
      }
      int v3 = 15030;
    }
    else
    {
      if ((a1 - 15100) <= 0x32 && ((1 << (a1 + 4)) & 0x4000000000401) != 0
        || (a1 - 15230) <= 0x19 && ((1 << (a1 - 126)) & 0x2000401) != 0)
      {
        return result;
      }
      int v3 = 15055;
    }
    goto LABEL_51;
  }
  if (a1 > 18199)
  {
    if (a1 > 19149)
    {
      if (a1 <= 90602)
      {
        if (a1 == 19150) {
          return result;
        }
        int v3 = 19160;
      }
      else
      {
        if (a1 == 90603 || a1 == 515621) {
          return result;
        }
        int v3 = 515652;
      }
    }
    else
    {
      if ((a1 - 18200) <= 0x28 && ((1 << (a1 - 24)) & 0x10002000001) != 0
        || a1 == 19030)
      {
        return result;
      }
      int v3 = 19090;
    }
    goto LABEL_51;
  }
  if (a1 > 15732)
  {
    if (a1 == 15733 || a1 == 17150) {
      return result;
    }
    int v3 = 18070;
LABEL_51:
    if (a1 == v3) {
      return result;
    }
    return 0;
  }
  unsigned int v7 = a1 - 15652;
  if (v7 > 0x3A) {
    return 0;
  }
  uint64_t v5 = 1 << v7;
  uint64_t v6 = 0x400000000840101;
LABEL_33:
  if ((v5 & v6) == 0) {
    return 0;
  }
  return result;
}

uint64_t sub_10016460C(int *a1)
{
  if (*a1 < 3) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  int v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled confidence type: %{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::MotionActivity_ConfidenceType ConvertCLMotionActivityConfidenceTypeToProtobuf(const CLMotionActivity::Confidence &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001647E0(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((int)result <= 11804)
  {
    if ((int)result > 2009)
    {
      BOOL v5 = (result - 2010) > 0x3D || ((1 << (result + 38)) & 0x2488004000005401) == 0;
      if (!v5
        || (result - 2101) <= 0x31 && ((1 << (result - 53)) & 0x2000000000011) != 0
        || (result - 3015) < 2)
      {
        return result;
      }
    }
    else
    {
      if (result < 0xC) {
        return result;
      }
      if ((result - 41) <= 0x3B && ((1 << (result - 41)) & 0x800000003F08801) != 0) {
        return result;
      }
    }
    goto LABEL_71;
  }
  if ((int)result > 15651)
  {
    if ((int)result > 18199)
    {
      if ((int)result <= 19149)
      {
        if ((int)result > 19029)
        {
          if (result == 19030) {
            return result;
          }
          int v6 = 19090;
        }
        else
        {
          if (result == 18200) {
            return result;
          }
          int v6 = 18240;
        }
      }
      else
      {
        if ((int)result > 515620)
        {
          if (result == 515621 || result == 515652) {
            return result;
          }
          if (result == 519150) {
            return 19160;
          }
          goto LABEL_71;
        }
        if (result == 19150) {
          return result;
        }
        int v6 = 90603;
      }
    }
    else
    {
      if ((int)result <= 15732)
      {
        uint64_t v4 = (result - 15652);
        if (v4 <= 0x3B)
        {
          if (((1 << (result - 36)) & 0x840101) != 0) {
            return result;
          }
          if (v4 == 59) {
            return 15710;
          }
        }
        goto LABEL_71;
      }
      if ((int)result > 18049)
      {
        if (result == 18050) {
          return 18070;
        }
        if (result == 18100) {
          return 18225;
        }
        goto LABEL_71;
      }
      if (result == 15733) {
        return result;
      }
      int v6 = 17150;
    }
LABEL_68:
    if (result == v6) {
      return result;
    }
    goto LABEL_71;
  }
  if ((int)result > 15254)
  {
    if ((int)result <= 15459)
    {
      if ((result - 15330) <= 0x1E && ((1 << (result + 30)) & 0x40100001) != 0) {
        return result;
      }
      int v6 = 15255;
    }
    else
    {
      if ((int)result <= 15591)
      {
        if (result == 15460) {
          return result;
        }
        if (result == 15560) {
          return 15562;
        }
        goto LABEL_71;
      }
      if (result == 15592 || result == 15610) {
        return result;
      }
      int v6 = 15620;
    }
    goto LABEL_68;
  }
  if ((int)result <= 15099)
  {
    if ((int)result > 15029)
    {
      if (result == 15030) {
        return result;
      }
      int v6 = 15055;
    }
    else
    {
      if (result == 11805) {
        return result;
      }
      int v6 = 12150;
    }
    goto LABEL_68;
  }
  if ((result - 15100) <= 0x32 && ((1 << (result + 4)) & 0x4000000000401) != 0
    || result == 15230)
  {
    return result;
  }
  if (result == 15250) {
    return 15240;
  }
LABEL_71:
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  unsigned int v7 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v8 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Received unhandled motion activity type: %{public}d", buf, 8u);
  }
  BOOL v9 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v9)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v10 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DominantMotionModeType ConvertCLMotionActivityTypeToProtobuf(const CLMotionActivity::Type &)", "%s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
    return 0;
  }
  return result;
}

void sub_100164CAC(uint64_t a1, unsigned int *a2, int32x4_t *a3, int *a4, int *a5, int *a6)
{
  if (!*(void *)(a1 + 16)) {
    return;
  }
  if ((*a2 & 0xFFFFFFFE) == 2)
  {
    if (vmaxv_u16((uint16x4_t)vmovn_s32(vceqzq_s32(*a3))))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      BOOL v9 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        if (a3->i32[0]) {
          BOOL v10 = a3->i32[1] == 0;
        }
        else {
          BOOL v10 = 1;
        }
        int v11 = !v10;
        if (*a4) {
          BOOL v12 = a4[1] == 0;
        }
        else {
          BOOL v12 = 1;
        }
        int v13 = !v12;
        LODWORD(buf) = 67109376;
        HIDWORD(buf) = v11;
        __int16 v71 = 1024;
        LODWORD(v72) = v13;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordRegistration,CLLocationProvider_Type,silo entry invalid,from_valid,%d,to_valid,%d", (uint8_t *)&buf, 0xEu);
      }
      if (!sub_10013D1A0(115, 2)) {
        return;
      }
      bzero(&buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      BOOL v14 = !a3->i32[0] || a3->i32[1] == 0;
      BOOL v15 = !v14;
      BOOL v16 = !*a4 || a4[1] == 0;
      BOOL v17 = !v16;
      *(_DWORD *)uint64_t v57 = 67109376;
      *(_DWORD *)&v57[4] = v15;
      *(_WORD *)&v57[8] = 1024;
      *(_DWORD *)&v57[10] = v17;
      int v18 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordRegistration(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &)", "%s\n", v18);
      if (v18 == (char *)&buf) {
        return;
      }
LABEL_54:
      free(v18);
      return;
    }
    sub_100168850(&v66);
    double v25 = (__n128 *)sub_10016BA10();
    sub_100168854(v25, v56);
    sub_100165AD4((uint64_t)&v66, a2, a3, a4, (uint64_t *)v56);
    v69 |= 2u;
    uint64_t v26 = v68;
    if (!v68) {
      operator new();
    }
    *(_DWORD *)(v68 + 492) |= 0x800u;
    uint64_t v27 = *(void *)(v26 + 352);
    if (!v27) {
      operator new();
    }
    *(_DWORD *)(v27 + 184) |= 0x10000u;
    int v28 = *(_DWORD **)(v27 + 128);
    if (!v28) {
      operator new();
    }
    int v29 = *a5;
    v28[9] |= 1u;
    v28[2] = v29;
    unsigned int v30 = sub_100169B90(a6);
    if (!sub_100169B58(v30)) {
      __assert_rtn("set_notification_type", "CLPLocationController.pb.h", 9437, "::CLP::LogEntry::PrivateData::LocationProviderNotification_NotificationType_IsValid(value)");
    }
    v28[9] |= 2u;
    v28[3] = v30;
    int v31 = sub_100168A44(a1);
    if (*(unsigned char *)(a1 + 8))
    {
      int v32 = v31;
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      long long v33 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        sub_101522B64((int *)a2, v57);
        if (SBYTE3(v59) >= 0) {
          long long v34 = v57;
        }
        else {
          long long v34 = *(unsigned char **)v57;
        }
        double v47 = v34;
        LODWORD(v49[0]) = a3->i32[0];
        sub_101522E48((int *)v49, v54);
        if (v55 >= 0) {
          long long v35 = v54;
        }
        else {
          long long v35 = (void **)v54[0];
        }
        int v51 = *a4;
        long long v36 = __p;
        sub_101522E48(&v51, __p);
        if (v53 < 0) {
          long long v36 = (void **)__p[0];
        }
        long long v37 = sub_10008A168(*a6);
        uint64_t v38 = sub_10016BA10();
        double v39 = sub_10018202C(v38);
        LODWORD(buf) = 67110402;
        HIDWORD(buf) = v32;
        __int16 v71 = 2080;
        uint64_t v72 = v47;
        __int16 v73 = 2080;
        double v74 = v35;
        __int16 v75 = 2080;
        long long v76 = v36;
        __int16 v77 = 2080;
        long long v78 = v37;
        __int16 v79 = 2050;
        double v80 = v39;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordRegistration,CLLocationProvider_Type,success,%d,message_type,%s,from,%s,to,%s,notification_type,%s,propagation_us,%{public}.3f", (uint8_t *)&buf, 0x3Au);
        if (v53 < 0) {
          operator delete(__p[0]);
        }
        if (v55 < 0) {
          operator delete(v54[0]);
        }
        if (SBYTE3(v59) < 0) {
          operator delete(*(void **)v57);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022BD0F8);
        }
        sub_101522B64((int *)a2, v54);
        if (v55 >= 0) {
          double v40 = v54;
        }
        else {
          double v40 = (void **)v54[0];
        }
        int v51 = a3->i32[0];
        double v41 = __p;
        sub_101522E48(&v51, __p);
        if (v53 < 0) {
          double v41 = (void **)__p[0];
        }
        int v48 = *a4;
        sub_101522E48(&v48, v49);
        if (v50 >= 0) {
          int v42 = v49;
        }
        else {
          int v42 = (void **)v49[0];
        }
        double v43 = sub_10008A168(*a6);
        uint64_t v44 = sub_10016BA10();
        double v45 = sub_10018202C(v44);
        *(_DWORD *)uint64_t v57 = 67110402;
        *(_DWORD *)&v57[4] = v32;
        *(_WORD *)&v57[8] = 2080;
        *(void *)&v57[10] = v40;
        __int16 v58 = 2080;
        uint64_t v59 = v41;
        __int16 v60 = 2080;
        uint64_t v61 = v42;
        __int16 v62 = 2080;
        long long v63 = v43;
        __int16 v64 = 2050;
        double v65 = v45;
        double v46 = (char *)_os_log_send_and_compose_impl();
        if (v50 < 0) {
          operator delete(v49[0]);
        }
        if (v53 < 0) {
          operator delete(__p[0]);
        }
        if (v55 < 0) {
          operator delete(v54[0]);
        }
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordRegistration(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &)", "%s\n", v46);
        if (v46 != (char *)&buf) {
          free(v46);
        }
      }
    }
    sub_1001687EC(&v66);
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v19 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      sub_101522B64((int *)a2, &buf);
      int v20 = SBYTE3(v74) >= 0 ? &buf : (void **)buf;
      *(_DWORD *)uint64_t v57 = 136315138;
      *(void *)&v57[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordRegistration,CLLocationProvider_Type,unsupported message type,%s", v57, 0xCu);
      if (SBYTE3(v74) < 0) {
        operator delete(buf);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      sub_101522B64((int *)a2, v57);
      if (SBYTE3(v59) >= 0) {
        uint64_t v21 = v57;
      }
      else {
        uint64_t v21 = *(unsigned char **)v57;
      }
      int v66 = 136315138;
      uint64_t v67 = v21;
      int v18 = (char *)_os_log_send_and_compose_impl();
      if (SBYTE3(v59) < 0) {
        operator delete(*(void **)v57);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordRegistration(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &)", "%s\n", v18);
      if (v18 != (char *)&buf) {
        goto LABEL_54;
      }
    }
  }
}

void sub_100165528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

uint64_t sub_100165630(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16))
  {
    uint64_t v3 = result;
    sub_100168850(v23);
    unsigned int v22 = 1;
    *(_DWORD *)uint64_t buf = 21;
    v21[0] = 21;
    v21[1] = sub_10016A9AC((int *)buf);
    sub_100165AD4((uint64_t)v23, &v22, v21, v21, (uint64_t *)a2);
    v25 |= 2u;
    uint64_t v4 = v24;
    if (!v24) {
      operator new();
    }
    *(_DWORD *)(v24 + 492) |= 0x800u;
    uint64_t v5 = *(void *)(v4 + 352);
    if (!v5) {
      operator new();
    }
    *(_DWORD *)(v5 + 184) |= 0x10u;
    uint64_t v6 = *(void *)(v5 + 32);
    if (!v6) {
      operator new();
    }
    *(_DWORD *)(v6 + 28) |= 1u;
    *(_DWORD *)(v6 + 8) = -1;
    if (!sub_1001662E0(1u)) {
      __assert_rtn("set_notification_type", "CLPLocationController.pb.h", 6520, "::CLP::LogEntry::PrivateData::SystemNotification_NotificationType_IsValid(value)");
    }
    int v7 = *(_DWORD *)(v6 + 28);
    *(_DWORD *)(v6 + 12) = 1;
    *(_DWORD *)(v6 + 28) = v7 | 6;
    uint64_t v8 = *(void *)(v6 + 16);
    if (!v8) {
      operator new();
    }
    *(_DWORD *)(v8 + 72) |= 1u;
    uint64_t v9 = *(void *)(v8 + 8);
    if (!v9) {
      operator new();
    }
    sub_1001662EC((uint64_t *)a2, v9);
    char v10 = *(unsigned char *)(a2 + 24);
    *(_DWORD *)(v8 + 72) |= 2u;
    *(unsigned char *)(v8 + 16) = v10;
    int v11 = sub_100168A44(v3);
    if (*(unsigned char *)(v3 + 8))
    {
      int v12 = v11;
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      int v13 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v14 = *(void *)(a2 + 16);
        uint64_t v15 = *(void *)a2;
        int v16 = *(unsigned __int8 *)(a2 + 24);
        *(_DWORD *)uint64_t buf = 67240960;
        int v35 = v12;
        __int16 v36 = 2050;
        uint64_t v37 = v14;
        __int16 v38 = 2050;
        uint64_t v39 = v15;
        __int16 v40 = 1026;
        int v41 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordHeartbeat,success,%{public}d,received timestamp,cfat,%{public}.3f,mct,%{public}.3f,is_valid,%{public}d", buf, 0x22u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022BD0F8);
        }
        uint64_t v17 = *(void *)(a2 + 16);
        uint64_t v18 = *(void *)a2;
        int v19 = *(unsigned __int8 *)(a2 + 24);
        int v26 = 67240960;
        int v27 = v12;
        __int16 v28 = 2050;
        uint64_t v29 = v17;
        __int16 v30 = 2050;
        uint64_t v31 = v18;
        __int16 v32 = 1026;
        int v33 = v19;
        int v20 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordHeartbeat(const CLUtils::Timestamp &)", "%s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
      }
    }
    return sub_1001687EC(v23);
  }
  return result;
}

void sub_100165A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1001687EC(va);
  _Unwind_Resume(a1);
}

void sub_100165AD4(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, uint64_t *a5)
{
  sub_10016673C((uint64_t)a5, a1);
  *(_DWORD *)(a1 + 52) |= 2u;
  uint64_t v10 = *(void *)(a1 + 40);
  if (!v10) {
    operator new();
  }
  *(_DWORD *)(v10 + 492) |= 0x800u;
  uint64_t v11 = *(void *)(v10 + 352);
  if (!v11) {
    operator new();
  }
  *(_DWORD *)(v11 + 184) |= 1u;
  uint64_t v12 = *(void *)(v11 + 8);
  if (!v12) {
    operator new();
  }
  sub_1001662EC(a5, v12);
  unsigned int v13 = sub_100166578(a2);
  if (!sub_1001662E0(v13)) {
    sub_101A66584();
  }
  int v14 = *(_DWORD *)(v11 + 184);
  *(_DWORD *)(v11 + 176) = v13;
  *(_DWORD *)(v11 + 184) = v14 | 6;
  uint64_t v15 = *(_DWORD **)(v11 + 16);
  if (!v15) {
    operator new();
  }
  sub_100165D1C(a3, v15);
  *(_DWORD *)(v11 + 184) |= 8u;
  if (!*(void *)(v11 + 24)) {
    operator new();
  }
  int v16 = *(_DWORD **)(v11 + 24);
  sub_100165D1C(a4, v16);
}

void sub_100165C84()
{
}

void *sub_100165CF8(void *result)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = off_1023053E8;
  return result;
}

void sub_100165D1C(_DWORD *a1, _DWORD *a2)
{
  if (a2)
  {
    *(_DWORD *)uint64_t buf = *a1;
    unsigned int v4 = sub_100165F2C((unsigned int *)buf);
    if (!sub_100165F20(v4)) {
      sub_101A66660();
    }
    a2[5] |= 1u;
    a2[2] = v4;
    *(_DWORD *)uint64_t buf = a1[1];
    unsigned int v5 = sub_1001660F0((unsigned int *)buf);
    if (!sub_100165F14(v5)) {
      sub_101A66634();
    }
    a2[5] |= 2u;
    a2[3] = v5;
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#locctl,#rec,failed to set log entry silo", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static void CLLocationControllerRecorder::setLocationControllerLogEntrySilo(const CLLocationControllerRecorder_Types::Silo &, CLP::LogEntry::PrivateData::Silo *)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

BOOL sub_100165F14(unsigned int a1)
{
  return a1 < 4;
}

BOOL sub_100165F20(unsigned int a1)
{
  return a1 < 0x1B;
}

uint64_t sub_100165F2C(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 0x1B)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v3 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67109120;
      int v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertServiceTypeToProtobuf,type should never be max,%d", buf, 8u);
    }
    uint64_t result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::ServiceType CLLocationControllerRecorder::convertServiceTypeToProtobuf(const CLLocationControllerRecorder_Types::ServiceType &)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1001660F0(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 4)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v3 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67109120;
      int v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertSiloTypeToProtobuf,type should never be max,%d", buf, 8u);
    }
    uint64_t result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::Silo_Type CLLocationControllerRecorder::convertSiloTypeToProtobuf(const CLLocationControllerRecorder_Types::SiloType &)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
      return 0;
    }
  }
  return result;
}

double sub_1001662B4(uint64_t a1)
{
  *(void *)a1 = off_1022AE950;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

BOOL sub_1001662E0(unsigned int a1)
{
  return a1 < 5;
}

void sub_1001662EC(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = *(_DWORD *)(a2 + 36);
    *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
    uint64_t v3 = *a1;
    *(_DWORD *)(a2 + 36) = v2 | 7;
    *(void *)(a2 + 24) = v3;
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    int v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#locctl,#rec,failed to set private data timestamp", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static void CLLocationControllerRecorder::setPrivateDataTimeStamp(const CLUtils::Timestamp &, CLP::LogEntry::PrivateData::TimeStamp *)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

double sub_10016649C(uint64_t a1)
{
  *(void *)a1 = off_102305460;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  return result;
}

double sub_1001664F0(uint64_t a1)
{
  *(void *)a1 = off_1022CEC88;
  double result = 0.0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  return result;
}

uint64_t sub_100166578(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 5)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v3 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67109120;
      int v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertMessageTypeToProtobuf,type should never be max,%d", buf, 8u);
    }
    uint64_t result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::MessageType CLLocationControllerRecorder::convertMessageTypeToProtobuf(const CLLocationControllerRecorder_Types::MessageType &)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
      return 0;
    }
  }
  return result;
}

double sub_10016673C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 52) |= 1u;
  uint64_t v2 = *(void *)(a2 + 32);
  if (!v2) {
    operator new();
  }
  int v3 = *(_DWORD *)(v2 + 44);
  *(int8x16_t *)(v2 + 8) = vextq_s8(*(int8x16_t *)(a1 + 8), *(int8x16_t *)(a1 + 8), 8uLL);
  double result = *(double *)a1;
  *(_DWORD *)(v2 + 44) = v3 | 7;
  *(double *)(v2 + 24) = result;
  return result;
}

void sub_1001667C0()
{
}

double sub_1001667E4(uint64_t a1)
{
  *(void *)a1 = off_102322490;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  return result;
}

void sub_100166814(uint64_t a1, unsigned int *a2, int32x4_t *a3, int *a4, int *a5, int *a6, uint64_t a7)
{
  if (!*(void *)(a1 + 16)) {
    return;
  }
  if (*a2 == 4)
  {
    if (vmaxv_u16((uint16x4_t)vmovn_s32(vceqzq_s32(*a3))))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      uint64_t v10 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        if (a3->i32[0]) {
          BOOL v11 = a3->i32[1] == 0;
        }
        else {
          BOOL v11 = 1;
        }
        int v12 = !v11;
        if (*a4) {
          BOOL v13 = a4[1] == 0;
        }
        else {
          BOOL v13 = 1;
        }
        int v14 = !v13;
        *(_DWORD *)uint64_t buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v12;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordMessage,CLLocationProvider_Type,silo entry invalid,from_valid,%d,to_valid,%d", buf, 0xEu);
      }
      if (!sub_10013D1A0(115, 2)) {
        return;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      BOOL v15 = !a3->i32[0] || a3->i32[1] == 0;
      BOOL v16 = !v15;
      BOOL v17 = !*a4 || a4[1] == 0;
      BOOL v18 = !v17;
      *(_DWORD *)uint64_t v101 = 67109376;
      *(_DWORD *)&v101[4] = v16;
      *(_WORD *)&v101[8] = 1024;
      *(_DWORD *)&v101[10] = v18;
      int v19 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordMessage(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v19);
      if (v19 == buf) {
        return;
      }
LABEL_54:
      free(v19);
      return;
    }
    sub_100168850(&v106);
    int v27 = (__n128 *)sub_10016BA10();
    sub_100168854(v27, v100);
    sub_100165AD4((uint64_t)&v106, a2, a3, a4, (uint64_t *)v100);
    v109 |= 2u;
    uint64_t v28 = v108;
    if (!v108) {
      operator new();
    }
    *(_DWORD *)(v108 + 492) |= 0x800u;
    uint64_t v29 = *(void *)(v28 + 352);
    if (!v29) {
      operator new();
    }
    *(_DWORD *)(v29 + 184) |= 0x10000u;
    uint64_t v30 = *(void *)(v29 + 128);
    if (!v30) {
      operator new();
    }
    int v31 = *a5;
    *(_DWORD *)(v30 + 36) |= 1u;
    *(_DWORD *)(v30 + 8) = v31;
    unsigned int v32 = sub_100169B90(a6);
    if (!sub_100169B58(v32)) {
      __assert_rtn("set_notification_type", "CLPLocationController.pb.h", 9437, "::CLP::LogEntry::PrivateData::LocationProviderNotification_NotificationType_IsValid(value)");
    }
    int v33 = *(_DWORD *)(v30 + 36);
    *(_DWORD *)(v30 + 12) = v32;
    *(_DWORD *)(v30 + 36) = v33 | 6;
    uint64_t v34 = *(void *)(v30 + 16);
    if (!v34) {
      operator new();
    }
    int v35 = *a6;
    if (*a6 > 35)
    {
      switch(v35)
      {
        case '$':
          uint64_t v39 = sub_10016F56C(v34);
          sub_10016F6DC(a7 + 1328, v39);
          goto LABEL_88;
        case ')':
          uint64_t v71 = sub_1005BE624(v34);
          sub_10146A1B8(a7 + 1448, v71);
          goto LABEL_88;
        case '*':
          uint64_t v37 = sub_1005BE6A4(v34);
          char v38 = *(unsigned char *)(a7 + 1480);
          *(_DWORD *)(v37 + 16) |= 1u;
          *(unsigned char *)(v37 + 8) = v38;
          goto LABEL_88;
      }
    }
    else
    {
      switch(v35)
      {
        case 9:
LABEL_88:
          int v72 = sub_100168A44(a1);
          if (*(unsigned char *)(a1 + 8))
          {
            int v73 = v72;
            if (qword_102419380 != -1) {
              dispatch_once(&qword_102419380, &stru_1022BD0F8);
            }
            double v74 = qword_102419388;
            if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
            {
              sub_101522B64((int *)a2, v101);
              if (v101[23] >= 0) {
                __int16 v75 = v101;
              }
              else {
                __int16 v75 = *(unsigned char **)v101;
              }
              LODWORD(v93[0]) = a3->i32[0];
              sub_101522E48((int *)v93, v98);
              if (v99 >= 0) {
                long long v76 = v98;
              }
              else {
                long long v76 = (void **)v98[0];
              }
              int v95 = *a4;
              sub_101522E48(&v95, __p);
              if (v97 >= 0) {
                __int16 v77 = __p;
              }
              else {
                __int16 v77 = (void **)__p[0];
              }
              long long v78 = sub_10008A168(*a6);
              uint64_t v79 = sub_10016BA10();
              double v80 = sub_10018202C(v79);
              *(_DWORD *)uint64_t buf = 67110402;
              *(_DWORD *)&uint8_t buf[4] = v73;
              *(_WORD *)&uint8_t buf[8] = 2080;
              *(void *)&buf[10] = v75;
              *(_WORD *)&buf[18] = 2080;
              *(void *)&buf[20] = v76;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = v77;
              __int16 v111 = 2080;
              uint64_t v112 = v78;
              __int16 v113 = 2050;
              double v114 = v80;
              _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordMessage,CLLocationProvider_Type,success,%d,message_type,%s,from,%s,to,%s,notification_type,%s,propagation_us,%{public}.3f", buf, 0x3Au);
              if (v97 < 0) {
                operator delete(__p[0]);
              }
              if (v99 < 0) {
                operator delete(v98[0]);
              }
              if ((v101[23] & 0x80000000) != 0) {
                operator delete(*(void **)v101);
              }
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419380 != -1) {
                dispatch_once(&qword_102419380, &stru_1022BD0F8);
              }
              sub_101522B64((int *)a2, v98);
              if (v99 >= 0) {
                long long v81 = v98;
              }
              else {
                long long v81 = (void **)v98[0];
              }
              int v95 = a3->i32[0];
              double v82 = __p;
              sub_101522E48(&v95, __p);
              if (v97 < 0) {
                double v82 = (void **)__p[0];
              }
              int v92 = *a4;
              sub_101522E48(&v92, v93);
              if (v94 >= 0) {
                double v83 = v93;
              }
              else {
                double v83 = (void **)v93[0];
              }
              int v84 = sub_10008A168(*a6);
              uint64_t v85 = sub_10016BA10();
              double v86 = sub_10018202C(v85);
              *(_DWORD *)uint64_t v101 = 67110402;
              *(_DWORD *)&v101[4] = v73;
              *(_WORD *)&v101[8] = 2080;
              *(void *)&v101[10] = v81;
              *(_WORD *)&v101[18] = 2080;
              *(void *)&v101[20] = v82;
              *(_WORD *)&v101[28] = 2080;
              *(void *)&v101[30] = v83;
              __int16 v102 = 2080;
              uint64_t v103 = v84;
              __int16 v104 = 2050;
              double v105 = v86;
              uint64_t v87 = (char *)_os_log_send_and_compose_impl();
              if (v94 < 0) {
                operator delete(v93[0]);
              }
              if (v97 < 0) {
                operator delete(__p[0]);
              }
              if (v99 < 0) {
                operator delete(v98[0]);
              }
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordMessage(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v87);
              if (v87 != buf) {
                free(v87);
              }
            }
          }
          sub_1001687EC(&v106);
          return;
        case 11:
          uint64_t v69 = *(void *)(a7 + 816);
          uint64_t v70 = sub_1001931A4(v34);
          sub_100020650(v69, v70);
          goto LABEL_88;
        case 18:
          unsigned int v36 = sub_1001C148C((unsigned int *)(a7 + 840));
          sub_1005BE5E0(v34, v36);
          goto LABEL_88;
      }
    }
    uint64_t v40 = sub_10016AC90(v34);
    sub_10016D01C(a7, v40);
    uint64_t v41 = sub_10016ABCC(v34);
    sub_10016DE1C(a7 + 160, v41);
    if (*(void *)(a7 + 800))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      int v42 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v98[0]) = a3->i32[0];
        sub_101522E48((int *)v98, v101);
        double v43 = v101[23] >= 0 ? v101 : *(unsigned char **)v101;
        uint64_t v44 = sub_10008A168(*a6);
        uint64_t v45 = sub_1010FB9FC(*(int **)(a7 + 800));
        *(_DWORD *)uint64_t buf = 136315650;
        *(void *)&uint8_t buf[4] = v43;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = v44;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v45;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "#locctl,#rec,received #batchedlocations,from,%s,notification,%s,size,%zu", buf, 0x20u);
        if ((v101[23] & 0x80000000) != 0) {
          operator delete(*(void **)v101);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022BD0F8);
        }
        LODWORD(__p[0]) = a3->i32[0];
        sub_101522E48((int *)__p, v98);
        if (v99 >= 0) {
          double v88 = v98;
        }
        else {
          double v88 = (void **)v98[0];
        }
        uint64_t v89 = sub_10008A168(*a6);
        uint64_t v90 = sub_1010FB9FC(*(int **)(a7 + 800));
        *(_DWORD *)uint64_t v101 = 136315650;
        *(void *)&v101[4] = v88;
        *(_WORD *)&v101[12] = 2080;
        *(void *)&v101[14] = v89;
        *(_WORD *)&v101[22] = 2048;
        *(void *)&v101[24] = v90;
        uint64_t v91 = (char *)_os_log_send_and_compose_impl();
        if (v99 < 0) {
          operator delete(v98[0]);
        }
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordMessage(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v91);
        if (v91 != buf) {
          free(v91);
        }
      }
      double v46 = *(int **)(a7 + 800);
      double v47 = (int *)sub_1005BE724(v34);
      sub_101468E9C(v46, v47);
    }
    int v48 = *(_DWORD *)(v34 + 112);
    *(unsigned char *)(v34 + 48) = *(unsigned char *)(a7 + 824);
    uint64_t v49 = *(void *)(a7 + 832);
    *(_DWORD *)(v34 + 112) = v48 | 0x30;
    *(void *)(v34 + 40) = v49;
    uint64_t v50 = sub_100167650(v34);
    uint64_t v51 = *(void *)(a7 + 856);
    *(_DWORD *)(v50 + 44) |= 1u;
    *(void *)(v50 + 8) = v51;
    uint64_t v52 = sub_100167650(v34);
    uint64_t v53 = *(void *)(a7 + 848);
    *(_DWORD *)(v52 + 44) |= 2u;
    *(void *)(v52 + 16) = v53;
    uint64_t v54 = sub_100167650(v34);
    uint64_t v55 = *(void *)(a7 + 864);
    *(_DWORD *)(v54 + 44) |= 4u;
    *(void *)(v54 + 24) = v55;
    uint64_t v56 = sub_100167650(v34);
    uint64_t v57 = *(void *)(a7 + 872);
    *(_DWORD *)(v56 + 44) |= 8u;
    *(void *)(v56 + 32) = v57;
    uint64_t v58 = sub_100169D64(v34);
    uint64_t v59 = *(void *)(a7 + 888);
    *(_DWORD *)(v58 + 28) |= 1u;
    *(void *)(v58 + 8) = v59;
    uint64_t v60 = sub_100169D64(v34);
    uint64_t v61 = *(void *)(a7 + 880);
    *(_DWORD *)(v60 + 28) |= 2u;
    *(void *)(v60 + 16) = v61;
    unsigned int v62 = sub_10016CE50((unsigned int *)(a7 + 928));
    sub_10016AC4C(v34, v62);
    uint64_t v63 = sub_1001699D0(v34);
    uint64_t v64 = *(void *)(a7 + 944);
    *(_DWORD *)(v63 + 36) |= 1u;
    *(void *)(v63 + 8) = v64;
    uint64_t v65 = sub_1001699D0(v34);
    uint64_t v66 = *(void *)(a7 + 936);
    *(_DWORD *)(v65 + 36) |= 2u;
    *(void *)(v65 + 16) = v66;
    uint64_t v67 = sub_1001699D0(v34);
    uint64_t v68 = *(void *)(a7 + 952);
    *(_DWORD *)(v67 + 36) |= 4u;
    *(void *)(v67 + 24) = v68;
    goto LABEL_88;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BD0F8);
  }
  int v20 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    sub_101522B64((int *)a2, buf);
    uint64_t v21 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)uint64_t v101 = 136315138;
    *(void *)&v101[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "#locctl,#rec,recordMessage,CLLocationProvider_Type,unsupported message type,%s", v101, 0xCu);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    sub_101522B64((int *)a2, v101);
    if (v101[23] >= 0) {
      unsigned int v22 = v101;
    }
    else {
      unsigned int v22 = *(unsigned char **)v101;
    }
    int v106 = 136315138;
    uint64_t v107 = v22;
    int v19 = (char *)_os_log_send_and_compose_impl();
    if ((v101[23] & 0x80000000) != 0) {
      operator delete(*(void **)v101);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerRecorder::recordMessage(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v19);
    if (v19 != buf) {
      goto LABEL_54;
    }
  }
}

void sub_10016751C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

uint64_t sub_100167650(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 0x80u;
  if (!*(void *)(a1 + 56)) {
    operator new();
  }
  return *(void *)(a1 + 56);
}

void sub_1001676AC()
{
}

void sub_1001676D0(void *a1)
{
  *a1 = off_102322508;
  uint64_t v2 = (wireless_diagnostics::google::protobuf::internal::ExtensionSet *)(a1 + 1);
  sub_100167730(a1);
  wireless_diagnostics::google::protobuf::internal::ExtensionSet::~ExtensionSet(v2);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void *sub_100167730(void *result)
{
  if ((void *)qword_10248D2B8 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[4];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    double result = (void *)v1[5];
    if (result)
    {
      int v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

void sub_1001677D0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102322490;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100167824(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022CEC88;
  sub_10016788C(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_10016788C(void *result)
{
  if ((void *)qword_10248A400 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    uint64_t v11 = v1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    uint64_t v12 = v1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = v1[12];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    uint64_t v14 = v1[13];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    uint64_t v15 = v1[14];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v16 = v1[15];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
    uint64_t v17 = v1[16];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    uint64_t v18 = v1[17];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
    uint64_t v19 = v1[18];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    uint64_t v20 = v1[19];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
    uint64_t v21 = v1[20];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    }
    uint64_t v22 = v1[21];
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    uint64_t v23 = v1[22];
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    uint64_t v24 = v1[23];
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    }
    uint64_t v25 = v1[24];
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
    uint64_t v26 = v1[25];
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
    uint64_t v27 = v1[26];
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    uint64_t v28 = v1[27];
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
    }
    uint64_t v29 = v1[28];
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    }
    uint64_t v30 = v1[29];
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
    }
    uint64_t v31 = v1[30];
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
    uint64_t v32 = v1[31];
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
    }
    uint64_t v33 = v1[32];
    if (v33) {
      (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
    }
    uint64_t v34 = v1[33];
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    }
    uint64_t v35 = v1[34];
    if (v35) {
      (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    }
    uint64_t v36 = v1[35];
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
    }
    uint64_t v37 = v1[36];
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
    }
    uint64_t v38 = v1[37];
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
    uint64_t v39 = v1[38];
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
    }
    uint64_t v40 = v1[39];
    if (v40) {
      (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
    }
    uint64_t v41 = v1[40];
    if (v41) {
      (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
    }
    uint64_t v42 = v1[41];
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
    }
    uint64_t v43 = v1[42];
    if (v43) {
      (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
    }
    uint64_t v44 = v1[43];
    if (v44) {
      (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
    }
    uint64_t v45 = v1[44];
    if (v45) {
      (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
    }
    uint64_t v46 = v1[45];
    if (v46) {
      (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
    }
    uint64_t v47 = v1[46];
    if (v47) {
      (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
    }
    uint64_t v48 = v1[47];
    if (v48) {
      (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
    }
    uint64_t v49 = v1[48];
    if (v49) {
      (*(void (**)(uint64_t))(*(void *)v49 + 8))(v49);
    }
    uint64_t v50 = v1[49];
    if (v50) {
      (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
    }
    uint64_t v51 = v1[50];
    if (v51) {
      (*(void (**)(uint64_t))(*(void *)v51 + 8))(v51);
    }
    uint64_t v52 = v1[51];
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
    }
    uint64_t v53 = v1[52];
    if (v53) {
      (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
    }
    uint64_t v54 = v1[53];
    if (v54) {
      (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
    }
    uint64_t v55 = v1[54];
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
    }
    uint64_t v56 = v1[55];
    if (v56) {
      (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
    }
    uint64_t v57 = v1[56];
    if (v57) {
      (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
    }
    uint64_t v58 = v1[57];
    if (v58) {
      (*(void (**)(uint64_t))(*(void *)v58 + 8))(v58);
    }
    uint64_t v59 = v1[58];
    if (v59) {
      (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
    }
    double result = (void *)v1[59];
    if (result)
    {
      uint64_t v60 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v60();
    }
  }
  return result;
}

void sub_1001682F8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102305460;
  sub_100168360(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_100168360(void *result)
{
  if ((void *)qword_10248AF70 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    uint64_t v11 = v1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    uint64_t v12 = v1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = v1[12];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    uint64_t v14 = v1[13];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    uint64_t v15 = v1[14];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v16 = v1[15];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
    uint64_t v17 = v1[16];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    uint64_t v18 = v1[17];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
    uint64_t v19 = v1[18];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    uint64_t v20 = v1[19];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
    uint64_t v21 = v1[20];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    }
    double result = (void *)v1[21];
    if (result)
    {
      uint64_t v22 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v22();
    }
  }
  return result;
}

void sub_100168744(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023053E8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100168798(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AE950;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_1001687F0(void *a1)
{
  *a1 = off_102322508;
  wireless_diagnostics::google::protobuf::internal::ExtensionSet::ExtensionSet((wireless_diagnostics::google::protobuf::internal::ExtensionSet *)(a1 + 1));
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  return a1;
}

void sub_10016883C(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

__n128 sub_100168854@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  if (!a1[1].n128_u8[8])
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022E7D18);
    }
    uint64_t v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      unint64_t v5 = a1->n128_u64[1];
      unint64_t v6 = a1[1].n128_u64[0];
      *(_DWORD *)uint64_t buf = 134349312;
      unint64_t v10 = v5;
      __int16 v11 = 2050;
      unint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "LocationController,#time,getTimestamp,#Warning: current latched timestamp is invalid,mct_sec,%{public}.3f,cfat_sec,%{public}.3f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022E7D18);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLUtils::Timestamp CLLocationControllerLatchedTime::getTimestamp()", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  __n128 result = *a1;
  *a2 = *a1;
  a2[1].n128_u8[8] = a1[1].n128_u8[8];
  return result;
}

uint64_t sub_100168A44(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v3 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#locctl,#rec,write:protobuf serializer object not initialized", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    LOWORD(__p[0]) = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLLocationControllerRecorder::write(const CLP::LogEntry::LogEntry &)", "%s\n", v4);
    goto LABEL_30;
  }
  if (!*(unsigned char *)(a1 + 24))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    unint64_t v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#locctl,#rec,write:session not open", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    LOWORD(__p[0]) = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationControllerRecorder::write(const CLP::LogEntry::LogEntry &)", "%s\n", v4);
LABEL_30:
    if (v4 != (char *)buf) {
      free(v4);
    }
    return 0;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  uint64_t v2 = wireless_diagnostics::google::protobuf::MessageLite::SerializeToString();
  if (v2)
  {
    sub_100168EAC(*(void *)(a1 + 16), (uint64_t)__p);
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    unint64_t v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#locctl,#rec,write:could not serialize protobuf message", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022BD0F8);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLocationControllerRecorder::write(const CLP::LogEntry::LogEntry &)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100168E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100168EAC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 125))
  {
    uint64_t v4 = (void *)(a1 + 8);
    memset(&__p, 0, sizeof(__p));
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) >= 0x1C3uLL)
    {
      std::string::size_type v5 = 0;
      while (1)
      {
        std::string::basic_string(&v44, (const std::string *)a2, v5, 0x1C2uLL, (std::allocator<char> *)buf);
        sub_1012131F8((uint64_t *)&v44, &__p);
        if (!v5) {
          break;
        }
        if (*(char *)(a2 + 23) >= 0) {
          unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          unint64_t v6 = *(void *)(a2 + 8);
        }
        if (v6 <= v5 + 450)
        {
          if (qword_1024194C0 != -1) {
            dispatch_once(&qword_1024194C0, &stru_102318920);
          }
          uint64_t v19 = qword_1024194C8;
          if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_INFO))
          {
            uint64_t v20 = (void *)(a1 + 8);
            if (*(char *)(a1 + 31) < 0) {
              uint64_t v20 = (void *)*v4;
            }
            int v21 = *(_DWORD *)(a1 + 740);
            p_p = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)uint64_t buf = 136446723;
            uint64_t v53 = v20;
            __int16 v54 = 1026;
            int v55 = v21;
            __int16 v56 = 2081;
            uint64_t v57 = p_p;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "#p%{public}s,#me,%{public}d,%{private}s", buf, 0x1Cu);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024194C0 != -1) {
              dispatch_once(&qword_1024194C0, &stru_102318920);
            }
            uint64_t v24 = (void *)(a1 + 8);
            if (*(char *)(a1 + 31) < 0) {
              uint64_t v24 = (void *)*v4;
            }
            int v25 = *(_DWORD *)(a1 + 740);
            uint64_t v26 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            int v46 = 136446723;
            uint64_t v47 = v24;
            __int16 v48 = 1026;
            int v49 = v25;
            __int16 v50 = 2081;
            uint64_t v51 = v26;
            uint64_t v27 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLProtobufSerializer::append(const std::string &)", "%s\n", v27);
            if (v27 != (char *)buf) {
              free(v27);
            }
          }
          char v18 = 0;
          goto LABEL_46;
        }
        if (qword_1024194C0 != -1) {
          dispatch_once(&qword_1024194C0, &stru_102318920);
        }
        uint64_t v7 = qword_1024194C8;
        if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_INFO))
        {
          uint64_t v8 = (void *)(a1 + 8);
          if (*(char *)(a1 + 31) < 0) {
            uint64_t v8 = (void *)*v4;
          }
          int v9 = *(_DWORD *)(a1 + 740);
          uint64_t v10 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)uint64_t buf = 136446723;
          uint64_t v53 = v8;
          __int16 v54 = 1026;
          int v55 = v9;
          __int16 v56 = 2081;
          uint64_t v57 = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "#p%{public}s,#mm,%{public}d,%{private}s", buf, 0x1Cu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024194C0 != -1) {
            dispatch_once(&qword_1024194C0, &stru_102318920);
          }
          __int16 v11 = (void *)(a1 + 8);
          if (*(char *)(a1 + 31) < 0) {
            __int16 v11 = (void *)*v4;
          }
          int v12 = *(_DWORD *)(a1 + 740);
          uint64_t v13 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
LABEL_56:
          int v46 = 136446723;
          uint64_t v47 = v11;
          __int16 v48 = 1026;
          int v49 = v12;
          __int16 v50 = 2081;
          uint64_t v51 = v13;
          uint64_t v23 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLProtobufSerializer::append(const std::string &)", "%s\n", v23);
          if (v23 != (char *)buf) {
            free(v23);
          }
        }
LABEL_35:
        char v18 = 1;
LABEL_46:
        if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v44.__r_.__value_.__l.__data_);
        }
        v5 += 450;
        if ((v18 & 1) == 0) {
          goto LABEL_75;
        }
      }
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102318920);
      }
      uint64_t v14 = qword_1024194C8;
      if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_INFO))
      {
        uint64_t v15 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          uint64_t v15 = (void *)*v4;
        }
        int v16 = *(_DWORD *)(a1 + 740);
        uint64_t v17 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t buf = 136446723;
        uint64_t v53 = v15;
        __int16 v54 = 1026;
        int v55 = v16;
        __int16 v56 = 2081;
        uint64_t v57 = v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "#p%{public}s,#ms,%{public}d,%{private}s", buf, 0x1Cu);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_35;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102318920);
      }
      __int16 v11 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        __int16 v11 = (void *)*v4;
      }
      int v12 = *(_DWORD *)(a1 + 740);
      uint64_t v13 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      goto LABEL_56;
    }
    sub_1012131F8((uint64_t *)a2, &__p);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102318920);
    }
    uint64_t v28 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_INFO))
    {
      uint64_t v29 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v29 = (void *)*v4;
      }
      int v30 = *(_DWORD *)(a1 + 740);
      uint64_t v31 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 136446723;
      uint64_t v53 = v29;
      __int16 v54 = 1026;
      int v55 = v30;
      __int16 v56 = 2081;
      uint64_t v57 = v31;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "#p%{public}s,#s,%{public}d,%{private}s", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102318920);
      }
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      int v37 = *(_DWORD *)(a1 + 740);
      uint64_t v38 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      int v46 = 136446723;
      uint64_t v47 = v4;
      __int16 v48 = 1026;
      int v49 = v37;
      __int16 v50 = 2081;
      uint64_t v51 = v38;
      uint64_t v39 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLProtobufSerializer::append(const std::string &)", "%s\n", v39);
      if (v39 != (char *)buf) {
        free(v39);
      }
    }
LABEL_75:
    ++*(_DWORD *)(a1 + 740);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (qword_10248B398 && *(unsigned char *)(a1 + 126))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v32 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v32 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a2 + 8);
    }
    if (v32 >= 0x80) {
      uint64_t v33 = (int)wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v32, a2);
    }
    else {
      uint64_t v33 = 1;
    }
    sub_10016995C(&__p, v33 + v32 + 4);
    wireless_diagnostics::google::protobuf::io::ArrayOutputStream::ArrayOutputStream((wireless_diagnostics::google::protobuf::io::ArrayOutputStream *)buf, __p.__r_.__value_.__l.__data_, LODWORD(__p.__r_.__value_.__r.__words[1]) - LODWORD(__p.__r_.__value_.__l.__data_), -1);
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::CodedOutputStream();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&v46, v32);
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v34 = (const void *)a2;
    }
    else {
      uint64_t v34 = *(const void **)a2;
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteRaw((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&v46, v34, (int)v32);
    unsigned int v35 = cnlogging::details::CNProtobufStreamChecksum::adler32();
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteLittleEndian32((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&v46, v35);
    uint64_t v36 = qword_10248B398;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768;
    block[2] = sub_10008A534;
    block[3] = &unk_1023188E0;
    block[4] = a1;
    block[5] = v33 + v32 + 4;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint64_t v41 = 0;
    sub_10016989C(&v41, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
    dispatch_async(v36, block);
    if (v41)
    {
      uint64_t v42 = v41;
      operator delete(v41);
    }
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::~CodedOutputStream((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)&v46);
    wireless_diagnostics::google::protobuf::io::ArrayOutputStream::~ArrayOutputStream((wireless_diagnostics::google::protobuf::io::ArrayOutputStream *)buf);
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100169810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10016989C(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    unint64_t v6 = result;
    __n128 result = sub_100169918(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1001698FC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100169918(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_1001D7FD4();
  }
  __n128 result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *sub_10016995C(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_100169918(a1, a2);
    uint64_t v4 = (char *)a1[1];
    std::string::size_type v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1001699B4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001699D0(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 0x400u;
  if (!*(void *)(a1 + 72)) {
    operator new();
  }
  return *(void *)(a1 + 72);
}

void sub_100169A2C()
{
}

void sub_100169A50(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102304EC0;
  sub_100169AB8(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_100169AB8(void *result)
{
  if ((void *)qword_10248AF00 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[2];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    __n128 result = (void *)v1[3];
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

BOOL sub_100169B58(unsigned int a1)
{
  return a1 < 0x31;
}

double sub_100169B64(uint64_t a1)
{
  *(void *)a1 = off_102304EC0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

uint64_t sub_100169B90(int *a1)
{
  if (*a1 < 0x30) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "ConvertLocationProviderNotificationTypeToProtobuf,unhandled type,%{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::LocationProviderNotification_NotificationType ConvertLocationProviderNotificationTypeToProtobuf(const CLLocationProvider_Type::Notification &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_100169D64(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 0x100u;
  if (!*(void *)(a1 + 64)) {
    operator new();
  }
  return *(void *)(a1 + 64);
}

void sub_100169DC0()
{
}

void sub_100169DE4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102304DD0;
  sub_100169E8C(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_100169E4C(uint64_t a1)
{
  *(void *)a1 = off_102304DD0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  return result;
}

void *sub_100169E8C(void *result)
{
  if ((void *)qword_10248AF08 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[7];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[8];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[9];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[10];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[11];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    double result = (void *)v1[12];
    if (result)
    {
      __int16 v11 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v11();
    }
  }
  return result;
}

void sub_10016A08C(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  *(_DWORD *)uint64_t buf = 1;
  v85[0] = 1;
  v85[1] = sub_10016A9AC((int *)buf);
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v9 = sub_10016AB88();
  *(_DWORD *)uint64_t buf = 4;
  int v86 = v8;
  sub_100166814(v9, (unsigned int *)buf, (int32x4_t *)(a1 + 5124), v85, &v86, a2, a3);
  if (!*a2)
  {
    if (qword_102419650 != -1) {
      dispatch_once(&qword_102419650, &stru_1022C1840);
    }
    uint64_t v10 = qword_102419658;
    if (os_log_type_enabled((os_log_t)qword_102419658, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v46 = *(void *)(a3 + 4);
      uint64_t v52 = *(void *)(a3 + 12);
      uint64_t v58 = *(void *)(a3 + 20);
      unsigned int v11 = *(_DWORD *)(a3 + 96);
      __int16 v50 = sub_10003E9A4(v11);
      uint64_t v56 = *(void *)(a3 + 44);
      uint64_t v62 = *(void *)(a3 + 60);
      int v66 = *(_DWORD *)(a3 + 84);
      uint64_t v70 = *(void *)(a3 + 88);
      uint64_t v74 = *(void *)(a3 + 28);
      uint64_t v78 = *(void *)(a3 + 36);
      uint64_t v82 = *(void *)(a3 + 76);
      uint64_t v12 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 0;
      double v13 = sub_10016BA54(v12, buf) - *(double *)(a3 + 76);
      uint64_t v14 = *(void *)(a3 + 184);
      uint64_t v15 = *(void *)(a3 + 52);
      int v83 = a4;
      uint64_t v16 = *(void *)(a3 + 68);
      int v17 = *(_DWORD *)(a3 + 124);
      int v44 = *(_DWORD *)(a3 + 128);
      uint64_t v48 = *(void *)(a3 + 100);
      uint64_t v54 = *(void *)(a3 + 108);
      uint64_t v60 = *(void *)(a3 + 116);
      int v64 = *(_DWORD *)(a3 + 132);
      int v68 = *(_DWORD *)(a3 + 136);
      int v72 = *(unsigned __int8 *)(a3 + 516);
      int v76 = *(_DWORD *)(a3 + 696);
      int v80 = *(_DWORD *)(a3 + 140);
      uint64_t v18 = sub_10016BA10();
      double v19 = sub_10018202C(v18);
      *(_DWORD *)uint64_t buf = 136322306;
      *(void *)uint64_t v143 = "CL";
      *(_WORD *)&v143[8] = 1024;
      *(_DWORD *)&v143[10] = 1;
      *(_WORD *)&v143[14] = 2048;
      *(void *)&v143[16] = v46;
      *(_WORD *)&v143[24] = 2048;
      *(void *)&v143[26] = v52;
      *(_WORD *)&v143[34] = 2048;
      *(void *)&v143[36] = v58;
      __int16 v144 = 1024;
      unsigned int v145 = v11;
      __int16 v146 = 2080;
      uint64_t v147 = v50;
      __int16 v148 = 2048;
      uint64_t v149 = v56;
      __int16 v150 = 2048;
      uint64_t v151 = v62;
      __int16 v152 = 1024;
      int v153 = v66;
      __int16 v154 = 2048;
      uint64_t v155 = v70;
      __int16 v156 = 2048;
      uint64_t v157 = v74;
      __int16 v158 = 2048;
      uint64_t v159 = v78;
      __int16 v160 = 2048;
      uint64_t v161 = v82;
      __int16 v162 = 2048;
      double v163 = v13;
      __int16 v164 = 2048;
      uint64_t v165 = v14;
      __int16 v166 = 1024;
      int v167 = v17;
      __int16 v168 = 2048;
      uint64_t v169 = v15;
      __int16 v170 = 2048;
      uint64_t v171 = v16;
      a4 = v83;
      __int16 v172 = 1024;
      int v173 = v44;
      __int16 v174 = 2048;
      uint64_t v175 = v48;
      __int16 v176 = 2048;
      uint64_t v177 = v54;
      __int16 v178 = 2048;
      uint64_t v179 = v60;
      __int16 v180 = 1024;
      int v181 = v64;
      __int16 v182 = 1024;
      int v183 = v68;
      __int16 v184 = 1024;
      int v185 = v72;
      __int16 v186 = 1024;
      int v187 = v76;
      __int16 v188 = 1024;
      int v189 = v80;
      __int16 v190 = 2050;
      double v191 = v19;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,LocationTimestamp,%.3f,Age,%.3f,timestampGps,%.3lf,floor,%d,SpeedAccuracy,%.3lf,CourseAccuracy,%.1lf,integrity,%d,rawLat,%.7lf,rawLon,%.7lf,rawCourse,%.2f,refFrame,%d,rawRefFrame,%d,propagated,%d,gnssContent,%d,signalEnv,%d,propagation_us,%{public}.3f", buf, 0xFCu);
    }
    if (sub_10013D1A0(117, 2))
    {
      bzero(buf, 0x65CuLL);
      int v84 = a4;
      if (qword_102419650 != -1) {
        dispatch_once(&qword_102419650, &stru_1022C1840);
      }
      uint64_t v30 = *(void *)(a3 + 4);
      uint64_t v31 = *(void *)(a3 + 12);
      uint64_t v32 = *(void *)(a3 + 20);
      unsigned int v33 = *(_DWORD *)(a3 + 96);
      uint64_t v34 = sub_10003E9A4(v33);
      uint64_t v43 = *(void *)(a3 + 44);
      uint64_t v45 = *(void *)(a3 + 60);
      int v49 = *(_DWORD *)(a3 + 84);
      uint64_t v53 = *(void *)(a3 + 88);
      uint64_t v55 = *(void *)(a3 + 28);
      uint64_t v59 = *(void *)(a3 + 36);
      double v63 = *(double *)(a3 + 76);
      double v35 = sub_1005BFA38() - v63;
      uint64_t v51 = *(void *)(a3 + 184);
      uint64_t v57 = *(void *)(a3 + 52);
      uint64_t v61 = *(void *)(a3 + 68);
      int v47 = *(_DWORD *)(a3 + 124);
      int v65 = *(_DWORD *)(a3 + 128);
      uint64_t v67 = *(void *)(a3 + 100);
      uint64_t v69 = *(void *)(a3 + 108);
      uint64_t v71 = *(void *)(a3 + 116);
      int v73 = *(_DWORD *)(a3 + 132);
      int v75 = *(_DWORD *)(a3 + 136);
      int v77 = *(unsigned __int8 *)(a3 + 516);
      int v79 = *(_DWORD *)(a3 + 696);
      int v81 = *(_DWORD *)(a3 + 140);
      uint64_t v36 = sub_10016BA10();
      double v37 = sub_10018202C(v36);
      int v86 = 136322306;
      double v87 = COERCE_DOUBLE("CL");
      __int16 v88 = 1024;
      *(_DWORD *)uint64_t v89 = 1;
      *(_WORD *)&v89[4] = 2048;
      *(void *)&v89[6] = v30;
      __int16 v90 = 2048;
      uint64_t v91 = v31;
      __int16 v92 = 2048;
      uint64_t v93 = v32;
      __int16 v94 = 1024;
      unsigned int v95 = v33;
      __int16 v96 = 2080;
      char v97 = v34;
      __int16 v98 = 2048;
      uint64_t v99 = v43;
      __int16 v100 = 2048;
      uint64_t v101 = v45;
      __int16 v102 = 1024;
      int v103 = v49;
      __int16 v104 = 2048;
      uint64_t v105 = v53;
      __int16 v106 = 2048;
      uint64_t v107 = v55;
      __int16 v108 = 2048;
      uint64_t v109 = v59;
      __int16 v110 = 2048;
      double v111 = v63;
      __int16 v112 = 2048;
      double v113 = v35;
      __int16 v114 = 2048;
      uint64_t v115 = v51;
      __int16 v116 = 1024;
      int v117 = v47;
      __int16 v118 = 2048;
      uint64_t v119 = v57;
      __int16 v120 = 2048;
      uint64_t v121 = v61;
      __int16 v122 = 1024;
      int v123 = v65;
      __int16 v124 = 2048;
      uint64_t v125 = v67;
      __int16 v126 = 2048;
      uint64_t v127 = v69;
      __int16 v128 = 2048;
      uint64_t v129 = v71;
      __int16 v130 = 1024;
      int v131 = v73;
      __int16 v132 = 1024;
      int v133 = v75;
      __int16 v134 = 1024;
      int v135 = v77;
      __int16 v136 = 1024;
      int v137 = v79;
      __int16 v138 = 1024;
      int v139 = v81;
      __int16 v140 = 2050;
      double v141 = v37;
      uint64_t v38 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("LOCATION", 1, 0, 2, "virtual void CLLocationController::notifyClientsWithData(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, BOOL, int, BOOL)", "%s\n", v38);
      if (v38 != (char *)buf) {
        free(v38);
      }
      a4 = v84;
    }
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C18A0);
    }
    uint64_t v20 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = *a2;
      *(_DWORD *)uint64_t buf = 68289795;
      *(_WORD *)&v143[4] = 2082;
      *(_DWORD *)uint64_t v143 = 0;
      *(void *)&v143[6] = "";
      *(_WORD *)&v143[14] = 1040;
      *(_DWORD *)&v143[16] = 156;
      *(_WORD *)&v143[20] = 2097;
      *(void *)&v143[22] = a3;
      *(_WORD *)&v143[30] = 2050;
      *(void *)&v143[32] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Notifying clients with location\", \"location\":%{private, location:CLClientLocation}.*P, \"notification\":%{public, location:CLLocationProvider_Type::Notification}lld}", buf, 0x2Cu);
    }
    double v22 = *(double *)(a3 + 88);
    if (v22 >= 0.0)
    {
      double v23 = v22 + *(double *)(a3 + 76);
      uint64_t v24 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 0;
      if (v23 < sub_10016BA54(v24, buf))
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        int v25 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = sub_10016BA10();
          *(_DWORD *)uint64_t buf = 0;
          double v27 = sub_10016BA54(v26, buf) - *(double *)(a3 + 76);
          uint64_t v28 = sub_10016BA10();
          double v29 = sub_10018202C(v28);
          *(_DWORD *)uint64_t buf = 134349312;
          *(double *)uint64_t v143 = v27;
          *(_WORD *)&v143[8] = 2050;
          *(double *)&v143[10] = v29;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "LocationController,#Warning,Notifying clients of an already-expired location,age,%{public}.3f,propagation_us,%{public}.3f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          double v39 = sub_1005BFA38() - *(double *)(a3 + 76);
          uint64_t v40 = sub_10016BA10();
          double v41 = sub_10018202C(v40);
          int v86 = 134349312;
          double v87 = v39;
          __int16 v88 = 2050;
          *(double *)uint64_t v89 = v41;
          uint64_t v42 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationController::notifyClientsWithData(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, BOOL, int, BOOL)", "%s\n", v42);
          if (v42 != (char *)buf) {
            free(v42);
          }
        }
      }
    }
  }
  sub_1000EE180((char *)a1, a2, a3, a4, 0xFFFFFFFFLL, 0);
}

uint64_t sub_10016A9AC(int *a1)
{
  uint64_t v1 = *a1;
  if (v1 < 0x1B) {
    return dword_101E0FDB0[v1];
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10232C3D0);
  }
  uint64_t v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67109120;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#locctl,#rec,serviceTypeToSiloType,unhandled type,%d", buf, 8u);
  }
  BOOL v6 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10232C3D0);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static CLLocationControllerRecorder_Types::SiloType CLLocationControllerRecorder_Types::Silo::serviceTypeToSiloType(const CLLocationControllerRecorder_Types::ServiceType &)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
    return 0;
  }
  return result;
}

uint64_t sub_10016AB88()
{
  if (qword_10247C650 != -1) {
    dispatch_once(&qword_10247C650, &stru_1022BD0D8);
  }
  return qword_10248A0C8;
}

uint64_t sub_10016ABCC(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 2u;
  if (!*(void *)(a1 + 16)) {
    operator new();
  }
  return *(void *)(a1 + 16);
}

void sub_10016AC28()
{
}

BOOL sub_10016AC4C(uint64_t a1, unsigned int a2)
{
  BOOL result = sub_10016E644(a2);
  if (!result) {
    sub_101A66608();
  }
  *(_DWORD *)(a1 + 112) |= 0x200u;
  *(_DWORD *)(a1 + 104) = a2;
  return result;
}

uint64_t sub_10016AC90(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 1u;
  if (!*(void *)(a1 + 8)) {
    operator new();
  }
  return *(void *)(a1 + 8);
}

void sub_10016ACEC()
{
}

uint64_t sub_10016AD10(uint64_t result)
{
  *(void *)BOOL result = off_102304290;
  *(void *)(result + 8) = 0;
  *(unsigned char *)(result + 16) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 20) = 0;
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(void *)(result + 48) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 72) = 0;
  return result;
}

double sub_10016AD54(uint64_t a1)
{
  *(void *)a1 = off_1022AEF68;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  *(_WORD *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0xFFFFFFFFLL;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 130) = 0u;
  *(_OWORD *)(a1 + 146) = 0u;
  *(_OWORD *)(a1 + 162) = 0u;
  *(_OWORD *)(a1 + 178) = 0u;
  *(_OWORD *)(a1 + 194) = 0u;
  *(_OWORD *)(a1 + 210) = 0u;
  *(_OWORD *)(a1 + 226) = 0u;
  *(_OWORD *)(a1 + 242) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 114) = 0u;
  *(void *)(a1 + 364) = 0;
  *(_OWORD *)(a1 + 258) = 0u;
  *(_OWORD *)(a1 + 341) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  return result;
}

void sub_10016ADEC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AF1C0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_10016AE40(uint64_t a1)
{
  *(void *)a1 = off_1022AF1C0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

void sub_10016AE6C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_10016AEA4(a1);

  operator delete();
}

void sub_10016AEA4(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102304308;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248AE38 != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_10016AF30(uint64_t *a1)
{
  sub_10016AF68(a1);

  operator delete();
}

void sub_10016AF68(uint64_t *a1)
{
  *a1 = (uint64_t)off_102304290;
  uint64_t v2 = a1 + 3;
  sub_10016AFCC(a1);
  sub_10016B2E8(v2);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void *sub_10016AFCC(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[6];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  if ((void *)qword_10248AE48 != result)
  {
    uint64_t v4 = result[1];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    double result = (void *)v1[7];
    if (result)
    {
      int v5 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v5();
    }
  }
  return result;
}

void *sub_10016B0AC(void *result)
{
  *double result = &off_102304308;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

void sub_10016B0D0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AF0D0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_10016B124(void *result)
{
  *double result = off_1022AF0D0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

void sub_10016B148(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AED10;
  sub_10016B1B0(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_10016B1B0(void *result)
{
  if ((void *)qword_102489CE0 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    double result = (void *)v1[12];
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

void sub_10016B250(uint64_t *a1)
{
  sub_10016B288(a1);

  operator delete();
}

void sub_10016B288(uint64_t *a1)
{
  *a1 = (uint64_t)off_1022AEF68;
  sub_10016B3E0(a1);
  sub_10016B2E8(a1 + 36);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

uint64_t sub_10016B2E8(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 3);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*a1 + 8 * i);
      if (v4)
      {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
        int v2 = *((_DWORD *)a1 + 3);
      }
    }
  }
  uint64_t result = *a1;
  if (*a1)
  {
    operator delete[]();
  }
  return result;
}

void sub_10016B38C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AEEF0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_10016B3E0(void *result)
{
  if ((void *)qword_102489D00 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[8];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[11];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[13];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[17];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[26];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t result = (void *)v1[40];
    if (result)
    {
      uint64_t v7 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v7();
    }
  }
  return result;
}

void sub_10016B530(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AEC98;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10016B584(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AEE00;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10016B5D8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AED88;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_10016B62C(uint64_t a1)
{
  *(void *)a1 = off_1022AED10;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(_OWORD *)(a1 + 120) = xmmword_101D1D160;
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  return result;
}

void sub_10016B684(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022AF058;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_10016B6D8(uint64_t a1)
{
  *(void *)a1 = off_1022AF058;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  return result;
}

void sub_10016B708(uint64_t a1)
{
  uint64_t v2 = sub_10016BA10();
  sub_10016BC44((uint64_t)buf);
  sub_10016BE74(v2, (uint64_t *)buf);
  uint64_t v3 = *(void *)(a1 + 304);
  if (v3)
  {
    uint64_t v4 = sub_10016BA10();
    LODWORD(buf[0]) = 1;
    double v5 = sub_10016BA54(v4, buf);
    sub_10016CA44(v3, v5);
  }
  uint64_t v6 = (__n128 *)sub_10016BA10();
  sub_100168854(v6, v15);
  uint64_t v7 = sub_10016AB88();
  sub_100165630(v7, (uint64_t)v15);
  uint64_t v8 = (unsigned char *)(a1 + 5152);
  if (*(unsigned char *)(a1 + 5152) && v15[0].n128_f64[0] > *(double *)(a1 + 5144))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    int v9 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf[0]) = 134349056;
      *(double *)((char *)buf + 4) = v15[0].n128_f64[0];
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "#locctl,#rec,triggered client list record at time,mct,%{public}.3f", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022C17A0);
      }
      int v16 = 134349056;
      unint64_t v17 = v15[0].n128_u64[0];
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::handleHeartbeatRequest()", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    uint64_t v10 = sub_10016AB88();
    sub_10068018C((void *)a1, buf);
    sub_1005B5AF8(v10, buf);
    sub_100682F6C((uint64_t)buf, *(void **)&buf[1]);
    if (*v8) {
      *uint64_t v8 = 0;
    }
  }
  if (*(unsigned char *)(a1 + 5164) && !((int)v15[0].n128_f64[0] % *(_DWORD *)(a1 + 5160)))
  {
    uint64_t v11 = sub_10016AB88();
    sub_10068018C((void *)a1, buf);
    sub_1005B5AF8(v11, buf);
    sub_100682F6C((uint64_t)buf, *(void **)&buf[1]);
  }
  char v12 = *(unsigned char *)(a1 + 1888) == 0;
  uint64_t v13 = sub_10016BA10();
  LODWORD(buf[0]) = 1;
  buf[0] = sub_10016BA54(v13, buf);
  sub_10016CA48(a1 + 768, v12, buf);
}

void sub_10016B9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *a18)
{
}

uint64_t sub_10016BA10()
{
  if (qword_1024801E0 != -1) {
    dispatch_once(&qword_1024801E0, &stru_1022E7CF8);
  }
  return qword_10248A9D0;
}

double sub_10016BA54(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = (void *)a1;
  if (!*(unsigned char *)(a1 + 24))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022E7D18);
    }
    uint64_t v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = v3[1];
      uint64_t v6 = v3[2];
      *(_DWORD *)uint64_t buf = 134349312;
      uint64_t v10 = v5;
      __int16 v11 = 2050;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "LocationController,#time,getTime,#Warning: current latched timestamp is invalid,mct_sec,%{public}.3f,cfat_sec,%{public}.3f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022E7D18);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CFTimeInterval CLLocationControllerLatchedTime::getTime(const Type &)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (*a2 != 1)
  {
    if (*a2) {
      return result;
    }
    v3 += 2;
  }
  return *(double *)v3;
}

void sub_10016BC44(uint64_t a1@<X8>)
{
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  if (mach_get_times())
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022DE120);
    }
    uint64_t v2 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "TCONV,mach_get_times failed", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022DE120);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "Timestamp CLUtils::getTimestampNow()", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)a1 = _Q0;
    *(void *)(a1 + 16) = 0xBFF0000000000000;
    *(void *)(a1 + 24) = 0;
  }
  else
  {
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)a1 = _Q0;
    *(void *)(a1 + 16) = 0xBFF0000000000000;
    *(unsigned char *)(a1 + 24) = 0;
    *(double *)(a1 + 16) = sub_10016BE44(&v10);
    *(double *)(a1 + 8) = sub_1000D3D90(v12);
    *(double *)a1 = sub_1000D3D90(v11);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

double sub_10016BE44(uint64_t *a1)
{
  return (double)a1[1] / 1000000000.0 + (double)*a1 - kCFAbsoluteTimeIntervalSince1970;
}

void sub_10016BE74(uint64_t a1, uint64_t *a2)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022E7D18);
    }
    uint64_t v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *a2;
      uint64_t v6 = a2[2];
      int v7 = *((unsigned __int8 *)a2 + 24);
      *(_DWORD *)uint64_t buf = 134218496;
      uint64_t v11 = v5;
      __int16 v12 = 2048;
      uint64_t v13 = v6;
      __int16 v14 = 1024;
      int v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LocationController,#time,setTime,set for the first time,mct,%.3f,cfat,%.3f,isValid,%d", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022E7D18);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerLatchedTime::setTime(const CLUtils::Timestamp &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  long long v8 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)((char *)a2 + 9);
  *(_OWORD *)a1 = v8;
  *(double *)(a1 + 32) = sub_10016C458();
}

uint64_t sub_10016C08C(uint64_t a1, int a2, double a3)
{
  uint64_t result = sub_10016C0EC(a1, a3);
  if (result)
  {
    *(_DWORD *)a1 = a2;
    if (*(void *)(a1 + 32))
    {
      double v6 = *(double *)(a1 + 56);
      return sub_1000A3F84(a1 + 8, a2, v6);
    }
  }
  return result;
}

BOOL sub_10016C0EC(uint64_t a1, double a2)
{
  double v4 = sub_10016C458();
  double v5 = v4;
  if (v4 >= a2)
  {
    double v10 = v4 - *(double *)(a1 + 56);
    if (v10 <= 1.0)
    {
      BOOL result = 1;
      goto LABEL_23;
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022F0428);
    }
    uint64_t v11 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349568;
      double v13 = v10;
      __int16 v14 = 2050;
      double v15 = a2;
      __int16 v16 = 2050;
      double v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "AmbientLight,Timing,diff_rxtime,%{public}.2f,mat,%{public}.3f,mct,%{public}.3f", buf, 0x20u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022F0428);
      }
      int v9 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLAmbientLightDecisionTree::sanityCheckAmbientLightMeasurementTiming(const double)", "%s\n");
      goto LABEL_19;
    }
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022F0428);
    }
    double v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      double v13 = a2;
      __int16 v14 = 2050;
      double v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "AmbientLight,Timing,mct_lt_mat,mat,%{public}f,mct,%{public}f", buf, 0x16u);
    }
    BOOL v7 = sub_10013D1A0(115, 0);
    BOOL result = 0;
    if (v7)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022F0428);
      }
      int v9 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLAmbientLightDecisionTree::sanityCheckAmbientLightMeasurementTiming(const double)", "%s\n");
LABEL_19:
      if (v9 != buf) {
        free(v9);
      }
      BOOL result = 0;
    }
  }
LABEL_23:
  *(double *)(a1 + 56) = v5;
  return result;
}

double sub_10016C458()
{
  uint64_t v0 = mach_continuous_time();

  return sub_1000D3D90(v0);
}

void sub_10016C480(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (sub_10016C624(v3, a2)) {
      *(unsigned char *)(a1 + 128) = 0;
    }
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    double v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#pbio IO subscription not enabled.", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230B0E8);
      }
      double v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLProactiveInertialOdometryManager::updateSubscriptionState(CFTimeInterval)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

uint64_t sub_10016C624(uint64_t a1, double a2)
{
  if (sub_10016C9F4())
  {
    (**(void (***)(uint64_t, double))a1)(a1, a2);
    if (*(unsigned char *)(a1 + 8))
    {
      if (!*(unsigned char *)(a1 + 32))
      {
        sub_100EB8F14(a1);
        return 1;
      }
    }
    else if (*(unsigned char *)(a1 + 32))
    {
      sub_100EB92E8(a1);
      return 1;
    }
    return 0;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1023009F8);
  }
  double v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#pbio Proactive Inertial Odometry is not supported on this device.", buf, 2u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1023009F8);
    }
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLProactiveInertialOdometrySubscription::updateSubscriptionState(const CFTimeInterval)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
    return 0;
  }
  return result;
}

void sub_10016C82C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 32);
  int v2 = *(unsigned __int8 *)(a1 + 64);
  *(unsigned char *)(a1 + 32) = v2;
  if (v2 != v1)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301258);
    }
    double v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      int v5 = *(unsigned __int8 *)(a1 + 32);
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "#pbio, CLProactiveInertialOdometrySubscription_Phone, fPolicyStateIsSubscribe, %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102301258);
      }
      double v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLProactiveInertialOdometrySubscription_Phone::_updateSubscriptionState(const CFTimeInterval)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

BOOL sub_10016C9F4()
{
  sub_100103240();
  BOOL result = 1;
  if (!sub_10016CCBC() || (uint64_t v0 = sub_100103240(), (sub_10016CD00(v0) & 1) == 0))
  {
    sub_100103240();
    if (!sub_10010145C()) {
      return 0;
    }
    uint64_t v1 = sub_100103240();
    if ((sub_10016CD00(v1) & 1) == 0) {
      return 0;
    }
  }
  return result;
}

void sub_10016CA48(uint64_t a1, char a2, double *a3)
{
  *(unsigned char *)(a1 + 130) = a2;
  if (*a3 - *(double *)(a1 + 56) <= 0.909)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022ACD48);
    }
    int v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      double v6 = *a3;
      double v7 = *(double *)(a1 + 56);
      double v8 = *a3 - v7;
      *(_DWORD *)uint64_t buf = 134349568;
      double v11 = v6;
      __int16 v12 = 2050;
      double v13 = v7;
      __int16 v14 = 2050;
      double v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#GPSPowerSavings,heartbeat too fast,now,%{public}.3lf,last,%{public}.3lf,diff,%{public}.3lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022ACD48);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLGpsPowerSavingsMonitor::tickHeartbeat1Hz(BOOL, const CFTimeInterval &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  else
  {
    *(double *)(a1 + 56) = *a3;
    if (*(double *)(a1 + 184) > 0.0)
    {
      ++*(_DWORD *)(a1 + 152);
      sub_100397464(a1, a3);
    }
  }
}

uint64_t sub_10016CCBC()
{
  if (qword_10247D4A8 != -1) {
    dispatch_once(&qword_10247D4A8, &stru_1022C6710);
  }
  return byte_10247D4A0;
}

BOOL sub_10016CD04()
{
  if (sub_10016CDA0()) {
    return 1;
  }
  if (qword_10247D338 != -1) {
    dispatch_once(&qword_10247D338, &stru_1022C6590);
  }
  if (qword_10247D348 != -1) {
    dispatch_once(&qword_10247D348, &stru_1022C65D0);
  }
  BOOL result = 1;
  if ((dword_10247D340 - 99) >= 0x23) {
    return dword_10247D340 == 260;
  }
  return result;
}

uint64_t sub_10016CDA0()
{
  if (qword_10247D338 != -1) {
    dispatch_once(&qword_10247D338, &stru_1022C6590);
  }
  if (qword_10247D348 != -1) {
    dispatch_once(&qword_10247D348, &stru_1022C65D0);
  }
  uint64_t result = 1;
  if (((dword_10247D340 - 139) > 0x2D
     || ((1 << (dword_10247D340 + 117)) & 0x3FFFE000001DLL) == 0)
    && (dword_10247D340 - 219) >= 7
    && (dword_10247D340 - 78) >= 3)
  {
    return 0;
  }
  return result;
}

uint64_t sub_10016CE50(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled motion detected type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      double v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::Location_MotionDetectedType ConvertCLMotionDetectedTypeToProtobuf(const CLLocationProvider_Type::MotionDetected &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

double sub_10016D01C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v4 = sub_10016D87C((unsigned int *)a1);
    if (!sub_10016D80C(v4)) {
      sub_101A5EA4C();
    }
    int v5 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 48) = v4;
    *(_DWORD *)(a2 + 152) = v5 | 3;
    uint64_t v6 = *(void *)(a2 + 8);
    if (!v6) {
      operator new();
    }
    *(_DWORD *)(v6 + 28) |= 1u;
    *(_DWORD *)(a2 + 152) |= 2u;
    *(_DWORD *)(v6 + 28) |= 2u;
    *(_OWORD *)(v6 + 8) = *(_OWORD *)(a1 + 4);
    int v7 = *(_DWORD *)(a2 + 152);
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 20);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 36);
    *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 152) = v7 | 0x3FC;
    *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 68);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 84);
    uint64_t v8 = *(void *)(a1 + 88);
    *(_DWORD *)(a2 + 152) = v7 | 0xFFC;
    *(void *)(a2 + 88) = v8;
    unsigned int v9 = sub_10016D640((unsigned int *)(a1 + 96));
    if (!sub_10016D634(v9)) {
      sub_101A5EA20();
    }
    int v10 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 104) = v9;
    *(_DWORD *)(a2 + 152) = v10 | 0x3000;
    uint64_t v11 = *(void *)(a2 + 96);
    if (!v11) {
      operator new();
    }
    *(_DWORD *)(v11 + 28) |= 1u;
    *(_DWORD *)(a2 + 152) |= 0x2000u;
    *(_DWORD *)(v11 + 28) |= 2u;
    *(_OWORD *)(v11 + 8) = *(_OWORD *)(a1 + 100);
    uint64_t v12 = *(void *)(a1 + 116);
    int v13 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 152) = v13 | 0x4000;
    *(void *)(a2 + 112) = v12;
    int v14 = *(_DWORD *)(a1 + 124);
    *(_DWORD *)(a2 + 152) = v13 | 0xC000;
    *(_DWORD *)(a2 + 108) = v14;
    int v15 = sub_10016DC34((unsigned int *)(a1 + 128));
    if (!sub_10016D828(v15)) {
      sub_101A5E9F4();
    }
    *(_DWORD *)(a2 + 152) |= 0x10000u;
    *(_DWORD *)(a2 + 120) = v15;
    unsigned int v16 = sub_10016D468((unsigned int *)(a1 + 132));
    if (!sub_10016E644(v16)) {
      sub_101A5E9C8();
    }
    *(_DWORD *)(a2 + 152) |= 0x20000u;
    *(_DWORD *)(a2 + 124) = v16;
    unsigned int v17 = sub_10016D468((unsigned int *)(a1 + 136));
    if (!sub_10016E644(v17)) {
      sub_101A5E99C();
    }
    *(_DWORD *)(a2 + 152) |= 0x40000u;
    *(_DWORD *)(a2 + 128) = v17;
    *(_DWORD *)uint64_t buf = 0;
    switch(*(_DWORD *)(a1 + 140))
    {
      case 1:
        int v18 = 1;
        goto LABEL_26;
      case 2:
        int v18 = 2;
        goto LABEL_26;
      case 3:
        int v18 = 3;
        goto LABEL_26;
      case 4:
        int v18 = 4;
        goto LABEL_26;
      case 6:
        int v18 = 6;
LABEL_26:
        *(_DWORD *)uint64_t buf = v18;
        break;
      default:
        break;
    }
    int v22 = sub_10016DA54((int *)buf);
    if (!sub_10016D86C(v22)) {
      sub_101A5E970();
    }
    int v23 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 132) = v22;
    double result = *(double *)(a1 + 144);
    *(double *)(a2 + 136) = result;
    char v24 = *(unsigned char *)(a1 + 152);
    *(_DWORD *)(a2 + 152) = v23 | 0x380000;
    *(unsigned char *)(a2 + 144) = v24;
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v19 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "pLocation,Invalid pointer", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertCLDaemonLocationToProtobuf(const CLDaemonLocation &, CLP::LogEntry::PrivateData::DaemonLocation *)", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
  }
  return result;
}

void sub_10016D438()
{
}

uint64_t sub_10016D468(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled client location reference frame type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::ClientLocationReferenceFrameType ConvertCLClientLocationReferenceTypeToProtobuf(const CLClientLocationReferenceFrame &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_10016D634(unsigned int a1)
{
  return a1 < 0xE;
}

uint64_t sub_10016D640(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 0xE)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled location type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::LocationType ConvertCLLocationTypeToProtobuf(const CLLocationType &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_10016D80C(unsigned int a1)
{
  return a1 < 3 || a1 == 0xFFFF;
}

BOOL sub_10016D828(int a1)
{
  BOOL result = 1;
  if ((a1 - 25) > 0x32 || ((1 << (a1 - 25)) & 0x4000002000001) == 0) {
    return (a1 + 1) < 2;
  }
  return result;
}

BOOL sub_10016D86C(int a1)
{
  return (a1 + 1) < 8;
}

uint64_t sub_10016D87C(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result - 1) >= 2 && result != 0xFFFF)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v4 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Received unhandled client location suitability type: %{public}d", buf, 8u);
    }
    BOOL v6 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v6)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocation_ClientLocationSuitabilityType ConvertCLClientLocationSuitabilityTypeToProtobuf(const CLClientLocationSuitability &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016DA54(int *a1)
{
  uint64_t v2 = *a1;
  if v2 < 7 && ((0x5Fu >> v2)) {
    return dword_101E0B8A0[v2];
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled signal environment type: %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    BOOL v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::SignalEnvironment_SignalEnvironmentType ConvertCLSignalEnvironmentTypeToProtobuf(const CLSignalEnvironmentProvider_Type::SignalEnvironmentType &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10016DC34(unsigned int *a1)
{
  uint64_t result = *a1;
  if (((result - 25) > 0x32 || ((1 << (result - 25)) & 0x4000002000001) == 0)
    && result != 0)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v5 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Received unhandled location integrity type: %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocation_LocationIntegrityType ConvertCLLocationIntegrityTypeToProtobuf(const CLLocationIntegrity &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_10016DE1C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(a2 + 364);
    *(_OWORD *)(a2 + 8) = *(_OWORD *)a1;
    *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 16);
    *(void *)(a2 + 40) = *(void *)(a1 + 32);
    *(void *)(a2 + 48) = *(void *)(a1 + 40);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 48);
    char v5 = *(unsigned char *)(a1 + 52);
    *(_DWORD *)(a2 + 364) = v4 | 0x1FF;
    *(unsigned char *)(a2 + 112) = v5;
    unsigned int v6 = sub_10016F1D0((unsigned int *)(a1 + 56));
    if (!sub_100165F14(v6)) {
      sub_101A5EC30();
    }
    int v7 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 60) = v6;
    *(_DWORD *)(a2 + 364) = v7 | 0x600;
    uint64_t v8 = *(void *)(a2 + 64);
    if (!v8) {
      operator new();
    }
    *(_DWORD *)(v8 + 28) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x400u;
    *(_DWORD *)(v8 + 28) |= 2u;
    *(_OWORD *)(v8 + 8) = *(_OWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 80);
    int v10 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 364) = v10 | 0x800;
    *(void *)(a2 + 72) = v9;
    int v11 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a2 + 364) = v10 | 0x1800;
    *(_DWORD *)(a2 + 80) = v11;
    *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 92);
    *(unsigned char *)(a2 + 113) = *(unsigned char *)(a1 + 96);
    *(_DWORD *)(a2 + 364) = v10 | 0x807800;
    uint64_t v12 = *(void *)(a2 + 136);
    if (!v12) {
      operator new();
    }
    *(_DWORD *)(v12 + 32) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    *(_DWORD *)(v12 + 32) |= 2u;
    *(_OWORD *)(v12 + 8) = *(_OWORD *)(a1 + 104);
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    char v13 = *(unsigned char *)(a1 + 120);
    *(_DWORD *)(v12 + 32) |= 4u;
    *(unsigned char *)(v12 + 24) = v13;
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    char v14 = *(unsigned char *)(a1 + 121);
    *(_DWORD *)(v12 + 32) |= 8u;
    *(unsigned char *)(v12 + 25) = v14;
    *(_DWORD *)(a2 + 364) |= 0x8000u;
    uint64_t v15 = *(void *)(a2 + 88);
    if (!v15) {
      operator new();
    }
    *(_DWORD *)(v15 + 28) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x8000u;
    *(_DWORD *)(v15 + 28) |= 2u;
    *(_OWORD *)(v15 + 8) = *(_OWORD *)(a1 + 296);
    int v16 = sub_10016E684((unsigned int *)(a1 + 312));
    if (!sub_10016E674(v16)) {
      sub_101A5EC04();
    }
    int v17 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 96) = v16;
    *(_DWORD *)(a2 + 100) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a2 + 364) = v17 | 0x70000;
    uint64_t v18 = *(void *)(a2 + 104);
    if (!v18) {
      operator new();
    }
    *(_DWORD *)(v18 + 28) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x40000u;
    *(_DWORD *)(v18 + 28) |= 2u;
    *(_OWORD *)(v18 + 8) = *(_OWORD *)(a1 + 320);
    *(_DWORD *)(a2 + 364) |= 0x180000u;
    *(_OWORD *)(a2 + 120) = *(_OWORD *)(a1 + 336);
    unsigned int v19 = sub_10016F004((unsigned int *)(a1 + 352));
    if (!sub_10016E644(v19)) {
      sub_101A5EBD8();
    }
    *(_DWORD *)(a2 + 116) = v19;
    *(unsigned char *)(a2 + 114) = *(unsigned char *)(a1 + 356);
    *(_OWORD *)(a2 + 144) = *(_OWORD *)(a1 + 360);
    *(_OWORD *)(a2 + 160) = *(_OWORD *)(a1 + 376);
    *(_OWORD *)(a2 + 176) = *(_OWORD *)(a1 + 496);
    *(unsigned char *)(a2 + 115) = *(unsigned char *)(a1 + 512);
    *(void *)(a2 + 192) = *(void *)(a1 + 392);
    *(void *)(a2 + 200) = *(void *)(a1 + 416);
    *(unsigned char *)(a2 + 276) = *(unsigned char *)(a1 + 424);
    *(int8x8_t *)(a2 + 364) = vorr_s8(*(int8x8_t *)(a2 + 364), (int8x8_t)0x7FF600000);
    uint64_t v20 = *(void *)(a2 + 208);
    if (!v20) {
      operator new();
    }
    *(_DWORD *)(v20 + 28) |= 1u;
    *(_DWORD *)(a2 + 368) |= 4u;
    *(_DWORD *)(v20 + 28) |= 2u;
    *(_OWORD *)(v20 + 8) = *(_OWORD *)(a1 + 432);
    uint64_t v21 = *(void *)(a1 + 448);
    *(_DWORD *)(a2 + 368) |= 8u;
    *(void *)(a2 + 216) = v21;
    unsigned int v22 = sub_10016D468((unsigned int *)(a1 + 456));
    if (!sub_10016E644(v22)) {
      sub_101A5EBAC();
    }
    int v23 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 272) = v22;
    *(_OWORD *)(a2 + 224) = *(_OWORD *)(a1 + 480);
    *(void *)(a2 + 240) = *(void *)(a1 + 600);
    *(_OWORD *)(a2 + 248) = *(_OWORD *)(a1 + 400);
    *(unsigned char *)(a2 + 277) = *(unsigned char *)(a1 + 425);
    *(void *)(a2 + 264) = *(void *)(a1 + 464);
    uint64_t v24 = *(void *)(a1 + 472);
    *(_DWORD *)(a2 + 368) = v23 | 0x1FF0;
    *(void *)(a2 + 280) = v24;
    int v25 = *(uint64_t **)(a1 + 520);
    if (v25)
    {
      uint64_t v26 = *v25;
      uint64_t v27 = v25[1];
      if (*v25 != v27)
      {
        do
        {
          uint64_t v28 = *(int *)(a2 + 296);
          int v29 = *(_DWORD *)(a2 + 300);
          if ((int)v28 >= v29)
          {
            if (v29 == *(_DWORD *)(a2 + 304))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 288), v29 + 1);
              int v29 = *(_DWORD *)(a2 + 300);
            }
            *(_DWORD *)(a2 + 300) = v29 + 1;
            sub_10146BE24();
          }
          uint64_t v30 = *(void *)(a2 + 288);
          *(_DWORD *)(a2 + 296) = v28 + 1;
          sub_101458DB0(v26, *(__n128 **)(v30 + 8 * v28));
          v26 += 28;
        }
        while (v26 != v27);
      }
    }
    unsigned int v31 = sub_10016EC6C((unsigned int *)(a1 + 536));
    if (!sub_10016E644(v31)) {
      sub_101A5EB80();
    }
    int v32 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 312) = v31;
    *(_DWORD *)(a2 + 368) = v32 | 0xC000;
    uint64_t v33 = *(void *)(a2 + 320);
    if (!v33) {
      operator new();
    }
    *(_DWORD *)(v33 + 40) |= 1u;
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    *(_DWORD *)(v33 + 40) |= 2u;
    *(_OWORD *)(v33 + 8) = *(_OWORD *)(a1 + 544);
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    uint64_t v34 = *(void *)(a1 + 560);
    *(_DWORD *)(v33 + 40) |= 4u;
    *(void *)(v33 + 24) = v34;
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    int v35 = sub_10016E684((unsigned int *)(a1 + 568));
    if (!sub_10016E674(v35)) {
      sub_101A5EAA4();
    }
    *(_DWORD *)(v33 + 40) |= 8u;
    *(_DWORD *)(v33 + 32) = v35;
    unsigned int v36 = sub_10016EAA0((unsigned __int8 *)(a1 + 576));
    if (!sub_10016E644(v36)) {
      sub_101A5EB54();
    }
    int v37 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 316) = v36;
    *(void *)(a2 + 328) = *(void *)(a1 + 584);
    uint64_t v38 = *(void *)(a1 + 592);
    *(_DWORD *)(a2 + 368) = v37 | 0x70000;
    *(void *)(a2 + 336) = v38;
    unsigned int v39 = sub_10016EE38((unsigned __int8 *)(a1 + 609));
    if (!sub_100165F14(v39)) {
      sub_101A5EB28();
    }
    int v40 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 344) = v39;
    char v41 = *(unsigned char *)(a1 + 610);
    *(_DWORD *)(a2 + 368) = v40 | 0x180000;
    *(unsigned char *)(a2 + 278) = v41;
    unsigned int v42 = sub_10016E8D4((unsigned int *)(a1 + 612));
    if (!sub_10016E644(v42)) {
      sub_101A5EAFC();
    }
    *(_DWORD *)(a2 + 368) |= 0x200000u;
    *(_DWORD *)(a2 + 348) = v42;
    unsigned int v43 = sub_10016F3A0((unsigned int *)(a1 + 616));
    if (!sub_1001662E0(v43)) {
      sub_101A5EAD0();
    }
    int v44 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 352) = v43;
    *(unsigned char *)(a2 + 279) = *(unsigned char *)(a1 + 608);
    char v45 = *(unsigned char *)(a1 + 636);
    *(_DWORD *)(a2 + 368) = v44 | 0x1C00000;
    *(unsigned char *)(a2 + 356) = v45;
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v46 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_FAULT, "pLocationPrivate,Invalid pointer", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      int v47 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertCLDaemonLocationPrivateToProtobuf(const CLDaemonLocationPrivate &, CLP::LogEntry::PrivateData::DaemonLocationPrivate *)", "%s\n", v47);
      if (v47 != (char *)buf) {
        free(v47);
      }
    }
  }
}

void sub_10016E5E4()
{
}

BOOL sub_10016E644(unsigned int a1)
{
  return a1 < 3;
}

void *sub_10016E650(void *result)
{
  *uint64_t result = off_1022AEC98;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

BOOL sub_10016E674(int a1)
{
  return (a1 + 1) < 4;
}

uint64_t sub_10016E684(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result + 1) >= 4)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled undulation model type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_UndulationModelType ConvertCLUndulationModelTypeToProtobuf(const CLUndulationModelType &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

double sub_10016E854(uint64_t a1)
{
  *(void *)a1 = off_1022AEEF0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(a1 + 32) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

void *sub_10016E884(void *result)
{
  *double result = off_1022AEE00;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

uint64_t sub_10016E8A8(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = off_1022AED88;
  *(_WORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_10016E8D4(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled daemon location private loi location accuracy type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_LoiLocationSourceAccuracy ConvertCLDaemonLocationPrivateLoiLocationSourceAccuracyTypeToProtobuf(const CLDaemonLocationPrivate::LoiLocationSourceAccuracy &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016EAA0(unsigned __int8 *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled daemon location private position context type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_PositionContextStateType ConvertCLDaemonLocationPrivatePositionContextStateTypeToProtobuf(const CLDaemonLocationPrivate::PositionContextStateType &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016EC6C(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled daemon location private gnss content type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_GnssContent ConvertCLDaemonLocationPrivateGnssContentTypeToProtobuf(const CLDaemonLocationPrivate::GnssContent &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016EE38(unsigned __int8 *a1)
{
  uint64_t result = *a1;
  if (result >= 4)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled daemon location private map matcher type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_MapMatcherType ConvertCLDaemonLocationPrivateMapMatcherTypeToProtobuf(const CLDaemonLocationPrivate::MapMatcherType &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016F004(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled client location origin device type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_ClientLocationOriginDeviceType ConvertCLClientLocationOriginDeviceTypeToProtobuf(const CLClientLocationOriginDevice &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016F1D0(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result - 1) >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled client location match quality type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::DaemonLocationPrivate_MatchQualityType ConvertCLClientLocationMatchQualityTypeToProtobuf(const CLClientLocationMatchQuality &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016F3A0(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 5)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled client batched location fix type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::BatchedLocationFixType ConvertCLBatchedLocationFixTypeToProtobuf(const CLBatchedLocationFixType &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_10016F56C(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 0x800u;
  if (!*(void *)(a1 + 80)) {
    operator new();
  }
  return *(void *)(a1 + 80);
}

void sub_10016F5C8()
{
}

void sub_10016F5EC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_10016F624(a1);

  operator delete();
}

void sub_10016F624(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_1022B0A98;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_102489ED8 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

double sub_10016F6B0(uint64_t a1)
{
  *(void *)a1 = &off_1022B0A98;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

BOOL sub_10016F6DC(BOOL result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    *(_DWORD *)(a2 + 36) |= 1u;
    uint64_t v4 = *(void *)(a2 + 8);
    if (!v4) {
      operator new();
    }
    if ((sub_10016F980((double *)(result + 16), v4, 1) & 1) == 0)
    {
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      BOOL v5 = qword_1024194C8;
      if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Error: Failed to convert PredictedGnssAvailability mach continuous time to protobuf", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024194C0 != -1) {
          dispatch_once(&qword_1024194C0, &stru_102327520);
        }
        int v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void ConvertPredictedGnssAvailabilityToProtobuf(const CLLocationProvider_Type::PredictedGnssAvailability &, CLP::LogEntry::PrivateData::GnssAvailabilityPrediction *)", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
      }
      (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
    }
    unsigned int v6 = sub_1001701C8((int *)(v3 + 4));
    if (!sub_100165F14(v6)) {
      sub_101A5F3C0();
    }
    int v7 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a2 + 24) = v6;
    uint64_t v8 = *(void *)(v3 + 8);
    *(_DWORD *)(a2 + 36) = v7 | 6;
    *(void *)(a2 + 16) = v8;
    unsigned int v9 = sub_10016FFF4((int *)v3);
    double result = sub_100165F14(v9);
    if (!result) {
      sub_101A5F394();
    }
    *(_DWORD *)(a2 + 36) |= 8u;
    *(_DWORD *)(a2 + 28) = v9;
  }
  return result;
}

void sub_10016F954()
{
}

uint64_t sub_10016F980(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v10 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    LOWORD(v23) = 0;
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    unsigned int v6 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)uint64_t buf = 134349056;
      double v26 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Mach continuous time cannot be negative or infinite: %{public}lf", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v8 = *a1;
    int v23 = 134349056;
    double v24 = v8;
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  *(_DWORD *)(a2 + 36) |= 4u;
  *(double *)(a2 + 24) = v4;
  if (a3) {
    return 1;
  }
  if (!qword_102487C40) {
    operator new();
  }
  *(double *)&unint64_t v22 = -1.0;
  BOOL v11 = sub_100B01594(qword_102487C40, a1, (double *)&v22);
  if (v11)
  {
    unint64_t v14 = v22;
    *(_DWORD *)(a2 + 36) |= 2u;
    *(void *)(a2 + 16) = v14;
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v15 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
    {
      double v16 = *a1;
      *(_DWORD *)uint64_t buf = 134217984;
      double v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Error: mach continuous to mach absolute time conversion failed: %lf", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      double v19 = *a1;
      int v23 = 134217984;
      double v24 = v19;
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  unint64_t v21 = 0xBFF0000000000000;
  if (sub_100B01790(qword_102487C40, (double *)&v22, (double *)&v21))
  {
    unint64_t v17 = v21;
    *(_DWORD *)(a2 + 36) |= 1u;
    *(void *)(a2 + 8) = v17;
    return v11;
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v18 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    double v26 = *(double *)&v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Error: Mach absolute to CF absolute time conversion failed: %lf", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v23 = 134217984;
    double v24 = *(double *)&v22;
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
LABEL_45:
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return 0;
}

uint64_t sub_10016FFF4(int *a1)
{
  if (*a1 < 3) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled gnss availability meas source,%{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::GnssAvailabilityPrediction_MeasurementSource ConvertCLGnssAvailabilityMeasurementSourceToProtobuf(const CLGnssAvailabilityPredictor::MeasurementSource &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001701C8(int *a1)
{
  if (*a1 < 3) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled gnss availability prediction state,%{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::GnssAvailabilityPrediction_GnssAvailability ConvertCLGnssAvailabilityStateToProtobuf(const CLGnssAvailabilityPredictor::PredictionType &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001703FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_100170408(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_100170410(uint64_t a1, uint64_t a2)
{
  int v4 = (void *)(a1 + 8);
  (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 16))(a1 + 8);
  uint64_t v5 = v4[31];
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 64))(v5, a2);
  }
  uint64_t v6 = *(void *)(a1 + 272);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 64))(v6, a2);
  }
  if (qword_102419430 != -1) {
    dispatch_once(&qword_102419430, &stru_102317FF0);
  }
  double v7 = qword_102419438;
  if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "CLMM,ForceNetworkUsage,%{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_102317FF0);
    }
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMapMatchingEngine::setForceNetworkUsage(BOOL)", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return (*(uint64_t (**)(void *))(*v4 + 24))(v4);
}

void sub_100170680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001706A8(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 112) = a2;
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_1001706DC(void *a1, uint64_t a2)
{
  int v4 = a1 + 1;
  (*(void (**)(void *))(a1[1] + 16))(a1 + 1);
  uint64_t v5 = v4[31];
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, a2);
  }
  uint64_t v6 = a1[34];
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 72))(v6, a2);
  }
  uint64_t v7 = a1[76];
  if (v7) {
    *(unsigned char *)(v7 + 8) = a2 ^ 1;
  }
  uint64_t v8 = a1[79];
  if (v8) {
    *(unsigned char *)(v8 + 8) = a2 ^ 1;
  }
  if (qword_102419430 != -1) {
    dispatch_once(&qword_102419430, &stru_102317FF0);
  }
  unsigned int v9 = qword_102419438;
  if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    int v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "CLMM,DisallowNetworkUsage,%{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_102317FF0);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMapMatchingEngine::setDisallowNetworkUsage(BOOL)", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  return (*(uint64_t (**)(void *))(*v4 + 24))(v4);
}

void sub_10017096C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100170994(void *result, int a2)
{
  uint64_t v2 = result;
  if (*((unsigned char *)result + 33))
  {
    uint64_t v3 = result[2];
    if (v3) {
      *(unsigned char *)(v3 + 192) = a2;
    }
  }
  else
  {
    uint64_t result = (void *)result[325];
    if (result)
    {
      if (a2)
      {
        BOOL v4 = !sub_101188738(v2);
        uint64_t result = (void *)v2[325];
      }
      else
      {
        BOOL v4 = 0;
      }
      return [result setAllowNetworkTileLoad:v4];
    }
  }
  return result;
}

uint64_t sub_100170A0C(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 113) = a2;
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 32))(result, a2 ^ 1u);
  }
  return result;
}

uint64_t sub_100170A90(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_100170A98(uint64_t a1)
{
  char v1 = *(unsigned char *)(a1 + 8);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  BOOL v4 = (unsigned __int8 *)(a1 + 9);
  do
  {
    uint64_t result = 2 * (result + v1);
    int v5 = *v4++;
    char v1 = v5;
  }
  while (v5);
  return result;
}

void sub_100170AC8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void *sub_100170AE0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v2 = (void *)(a1 + 48);
  v2[2] = 0;
  return sub_10016989C(v2, *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
}

uint64_t sub_100170AF8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_100170B00(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

BOOL sub_100170B08(uint64_t a1, uint64_t a2)
{
  return a1 == a2 || strcmp((const char *)(a1 + 8), (const char *)(a2 + 8)) == 0;
}

uint64_t sub_100170B44(uint64_t a1)
{
  return *(unsigned int *)(a1 + 180);
}

void *sub_100170B4C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)uint64_t buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLElevationChangeEntry>::update(CFAbsoluteTime)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 6));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 6);
LABEL_15:
  uint64_t v15 = v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 3) & 0x1FFFFFFFFFFFFFF8))
        + (((*(void *)(a1 + 64) + v9) & 0x3F) << 6);
    if (v15 == v16 || *(double *)(a1 + 104) + -1200.0 <= *(double *)(v15 + 8)) {
      break;
    }
    v13 += 64;
    v15 += 64;
    if (*(void *)v14 + 4096 == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  return sub_100170EA4((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

void *sub_100170EA4(void *a1, char *a2, uint64_t a3, char *a4, uint64_t a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((a5 - *(void *)a4) >> 6) + 8 * (a4 - a2) - ((a3 - *(void *)a2) >> 6);
  }
  uint64_t v7 = a1[1];
  int v8 = (char *)(v7 + 8 * (a1[4] >> 6));
  if (a1[2] == v7) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)v8 + ((a1[4] & 0x3FLL) << 6);
  }
  uint64_t v33 = (char **)(v7 + 8 * (a1[4] >> 6));
  uint64_t v34 = (char *)v9;
  if (v9 == a3) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = ((a3 - *(void *)a2) >> 6) + 8 * (a2 - v8) - ((v9 - *(void *)v8) >> 6);
  }
  uint64_t v11 = (char **)sub_1001710DC((uint64_t)&v33, v10);
  v32.n128_u64[0] = (unint64_t)v11;
  v32.n128_u64[1] = (unint64_t)v12;
  if (v6 >= 1)
  {
    if (v10 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      double v19 = v11;
      uint64_t v20 = v12;
      unint64_t v21 = v33;
      double v22 = v34;
      __int16 v23 = sub_1001710DC((uint64_t)&v32, v6);
      sub_101121954(v21, v22, v19, v20, v23, v24, &v35);
      __int16 v25 = v34;
      if (v34 != v36)
      {
        double v26 = v33;
        do
        {
          v25 += 64;
          uint64_t v34 = v25;
          if (v25 - *v26 == 4096)
          {
            __int16 v27 = v26[1];
            ++v26;
            __int16 v25 = v27;
            uint64_t v33 = v26;
            uint64_t v34 = v27;
          }
        }
        while (v25 != v36);
      }
      uint64_t v28 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v28;
      while ((sub_10017E0A8((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      uint64_t v13 = (char **)sub_1001710DC((uint64_t)&v32, v6);
      unint64_t v15 = a1[4] + a1[5];
      uint64_t v16 = a1[1];
      uint64_t v17 = (char **)(v16 + 8 * (v15 >> 6));
      if (a1[2] == v16) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = &(*v17)[64 * (v15 & 0x3F)];
      }
      __n128 v35 = v32;
      sub_10017ED68(v13, v14, v17, v18, (uint64_t)&v35);
      a1[5] -= v6;
      while ((sub_10017DE18(a1, 1) & 1) != 0)
        ;
    }
  }
  uint64_t v29 = a1[1];
  if (a1[2] == v29) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = *(void *)(v29 + 8 * (a1[4] >> 6)) + ((a1[4] & 0x3FLL) << 6);
  }
  v35.n128_u64[0] = v29 + 8 * (a1[4] >> 6);
  v35.n128_u64[1] = v30;
  return sub_1001710DC((uint64_t)&v35, v10);
}

void *sub_1001710DC(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 6);
    if (v4 < 1) {
      result -= (unint64_t)(63 - v4) >> 6;
    }
    else {
      result += (unint64_t)v4 >> 6;
    }
  }
  return result;
}

uint64_t sub_100171140(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1[4] + 16))();
  if (result)
  {
    uint64_t v3 = (uint64_t (*)(void *, uint64_t))a1[5];
    uint64_t v4 = a1[12];
    return v3(a1 + 6, v4);
  }
  return result;
}

BOOL sub_10017119C(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

unint64_t sub_1001711B4(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022F3D80);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)uint64_t buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022F3D80);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>::update(CFAbsoluteTime) [Data_T = CLMotionStateMediator_Type::MediatedMotionActivity]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 / 0x11));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*(void *)v12 + 232 * (v9 % 0x11));
  }
  uint64_t v14 = (char *)(v10 + 8 * (v9 / 0x11));
LABEL_15:
  unint64_t v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(*(void *)(a1 + 32) + 8 * ((*(void *)(a1 + 64) + v9) / 0x11))
        + 232 * ((*(void *)(a1 + 64) + v9) % 0x11);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 29;
    v13 += 232;
    if ((char *)(*(void *)v14 + 3944) == v13)
    {
      uint64_t v17 = (char *)*((void *)v14 + 1);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*(void *)v12 + 232 * (v9 % 0x11));
  }
  return sub_100171538((void *)(a1 + 24), v12, v18, v14, v13);
}

unint64_t sub_100171538(void *a1, char *a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 2 * (a4 - a2)
  }
       + ((a4 - a2) >> 3)
       + 0x34F72C234F72C235 * ((uint64_t)&a5[-*(void *)a4] >> 3)
       - 0x34F72C234F72C235 * ((uint64_t)&a3[-*(void *)a2] >> 3);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  unint64_t v9 = (char **)(v8 + 8 * (v7 / 0x11));
  if (a1[2] == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &(*v9)[232 * (v7 % 0x11)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 2 * (a2 - (char *)v9)
  }
        + ((a2 - (char *)v9) >> 3)
        + 0x34F72C234F72C235 * ((uint64_t)&a3[-*(void *)a2] >> 3)
        - 0x34F72C234F72C235 * ((v10 - *v9) >> 3);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x11);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_1001717C4(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_1001717C4(v24, v6);
      sub_10066560C(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_100665538((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_1001717C4(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      unint64_t v16 = (unsigned char **)(v15 + 8 * (v14 / 0x11));
      if (a1[2] == v15) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = &(*v16)[232 * (v14 % 0x11)];
      }
      v24[0] = v12;
      sub_1006657C0(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_100665598(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  unint64_t v21 = (void *)(v20 + 8 * (v19 / 0x11));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 232 * (v19 % 0x11);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_1001717C4(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_1001717C4(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 + 0x34F72C234F72C235 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 16 - v3;
      uint64_t v6 = &v2[-(v5 / 0x11)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 232 * (17 * (v5 / 0x11) - v5) + 3712;
    }
    else
    {
      *uint64_t result = &v2[v3 / 0x11];
      unint64_t v4 = v2[v3 / 0x11] + 232 * (v3 % 0x11);
    }
    result[1] = v4;
  }
  return result;
}

unint64_t sub_10017186C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022E9388);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)uint64_t buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022E9388);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLOdometerEntry>::update(CFAbsoluteTime) [Data_T = CLOdometerEntry]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  __n128 v12 = (void *)(v10 + 8 * (v9 / 0x15));
  if (v11 == v10) {
    __n128 v13 = 0;
  }
  else {
    __n128 v13 = (char *)(*v12 + 192 * (v9 % 0x15));
  }
  unint64_t v14 = (void *)(v10 + 8 * (v9 / 0x15));
LABEL_15:
  uint64_t v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x15)) + 192 * ((*(void *)(a1 + 64) + v9) % 0x15);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 24;
    v13 += 192;
    if ((char *)(*v14 + 4032) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      __n128 v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 192 * (v9 % 0x15));
  }
  return sub_100171BFC((void *)(a1 + 24), v12, v18, v14, v13);
}

unint64_t sub_100171BFC(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 21 * (a4 - a2)
  }
       - 0x5555555555555555 * ((uint64_t)&a5[-*a4] >> 6)
       + 0x5555555555555555 * ((uint64_t)&a3[-*a2] >> 6);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  unint64_t v9 = (char **)(v8 + 8 * (v7 / 0x15));
  if (a1[2] == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &(*v9)[192 * (v7 % 0x15)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 21 * ((char **)a2 - v9)
  }
        - 0x5555555555555555 * ((uint64_t)&a3[-*a2] >> 6)
        + 0x5555555555555555 * ((v10 - *v9) >> 6);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x15);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_100171E98(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_100171E98(v24, v6);
      sub_100AD8B10(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_100AD8A38((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_100171E98(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      unint64_t v16 = (unsigned char **)(v15 + 8 * (v14 / 0x15));
      if (a1[2] == v15) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = &(*v16)[192 * (v14 % 0x15)];
      }
      v24[0] = v12;
      sub_100AD8CC4(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_100AD8A98(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  unint64_t v21 = (void *)(v20 + 8 * (v19 / 0x15));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 192 * (v19 % 0x15);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_100171E98(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_100171E98(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x5555555555555555 * ((uint64_t)(result[1] - *(void *)*result) >> 6);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 20 - v3;
      uint64_t v6 = &v2[-(v5 / 0x15)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 192 * (21 * (v5 / 0x15) - v5) + 3840;
    }
    else
    {
      *uint64_t result = &v2[v3 / 0x15];
      unint64_t v4 = v2[v3 / 0x15] + 192 * (v3 % 0x15);
    }
    result[1] = v4;
  }
  return result;
}

void sub_100171F54(void *a1)
{
  uint64_t v2 = a1[6];
  *(unsigned char *)(*(void *)(a1[5] + 8) + 48) = 65;
  BOOL v3 = sub_100172054(v2, *(void *)(a1[5] + 8) + 48, 100);
  uint64_t v4 = a1[4];
  if (v4)
  {
    (*(void (**)(uint64_t, BOOL))(v4 + 16))(v4, v3);
    unint64_t v5 = (const void *)a1[4];
    _Block_release(v5);
  }
}

void sub_100171FD4(void *a1)
{
  uint64_t v2 = a1[6];
  *(unsigned char *)(*(void *)(a1[5] + 8) + 48) = 25;
  BOOL v3 = sub_100172054(v2, *(void *)(a1[5] + 8) + 48, 2);
  uint64_t v4 = a1[4];
  if (v4)
  {
    (*(void (**)(uint64_t, BOOL))(v4 + 16))(v4, v3);
    unint64_t v5 = (const void *)a1[4];
    _Block_release(v5);
  }
}

BOOL sub_100172054(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    mach_error_t v7 = -536870187;
    uint64_t v22 = 256;
    mach_error_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, uint64_t *))(*(void *)v3 + 80))(v3, a2, a3, &v25, &v22);
    if (v8 == -536870187)
    {
      while (*(_DWORD *)(a1 + 16) < 5u)
      {
        if (qword_102418FE0 != -1) {
          dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
        }
        unint64_t v9 = qword_102418FE8;
        if (os_log_type_enabled((os_log_t)qword_102418FE8, OS_LOG_TYPE_INFO))
        {
          int v10 = dword_101D8A400[*(int *)(a1 + 16)];
          *(_DWORD *)uint64_t buf = 67109120;
          LODWORD(v32) = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "CMA busy. Waiting %d microseconds.", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FE0 != -1) {
            dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
          }
          int v11 = dword_101D8A400[*(int *)(a1 + 16)];
          int v23 = 67109120;
          int v24 = v11;
          __n128 v12 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMotionCoprocessorCommander::sendCommandPayload(const void *, size_t)", "%s\n", v12);
          if (v12 != (char *)buf) {
            free(v12);
          }
        }
        usleep(dword_101D8A400[*(int *)(a1 + 16)]);
        ++*(_DWORD *)(a1 + 16);
        uint64_t v22 = 256;
        mach_error_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, uint64_t *))(*(void *)v3 + 80))(v3, a2, a3, &v25, &v22);
        if (v8 != -536870187) {
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      mach_error_t v7 = v8;
      if (!v8)
      {
        *(_DWORD *)(a1 + 16) = 0;
        return 1;
      }
    }
    if (qword_102418FE0 != -1) {
      dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
    }
    __n128 v13 = qword_102418FE8;
    if (os_log_type_enabled((os_log_t)qword_102418FE8, OS_LOG_TYPE_FAULT))
    {
      unint64_t v14 = mach_error_string(v7);
      int v15 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 136446722;
      __n128 v32 = v14;
      __int16 v33 = 1026;
      mach_error_t v34 = v7;
      __int16 v35 = 1026;
      int v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "sendCommandPayload() = %{public}s (0x%{public}x),fNumConsecutiveCMAFailures,%{public}d", buf, 0x18u);
    }
    BOOL v16 = sub_10013D1A0(115, 0);
    BOOL result = 0;
    if (v16)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FE0 != -1) {
        dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
      }
      uint64_t v18 = mach_error_string(v7);
      int v19 = *(_DWORD *)(a1 + 16);
      int v25 = 136446722;
      double v26 = v18;
      __int16 v27 = 1026;
      mach_error_t v28 = v7;
      __int16 v29 = 1026;
      int v30 = v19;
      uint64_t v20 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMotionCoprocessorCommander::sendCommandPayload(const void *, size_t)", "%s\n");
LABEL_32:
      if (v20 != buf) {
        free(v20);
      }
      return 0;
    }
  }
  else
  {
    if (qword_102418FE0 != -1) {
      dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
    }
    unint64_t v21 = qword_102418FE8;
    if (os_log_type_enabled((os_log_t)qword_102418FE8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "cmaHidDriverInterface NULL", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FE0 != -1) {
        dispatch_once(&qword_102418FE0, &stru_1022EFDF0);
      }
      LOWORD(v25) = 0;
      uint64_t v20 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMotionCoprocessorCommander::sendCommandPayload(const void *, size_t)", "%s\n");
      goto LABEL_32;
    }
  }
  return result;
}

uint64_t sub_100172594(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1[4] + 16))();
  if (result)
  {
    uint64_t v3 = (uint64_t (*)(void *, uint64_t))a1[5];
    uint64_t v4 = a1[34];
    return v3(a1 + 6, v4);
  }
  return result;
}

BOOL sub_1001725F0(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

id sub_100172608(uint64_t a1)
{
  return sub_10005DEB0(*(id *)(a1 + 32), 1, *(double *)(a1 + 40));
}

void sub_10017261C(uint64_t a1, double *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    char v5 = sub_1000A68BC(*(void *)(a1 + 88)) > 0.0;
    sub_100B379E4(v4, a2, v5);
  }
  if (*(_DWORD *)(a1 + 216) == 3) {
    ++*(_DWORD *)(a1 + 56);
  }
  if (sub_1001825D4(a1, a2))
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1023069F0);
    }
    uint64_t v6 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Background escalation manager consuming more power than workout alerts", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1023069F0);
      }
      LOWORD(v15[0]) = 0;
      __n128 v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLBackgroundEscalationManager::update(const CLWorkoutPredictorInputs &)", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
    uint64_t v8 = a1 + 88;
    uint64_t v7 = *(void *)(a1 + 88);
    ++*(_DWORD *)(a1 + 60);
    if (sub_1000A68BC(v7) <= 0.0)
    {
      (*(void (**)(void))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72));
    }
    else
    {
      (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
      uint64_t v8 = a1 + 72;
    }
  }
  else
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1023069F0);
    }
    unint64_t v9 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Background escalation manager not consuming more power than workout alerts", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1023069F0);
      }
      LOWORD(v15[0]) = 0;
      __n128 v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLBackgroundEscalationManager::update(const CLWorkoutPredictorInputs &)", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72));
    uint64_t v8 = a1 + 88;
  }
  (*(void (**)(void))(**(void **)v8 + 24))();
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102482648, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102482648))
  {
    *(_DWORD *)uint64_t buf = 8;
    sub_1004F7D80(qword_102482630, buf, 1uLL);
    __cxa_atexit((void (*)(void *))sub_1004F7E04, qword_102482630, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102482648);
  }
  __int16 v16 = 0;
  *(_OWORD *)int v15 = xmmword_101D1E250;
  memset(&v15[2], 0, 135);
  long long v17 = xmmword_101D1E250;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v20 = 0;
  v21[0] = 0;
  *(void *)((char *)v21 + 5) = 0;
  *(void *)((char *)&v21[1] + 6) = 0;
  char v22 = 0;
  memset(&v21[3], 0, 24);
  long long v23 = xmmword_101D1E250;
  uint64_t v24 = 0;
  int v25 = 0;
  unint64_t v26 = 0xFFEFFFFFFFFFFFFFLL;
  int v37 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  int v32 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  unint64_t v40 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v41 = 0;
  int v42 = 0;
  uint64_t v48 = 0;
  __int16 v49 = 0;
  int v54 = 0;
  int v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v51 = 0u;
  long long v50 = 0u;
  char v52 = 0;
  memset(v53, 0, sizeof(v53));
  double v55 = -1.79769313e308;
  long long v74 = 0u;
  long long v73 = 0u;
  long long v72 = 0u;
  long long v71 = 0u;
  long long v70 = 0u;
  long long v69 = 0u;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  uint64_t v75 = 0;
  unint64_t v76 = 0xFFEFFFFFFFFFFFFFLL;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  unint64_t v81 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v82 = 0;
  int v83 = 0;
  uint64_t v84 = 0;
  char v85 = 0;
  unint64_t v86 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v88 = 0;
  uint64_t v87 = 0;
  uint64_t v89 = 0x80000000800000;
  uint64_t v91 = 0;
  uint64_t v90 = 0;
  long long v92 = xmmword_101D1E260;
  uint64_t v93 = 0x80000000800000;
  long long v94 = 0u;
  long long v95 = 0u;
  uint64_t v96 = 0;
  unint64_t v97 = 0xFFEFFFFFFFFFFFFFLL;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  int v104 = 0;
  unint64_t v105 = 0xFFEFFFFFFFFFFFFFLL;
  __int16 v106 = 0;
  int v107 = 0;
  unint64_t v108 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v109 = 7;
  unint64_t v110 = 0xFFEFFFFFFFFFFFFFLL;
  char v111 = 0;
  uint64_t v113 = 0;
  uint64_t v112 = 0;
  uint64_t v114 = 0;
  sub_100174478(a2, qword_102482630, (uint64_t)v15);
  if (v55 != -1.79769313e308)
  {
    if (*(unsigned char *)(a1 + 244))
    {
      *(_DWORD *)(a1 + 232) = v60;
    }
    else
    {
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1023069F0);
      }
      int v10 = qword_1024191C8;
      if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 67240192;
        int v116 = v60;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Background escalation manager updating floors ascended baseline: %{public}u ", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191C0 != -1) {
          dispatch_once(&qword_1024191C0, &stru_1023069F0);
        }
        unint64_t v14 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLBackgroundEscalationManager::update(const CLWorkoutPredictorInputs &)", "%s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
      }
      int v11 = v60;
      *(_DWORD *)(a1 + 232) = v60;
      *(_DWORD *)(a1 + 236) = v11;
      *(unsigned char *)(a1 + 244) = 1;
    }
    if (*(_DWORD *)(a1 + 216) != 3) {
      sub_1000A5B7C(a1, 0, *((double *)&v56 + 1));
    }
  }
}

void sub_100172DFC(_Unwind_Exception *a1)
{
}

uint64_t sub_100172E1C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8) != 1 && *(int *)(a1 + 104) >= 1) {
    sub_100EBC6AC(a1 + 96);
  }

  return sub_100172E70(a1);
}

uint64_t sub_100172E70(uint64_t result)
{
  if (*(_DWORD *)(result + 8) != 1)
  {
    uint64_t v1 = result;
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1022DA160);
    }
    uint64_t v2 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_INFO))
    {
      uint64_t v3 = (void *)(v1 + 24);
      if (*(char *)(v1 + 47) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "NonInterruptingTimer, %s, stopTimer", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022DA160);
      }
      char v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNonInterruptingTimer::stopTimer()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    double v4 = sub_1000A68BC(v1);
    uint64_t result = sub_100A19C6C(v1, v4);
    *(_DWORD *)(v1 + 8) = 1;
  }
  return result;
}

uint64_t sub_100173060(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

void *sub_100173080(void *a1, char *a2, uint64_t a3, char *a4, uint64_t a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((a5 - *(void *)a4) >> 5) + 16 * (a4 - a2) - ((a3 - *(void *)a2) >> 5);
  }
  uint64_t v7 = a1[1];
  uint64_t v8 = (char *)(v7 + 8 * (a1[4] >> 7));
  if (a1[2] == v7) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)v8 + 32 * (a1[4] & 0x7FLL);
  }
  long long v33 = (char **)(v7 + 8 * (a1[4] >> 7));
  long long v34 = (char *)v9;
  if (v9 == a3) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = ((a3 - *(void *)a2) >> 5) + 16 * (a2 - v8) - ((v9 - *(void *)v8) >> 5);
  }
  int v11 = (char **)sub_1001732B8((uint64_t)&v33, v10);
  v32.n128_u64[0] = (unint64_t)v11;
  v32.n128_u64[1] = (unint64_t)v12;
  if (v6 >= 1)
  {
    if (v10 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      int v19 = v11;
      uint64_t v20 = v12;
      unint64_t v21 = v33;
      char v22 = v34;
      long long v23 = sub_1001732B8((uint64_t)&v32, v6);
      sub_100ADAA78(v21, v22, v19, v20, v23, v24, &v35);
      int v25 = v34;
      if (v34 != v36)
      {
        unint64_t v26 = v33;
        do
        {
          v25 += 32;
          long long v34 = v25;
          if (v25 - *v26 == 4096)
          {
            long long v27 = v26[1];
            ++v26;
            int v25 = v27;
            long long v33 = v26;
            long long v34 = v27;
          }
        }
        while (v25 != v36);
      }
      uint64_t v28 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v28;
      while ((sub_1002D0514((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      __n128 v13 = (char **)sub_1001732B8((uint64_t)&v32, v6);
      unint64_t v15 = a1[4] + a1[5];
      uint64_t v16 = a1[1];
      long long v17 = (char **)(v16 + 8 * (v15 >> 7));
      if (a1[2] == v16) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = &(*v17)[32 * (v15 & 0x7F)];
      }
      __n128 v35 = v32;
      sub_10017EC98(v13, v14, v17, v18, (uint64_t)&v35);
      a1[5] -= v6;
      while ((sub_10017DE88(a1, 1) & 1) != 0)
        ;
    }
  }
  uint64_t v29 = a1[1];
  if (a1[2] == v29) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = *(void *)(v29 + 8 * (a1[4] >> 7)) + 32 * (a1[4] & 0x7FLL);
  }
  v35.n128_u64[0] = v29 + 8 * (a1[4] >> 7);
  v35.n128_u64[1] = v30;
  return sub_1001732B8((uint64_t)&v35, v10);
}

void *sub_1001732B8(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 5);
    if (v4 < 1) {
      result -= (unint64_t)(127 - v4) >> 7;
    }
    else {
      result += (unint64_t)v4 >> 7;
    }
  }
  return result;
}

uint64_t sub_10017331C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 108);
}

BOOL sub_100173324(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 <= 0) {
    sub_101ABA43C();
  }
  if (*(_DWORD *)(a3 + 8) != a2 || *(_DWORD *)(a3 + 12) != a2) {
    sub_101ABA468();
  }
  BOOL v6 = 0;
  int v7 = 0;
  double v8 = *(double *)(a1 + 128);
LABEL_8:
  int v9 = 0;
  double v10 = 0.0;
  while (1)
  {
    double v11 = sub_1001733F4(a3, v9, v7);
    if (v11 < 0.0 || v11 > 1.0) {
      return v6;
    }
    double v10 = v10 + v11;
    if (a2 == ++v9)
    {
      if (fabs(v10 + -1.0) <= v8)
      {
        BOOL v6 = ++v7 >= a2;
        if (v7 != a2) {
          goto LABEL_8;
        }
      }
      return v6;
    }
  }
}

double sub_1001733F4(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    sub_101A7E8EC();
  }
  unsigned int v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0) {
    sub_101A7E918();
  }
  if ((signed int)v4 >= *(_DWORD *)(a1 + 16)) {
    sub_101A7E944();
  }
  return *(double *)(v3 + 8 * v4);
}

uint64_t sub_10017343C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

double *sub_10017345C(double *result, double *a2, uint64_t a3, uint64_t a4, char a5)
{
  double v10 = result;
LABEL_2:
  double v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    double v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          double v24 = *(a2 - 1);
          float v25 = v24;
          double v26 = *v11;
          float v27 = *v11;
          if (v25 > v27)
          {
            *double v11 = v24;
            *(a2 - 1) = v26;
          }
          break;
        case 3uLL:
          double v28 = v11[1];
          float v29 = v28;
          float v30 = *(a2 - 1);
          BOOL v31 = v29 <= v30;
          if (v29 <= v30) {
            uint64_t v32 = *((void *)a2 - 1);
          }
          else {
            uint64_t v32 = *((void *)v11 + 1);
          }
          if (!v31) {
            double v28 = *(a2 - 1);
          }
          *(a2 - 1) = v28;
          *((void *)v11 + 1) = v32;
          double v33 = *(a2 - 1);
          float v34 = v33;
          float v35 = *v11;
          BOOL v36 = v34 <= v35;
          if (v34 <= v35) {
            double v37 = *v11;
          }
          else {
            double v37 = *(a2 - 1);
          }
          if (!v36) {
            double v33 = *v11;
          }
          *(a2 - 1) = v33;
          float v38 = v37;
          float v39 = v11[1];
          BOOL v40 = v38 <= v39;
          if (v38 <= v39) {
            uint64_t v41 = *((void *)v11 + 1);
          }
          else {
            uint64_t v41 = *(void *)v11;
          }
          if (!v40) {
            double v37 = v11[1];
          }
          *(void *)double v11 = v41;
          v11[1] = v37;
          break;
        case 4uLL:
          uint64_t v42 = *(void *)v11;
          double v43 = v11[1];
          float v44 = *v11;
          float v45 = v11[2];
          BOOL v46 = v44 <= v45;
          if (v44 <= v45) {
            uint64_t v47 = *((void *)v11 + 2);
          }
          else {
            uint64_t v47 = *(void *)v11;
          }
          if (!v46) {
            uint64_t v42 = *((void *)v11 + 2);
          }
          *((void *)v11 + 2) = v42;
          *(void *)double v11 = v47;
          float v48 = v43;
          float v49 = *(a2 - 1);
          BOOL v50 = v48 <= v49;
          if (v48 <= v49) {
            double v51 = *(a2 - 1);
          }
          else {
            double v51 = v43;
          }
          if (!v50) {
            double v43 = *(a2 - 1);
          }
          *(a2 - 1) = v43;
          float v52 = *v11;
          float v53 = v51;
          BOOL v54 = v52 <= v53;
          if (v52 <= v53) {
            double v55 = v51;
          }
          else {
            double v55 = *v11;
          }
          if (v54) {
            double v51 = *v11;
          }
          *double v11 = v55;
          v11[1] = v51;
          double v56 = v11[2];
          float v57 = v56;
          float v58 = *(a2 - 1);
          BOOL v59 = v57 <= v58;
          if (v57 <= v58) {
            double v60 = *(a2 - 1);
          }
          else {
            double v60 = v11[2];
          }
          if (!v59) {
            double v56 = *(a2 - 1);
          }
          *(a2 - 1) = v56;
          double v61 = v11[1];
          float v62 = v61;
          float v63 = v60;
          BOOL v64 = v62 <= v63;
          if (v62 <= v63) {
            double v65 = v60;
          }
          else {
            double v65 = v11[1];
          }
          if (!v64) {
            double v61 = v60;
          }
          v11[1] = v65;
          int32x4_t v11[2] = v61;
          break;
        case 5uLL:
          uint64_t result = sub_10017E5C8(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return sub_1011422A0(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    long long v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_1001738A4(v11, &v11[v15 >> 1], a2 - 1);
      sub_1001738A4(v11 + 1, v17 - 1, a2 - 2);
      sub_1001738A4(v11 + 2, &v11[v16 + 1], a2 - 3);
      sub_1001738A4(v17 - 1, v17, &v11[v16 + 1]);
      double v18 = *v11;
      *double v11 = *v17;
      *long long v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_1001738A4(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    float v19 = *(v11 - 1);
    float v20 = *v11;
    if (v19 <= v20)
    {
      uint64_t result = sub_101141F40(v11, a2);
      double v11 = result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v21 = sub_100173944(v11, a2);
    if ((v22 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v23 = sub_10114200C(v11, v21);
    double v11 = v21 + 1;
    uint64_t result = (double *)sub_10114200C(v21 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v21;
      if (v23) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v23)
    {
LABEL_17:
      uint64_t result = (double *)sub_10017345C(v10, v21, a3, -v13, a5 & 1);
      double v11 = v21 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return sub_10017EE38(v11, a2);
  }
  else if (v11 != a2)
  {
    while (v10 + 1 != a2)
    {
      double v68 = *v10;
      double v67 = v10[1];
      long long v66 = ++v10;
      float v69 = v67;
      float v70 = v68;
      if (v69 > v70)
      {
        do
        {
          *long long v66 = v68;
          double v68 = *(v66 - 2);
          float v71 = v68;
          --v66;
        }
        while (v69 > v71);
        *long long v66 = v67;
      }
    }
  }
  return result;
}

uint64_t sub_1001738A4(double *a1, double *a2, double *a3)
{
  double v3 = *a2;
  float v4 = *a2;
  double v5 = *a1;
  float v6 = *a1;
  double v7 = *a3;
  float v8 = *a3;
  if (v4 > v6)
  {
    if (v8 > v4)
    {
      *a1 = v7;
      *a3 = v5;
      return 1;
    }
    *a1 = v3;
    *a2 = v5;
    float v12 = *a3;
    if (v12 <= v6) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v5;
    return 2;
  }
  if (v8 > v4)
  {
    *a2 = v7;
    *a3 = v3;
    float v9 = *a2;
    double v10 = *a1;
    float v11 = *a1;
    if (v9 <= v11) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v10;
    return 2;
  }
  return 0;
}

double *sub_100173944(double *a1, double *a2)
{
  uint64_t v2 = 0;
  double v3 = *a1;
  float v4 = *a1;
  do
  {
    double v5 = a1[v2 + 1];
    float v6 = v5;
    ++v2;
  }
  while (v6 > v4);
  double v7 = &a1[v2];
  float v8 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v7 >= a2) {
        break;
      }
      double v11 = *--a2;
      float v12 = v11;
    }
    while (v12 <= v4);
  }
  else
  {
    do
    {
      double v9 = *--a2;
      float v10 = v9;
    }
    while (v10 <= v4);
  }
  if (v7 < a2)
  {
    double v13 = *a2;
    uint64_t v14 = &a1[v2];
    unint64_t v15 = a2;
    do
    {
      *uint64_t v14 = v13;
      double *v15 = v5;
      do
      {
        double v16 = v14[1];
        ++v14;
        double v5 = v16;
        float v17 = v16;
      }
      while (v17 > v4);
      do
      {
        double v18 = *--v15;
        double v13 = v18;
        float v19 = v18;
      }
      while (v19 <= v4);
    }
    while (v14 < v15);
    float v8 = v14 - 1;
  }
  if (v8 != a1) {
    *a1 = *v8;
  }
  *float v8 = v3;
  return v8;
}

uint64_t sub_100173A10(uint64_t a1)
{
  return *(unsigned int *)(a1 + 360);
}

uint64_t sub_100173A18(uint64_t a1)
{
  return *(unsigned int *)(a1 + 148);
}

uint64_t sub_100173A20(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_100173A28(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

void sub_100173A30(uint64_t a1)
{
}

uint64_t sub_100173A38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

unint64_t sub_100173A58(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 24 * (a4 - a2)
  }
       - 0x30C30C30C30C30C3 * ((uint64_t)&a5[-*a4] >> 3)
       + 0x30C30C30C30C30C3 * ((uint64_t)&a3[-*a2] >> 3);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  double v9 = (char **)(v8 + 8 * (v7 / 0x18));
  if (a1[2] == v8) {
    float v10 = 0;
  }
  else {
    float v10 = &(*v9)[168 * (v7 % 0x18)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 24 * ((char **)a2 - v9)
  }
        - 0x30C30C30C30C30C3 * ((uint64_t)&a3[-*a2] >> 3)
        + 0x30C30C30C30C30C3 * ((v10 - *v9) >> 3);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x18);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_100173CEC(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_100173CEC(v24, v6);
      sub_1012A8F6C(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_1006AD808((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_100173CEC(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      double v16 = (unsigned char **)(v15 + 8 * (v14 / 0x18));
      if (a1[2] == v15) {
        float v17 = 0;
      }
      else {
        float v17 = &(*v16)[168 * (v14 % 0x18)];
      }
      v24[0] = v12;
      sub_1006AD4E4(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_1006AD668(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  unint64_t v21 = (void *)(v20 + 8 * (v19 / 0x18));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 168 * (v19 % 0x18);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_100173CEC(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_100173CEC(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x30C30C30C30C30C3 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 23 - v3;
      uint64_t v6 = &v2[-(v5 / 0x18)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 168 * (24 * (v5 / 0x18) - v5) + 3864;
    }
    else
    {
      *uint64_t result = &v2[v3 / 0x18];
      unint64_t v4 = v2[v3 / 0x18] + 168 * (v3 % 0x18);
    }
    result[1] = v4;
  }
  return result;
}

unint64_t sub_100173D90(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 23 * (a4 - a2)
  }
       + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a5[-*a4] >> 4)
       - 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a3[-*a2] >> 4);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  double v9 = (char **)(v8 + 8 * (v7 / 0x17));
  if (a1[2] == v8) {
    float v10 = 0;
  }
  else {
    float v10 = &(*v9)[176 * (v7 % 0x17)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 23 * ((char **)a2 - v9)
  }
        + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a3[-*a2] >> 4)
        - 0x2E8BA2E8BA2E8BA3 * ((v10 - *v9) >> 4);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x17);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_100174054(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_100174054(v24, v6);
      sub_100A32074(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_100A31F9C((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_100174054(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      double v16 = (unsigned char **)(v15 + 8 * (v14 / 0x17));
      if (a1[2] == v15) {
        float v17 = 0;
      }
      else {
        float v17 = &(*v16)[176 * (v14 % 0x17)];
      }
      v24[0] = v12;
      sub_100A32228(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_100A31FFC(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  unint64_t v21 = (void *)(v20 + 8 * (v19 / 0x17));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 176 * (v19 % 0x17);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_100174054(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_100174054(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(result[1] - *(void *)*result) >> 4);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 22 - v3;
      uint64_t v6 = &v2[-(v5 / 0x17)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 176 * (23 * (v5 / 0x17) - v5) + 3872;
    }
    else
    {
      *uint64_t result = &v2[v3 / 0x17];
      unint64_t v4 = v2[v3 / 0x17] + 176 * (v3 % 0x17);
    }
    result[1] = v4;
  }
  return result;
}

unint64_t sub_100174118(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 26 * (a4 - a2)
  }
       - 0x79435E50D79435E5 * ((uint64_t)&a5[-*a4] >> 3)
       + 0x79435E50D79435E5 * ((uint64_t)&a3[-*a2] >> 3);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  double v9 = (char **)(v8 + 8 * (v7 / 0x1A));
  if (a1[2] == v8) {
    float v10 = 0;
  }
  else {
    float v10 = &(*v9)[152 * (v7 % 0x1A)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 26 * ((char **)a2 - v9)
  }
        - 0x79435E50D79435E5 * ((uint64_t)&a3[-*a2] >> 3)
        + 0x79435E50D79435E5 * ((v10 - *v9) >> 3);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x1A);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_1001743C4(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_1001743C4(v24, v6);
      sub_10041FA44(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_10041F9E4((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_1001743C4(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      double v16 = (unsigned char **)(v15 + 8 * (v14 / 0x1A));
      if (a1[2] == v15) {
        float v17 = 0;
      }
      else {
        float v17 = &(*v16)[152 * (v14 % 0x1A)];
      }
      v24[0] = v12;
      sub_10041FBF8(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_10017E108(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  unint64_t v21 = (void *)(v20 + 8 * (v19 / 0x1A));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 152 * (v19 % 0x1A);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_1001743C4(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_1001743C4(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x79435E50D79435E5 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 25 - v3;
      uint64_t v6 = &v2[-(v5 / 0x1A)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 152 * (26 * (v5 / 0x1A) - v5) + 3800;
    }
    else
    {
      *uint64_t result = &v2[v3 / 0x1A];
      unint64_t v4 = v2[v3 / 0x1A] + 152 * (v3 % 0x1A);
    }
    result[1] = v4;
  }
  return result;
}

uint64_t sub_100174478(double *a1, void *a2, uint64_t a3)
{
  double v35 = 0.0;
  int v6 = sub_100182EA4(a1, (uint64_t)a2, &v35);
  *(_OWORD *)(a3 + 132) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  memset(&v36[6], 0, 24);
  *(_OWORD *)(a3 + 992) = 0u;
  *(_OWORD *)(a3 + 1008) = 0u;
  *(_OWORD *)(a3 + 1024) = 0u;
  *(_OWORD *)(a3 + 664) = 0u;
  *(_OWORD *)(a3 + 680) = 0u;
  *(_OWORD *)(a3 + 696) = 0u;
  *(_OWORD *)(a3 + 712) = 0u;
  *(_OWORD *)(a3 + 728) = 0u;
  *(_OWORD *)(a3 + 744) = 0u;
  *(_OWORD *)(a3 + 760) = 0u;
  *(_OWORD *)(a3 + 776) = 0u;
  *(_OWORD *)(a3 + 792) = 0u;
  *(_OWORD *)(a3 + 808) = 0u;
  *(_OWORD *)(a3 + 824) = 0u;
  *(_OWORD *)(a3 + 840) = 0u;
  *(_OWORD *)(a3 + 856) = 0u;
  *(_OWORD *)(a3 + 872) = 0u;
  *(_OWORD *)(a3 + 888) = 0u;
  *(_OWORD *)(a3 + 904) = 0u;
  *(_OWORD *)(a3 + 920) = 0u;
  *(_OWORD *)(a3 + 936) = 0u;
  *(_OWORD *)(a3 + 952) = 0u;
  *(void *)(a3 + 968) = 0;
  *(_OWORD *)(a3 + 1184) = 0u;
  *(_OWORD *)(a3 + 1168) = 0u;
  *(_OWORD *)a3 = xmmword_101D1E250;
  *(void *)(a3 + 16) = 0;
  *(_WORD *)(a3 + 148) = 0;
  *(unsigned char *)(a3 + 150) = 0;
  *(_WORD *)(a3 + 152) = 0;
  *(_OWORD *)(a3 + 160) = xmmword_101D1E250;
  *(void *)(a3 + 176) = 0;
  *(_DWORD *)(a3 + 184) = 0;
  *(void *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(void *)(a3 + 205) = 0;
  *(void *)(a3 + 214) = 0;
  *(_OWORD *)(a3 + 232) = 0u;
  *(unsigned char *)(a3 + 248) = 0;
  *(_OWORD *)(a3 + 256) = xmmword_101D1E250;
  *(void *)(a3 + 272) = 0;
  *(_DWORD *)(a3 + 280) = 0;
  *(void *)(a3 + 288) = 0xFFEFFFFFFFFFFFFFLL;
  *(_DWORD *)(a3 + 376) = 0;
  *(_OWORD *)(a3 + 344) = 0u;
  *(_OWORD *)(a3 + 360) = 0u;
  *(_OWORD *)(a3 + 312) = 0u;
  *(_OWORD *)(a3 + 328) = 0u;
  *(_OWORD *)(a3 + 296) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 441) = 0u;
  *(_DWORD *)(a3 + 464) = 0;
  *(_OWORD *)(a3 + 472) = 0u;
  *(void *)(a3 + 488) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a3 + 496) = 0;
  *(_DWORD *)(a3 + 504) = 0;
  *(void *)(a3 + 584) = 0;
  *(_WORD *)(a3 + 592) = 0;
  *(_DWORD *)(a3 + 576) = 0;
  *(_OWORD *)(a3 + 544) = 0u;
  *(_OWORD *)(a3 + 560) = 0u;
  *(_OWORD *)(a3 + 512) = 0u;
  *(_OWORD *)(a3 + 528) = 0u;
  *(_OWORD *)(a3 + 608) = *(_OWORD *)&v36[14];
  *(_OWORD *)(a3 + 594) = *(_OWORD *)v36;
  *(unsigned char *)(a3 + 632) = 0;
  *(void *)(a3 + 624) = 0;
  *(_DWORD *)(a3 + 648) = 0;
  *(_DWORD *)(a3 + 643) = 0;
  *(void *)(a3 + 636) = 0;
  *(void *)(a3 + 656) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a3 + 976) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a3 + 984) = 0;
  *(void *)(a3 + 1040) = 0;
  *(void *)(a3 + 1048) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a3 + 1056) = 0;
  *(_DWORD *)(a3 + 1064) = 0;
  *(void *)(a3 + 1072) = 0;
  *(unsigned char *)(a3 + 1080) = 0;
  *(void *)(a3 + 1088) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a3 + 1096) = 0u;
  *(void *)(a3 + 1112) = 0x80000000800000;
  *(_OWORD *)(a3 + 1120) = 0u;
  *(_OWORD *)(a3 + 1136) = xmmword_101D1E260;
  *(void *)(a3 + 1152) = 0x80000000800000;
  *(void *)(a3 + 1160) = 0;
  *(void *)(a3 + 1200) = 0xFFEFFFFFFFFFFFFFLL;
  *(_DWORD *)(a3 + 1304) = 0;
  *(_OWORD *)(a3 + 1272) = 0u;
  *(_OWORD *)(a3 + 1288) = 0u;
  *(_OWORD *)(a3 + 1240) = 0u;
  *(_OWORD *)(a3 + 1256) = 0u;
  *(_OWORD *)(a3 + 1208) = 0u;
  *(_OWORD *)(a3 + 1224) = 0u;
  *(void *)(a3 + 1312) = 0xFFEFFFFFFFFFFFFFLL;
  *(_WORD *)(a3 + 1320) = 0;
  *(_DWORD *)(a3 + 1324) = 0;
  *(void *)(a3 + 1328) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a3 + 1336) = 7;
  *(void *)(a3 + 1344) = 0xFFEFFFFFFFFFFFFFLL;
  *(unsigned char *)(a3 + 1352) = 0;
  *(void *)(a3 + 1372) = 0;
  *(_OWORD *)(a3 + 1356) = 0u;
  unint64_t v7 = (_DWORD *)*a2;
  uint64_t v8 = (_DWORD *)a2[1];
  if ((_DWORD *)*a2 != v8)
  {
    double v9 = v35;
    do
    {
      switch(*v7)
      {
        case 0:
          v6 &= sub_1001865E0((uint64_t)(a1 + 1), (_OWORD *)a3, v9);
          sub_100AD83E4((uint64_t)(a1 + 1));
          break;
        case 1:
          uint64_t v10 = (*(uint64_t (**)(void))(**(void **)a1 + 104))();
          v6 &= sub_10111AB04(v10, (_OWORD *)(a3 + 160), v9);
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 104))();
          sub_10111ABE0(v11);
          break;
        case 2:
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)a1 + 120))();
          v6 &= sub_1000BE0C4(v12, (_OWORD *)(a3 + 288), v9);
          uint64_t v13 = (*(uint64_t (**)(void))(**(void **)a1 + 120))();
          sub_1006C1B00(v13);
          break;
        case 3:
          uint64_t v14 = (*(uint64_t (**)(void))(**(void **)a1 + 112))();
          v6 &= sub_10111AC74(v14, (_OWORD *)(a3 + 224), v9);
          uint64_t v15 = (*(uint64_t (**)(void))(**(void **)a1 + 112))();
          sub_10111AD50(v15);
          break;
        case 4:
          uint64_t v16 = (*(uint64_t (**)(void))(**(void **)a1 + 128))();
          v6 &= sub_10111ADE4(v16, (_OWORD *)(a3 + 480), v9);
          uint64_t v17 = (*(uint64_t (**)(void))(**(void **)a1 + 128))();
          sub_10111AF14(v17);
          break;
        case 5:
          uint64_t v18 = (*(uint64_t (**)(void))(**(void **)a1 + 144))();
          v6 &= sub_10111AFA8(v18, a3 + 976, v9);
          uint64_t v19 = (*(uint64_t (**)(void))(**(void **)a1 + 144))();
          sub_1006AC0E8(v19);
          break;
        case 6:
          uint64_t v20 = (*(uint64_t (**)(void))(**(void **)a1 + 152))();
          v6 &= sub_10111B0BC(v20, a3 + 1048, v9);
          uint64_t v21 = (*(uint64_t (**)(void))(**(void **)a1 + 152))();
          sub_10111B1C0(v21);
          break;
        case 7:
          uint64_t v22 = (*(uint64_t (**)(void))(**(void **)a1 + 160))();
          v6 &= sub_1000BE1F4(v22, a3 + 1088, v9);
          uint64_t v23 = (*(uint64_t (**)(void))(**(void **)a1 + 160))();
          sub_100AD8E44(v23);
          break;
        case 8:
          uint64_t v24 = (*(uint64_t (**)(void))(**(void **)a1 + 136))();
          v6 &= sub_10002F800(v24, (void *)(a3 + 656), v9);
          uint64_t v25 = (*(uint64_t (**)(void))(**(void **)a1 + 136))();
          sub_100186B50(v25);
          break;
        case 9:
          uint64_t v26 = (*(uint64_t (**)(void))(**(void **)a1 + 168))();
          v6 &= sub_10111B254(v26, a3 + 1160, v9);
          uint64_t v27 = (*(uint64_t (**)(void))(**(void **)a1 + 168))();
          sub_10111B384(v27);
          break;
        case 0xA:
          uint64_t v28 = (*(uint64_t (**)(void))(**(void **)a1 + 176))();
          v6 &= sub_100175B34(v28, (_OWORD *)(a3 + 1312), v9);
          uint64_t v29 = (*(uint64_t (**)(void))(**(void **)a1 + 176))();
          sub_1006BFA44(v29);
          break;
        case 0xB:
          uint64_t v30 = (*(uint64_t (**)(void))(**(void **)a1 + 192))();
          v6 &= sub_100175B34(v30, (_OWORD *)(a3 + 1328), v9);
          uint64_t v31 = (*(uint64_t (**)(void))(**(void **)a1 + 192))();
          sub_10111B418(v31);
          break;
        case 0xC:
          uint64_t v32 = (*(uint64_t (**)(void))(**(void **)a1 + 200))();
          v6 &= sub_10111B4AC(v32, a3 + 1344, v9);
          uint64_t v33 = (*(uint64_t (**)(void))(**(void **)a1 + 200))();
          sub_10111B5B0(v33);
          break;
        default:
          break;
      }
      ++v7;
    }
    while (v7 != v8);
  }
  return v6 & 1;
}

uint64_t sub_100174C6C(uint64_t a1)
{
  return a1 + 1352;
}

BOOL sub_100174C74(uint64_t a1, double *a2, double a3)
{
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  BOOL result = sub_100174F3C(*(void **)(a1 + 656), (uint64_t)&v30, &v28, a3);
  if (result)
  {
    uint64_t v6 = *((void *)&v31 + 1);
    uint64_t v7 = *(void *)v31;
    uint64_t v8 = *((void *)&v31 + 1) - *(void *)v31;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 6);
    unint64_t v10 = v9 - 1;
    if (v8 < 193)
    {
      uint64_t v14 = ((21 - v9) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v15 = v14 + ((21 - v9 - v14) >> 1);
      uint64_t v12 = *(void *)(v31 - 8 * (v15 >> 4));
      uint64_t v13 = v12 + 192 * (v9 - 21 + 21 * (v15 >> 4)) + 3840;
      if (v13 == *((void *)&v29 + 1)) {
        return 0;
      }
      unint64_t v11 = -(uint64_t)(v15 >> 4);
    }
    else
    {
      unint64_t v11 = v10 / 0x15;
      uint64_t v12 = *(void *)(v31 + 8 * (v10 / 0x15));
      uint64_t v13 = v12 + 192 * (v10 % 0x15);
      if (v13 == *((void *)&v29 + 1)) {
        return 0;
      }
    }
    if (v13 == v12) {
      uint64_t v13 = *(void *)(v31 + 8 * v11 - 8) + 4032;
    }
    if (*(double *)(v13 - 192) > a3) {
      return 0;
    }
    uint64_t v16 = *((void *)&v31 + 1);
    if (*((void *)&v31 + 1) == v7) {
      uint64_t v16 = *(void *)(v31 - 8) + 4032;
    }
    if (*(double *)(v16 - 192) <= a3) {
      return 0;
    }
    if (v8 < 193)
    {
      uint64_t v20 = ((21 - v9) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v21 = (v20 + ((21 - v9 - v20) >> 1)) >> 4;
      unint64_t v17 = -(uint64_t)v21;
      uint64_t v18 = *(void *)(v31 - 8 * v21);
      uint64_t v19 = v18 + 192 * (v9 - 21 + 21 * v21) + 3840;
    }
    else
    {
      unint64_t v17 = v10 / 0x15;
      uint64_t v18 = *(void *)(v31 + 8 * (v10 / 0x15));
      uint64_t v19 = v18 + 192 * (v10 % 0x15);
    }
    if (v19 == v18) {
      uint64_t v19 = *(void *)(v31 + 8 * v17 - 8) + 4032;
    }
    if (v8 < 193)
    {
      unint64_t v25 = 21 - v9;
      uint64_t v26 = ((21 - v9) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v27 = (v26 + ((v25 - v26) >> 1)) >> 4;
      unint64_t v22 = -(uint64_t)v27;
      uint64_t v23 = *(void *)(v31 - 8 * v27);
      uint64_t v24 = v23 + 192 * (21 * v27 - v25) + 3840;
    }
    else
    {
      unint64_t v22 = v10 / 0x15;
      uint64_t v23 = *(void *)(v31 + 8 * (v10 / 0x15));
      uint64_t v24 = v23 + 192 * (v10 % 0x15);
    }
    if (v24 == v23) {
      uint64_t v24 = *(void *)(v31 + 8 * v22 - 8) + 4032;
    }
    if (*((void *)&v31 + 1) == v7) {
      uint64_t v6 = *(void *)(v31 - 8) + 4032;
    }
    *a2 = sub_1001BF26C(*(double *)(v19 - 192), *(double *)(v24 - 144), *(double *)(v6 - 192), *(double *)(v6 - 144), a3);
    return 1;
  }
  return result;
}

BOOL sub_100174F3C(void *a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = a1[7];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x15));
  if (a1[5] == v5) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *v6 + 192 * (v4 % 0x15);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  uint64_t v9 = a1[8];
  if (!v9) {
    return 0;
  }
  unint64_t v10 = a1[7] + v9;
  uint64_t v11 = ((v10 - 1) * (unsigned __int128)0x8618618618618619) >> 64;
  unint64_t v12 = (v11 + ((v10 - 1 - v11) >> 1)) >> 4;
  uint64_t v13 = a1[4];
  uint64_t v14 = a1[5];
  unint64_t v15 = (void *)(v13 + 8 * (v10 / 0x15));
  if (*(double *)(*(void *)(v13 + 8 * v12) + 192 * (v10 - 1 - 21 * v12)) < a4)
  {
    if (v14 == v13) {
      unint64_t v16 = 0;
    }
    else {
      unint64_t v16 = *v15 + 192 * (v10 % 0x15);
    }
    BOOL result = 0;
    *(void *)a2 = v15;
    *(void *)(a2 + 8) = v16;
    *(void *)(a2 + 16) = v15;
    *(void *)(a2 + 24) = v16;
    return result;
  }
  if (v14 == v13) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = *v15 + 192 * (v10 % 0x15);
  }
  uint64_t v19 = a3[3];
  if (v18 == v19)
  {
LABEL_22:
    uint64_t v24 = *(void *)(a2 + 24);
    return v24 != v19;
  }
  uint64_t v20 = *v15;
  unint64_t v21 = v18;
  unint64_t v22 = v15;
  while (1)
  {
    uint64_t v23 = v21 - v20;
    if (v21 == v20) {
      break;
    }
    if (*(double *)(v21 - 192) <= a4) {
      goto LABEL_23;
    }
LABEL_21:
    v21 -= 192;
    if (v21 == v19) {
      goto LABEL_22;
    }
  }
  uint64_t v20 = *(v22 - 1);
  if (*(double *)(v20 + 3840) > a4)
  {
    unint64_t v21 = v20 + 4032;
    --v22;
    goto LABEL_21;
  }
LABEL_23:
  unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (v23 >> 6);
  if (v23 < -191)
  {
    unint64_t v30 = 19 - v25;
    uint64_t v31 = ((19 - v25) * (unsigned __int128)0x8618618618618619) >> 64;
    unint64_t v32 = (v31 + ((v30 - v31) >> 1)) >> 4;
    long long v29 = &v22[-v32];
    uint64_t v24 = *v29 + 192 * (21 * v32 - v30) + 3840;
  }
  else
  {
    unint64_t v26 = v25 + 1;
    uint64_t v27 = ((v25 + 1) * (unsigned __int128)0x8618618618618619) >> 64;
    unint64_t v28 = (v27 + ((v26 - v27) >> 1)) >> 4;
    long long v29 = &v22[v28];
    uint64_t v24 = *v29 + 192 * (v26 - 21 * v28);
  }
  *(void *)a2 = v15;
  *(void *)(a2 + 8) = v18;
  *(void *)(a2 + 16) = v29;
  *(void *)(a2 + 24) = v24;
  uint64_t v19 = a3[3];
  return v24 != v19;
}

double sub_1001751A0(double *a1, double a2)
{
  long long v12 = 0u;
  long long v13 = 0u;
  double v4 = a2 + -360.0;
  sub_100175308((uint64_t)a1, (uint64_t)&v12, a2 + -360.0, a2);
  long long v10 = 0u;
  long long v11 = 0u;
  sub_100175308((uint64_t)a1, (uint64_t)&v10, a2 + -720.0, v4);
  BOOL v5 = 0;
  if (*((double *)&v13 + 1) >= 0.45 && (unint64_t)v13 >= 0x32) {
    BOOL v5 = vabdd_f64(*((double *)&v12 + 1), *(double *)&v12) > 324.0;
  }
  BOOL v6 = 0;
  if (*((double *)&v11 + 1) >= 0.45 && (unint64_t)v11 >= 0x32) {
    BOOL v6 = fabs(*((double *)&v10 + 1) - *(double *)&v10) > 324.0;
  }
  if (v5)
  {
    double v7 = *a1;
    if (*a1 < 3.0)
    {
      double v7 = v7 + vabdd_f64(*((double *)&v12 + 1), a1[8]) / 720.0;
      *a1 = v7;
      double v8 = 0.0;
      if (!v6) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
    double v8 = 0.0;
    if (v6) {
LABEL_13:
    }
      double v8 = 0.05;
  }
  else
  {
    *a1 = 0.0;
    double v7 = 0.0;
    double v8 = 0.0;
  }
LABEL_14:
  double result = fmin(v8 * v7, 0.3);
  a1[8] = *((double *)&v12 + 1);
  return result;
}

void sub_100175308(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = xmmword_101D9A180;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_101D9A190;
  std::string __p = 0;
  double v37 = 0;
  float v38 = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v7
    || (unint64_t v9 = *(void *)(a1 + 48),
        long long v10 = (void *)(v7 + 8 * (v9 >> 8)),
        long long v11 = (double *)(*v10 + 16 * v9),
        uint64_t v12 = *(void *)(v7 + (((*(void *)(a1 + 56) + v9) >> 5) & 0x7FFFFFFFFFFFFF8))
            + 16 * (*(unsigned char *)(a1 + 56) + v9),
        v11 == (double *)v12))
  {
    *(void *)(a2 + 16) = 0;
    return;
  }
  long long v13 = 0;
  do
  {
    double v14 = *v11;
    if (*v11 >= a3 && v14 <= a4)
    {
      double v16 = *(double *)a2;
      if (*(double *)(a2 + 8) >= v14) {
        double v14 = *(double *)(a2 + 8);
      }
      *(double *)(a2 + 8) = v14;
      double v17 = *v11;
      if (*v11 >= v16) {
        double v17 = v16;
      }
      *(double *)a2 = v17;
      float v18 = v11[1];
      float v19 = (*(float *)(a1 + 12) - v18) / (*(float *)(a1 + 12) - *(float *)(a1 + 8));
      double v20 = (float)(1.0 - v19);
      if (v13 >= (double *)v38)
      {
        unint64_t v22 = __p;
        uint64_t v23 = v13 - __p;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v25 = v38 - (char *)__p;
        if ((v38 - (char *)__p) >> 2 > v24) {
          unint64_t v24 = v25 >> 2;
        }
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26)
        {
          uint64_t v27 = (char *)sub_1000DA54C((uint64_t)&v38, v26);
          unint64_t v22 = __p;
          long long v13 = v37;
        }
        else
        {
          uint64_t v27 = 0;
        }
        unint64_t v28 = (double *)&v27[8 * v23];
        *unint64_t v28 = v20;
        unint64_t v21 = v28 + 1;
        while (v13 != v22)
        {
          uint64_t v29 = *((void *)v13-- - 1);
          *((void *)v28-- - 1) = v29;
        }
        std::string __p = v28;
        float v38 = &v27[8 * v26];
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        *long long v13 = v20;
        unint64_t v21 = v13 + 1;
      }
      double v37 = v21;
      long long v13 = v21;
    }
    v11 += 2;
    if ((double *)((char *)v11 - *v10) == (double *)4096)
    {
      unint64_t v30 = (double *)v10[1];
      ++v10;
      long long v11 = v30;
    }
  }
  while (v11 != (double *)v12);
  uint64_t v31 = __p;
  uint64_t v32 = v13 - __p;
  *(void *)(a2 + 16) = v32;
  if (v13 == __p)
  {
    if (!__p) {
      return;
    }
  }
  else
  {
    double v33 = (double)(unint64_t)(v32 - 1) * 0.5;
    unint64_t v34 = (unint64_t)v33;
    double v35 = &__p[(unint64_t)v33];
    if (v35 != v13)
    {
      sub_10039BFC4(__p, v35, v13, v33);
      uint64_t v31 = __p;
    }
    *(double *)(a2 + 24) = v31[v34];
  }
  operator delete(v31);
}

void sub_100175564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100175608(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t sub_100175610(uint64_t a1, uint64_t a2, char *__dst, double a4)
{
  *(_WORD *)&__src[152] = 0;
  *(_OWORD *)__src = xmmword_101D1C570;
  memset(&__src[16], 0, 135);
  *(void *)&__src[160] = 0xBFF0000000000000;
  *(_DWORD *)&__src[168] = 0;
  memset(&__src[184], 0, 312);
  *(void *)&__src[176] = 0xBFF0000000000000;
  *(void *)&__src[496] = 0xBFF0000000000000;
  *(void *)&__src[504] = 0;
  *(void *)&__src[512] = 0xBFF0000000000000;
  *(_DWORD *)&__src[688] = 0;
  *(void *)&__src[696] = 0;
  memset(&__src[520], 0, 84);
  memset(&__src[608], 0, 73);
  *(void *)&__src[704] = 0xBFF0000000000000;
  *(void *)&__src[720] = 0;
  *(void *)&__src[712] = 0;
  *(void *)&__src[728] = 0x80000000800000;
  *(void *)&__src[744] = 0;
  *(void *)&__src[736] = 0;
  *(_OWORD *)&__src[752] = xmmword_101D1E260;
  *(void *)&__src[768] = 0x80000000800000;
  unint64_t v32 = 0xBFF0000000000000;
  long long v34 = 0xBFF0000000000000;
  long long v35 = 0uLL;
  *(void *)BOOL v36 = 0xBFF0000000000000;
  *(_OWORD *)&v36[8] = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  unint64_t v39 = 0xBFF0000000000000;
  uint64_t v40 = 0x600000006;
  uint64_t v42 = 0;
  uint64_t v41 = 0;
  uint64_t v43 = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v44 = _Q0;
  memcpy(__dst, __src, 0x308uLL);
  *((void *)__dst + 97) = 0xBFF0000000000000;
  sub_10017C740((uint64_t *)__dst + 98);
  *((void *)__dst + 99) = 0;
  *((void *)__dst + 98) = 0;
  *((void *)__dst + 100) = 0;
  memset(v33, 0, sizeof(v33));
  long long v12 = v35;
  *(_OWORD *)(__dst + 808) = v34;
  *(_OWORD *)(__dst + 824) = v12;
  *(_OWORD *)(__dst + 840) = *(_OWORD *)v36;
  *((void *)__dst + 107) = *(void *)&v36[16];
  long long v13 = (void *)*((void *)__dst + 108);
  if (v13)
  {
    *((void *)__dst + 109) = v13;
    operator delete(v13);
  }
  *((void *)__dst + 108) = 0;
  *((void *)__dst + 109) = 0;
  *((void *)__dst + 110) = 0;
  uint64_t v38 = 0;
  long long v37 = 0uLL;
  *((void *)__dst + 111) = 0xBFF0000000000000;
  *((void *)__dst + 112) = v40;
  double v14 = (void *)*((void *)__dst + 113);
  if (v14)
  {
    *((void *)__dst + 114) = v14;
    operator delete(v14);
  }
  *((void *)__dst + 113) = 0;
  *((void *)__dst + 114) = 0;
  *((void *)__dst + 115) = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  *((_OWORD *)__dst + 58) = v44;
  float v45 = (void **)v33;
  sub_1000D7F78(&v45);
  unint64_t v15 = *(_DWORD **)a2;
  double v16 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 == v16)
  {
    char v17 = 1;
  }
  else
  {
    char v17 = 1;
    do
    {
      switch(*v15)
      {
        case 0:
          uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 96))(*(void *)(a1 + 24));
          char v19 = sub_1001865E0(v18, __dst, a4);
          goto LABEL_18;
        case 1:
          uint64_t v20 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))(*(void *)(a1 + 24));
          char v19 = sub_100175B34(v20, (_OWORD *)__dst + 10, a4);
          goto LABEL_18;
        case 2:
          uint64_t v21 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 112))(*(void *)(a1 + 24));
          char v19 = sub_10002F800(v21, __dst + 176, a4);
          goto LABEL_18;
        case 3:
          uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
          char v19 = sub_100175B34(v22, (_OWORD *)__dst + 31, a4);
          goto LABEL_18;
        case 4:
          uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 120))(*(void *)(a1 + 24));
          char v19 = sub_1000BE0C4(v23, (_OWORD *)__dst + 32, a4);
          goto LABEL_18;
        case 5:
          uint64_t v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 136))(*(void *)(a1 + 24));
          char v19 = sub_1000BE1F4(v24, (uint64_t)(__dst + 704), a4);
          goto LABEL_18;
        case 6:
          uint64_t v25 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 144))(*(void *)(a1 + 24));
          char v19 = sub_100186D34(v25, (void *)__dst + 97, a4);
          goto LABEL_18;
        case 7:
          uint64_t v26 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 152))(*(void *)(a1 + 24));
          char v19 = sub_100186708(v26, __dst + 808, a4);
          goto LABEL_18;
        case 8:
          uint64_t v27 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 160))(*(void *)(a1 + 24));
          char v19 = sub_1001867DC(v27, (uint64_t)(__dst + 840), a4);
          goto LABEL_18;
        case 9:
          uint64_t v28 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 168))(*(void *)(a1 + 24));
          char v19 = sub_100186BE4(v28, (uint64_t)(__dst + 888), a4);
LABEL_18:
          v17 &= v19;
          break;
        default:
          break;
      }
      ++v15;
    }
    while (v15 != v16);
  }
  return v17 & 1;
}

uint64_t sub_100175B34(uint64_t a1, _OWORD *a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  unsigned __int8 v6 = v5 + v3;
  uint64_t v7 = (uint64_t *)(v4 + 8 * ((v5 + v3) >> 8));
  uint64_t v8 = *v7;
  uint64_t v9 = *v7 + 16 * v6;
  unint64_t v10 = v5 >> 8;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 >> 8)) + 16 * v5;
  if (v9 != v11)
  {
    while (1)
    {
      uint64_t v12 = v9;
      if (v9 == v8) {
        uint64_t v12 = *(v7 - 1) + 4096;
      }
      double v13 = *(double *)(v12 - 16);
      if (v13 <= a3 && v13 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v9 == v8)
      {
        uint64_t v14 = *--v7;
        uint64_t v8 = v14;
        uint64_t v9 = v14 + 4096;
      }
      v9 -= 16;
      if (v9 == v11)
      {
        uint64_t v9 = v11;
        break;
      }
    }
  }
  if (v9 == *(void *)(v4 + 8 * v10) + 16 * *(void *)(a1 + 48)) {
    return 0;
  }
  if (v9 == *v7) {
    uint64_t v9 = *(v7 - 1) + 4096;
  }
  *a2 = *(_OWORD *)(v9 - 16);
  return 1;
}

void sub_100175C04(uint64_t a1, long long *a2)
{
  long long v3 = a2[7];
  long long v30 = a2[6];
  long long v31 = v3;
  long long v4 = a2[9];
  long long v32 = a2[8];
  long long v33 = v4;
  long long v5 = a2[3];
  long long v26 = a2[2];
  long long v27 = v5;
  long long v6 = a2[5];
  long long v28 = a2[4];
  long long v29 = v6;
  long long v7 = a2[1];
  long long v24 = *a2;
  long long v25 = v7;
  uint64_t v8 = *(void *)(a1 + 280);
  if (v8) {
    (*(void (**)(uint64_t, long long *))(*(void *)v8 + 48))(v8, &v24);
  }
  uint64_t v9 = *(void *)(a1 + 56);
  if (v9)
  {
    unint64_t v10 = v9 + *(void *)(a1 + 48) - 1;
    uint64_t v11 = *(void ***)(a1 + 24);
    double v12 = *((double *)v11[v10 / 0x19] + 20 * (v10 % 0x19) + 1);
    if (v12 > *((double *)&v24 + 1))
    {
      uint64_t v13 = *(void *)(a1 + 32);
      *(void *)(a1 + 56) = 0;
      unint64_t v14 = v13 - (void)v11;
      if (v14 >= 0x11)
      {
        do
        {
          operator delete(*v11);
          uint64_t v15 = *(void *)(a1 + 32);
          uint64_t v11 = (void **)(*(void *)(a1 + 24) + 8);
          *(void *)(a1 + 24) = v11;
          unint64_t v14 = v15 - (void)v11;
        }
        while (v14 > 0x10);
      }
      if (v14 >> 3 == 1)
      {
        uint64_t v16 = 12;
      }
      else
      {
        if (v14 >> 3 != 2)
        {
LABEL_12:
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102301FE0);
          }
          char v17 = qword_102418FD8;
          if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)uint64_t buf = 134218240;
            uint64_t v39 = *((void *)&v24 + 1);
            __int16 v40 = 2048;
            double v41 = v12;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "time rollback on add, newItemTime, %f, lastItemTime, %f", buf, 0x16u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102418FD0 != -1) {
              dispatch_once(&qword_102418FD0, &stru_102301FE0);
            }
            int v34 = 134218240;
            uint64_t v35 = *((void *)&v24 + 1);
            __int16 v36 = 2048;
            double v37 = v12;
            uint64_t v23 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLMotionCoprocessorInterface::MotionState>::add(const T &) [T = CLMotionCoprocessorInterface::MotionState]", "%s\n", v23);
            if (v23 != (char *)buf) {
              free(v23);
            }
          }
          goto LABEL_17;
        }
        uint64_t v16 = 25;
      }
      *(void *)(a1 + 48) = v16;
      goto LABEL_12;
    }
  }
LABEL_17:
  sub_100175F20((void *)(a1 + 16), (uint64_t)&v24);
  long long v18 = v31;
  *(_OWORD *)(a1 + 192) = v30;
  *(_OWORD *)(a1 + 208) = v18;
  long long v19 = v33;
  *(_OWORD *)(a1 + 224) = v32;
  *(_OWORD *)(a1 + 240) = v19;
  long long v20 = v27;
  *(_OWORD *)(a1 + 128) = v26;
  *(_OWORD *)(a1 + 144) = v20;
  long long v21 = v29;
  *(_OWORD *)(a1 + 160) = v28;
  *(_OWORD *)(a1 + 176) = v21;
  long long v22 = v25;
  *(_OWORD *)(a1 + 96) = v24;
  *(_OWORD *)(a1 + 112) = v22;
}

__n128 sub_100175F20(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 25 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10017D5D0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x19)) + 160 * (v7 % 0x19);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  long long v10 = *(_OWORD *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v12 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v8 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 80) = v12;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = v11;
  __n128 result = *(__n128 *)(a2 + 96);
  long long v14 = *(_OWORD *)(a2 + 112);
  long long v15 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(v8 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v8 + 144) = v15;
  *(__n128 *)(v8 + 96) = result;
  *(_OWORD *)(v8 + 112) = v14;
  ++a1[5];
  return result;
}

void sub_100175FF8(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void *sub_10017600C(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0) {
    return sub_1000DC48C(result, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  long long v3 = *(_OWORD *)(a2 + 40);
  result[2] = *(void *)(a2 + 56);
  *(_OWORD *)__n128 result = v3;
  return result;
}

uint64_t sub_10017603C(uint64_t result, void *a2)
{
  if (a2)
  {
    long long v3 = *(_DWORD **)(result + 32);
    v23[0] = 0;
    char v25 = 0;
    v26[0] = 0;
    *(void *)uint64_t buf = v26;
    if (*((unsigned char *)sub_1000C7FFC((uint64_t)(v3 + 654), v26, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 720))
    {
      v26[0] = 0;
      *(void *)uint64_t buf = v26;
      uint64_t v4 = sub_1000C7FFC((uint64_t)(v3 + 654), v26, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      sub_1000C8260((uint64_t)v23, (uint64_t)(v4 + 3));
    }
    else
    {
      v26[0] = 1;
      *(void *)uint64_t buf = v26;
      if (!*((unsigned char *)sub_1000C7FFC((uint64_t)(v3 + 654), v26, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 720))
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_102343F68);
        }
        char v17 = qword_1024193D8;
        if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "#warning,#gnssawd,fetchSignalStrengthMeasurementsWithReply Couldn't get current serving cell", buf, 2u);
        }
        if (!sub_10013D1A0(115, 2)) {
          return sub_1000F3950((uint64_t)v23);
        }
        bzero(buf, 0x65CuLL);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_102343F68);
        }
        LOWORD(v26[0]) = 0;
        long long v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLGnssAWD::fetchSignalStrengthMeasurementsWithReply()_block_invoke", "%s\n", v18);
        goto LABEL_59;
      }
      v26[0] = 1;
      *(void *)uint64_t buf = v26;
      uint64_t v5 = sub_1000C7FFC((uint64_t)(v3 + 654), v26, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      sub_1000C8260((uint64_t)v23, (uint64_t)(v5 + 3));
    }
    if (v25)
    {
      if (v24 <= 0xA)
      {
        if (((1 << v24) & 0x87) != 0)
        {
          v3[634] = [[objc_msgSend(a2, "rscp") intValue];
          v3[633] = [[objc_msgSend(a2, "ecn0") intValue];
          sub_1000C7F88(buf);
          LOBYTE(v26[0]) = 0;
          int v6 = sub_1000D2988(*(uint64_t *)buf, "EnableGnssAwdVerboseLogging", (BOOL *)v26);
          if (LOBYTE(v26[0])) {
            int v7 = v6;
          }
          else {
            int v7 = 0;
          }
          if (v30) {
            sub_1000DB0A0(v30);
          }
          if (!v7) {
            goto LABEL_41;
          }
          if (qword_1024193D0 != -1) {
            dispatch_once(&qword_1024193D0, &stru_102343F68);
          }
          unint64_t v8 = qword_1024193D8;
          if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
          {
            int v9 = v3[634];
            int v10 = v3[633];
            *(_DWORD *)uint64_t buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v9;
            LOWORD(v30) = 1024;
            *(_DWORD *)((char *)&v30 + 2) = v10;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#gnssawd,Cellular-AWD,GSM,RSRP,%d,SNR,%d", buf, 0xEu);
          }
          if (!sub_10013D1A0(115, 2)) {
            goto LABEL_41;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1024193D0 == -1)
          {
LABEL_62:
            int v20 = v3[634];
            int v21 = v3[633];
            v26[0] = 67109376;
            v26[1] = v20;
            __int16 v27 = 1024;
            int v28 = v21;
            long long v22 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLGnssAWD::fetchSignalStrengthMeasurementsWithReply()_block_invoke", "%s\n", v22);
            if (v22 != (char *)buf) {
              free(v22);
            }
LABEL_41:
            v3[591] = v3[588];
            return sub_1000F3950((uint64_t)v23);
          }
LABEL_67:
          dispatch_once(&qword_1024193D0, &stru_102343F68);
          goto LABEL_62;
        }
        if (((1 << v24) & 0x440) != 0)
        {
          v3[634] = [[objc_msgSend(a2, "rsrp") intValue];
          v3[633] = [[objc_msgSend(a2, "snr") intValue];
          sub_1000C7F88(buf);
          LOBYTE(v26[0]) = 0;
          int v12 = sub_1000D2988(*(uint64_t *)buf, "EnableGnssAwdVerboseLogging", (BOOL *)v26);
          if (LOBYTE(v26[0])) {
            int v13 = v12;
          }
          else {
            int v13 = 0;
          }
          if (v30) {
            sub_1000DB0A0(v30);
          }
          if (!v13) {
            goto LABEL_41;
          }
          if (qword_1024193D0 != -1) {
            dispatch_once(&qword_1024193D0, &stru_102343F68);
          }
          long long v14 = qword_1024193D8;
          if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
          {
            int v15 = v3[634];
            int v16 = v3[633];
            *(_DWORD *)uint64_t buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v15;
            LOWORD(v30) = 1024;
            *(_DWORD *)((char *)&v30 + 2) = v16;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "#gnssawd,Cellular-AWD,5G-LTE,RSRP,%d,SNR,%d", buf, 0xEu);
          }
          if (!sub_10013D1A0(115, 2)) {
            goto LABEL_41;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1024193D0 == -1) {
            goto LABEL_62;
          }
          goto LABEL_67;
        }
      }
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102343F68);
      }
      long long v19 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "#warning,#gnssawd,Cellular-AWD,Unhandled serving cell to obtain cellular signal strength", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return sub_1000F3950((uint64_t)v23);
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 == -1) {
        goto LABEL_58;
      }
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102343F68);
      }
      long long v11 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "#warning,#gnssawd,Cellular-AWD,fetchSignalStrengthMeasurementsWithReply Unhandled serving cell", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return sub_1000F3950((uint64_t)v23);
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 == -1) {
        goto LABEL_58;
      }
    }
    dispatch_once(&qword_1024193D0, &stru_102343F68);
LABEL_58:
    LOWORD(v26[0]) = 0;
    long long v18 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLGnssAWD::fetchSignalStrengthMeasurementsWithReply()_block_invoke", "%s\n", v18);
LABEL_59:
    if (v18 != (char *)buf) {
      free(v18);
    }
    return sub_1000F3950((uint64_t)v23);
  }
  return result;
}

void sub_1001768D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000F3950((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100176928(uint64_t a1, void *a2, void *a3)
{
}

uint64_t sub_100176938(uint64_t result, uint64_t a2)
{
  *(_WORD *)(result + 48) = *(_WORD *)(a2 + 48);
  return result;
}

__n128 sub_100176944(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 48) = v2;
  __n128 result = *(__n128 *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 112);
  long long v6 = *(_OWORD *)(a2 + 128);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 112) = v5;
  *(_OWORD *)(a1 + 128) = v6;
  *(__n128 *)(a1 + 96) = result;
  return result;
}

unint64_t sub_100176970(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 102 * (a4 - a2)
  }
       - 0x3333333333333333 * ((uint64_t)&a5[-*a4] >> 3)
       + 0x3333333333333333 * ((uint64_t)&a3[-*a2] >> 3);
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  int v9 = (char **)(v8 + 8 * (v7 / 0x66));
  if (a1[2] == v8) {
    int v10 = 0;
  }
  else {
    int v10 = &(*v9)[40 * (v7 % 0x66)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 102 * ((char **)a2 - v9)
  }
        - 0x3333333333333333 * ((uint64_t)&a3[-*a2] >> 3)
        + 0x3333333333333333 * ((v10 - *v9) >> 3);
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x66);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_100176BF4(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_100176BF4(v24, v6);
      sub_101122320(v9, v10, (char **)v12.n128_u64[0], (char *)v12.n128_u64[1], v24[0].n128_u64[0], (char *)v24[0].n128_u64[1], v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
      while ((sub_100473B58((uint64_t)a1, 1) & 1) != 0)
        ;
    }
    else
    {
      sub_100176BF4(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      int v16 = (unsigned char **)(v15 + 8 * (v14 / 0x66));
      if (a1[2] == v15) {
        char v17 = 0;
      }
      else {
        char v17 = &(*v16)[40 * (v14 % 0x66)];
      }
      v24[0] = v12;
      sub_10017EC04(v13.n128_u64[0], (unsigned char *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_10017D8E8(a1, 1) & 1) != 0)
        ;
    }
  }
  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  int v21 = (void *)(v20 + 8 * (v19 / 0x66));
  if (a1[2] == v20) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = *v21 + 40 * (v19 % 0x66);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_100176BF4(v24, v11);
  return v24[0].n128_u64[0];
}

void *sub_100176BF4(void *result, uint64_t a2)
{
  if (a2)
  {
    long long v2 = (void *)*result;
    unint64_t v3 = a2 - 0x3333333333333333 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 101 - v3;
      uint64_t v6 = &v2[-(v5 / 0x66)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 40 * (102 * (v5 / 0x66) - v5) + 4040;
    }
    else
    {
      *__n128 result = &v2[v3 / 0x66];
      unint64_t v4 = v2[v3 / 0x66] + 40 * (v3 % 0x66);
    }
    result[1] = v4;
  }
  return result;
}

unsigned char *sub_100176CA0(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[32] = 0;
  if (*(unsigned char *)(a2 + 32))
  {
    sub_100176D00((uint64_t)a1, a2);
    a1[32] = 1;
  }
  return a1;
}

void sub_100176CE4(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 32)) {
    sub_100178B14(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100176D00(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  sub_100176D48(a1, a2);
  return a1;
}

void sub_100176D34(_Unwind_Exception *a1)
{
  sub_100178B14(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100176D48(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 24);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_1022C4350[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 24) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1022C4370 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

void *sub_100176DD8(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0) {
    return sub_1000DC48C(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  long long v3 = *a3;
  __dst[2] = *((void *)a3 + 2);
  *(_OWORD *)__dst = v3;
  return result;
}

unint64_t sub_100176E04(uint64_t a1, double a2)
{
  sub_10015E55C(a1, *(double *)(a1 + 2344), a2);
  double v4 = *(double *)(a1 + 2344);
  if (v4 < a2) {
    double v4 = a2;
  }
  *(double *)(a1 + 2344) = v4;
  uint64_t v5 = *(void *)(a1 + 2256);
  unint64_t v6 = *(void *)(a1 + 2280);
  char v7 = (void *)(v5 + 8 * (v6 / 0x66));
  if (*(void *)(a1 + 2264) == v5)
  {
    int v9 = 0;
  }
  else
  {
    unint64_t v8 = *(void *)(v5 + 8 * (v6 / 0x66)) + 40 * (v6 % 0x66);
    int v9 = (char *)(*(void *)(v5 + 8 * ((*(void *)(a1 + 2288) + v6) / 0x66))
                + 40 * ((*(void *)(a1 + 2288) + v6) % 0x66));
    if ((char *)v8 != v9)
    {
      while (*(double *)v8 > a2)
      {
        v8 += 40;
        if (v8 - *v7 == 4080)
        {
          unint64_t v10 = v7[1];
          ++v7;
          unint64_t v8 = v10;
        }
        if ((char *)v8 == v9) {
          goto LABEL_24;
        }
      }
      sub_1001770A4(a1, (uint64_t *)v8);
      uint64_t v11 = *(void *)(a1 + 2328);
      if (!v11) {
LABEL_30:
      }
        sub_10015E48C();
      uint64_t v12 = *(void *)v8;
      double v28 = (*(double (**)(uint64_t, unint64_t))(*(void *)v11 + 48))(v11, v8);
      uint64_t v29 = v13;
      sub_1001771A4((double *)a1, &v28, *(double *)&v12);
    }
    if ((char *)v8 != v9)
    {
      unint64_t v14 = v8;
      uint64_t v15 = v7;
      while (1)
      {
        v14 += 40;
        if (v14 - *v15 == 4080)
        {
          unint64_t v16 = v15[1];
          ++v15;
          unint64_t v14 = v16;
        }
        if ((char *)v14 == v9) {
          break;
        }
        if (*(double *)v14 > a2)
        {
          long long v20 = *(_OWORD *)v14;
          long long v21 = *(_OWORD *)(v14 + 16);
          *(void *)(v8 + 32) = *(void *)(v14 + 32);
          *(_OWORD *)unint64_t v8 = v20;
          *(_OWORD *)(v8 + 16) = v21;
          v8 += 40;
          if (v8 - *v7 == 4080)
          {
            unint64_t v22 = v7[1];
            ++v7;
            unint64_t v8 = v22;
          }
        }
        else
        {
          sub_1001770A4(a1, (uint64_t *)v14);
          uint64_t v17 = *(void *)(a1 + 2328);
          if (!v17) {
            goto LABEL_30;
          }
          uint64_t v18 = *(void *)v14;
          double v28 = (*(double (**)(uint64_t, unint64_t))(*(void *)v17 + 48))(v17, v14);
          uint64_t v29 = v19;
          sub_1001771A4((double *)a1, &v28, *(double *)&v18);
        }
      }
      int v9 = (char *)v8;
    }
  }
LABEL_24:
  unint64_t v23 = *(void *)(a1 + 2280) + *(void *)(a1 + 2288);
  uint64_t v24 = *(void *)(a1 + 2256);
  char v25 = (void *)(v24 + 8 * (v23 / 0x66));
  if (*(void *)(a1 + 2264) == v24) {
    long long v26 = 0;
  }
  else {
    long long v26 = (char *)(*v25 + 40 * (v23 % 0x66));
  }

  return sub_100176970((void *)(a1 + 2248), v7, v9, v25, v26);
}

double sub_100177090()
{
  return 1.79769313e308;
}

uint64_t sub_1001770A4(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = a2[2];
  if (v2 == 3)
  {
    double v4 = *(double *)a2;
    if (*(double *)(result + 2416) == 0.0) {
      *(double *)(result + 2416) = v4;
    }
    *(double *)(result + 2424) = v4;
    ++*(_DWORD *)(result + 2432);
  }
  else if (v2 == 2)
  {
    double v3 = *(double *)a2;
    if (*(double *)(result + 2400) == 0.0) {
      *(double *)(result + 2400) = v3;
    }
    *(double *)(result + 2408) = v3;
    ++*(_DWORD *)(result + 2436);
  }
  double v5 = *((double *)a2 + 3);
  if (*(double *)(result + 2472) < v5) {
    *(double *)(result + 2472) = v5;
  }
  if (*(double *)(result + 2480) > v5) {
    *(double *)(result + 2480) = v5;
  }
  *(double *)(result + 2488) = v5 + *(double *)(result + 2488);
  ++*(void *)(result + 2496);
  float v6 = *((float *)a2 + 2);
  if (*(_DWORD *)(result + 2504) < (int)v6) {
    *(_DWORD *)(result + 2504) = (int)v6;
  }
  if (v6 >= 0.0)
  {
    for (uint64_t i = 0; i != 17; ++i)
    {
      if (v6 <= dword_101E0A548[i]) {
        break;
      }
    }
    if (i >= 0x10) {
      LODWORD(i) = 16;
    }
    ++*(_DWORD *)(result + 4 * i + 2508);
  }
  return result;
}

void sub_1001771A4(double *a1, double *a2, double a3)
{
  double v4 = *a2;
  double v5 = a2[1];
  if (v5 > *a2)
  {
    double v6 = a1[279];
    if (v6 < a1[292]) {
      double v6 = a1[292];
    }
    if (v4 < v6) {
      double v4 = v6;
    }
    if (v5 < a1[287]) {
      double v5 = a1[287];
    }
    a1[287] = v5;
    sub_10144B4F8((uint64_t)a1, v4, a3);
  }
}

id sub_1001771E4(uint64_t a1, void *a2)
{
  return _[a2 onKFFilteredPressure:a1];
}

id sub_1001771F0(uint64_t a1, void *a2)
{
  return _[a2 onKFFilteredPressure:a1];
}

uint64_t sub_10017721C(uint64_t a1, uint64_t a2)
{
  return sub_1000AE100(*(void *)(a1 + 32), a2, *(const __CFString **)(a1 + 48), *(const __CFDictionary **)(a1 + 56));
}

uint64_t sub_10017722C(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1[4] + 16))();
  if (result)
  {
    double v3 = (uint64_t (*)(void *, uint64_t))a1[5];
    uint64_t v4 = a1[20];
    return v3(a1 + 6, v4);
  }
  return result;
}

BOOL sub_100177288(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t sub_1001772A0(uint64_t a1)
{
  return sub_100255458(a1 + 48);
}

void sub_1001772A8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1001772C4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1001772DC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v1 = (void *)(a1 + 48);
  uint64_t v2 = v3;
  void *v1 = 0;
  if (v3) {
    sub_100436D2C((uint64_t)v1, v2);
  }
}

void sub_1001772F0(uint64_t a1)
{
}

void sub_100177304(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

uint64_t sub_100177318(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100177350(uint64_t a1)
{
}

void sub_100177364(uint64_t a1)
{
}

void sub_100177370(uint64_t a1)
{
}

void sub_10017737C(uint64_t a1)
{
  if (*(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 64);
    operator delete(v2);
  }
}

void sub_100177404(uint64_t a1)
{
}

void sub_100177410(uint64_t a1)
{
}

void sub_10017741C(uint64_t a1)
{
}

void sub_100177428(uint64_t a1)
{
}

uint64_t sub_100177434(uint64_t a1)
{
  return sub_1001111C8(a1 + 48);
}

void sub_10017743C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_100177454(uint64_t a1)
{
}

void sub_100177464(uint64_t a1)
{
}

uint64_t sub_100177474(uint64_t a1)
{
  return sub_1007E1E64(a1 + 48);
}

uint64_t sub_10017747C(uint64_t a1)
{
  return sub_1001AB240(a1 + 48);
}

void sub_100177484(uint64_t a1)
{
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 64);
    operator delete(v2);
  }
}

void sub_1001774FC(uint64_t a1)
{
}

void sub_100177508(uint64_t a1)
{
}

void sub_100177514(uint64_t a1)
{
}

void sub_100177520(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {
    *(void *)(a1 + 280) = v2;
    operator delete(v2);
  }

  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 48);
    operator delete(v3);
  }
}

void sub_1001775B4(uint64_t a1)
{
}

uint64_t sub_1001775C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1001775F8(uint64_t a1)
{
}

uint64_t sub_100177604(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10017763C(uint64_t a1)
{
}

void sub_100177648(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

void sub_10017765C(uint64_t a1)
{
}

void sub_100177668(uint64_t a1)
{
}

void sub_100177674(uint64_t a1)
{
}

void sub_100177680(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_100177698(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  sub_101258EFC(&v1);
}

void sub_1001776C4(uint64_t a1)
{
}

void sub_1001776D0(uint64_t a1)
{
}

void sub_1001776DC(uint64_t a1)
{
}

void sub_1001776E8(uint64_t a1)
{
}

void sub_1001776F4(uint64_t a1)
{
}

void sub_100177700(uint64_t a1)
{
}

void sub_10017770C(uint64_t a1)
{
}

void sub_10017771C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t sub_100177734(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    operator delete();
  }
  return result;
}

void sub_10017775C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_100177774(uint64_t a1)
{
}

void sub_100177780(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(void *)(a1 + 232) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 192);
  if (v3)
  {
    *(void *)(a1 + 200) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 160);
  if (v4)
  {
    *(void *)(a1 + 168) = v4;
    operator delete(v4);
  }
  double v5 = *(void **)(a1 + 96);
  if (v5)
  {
    *(void *)(a1 + 104) = v5;
    operator delete(v5);
  }
  if (*(char *)(a1 + 79) < 0)
  {
    double v6 = *(void **)(a1 + 56);
    operator delete(v6);
  }
}

uint64_t sub_100177808(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100177844(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_1000DB0A0(v1);
  }
}

uint64_t sub_100177858(uint64_t result)
{
  if (*(unsigned char *)(result + 352)) {
    return sub_10071874C(result + 296);
  }
  return result;
}

uint64_t sub_100177870(uint64_t a1, uint64_t a2)
{
  return sub_1002552F8(a1 + 48, a2 + 48);
}

__n128 sub_10017787C(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

uint64_t sub_1001778A0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(_WORD *)(result + 56) = *(_WORD *)(a2 + 56);
  *(void *)(result + 48) = v2;
  return result;
}

__n128 sub_1001778B4(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

uint64_t sub_1001778D8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void sub_1001778E8(uint64_t a1, uint64_t a2)
{
}

__n128 sub_1001778F8(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v2;
  long long v3 = *(_OWORD *)(a2 + 80);
  long long v4 = *(_OWORD *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 96) = v4;
  __n128 result = *(__n128 *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  long long v8 = *(_OWORD *)(a2 + 176);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(a1 + 160) = v7;
  *(_OWORD *)(a1 + 176) = v8;
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t sub_10017792C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 53) = *(void *)(a2 + 53);
  *(void *)(result + 48) = v2;
  return result;
}

__n128 sub_100177940(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

uint64_t sub_10017795C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void sub_10017796C(uint64_t a1, uint64_t a2)
{
}

__n128 sub_10017797C(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

__n128 sub_100177990(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  long long v2 = *(_OWORD *)(a2 + 64);
  long long v3 = *(_OWORD *)(a2 + 80);
  long long v4 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = v4;
  *(_OWORD *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 80) = v3;
  __n128 result = *(__n128 *)(a2 + 128);
  long long v6 = *(_OWORD *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(_OWORD *)(a1 + 144) = v6;
  *(_OWORD *)(a1 + 160) = v7;
  *(__n128 *)(a1 + 128) = result;
  return result;
}

void sub_1001779C4(uint64_t a1, uint64_t a2)
{
}

void sub_1001779D4(uint64_t a1, uint64_t a2)
{
}

__n128 sub_1001779E4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  long long v2 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = v2;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  long long v3 = *(_OWORD *)(a2 + 88);
  long long v4 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 118) = *(_OWORD *)(a2 + 118);
  *(_OWORD *)(a1 + 104) = v4;
  *(_OWORD *)(a1 + 88) = v3;
  long long v5 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v5;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 136) = 0;
  long long v6 = *(_OWORD *)(a2 + 160);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = v6;
  long long v7 = *(_OWORD *)(a2 + 184);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = v7;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  *(void *)(a2 + 200) = 0;
  long long v8 = *(_OWORD *)(a2 + 208);
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  *(_OWORD *)(a1 + 208) = v8;
  long long v9 = *(_OWORD *)(a2 + 232);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v9;
  *(void *)(a2 + 232) = 0;
  *(void *)(a2 + 240) = 0;
  *(void *)(a2 + 248) = 0;
  long long v10 = *(_OWORD *)(a2 + 256);
  *(unsigned char *)(a1 + 272) = *(unsigned char *)(a2 + 272);
  *(_OWORD *)(a1 + 256) = v10;
  long long v11 = *(_OWORD *)(a2 + 280);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(_OWORD *)(a1 + 280) = v11;
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  __n128 result = *(__n128 *)(a2 + 304);
  *(unsigned char *)(a1 + 320) = *(unsigned char *)(a2 + 320);
  *(__n128 *)(a1 + 304) = result;
  return result;
}

void sub_100177AC8(uint64_t a1, uint64_t a2)
{
}

void sub_100177AD8(uint64_t a1, uint64_t a2)
{
}

void sub_100177AE8(uint64_t a1, uint64_t a2)
{
}

void sub_100177AF8(uint64_t a1, uint64_t a2)
{
}

void *sub_100177B08(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v2;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v3 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v3;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  long long v4 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v4;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v5 = *(_OWORD *)(a2 + 120);
  long long v6 = *(_OWORD *)(a2 + 136);
  long long v7 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 152) = v7;
  *(_OWORD *)(a1 + 136) = v6;
  *(_OWORD *)(a1 + 120) = v5;
  long long v8 = *(_OWORD *)(a2 + 184);
  long long v9 = *(_OWORD *)(a2 + 200);
  long long v10 = *(_OWORD *)(a2 + 216);
  *(void *)(a1 + 229) = *(void *)(a2 + 229);
  *(_OWORD *)(a1 + 216) = v10;
  *(_OWORD *)(a1 + 200) = v9;
  *(_OWORD *)(a1 + 184) = v8;
  long long v11 = *(_OWORD *)(a2 + 240);
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  *(_OWORD *)(a1 + 240) = v11;
  *(void *)(a2 + 240) = 0;
  *(void *)(a2 + 248) = 0;
  *(void *)(a2 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(void *)(a2 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(void *)(a2 + 272) = 0;
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 288) = 0;
  long long v12 = *(_OWORD *)(a2 + 296);
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  *(_OWORD *)(a1 + 296) = v12;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  *(void *)(a2 + 312) = 0;
  long long v13 = *(_OWORD *)(a2 + 320);
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = v13;
  *(void *)(a2 + 328) = 0;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 320) = 0;
  long long v14 = *(_OWORD *)(a2 + 344);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(_OWORD *)(a1 + 344) = v14;
  *(void *)(a2 + 344) = 0;
  *(void *)(a2 + 352) = 0;
  *(void *)(a2 + 360) = 0;
  long long v15 = *(_OWORD *)(a2 + 368);
  long long v16 = *(_OWORD *)(a2 + 384);
  long long v17 = *(_OWORD *)(a2 + 416);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  *(_OWORD *)(a1 + 416) = v17;
  *(_OWORD *)(a1 + 368) = v15;
  *(_OWORD *)(a1 + 384) = v16;
  long long v18 = *(_OWORD *)(a2 + 432);
  long long v19 = *(_OWORD *)(a2 + 448);
  long long v20 = *(_OWORD *)(a2 + 464);
  *(void *)(a1 + 477) = *(void *)(a2 + 477);
  *(_OWORD *)(a1 + 448) = v19;
  *(_OWORD *)(a1 + 464) = v20;
  *(_OWORD *)(a1 + 432) = v18;
  long long v21 = *(_OWORD *)(a2 + 488);
  *(void *)(a1 + 504) = *(void *)(a2 + 504);
  *(_OWORD *)(a1 + 488) = v21;
  *(void *)(a2 + 488) = 0;
  *(void *)(a2 + 496) = 0;
  *(void *)(a2 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 512) = *(void *)(a2 + 512);
  *(void *)(a2 + 512) = 0;
  *(void *)(a1 + 528) = 0;
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 520) = *(void *)(a2 + 520);
  *(void *)(a1 + 528) = *(void *)(a2 + 528);
  *(void *)(a1 + 536) = *(void *)(a2 + 536);
  *(void *)(a2 + 528) = 0;
  *(void *)(a2 + 520) = 0;
  *(void *)(a2 + 536) = 0;
  return memcpy((void *)(a1 + 544), (const void *)(a2 + 544), 0x458uLL);
}

__n128 sub_100177CC0(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void sub_100177CE4(uint64_t a1, uint64_t a2)
{
}

__n128 sub_100177CF4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  long long v4 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v4;
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void sub_100177D08(uint64_t a1, uint64_t a2)
{
}

__n128 sub_100177D18(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v2;
  long long v3 = *(_OWORD *)(a2 + 80);
  long long v4 = *(_OWORD *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 96) = v4;
  __n128 result = *(__n128 *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  long long v8 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 188) = *(_OWORD *)(a2 + 188);
  *(_OWORD *)(a1 + 160) = v7;
  *(_OWORD *)(a1 + 176) = v8;
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t sub_100177D4C(uint64_t a1, uint64_t a2)
{
  return sub_1007E1FD0(a1 + 48, a2 + 48);
}

_OWORD *sub_100177D58(uint64_t a1, uint64_t a2)
{
  return sub_100006280((_OWORD *)(a1 + 48), (long long *)(a2 + 48));
}

__n128 sub_100177D64(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  long long v2 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = v2;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  long long v3 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v3;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 88) = 0;
  long long v4 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = v4;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  __n128 result = *(__n128 *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(__n128 *)(a1 + 136) = result;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  int v6 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v6;
  return result;
}

void sub_100177DE0(uint64_t a1, uint64_t a2)
{
}

void sub_100177DF0(uint64_t a1, uint64_t a2)
{
}

void sub_100177E00(uint64_t a1, uint64_t a2)
{
}

char *sub_100177E10(uint64_t a1, uint64_t a2)
{
  return sub_10048AEC0((char *)(a1 + 48), (long long *)(a2 + 48));
}

void sub_100177E1C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100177E2C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void sub_100177E3C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100177E4C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void sub_100177E5C(uint64_t a1, uint64_t a2)
{
}

__n128 sub_100177E6C(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v2;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v3 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v3;
  __n128 result = *(__n128 *)(a2 + 120);
  long long v5 = *(_OWORD *)(a2 + 136);
  uint64_t v6 = *(void *)(a2 + 152);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 152) = v6;
  *(_OWORD *)(a1 + 136) = v5;
  *(__n128 *)(a1 + 120) = result;
  return result;
}

uint64_t sub_100177EB8(uint64_t *a1, uint64_t a2)
{
  a1[6] = (uint64_t)(a1 + 6);
  a1[7] = (uint64_t)(a1 + 6);
  a1[8] = 0;
  return sub_1010698D4((uint64_t)(a1 + 6), a1 + 6, (void *)(a2 + 48));
}

uint64_t sub_100177ED4(uint64_t result, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a2 + 48);
  *(unsigned char *)(result + 50) = *(unsigned char *)(a2 + 50);
  *(_WORD *)(result + 48) = v2;
  return result;
}

void sub_100177EE8(uint64_t a1, uint64_t a2)
{
}

void sub_100177EF8(uint64_t a1, uint64_t a2)
{
}

__n128 sub_100177F08(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

__n128 sub_100177F2C(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void sub_100177F50(uint64_t a1, uint64_t a2)
{
}

void sub_100177F60(uint64_t a1, uint64_t a2)
{
}

void sub_100177F70(uint64_t a1, uint64_t a2)
{
}

void sub_100177F80(uint64_t a1, uint64_t a2)
{
}

void sub_100177F90(uint64_t a1, uint64_t a2)
{
}

void sub_100177FA0(uint64_t a1, uint64_t a2)
{
}

void sub_100177FB0(uint64_t a1, uint64_t a2)
{
}

__n128 sub_100177FC0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 76) = *(_OWORD *)(a2 + 76);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

__n128 sub_100177FD4(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

uint64_t sub_100177FF8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

__n128 sub_100178008(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void sub_10017802C(uint64_t a1, uint64_t a2)
{
}

__n128 sub_10017803C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  long long v2 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v2;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  int v3 = *(_DWORD *)(a2 + 88);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a2 + 92);
  *(_DWORD *)(a1 + 88) = v3;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  long long v4 = *(_OWORD *)(a2 + 120);
  long long v5 = *(_OWORD *)(a2 + 136);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v5;
  *(_OWORD *)(a1 + 120) = v4;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 160) = 0;
  *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a2 + 200) = 0;
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 192) = 0;
  *(unsigned char *)(a1 + 216) = *(unsigned char *)(a2 + 216);
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a1 + 240) = *(void *)(a2 + 240);
  *(void *)(a2 + 224) = 0;
  *(void *)(a2 + 232) = 0;
  *(void *)(a2 + 240) = 0;
  *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 248);
  __n128 result = *(__n128 *)(a2 + 256);
  *(__n128 *)(a1 + 256) = result;
  return result;
}

uint64_t sub_100178130(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

__n128 sub_100178140(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  __n128 result = *(__n128 *)(a2 + 64);
  long long v3 = *(_OWORD *)(a2 + 80);
  long long v4 = *(_OWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 96) = v4;
  *(__n128 *)(a1 + 64) = result;
  return result;
}

__n128 sub_100178164(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t sub_100178174(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  return result;
}

__n128 sub_100178180(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 352) = 0;
  if (*(unsigned char *)(a2 + 352))
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    long long v5 = *(_OWORD *)(a2 + 64);
    long long v6 = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 96) = v6;
    *(_OWORD *)(a1 + 48) = v4;
    *(_OWORD *)(a1 + 64) = v5;
    long long v7 = *(_OWORD *)(a2 + 112);
    long long v8 = *(_OWORD *)(a2 + 128);
    long long v9 = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(a1 + 160) = v9;
    *(_OWORD *)(a1 + 112) = v7;
    *(_OWORD *)(a1 + 128) = v8;
    long long v10 = *(_OWORD *)(a2 + 176);
    long long v11 = *(_OWORD *)(a2 + 192);
    long long v12 = *(_OWORD *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
    *(_OWORD *)(a1 + 224) = v12;
    *(_OWORD *)(a1 + 176) = v10;
    *(_OWORD *)(a1 + 192) = v11;
    long long v13 = *(_OWORD *)(a2 + 240);
    long long v14 = *(_OWORD *)(a2 + 256);
    long long v15 = *(_OWORD *)(a2 + 272);
    *(void *)(a1 + 288) = *(void *)(a2 + 288);
    *(_OWORD *)(a1 + 256) = v14;
    *(_OWORD *)(a1 + 272) = v15;
    *(_OWORD *)(a1 + 240) = v13;
    sub_1000E2908(a1 + 296, (uint64_t *)(a2 + 296));
    __n128 result = *(__n128 *)(a2 + 336);
    *(__n128 *)(a1 + 336) = result;
    *(unsigned char *)(a1 + 352) = 1;
  }
  return result;
}

__n128 sub_10017821C(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v2;
  long long v3 = *(_OWORD *)(a2 + 80);
  long long v4 = *(_OWORD *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 96) = v4;
  __n128 result = *(__n128 *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  long long v8 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 188) = *(_OWORD *)(a2 + 188);
  *(_OWORD *)(a1 + 160) = v7;
  *(_OWORD *)(a1 + 176) = v8;
  *(__n128 *)(a1 + 144) = result;
  return result;
}

void sub_100178250(uint64_t a1, NSObject *a2, uint64_t *a3)
{
  sub_1001952F8((uint64_t)[*(id *)(a1 + 8) fitnessModeStateMachine], (uint64_t)a2);
  if (sub_100182064([*(id *)(a1 + 8) fitnessModeStateMachine]))
  {
    if ([*(id *)(a1 + 8) pipelinedSeeded])
    {
      sub_100134750(__p, "startstop");
      sub_1001C7FDC(a1, 2, (uint64_t *)__p);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if ([*(id *)(a1 + 8) pipelinedSeeded]) {
    sub_1001CB82C(a1, (uint64_t)a2, a3);
  }
  else {
    sub_1001BDAFC(a1, a2, (char *)a3);
  }
}

void sub_100178314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100178338(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (*(double *)(a3 + 20) <= 165.0)
  {
    sub_10018818C((uint64_t)v23, (uint64_t)a2, a3);
    long long v8 = *(void **)(a1 + 8);
    v22[8] = v23[8];
    v22[9] = v23[9];
    v22[10] = v23[10];
    v22[4] = v23[4];
    v22[5] = v23[5];
    void v22[6] = v23[6];
    v22[7] = v23[7];
    v22[0] = v23[0];
    v22[1] = v23[1];
    v22[2] = v23[2];
    uint64_t v22[3] = v23[3];
    [v8 setLatestPosition:v22];
    [*(id *)(a1 + 8) latestNavModeEstimate];
    int v10 = v9;
    uint64_t v11 = sub_1001801E0((uint64_t)[*(id *)(a1 + 8) navModeEstimator], a3);
    [*(id *)(a1 + 8) setLatestNavModeEstimate:v11, v12];
    [*(id *)(a1 + 8) latestNavModeEstimate];
    int v14 = v13;
    if (v10 != v13)
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      long long v15 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 67174657;
        *(_DWORD *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "updateLatestEstimate state,%{private}d", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        int v24 = 67174657;
        LODWORD(v25) = v14;
        long long v19 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::updateLatestEstimate(std::chrono::steady_clock::time_point, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v19);
        if (v19 != buf) {
          free(v19);
        }
      }
      unsigned int v16 = [*(id *)(a1 + 8) pipelinedSeeded];
      if (v14 == 2)
      {
        if (v16)
        {
          sub_100134750(buf, "navmode");
          sub_1001C7FDC(a1, 2, (uint64_t *)buf);
          if (v27 < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
    }
    sub_100134750(buf, "updateLatestEstimate");
    sub_100178250(a1, a2, (uint64_t *)buf);
    if (v27 < 0) {
      operator delete(*(void **)buf);
    }
  }
  else if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    long long v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a3 + 20);
      *(_DWORD *)uint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Ignoring LocationController fix with horizontalAccuracy %f because the existing fix would be more helpful anyway.", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 == -1)
      {
LABEL_33:
        uint64_t v20 = *(void *)(a3 + 20);
        int v24 = 134217984;
        uint64_t v25 = v20;
        long long v21 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::updateLatestEstimate(std::chrono::steady_clock::time_point, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v21);
        if (v21 != buf) {
          free(v21);
        }
        return;
      }
LABEL_35:
      dispatch_once(&qword_1024193A0, &stru_10229E160);
      goto LABEL_33;
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    long long v17 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a3 + 20);
      *(_DWORD *)uint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Ignoring LocationController fix with horizontalAccuracy %f because the existing fix would be more helpful anyway.", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 == -1) {
        goto LABEL_33;
      }
      goto LABEL_35;
    }
  }
}

void sub_1001788A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001788DC(uint64_t a1)
{
  return sub_1000064D0(a1 + 32);
}

char *sub_1001788E4(uint64_t a1, uint64_t a2)
{
  return sub_100089AE0((char *)(a1 + 32), (long long *)(a2 + 32));
}

void sub_1001788F0(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1023192F0);
    }
    long long v2 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      int v3 = *(_DWORD *)(a1 + 48);
      uint64_t v4 = *(void *)(a1 + 40);
      v5[0] = 68289538;
      v5[1] = 0;
      __int16 v6 = 2082;
      char v7 = "";
      __int16 v8 = 1026;
      int v9 = v3;
      __int16 v10 = 2114;
      uint64_t v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Releasing process assertion\", \"pid\":%{public}u, \"clientKeyPath\":%{public, location:escape_only}@}", (uint8_t *)v5, 0x22u);
    }
    [*(id *)(a1 + 32) invalidate];
  }
}

uint64_t sub_100178A04(uint64_t result, int a2)
{
  if (a2) {
    ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 64);
  }
  return result;
}

uint64_t sub_100178A20(uint64_t result, uint64_t a2)
{
  if (a2 >= 1) {
    ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 64);
  }
  return result;
}

uint64_t sub_100178A40(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 60) = a2;
  return result;
}

uint64_t sub_100178A50(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 56) = a2;
  return result;
}

uint64_t sub_100178A60(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 52) = a2;
  return result;
}

uint64_t sub_100178A70(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 51) = a2;
  return result;
}

uint64_t sub_100178A80(uint64_t result, int a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 50) = a2 == 0;
  return result;
}

uint64_t sub_100178A98(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 49) = a2;
  return result;
}

uint64_t sub_100178AA8(uint64_t result, int a2)
{
  if (a2) {
    ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 68);
  }
  return result;
}

uint64_t sub_100178AC4(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 48) = a2;
  return result;
}

uint64_t sub_100178AD4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_100178AF4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_100178B14(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1022C4350[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void sub_100178B70(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t sub_100178B84(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v7 = 0;
  uint64_t v2 = sub_100178BF0(a1 + 8, &v7);
  int v6 = 1;
  uint64_t v3 = sub_100178BF0(v1, &v6) + v2;
  int v5 = 2;
  return v3 + sub_100178BF0(v1, &v5);
}

uint64_t sub_100178BF0(uint64_t a1, int *a2)
{
  char v4 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  int v5 = *a2;
  while (1)
  {
    int v6 = *((_DWORD *)v3 + 8);
    if (v5 >= v6) {
      break;
    }
    uint64_t v2 = v3;
LABEL_7:
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      return 0;
    }
  }
  if (v6 < v5)
  {
    ++v3;
    goto LABEL_7;
  }
  uint64_t v9 = *v3;
  __int16 v10 = v3;
  if (*v3)
  {
    __int16 v10 = v3;
    do
    {
      int v11 = *(_DWORD *)(v9 + 32);
      BOOL v12 = v11 < v5;
      if (v11 >= v5) {
        int v13 = (uint64_t *)v9;
      }
      else {
        int v13 = (uint64_t *)(v9 + 8);
      }
      if (!v12) {
        __int16 v10 = (void *)v9;
      }
      uint64_t v9 = *v13;
    }
    while (*v13);
  }
  uint64_t v14 = v3[1];
  if (v14)
  {
    do
    {
      int v15 = *(_DWORD *)(v14 + 32);
      BOOL v16 = v5 < v15;
      if (v5 >= v15) {
        long long v17 = (uint64_t *)(v14 + 8);
      }
      else {
        long long v17 = (uint64_t *)v14;
      }
      if (v16) {
        uint64_t v2 = (void *)v14;
      }
      uint64_t v14 = *v17;
    }
    while (*v17);
  }
  if (v10 == v2) {
    return 0;
  }
  uint64_t v7 = 0;
  do
  {
    uint64_t v18 = (void *)v10[1];
    if (v18)
    {
      do
      {
        long long v19 = v18;
        uint64_t v18 = (void *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        long long v19 = (void *)v10[2];
        BOOL v20 = *v19 == (void)v10;
        __int16 v10 = v19;
      }
      while (!v20);
    }
    ++v7;
    __int16 v10 = v19;
  }
  while (v19 != v2);
  return v7;
}

BOOL sub_100178CCC(_DWORD *a1, double a2)
{
  if (!sub_100178D5C((uint64_t)a1, a2, 6.0) && *a1 == 1 || !sub_100178D5C((uint64_t)a1, a2, 6.0) && !*a1) {
    return 1;
  }
  if (sub_100178D5C((uint64_t)a1, a2, 6.0)) {
    return 0;
  }
  return *a1 == 3;
}

BOOL sub_100178D5C(uint64_t a1, double a2, double a3)
{
  double v3 = *(double *)(a1 + 40);
  return vabdd_f64(a2, v3) > a3 || v3 < 0.0;
}

uint64_t sub_100178D78(uint64_t a1)
{
  double v3 = (void *)(a1 + 240);
  uint64_t v2 = *(void **)(a1 + 240);
  if (v2)
  {
    do
    {
      sub_1001887B4(v2 + 1, (double *)(a1 + 184));
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
    char v4 = (void *)*v3;
    *(void *)uint64_t buf = 0;
    if (v4)
    {
      int v5 = v3;
      do
      {
        BOOL v6 = sub_10017B90C((uint64_t)(v4 + 1));
        uint64_t v7 = *(void **)v5;
        if (v6)
        {
          do
            uint64_t v7 = (void *)*v7;
          while (v7 && sub_10017B90C((uint64_t)(v7 + 1)));
          if (buf != v5 && v5 != (unsigned char *)v7)
          {
            __int16 v8 = v5;
            do
            {
              uint64_t v9 = v8;
              __int16 v8 = (void *)*v8;
            }
            while (v8 != v7);
            if (v9 != (void *)v5)
            {
              *uint64_t v9 = *(void *)buf;
              *(void *)uint64_t buf = *(void *)v5;
              *(void *)int v5 = v7;
            }
          }
          if (!v7) {
            break;
          }
        }
        char v4 = (void *)*v7;
        int v5 = v7;
      }
      while (*v7);
    }
  }
  else
  {
    *(void *)uint64_t buf = 0;
  }
  uint64_t v48 = (uint64_t)v3;
  sub_100179680((void **)buf);
  __int16 v10 = (uint64_t **)(a1 + 216);
  int v11 = *(uint64_t **)(a1 + 216);
  BOOL v12 = (uint64_t *)(a1 + 224);
  while (v12 != v11)
  {
    sub_1001887B4(v11 + 5, (double *)(a1 + 184));
    if (v11[10])
    {
      int v13 = (uint64_t *)v11[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          int v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (uint64_t *)v11[2];
          BOOL v15 = *v14 == (void)v11;
          int v11 = v14;
        }
        while (!v15);
      }
      int v11 = v14;
    }
    else
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      BOOL v16 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        int v17 = *((_DWORD *)v11 + 173);
        uint64_t v18 = sub_10003E9A4(*((_DWORD *)v11 + 8));
        *(_DWORD *)uint64_t buf = 67240450;
        *(_DWORD *)&uint8_t buf[4] = v17;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "#fusion,purging,provider specific hypothesis with empty buffer is erased,hID,%{public}d,type,%{public}s", buf, 0x12u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        int v20 = *((_DWORD *)v11 + 173);
        long long v21 = sub_10003E9A4(*((_DWORD *)v11 + 8));
        *(_DWORD *)float v52 = 67240450;
        *(_DWORD *)&v52[4] = v20;
        *(_WORD *)&v52[8] = 2082;
        *(void *)&v52[10] = v21;
        unint64_t v22 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesPurging()", "%s\n", v22);
        if (v22 != buf) {
          free(v22);
        }
      }
      long long v19 = sub_1000F0A30((uint64_t **)(a1 + 216), v11);
      sub_1008A9614(v11 + 5);
      operator delete(v11);
      int v11 = v19;
    }
  }
  uint64_t v51 = a1;
  *(void *)float v52 = 0;
  *(void *)uint64_t buf = a1;
  unint64_t v23 = *(void **)(a1 + 240);
  if (v23)
  {
    int v24 = (unsigned char *)v48;
    do
    {
      int v25 = sub_10017B3F4((uint64_t)buf, (uint64_t)(v23 + 1));
      long long v26 = *(void **)v24;
      if (v25)
      {
        do
          long long v26 = (void *)*v26;
        while (v26 && sub_10017B3F4((uint64_t)buf, (uint64_t)(v26 + 1)));
        if (v52 != v24 && v24 != (unsigned char *)v26)
        {
          char v27 = v24;
          do
          {
            double v28 = v27;
            char v27 = (void *)*v27;
          }
          while (v27 != v26);
          if (v28 != (void *)v24)
          {
            *double v28 = *(void *)v52;
            *(void *)float v52 = *(void *)v24;
            *(void *)int v24 = v26;
          }
        }
        if (!v26) {
          break;
        }
      }
      unint64_t v23 = (void *)*v26;
      int v24 = v26;
    }
    while (*v26);
  }
  sub_100179680((void **)v52);
  uint64_t v29 = *v10;
  while (v12 != v29)
  {
    if (sub_10017B3F4((uint64_t)&v51, (uint64_t)(v29 + 5)))
    {
      long long v30 = sub_1000F0A30((uint64_t **)(a1 + 216), v29);
      sub_1008A9614(v29 + 5);
      operator delete(v29);
      uint64_t v29 = v30;
    }
    else
    {
      long long v31 = (uint64_t *)v29[1];
      if (v31)
      {
        do
        {
          long long v32 = v31;
          long long v31 = (uint64_t *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          long long v32 = (uint64_t *)v29[2];
          BOOL v15 = *v32 == (void)v29;
          uint64_t v29 = v32;
        }
        while (!v15);
      }
      uint64_t v29 = v32;
    }
  }
  uint64_t v50 = a1;
  long long v33 = *(void **)(a1 + 240);
  if (v33)
  {
    uint64_t v34 = 0;
    do
    {
      ++v34;
      long long v33 = (void *)*v33;
    }
    while (v33);
    if ((unint64_t)(v34 - 1) >= 0xC)
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v35 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 134349312;
        *(void *)&uint8_t buf[4] = v34;
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(void *)&unsigned char buf[14] = 12;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "#fusion,purging,maximum number of fused hypotheses reached,number,%{public}zu,max,%{public}zu", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        *(_DWORD *)float v52 = 134349312;
        *(void *)&v52[4] = v34;
        *(_WORD *)&v52[12] = 2050;
        *(void *)&v52[14] = 12;
        uint64_t v47 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesPurging()", "%s\n", v47);
        if (v47 != buf) {
          free(v47);
        }
      }
      int v49 = v34 - 12;
      sub_100E9CC14(&v50, &v49, 0);
      if (v49 >= 1)
      {
        sub_100E9CC14(&v50, &v49, 4);
        if (v49 >= 1)
        {
          sub_100E9CC14(&v50, &v49, 3);
          if (v49 >= 1)
          {
            sub_100E9CC14(&v50, &v49, 1);
            if (v49 >= 1)
            {
              unint64_t v36 = 13;
              uint64_t v37 = v48;
              do
              {
                uint64_t v37 = *(void *)v37;
                --v36;
              }
              while (v36 > 1);
              for (; v37; uint64_t v37 = *(void *)v37)
              {
                if (qword_102419510 != -1) {
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                }
                uint64_t v38 = qword_102419518;
                if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v39 = *(void *)(v37 + 48);
                  if (v39) {
                    uint64_t v40 = *(void *)(*(void *)(*(void *)(v37 + 16)
                  }
                                                + 8 * ((v39 + *(void *)(v37 + 40) - 1) / 0x17uLL))
                                    + 176 * ((v39 + *(void *)(v37 + 40) - 1) % 0x17uLL)
                                    + 8);
                  else {
                    uint64_t v40 = 0;
                  }
                  int v41 = *(_DWORD *)(v37 + 660);
                  *(_DWORD *)uint64_t buf = 67240704;
                  *(_DWORD *)&uint8_t buf[4] = v41;
                  *(_WORD *)&uint8_t buf[8] = 2050;
                  *(void *)&buf[10] = v40;
                  *(_WORD *)&buf[18] = 2050;
                  *(void *)&buf[20] = v39;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "#fusion,purging,active fused hypothesis deleted,hID,%{public}d,validityTime_MCT,%{public}.3f,bufferSize,%{public}zu", buf, 0x1Cu);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  int v42 = *(_DWORD *)(v37 + 660);
                  uint64_t v43 = *(void *)(v37 + 48);
                  if (v43) {
                    uint64_t v44 = *(void *)(*(void *)(*(void *)(v37 + 16)
                  }
                                                + 8 * ((v43 + *(void *)(v37 + 40) - 1) / 0x17uLL))
                                    + 176 * ((v43 + *(void *)(v37 + 40) - 1) % 0x17uLL)
                                    + 8);
                  else {
                    uint64_t v44 = 0;
                  }
                  *(_DWORD *)float v52 = 67240704;
                  *(_DWORD *)&v52[4] = v42;
                  *(_WORD *)&v52[8] = 2050;
                  *(void *)&v52[10] = v44;
                  *(_WORD *)&v52[18] = 2050;
                  *(void *)&v52[20] = v43;
                  float v45 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesPurging()", "%s\n", v45);
                  if (v45 != buf) {
                    free(v45);
                  }
                }
              }
              sub_100E9CF4C(v48, 0, 0);
            }
          }
        }
      }
    }
  }
  return 1;
}

void sub_100179630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_1001C7F8C(exception_object);
}

void sub_100179680(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    do
    {
      double v3 = (void *)*v2;
      sub_1008A9614(v2 + 1);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  *a1 = 0;
}

void sub_1001796D0(_OWORD *a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a2 + 96) = v2;
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a2 + 224);
  long long v3 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a2 + 32) = v3;
  long long v4 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a2 + 64) = v4;
  long long v6 = a1[3];
  long long v5 = a1[4];
  long long v7 = a1[6];
  *(_OWORD *)(a2 + 208) = a1[5];
  *(_OWORD *)(a2 + 224) = v7;
  *(_OWORD *)(a2 + 176) = v6;
  *(_OWORD *)(a2 + 192) = v5;
  long long v9 = a1[1];
  long long v8 = a1[2];
  *(_OWORD *)(a2 + 128) = *a1;
  *(_OWORD *)(a2 + 144) = v9;
  *(_OWORD *)(a2 + 160) = v8;
  if (*(unsigned char *)(a2 + 8)) {
    sub_10006B580(a2);
  }
  else {
    *(unsigned char *)(a2 + 8) = 1;
  }
}

void sub_10017972C(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  long long v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100179780(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 1216);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 975) < 0) {
    operator delete(*(void **)(a1 + 952));
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 856);
  if (v3) {
    sub_1000DB0A0(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 736);
  if (v4)
  {
    sub_1000DB0A0(v4);
  }
}

void sub_1001797F8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100179808(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_1000DB0A0(v1);
  }
}

void sub_100179818(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_1000DB0A0(v1);
  }
}

void sub_100179828(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  long long v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_10017987C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10017988C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_1000DB0A0(v1);
  }
}

unsigned char *sub_10017989C(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 64);
  a1[7] = *(void *)(a2 + 56);
  a1[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 9;
  if (*(char *)(a2 + 95) < 0) {
    return sub_1000DC48C(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v5 = *(_OWORD *)(a2 + 72);
  a1[11] = *(void *)(a2 + 88);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_100179904(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 64);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10017991C(uint64_t a1, uint64_t a2)
{
  return sub_1000EF97C(a1 + 48, a2 + 48);
}

uint64_t sub_100179928(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100179944(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100179960(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

unsigned char *sub_10017997C(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_1000DC48C(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_1001799E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001799FC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100179A18(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100179A34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3321888768;
  long long v6 = sub_10000832C;
  long long v7 = &unk_1022F2128;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v10 = v2;
  uint64_t v8 = v3;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_1000DC48C(&__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 72);
    uint64_t v12 = *(void *)(a1 + 88);
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4 && *(void *)(v4 + 8) != -1) {
    v6((uint64_t)v5);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100179B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100179B30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v6 = *(id **)(a1 + 32);
  id v7 = [*v6 silo];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3321888768;
  v10[2] = sub_100179A34;
  v10[3] = &unk_1022F2160;
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 48);
  v10[6] = v6;
  v10[7] = v9;
  int v11 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v10[4] = a2;
  if (*(char *)(a1 + 79) < 0)
  {
    sub_1000DC48C(&__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 72);
  }
  v10[5] = a3;
  [v7 async:v10];
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_100179C3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100179C6C(void *a1)
{
  uint64_t v2 = a1[6];
  *(unsigned char *)(*(void *)(a1[5] + 8) + 48) = 80;
  BOOL v3 = sub_100172054(v2, *(void *)(a1[5] + 8) + 48, 2);
  uint64_t v4 = a1[4];
  if (v4)
  {
    (*(void (**)(uint64_t, BOOL))(v4 + 16))(v4, v3);
    long long v5 = (const void *)a1[4];
    _Block_release(v5);
  }
}

void sub_100179CEC(uint64_t a1)
{
}

void sub_100179CF4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  v4[0] = *(long long ***)(a1 + 40);
  v4[1] = (long long **)v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10009E05C(v2, v4);
  if (v3)
  {
    sub_1000DB0A0((std::__shared_weak_count *)v3);
  }
}

void sub_100179D68(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1000DB0A0(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100179D80(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 40);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  v6[2] = sub_100179CF4;
  v6[3] = &unk_1022C8850;
  uint64_t v5 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  v6[4] = v2;
  v6[5] = v5;
  id v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v3 async:v6];
  if (v7) {
    sub_1000DB0A0(v7);
  }
}

void sub_100179E20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_1000DB0A0(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100179E38(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = sub_100082064(*(void *)(v1 + 160) + 72);
  if (result)
  {
    uint64_t v3 = *(void *)(v1 + 160);
    return sub_1001AF12C(v3, 1000);
  }
  return result;
}

void sub_100179E8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ([*(id *)(v1 + 112) isMonitoring]) {
    sub_10131C434(v1, 0, 0x64u);
  }
  if (sub_100082064(*(void *)(v1 + 160) + 72))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_100027DC0(v1, 0);
    if (vabdd_f64(Current, *(double *)(v1 + 240)) > *(double *)(v1 + 280))
    {
      if (qword_102419110 != -1) {
        dispatch_once(&qword_102419110, &stru_102320268);
      }
      uint64_t v3 = qword_102419118;
      if (os_log_type_enabled((os_log_t)qword_102419118, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Aggregating accel sensor recorder samples.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419110 != -1) {
          dispatch_once(&qword_102419110, &stru_102320268);
        }
        long long v6 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "CLSensorRecorderNotifier::CLSensorRecorderNotifier(id<CLIntersiloUniverse>)_block_invoke", "%s\n", v6);
        if (v6 != (char *)buf) {
          free(v6);
        }
      }
      uint64_t v4 = *(void *)(v1 + 288);
      uint64_t v5 = operator new(0x18uLL);
      *(void *)uint64_t buf = v5;
      uint64_t v9 = (char *)(v5 + 3);
      *uint64_t v5 = v4;
      v5[1] = 0x7FEFFFFFFFFFFFFFLL;
      *((unsigned char *)v5 + 16) = 0;
      uint64_t v8 = v5 + 3;
      (*(void (**)(void, uint8_t *))(**(void **)(v1 + 160) + 32))(*(void *)(v1 + 160), buf);
      *(double *)(v1 + 240) = Current;
      if (*(void *)buf)
      {
        uint64_t v8 = *(void **)buf;
        operator delete(*(void **)buf);
      }
    }
  }
}

void sub_10017A0EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_10017A110(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 156) += **(_DWORD **)(a1 + 40);
  double result = **(double **)(a1 + 48) + *(double *)(v1 + 160);
  *(double *)(v1 + 160) = result;
  return result;
}

int32x2_t sub_10017A13C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 8))
  {
    uint64_t v2 = *(void *)(a1 + 40);
    *(int32x4_t *)(v1 + 36) = vaddq_s32(*(int32x4_t *)(v1 + 36), vuzp1q_s32(*(int32x4_t *)v2, vrev64q_s32(*(int32x4_t *)v2)));
    int32x2_t result = vadd_s32(*(int32x2_t *)(v1 + 52), *(int32x2_t *)(v2 + 16));
    *(int32x2_t *)(v1 + 52) = result;
  }
  return result;
}

__n128 sub_10017A178(uint64_t a1)
{
  uint64_t v1 = *(__n128 **)(a1 + 32);
  if (v1[19].n128_u8[8])
  {
    result.n128_u64[0] = v1[20].n128_u64[0];
    if (result.n128_f64[0] == *(double *)(a1 + 40))
    {
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_1023192B0);
      }
      uint64_t v4 = qword_102419528;
      if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v5 = v1[1].n128_u64[1];
        v7[0] = 68289282;
        v7[1] = 0;
        __int16 v8 = 2082;
        uint64_t v9 = "";
        __int16 v10 = 2114;
        unint64_t v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"received location system state of LocationUpdateSession\", \"Client\":%{public, location:escape_only}@}", (uint8_t *)v7, 0x1Cu);
      }
      long long v6 = *(__n128 **)(a1 + 48);
      __n128 result = *v6;
      v1[23].n128_u64[0] = v6[1].n128_u64[0];
      v1[22] = result;
    }
  }
  return result;
}

double sub_10017A29C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_10017A178;
  v5[3] = &unk_1022B8680;
  v5[4] = v2;
  double result = *(double *)(a1 + 56);
  *(double *)&v5[5] = result;
  v5[6] = a2;
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (*(void *)(v4 + 8) != -1) {
      *(void *)&double result = sub_10017A178((uint64_t)v5).n128_u64[0];
    }
  }
  return result;
}

void sub_10017A32C(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_1023192B0);
  }
  uint64_t v4 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(v3 + 24);
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    __int16 v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#provisional force intermediation response(#cblsPowerSaver)\", \"Client\":%{public, location:escape_only}@, \"shouldContinue\":%{public}hhd}", (uint8_t *)v6, 0x22u);
  }
}

id sub_10017A430(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 32)) {
    sub_101A94A9C();
  }
  id result = a2;
  *(void *)(v2 + 32) = result;
  return result;
}

id sub_10017A464(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
    }
    uint64_t v4 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      uint64_t v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#Warning,#cterror,#ctcl,triggerCellMonitorRefresh,error,%@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 == -1)
      {
LABEL_16:
        __int16 v7 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLCoreTelephonyClient::triggerCellMonitorRefresh(SimInstance)_block_invoke", "%s\n", v7);
        if (v7 != (char *)buf) {
          free(v7);
        }
        return sub_10001F40C(v3, a2 == 0);
      }
LABEL_18:
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
      goto LABEL_16;
    }
  }
  else
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
    }
    uint64_t v5 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#ctcl,triggerCellMonitorRefresh,success", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 == -1) {
        goto LABEL_16;
      }
      goto LABEL_18;
    }
  }
  return sub_10001F40C(v3, a2 == 0);
}

void sub_10017A6F0(uint64_t a1, void *a2, void *a3)
{
}

void sub_10017A6FC(uint64_t a1)
{
}

uint64_t sub_10017A704(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 620) += *(_DWORD *)(result + 40);
  return result;
}

float sub_10017A71C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 596) += *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v1 + 568) += *(_DWORD *)(a1 + 44);
  *(_DWORD *)(v1 + 572) += *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v1 + 584) += *(_DWORD *)(a1 + 52);
  *(_DWORD *)(v1 + 592) += *(_DWORD *)(a1 + 56);
  *(_DWORD *)(v1 + 588) += *(_DWORD *)(a1 + 60);
  *(float *)(v1 + 600) = *(float *)(a1 + 64) + *(float *)(v1 + 600);
  float result = *(float *)(a1 + 68) + *(float *)(v1 + 604);
  *(float *)(v1 + 604) = result;
  *(_DWORD *)(v1 + 576) += *(_DWORD *)(a1 + 72);
  *(_DWORD *)(v1 + 580) += *(_DWORD *)(a1 + 76);
  *(_DWORD *)(v1 + 608) += *(_DWORD *)(a1 + 80);
  *(_DWORD *)(v1 + 612) += *(_DWORD *)(a1 + 84);
  *(_DWORD *)(v1 + 624) += *(_DWORD *)(a1 + 88);
  *(_DWORD *)(v1 + 628) += *(_DWORD *)(a1 + 92);
  return result;
}

void sub_10017A804(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  v4[0] = *(uint64_t **)(a1 + 40);
  v4[1] = (uint64_t *)v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10003B524(v2, v4);
  if (v3)
  {
    sub_1000DB0A0(v3);
  }
}

void sub_10017A878(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1000DB0A0(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017A890(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 40);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _DWORD v6[2] = sub_10017A804;
  v6[3] = &unk_10232E3F8;
  uint64_t v5 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  v6[4] = v2;
  v6[5] = v5;
  __int16 v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v3 async:v6];
  if (v7) {
    sub_1000DB0A0(v7);
  }
}

void sub_10017A930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_1000DB0A0(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017A948(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t, float, double))(*(void *)a2 + 208))(a2, a1 + 40, a1 + 52, *(float *)(a1 + 64), *(double *)(a1 + 32));
  if (qword_1024190B0 != -1) {
    dispatch_once(&qword_1024190B0, &stru_10231D0A0);
  }
  uint64_t v3 = off_1024190B8;
  if (os_log_type_enabled((os_log_t)off_1024190B8, OS_LOG_TYPE_DEBUG))
  {
    double v4 = *(float *)(a1 + 40);
    double v5 = *(float *)(a1 + 44);
    double v6 = *(float *)(a1 + 48);
    double v7 = *(float *)(a1 + 52);
    double v8 = *(float *)(a1 + 56);
    double v9 = *(float *)(a1 + 60);
    double v10 = *(float *)(a1 + 64);
    *(_DWORD *)uint64_t buf = 134350592;
    double v13 = v4;
    __int16 v14 = 2050;
    double v15 = v5;
    __int16 v16 = 2050;
    double v17 = v6;
    __int16 v18 = 2050;
    double v19 = v7;
    __int16 v20 = 2050;
    double v21 = v8;
    __int16 v22 = 2050;
    double v23 = v9;
    __int16 v24 = 2050;
    double v25 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "[CLGBE] SPU bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,temperature,%{public}f", buf, 0x48u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190B0 != -1) {
      dispatch_once(&qword_1024190B0, &stru_10231D0A0);
    }
    __int16 v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)_block_invoke", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
}

void sub_10017ABF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2 && *(void *)(v2 + 8) != -1) {
    sub_100009A0C((uint64_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 48));
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

__n128 sub_10017AC8C(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  long long v3 = *a2;
  *(void *)(v2 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(v2 + 72) = v3;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  return result;
}

void sub_10017ACAC(uint64_t a1, double a2, double a3)
{
  *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 112) = a2;
  *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 120) = a3;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10017ACCC(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    sub_10004C7A0(v3, a1 + 48);
  }
  else
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230E780);
    }
    double v4 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*(id *)(a1 + 32) UTF8String];
      v6[0] = 68289282;
      v6[1] = 0;
      __int16 v7 = 2082;
      double v8 = "";
      __int16 v9 = 2082;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#SLC Not sending due to CLCM provisional intermediation\", \"client\":%{public, location:escape_only}s}", (uint8_t *)v6, 0x1Cu);
    }
  }
}

void sub_10017ADFC(uint64_t a1)
{
}

void sub_10017AE04(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if ([a2 subIdentityType] != 122) {
    return;
  }
  id v5 = [a2 zoneId];
  id v6 = [objc_msgSend(*(id *)(v4 + 136), "readonlyStoreAtKeyPath:", a2) dictionary];
  unsigned int v7 = [*(id *)(v4 + 136) intForKey:@"Provenance" atKeyPath:a2 defaultValue:0];
  if (v7 != 1)
  {
    if (v7 == 2)
    {
      double v8 = *(void **)(a1 + 32);
      [v8 setObject:v6 forKeyedSubscript:a2];
    }
    return;
  }
  id v9 = [*(id *)(a1 + 40) objectForKeyedSubscript:v5];
  if (v9)
  {
    if (sub_1007DFDEC(v9, v6))
    {
      [*(id *)(a1 + 40) removeObjectForKey:v5];
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      id v10 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
      {
        long long __p = (void *)68289282;
        __int16 v15 = 2082;
        __int16 v16 = "";
        __int16 v17 = 2082;
        id v18 = [v5 UTF8String];
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Zone unchanged. Remove from infoPlistZones. Will skip registration\", \"ZoneId\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
      }
      return;
    }
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    int v12 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      long long __p = (void *)68289282;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      id v18 = [v5 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Zone has been updated. Delete from clients.plist first. Will be re-registered\", \"ZoneId\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
    }
  }
  else
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    __int16 v11 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      long long __p = (void *)68289282;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      id v18 = [v5 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"ClientsPlistZone is stale. Not found in Info.plist. Delete\", \"ZoneId\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
    }
  }
  double v13 = *(char **)(a1 + 56);
  sub_100134750(&__p, (char *)[v5 UTF8String]);
  sub_1007CE5D8(v4, v13, (char *)&__p, 0);
  if (SBYTE3(v18) < 0) {
    operator delete(__p);
  }
}

void sub_10017B178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_10017B1A0(uint64_t a1)
{
  return sub_100105FDC(*(unsigned char **)(a1 + 32));
}

id sub_10017B1A8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  double v2 = sub_1000D3E50();

  return sub_10005DEB0(v1, 0, v2);
}

uint64_t sub_10017B1E4(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = CMVO2MaxRetrocomputeRecord;
    uint64_t v4 = a2;
    +[NSDictionary dictionaryWithObjects:&v4 forKeys:&v3 count:1];
  }
  else
  {
    uint64_t v5 = CMErrorMessage;
    id v6 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
    +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  }
  return CLConnectionMessage::sendReply();
}

uint64_t sub_10017B2B8(uint64_t a1, uint64_t a2)
{
  return sub_1000612C4(*(void *)(a1 + 32), a2, *(const __CFDictionary **)(a1 + 48));
}

void sub_10017B2C8(id a1, __CFRunLoopTimer *a2)
{
}

char *sub_10017B2DC@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  return sub_100089AE0(a2, (long long *)(a1 + 32));
}

__n128 sub_10017B2E8@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 64);
  *(__n128 *)(a2 + 32) = result;
  *(void *)(a2 + 48) = *(void *)(a1 + 80);
  return result;
}

uint64_t sub_10017B304(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_10017B324(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_10017B344(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_10017B364(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    sub_1000064D0(result);
    operator delete();
  }
  return result;
}

uint64_t sub_10017B3B0(uint64_t result, uint64_t a2)
{
  *(_WORD *)(result + 48) = *(_WORD *)(a2 + 48);
  return result;
}

id sub_10017B3BC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _processReceivedWiFiDeviceLinkScore:*(unsigned int *)(a1 + 40)];
}

id sub_10017B3CC(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 32) + 160) ingestTAEvent:*(void *)(a1 + 40)];
}

id sub_10017B3E0(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 32) + 120) ingestTAEvent:*(void *)(a1 + 40)];
}

uint64_t sub_10017B3F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (!v3)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    id v9 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(a2 + 652);
      *(_DWORD *)uint64_t buf = 67240192;
      int v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#fusion,purging,hypothesis with empty buffer is erased,hID,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  double v4 = sub_100022DBC(*(void *)(*(void *)(a2 + 8) + 8 * ((v3 + *(void *)(a2 + 32) - 1) / 0x17uLL))+ 176 * ((v3 + *(void *)(a2 + 32) - 1) % 0x17uLL), (double *)(*(void *)a1 + 184));
  if (*(_DWORD *)(a2 + 660) == 1 && v4 > 15.0)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v5 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *(_DWORD *)(a2 + 652);
      int v7 = *(_DWORD *)(a2 + 660);
      uint64_t v8 = *(void *)(a2 + 40);
      *(_DWORD *)uint64_t buf = 67241216;
      int v19 = v6;
      __int16 v20 = 1026;
      int v21 = v7;
      __int16 v22 = 2050;
      uint64_t v23 = v8;
      __int16 v24 = 2050;
      double v25 = v4;
      __int16 v26 = 2050;
      uint64_t v27 = 0x402E000000000000;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#fusion,purging,stale tentative hypothesis is erased,hID,%{public}d,State,%{public}d,bufferSize,%{public}zu,age,%{public}.2f,maxAge,%{public}.2f", buf, 0x2Cu);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1)
    {
LABEL_27:
      __int16 v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "auto cllcf::CLLCFusion::performHypothesesPurging()::(anonymous class)::operator()(const LCFusionLocationHypothesis &) const", "%s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
      return 1;
    }
LABEL_29:
    dispatch_once(&qword_102419510, &stru_1022FFA18);
    goto LABEL_27;
  }
  if (v4 > 30.0)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    __int16 v11 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *(_DWORD *)(a2 + 652);
      int v13 = *(_DWORD *)(a2 + 660);
      uint64_t v14 = *(void *)(a2 + 40);
      int v15 = *(_DWORD *)(a2 + 656);
      *(_DWORD *)uint64_t buf = 67241472;
      int v19 = v12;
      __int16 v20 = 1026;
      int v21 = v13;
      __int16 v22 = 2050;
      uint64_t v23 = v14;
      __int16 v24 = 2050;
      double v25 = v4;
      __int16 v26 = 2050;
      uint64_t v27 = 0x403E000000000000;
      __int16 v28 = 1026;
      int v29 = v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#fusion,purging,stale hypothesis is erased,hID,%{public}d,State,%{public}d,bufferSize,%{public}zu,age,%{public}.2f,maxAge,%{public}.2f,numLostDataAssociation,%{public}u", buf, 0x32u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  return 0;
}

BOOL sub_10017B90C(uint64_t a1)
{
  if (!*(void *)(a1 + 40))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v2 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v3 = *(_DWORD *)(a1 + 652);
      *(_DWORD *)uint64_t buf = 67240192;
      int v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#fusion,purging,fused hypothesis with empty buffer is erased,hID,%{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "auto cllcf::CLLCFusion::performHypothesesPurging()::(anonymous class)::operator()(const LCFusionLocationHypothesis &) const", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  return *(void *)(a1 + 40) == 0;
}

BOOL sub_10017BAD4(uint64_t a1)
{
  if (!*(void *)(a1 + 40))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v2 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v3 = *(_DWORD *)(a1 + 652);
      *(_DWORD *)uint64_t buf = 67240192;
      int v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#fusion,purging,merged hypothesis with empty buffer is erased,hID,%{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "auto cllcf::CLLCFusion::performHypothesesMerging()::(anonymous class)::operator()(const LCFusionLocationHypothesis &) const", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  return *(void *)(a1 + 40) == 0;
}

uint64_t sub_10017BC9C(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  int v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  CFDictionaryRef DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_10013FA80((int)v15, DictionaryOfClasses);
  BOOL v14 = 0;
  if (sub_1000D2988((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14))
  {
    uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    int v10 = (void *)(a2 + (v9 >> 1));
    if (v9) {
      uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }
  else
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_102307AA0);
    }
    __int16 v11 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      int v19 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Couldn't get value for kCLConnectionMessageSubscribeKey key\"}", buf, 0x12u);
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_102307AA0);
      }
    }
    int v12 = qword_102419528;
    if (os_signpost_enabled((os_log_t)qword_102419528))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      int v19 = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Couldn't get value for kCLConnectionMessageSubscribeKey key", "{\"msg%{public}.0s\":\"Couldn't get value for kCLConnectionMessageSubscribeKey key\"}", buf, 0x12u);
    }
  }
  return sub_10013F3C4(v15);
}

void sub_10017BECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10017BEE8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 180);
}

void sub_10017BEF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_10017BEF8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000E65E0(a1 - 352);
  if ((result & 1) == 0)
  {
    return sub_10006BA88(a1 + 256, a2);
  }
  return result;
}

uint64_t sub_10017BF4C()
{
  return sub_10019BAEC();
}

uint64_t sub_10017BF58(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 - 152;
  double v6 = sub_1001AACF8(a1 - 152, *(double *)(a1 + 200));
  long long v4 = a2[1];
  long long v7 = *a2;
  long long v8 = v4;
  return sub_1000E01AC(v3, 8, (uint64_t)&v6, 40);
}

uint64_t sub_10017BFB0()
{
  return sub_1000530D0();
}

void sub_10017BFB8(uint64_t a1, uint64_t a2, float a3)
{
}

uint64_t sub_10017BFC0(uint64_t a1, uint64_t a2)
{
  return sub_100038D48(a1 - 152, a2);
}

uint64_t sub_10017BFC8()
{
  return sub_100087F60();
}

uint64_t sub_10017BFD0@<X0>(char a1@<W0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a2 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  uint64_t result = sub_1001110E4(a3, v5 + 1);
  if (*(char *)(result + 23) >= 0) {
    long long v7 = (unsigned char *)result;
  }
  else {
    long long v7 = *(unsigned char **)result;
  }
  *long long v7 = a1;
  long long v8 = v7 + 1;
  if (v5)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  *((unsigned char *)v8 + v5) = 0;
  return result;
}

void *sub_10017C060(void *result, double *a2, uint64_t a3, double *a4, uint64_t a5, uint64_t a6)
{
  if (a2 != a4)
  {
    while (*(double *)&a5 - *a2 <= *(double *)(a6 + 88))
    {
      a2 += 2;
      if ((double *)((char *)a2 - *result) == (double *)4096)
      {
        double v6 = (double *)result[1];
        ++result;
        a2 = v6;
      }
      if (a2 == a4) {
        return result;
      }
    }
  }
  if (a2 != a4)
  {
    long long v7 = a2;
    long long v8 = result;
    while (1)
    {
      v7 += 2;
      if ((double *)((char *)v7 - *v8) == (double *)4096)
      {
        uint64_t v9 = (double *)v8[1];
        ++v8;
        long long v7 = v9;
      }
      if (v7 == a4) {
        break;
      }
      if (*(double *)&a5 - *v7 <= *(double *)(a6 + 88))
      {
        *(_OWORD *)a2 = *(_OWORD *)v7;
        a2 += 2;
        if ((double *)((char *)a2 - *result) == (double *)4096)
        {
          int v10 = (double *)result[1];
          ++result;
          a2 = v10;
        }
      }
    }
  }
  return result;
}

void *sub_10017C110(void *result, _OWORD *a2, uint64_t a3, _OWORD *a4, uint64_t a5, uint64_t a6)
{
  if (a2 != a4)
  {
    while (*(double *)&a5 - *(double *)a2 <= *(double *)(a6 + 88))
    {
      a2 += 2;
      if ((_OWORD *)((char *)a2 - *result) == (_OWORD *)4096)
      {
        double v6 = (_OWORD *)result[1];
        ++result;
        a2 = v6;
      }
      if (a2 == a4) {
        return result;
      }
    }
  }
  if (a2 != a4)
  {
    long long v7 = a2;
    long long v8 = result;
    while (1)
    {
      v7 += 2;
      if ((_OWORD *)((char *)v7 - *v8) == (_OWORD *)4096)
      {
        uint64_t v9 = (_OWORD *)v8[1];
        ++v8;
        long long v7 = v9;
      }
      if (v7 == a4) {
        break;
      }
      if (*(double *)&a5 - *(double *)v7 <= *(double *)(a6 + 88))
      {
        long long v10 = v7[1];
        *a2 = *v7;
        a2[1] = v10;
        a2 += 2;
        if ((_OWORD *)((char *)a2 - *result) == (_OWORD *)4096)
        {
          __int16 v11 = (_OWORD *)result[1];
          ++result;
          a2 = v11;
        }
      }
    }
  }
  return result;
}

void *sub_10017C1C0(void *result, double *a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  if (a2 != (double *)a4)
  {
    while (*(double *)&a5 - a2[1] <= *(double *)(a6 + 344))
    {
      a2 += 8;
      if ((double *)((char *)a2 - *result) == (double *)4096)
      {
        double v6 = (double *)result[1];
        ++result;
        a2 = v6;
      }
      if (a2 == (double *)a4) {
        return result;
      }
    }
  }
  if (a2 != (double *)a4)
  {
    long long v7 = a2;
    long long v8 = result;
    while (1)
    {
      v7 += 8;
      if ((double *)((char *)v7 - *v8) == (double *)4096)
      {
        uint64_t v9 = (double *)v8[1];
        ++v8;
        long long v7 = v9;
      }
      if (v7 == (double *)a4) {
        break;
      }
      if (*(double *)&a5 - v7[1] <= *(double *)(a6 + 344))
      {
        long long v10 = *(_OWORD *)v7;
        long long v11 = *((_OWORD *)v7 + 1);
        long long v12 = *((_OWORD *)v7 + 3);
        *((_OWORD *)a2 + 2) = *((_OWORD *)v7 + 2);
        *((_OWORD *)a2 + 3) = v12;
        *(_OWORD *)a2 = v10;
        *((_OWORD *)a2 + 1) = v11;
        a2 += 8;
        if ((double *)((char *)a2 - *result) == (double *)4096)
        {
          int v13 = (double *)result[1];
          ++result;
          a2 = v13;
        }
      }
    }
  }
  return result;
}

void sub_10017C278(uint64_t a1, uint64_t a2, void **a3, void **a4, void **a5, uint64_t a6)
{
  long long v8 = *a3;
  uint64_t v9 = *a4;
  long long v10 = *a5;
  if (*(char *)(a6 + 23) < 0)
  {
    sub_1000DC48C(v11, *(void **)a6, *(void *)(a6 + 8));
  }
  else
  {
    *(_OWORD *)long long v11 = *(_OWORD *)a6;
    uint64_t v12 = *(void *)(a6 + 16);
  }
  if (*(char *)(a6 + 47) < 0)
  {
    sub_1000DC48C(&__p, *(void **)(a6 + 24), *(void *)(a6 + 32));
  }
  else
  {
    long long __p = *(_OWORD *)(a6 + 24);
    uint64_t v14 = *(void *)(a6 + 40);
  }
  uint64_t v15 = *(void *)(a6 + 48);
  sub_1001956E0(a2, v8, v9, v10, (uint64_t)v11);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_10017C358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10017C384(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_10017C6FC(a1, a2);
    long long v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_10017C3E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017C3FC(void **a1, unint64_t a2)
{
  long long v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_1001D7FD4();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    double v6 = (char *)sub_1000DA54C(v3, a2);
    long long v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    long long v10 = (char *)*a1;
    long long v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t sub_10017C4A4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493) {
      sub_1001D7FD4();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_10017EA6C(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 56 * v6;
    sub_10017C5B4(a1, v7);
    return sub_10017F1CC((uint64_t)v7);
  }
  return result;
}

void sub_10017C550(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10017F1CC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10017C564(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 56)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

uint64_t sub_10017C5B4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10017E254((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_10017C62C(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10017C564((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *sub_10017C680(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10022F168(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_10017C6E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10017C6FC(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_1001D7FD4();
  }
  uint64_t result = (char *)sub_10017EA34((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void sub_10017C740(uint64_t *a1)
{
  if (*a1)
  {
    sub_1000D7FCC(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t *sub_10017C77C(uint64_t a1, int *a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v4 = *a2;
  while (1)
  {
    int v5 = *((_DWORD *)v3 + 7);
    if (v4 >= v5) {
      break;
    }
    uint64_t v2 = v3;
LABEL_7:
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      return v2;
    }
  }
  if (v5 < v4)
  {
    ++v3;
    goto LABEL_7;
  }
  uint64_t v7 = (uint64_t *)*v3;
  uint64_t result = v3;
  if (*v3)
  {
    uint64_t result = v3;
    do
    {
      int v8 = *((_DWORD *)v7 + 7);
      BOOL v9 = v8 < v4;
      if (v8 >= v4) {
        long long v10 = (uint64_t **)v7;
      }
      else {
        long long v10 = (uint64_t **)(v7 + 1);
      }
      if (!v9) {
        uint64_t result = v7;
      }
      uint64_t v7 = *v10;
    }
    while (*v10);
  }
  uint64_t v11 = v3[1];
  if (v11)
  {
    do
    {
      if (v4 >= *(_DWORD *)(v11 + 28)) {
        uint64_t v12 = (uint64_t *)(v11 + 8);
      }
      else {
        uint64_t v12 = (uint64_t *)v11;
      }
      uint64_t v11 = *v12;
    }
    while (*v12);
  }
  return result;
}

uint64_t sub_10017C814(uint64_t **a1, int *a2)
{
  uint64_t v3 = sub_10017C77C((uint64_t)a1, a2);
  if (v3 == v4) {
    return 0;
  }
  int v5 = v3;
  uint64_t v6 = v4;
  uint64_t v7 = 0;
  do
  {
    int v8 = sub_1000F0A30(a1, v5);
    operator delete(v5);
    ++v7;
    int v5 = v8;
  }
  while (v8 != v6);
  return v7;
}

uint64_t sub_10017C890(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_1000F0A30((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

__n128 sub_10017C90C@<Q0>(uint64_t a1@<X0>, _DWORD **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  BOOL v6 = (char *)operator new(0xC0uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *((_DWORD *)v6 + 7) = **a2;
  *((_DWORD *)v6 + 8) = 0xFFFF;
  *(void *)(v6 + 36) = 0;
  *(void *)(v6 + 44) = 0;
  *(_OWORD *)(v6 + 52) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(v6 + 68) = result;
  *(__n128 *)(v6 + 84) = result;
  *(__n128 *)(v6 + 100) = result;
  *((_DWORD *)v6 + 29) = 0;
  *((_DWORD *)v6 + 36) = 0;
  *((void *)v6 + 15) = 0xBFF0000000000000;
  *((void *)v6 + 16) = 0;
  *((void *)v6 + 17) = 0;
  *(void *)(v6 + 148) = 0xBFF0000000000000;
  *((_DWORD *)v6 + 39) = 0x7FFFFFFF;
  *((void *)v6 + 20) = 0;
  *((void *)v6 + 21) = 0;
  v6[184] = 0;
  *((void *)v6 + 22) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t *sub_10017C9B0(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    sub_1000EDF90(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *sub_10017CA70(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  BOOL v6 = (uint64_t **)sub_1001070AC((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    sub_100760024((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000EDF90(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_1007601D8((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_10017CB1C@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  BOOL v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = sub_10112FE94((uint64_t)v6 + 32, *a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_10017CB84(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1008B4750(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_10017CBA0(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  BOOL v6 = a1[1];
  unint64_t v8 = a1 + 1;
  BOOL v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        BOOL v6 = *v9;
        unint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        unint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v12 = operator new(0x30uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((void *)v12 + 5) = 0;
    char v15 = 1;
    sub_1000EDF90(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_100EA38A8((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

uint64_t sub_10017CC88(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = v2;
    }
    else {
      uint64_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  sub_1007E2518((uint64_t **)a1, v4);
  return 1;
}

double sub_10017CCF0(void *a1, double *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_10058D258(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  double result = *a2;
  *(double *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
  return result;
}

void *sub_10017CD78(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v3 = a2[4];
    uint64_t v4 = a2[1];
    if (a2[2] == v4)
    {
      uint64_t v5 = 0;
      uint64_t v8 = 0;
      uint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x17));
    }
    else
    {
      uint64_t v5 = *(void *)(v4 + 8 * (v3 / 0x17)) + 176 * (v3 % 0x17);
      unint64_t v6 = a2[5] + v3;
      uint64_t v7 = (void *)(v4 + 8 * (v6 / 0x17));
      uint64_t v8 = *v7 + 176 * (v6 % 0x17);
    }
    sub_10017CF88(a1, (uint64_t *)(v4 + 8 * (v3 / 0x17)), v5, v7, v8);
  }
  return a1;
}

__n128 sub_10017CE48(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 23 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10132EAE8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  uint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x17));
  unint64_t v9 = v7 % 0x17;
  uint64_t v10 = v8 + 176 * v9;
  *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
  uint64_t v11 = *(void *)(a2 + 24);
  *(void *)(v10 + 16) = *(void *)(a2 + 16);
  *(void *)(v10 + 24) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = v8 + 176 * v9;
  *(void *)(v12 + 32) = off_10232A710;
  long long v13 = *(_OWORD *)(a2 + 40);
  long long v14 = *(_OWORD *)(a2 + 56);
  long long v15 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v12 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(v12 + 72) = v15;
  *(_OWORD *)(v12 + 56) = v14;
  *(_OWORD *)(v12 + 40) = v13;
  __n128 result = *(__n128 *)(a2 + 104);
  long long v17 = *(_OWORD *)(a2 + 120);
  long long v18 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(v12 + 148) = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(v12 + 136) = v18;
  *(_OWORD *)(v12 + 120) = v17;
  *(__n128 *)(v12 + 104) = result;
  *(_WORD *)(v12 + 168) = *(_WORD *)(a2 + 168);
  ++a1[5];
  return result;
}

void *sub_10017CF88(void *a1, uint64_t *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 23 * (a4 - a2) + 0x2E8BA2E8BA2E8BA3 * ((a5 - *a4) >> 4) - 0x2E8BA2E8BA2E8BA3 * ((a3 - *a2) >> 4);
  }
  return sub_10017CFEC(a1, a2, a3, v5);
}

void *sub_10017CFEC(void *a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v8 = a1[5];
  if (v8 >= a4)
  {
    unint64_t v15 = a1[4];
    uint64_t v16 = a1[1];
    long long v17 = (uint64_t *)(v16 + 8 * (v15 / 0x17));
    if (a1[2] == v16) {
      unint64_t v18 = 0;
    }
    else {
      unint64_t v18 = *v17 + 176 * (v15 % 0x17);
    }
    __int16 v22 = a2;
    uint64_t v23 = a3;
    sub_100174054(&v22, a4);
    __int16 v20 = v22;
    uint64_t v21 = v23;
    __int16 v22 = v17;
    uint64_t v23 = v18;
    sub_100028D50(a2, a3, v20, v21, (uint64_t)&v22);
    return (void *)sub_100EA2B10((uint64_t)a1, v22, v23);
  }
  else
  {
    __int16 v22 = a2;
    uint64_t v23 = a3;
    sub_100174054(&v22, v8);
    unint64_t v9 = v22;
    uint64_t v10 = v23;
    unint64_t v11 = a1[4];
    uint64_t v12 = a1[1];
    long long v13 = (uint64_t *)(v12 + 8 * (v11 / 0x17));
    if (a1[2] == v12) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = *v13 + 176 * (v11 % 0x17);
    }
    __int16 v22 = v13;
    uint64_t v23 = v14;
    sub_100028D50(a2, a3, v9, v10, (uint64_t)&v22);
    return sub_10017D158(a1, v9, v10, a4 - a1[5]);
  }
}

void *sub_10017D158(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 23 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100EA2CFC(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  long long v13 = (void *)(v8 + 8 * (v11 / 0x17));
  if (v9 == v8) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *v13 + 176 * (v11 % 0x17);
  }
  long long v30 = (void *)(v8 + 8 * (v11 / 0x17));
  unint64_t v31 = v14;
  __n128 result = sub_100174054(&v30, a4);
  uint64_t v16 = v31;
  if (v14 != v31)
  {
    long long v17 = v30;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4048;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        unint64_t v19 = v14 + 32;
        unint64_t v20 = v14;
        do
        {
          *(_OWORD *)unint64_t v20 = *(_OWORD *)a3;
          *(void *)(v20 + 16) = *(void *)(a3 + 16);
          uint64_t v21 = *(void *)(a3 + 24);
          *(void *)(v20 + 24) = v21;
          if (v21) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 16), 1uLL, memory_order_relaxed);
          }
          *(void *)(v20 + 32) = off_10232A710;
          long long v22 = *(_OWORD *)(a3 + 40);
          long long v23 = *(_OWORD *)(a3 + 56);
          long long v24 = *(_OWORD *)(a3 + 72);
          *(_OWORD *)(v20 + 88) = *(_OWORD *)(a3 + 88);
          *(_OWORD *)(v20 + 72) = v24;
          *(_OWORD *)(v20 + 56) = v23;
          *(_OWORD *)(v20 + 40) = v22;
          long long v25 = *(_OWORD *)(a3 + 104);
          long long v26 = *(_OWORD *)(a3 + 120);
          long long v27 = *(_OWORD *)(a3 + 136);
          *(_OWORD *)(v20 + 148) = *(_OWORD *)(a3 + 148);
          *(_OWORD *)(v20 + 136) = v27;
          *(_OWORD *)(v20 + 120) = v26;
          *(_OWORD *)(v20 + 104) = v25;
          *(_WORD *)(v20 + 168) = *(_WORD *)(a3 + 168);
          a3 += 176;
          if (a3 - *a2 == 4048)
          {
            uint64_t v28 = a2[1];
            ++a2;
            a3 = v28;
          }
          v19 += 176;
          v20 += 176;
        }
        while (v20 != v18);
      }
      a1[5] += 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v18 - v14) >> 4);
      if (v13 == v17) {
        break;
      }
      unint64_t v29 = v13[1];
      ++v13;
      unint64_t v14 = v29;
    }
    while (v29 != v16);
  }
  return result;
}

__n128 sub_10017D36C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 28 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10068EA88(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x1C)) + 144 * (v7 % 0x1C);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  long long v9 = *(_OWORD *)(a2 + 16);
  long long v10 = *(_OWORD *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v8 + 64) = v11;
  *(_OWORD *)(v8 + 16) = v9;
  *(_OWORD *)(v8 + 32) = v10;
  __n128 result = *(__n128 *)(a2 + 80);
  long long v13 = *(_OWORD *)(a2 + 96);
  long long v14 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v8 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v8 + 128) = v14;
  *(__n128 *)(v8 + 80) = result;
  *(_OWORD *)(v8 + 96) = v13;
  ++a1[5];
  return result;
}

uint64_t sub_10017D440(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x1C) {
    a2 = 1;
  }
  if (v2 < 0x38) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 28;
  }
  return v4 ^ 1u;
}

uint64_t sub_10017D4A0(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 8 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100EA32C4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v7 & 0x3F) << 6));
  long long v9 = *a2;
  long long v10 = a2[1];
  long long v11 = a2[3];
  v8[2] = a2[2];
  void v8[3] = v11;
  *unint64_t v8 = v9;
  v8[1] = v10;
  uint64_t v12 = a1[4];
  uint64_t v13 = a1[5] + 1;
  a1[5] = v13;
  unint64_t v14 = v12 + v13;
  uint64_t v15 = a1[1];
  uint64_t v16 = (void *)(v15 + 8 * (v14 >> 6));
  uint64_t v17 = *v16 + ((v14 & 0x3F) << 6);
  if (a1[2] == v15) {
    uint64_t v17 = 0;
  }
  if (v17 == *v16) {
    uint64_t v17 = *(v16 - 1) + 4096;
  }
  return v17 - 64;
}

uint64_t sub_10017D570(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x19) {
    a2 = 1;
  }
  if (v2 < 0x32) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 25;
  }
  return v4 ^ 1u;
}

void sub_10017D5D0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x19;
  unint64_t v4 = v2 - 25;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFA0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFA0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  double v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  float v53 = operator new(0xFA0uLL);
  sub_1000DA434(&v54, &v53);
  long long v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  unint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_10017D89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10017D8E8(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 102 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x66) {
    a2 = 1;
  }
  if (v5 < 0xCC) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

__n128 sub_10017D960(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 2 * (v4 - v5) + ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100D42CC0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x11)) + 232 * (v7 % 0x11);
  long long v9 = *a2;
  long long v10 = a2[2];
  *(_OWORD *)(v8 + 16) = a2[1];
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)unint64_t v8 = v9;
  long long v11 = a2[3];
  long long v12 = a2[4];
  long long v13 = a2[6];
  *(_OWORD *)(v8 + 80) = a2[5];
  *(_OWORD *)(v8 + 96) = v13;
  *(_OWORD *)(v8 + 48) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  long long v14 = a2[7];
  long long v15 = a2[8];
  long long v16 = a2[10];
  *(_OWORD *)(v8 + 144) = a2[9];
  *(_OWORD *)(v8 + 160) = v16;
  *(_OWORD *)(v8 + 112) = v14;
  *(_OWORD *)(v8 + 128) = v15;
  __n128 result = (__n128)a2[11];
  long long v18 = a2[12];
  long long v19 = a2[13];
  *(void *)(v8 + 224) = *((void *)a2 + 28);
  *(_OWORD *)(v8 + 192) = v18;
  *(_OWORD *)(v8 + 208) = v19;
  *(__n128 *)(v8 + 176) = result;
  ++a1[5];
  return result;
}

__n128 sub_10017DA48(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 102 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10144C9C4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *(void *)(v8 + 32) = *(void *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

void sub_10017DB00(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x10;
  unint64_t v4 = v2 - 16;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    long long v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1400uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1400uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  double v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  float v53 = operator new(0x1400uLL);
  sub_1000DA434(&v54, &v53);
  long long v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  unint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_10017DDCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10017DE18(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 8 * (v2 - v3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x40) {
    a2 = 1;
  }
  if (v5 < 0x80) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t sub_10017DE88(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 16 * (v2 - v3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x80) {
    a2 = 1;
  }
  if (v5 < 0x100) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

__n128 sub_10017DEF8(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 26 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100DCE7C4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x1A)) + 156 * (v7 % 0x1A);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  long long v10 = *(_OWORD *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v12 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v8 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 80) = v12;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = v11;
  __n128 result = *(__n128 *)(a2 + 96);
  long long v14 = *(_OWORD *)(a2 + 112);
  long long v15 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v8 + 140) = *(_OWORD *)(a2 + 140);
  *(_OWORD *)(v8 + 112) = v14;
  *(_OWORD *)(v8 + 128) = v15;
  *(__n128 *)(v8 + 96) = result;
  ++a1[5];
  return result;
}

int64x2_t sub_10017DFD0(uint64_t a1, long long *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_1013F13D0((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x1A));
  uint64_t v7 = *v6 + 156 * (v4 % 0x1A);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4056;
  }
  long long v8 = *a2;
  *(_OWORD *)(v7 - 140) = a2[1];
  *(_OWORD *)(v7 - 156) = v8;
  long long v9 = a2[2];
  long long v10 = a2[3];
  long long v11 = a2[4];
  *(_OWORD *)(v7 - 76) = a2[5];
  *(_OWORD *)(v7 - 92) = v11;
  *(_OWORD *)(v7 - 108) = v10;
  *(_OWORD *)(v7 - 124) = v9;
  long long v12 = a2[6];
  long long v13 = a2[7];
  long long v14 = a2[8];
  *(_OWORD *)(v7 - 16) = *(long long *)((char *)a2 + 140);
  *(_OWORD *)(v7 - 28) = v14;
  *(_OWORD *)(v7 - 44) = v13;
  *(_OWORD *)(v7 - 60) = v12;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_101D1F270);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

uint64_t sub_10017E0A8(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x40) {
    a2 = 1;
  }
  if (v2 < 0x80) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 64;
  }
  return v4 ^ 1u;
}

uint64_t sub_10017E108(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 26 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x1A) {
    a2 = 1;
  }
  if (v5 < 0x34) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t sub_10017E180(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_10017E314(a1 + 8, a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a3 + 40);
  return a1;
}

char *sub_10017E1D8(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  sub_100006280(__dst + 24, a3);
  return __dst;
}

void sub_10017E238(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10017E254(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      long long v10 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(unsigned char *)(v8 - 8) = *(unsigned char *)(a3 - 8);
      v8 -= 56;
      v7 -= 56;
      a3 -= 56;
    }
    while (a3 != a5);
    *((void *)&v16 + 1) = v8;
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_10017E590((uint64_t)v13);
  return v11;
}

uint64_t sub_10017E314(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_1006B9168((_OWORD *)a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10017E354(_Unwind_Exception *a1)
{
  sub_1000F5BB0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10017E36C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(CLConnectionMessage **)a3;
  long long v5 = *(std::__shared_weak_count **)(a3 + 8);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t v7 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  CFDictionaryRef DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(v6, v7);
  id v9 = [[DictionaryOfClasses objectForKeyedSubscript:@"kCLConnectionMessageSubscribeKey"] BOOLValue];
  long long v10 = *(void (**)(void *, id, void *))a1;
  uint64_t v11 = *(void *)(a1 + 8);
  long long v12 = (void *)(a2 + (v11 >> 1));
  if (v11) {
    long long v10 = *(void (**)(void *, id, void *))(*v12 + v10);
  }
  v10(v12, v9, DictionaryOfClasses);
  if (v5)
  {
    sub_1000DB0A0(v5);
  }
}

void sub_10017E45C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1000DB0A0(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017E474(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  sub_10017BC9C(a1, a2, (CLConnectionMessage **)&v3);
  if (*((void *)&v3 + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&v3 + 1));
  }
}

void sub_10017E4B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017E4D0(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v3 = *a2;
  long long v4 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  sub_10002AC60(a1, v3, (uint64_t)&v4);
  if (*((void *)&v4 + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&v4 + 1));
  }
}

void sub_10017E518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10017E530(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v3 = *a2;
  long long v4 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  sub_10002AED8(a1, v3, (uint64_t)&v4);
  if (*((void *)&v4 + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&v4 + 1));
  }
}

void sub_10017E578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10017E590(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_101455A08(a1);
  }
  return a1;
}

double *sub_10017E5C8(double *result, double *a2, double *a3, double *a4, double *a5)
{
  double v5 = *result;
  float v6 = *result;
  float v7 = *a2;
  BOOL v8 = v6 <= v7;
  if (v6 <= v7) {
    double v9 = *a2;
  }
  else {
    double v9 = *result;
  }
  if (!v8) {
    double v5 = *a2;
  }
  *a2 = v5;
  *int64x2_t result = v9;
  double v10 = *a4;
  float v11 = *a4;
  float v12 = *a5;
  BOOL v13 = v11 <= v12;
  if (v11 <= v12) {
    double v14 = *a5;
  }
  else {
    double v14 = *a4;
  }
  if (!v13) {
    double v10 = *a5;
  }
  *a5 = v10;
  *a4 = v14;
  double v15 = *a5;
  float v16 = *a5;
  float v17 = *a3;
  BOOL v18 = v16 <= v17;
  if (v16 <= v17) {
    double v19 = *a3;
  }
  else {
    double v19 = *a5;
  }
  if (!v18) {
    double v15 = *a3;
  }
  *a5 = v15;
  float v20 = v19;
  float v21 = *a4;
  BOOL v22 = v20 <= v21;
  if (v20 <= v21) {
    double v23 = *a4;
  }
  else {
    double v23 = *a3;
  }
  *a3 = v23;
  if (!v22) {
    double v19 = *a4;
  }
  *a4 = v19;
  double v24 = *a2;
  float v25 = *a2;
  float v26 = *a5;
  BOOL v27 = v25 <= v26;
  if (v25 <= v26) {
    double v28 = *a5;
  }
  else {
    double v28 = *a2;
  }
  if (!v27) {
    double v24 = *a5;
  }
  *a5 = v24;
  *a2 = v28;
  double v29 = *a4;
  float v30 = *a4;
  float v31 = *result;
  BOOL v32 = v30 <= v31;
  if (v30 <= v31) {
    double v33 = *result;
  }
  else {
    double v33 = *a4;
  }
  if (!v32) {
    double v29 = *result;
  }
  *a4 = v29;
  float v34 = v33;
  float v35 = *a3;
  BOOL v36 = v34 <= v35;
  if (v34 <= v35) {
    double v37 = *a3;
  }
  else {
    double v37 = *result;
  }
  *int64x2_t result = v37;
  if (!v36) {
    double v33 = *a3;
  }
  *a3 = v33;
  double v38 = *a4;
  float v39 = *a4;
  float v40 = *a2;
  BOOL v41 = v39 <= v40;
  if (v39 <= v40) {
    double v42 = *a2;
  }
  else {
    double v42 = *a4;
  }
  if (!v41) {
    double v38 = *a2;
  }
  *a4 = v38;
  float v43 = v42;
  float v44 = *a3;
  BOOL v45 = v43 <= v44;
  if (v43 <= v44) {
    double v46 = *a3;
  }
  else {
    double v46 = *a2;
  }
  *a2 = v46;
  if (!v45) {
    double v42 = *a3;
  }
  *a3 = v42;
  return result;
}

char *sub_10017E710@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  float v6 = a4;
  if (__src != a3)
  {
    double v9 = __src;
    float v6 = a4 + 1;
    double v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 5 >= v11 >> 5 ? v11 >> 5 : (a3 - v9) >> 5;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 32 * v12);
      }
      v9 += 32 * v12;
      if (v9 == a3) {
        break;
      }
      BOOL v13 = (char *)*v6++;
      double v10 = v13;
      __dst = v13;
    }
    __dst += 32 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst) {
      __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

char *sub_10017E7D0@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  float v6 = a4;
  if (__src != a3)
  {
    double v9 = __src;
    float v6 = a4 + 1;
    double v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 6 >= v11 >> 6 ? v11 >> 6 : (a3 - v9) >> 6;
      if (v12) {
        __src = (char *)memmove(__dst, v9, v12 << 6);
      }
      v9 += 64 * v12;
      if (v9 == a3) {
        break;
      }
      BOOL v13 = (char *)*v6++;
      double v10 = v13;
      __dst = v13;
    }
    __dst += 64 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst) {
      __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

void sub_10017E894(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void sub_10017E8B0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void *sub_10017E8E4(void *a1, void **a2, void **a3, void **a4, uint64_t a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022C9878;
  sub_10017C278((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_10017E94C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_10017E960(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022B2330;
  CLConnectionMessage::CLConnectionMessage();
  return a1;
}

void sub_10017E9AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_10017E9C0(void *a1, char *__s)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022B2330;
  sub_10000DCD8((int)&v4, a1 + 24, __s);
  return a1;
}

void sub_10017EA20(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_10017EA34(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_1001D7FA0();
  }
  return operator new(4 * a2);
}

void *sub_10017EA6C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_1001D7FA0();
  }
  return operator new(56 * a2);
}

void *sub_10017EAB8(unint64_t a1)
{
  if (a1 >> 59) {
    sub_1001D7FA0();
  }
  return operator new(32 * a1);
}

void *sub_10017EAF0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    sub_1001D7FA0();
  }
  return operator new(a2 << 6);
}

void *sub_10017EB28(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x155555555555556) {
    sub_1001D7FA0();
  }
  return operator new(192 * a2);
}

void *sub_10017EB70(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCDLL) {
    sub_1001D7FA0();
  }
  return operator new(320 * a2);
}

void *sub_10017EBB8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1745D1745D1745ELL) {
    sub_1001D7FA0();
  }
  return operator new(176 * a2);
}

double sub_10017EC04(void *a1, unsigned char *a2, unsigned char **a3, unsigned char *a4, uint64_t a5)
{
  char v7 = *(void ***)a5;
  BOOL v8 = *(char **)(a5 + 8);
  if (a1 != a3)
  {
    double v10 = a1 + 1;
    for (uint64_t i = (unsigned char *)(*a1 + 4080); ; uint64_t i = v12 + 4080)
    {
      sub_1001802B4(a2, v8, i, v7, &v14);
      BOOL v8 = (char *)*((void *)&v15 + 1);
      char v7 = (void **)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      uint64_t v12 = (unsigned char *)*v10++;
      a2 = v12;
    }
    a2 = *a3;
  }
  sub_1001802B4(a2, v8, a4, v7, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

double sub_10017EC98(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    double v10 = __src;
  }
  else
  {
    BOOL v8 = a1 + 1;
    sub_10017E710(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      double v9 = *v8++;
      sub_10017E710(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    double v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }
  sub_10017E710(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

double sub_10017ED68(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    double v10 = __src;
  }
  else
  {
    BOOL v8 = a1 + 1;
    sub_10017E7D0(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      double v9 = *v8++;
      sub_10017E7D0(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    double v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }
  sub_10017E7D0(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

double *sub_10017EE38(double *result, double *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v3 = 0;
      char v4 = result;
      do
      {
        double v6 = *v4;
        double v5 = v4[1];
        char v4 = v2;
        float v7 = v5;
        float v8 = v6;
        if (v7 > v8)
        {
          uint64_t v9 = v3;
          while (1)
          {
            *(double *)((char *)result + v9 + 8) = v6;
            if (!v9) {
              break;
            }
            double v6 = *(double *)((char *)result + v9 - 8);
            float v10 = v6;
            v9 -= 8;
            if (v7 <= v10)
            {
              uint64_t v11 = (double *)((char *)result + v9 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v11 = result;
LABEL_10:
          *uint64_t v11 = v5;
        }
        uint64_t v2 = v4 + 1;
        v3 += 8;
      }
      while (v4 + 1 != a2);
    }
  }
  return result;
}

__n128 sub_10017EEB8@<Q0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xA0uLL);
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = off_1022FFB60;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((void *)v2 + 3) = off_10232A710;
  __asm { FMOV            V0.2D, #-1.0 }
  *((__n128 *)v2 + 2) = result;
  *((void *)v2 + 8) = 0xBFF0000000000000;
  *((void *)v2 + 10) = 0xBFF0000000000000;
  *(__n128 *)(v2 + 104) = result;
  *(__n128 *)(v2 + 120) = result;
  *((void *)v2 + 17) = 0xBFF0000000000000;
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_10017EF58(void **a1@<X1>, void **a2@<X2>, void **a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  float v10 = operator new(0x140uLL);
  sub_10017E8E4(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_10017FD68((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_10017EFD8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10017EFEC@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x70uLL);
  __n128 result = sub_10017E960(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_10017F03C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10017F050@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  char v4 = operator new(0x70uLL);
  __n128 result = sub_10017E9C0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10017F0A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10017F0B4(void *a1, void *a2)
{
  double v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  double v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    float v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      double v19 = (char *)sub_1000DA54C(v4, v18);
      float v21 = &v19[8 * (v18 >> 2)];
      BOOL v22 = (uint64_t *)a1[1];
      double v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        double v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        float v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)float v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      BOOL v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        double v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      long long v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        double v6 = (char *)a1[1];
      }
      float v17 = &v6[8 * v13];
      double v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)double v6 = *a2;
  a1[2] += 8;
}

uint64_t sub_10017F1CC(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10017F204(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 56;
      *(void *)(a1 + 16) = v2 - 56;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_10017F25C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100100330(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_10089DA1C(a1, i + 2, i + 2);
  return a1;
}

void sub_10017F2BC(_Unwind_Exception *a1)
{
  sub_1000D7D80(v1);
  _Unwind_Resume(a1);
}

void *sub_10017F2D4(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t *sub_10017F3C0(void *a1, void *a2)
{
  __n128 result = sub_10017F2D4(a1, a2);
  if (result)
  {
    sub_10017FB70(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

unsigned __int8 *sub_10017F3F8(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  sub_1010AC34C(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100100330(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  sub_1010AC3F0((uint64_t)v26, 0);
  return i;
}

void sub_10017F67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1010AC3F0((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_10017F694(uint64_t a1, unsigned __int8 *a2, long long *a3, long long *a4)
{
  unint64_t v9 = (void *)(a1 + 24);
  unint64_t v10 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = v10;
      if (v10 >= v12) {
        unint64_t v4 = v10 % v12;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v10;
    }
    long long v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4) {
            break;
          }
        }
      }
    }
  }
  sub_10017F920(a1, v11, a3, a4, (uint64_t)v27);
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_100100330(a1, v23);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
      else {
        unint64_t v4 = v11;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v11;
    }
  }
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)v27[0] = *v24;
    *unint64_t v24 = v27[0];
  }
  else
  {
    *(void *)v27[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v27[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v27[0])
    {
      unint64_t v25 = *(void *)(*(void *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12) {
          v25 %= v12;
        }
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v25) = v27[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  sub_10017FCC0((uint64_t)v27, 0);
  return i;
}

void sub_10017F908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10017FCC0((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

char *sub_10017F920@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, long long *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  unint64_t v10 = operator new(0x78uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *(void *)unint64_t v10 = 0;
  *((void *)v10 + 1) = a2;
  __n128 result = sub_10017E1D8((char *)v10 + 16, a3, a4);
  *(unsigned char *)(a5 + 16) = 1;
  return result;
}

void sub_10017F990(_Unwind_Exception *a1)
{
  sub_10017FCC0(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10017F9A8(uint64_t a1)
{
  sub_10001F3A0(a1, *(void **)(a1 + 16));
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10017F9E4(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_10017FBF0(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void *sub_10017FA3C@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint8x8_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint8x8_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t sub_10017FB70(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10017FA3C(a1, a2, (uint64_t)&__p);
  int8x8_t v3 = __p;
  long long __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

uint64_t sub_10017FBB4(uint64_t a1)
{
  sub_10017FBF0(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10017FBF0(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      int8x8_t v3 = (void *)*v2;
      unint64_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        sub_1000DB0A0(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_10017FC38(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_10017FCC0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100C6488C((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t sub_10017FD18(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1001AB2CC(result);
    operator delete();
  }
  return result;
}

void sub_10017FD68(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    unint64_t v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      uint8x8_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        unint64_t v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        sub_1000DB0A0(v5);
      }
    }
  }
}

void sub_10017FDF0(int a1, void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void *sub_10017FE34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = operator new(0x30uLL);
  *unint64_t v7 = a2;
  v7[1] = a3;
  unint64_t v8 = v7 + 2;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_1000DC48C(v8, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v8 = *(_OWORD *)a4;
    v7[4] = *(void *)(a4 + 16);
  }
  void v7[5] = *(void *)(a4 + 24);
  return v7;
}

void sub_10017FEA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

long long *sub_10017FEB8(long long *result, uint64_t *a2)
{
  uint64_t v2 = *((void *)result + 2);
  *((void *)result + 2) = a2[2];
  a2[2] = v2;
  long long v3 = *result;
  *uint64_t result = *(_OWORD *)a2;
  *(_OWORD *)a2 = v3;
  if (*((void *)result + 2))
  {
    **((void **)result + 1) = result;
    unint64_t v4 = *(long long **)result;
  }
  else
  {
    *(void *)uint64_t result = result;
    unint64_t v4 = result;
  }
  *((void *)v4 + 1) = result;
  if (a2[2])
  {
    *(void *)a2[1] = a2;
    uint8x8_t v5 = (uint64_t *)*a2;
  }
  else
  {
    *a2 = (uint64_t)a2;
    uint8x8_t v5 = a2;
  }
  v5[1] = (uint64_t)a2;
  return result;
}

void sub_10017FF2C(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    long long v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint8x8_t v5 = (uint64_t *)v3[1];
        uint8x8_t v6 = (std::__shared_weak_count *)v3[3];
        if (v6) {
          sub_1000DB0A0(v6);
        }
        operator delete(v3);
        long long v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_10017FFA4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void sub_10017FFAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10017FFB4(uint64_t a1, uint64_t a2, long long *a3)
{
}

void sub_10017FFBC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void sub_10017FFC4(uint64_t a1, unsigned __int8 *a2)
{
}

id sub_10017FFD4(uint64_t a1)
{
  id v1 = [[[*(id **)(a1 + 8)) vendor] proxyForService:@"CLClientManager"];

  return [v1 syncgetNonSystemLocationClientKeys];
}

uint64_t sub_100180010(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_1001A34E0(v2, 7, (uint64_t)&v4);
}

uint64_t sub_100180044(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_1001A34E0(v2, 6, (uint64_t)&v4);
}

uint64_t sub_100180078(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_1001A34E0(v2, 4, (uint64_t)&v4);
}

BOOL sub_1001800AC(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  int v3 = *(_DWORD *)(a2 + 20);
  if (v3 != 256 && v3 != 512) {
    return v3 != 4096;
  }
  return result;
}

BOOL sub_1001800E8(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 20);
  return v2 == 256 || v2 == 4096 || v2 == 512;
}

uint64_t sub_10018011C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_1001A34E0(v2, 2, (uint64_t)&v4);
}

void sub_100180150(uint64_t a1, uint64_t *a2, long long *a3)
{
}

void sub_100180158(uint64_t a1, uint64_t *a2, long long *a3)
{
}

uint64_t sub_100180160(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_10018016C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_100180178(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_100180184(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  int v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

std::logic_error *sub_1001801AC(std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  return result;
}

uint64_t sub_1001801E0(uint64_t a1, uint64_t a2)
{
  sub_10019397C(*(void *)a1, a2);
  uint64_t v5 = *(void *)(a2 + 76);
  int v6 = *(_DWORD *)(*(void *)a1 + 4);
  if (v6 == 2) {
    int v7 = 1;
  }
  else {
    int v7 = 2 * (v6 == 1);
  }
  int v8 = *(_DWORD *)(a1 + 8);
  if (v8 != v7) {
    sub_1004B608C(v4, v8, v7);
  }
  *(_DWORD *)(a1 + 8) = v7;
  return v5;
}

uint64_t sub_100180260(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10015E48C();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

void *sub_1001802B4@<X0>(unsigned char *__src@<X1>, char *__dst@<X4>, unsigned char *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
  int v6 = a4;
  int v7 = __src;
  if (__src == a3)
  {
    unint64_t v9 = __src;
  }
  else
  {
    unint64_t v9 = a3;
    int v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - __dst + 4080) >> 3);
      unint64_t v12 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3);
      if (v12) {
        BOOL result = memmove(__dst, v7, 40 * v12);
      }
      v7 += 40 * v12;
      if (v7 == v9) {
        break;
      }
      unint64_t v14 = (char *)*v6++;
      uint64_t v10 = v14;
      __dst = v14;
    }
    __dst += 40 * v12;
    if ((char *)*(v6 - 1) + 4080 == __dst) {
      __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = v9;
  a5[1] = v6;
  a5[2] = __dst;
  return result;
}

uint64_t sub_1001803A0(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    sub_101ABA308();
  }
  if ((a2 & 0x80000000) != 0) {
    sub_101ABA334();
  }
  if (*(_DWORD *)(a1 + 16) <= (signed int)a2) {
    sub_101ABA360();
  }
  return *(void *)(v2 + 8 * a2);
}

double sub_1001803DC(uint64_t a1, double *a2)
{
  double v2 = *(double *)(a1 + 16);
  if (v2 > 0.0) {
    return *a2 - v2;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_10232A7E8);
  }
  char v4 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#Error,ProviderLoc,getAge called while MCT not set", buf, 2u);
  }
  double v3 = -1.0;
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_10232A7E8);
    }
    int v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual CFTimeInterval cllcf::LCFusionProviderLocation::getAge(const CFTimeInterval &) const", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  return v3;
}

void sub_10018058C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_100180598(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 128) < 0xFu) & (0x20Eu >> *(_DWORD *)(a1 + 128));
}

BOOL sub_1001805B4(void *a1, double *a2)
{
  uint64_t v2 = a1[5];
  if (!v2) {
    return 0;
  }
  if (*a2 >= 0.0)
  {
    unint64_t v7 = v2 + a1[4] - 1;
    uint64_t v8 = *(void *)(a1[1] + 8 * (v7 / 0x1C));
    uint64_t v9 = sub_10016BA10();
    int v12 = 1;
    double v10 = sub_10016BA54(v9, &v12);
    double v11 = *(double *)(v8 + 144 * (v7 % 0x1C));
    if (v11 < 0.0 || v10 >= v11 && v10 - v11 > *a2) {
      return 0;
    }
  }
  unint64_t v5 = a1[5] + a1[4] - 1;
  return *(unsigned char *)(*(void *)(a1[1] + 8 * (v5 / 0x1C)) + 144 * (v5 % 0x1C) + 56) != 0;
}

BOOL sub_1001806D4(uint64_t a1)
{
  return *(double *)(a1 + 80) >= 0.0 && *(_DWORD *)(a1 + 96) && (CLMotionActivity::isTypePedestrian() & 1) != 0;
}

BOOL sub_100180714(uint64_t a1)
{
  return *(double *)(a1 + 80) >= 0.0 && *(_DWORD *)(a1 + 96) && (CLMotionActivity::isTypeCycling() & 1) != 0;
}

BOOL sub_100180754(void *a1, _OWORD *a2)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    double v3 = (_OWORD *)(*(void *)(a1[1] + 8 * ((v2 + a1[4] - 1) / 0x1CuLL)) + 144 * ((v2 + a1[4] - 1) % 0x1CuLL));
    long long v4 = v3[4];
    long long v6 = v3[1];
    long long v5 = v3[2];
    a2[3] = v3[3];
    a2[4] = v4;
    a2[1] = v6;
    a2[2] = v5;
    long long v7 = v3[8];
    long long v9 = v3[5];
    long long v8 = v3[6];
    a2[7] = v3[7];
    a2[8] = v7;
    a2[5] = v9;
    a2[6] = v8;
    *a2 = *v3;
  }
  return v2 != 0;
}

BOOL sub_1001807D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 96) = 0;
  *(void *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 112) = 0;
  *(void *)(a3 + 136) = 0;
  *(void *)(a3 + 144) = 0;
  *(void *)(a3 + 128) = 0;
  *(unsigned char *)(a3 + 152) = 0;
  *(_DWORD *)a3 = 0xFFFF;
  *(void *)(a3 + 12) = 0;
  *(void *)(a3 + 4) = 0;
  *(_OWORD *)(a3 + 20) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a3 + 36) = _Q0;
  *(_OWORD *)(a3 + 52) = _Q0;
  *(_OWORD *)(a3 + 68) = _Q0;
  *(_DWORD *)(a3 + 84) = 0;
  *(void *)(a3 + 88) = 0xBFF0000000000000;
  *(void *)(a3 + 116) = 0xBFF0000000000000;
  *(_DWORD *)(a3 + 124) = 0x7FFFFFFF;
  int v8 = *(_DWORD *)(a2 + 128);
  if (!v8)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v11 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#Error,convertFusedLocationToCLDaemonLocation,fused location type is Unknown", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1)
    {
LABEL_18:
      uint8x8_t v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::convertFusedLocationToCLDaemonLocation(const LCFusionProviderLocation &, CLDaemonLocation &) const", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
      return 0;
    }
LABEL_21:
    dispatch_once(&qword_102419510, &stru_1022FFA18);
    goto LABEL_18;
  }
  double v9 = *(double *)(a2 + 40);
  if (v9 > 0.0)
  {
    *(_DWORD *)(a3 + 96) = v8;
    *(void *)(a3 + 76) = *(void *)(a2 + 8);
    *(_OWORD *)(a3 + 4) = *(_OWORD *)(a2 + 24);
    *(double *)(a3 + 20) = v9;
    *(_OWORD *)(a3 + 28) = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a3 + 44) = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a3 + 60) = *(_OWORD *)(a2 + 96);
    *(_DWORD *)(a3 + 84) = *(_DWORD *)(a2 + 120);
    *(void *)(a3 + 88) = *(void *)(a2 + 112);
    BOOL result = 1;
    *(_DWORD *)(a3 + 132) = 1;
    return result;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  int v12 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#Error,convertFusedLocationToCLDaemonLocation,get fused location failed,hunc <= 0", buf, 2u);
  }
  BOOL result = sub_10013D1A0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  return result;
}

void sub_100180B34(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

BOOL sub_100180B40(uint64_t a1, int a2)
{
  if (a2 - 1) < 0xB && ((0x7EFu >> (a2 - 1))) {
    return 1;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  double v3 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    int v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#fusion,unsupported location,type,%{public}d", buf, 8u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::isLocationTypeSupported(CLLocationType) const", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
    return 0;
  }
  return result;
}

void sub_100180D0C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

BOOL sub_100180D18(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a1 + 2160) - 3) >= 2)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v10 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "#Error,get fused location failed, Fusion is not in the running state", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_26;
    }
LABEL_39:
    dispatch_once(&qword_102419510, &stru_1022FFA18);
LABEL_26:
    uint8x8_t v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::getFusedLocation(CLDaemonLocation &) const", "%s\n", v13);
LABEL_36:
    if (v13 != (char *)buf) {
      free(v13);
    }
    return 0;
  }
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 128) = 0;
  *(unsigned char *)(a2 + 152) = 0;
  *(_DWORD *)a2 = 0xFFFF;
  *(void *)(a2 + 12) = 0;
  *(void *)(a2 + 4) = 0;
  *(_OWORD *)(a2 + 20) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 36) = _Q0;
  *(_OWORD *)(a2 + 52) = _Q0;
  *(_OWORD *)(a2 + 68) = _Q0;
  *(_DWORD *)(a2 + 84) = 0;
  *(void *)(a2 + 88) = 0xBFF0000000000000;
  *(void *)(a2 + 116) = 0xBFF0000000000000;
  *(_DWORD *)(a2 + 124) = 0x7FFFFFFF;
  if (!*(_DWORD *)(a1 + 1096))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v11 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#Error,getFusedLocation,fused location type is Unknown", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_26;
    }
    goto LABEL_39;
  }
  if (*(double *)(a1 + 1008) <= 0.0)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v12 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#Error,getFusedLocation,get fused location: failed, hunc <= 0", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_26;
    }
    goto LABEL_39;
  }
  if (sub_1001807D0(a1, a1 + 968, a2))
  {
    *(_DWORD *)a2 = *(_DWORD *)a1;
    *(void *)(a2 + 124) = *(void *)(a1 + 124);
    *(_OWORD *)(a2 + 100) = *(_OWORD *)(a1 + 100);
    *(void *)(a2 + 116) = *(void *)(a1 + 116);
    *(void *)(a2 + 136) = *(void *)(a1 + 136);
    *(unsigned char *)(a2 + 152) = *(unsigned char *)(a1 + 152);
    BOOL result = 1;
    *(_DWORD *)(a2 + 132) = 1;
    return result;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  unint64_t v14 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "#fusion,getFusedLocation,failed to convert to daemon location", buf, 2u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint8x8_t v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::getFusedLocation(CLDaemonLocation &) const", "%s\n", v13);
    goto LABEL_36;
  }
  return result;
}

void sub_1001812D4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_1001812E0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t sub_1001812E8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1001812F0(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_35;
  }
  if ((*(unsigned char *)(a1 + 36) & 1) == 0)
  {
    LODWORD(v4) = 0;
    if ((*(unsigned char *)(a1 + 36) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v6 = *(void *)(a1 + 8);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    char v8 = v7;
    uint64_t v9 = *(void *)(v6 + 8);
    if ((v7 & 0x80u) == 0) {
      unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      uint64_t v9 = *(void *)(v6 + 8);
      int v3 = *(_DWORD *)(a1 + 36);
      char v8 = *(unsigned char *)(v6 + 23);
    }
    else
    {
      int v11 = 1;
    }
    if (v8 < 0) {
      int v7 = v9;
    }
    LODWORD(v4) = v4 + v11 + v7 + 1;
    goto LABEL_22;
  }
  long long v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v5 & 0x80000000) != 0)
  {
    LODWORD(v4) = 11;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v5 >= 0x80)
    {
      LODWORD(v4) = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
      if ((v3 & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    LODWORD(v4) = 2;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_22:
  if ((v3 & 4) != 0) {
    uint64_t v4 = (v4 + 5);
  }
  else {
    uint64_t v4 = v4;
  }
  if ((v3 & 8) != 0)
  {
    uint64_t v12 = *(void *)(a1 + 24);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    char v14 = v13;
    uint64_t v15 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16 >= 0x80)
    {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16, a2);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      uint64_t v15 = *(void *)(v12 + 8);
      char v14 = *(unsigned char *)(v12 + 23);
    }
    else
    {
      int v17 = 1;
    }
    if (v14 < 0) {
      int v13 = v15;
    }
    uint64_t v4 = (v4 + v17 + v13 + 1);
  }
LABEL_35:
  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

uint64_t sub_10018142C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_100181434(uint64_t a1, unsigned int a2)
{
  if (!*(unsigned char *)(a1 + 28))
  {
    uint64_t v3 = 0;
    goto LABEL_18;
  }
  if ((*(unsigned char *)(a1 + 28) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_10248AF50 + 8);
  }
  long long v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100181968(v4, a2);
  int v6 = (int)v5;
  if (v5 >= 0x80) {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
  }
  else {
    int v7 = 1;
  }
  uint64_t v3 = (v6 + v7 + 1);
  if ((*(_DWORD *)(a1 + 28) & 2) != 0)
  {
LABEL_12:
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_10248AF50 + 16);
    }
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1003EF7D4(v8, a2);
    int v11 = (int)v9;
    if (v9 >= 0x80) {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, v10);
    }
    else {
      int v12 = 1;
    }
    uint64_t v3 = (v3 + v11 + v12 + 1);
  }
LABEL_18:
  *(_DWORD *)(a1 + 24) = v3;
  return v3;
}

uint64_t sub_100181508(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (!v4) {
      uint64_t v4 = *(void *)(qword_10248AF20 + 8);
    }
    long long v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100181E74(v4, a2);
    int v7 = (int)v5;
    if (v5 >= 0x80) {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, v6);
    }
    else {
      int v8 = 1;
    }
    uint64_t result = (v7 + v8 + 1);
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

uint64_t sub_100181578(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 20))
  {
    uint64_t v5 = *(void *)(result + 8);
    if (!v5) {
      uint64_t v5 = *(void *)(qword_10248AF20 + 8);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, v5, a2, a4);
  }
  return result;
}

uint64_t sub_1001815A4(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8, a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(unsigned char *)(v4 + 23);
    }
    else
    {
      int v9 = 2;
    }
    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

uint64_t sub_100181624(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return result;
}

uint64_t sub_100181640(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[15];
  if ((_BYTE)v3)
  {
    unsigned int v4 = ((int)(v3 << 31) >> 31) & 9;
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if ((v3 & 8) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x10) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x20) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x40) != 0) {
      uint64_t v5 = v4 + 9;
    }
    else {
      uint64_t v5 = v4;
    }
    if ((v3 & 0x80) != 0)
    {
      char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[9];
      if ((v6 & 0x80000000) != 0)
      {
        int v7 = 11;
      }
      else if (v6 >= 0x80)
      {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        unsigned int v3 = a1[15];
      }
      else
      {
        int v7 = 2;
      }
      uint64_t v5 = (v7 + v5);
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  if ((v3 & 0xFF00) != 0)
  {
    if ((v3 & 0x100) != 0)
    {
      unint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[12];
      if ((v8 & 0x80000000) != 0)
      {
        int v9 = 11;
      }
      else if (v8 >= 0x80)
      {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
        unsigned int v3 = a1[15];
      }
      else
      {
        int v9 = 2;
      }
      uint64_t v5 = (v9 + v5);
    }
    if ((v3 & 0x200) != 0)
    {
      int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[13];
      if ((v10 & 0x80000000) != 0)
      {
        int v11 = 11;
      }
      else if (v10 >= 0x80)
      {
        int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
      }
      else
      {
        int v11 = 2;
      }
      uint64_t v5 = (v11 + v5);
    }
  }
  a1[14] = v5;
  return v5;
}

uint64_t sub_100181770(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v4 = 11;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_19;
    }
  }
  char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 11;
  }
  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_19:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_10248AF48 + 16);
    }
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100181434(v8, a2);
    int v11 = (int)v9;
    if (v9 >= 0x80) {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, v10);
    }
    else {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v11 + v12 + 1);
  }
LABEL_26:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_10018186C(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v4 = 11;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_19;
    }
  }
  char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 11;
  }
  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_19:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_10248AF18 + 16);
    }
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100181508(v8, a2);
    int v11 = (int)v9;
    if (v9 >= 0x80) {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, v10);
    }
    else {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v11 + v12 + 1);
  }
LABEL_26:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_100181968(uint64_t a1, unsigned int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 32);
  if (*(unsigned char *)(a1 + 32))
  {
    unsigned int v4 = (v3 << 31 >> 31) & 9;
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = *(void *)(a1 + 16);
      if (!v5) {
        uint64_t v5 = *(void *)(qword_102489D90 + 16);
      }
      char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100181B78(v5, a2);
      int v8 = (int)v6;
      if (v6 >= 0x80) {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, v7);
      }
      else {
        int v9 = 1;
      }
      v4 += v8 + v9 + 1;
      int v3 = *(_DWORD *)(a1 + 32);
    }
    if ((v3 & 4) != 0) {
      uint64_t result = v4 + 2;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 28) = result;
  return result;
}

uint64_t sub_100181A04(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 28))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v4 = 11;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_19;
    }
  }
  char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 11;
  }
  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_19:
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_10248AEF0 + 16);
    }
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1001815A4(v8, a2);
    int v11 = (int)v9;
    if (v9 >= 0x80) {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, v10);
    }
    else {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v11 + v12 + 1);
  }
LABEL_26:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

uint64_t sub_100181B00(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        unsigned int v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 20);
      }
      else
      {
        unsigned int v4 = 2;
      }
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      uint64_t result = v4 + 2;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

uint64_t sub_100181B78(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 92);
  if (!(_BYTE)v3)
  {
    uint64_t v5 = 0;
    goto LABEL_42;
  }
  if ((v3 & 1) == 0)
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  char v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 10;
  }
  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
    int v3 = *(_DWORD *)(a1 + 92);
  }
  else
  {
    int v7 = 1;
  }
  int v4 = v7 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_12:
    uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v8 & 0x80000000) != 0)
    {
      int v9 = 10;
    }
    else if (v8 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
      int v3 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      int v9 = 1;
    }
    v4 += v9 + 1;
  }
LABEL_18:
  if ((v3 & 4) != 0)
  {
    unsigned int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v10 & 0x80000000) != 0)
    {
      int v11 = 10;
    }
    else if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
      int v3 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      int v11 = 1;
    }
    v4 += v11 + 1;
    if ((v3 & 8) == 0) {
      goto LABEL_33;
    }
    goto LABEL_27;
  }
  if ((v3 & 8) != 0)
  {
LABEL_27:
    int v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if ((v12 & 0x80000000) != 0)
    {
      int v13 = 10;
    }
    else if (v12 >= 0x80)
    {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2);
      int v3 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      int v13 = 1;
    }
    v4 += v13 + 1;
  }
LABEL_33:
  unsigned int v14 = v4 + 2;
  if ((v3 & 0x10) == 0) {
    unsigned int v14 = v4;
  }
  if ((v3 & 0x20) != 0) {
    v14 += 5;
  }
  if ((v3 & 0x40) != 0) {
    v14 += 9;
  }
  if ((v3 & 0x80) != 0) {
    uint64_t v5 = v14 + 2;
  }
  else {
    uint64_t v5 = v14;
  }
LABEL_42:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_99;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 48);
    if ((v15 & 0x80000000) != 0)
    {
      int v16 = 11;
    }
    else if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      int v16 = 2;
    }
    LODWORD(v5) = v16 + v5;
  }
  unsigned int v17 = v5 + 9;
  if ((v3 & 0x200) == 0) {
    unsigned int v17 = v5;
  }
  if ((v3 & 0x400) != 0) {
    uint64_t v5 = v17 + 9;
  }
  else {
    uint64_t v5 = v17;
  }
  if ((v3 & 0x800) != 0)
  {
    float v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 52);
    if ((v18 & 0x80000000) != 0)
    {
      int v19 = 11;
    }
    else if (v18 >= 0x80)
    {
      int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v18, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      int v19 = 2;
    }
    uint64_t v5 = (v19 + v5);
    if ((v3 & 0x1000) == 0)
    {
LABEL_57:
      if ((v3 & 0x2000) == 0) {
        goto LABEL_58;
      }
      goto LABEL_73;
    }
  }
  else if ((v3 & 0x1000) == 0)
  {
    goto LABEL_57;
  }
  BOOL v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 72);
  if ((v20 & 0x80000000) != 0)
  {
    int v21 = 11;
  }
  else if (v20 >= 0x80)
  {
    int v21 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 92);
  }
  else
  {
    int v21 = 2;
  }
  uint64_t v5 = (v21 + v5);
  if ((v3 & 0x2000) == 0)
  {
LABEL_58:
    if ((v3 & 0x4000) == 0) {
      goto LABEL_59;
    }
    goto LABEL_83;
  }
LABEL_73:
  uint64_t v22 = *(void *)(a1 + 64);
  if (!v22) {
    uint64_t v22 = *(void *)(qword_102489D58 + 64);
  }
  int v23 = *(unsigned __int8 *)(v22 + 36);
  int v24 = (v23 << 31 >> 31) & 9;
  if ((v23 & 2) != 0) {
    v24 += 9;
  }
  if ((v23 & 4) != 0) {
    v24 += 9;
  }
  if (*(unsigned char *)(v22 + 36)) {
    int v25 = v24;
  }
  else {
    int v25 = 0;
  }
  *(_DWORD *)(v22 + 32) = v25;
  uint64_t v5 = (v5 + v25 + 2);
  int v3 = *(_DWORD *)(a1 + 92);
  if ((v3 & 0x4000) == 0)
  {
LABEL_59:
    if ((v3 & 0x8000) == 0) {
      goto LABEL_99;
    }
    goto LABEL_93;
  }
LABEL_83:
  uint64_t v26 = *(void *)(a1 + 80);
  if (!v26) {
    uint64_t v26 = *(void *)(qword_102489D58 + 80);
  }
  int v27 = *(unsigned __int8 *)(v26 + 36);
  int v28 = (v27 << 31 >> 31) & 9;
  if ((v27 & 2) != 0) {
    v28 += 9;
  }
  if ((v27 & 4) != 0) {
    v28 += 9;
  }
  if (*(unsigned char *)(v26 + 36)) {
    int v29 = v28;
  }
  else {
    int v29 = 0;
  }
  *(_DWORD *)(v26 + 32) = v29;
  uint64_t v5 = (v5 + v29 + 2);
  if ((*(_DWORD *)(a1 + 92) & 0x8000) != 0)
  {
LABEL_93:
    float v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 76);
    if ((v30 & 0x80000000) != 0)
    {
      int v31 = 12;
    }
    else if (v30 >= 0x80)
    {
      int v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30, a2) + 2;
    }
    else
    {
      int v31 = 3;
    }
    uint64_t v5 = (v31 + v5);
  }
LABEL_99:
  *(_DWORD *)(a1 + 88) = v5;
  return v5;
}

uint64_t sub_100181E74(uint64_t a1, unsigned int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 56);
  if (*(unsigned char *)(a1 + 56))
  {
    if ((v3 & 2) != 0) {
      int v4 = ((v3 << 31 >> 31) & 9) + 9;
    }
    else {
      int v4 = (v3 << 31 >> 31) & 9;
    }
    if ((v3 & 4) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
      if ((v5 & 0x80000000) != 0)
      {
        int v6 = 11;
      }
      else if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 56);
      }
      else
      {
        int v6 = 2;
      }
      v4 += v6;
    }
    if ((v3 & 8) != 0)
    {
      uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 28);
      if ((v8 & 0x80000000) != 0)
      {
        int v9 = 11;
      }
      else if (v8 >= 0x80)
      {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 56);
      }
      else
      {
        int v9 = 2;
      }
      v4 += v9;
    }
    if ((v3 & 0x10) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x20) != 0)
    {
      unsigned int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
      if ((v10 & 0x80000000) != 0)
      {
        int v11 = 11;
      }
      else if (v10 >= 0x80)
      {
        int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 56);
      }
      else
      {
        int v11 = 2;
      }
      v4 += v11;
    }
    unsigned int v12 = v4 + 2;
    if ((v3 & 0x40) == 0) {
      unsigned int v12 = v4;
    }
    if ((v3 & 0x80) != 0) {
      uint64_t result = v12 + 5;
    }
    else {
      uint64_t result = v12;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 52) = result;
  return result;
}

uint64_t sub_100181F80@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v3 = (uint64_t **)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16))(a1 + 56);
  sub_10019DAA8(v3[5], a2);
  return ((uint64_t (*)(uint64_t **))(*v3)[3])(v3);
}

void sub_100182018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

double sub_10018202C(uint64_t a1)
{
  return (sub_10016C458() - *(double *)(a1 + 32)) * 1000000.0;
}

BOOL sub_100182064(_DWORD *a1)
{
  return (*a1 - 7) < 0xFFFFFFFD;
}

uint64_t sub_100182078(uint64_t a1, int a2, unsigned int a3, double *a4)
{
  uint64_t v5 = a3;
  if (a3 < 8)
  {
    int v9 = sub_100182470(a1, a2);
    uint64_t result = 0;
    double v7 = dbl_101E0F6B8[v9] * dbl_101E0F6E8[2 * v5 + 1];
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_10232BC08);
    }
    int v6 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      uint64_t v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "CLOutdoorEstimator,lookupActivityStateProbabilityGivenOutdoor(),latent probability index out of bound,%lu", buf, 0xCu);
    }
    double v7 = -1.0;
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_10232BC08);
      }
      unsigned int v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "int32_t CLOutdoorEstimatorLookupTables::lookupActivityStateProbabilityGivenOutdoor(const CMMotionContext::MotionType, const CLSignalEnvironmentProvider_Type::SignalEnvironmentType, double &) const", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
    uint64_t result = 0xFFFFFFFFLL;
  }
  *a4 = v7;
  return result;
}

uint64_t sub_100182274(uint64_t a1, int a2, unsigned int a3, double *a4)
{
  uint64_t v5 = a3;
  if (a3 < 8)
  {
    int v9 = sub_100182470(a1, a2);
    uint64_t result = 0;
    double v7 = dbl_101E0F758[v9] * dbl_101E0F6E8[2 * v5 + 1];
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_10232BC08);
    }
    int v6 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      uint64_t v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "CLOutdoorEstimator,lookupActivityStateProbabilityGivenIndoor(),latent probability index out of bound,%lu", buf, 0xCu);
    }
    double v7 = -1.0;
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_10232BC08);
      }
      unsigned int v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "int32_t CLOutdoorEstimatorLookupTables::lookupActivityStateProbabilityGivenIndoor(const CMMotionContext::MotionType, const CLSignalEnvironmentProvider_Type::SignalEnvironmentType, double &) const", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
    uint64_t result = 0xFFFFFFFFLL;
  }
  *a4 = v7;
  return result;
}

uint64_t sub_100182470(uint64_t a1, int a2)
{
  if (a2 <= 127)
  {
    if (a2 > 31)
    {
      if (a2 != 32)
      {
        if (a2 == 64) {
          return 3;
        }
        return 0;
      }
    }
    else
    {
      if (a2 == 4) {
        return 1;
      }
      if (a2 != 16) {
        return 0;
      }
    }
    return 2;
  }
  if (a2 >= 0x2000)
  {
    if (a2 != 0x2000 && a2 != 12288 && a2 != 0x4000) {
      return 0;
    }
    return 5;
  }
  if (a2 == 128) {
    return 4;
  }
  if (a2 == 4096) {
    return 5;
  }
  return 0;
}

uint64_t sub_100182504(uint64_t a1)
{
  return a1 + 1032;
}

uint64_t sub_10018250C(uint64_t a1)
{
  return a1 + 2448;
}

uint64_t sub_100182514(uint64_t a1)
{
  return a1 + 680;
}

uint64_t sub_10018251C(uint64_t a1)
{
  return a1 + 2048;
}

uint64_t sub_100182524(uint64_t a1)
{
  return a1 + 1816;
}

BOOL sub_10018252C(void *a1)
{
  uint64_t v1 = a1[8];
  return v1
      && *(unsigned char *)(*(void *)(*(void *)(a1[4] + (((unint64_t)(v1 + a1[7] - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                              + 16 * (v1 + *((unsigned char *)a1 + 56) - 1))
                  + 24) == 0;
}

void *sub_100182574@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[8];
  if (v2
    && (unint64_t v3 = v2 + result[7] - 1,
        uint64_t v4 = *(void *)(result[4] + ((v3 >> 5) & 0x7FFFFFFFFFFFFF8)),
        uint64_t v5 = *(void *)(v4 + 16 * v3),
        !*(unsigned char *)(v5 + 24)))
  {
    uint64_t v6 = *(void *)(v4 + 16 * v3 + 8);
    *a2 = v5;
    a2[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

uint64_t sub_1001825D4(uint64_t a1, double *a2)
{
  if (*(_DWORD *)(a1 + 216) != 3) {
    return 0;
  }
  __int16 v11 = 0;
  *(_OWORD *)unsigned int v10 = xmmword_101D1E250;
  memset(&v10[2], 0, 135);
  long long v12 = xmmword_101D1E250;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  v16[0] = 0;
  *(void *)((char *)v16 + 5) = 0;
  *(void *)((char *)&v16[1] + 6) = 0;
  char v17 = 0;
  memset(&v16[3], 0, 24);
  long long v18 = xmmword_101D1E250;
  uint64_t v19 = 0;
  int v20 = 0;
  unint64_t v21 = 0xFFEFFFFFFFFFFFFFLL;
  int v32 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  int v27 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  memset(v31, 0, sizeof(v31));
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unint64_t v35 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v36 = 0;
  int v37 = 0;
  uint64_t v43 = 0;
  __int16 v44 = 0;
  int v49 = 0;
  int v42 = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v46 = 0u;
  long long v45 = 0u;
  char v47 = 0;
  memset(v48, 0, sizeof(v48));
  unint64_t v50 = 0xFFEFFFFFFFFFFFFFLL;
  long long v69 = 0u;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  long long v53 = 0u;
  long long v52 = 0u;
  long long v51 = 0u;
  uint64_t v70 = 0;
  unint64_t v71 = 0xFFEFFFFFFFFFFFFFLL;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  double v76 = -1.79769313e308;
  uint64_t v77 = 0;
  int v78 = 0;
  uint64_t v79 = 0;
  char v80 = 0;
  unint64_t v81 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v83 = 0;
  uint64_t v82 = 0;
  uint64_t v84 = 0x80000000800000;
  uint64_t v86 = 0;
  uint64_t v85 = 0;
  long long v87 = xmmword_101D1E260;
  uint64_t v88 = 0x80000000800000;
  long long v89 = 0u;
  long long v90 = 0u;
  uint64_t v91 = 0;
  unint64_t v92 = 0xFFEFFFFFFFFFFFFFLL;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  int v99 = 0;
  unint64_t v100 = 0xFFEFFFFFFFFFFFFFLL;
  __int16 v101 = 0;
  int v102 = 0;
  unint64_t v103 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v104 = 7;
  unint64_t v105 = 0xFFEFFFFFFFFFFFFFLL;
  char v106 = 0;
  uint64_t v108 = 0;
  uint64_t v107 = 0;
  uint64_t v109 = 0;
  uint64_t v4 = operator new(4uLL);
  long long __p = v4;
  *uint64_t v4 = 6;
  uint64_t v8 = v4 + 1;
  int v9 = v4 + 1;
  sub_100174478(a2, &__p, (uint64_t)v10);
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
  if (v76 == -1.79769313e308)
  {
    BOOL v5 = 0;
  }
  else
  {
    BOOL v5 = 1;
    if (v77 && v77 != 25) {
      BOOL v5 = v80 != 0;
    }
  }
  return vabdd_f64(CFAbsoluteTimeGetCurrent(), *(double *)(a1 + 48)) < 420.0 || v5;
}

void sub_1001828B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

uint64_t sub_1001828E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 128))();
}

BOOL sub_100182908(uint64_t a1, uint64_t a2, double a3)
{
  sub_100176CA0(v8, a2);
  int v5 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 96))(a1, v8);
  if (v8[32]) {
    sub_100178B14((uint64_t)v8);
  }
  if (v5)
  {
    sub_1011C5764(*(void *)(a1 + 64), 1, a3);
    return 0;
  }
  else
  {
    double v7 = *(double *)(a1 + 88);
    return v7 <= a3 || v7 == 1.79769313e308;
  }
}

void sub_1001829C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a14) {
    sub_100178B14((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001829DC(float a1)
{
  if (a1 <= 0.5) {
    return 1;
  }
  else {
    return 2;
  }
}

BOOL sub_1001829F0(uint64_t a1)
{
  return *(unsigned char *)(a1 + 113) && sub_100DF398C(a1);
}

void *sub_100182A04@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = (char *)[*(id *)(a1 + 24) clientAnchor];
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = "";
  }

  return sub_100134750(a2, v4);
}

uint64_t sub_100182A54()
{
  sub_100103240();

  return sub_1001073D0();
}

BOOL sub_100182A7C()
{
  return sub_1001198CC() == 1;
}

id sub_100182A9C(uint64_t a1)
{
  id v1 = [[objc_msgSend(*(id *)(a1 + 16), "vendor") proxyForService:@"CLNetworkLocationProvider"];

  return _[v1 syncgetIsBroadConnection];
}

uint64_t sub_100182AD4(uint64_t a1)
{
  return sub_100016E64(a1 + 80);
}

void sub_100182ADC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ([*(id *)(a1 + 152) indoord])
  {
    id v6 = objc_alloc((Class)CLGpsPosition);
    sub_100BCE8BC(v33, a3);
    id v7 = [v6 initWithLocation:a2 andPrivateLocation:v33];
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10231A1C8);
    }
    uint64_t v8 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (v7)
      {
        [v7 gpsLocation];
        uint64_t v9 = *(void *)((char *)v33 + 4);
        [v7 gpsLocation];
        uint64_t v10 = *(void *)&v18[12];
        [v7 gpsLocation];
        int v11 = v17;
      }
      else
      {
        int v11 = 0;
        uint64_t v10 = 0;
        uint64_t v9 = 0;
        memset(v33, 0, 156);
        *(_OWORD *)long long v18 = 0u;
        memset(v16, 0, 20);
      }
      *(_DWORD *)uint64_t buf = 134284033;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2049;
      *(void *)&unsigned char buf[14] = v10;
      *(_WORD *)&buf[22] = 1025;
      *(_DWORD *)&unsigned char buf[24] = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Notifying pipelined of a new outdoor location @ %{private}.6lf, %{private}.6lf, type, %{private}d", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(v33, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10231A1C8);
      }
      if (v7)
      {
        [v7 gpsLocation];
        uint64_t v12 = *(void *)&v18[4];
        [v7 gpsLocation];
        uint64_t v13 = *(void *)((char *)v16 + 12);
        [v7 gpsLocation];
        int v14 = v24;
      }
      else
      {
        int v14 = 0;
        uint64_t v13 = 0;
        uint64_t v12 = 0;
        long long v25 = 0u;
        memset(v26, 0, sizeof(v26));
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v20 = 0u;
        memset(buf, 0, sizeof(buf));
      }
      int v27 = 134284033;
      uint64_t v28 = v12;
      __int16 v29 = 2049;
      uint64_t v30 = v13;
      __int16 v31 = 1025;
      int v32 = v14;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLPipelineLocationProvider::sendOutdoorLocationToPipelined(const CLDaemonLocation &, const CLDaemonLocationPrivate &) const", "%s\n", v15);
      if (v15 != (char *)v33) {
        free(v15);
      }
    }
    [objc_msgSend(*(id *)(a1 + 152), "indoord") outdoorLocationAvailable:v7];
  }
}

double sub_100182E54()
{
  return 166.0;
}

uint64_t sub_100182E60(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 3508) - 1;
  if (v1 > 5) {
    return 0;
  }
  else {
    return dword_101D51530[v1];
  }
}

BOOL sub_100182E88(uint64_t a1, int32x2_t *a2)
{
  return *(unsigned char *)(a1 + 3528) && (uint64_t v2 = *(void *)(a1 + 3520)) != 0 && sub_100183FEC(v2, a2);
}

uint64_t sub_100182EA4(double *a1, uint64_t a2, double *a3)
{
  double v4 = a1[14];
  char v5 = v4 != -1.0;
  if (v4 != -1.0 && v4 > -1.79769313e308) {
    double v6 = a1[14];
  }
  else {
    double v6 = -1.79769313e308;
  }
  id v7 = *(_DWORD **)a2;
  uint64_t v8 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 != v8)
  {
    do
    {
      switch(*v7)
      {
        case 1:
          double v10 = *(double *)((*(uint64_t (**)(void))(**(void **)a1 + 104))() + 360);
          goto LABEL_20;
        case 2:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 120))();
          goto LABEL_19;
        case 3:
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)a1 + 112))();
          goto LABEL_15;
        case 4:
          double v10 = *(double *)((*(uint64_t (**)(void))(**(void **)a1 + 128))() + 104);
          goto LABEL_20;
        case 5:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 144))();
          goto LABEL_19;
        case 6:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 152))();
          goto LABEL_19;
        case 7:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 160))();
          goto LABEL_19;
        case 8:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 136))();
          goto LABEL_19;
        case 9:
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)a1 + 168))();
LABEL_15:
          double v10 = *(double *)(v12 + 136);
          goto LABEL_20;
        case 0xA:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 176))();
          goto LABEL_19;
        case 0xB:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 192))();
          goto LABEL_19;
        case 0xC:
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 200))();
LABEL_19:
          double v10 = *(double *)(v11 + 96);
LABEL_20:
          if (v10 != -1.0 && v10 > v6) {
            double v6 = v10;
          }
          v5 &= v10 != -1.0;
          break;
        default:
          break;
      }
      ++v7;
    }
    while (v7 != v8);
  }
  *a3 = v6;
  return v5 & 1;
}

void sub_100183190(int *a1)
{
  if (qword_102419430 != -1) {
    dispatch_once(&qword_102419430, &stru_102305C80);
  }
  uint64_t v2 = qword_102419438;
  if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *((unsigned __int8 *)a1 + 15);
    int v4 = *((unsigned __int8 *)a1 + 13);
    int v5 = *((unsigned __int8 *)a1 + 12);
    int v6 = a1[6];
    int v7 = *((unsigned __int8 *)a1 + 14);
    int v8 = *a1;
    uint64_t v9 = *((void *)a1 + 2);
    *(_DWORD *)uint64_t buf = 67241728;
    int v12 = v3;
    __int16 v13 = 1026;
    int v14 = v4;
    __int16 v15 = 1026;
    int v16 = v5;
    __int16 v17 = 1026;
    int v18 = v6;
    __int16 v19 = 1026;
    int v20 = v7;
    __int16 v21 = 1026;
    int v22 = v8;
    __int16 v23 = 2050;
    uint64_t v24 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLMM,AllowNetworkUsage,%{public}d,batterySaverMode,%{public}d,thermalVoteToAllow,%{public}d,signalEnv,%{public}d,isMapsForeground,%{public}d,thermalLevel,%{public}d,currentBatteryLevel,%{public}.2lf", buf, 0x30u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_102305C80);
    }
    double v10 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMapMatcherNetworkUsage::log() const", "%s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
}

uint64_t sub_1001833E4(uint64_t a1)
{
  double v2 = sub_10016C458();
  if (vabdd_f64(v2, *(double *)(a1 + 4608)) > 10.0) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 4650))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    int v5 = qword_1024193D8;
    uint64_t v3 = 1;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      int v6 = *(unsigned __int8 *)(a1 + 4650);
      double v7 = *(double *)(a1 + 4624);
      int v13 = 68289795;
      int v14 = 0;
      __int16 v15 = 2082;
      int v16 = "";
      __int16 v17 = 1026;
      int v18 = v6;
      __int16 v19 = 2049;
      double v20 = v7;
      __int16 v21 = 2049;
      double v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, TBA\", \"isTunnel\":%{public}d, \"lat\":\"%{private}.7f\", \"lon\":\"%{private}.7f\"}", (uint8_t *)&v13, 0x2Cu);
    }
  }
  else
  {
    double v8 = *(double *)(a1 + 11664);
    if (v8 <= 0.0) {
      return 0;
    }
    double v9 = vabdd_f64(v2, v8);
    BOOL v10 = *(unsigned char *)(a1 + 4648) && v9 < 10.0;
    if (!v10 || *(_DWORD *)(a1 + 11556) > 1u) {
      return 0;
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v11 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *(_DWORD *)(a1 + 11556);
      int v13 = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      int v16 = "";
      __int16 v17 = 1026;
      int v18 = v12;
      __int16 v19 = 2050;
      double v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssAssistancePosition,TBA,Current location close to tunnel\", \"gnssContent\":%{public}d, \"gnssContentAge\":\"%{public}.1f\"}", (uint8_t *)&v13, 0x22u);
    }
    return 1;
  }
  return v3;
}

BOOL sub_10018360C(uint64_t a1, double *a2)
{
  BOOL result = *a2 <= 3628972800.0 && *a2 >= 441763200.0;
  if (result || (byte_1024863EC & 1) == 0) {
    byte_1024863EC = !result;
  }
  return result;
}

uint64_t sub_10018364C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 41);
}

uint64_t sub_100183654(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 488))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023144B0);
    }
    double v2 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      int v3 = *(unsigned __int8 *)(a1 + 488);
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v12) = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "DEM,isUseOfDemInappropriate,true,fIsAirborne,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 == -1)
    {
LABEL_23:
      BOOL v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLDigitalElevationModel::isUseOfDemInappropriate() const", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
      return 1;
    }
LABEL_25:
    dispatch_once(&qword_1024193D0, &stru_1023144B0);
    goto LABEL_23;
  }
  if (*(double *)(a1 + 496) > 0.0)
  {
    double v5 = sub_10016C458();
    if (vabdd_f64(v5, *(double *)(a1 + 496)) < 10.0
      && (*(unsigned char *)(a1 + 538) || *(unsigned char *)(a1 + 539) || *(unsigned char *)(a1 + 536) || *(unsigned char *)(a1 + 537)))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1023144B0);
      }
      int v6 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = *(void *)(a1 + 496);
        uint64_t v8 = *(void *)(a1 + 512);
        uint64_t v9 = *(void *)(a1 + 520);
        *(_DWORD *)uint64_t buf = 134350081;
        double v12 = v5;
        __int16 v13 = 2050;
        uint64_t v14 = v7;
        __int16 v15 = 1026;
        int v16 = 1;
        __int16 v17 = 2049;
        uint64_t v18 = v8;
        __int16 v19 = 2049;
        uint64_t v20 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "DEM,isUseOfDemInappropriate,true,TBA,currentTime,%{public}.1lf,TBA machContinuousTime,%{public}.1lf,isCloseToOrAtTunnelBridge,%{public}d,lat,%{private}.8lf,lon,%{private}.8lf", buf, 0x30u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return 1;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 == -1) {
        goto LABEL_23;
      }
      goto LABEL_25;
    }
  }
  return 0;
}

void sub_1001839D0(uint64_t a1, uuid_t dst)
{
  if (*(_DWORD *)a1) {
    uuid_copy(dst, (const unsigned __int8 *)(a1 + 168));
  }
  else {
    uuid_clear(dst);
  }
}

BOOL sub_1001839F0()
{
  return sub_1001198CC() == 1;
}

id sub_100183A10(uint64_t a1)
{
  id v1 = [objc_msgSend(*(id *)(a1 + 16), "vendor") proxyForService:@"CLNetworkLocationProvider"];

  return _[v1 syncgetIsBroadConnection];
}

uint64_t sub_100183A48(uint64_t a1)
{
  sub_100103240();
  if (sub_10016CCBC()) {
    return (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 2) != 0
  }
         || ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 8) != 0)
        && *(unsigned char *)(a1 + 1696) != 0;
  sub_100103240();
  if (sub_1001B7C64()) {
    return (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 2) != 0
  }
         || ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 8) != 0)
        && *(unsigned char *)(a1 + 1696) != 0;
  sub_100103240();
  if (sub_10073CFB8()) {
    return (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 2) != 0
  }
         || ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 8) != 0)
        && *(unsigned char *)(a1 + 1696) != 0;
  sub_100103240();
  uint64_t result = sub_1000F08D4();
  if (result) {
    return (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 2) != 0
  }
         || ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56)) & 8) != 0)
        && *(unsigned char *)(a1 + 1696) != 0;
  return result;
}

BOOL sub_100183B04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(double *)(a3 + 16) == 0.0
      && *(_DWORD *)(a2 + 24) == *(_DWORD *)(a3 + 24)
      && *(double *)(a2 + 72) == *(double *)(a3 + 72)
      && *(_DWORD *)(a2 + 144) == *(_DWORD *)(a3 + 144)
      && *(_DWORD *)(a2 + 148) == *(_DWORD *)(a3 + 148)
      && *(double *)(a2 + 32) == *(double *)(a3 + 32)
      && *(double *)(a2 + 80) == *(double *)(a3 + 80);
}

double sub_100183B7C(uint64_t a1)
{
  long long v5 = 0u;
  long long v6 = 0u;
  memset(v4, 0, sizeof(v4));
  BOOL v1 = sub_100174F3C(*(void **)a1, (uint64_t)&v5, v4, *(double *)(a1 + 32) + 5.0);
  double result = -1.0;
  if (v1)
  {
    uint64_t v3 = *((void *)&v6 + 1);
    if (*((void *)&v6 + 1) == *(void *)v6) {
      uint64_t v3 = *(void *)(v6 - 8) + 4032;
    }
    return *(double *)(v3 - 192);
  }
  return result;
}

double sub_100183BE8(uint64_t a1)
{
  long long v5 = 0u;
  long long v6 = 0u;
  memset(v4, 0, sizeof(v4));
  BOOL v1 = sub_100174F3C(*(void **)a1, (uint64_t)&v5, v4, *(double *)(a1 + 24) + 5.0);
  double result = -1.0;
  if (v1)
  {
    uint64_t v3 = *((void *)&v6 + 1);
    if (*((void *)&v6 + 1) == *(void *)v6) {
      uint64_t v3 = *(void *)(v6 - 8) + 4032;
    }
    return *(double *)(v3 - 192);
  }
  return result;
}

double sub_100183C54(void **a1, double a2)
{
  double v2 = a2;
  uint64_t v6 = 0;
  if (!sub_100183D00(a2, (uint64_t)a1, *a1, (double *)&v6))
  {
    uint64_t v4 = (*a1)[8];
    if (v4) {
      return *(double *)(*(void *)((*a1)[4] + 8 * ((v4 + (*a1)[7] - 1) / 0x15uLL))
    }
                       + 192 * ((v4 + (*a1)[7] - 1) % 0x15uLL));
    else {
      return -1.79769313e308;
    }
  }
  return v2;
}

BOOL sub_100183D00(double a1, uint64_t a2, void *a3, double *a4)
{
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  BOOL result = sub_100174F3C(a3, (uint64_t)&v31, &v29, a1);
  if (result)
  {
    uint64_t v7 = *((void *)&v32 + 1);
    uint64_t v8 = *(void *)v32;
    uint64_t v9 = *((void *)&v32 + 1) - *(void *)v32;
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 6);
    unint64_t v11 = v10 - 1;
    if (v9 < 193)
    {
      uint64_t v15 = ((21 - v10) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v16 = v15 + ((21 - v10 - v15) >> 1);
      uint64_t v13 = *(void *)(v32 - 8 * (v16 >> 4));
      uint64_t v14 = v13 + 192 * (v10 - 21 + 21 * (v16 >> 4)) + 3840;
      if (v14 == *((void *)&v30 + 1)) {
        return 0;
      }
      unint64_t v12 = -(uint64_t)(v16 >> 4);
    }
    else
    {
      unint64_t v12 = v11 / 0x15;
      uint64_t v13 = *(void *)(v32 + 8 * (v11 / 0x15));
      uint64_t v14 = v13 + 192 * (v11 % 0x15);
      if (v14 == *((void *)&v30 + 1)) {
        return 0;
      }
    }
    if (v14 == v13) {
      uint64_t v14 = *(void *)(v32 + 8 * v12 - 8) + 4032;
    }
    if (*(double *)(v14 - 192) > a1) {
      return 0;
    }
    uint64_t v17 = *((void *)&v32 + 1);
    if (*((void *)&v32 + 1) == v8) {
      uint64_t v17 = *(void *)(v32 - 8) + 4032;
    }
    if (*(double *)(v17 - 192) <= a1) {
      return 0;
    }
    if (v9 < 193)
    {
      uint64_t v21 = ((21 - v10) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v22 = (v21 + ((21 - v10 - v21) >> 1)) >> 4;
      unint64_t v18 = -(uint64_t)v22;
      uint64_t v19 = *(void *)(v32 - 8 * v22);
      uint64_t v20 = v19 + 192 * (v10 - 21 + 21 * v22) + 3840;
    }
    else
    {
      unint64_t v18 = v11 / 0x15;
      uint64_t v19 = *(void *)(v32 + 8 * (v11 / 0x15));
      uint64_t v20 = v19 + 192 * (v11 % 0x15);
    }
    if (v20 == v19) {
      uint64_t v20 = *(void *)(v32 + 8 * v18 - 8) + 4032;
    }
    if (v9 < 193)
    {
      unint64_t v26 = 21 - v10;
      uint64_t v27 = ((21 - v10) * (unsigned __int128)0x8618618618618619) >> 64;
      unint64_t v28 = (v27 + ((v26 - v27) >> 1)) >> 4;
      unint64_t v23 = -(uint64_t)v28;
      uint64_t v24 = *(void *)(v32 - 8 * v28);
      uint64_t v25 = v24 + 192 * (21 * v28 - v26) + 3840;
    }
    else
    {
      unint64_t v23 = v11 / 0x15;
      uint64_t v24 = *(void *)(v32 + 8 * (v11 / 0x15));
      uint64_t v25 = v24 + 192 * (v11 % 0x15);
    }
    if (v25 == v24) {
      uint64_t v25 = *(void *)(v32 + 8 * v23 - 8) + 4032;
    }
    if (*((void *)&v32 + 1) == v8) {
      uint64_t v7 = *(void *)(v32 - 8) + 4032;
    }
    *a4 = sub_1001BF26C(*(double *)(v20 - 192), *(double *)(v25 - 144), *(double *)(v7 - 192), *(double *)(v7 - 144), a1);
    return 1;
  }
  return result;
}

BOOL sub_100183FC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(double *)(a3 + 32) <= *(double *)(a2 + 32);
}

uint64_t sub_100183FDC(uint64_t a1)
{
  return CLConnection::getName(*(CLConnection **)(a1 + 8));
}

uint64_t sub_100183FE4()
{
  return 0;
}

BOOL sub_100183FEC(uint64_t a1, int32x2_t *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 2232);
  if (*(unsigned char *)(a1 + 2232))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102345560);
    }
    long long v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a1 + 2160);
      uint64_t v7 = *(void *)(a1 + 2168);
      uint64_t v8 = *(void *)(a1 + 2184);
      uint64_t v9 = *(void *)(a1 + 2176);
      *(_DWORD *)uint64_t buf = 134349824;
      *(void *)uint64_t v27 = v6;
      *(_WORD *)&v27[8] = 2050;
      uint64_t v28 = v7;
      *(_WORD *)long long v29 = 2050;
      *(void *)&v29[2] = v8;
      __int16 v30 = 2050;
      uint64_t v31 = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "BaroAlt,DriftRate Data,closeLoopError,%{public}lf,durationSinceLastCalibEv,%{public}lf,distanceFromLastCalibEv,%{public}lf,estAltUnc,%{public}lf", buf, 0x2Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102345560);
      }
      uint64_t v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeter::getBarometricAltitudeAWDData(CLDaemonStats_Type::BarometricAltitudeDriftRateInfo &) const", "%s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
    a2->i32[0] = llround(*(double *)(a1 + 2160) * 10.0);
    unsigned int v10 = vcvtad_u64_f64(*(double *)(a1 + 2168));
    a2->i32[1] = v10;
    __asm { FMOV            V1.2D, #10.0 }
    a2[1] = vmovn_s64((int64x2_t)vcvtq_u64_f64(vrndaq_f64(vmulq_f64(*(float64x2_t *)(a1 + 2176), _Q1))));
    if (v10 >= 5 && *(_DWORD *)(a1 + 3744) <= v10)
    {
      *(_OWORD *)(a1 + 3740) = *(_OWORD *)a2->i8;
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102345560);
      }
      uint64_t v17 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        int v18 = *(_DWORD *)(a1 + 3740);
        int v19 = *(_DWORD *)(a1 + 3744);
        int v20 = *(_DWORD *)(a1 + 3752);
        int v21 = *(_DWORD *)(a1 + 3748);
        *(_DWORD *)uint64_t buf = 67240960;
        *(_DWORD *)uint64_t v27 = v18;
        *(_WORD *)&v27[4] = 1026;
        *(_DWORD *)&v27[6] = v19;
        LOWORD(v28) = 1026;
        *(_DWORD *)((char *)&v28 + 2) = v20;
        HIWORD(v28) = 1026;
        *(_DWORD *)long long v29 = v21;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "BaroAlt,DriftRate Core Analytics Data,closeLoopError,%{public}d,durationSinceLastCalibEv,%{public}d,distanceFromLastCalibEv,%{public}d,estAltUnc,%{public}d", buf, 0x1Au);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_102345560);
        }
        uint64_t v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeter::getBarometricAltitudeAWDData(CLDaemonStats_Type::BarometricAltitudeDriftRateInfo &) const", "%s\n", v25);
        if (v25 != (char *)buf) {
          free(v25);
        }
      }
      uint64_t v22 = sub_10071B604();
      sub_100726370(v22, (int *)(a1 + 3740));
    }
    *(unsigned char *)(a1 + 2232) = 0;
  }
  return v2 != 0;
}

uint64_t sub_10018440C(uint64_t a1, double a2)
{
  double v13 = a2;
  if (*(double *)(a1 + 3344) < 2.22044605e-16) {
    goto LABEL_8;
  }
  uint64_t v3 = *(void *)a1;
  if (!*(void *)a1) {
    goto LABEL_9;
  }
  double v4 = sub_1000A4CE8(*(void *)a1, &v13);
  double v5 = sub_1000A4F34(v4, *(double *)(a1 + 3344), 315360000.0);
  if (*(unsigned char *)(a1 + 276))
  {
    LODWORD(v6) = *(_DWORD *)(a1 + 272);
    double v7 = (double)v6;
  }
  else
  {
    double v7 = 259200.0;
  }
  if (v5 >= v7) {
LABEL_8:
  }
    uint64_t v3 = 1;
  else {
    uint64_t v3 = 0;
  }
LABEL_9:
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102345560);
  }
  uint64_t v8 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = *(void *)(a1 + 3344);
    *(_DWORD *)uint64_t buf = 134349568;
    uint64_t v21 = v9;
    __int16 v22 = 2050;
    double v23 = v13;
    __int16 v24 = 1026;
    int v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "BaroAlt,BiasStalenessCheck,Time,%{public}.3lf,machContNow,%{public}.3lf,isStale,%{public}d", buf, 0x1Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102345560);
    }
    uint64_t v11 = *(void *)(a1 + 3344);
    int v14 = 134349568;
    uint64_t v15 = v11;
    __int16 v16 = 2050;
    double v17 = v13;
    __int16 v18 = 1026;
    int v19 = v3;
    unint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLBarometricAltimeter::isBaroBiasHistoryStale(const CFTimeInterval) const", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  return v3;
}

double sub_10018466C(uint64_t a1)
{
  long long __p = 0;
  double v23 = 0;
  __int16 v24 = 0;
  sub_10017C3FC(&__p, 0x40uLL);
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v2 == v3)
  {
    unint64_t v6 = v23;
  }
  else
  {
    double v4 = v23;
    do
    {
      double v5 = *(float *)(v2 + 8);
      if (v4 >= (double *)v24)
      {
        double v7 = (double *)__p;
        uint64_t v8 = ((char *)v4 - (unsigned char *)__p) >> 3;
        unint64_t v9 = v8 + 1;
        if ((unint64_t)(v8 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v10 = v24 - (unsigned char *)__p;
        if ((v24 - (unsigned char *)__p) >> 2 > v9) {
          unint64_t v9 = v10 >> 2;
        }
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v9;
        }
        if (v11)
        {
          unint64_t v12 = (char *)sub_1000DA54C((uint64_t)&v24, v11);
          double v7 = (double *)__p;
          double v4 = v23;
        }
        else
        {
          unint64_t v12 = 0;
        }
        double v13 = (double *)&v12[8 * v8];
        *double v13 = v5;
        unint64_t v6 = v13 + 1;
        while (v4 != v7)
        {
          uint64_t v14 = *((void *)v4-- - 1);
          *((void *)v13-- - 1) = v14;
        }
        long long __p = v13;
        double v23 = v6;
        __int16 v24 = &v12[8 * v11];
        if (v7) {
          operator delete(v7);
        }
      }
      else
      {
        *double v4 = v5;
        unint64_t v6 = v4 + 1;
      }
      double v23 = v6;
      v2 += 16;
      double v4 = v6;
    }
    while (v2 != v3);
  }
  if (__p == v6)
  {
    double v20 = -1.0;
    if (!v6) {
      return v20;
    }
    goto LABEL_29;
  }
  sub_10017345C((double *)__p, v6, (uint64_t)&v25, 126 - 2 * __clz(((char *)v6 - (unsigned char *)__p) >> 3), 1);
  unint64_t v6 = (double *)__p;
  unint64_t v15 = ((char *)v23 - (unsigned char *)__p) >> 3;
  double v16 = 0.0;
  if (v15 >= 5) {
    unint64_t v15 = 5;
  }
  if (v15)
  {
    double v17 = (double *)__p;
    unint64_t v18 = v15;
    do
    {
      double v19 = *v17++;
      double v16 = v16 + v19;
      --v18;
    }
    while (v18);
  }
  double v20 = v16 / (double)v15;
  if (__p)
  {
LABEL_29:
    double v23 = v6;
    operator delete(v6);
  }
  return v20;
}

void sub_100184838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10018485C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 760) || sub_1000E6E34(a1 + 464)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 88)) {
    return 1;
  }
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_1022F2A90);
  }
  uint64_t v3 = qword_102419568;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v4)
  {
    sub_10012FD50(a1);
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    double v7 = "";
    __int16 v8 = 2050;
    uint64_t v9 = sub_10012FD50(a1);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#warning: Harvesting was turned off but we're still checking for active traces\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}", (uint8_t *)v5, 0x1Cu);
    return 0;
  }
  return result;
}

BOOL sub_100184990(uint64_t a1, double *a2, double a3, double a4)
{
  double v11 = 0.0;
  double v12 = 0.0;
  *a2 = 0.0;
  if (a3 <= a4)
  {
    if (a3 != a4)
    {
      BOOL result = sub_100174C74(a1, &v12, a3);
      if (!result) {
        return result;
      }
      BOOL result = sub_100174C74(a1, &v11, a4);
      if (!result) {
        return result;
      }
      *a2 = v11 - v12;
    }
    return 1;
  }
  if (qword_102419030 != -1) {
    dispatch_once(&qword_102419030, &stru_1022F3BA0);
  }
  __int16 v6 = qword_102419038;
  if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 134349312;
    double v18 = a3;
    __int16 v19 = 2050;
    double v20 = a4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Time rolled back! t1,%{public}f,t2,%{public}f", buf, 0x16u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_1022F3BA0);
    }
    int v13 = 134349312;
    double v14 = a3;
    __int16 v15 = 2050;
    double v16 = a4;
    __int16 v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLStepDistanceFusion::getOdometerDistance(CFAbsoluteTime, CFAbsoluteTime, double &) const", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
    return 0;
  }
  return result;
}

uint64_t sub_100184BB4(uint64_t a1)
{
  if (sub_100087E8C(a1)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 160) != 1) {
    return 0;
  }

  return CLMotionActivity::isTypeIndoorPedestrian();
}

BOOL sub_100184C14(double *a1)
{
  if (*a1 <= 0.0) {
    return 1;
  }
  double v2 = vabdd_f64(sub_10016C458(), *a1);
  uint64_t v3 = sub_100178B84((uint64_t)a1);
  if (v3 && v2 <= 86400.0)
  {
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_102328DC8);
    }
    BOOL v4 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349568;
      uint64_t v9 = v3;
      __int16 v10 = 2050;
      double v11 = v2;
      __int16 v12 = 2050;
      uint64_t v13 = 0x40F5180000000000;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "CLGMTPS,LOIs already exist,%{public}ld,and it's not time to refresh yet,%{public}.1lf,threshold,%{public}.1lf", buf, 0x20u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419430 == -1) {
        goto LABEL_20;
      }
      goto LABEL_23;
    }
    return result;
  }
  if (v2 > 3600.0) {
    return 1;
  }
  if (qword_102419430 != -1) {
    dispatch_once(&qword_102419430, &stru_102328DC8);
  }
  __int16 v6 = qword_102419438;
  if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134349568;
    uint64_t v9 = v3;
    __int16 v10 = 2050;
    double v11 = v2;
    __int16 v12 = 2050;
    uint64_t v13 = 0x40AC200000000000;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CLGMTPS,home work school LOIs does not exist,%{public}ld,but we recently requested,%{public}.1lf,need to wait,%{public}.1lf", buf, 0x20u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419430 == -1)
    {
LABEL_20:
      double v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLRoutineManagerInfo::shouldQueryLOI() const", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
      return 0;
    }
LABEL_23:
    dispatch_once(&qword_102419430, &stru_102328DC8);
    goto LABEL_20;
  }
  return result;
}

uint64_t sub_100184F74(uint64_t a1, _OWORD *a2)
{
  *a2 = 0u;
  a2[1] = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v8, &v6);
  if (result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4096;
      }
      long long v5 = *(_OWORD *)(v4 - 16);
      *a2 = *(_OWORD *)(v4 - 32);
      a2[1] = v5;
      return 1;
    }
  }
  return result;
}

uint64_t sub_100185018(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v7, &v5);
  if (result)
  {
    uint64_t v4 = *((void *)&v8 + 1);
    if (*((void *)&v8 + 1) == *((void *)&v6 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v8 == *((void *)&v8 + 1)) {
        uint64_t v4 = *(void *)(v8 - 8) + 4096;
      }
      *(_OWORD *)a2 = *(_OWORD *)(v4 - 16);
      return 1;
    }
  }
  return result;
}

BOOL sub_1001850BC(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = (void *)(v5 + 8 * (v4 >> 8));
  if (*(void *)(a1 + 40) == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 16 * v4;
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  double v11 = (uint64_t *)(v10 + 8 * (v9 >> 8));
  if (*(void *)(a1 + 40) == v10) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *v11 + 16 * v9;
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    uint64_t v16 = v12;
    double v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4096;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 16), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4096;
        }
        double v15 = v19;
        if (*(double *)(v20 - 16) == a4) {
          break;
        }
      }
      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        uint64_t v16 = v21 + 4096;
      }
      v16 -= 16;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }
    uint64_t v13 = a3[3];
  }
  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_1001851D8(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v8, &v6);
  if (result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4080;
      }
      long long v5 = *(_OWORD *)(v4 - 24);
      a2[2] = *(void *)(v4 - 8);
      *(_OWORD *)a2 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t sub_100185288(uint64_t a1, _OWORD *a2)
{
  *a2 = 0u;
  a2[1] = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v8, &v6);
  if (result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4096;
      }
      long long v5 = *(_OWORD *)(v4 - 16);
      *a2 = *(_OWORD *)(v4 - 32);
      a2[1] = v5;
      return 1;
    }
  }
  return result;
}

BOOL sub_10018532C(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = (void *)(v4 + 8 * (*(void *)(a1 + 56) >> 7));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *v5 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  long long v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = (uint64_t *)(v9 + 8 * (v8 >> 7));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *v10 + 32 * (v8 & 0x7F);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    uint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 4096;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 32), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 4096;
        }
        double v14 = v18;
        if (*(double *)(v19 - 32) == a4) {
          break;
        }
      }
      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 4096;
      }
      v15 -= 32;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }
    uint64_t v12 = a3[3];
  }
  return v12 != *(void *)(a2 + 24);
}

uint64_t sub_100185450(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v7, &v5);
  if (result)
  {
    uint64_t v4 = *((void *)&v8 + 1);
    if (*((void *)&v8 + 1) == *((void *)&v6 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v8 == *((void *)&v8 + 1)) {
        uint64_t v4 = *(void *)(v8 - 8) + 4096;
      }
      *(_OWORD *)a2 = *(_OWORD *)(v4 - 16);
      return 1;
    }
  }
  return result;
}

uint64_t sub_1001854F4(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v8, &v6);
  if (result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4080;
      }
      long long v5 = *(_OWORD *)(v4 - 24);
      a2[2] = *(void *)(v4 - 8);
      *(_OWORD *)a2 = v5;
      return 1;
    }
  }
  return result;
}

BOOL sub_1001855A4(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = (void *)(v5 + 8 * (v4 / 0xAA));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *v6 + 24 * (v4 % 0xAA);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 / 0xAA));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = *v11 + 24 * (v9 % 0xAA);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4080;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 24), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4080;
        }
        double v15 = v19;
        if (*(double *)(v20 - 24) == a4) {
          break;
        }
      }
      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4080;
      }
      v16 -= 24;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }
    uint64_t v13 = a3[3];
  }
  return v13 != *(void *)(a2 + 24);
}

BOOL sub_1001856E8(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(v4 + 8 * (*(void *)(a1 + 56) >> 4));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *v5 + 320 * (*(void *)(a1 + 56) & 0xFLL);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  long long v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = (uint64_t *)(v9 + 8 * (v8 >> 4));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *v10 + 320 * (v8 & 0xF);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    unint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 5120;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 320), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 5120;
        }
        double v14 = v18;
        if (*(double *)(v19 - 320) == a4) {
          break;
        }
      }
      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 5120;
      }
      v15 -= 320;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }
    uint64_t v12 = a3[3];
  }
  return v12 != *(void *)(a2 + 24);
}

uint64_t sub_100185820(uint64_t a1, _OWORD *a2)
{
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v10, &v8);
  if (result)
  {
    uint64_t v4 = *((void *)&v11 + 1);
    if (*((void *)&v11 + 1) == *((void *)&v9 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v11 == *((void *)&v11 + 1)) {
        uint64_t v4 = *(void *)(v11 - 8) + 4096;
      }
      long long v5 = *(_OWORD *)(v4 - 64);
      long long v6 = *(_OWORD *)(v4 - 48);
      long long v7 = *(_OWORD *)(v4 - 16);
      a2[2] = *(_OWORD *)(v4 - 32);
      a2[3] = v7;
      *a2 = v5;
      a2[1] = v6;
      return 1;
    }
  }
  return result;
}

BOOL sub_1001858D0(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = (void *)(v4 + 8 * (*(void *)(a1 + 56) >> 6));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *v5 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  long long v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  long long v10 = (uint64_t *)(v9 + 8 * (v8 >> 6));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *v10 + ((v8 & 0x3F) << 6);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    unint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 4096;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 56), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 4096;
        }
        double v14 = v18;
        if (*(double *)(v19 - 56) == a4) {
          break;
        }
      }
      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 4096;
      }
      v15 -= 64;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }
    uint64_t v12 = a3[3];
  }
  return v12 != *(void *)(a2 + 24);
}

uint64_t sub_1001859F4(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 160) = 0;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v15, &v13);
  if (result)
  {
    uint64_t v4 = *((void *)&v16 + 1);
    if (*((void *)&v16 + 1) == *((void *)&v14 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v16 == *((void *)&v16 + 1)) {
        uint64_t v4 = *(void *)(v16 - 8) + 4032;
      }
      long long v5 = *(_OWORD *)(v4 - 168);
      long long v6 = *(_OWORD *)(v4 - 136);
      *(_OWORD *)(a2 + 16) = *(_OWORD *)(v4 - 152);
      *(_OWORD *)(a2 + 32) = v6;
      *(_OWORD *)a2 = v5;
      long long v7 = *(_OWORD *)(v4 - 120);
      long long v8 = *(_OWORD *)(v4 - 104);
      long long v9 = *(_OWORD *)(v4 - 72);
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v4 - 88);
      *(_OWORD *)(a2 + 96) = v9;
      *(_OWORD *)(a2 + 48) = v7;
      *(_OWORD *)(a2 + 64) = v8;
      long long v10 = *(_OWORD *)(v4 - 56);
      long long v11 = *(_OWORD *)(v4 - 40);
      long long v12 = *(_OWORD *)(v4 - 24);
      *(void *)(a2 + 160) = *(void *)(v4 - 8);
      *(_OWORD *)(a2 + 128) = v11;
      *(_OWORD *)(a2 + 144) = v12;
      *(_OWORD *)(a2 + 112) = v10;
      return 1;
    }
  }
  return result;
}

BOOL sub_100185AEC(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = (void *)(v5 + 8 * (v4 / 0x18));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *v6 + 168 * (v4 % 0x18);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  long long v11 = (uint64_t *)(v10 + 8 * (v9 / 0x18));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = *v11 + 168 * (v9 % 0x18);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4032;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 168), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4032;
        }
        double v15 = v19;
        if (*(double *)(v20 - 168) == a4) {
          break;
        }
      }
      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4032;
      }
      v16 -= 168;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }
    uint64_t v13 = a3[3];
  }
  return v13 != *(void *)(a2 + 24);
}

BOOL sub_100185C30(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = (void *)(v5 + 8 * (v4 / 0x17));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *v6 + 176 * (v4 % 0x17);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  long long v11 = (uint64_t *)(v10 + 8 * (v9 / 0x17));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = *v11 + 176 * (v9 % 0x17);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4048;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 168), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4048;
        }
        double v15 = v19;
        if (*(double *)(v20 - 168) == a4) {
          break;
        }
      }
      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4048;
      }
      v16 -= 176;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }
    uint64_t v13 = a3[3];
  }
  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100185D8C(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 144) = 0;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, long long *, long long *))(*(void *)a1 + 16))(a1, &v14, &v12);
  if (result)
  {
    uint64_t v4 = *((void *)&v15 + 1);
    if (*((void *)&v15 + 1) == *((void *)&v13 + 1))
    {
      return 0;
    }
    else
    {
      if (*(void *)v15 == *((void *)&v15 + 1)) {
        uint64_t v4 = *(void *)(v15 - 8) + 3952;
      }
      long long v5 = *(_OWORD *)(v4 - 136);
      *(_OWORD *)a2 = *(_OWORD *)(v4 - 152);
      *(_OWORD *)(a2 + 16) = v5;
      long long v6 = *(_OWORD *)(v4 - 120);
      long long v7 = *(_OWORD *)(v4 - 104);
      long long v8 = *(_OWORD *)(v4 - 72);
      *(_OWORD *)(a2 + 64) = *(_OWORD *)(v4 - 88);
      *(_OWORD *)(a2 + 80) = v8;
      *(_OWORD *)(a2 + 32) = v6;
      *(_OWORD *)(a2 + 48) = v7;
      long long v9 = *(_OWORD *)(v4 - 56);
      long long v10 = *(_OWORD *)(v4 - 40);
      long long v11 = *(_OWORD *)(v4 - 24);
      *(void *)(a2 + 144) = *(void *)(v4 - 8);
      *(_OWORD *)(a2 + 112) = v10;
      *(_OWORD *)(a2 + 128) = v11;
      *(_OWORD *)(a2 + 96) = v9;
      return 1;
    }
  }
  return result;
}

BOOL sub_100185E7C(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = (void *)(v5 + 8 * (v4 / 0x1A));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *v6 + 152 * (v4 % 0x1A);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  long long v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  long long v11 = (uint64_t *)(v10 + 8 * (v9 / 0x1A));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = *v11 + 152 * (v9 % 0x1A);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 3952;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 112), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 3952;
        }
        double v15 = v19;
        if (*(double *)(v20 - 112) == a4) {
          break;
        }
      }
      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 3952;
      }
      v16 -= 152;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }
    uint64_t v13 = a3[3];
  }
  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100185FC8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

__n128 sub_100185FD0(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  long long v4 = a3[2];
  *(_OWORD *)(a2 + 16) = a3[1];
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)a2 = v3;
  long long v5 = a3[3];
  long long v6 = a3[4];
  long long v7 = a3[6];
  *(_OWORD *)(a2 + 80) = a3[5];
  *(_OWORD *)(a2 + 96) = v7;
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 64) = v6;
  __n128 result = (__n128)a3[7];
  long long v9 = a3[8];
  long long v10 = a3[10];
  *(_OWORD *)(a2 + 144) = a3[9];
  *(_OWORD *)(a2 + 160) = v10;
  *(__n128 *)(a2 + 112) = result;
  *(_OWORD *)(a2 + 128) = v9;
  return result;
}

BOOL sub_100186004(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 32)) {
    return 0;
  }
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 168))(v6);
  if (!*(unsigned char *)(a2 + 32)) {
    sub_10020D700();
  }
  if (*(_DWORD *)(a2 + 24) == 1) {
    long long v3 = sub_1006BCC18(v6, (unint64_t *)a2);
  }
  else {
    long long v3 = (void *)v6[3];
  }
  BOOL v4 = v3 != 0;
  sub_1000D7D80((uint64_t)v6);
  return v4;
}

void sub_1001860A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000D7D80((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001860BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10017F25C(a2, a1 + 144);
}

uint64_t sub_1001860C8(uint64_t a1)
{
  LODWORD(result) = (*(uint64_t (**)(void, double *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v2, *(double *)(a1 + 112));
  if (v2[1] == 0.0) {
    return 0;
  }
  else {
    return result;
  }
}

BOOL sub_100186124(const std::string *a1)
{
  return std::string::compare(a1 + 1, "Location in use on paired watch by 3rd party app") == 0;
}

BOOL sub_100186150(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 132) | 2) != 2) {
    return 1;
  }
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_1022BABA0);
  }
  long long v3 = qword_102419568;
  BOOL result = os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO);
  if (result)
  {
    uint64_t v5 = *(unsigned int *)(a2 + 132);
    v6[0] = 68289283;
    v6[1] = 0;
    __int16 v7 = 2082;
    long long v8 = "";
    __int16 v9 = 2049;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"WARN: location dropped due to referenceFrame\", \"referenceFrame\":%{private, location:CLClientLocationReferenceFrame}lld}", (uint8_t *)v6, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t sub_100186258(uint64_t a1)
{
  return (*(unsigned int *)(a1 + 664) < 0x39uLL) & (0x110000000000C20uLL >> *(_DWORD *)(a1 + 664));
}

uint64_t sub_100186278(uint64_t a1)
{
  return a1 + 664;
}

uint64_t sub_100186280(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))();
}

uint64_t sub_1001862A8(uint64_t a1)
{
  return a1 + 392;
}

uint64_t sub_1001862B0(uint64_t a1)
{
  return a1 + 528;
}

uint64_t sub_1001862B8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 185);
}

__n128 sub_1001862C0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 184);
  *(void *)(a2 + 32) = *(void *)(a1 + 216);
  __n128 result = *(__n128 *)(a1 + 200);
  *(__n128 *)(a2 + 16) = result;
  return result;
}

id sub_1001862DC(uint64_t a1)
{
  return [*(id *)(a1 + 48) count];
}

BOOL sub_1001862E4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 168) == 3;
}

uint64_t sub_1001862F4(uint64_t result, void *a2, int *a3, double a4)
{
  int v4 = *(_DWORD *)(result + 8);
  if (v4 != -1)
  {
    if (vabdd_f64(*(double *)(result + 16), a4) >= 5400.0 || fabs(*(double *)result) <= 2.22044605e-16) {
      int v4 = -1;
    }
    else {
      *a2 = *(void *)result;
    }
  }
  *a3 = v4;
  return result;
}

BOOL sub_100186344(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  BOOL v6 = sub_10001136C(cf, a3);
  if (!v6)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1022B6AC8);
    }
    __int16 v7 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)uint64_t buf = 138412546;
      uint64_t v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022B6AC8);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      long long v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CLNameValuePair &, int) const", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1001865E0(uint64_t a1, _OWORD *a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  unint64_t v6 = v5 + v3;
  __int16 v7 = (uint64_t *)(v4 + 8 * (v6 / 0x19));
  uint64_t v8 = *v7;
  uint64_t v9 = *v7 + 160 * (v6 % 0x19);
  unint64_t v10 = v5 / 0x19;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 / 0x19));
  unint64_t v12 = v5 % 0x19;
  uint64_t v13 = v11 + 160 * v12;
  if (v9 != v13)
  {
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v8) {
        uint64_t v14 = *(v7 - 1) + 4000;
      }
      double v15 = *(double *)(v14 - 152);
      if (v15 <= a3 && v15 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v9 == v8)
      {
        uint64_t v16 = *--v7;
        uint64_t v8 = v16;
        uint64_t v9 = v16 + 4000;
      }
      v9 -= 160;
      if (v9 == v13)
      {
        uint64_t v9 = v11 + 160 * v12;
        break;
      }
    }
  }
  if (v9 == *(void *)(v4 + 8 * v10) + 160 * v12) {
    return 0;
  }
  if (v9 == *v7) {
    uint64_t v9 = *(v7 - 1) + 4000;
  }
  long long v17 = *(_OWORD *)(v9 - 144);
  *a2 = *(_OWORD *)(v9 - 160);
  a2[1] = v17;
  long long v18 = *(_OWORD *)(v9 - 128);
  long long v19 = *(_OWORD *)(v9 - 112);
  long long v20 = *(_OWORD *)(v9 - 80);
  a2[4] = *(_OWORD *)(v9 - 96);
  a2[5] = v20;
  a2[2] = v18;
  a2[3] = v19;
  long long v21 = *(_OWORD *)(v9 - 64);
  long long v22 = *(_OWORD *)(v9 - 48);
  long long v23 = *(_OWORD *)(v9 - 16);
  a2[8] = *(_OWORD *)(v9 - 32);
  a2[9] = v23;
  a2[6] = v21;
  a2[7] = v22;
  return 1;
}

uint64_t sub_100186708(uint64_t a1, _OWORD *a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  char v6 = v5 + v3;
  __int16 v7 = (uint64_t *)(v4 + 8 * ((v5 + v3) >> 7));
  uint64_t v8 = *v7;
  uint64_t v9 = *v7 + 32 * (v6 & 0x7F);
  unint64_t v10 = v5 >> 7;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 >> 7));
  uint64_t v12 = v5 & 0x7F;
  uint64_t v13 = v11 + 32 * v12;
  if (v9 != v13)
  {
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v8) {
        uint64_t v14 = *(v7 - 1) + 4096;
      }
      double v15 = *(double *)(v14 - 32);
      if (v15 <= a3 && v15 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v9 == v8)
      {
        uint64_t v16 = *--v7;
        uint64_t v8 = v16;
        uint64_t v9 = v16 + 4096;
      }
      v9 -= 32;
      if (v9 == v13)
      {
        uint64_t v9 = v13;
        break;
      }
    }
  }
  if (v9 == *(void *)(v4 + 8 * v10) + 32 * v12) {
    return 0;
  }
  if (v9 == *v7) {
    uint64_t v9 = *(v7 - 1) + 4096;
  }
  long long v17 = *(_OWORD *)(v9 - 16);
  *a2 = *(_OWORD *)(v9 - 32);
  a2[1] = v17;
  return 1;
}

uint64_t sub_1001867DC(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  unint64_t v6 = v5 + v3;
  __int16 v7 = (uint64_t *)(v4 + 8 * ((v5 + v3) / 0x55));
  uint64_t v8 = *v7;
  uint64_t v9 = *v7 + 48 * (v6 % 0x55);
  unint64_t v10 = v5 / 0x55;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 / 0x55));
  unint64_t v12 = v5 % 0x55;
  uint64_t v13 = v11 + 48 * v12;
  if (v9 != v13)
  {
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v8) {
        uint64_t v14 = *(v7 - 1) + 4080;
      }
      double v15 = *(double *)(v14 - 48);
      if (v15 <= a3 && v15 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v9 == v8)
      {
        uint64_t v16 = *--v7;
        uint64_t v8 = v16;
        uint64_t v9 = v16 + 4080;
      }
      v9 -= 48;
      if (v9 == v13)
      {
        uint64_t v9 = v11 + 48 * v12;
        break;
      }
    }
  }
  if (v9 == *(void *)(v4 + 8 * v10) + 48 * v12) {
    return 0;
  }
  if (v9 == *v7) {
    uint64_t v9 = *(v7 - 1) + 4080;
  }
  long long v17 = *(_OWORD *)(v9 - 48);
  *(void *)(a2 + 16) = *(void *)(v9 - 32);
  *(_OWORD *)a2 = v17;
  if (v9 - 48 != a2) {
    sub_100ADA2D8((char *)(a2 + 24), *(char **)(v9 - 24), *(void *)(v9 - 16), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v9 - 16) - *(void *)(v9 - 24)) >> 2));
  }
  return 1;
}

void sub_100186918(void *a1, char **a2, double a3, double a4)
{
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = (void *)(v7 + 8 * (a1[6] >> 4));
  if (v8 == v7) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = (double *)(*v9 + 320 * (a1[6] & 0xFLL));
  }
  uint64_t v30 = (uint64_t)(a2 + 2);
  double v11 = a4 + 1.0e-13;
  while (1)
  {
    if (v8 == v7)
    {
      uint64_t v13 = 0;
    }
    else
    {
      unint64_t v12 = a1[7] + a1[6];
      uint64_t v13 = *(void *)(v7 + ((v12 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 320 * (v12 & 0xF);
    }
    if (v10 == (double *)v13) {
      break;
    }
    if (*v10 <= v11 && *v10 + 1.0e-13 > a3)
    {
      uint64_t v16 = a2[1];
      double v15 = a2[2];
      if (v16 >= v15)
      {
        unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((v16 - *a2) >> 6);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0xCCCCCCCCCCCCCCLL) {
          sub_1001D7FD4();
        }
        unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * ((v15 - *a2) >> 6);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x66666666666666) {
          unint64_t v21 = 0xCCCCCCCCCCCCCCLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          long long v22 = (char *)sub_10017EB70(v30, v21);
          uint64_t v24 = v23;
        }
        else
        {
          long long v22 = 0;
          uint64_t v24 = 0;
        }
        char v25 = &v22[320 * v18];
        memcpy(v25, v10, 0x140uLL);
        unint64_t v26 = *a2;
        uint64_t v27 = a2[1];
        uint64_t v28 = v25;
        if (v27 != *a2)
        {
          do
          {
            v27 -= 320;
            v28 -= 320;
            memcpy(v28, v27, 0x140uLL);
          }
          while (v27 != v26);
          uint64_t v27 = *a2;
        }
        long long v17 = v25 + 320;
        *a2 = v28;
        a2[1] = v25 + 320;
        a2[2] = &v22[320 * v24];
        if (v27) {
          operator delete(v27);
        }
      }
      else
      {
        memcpy(a2[1], v10, 0x140uLL);
        long long v17 = v16 + 320;
      }
      a2[1] = v17;
    }
    v10 += 40;
    if ((double *)((char *)v10 - *v9) == (double *)5120)
    {
      long long v29 = (double *)v9[1];
      ++v9;
      unint64_t v10 = v29;
    }
    uint64_t v7 = a1[3];
    uint64_t v8 = a1[4];
  }
}

uint64_t sub_100186B50(uint64_t result)
{
  if (*(double *)(result + 64) != -1.0)
  {
    uint64_t v1 = result;
    if (!*(unsigned char *)(result + 8))
    {
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      if (result)
      {
        *(unsigned char *)(v1 + 8) = 1;
      }
      else if (!*(unsigned char *)(v1 + 8))
      {
        double v2 = 2.22507386e-308;
        goto LABEL_7;
      }
    }
    double v2 = *(double *)(v1 + 64) + 30.0;
LABEL_7:
    *(double *)(v1 + 72) = v2;
  }
  return result;
}

uint64_t sub_100186BE4(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v6 = *(void *)(a1 + 48);
  unint64_t v7 = v6 + v3;
  uint64_t v8 = (uint64_t *)(v4 + 8 * ((v6 + v3) / 0x49));
  uint64_t v9 = *v8;
  uint64_t v10 = *v8 + 56 * (v7 % 0x49);
  unint64_t v11 = v6 / 0x49;
  uint64_t v12 = *(void *)(v4 + 8 * (v6 / 0x49));
  unint64_t v13 = v6 % 0x49;
  uint64_t v14 = v12 + 56 * v13;
  if (v10 != v14)
  {
    while (1)
    {
      uint64_t v15 = v10;
      if (v10 == v9) {
        uint64_t v15 = *(v8 - 1) + 4088;
      }
      double v16 = *(double *)(v15 - 56);
      if (v16 <= a3 && v16 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v10 == v9)
      {
        uint64_t v17 = *--v8;
        uint64_t v9 = v17;
        uint64_t v10 = v17 + 4088;
      }
      v10 -= 56;
      if (v10 == v14)
      {
        uint64_t v10 = v14;
        break;
      }
    }
  }
  if (v10 == *(void *)(v4 + 8 * v11) + 56 * v13) {
    return 0;
  }
  if (v10 == *v8) {
    uint64_t v10 = *(v8 - 1) + 4088;
  }
  *(void *)a2 = *(void *)(v10 - 56);
  *(void *)(a2 + 8) = *(void *)(v10 - 48);
  if (v10 - 56 != a2) {
    sub_1008A9A00((char *)(a2 + 16), *(char **)(v10 - 40), *(void *)(v10 - 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v10 - 32) - *(void *)(v10 - 40)) >> 3));
  }
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(v10 - 16);
  return 1;
}

uint64_t sub_100186D34(uint64_t a1, void *a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) == v4) {
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  unint64_t v6 = v5 + v3;
  unint64_t v7 = (uint64_t *)(v4 + 8 * (v6 >> 7));
  uint64_t v8 = *v7;
  uint64_t v9 = *v7 + 32 * (v6 & 0x7F);
  unint64_t v10 = v5 >> 7;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 >> 7));
  uint64_t v12 = v5 & 0x7F;
  uint64_t v13 = v11 + 32 * v12;
  if (v9 != v13)
  {
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v8) {
        uint64_t v14 = *(v7 - 1) + 4096;
      }
      double v15 = *(double *)(v14 - 32);
      if (v15 <= a3 && v15 > a3 - *(double *)(a1 + 80)) {
        break;
      }
      if (v9 == v8)
      {
        uint64_t v16 = *--v7;
        uint64_t v8 = v16;
        uint64_t v9 = v16 + 4096;
      }
      v9 -= 32;
      if (v9 == v13)
      {
        uint64_t v9 = v13;
        break;
      }
    }
  }
  if (v9 == *(void *)(v4 + 8 * v10) + 32 * v12) {
    return 0;
  }
  if (v9 == *v7) {
    uint64_t v9 = *(v7 - 1) + 4096;
  }
  *a2 = *(void *)(v9 - 32);
  if ((void *)(v9 - 32) != a2) {
    sub_1000DAC8C(a2 + 1, *(void *)(v9 - 24), *(void *)(v9 - 16), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v9 - 16) - *(void *)(v9 - 24)) >> 3));
  }
  return 1;
}

uint64_t sub_100186E4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100110970(buf);
  sub_1001AC054(a2, (long long *)buf);
  if (__p)
  {
    __int16 v138 = __p;
    operator delete(__p);
  }

  if (v135 < 0) {
    operator delete(v134);
  }
  if (SBYTE7(v132) < 0) {
    operator delete(*(void **)&v131[16]);
  }
  if ((v131[15] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  sub_1001ABED0((uint64_t)buf);
  long long v6 = *(_OWORD *)&v131[16];
  *(_OWORD *)(a3 + 32) = *(_OWORD *)v131;
  *(_OWORD *)(a3 + 48) = v6;
  *(_OWORD *)(a3 + 64) = v132;
  *(void *)(a3 + 80) = v133;
  long long v7 = *(_OWORD *)&buf[16];
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_OWORD *)(a3 + 16) = v7;
  if (!*sub_10016363C()
    || (uint64_t v9 = a1 + 240, v8 = *(void **)(a1 + 240), v10 = (void *)(a1 + 248), v8 == (void *)(a1 + 248)))
  {
    char v96 = 0;
  }
  else
  {
    char v96 = 0;
    uint64_t v11 = &qword_102419000;
    do
    {
      if ((v8[24] & 0xA0) == 0x80
        && *((double *)v8 + 16) <= 400.0
        && !*((unsigned char *)v8 + 220)
        && *((_DWORD *)v8 + 53) != 2
        && v8[33] == v8[32])
      {
        *(void *)__int16 v118 = v8[45];
        long long v12 = *(_OWORD *)(v8 + 41);
        long long v115 = *(_OWORD *)(v8 + 39);
        long long v116 = v12;
        long long v117 = *(_OWORD *)(v8 + 43);
        long long v13 = *(_OWORD *)(v8 + 37);
        long long v113 = *(_OWORD *)(v8 + 35);
        long long v114 = v13;
        sub_100110970((char *)v101);
        __str = (std::string *)(v8 + 4);
        if (sub_100DC9174(a1, (unsigned __int8 *)v8 + 32, (uint64_t)v101))
        {
          if (!v107)
          {
            uint64_t v14 = v11;
            if (v11[120] != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            double v15 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_FAULT))
            {
              std::string::size_type v16 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v16 = __str->__r_.__value_.__r.__words[0];
              }
              uint64_t v17 = v8 + 7;
              if (*((char *)v8 + 79) < 0) {
                uint64_t v17 = (void *)*v17;
              }
              unint64_t v18 = v101;
              if (v102 < 0) {
                unint64_t v18 = (void **)v101[0];
              }
              unint64_t v19 = v103;
              if (v104 < 0) {
                unint64_t v19 = (void **)v103[0];
              }
              *(_DWORD *)uint64_t buf = 136381443;
              *(void *)&uint8_t buf[4] = v16;
              *(_WORD *)&unsigned char buf[12] = 2081;
              *(void *)&unsigned char buf[14] = v17;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v18;
              *(_WORD *)int v131 = 2081;
              *(void *)&v131[2] = v19;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "Fence %{private}s/%{private}s has helper fence %{private}s/%{private}s, but isHelperFence isn't set.", buf, 0x2Au);
            }
            uint64_t v11 = v14;
            if (sub_10013D1A0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (v14[120] != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              std::string::size_type v73 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v73 = __str->__r_.__value_.__r.__words[0];
              }
              long long v74 = (v8 + 7);
              if (*((char *)v8 + 79) < 0) {
                long long v74 = v74->isa;
              }
              long long v75 = v101;
              if (v102 < 0) {
                long long v75 = (void **)v101[0];
              }
              double v76 = v103;
              if (v104 < 0) {
                double v76 = (void **)v103[0];
              }
              *(_DWORD *)uint64_t v119 = 136381443;
              *(void *)&v119[4] = v73;
              __int16 v120 = 2081;
              os_log_t v121 = v74;
              __int16 v122 = 2081;
              int v123 = v75;
              __int16 v124 = 2081;
              double v125 = *(double *)&v76;
              uint64_t v77 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLFenceMonitor::getUpdatedProximityState(CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &) const", "%s\n", v77);
              if (v77 != buf) {
                free(v77);
              }
              uint64_t v11 = v14;
            }
          }
          uint64_t v20 = sub_10001A4C4(v9, (unsigned __int8 *)v101);
          if (v10 == (void *)v20)
          {
            long long v39 = v11;
            if (v11[120] != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            long long v40 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_FAULT))
            {
              std::string::size_type v41 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v41 = __str->__r_.__value_.__r.__words[0];
              }
              int v42 = v8 + 7;
              if (*((char *)v8 + 79) < 0) {
                int v42 = (void *)*v42;
              }
              uint64_t v43 = v101;
              if (v102 < 0) {
                uint64_t v43 = (void **)v101[0];
              }
              __int16 v44 = v103;
              if (v104 < 0) {
                __int16 v44 = (void **)v103[0];
              }
              *(_DWORD *)uint64_t buf = 136315906;
              *(void *)&uint8_t buf[4] = v41;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&unsigned char buf[14] = v42;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = v43;
              *(_WORD *)int v131 = 2080;
              *(void *)&v131[2] = v44;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Fence %s/%s does not have monitoring status for helper fence %s/%s", buf, 0x2Au);
            }
            uint64_t v11 = v39;
            if (sub_10013D1A0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (v39[120] != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              std::string::size_type v78 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v78 = __str->__r_.__value_.__r.__words[0];
              }
              uint64_t v79 = (v8 + 7);
              if (*((char *)v8 + 79) < 0) {
                uint64_t v79 = v79->isa;
              }
              char v80 = v101;
              if (v102 < 0) {
                char v80 = (void **)v101[0];
              }
              unint64_t v81 = v103;
              if (v104 < 0) {
                unint64_t v81 = (void **)v103[0];
              }
              *(_DWORD *)uint64_t v119 = 136315906;
              *(void *)&v119[4] = v78;
              __int16 v120 = 2080;
              os_log_t v121 = v79;
              __int16 v122 = 2080;
              int v123 = v80;
              __int16 v124 = 2080;
              double v125 = *(double *)&v81;
              uint64_t v82 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLFenceMonitor::getUpdatedProximityState(CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &) const", "%s\n", v82);
              if (v82 != buf) {
                free(v82);
              }
              uint64_t v11 = v39;
            }
          }
          else
          {
            *(void *)__int16 v118 = *(void *)(v20 + 360);
            long long v21 = *(_OWORD *)(v20 + 328);
            long long v115 = *(_OWORD *)(v20 + 312);
            long long v116 = v21;
            long long v117 = *(_OWORD *)(v20 + 344);
            long long v22 = *(_OWORD *)(v20 + 296);
            long long v113 = *(_OWORD *)(v20 + 280);
            long long v114 = v22;
            if (v11[120] != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            uint64_t v23 = qword_1024193C8;
            if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
            {
              std::string::size_type v24 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v24 = __str->__r_.__value_.__r.__words[0];
              }
              char v25 = v8 + 7;
              std::string::size_type v85 = v24;
              log = v23;
              if (*((char *)v8 + 79) < 0) {
                char v25 = (void *)*v25;
              }
              uint64_t v84 = v25;
              uint64_t v89 = a1;
              uint64_t v91 = v9;
              if (v102 >= 0) {
                unint64_t v26 = v101;
              }
              else {
                unint64_t v26 = (void **)v101[0];
              }
              if (v104 >= 0) {
                uint64_t v27 = v103;
              }
              else {
                uint64_t v27 = (void **)v103[0];
              }
              sub_100777704((int *)v8 + 90, v119);
              int v28 = SHIBYTE(v122);
              long long v29 = *(unsigned char **)v119;
              sub_100777704(v118, v99);
              uint64_t v30 = v119;
              if (v28 < 0) {
                uint64_t v30 = v29;
              }
              uint64_t v31 = v99;
              if (v100 < 0) {
                uint64_t v31 = (void **)v99[0];
              }
              *(_DWORD *)uint64_t buf = 136381955;
              *(void *)&uint8_t buf[4] = v85;
              *(_WORD *)&unsigned char buf[12] = 2081;
              *(void *)&unsigned char buf[14] = v84;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v26;
              *(_WORD *)int v131 = 2081;
              *(void *)&v131[2] = v27;
              *(_WORD *)&v131[10] = 2081;
              *(void *)&v131[12] = v30;
              *(_WORD *)&v131[20] = 2081;
              *(void *)&v131[22] = v31;
              _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "converging state, Fence %{private}s/%{private}s using monitoring status from helper fence %{private}s/%{private}s. Old proximity state: %{private}s, new proximity state: %{private}s", buf, 0x3Eu);
              if (v100 < 0) {
                operator delete(v99[0]);
              }
              a1 = v89;
              uint64_t v9 = v91;
              uint64_t v11 = &qword_102419000;
              if (SHIBYTE(v122) < 0) {
                operator delete(*(void **)v119);
              }
            }
            if (sub_10013D1A0(115, 2))
            {
              uint64_t v90 = a1;
              uint64_t v92 = v9;
              bzero(buf, 0x65CuLL);
              if (v11[120] != -1) {
                dispatch_once(&qword_1024193C0, &stru_1022F7C40);
              }
              std::string::size_type v86 = (std::string::size_type)(v8 + 4);
              if (*((char *)v8 + 55) < 0) {
                std::string::size_type v86 = __str->__r_.__value_.__r.__words[0];
              }
              os_log_t loga = (os_log_t)(v8 + 7);
              if (*((char *)v8 + 79) < 0) {
                os_log_t loga = (os_log_t)loga->isa;
              }
              if (v102 >= 0) {
                long long v32 = v101;
              }
              else {
                long long v32 = (void **)v101[0];
              }
              if (v104 >= 0) {
                uint64_t v33 = v103;
              }
              else {
                uint64_t v33 = (void **)v103[0];
              }
              sub_100777704((int *)v8 + 90, v99);
              int v34 = v100;
              unint64_t v35 = (void **)v99[0];
              sub_100777704(v118, v97);
              uint64_t v36 = v99;
              if (v34 < 0) {
                uint64_t v36 = v35;
              }
              int v37 = v97;
              if (v98 < 0) {
                int v37 = (void **)v97[0];
              }
              *(_DWORD *)uint64_t v119 = 136381955;
              *(void *)&v119[4] = v86;
              __int16 v120 = 2081;
              os_log_t v121 = loga;
              __int16 v122 = 2081;
              int v123 = v32;
              __int16 v124 = 2081;
              double v125 = *(double *)&v33;
              __int16 v126 = 2081;
              uint64_t v127 = v36;
              __int16 v128 = 2081;
              uint64_t v129 = v37;
              long long v38 = (char *)_os_log_send_and_compose_impl();
              if (v98 < 0) {
                operator delete(v97[0]);
              }
              if (v100 < 0) {
                operator delete(v99[0]);
              }
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitor::getUpdatedProximityState(CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &) const", "%s\n", v38);
              if (v38 != buf) {
                free(v38);
              }
              a1 = v90;
              uint64_t v9 = v92;
              uint64_t v11 = &qword_102419000;
            }
          }
        }
        if (*((double *)&v117 + 1) <= *(double *)(a1 + 136))
        {
          long long v58 = v11;
          if (v11[120] != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          long long v59 = qword_1024193C8;
          if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
          {
            std::string::size_type v60 = (std::string::size_type)(v8 + 4);
            if (*((char *)v8 + 55) < 0) {
              std::string::size_type v60 = __str->__r_.__value_.__r.__words[0];
            }
            long long v61 = v8 + 7;
            if (*((char *)v8 + 79) < 0) {
              long long v61 = (void *)*v61;
            }
            double v62 = *(double *)(a1 + 136) - *((double *)&v117 + 1);
            *(_DWORD *)uint64_t buf = 136381443;
            *(void *)&uint8_t buf[4] = v60;
            *(_WORD *)&unsigned char buf[12] = 2081;
            *(void *)&unsigned char buf[14] = v61;
            *(_WORD *)&buf[22] = 2049;
            *(void *)&unsigned char buf[24] = *((void *)&v117 + 1);
            *(_WORD *)int v131 = 2049;
            *(double *)&v131[2] = v62;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEBUG, "converging state, Fence %{private}s/%{private}s proximity state is stale. Last update timestamp: %{private}f (%{private}f seconds prior)", buf, 0x2Au);
          }
          uint64_t v11 = v58;
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (v58[120] != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            if (*((char *)v8 + 55) < 0) {
              __str = (std::string *)__str->__r_.__value_.__r.__words[0];
            }
            long long v66 = (v8 + 7);
            if (*((char *)v8 + 79) < 0) {
              long long v66 = v66->isa;
            }
            double v67 = *(double *)(a1 + 136) - *((double *)&v117 + 1);
            *(_DWORD *)uint64_t v119 = 136381443;
            *(void *)&v119[4] = __str;
            __int16 v120 = 2081;
            os_log_t v121 = v66;
            __int16 v122 = 2049;
            int v123 = (void **)*((void *)&v117 + 1);
            __int16 v124 = 2049;
            double v125 = v67;
            long long v68 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitor::getUpdatedProximityState(CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &) const", "%s\n", v68);
            if (v68 != buf) {
              free(v68);
            }
            uint64_t v11 = v58;
          }
        }
        else if (v118[0] > *(_DWORD *)(a3 + 80))
        {
          if (v11[120] != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          long long v45 = qword_1024193C8;
          if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v93 = v9;
            std::string::size_type v46 = (std::string::size_type)(v8 + 4);
            if (*((char *)v8 + 55) < 0) {
              std::string::size_type v46 = __str->__r_.__value_.__r.__words[0];
            }
            char v47 = v8 + 7;
            if (*((char *)v8 + 79) < 0) {
              char v47 = (void *)*v47;
            }
            sub_100777704(v118, v119);
            uint64_t v48 = v119;
            if (v122 < 0) {
              uint64_t v48 = *(unsigned char **)v119;
            }
            *(_DWORD *)uint64_t buf = 136381443;
            *(void *)&uint8_t buf[4] = v46;
            *(_WORD *)&unsigned char buf[12] = 2081;
            *(void *)&unsigned char buf[14] = v47;
            *(_WORD *)&buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v48;
            *(_WORD *)int v131 = 2049;
            *(void *)&v131[2] = v114;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "converging state, most energetic updated by fence %{private}s/%{private}s %{private}s. Distance: %{private}f", buf, 0x2Au);
            if (SHIBYTE(v122) < 0) {
              operator delete(*(void **)v119);
            }
            uint64_t v9 = v93;
          }
          uint64_t v11 = &qword_102419000;
          if (sub_10013D1A0(115, 2))
          {
            uint64_t v94 = v9;
            bzero(buf, 0x65CuLL);
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            std::string::size_type v69 = (std::string::size_type)(v8 + 4);
            if (*((char *)v8 + 55) < 0) {
              std::string::size_type v69 = __str->__r_.__value_.__r.__words[0];
            }
            uint64_t v70 = (v8 + 7);
            if (*((char *)v8 + 79) < 0) {
              uint64_t v70 = v70->isa;
            }
            sub_100777704(v118, v99);
            unint64_t v71 = v99;
            if (v100 < 0) {
              unint64_t v71 = (void **)v99[0];
            }
            *(_DWORD *)uint64_t v119 = 136381443;
            *(void *)&v119[4] = v69;
            __int16 v120 = 2081;
            os_log_t v121 = v70;
            __int16 v122 = 2081;
            int v123 = v71;
            __int16 v124 = 2049;
            double v125 = *(double *)&v114;
            long long v72 = (char *)_os_log_send_and_compose_impl();
            if (v100 < 0) {
              operator delete(v99[0]);
            }
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitor::getUpdatedProximityState(CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &) const", "%s\n", v72);
            if (v72 != buf) {
              free(v72);
            }
            uint64_t v9 = v94;
            uint64_t v11 = &qword_102419000;
          }
          long long v49 = v116;
          *(_OWORD *)(a3 + 32) = v115;
          *(_OWORD *)(a3 + 48) = v49;
          *(_OWORD *)(a3 + 64) = v117;
          *(void *)(a3 + 80) = *(void *)v118;
          long long v50 = v114;
          *(_OWORD *)a3 = v113;
          *(_OWORD *)(a3 + 16) = v50;
          std::string::operator=((std::string *)a2, __str);
          std::string::operator=((std::string *)(a2 + 24), (const std::string *)(v8 + 7));
          std::string::operator=((std::string *)(a2 + 48), (const std::string *)(v8 + 10));
          long long v51 = *(_OWORD *)(v8 + 13);
          long long v52 = *(_OWORD *)(v8 + 15);
          long long v53 = *(_OWORD *)(v8 + 19);
          *(_OWORD *)(a2 + 104) = *(_OWORD *)(v8 + 17);
          *(_OWORD *)(a2 + 120) = v53;
          *(_OWORD *)(a2 + 72) = v51;
          *(_OWORD *)(a2 + 88) = v52;
          long long v54 = *(_OWORD *)(v8 + 21);
          long long v55 = *(_OWORD *)(v8 + 23);
          long long v56 = *(_OWORD *)(v8 + 25);
          *(void *)(a2 + 181) = *(void *)((char *)v8 + 213);
          *(_OWORD *)(a2 + 152) = v55;
          *(_OWORD *)(a2 + 168) = v56;
          *(_OWORD *)(a2 + 136) = v54;
          std::string::operator=((std::string *)(a2 + 192), (const std::string *)(v8 + 28));
          long long v57 = *(void **)(a2 + 216);
          *(void *)(a2 + 216) = (id)v8[31];

          if (__str != (std::string *)a2) {
            sub_10027C3B4((char *)(a2 + 224), (char *)v8[32], v8[33], (uint64_t)(v8[33] - v8[32]) >> 4);
          }
          char v96 = 1;
        }
        if (v111)
        {
          uint64_t v112 = v111;
          operator delete(v111);
        }

        if (v109 < 0) {
          operator delete(v108);
        }
        if (v106 < 0) {
          operator delete(v105);
        }
        if (v104 < 0) {
          operator delete(v103[0]);
        }
        if (v102 < 0) {
          operator delete(v101[0]);
        }
      }
      long long v63 = (void *)v8[1];
      if (v63)
      {
        do
        {
          long long v64 = v63;
          long long v63 = (void *)*v63;
        }
        while (v63);
      }
      else
      {
        do
        {
          long long v64 = (void *)v8[2];
          BOOL v65 = *v64 == (void)v8;
          uint64_t v8 = v64;
        }
        while (!v65);
      }
      uint64_t v8 = v64;
    }
    while (v64 != v10);
  }
  return v96 & 1;
}

void sub_100187DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,char a40)
{
}

uint64_t sub_100187E7C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 67);
}

double sub_100187E84(uint64_t a1)
{
  int v2 = sub_100087DF0(a1);
  if ((v2 - 1) < 2) {
    return *(double *)(a1 + 1144);
  }
  double v3 = 0.0;
  if (v2 != 3) {
    return v3;
  }
  sub_100103240();
  if ((sub_10010145C() & 1) == 0)
  {
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_10230E560);
    }
    unint64_t v5 = qword_102419038;
    if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "[PaceController] getPace - invalid output configuration!", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return v3;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_10230E560);
    }
    long long v6 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "double CLPedometer::PaceController::getPace() const", "%s\n");
LABEL_26:
    if (v6 != buf) {
      free(v6);
    }
    return v3;
  }
  if (*(unsigned char *)(a1 + 496))
  {
    double v4 = *(double *)(a1 + 488);
    if (v4 == 0.0) {
      return 0.0;
    }
    else {
      return 1.0 / v4;
    }
  }
  if (qword_102419030 != -1) {
    dispatch_once(&qword_102419030, &stru_10230E560);
  }
  long long v7 = qword_102419038;
  if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "[PaceController] getPace - RunningSpeedKF pace invalid", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_10230E560);
    }
    long long v6 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "double CLPedometer::PaceController::getPace() const", "%s\n");
    goto LABEL_26;
  }
  return v3;
}

uint64_t sub_10018818C(uint64_t result, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)__n128 result = *(_OWORD *)a3;
  *(_OWORD *)(result + 16) = v3;
  long long v4 = *(_OWORD *)(a3 + 32);
  long long v5 = *(_OWORD *)(a3 + 48);
  long long v6 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(result + 64) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(result + 80) = v6;
  *(_OWORD *)(result + 32) = v4;
  *(_OWORD *)(result + 48) = v5;
  long long v7 = *(_OWORD *)(a3 + 96);
  long long v8 = *(_OWORD *)(a3 + 112);
  long long v9 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(result + 140) = *(_OWORD *)(a3 + 140);
  *(_OWORD *)(result + 112) = v8;
  *(_OWORD *)(result + 128) = v9;
  *(_OWORD *)(result + 96) = v7;
  *(void *)&long long v7 = *(void *)(a3 + 88);
  uint64_t v10 = (uint64_t)(*(double *)&v7 * 1000000000.0) + a2;
  if (*(double *)&v7 < 0.0) {
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
  *(void *)(result + 160) = a2;
  *(void *)(result + 168) = v10;
  return result;
}

void sub_1001881E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t __ldb = *(unsigned int *)(a1 + 12);
  if (__ldb != *(_DWORD *)(a2 + 8)) {
    sub_101A8A500();
  }
  if (a1 == a3) {
    sub_101A8A4A8();
  }
  if (a2 == a3) {
    sub_101A8A4D4();
  }
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a2 + 12);
  sub_100062B3C((_DWORD *)a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a2 + 12));
  if (__ldb <= v8) {
    int v9 = v8;
  }
  else {
    int v9 = __ldb;
  }
  if (v9 <= v7) {
    int v9 = v7;
  }
  uint64_t v10 = *(const double **)(a1 + 32);
  if (v9 > 5)
  {
    cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, v7, v8, __ldb, 1.0, v10, v7, *(const double **)(a2 + 32), __ldb, 0.0, *(double **)(a3 + 32), *(_DWORD *)(a3 + 8));
  }
  else if (v8)
  {
    uint64_t v11 = 0;
    long long v12 = *(double **)(a2 + 32);
    uint64_t v13 = *(void *)(a3 + 32);
    do
    {
      if (v7)
      {
        uint64_t v14 = 0;
        double v15 = (double *)v10;
        do
        {
          double v16 = 0.0;
          if (__ldb)
          {
            uint64_t v17 = __ldb;
            unint64_t v18 = v12;
            unint64_t v19 = v15;
            do
            {
              double v20 = *v18++;
              double v16 = v16 + *v19 * v20;
              v19 += v7;
              --v17;
            }
            while (v17);
          }
          *(double *)(v13 + 8 * (v11 * v7 + v14++)) = v16;
          ++v15;
        }
        while (v14 != v7);
      }
      ++v11;
      v12 += __ldb;
    }
    while (v11 != v8);
  }
}

uint64_t sub_10018834C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0x100000002;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_10232BF28;
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 2)
  {
    int v9 = "this->max_num_rows_ >= num_rows";
    int v10 = 422;
LABEL_11:
    uint64_t v11 = "cnmatrixbase.h";
    long long v12 = "SetMatrixSize";
    goto LABEL_15;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 12);
  if (v5 >= 2)
  {
    int v9 = "this->max_num_cols_ >= num_cols";
    int v10 = 423;
    goto LABEL_11;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v5;
  int v6 = v5 * v3;
  *(_DWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 20) = v3;
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 2u)
  {
    int v9 = "this->max_num_rows_ >= A.NumRows()";
    int v10 = 567;
LABEL_14:
    uint64_t v11 = "cnmatrix.h";
    long long v12 = "CNMatrix";
LABEL_15:
    __assert_rtn(v12, v11, v10, v9);
  }
  if (*(_DWORD *)(a2 + 12) > 1u)
  {
    int v9 = "this->max_num_cols_ >= A.NumCols()";
    int v10 = 568;
    goto LABEL_14;
  }
  if (v6)
  {
    uint64_t v7 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 32) + 8 * v7) = sub_1001803A0(a2, v7);
      ++v7;
    }
    while (v7 < *(int *)(a1 + 16));
  }
  return a1;
}

void sub_100188480(_Unwind_Exception *a1)
{
  void *v1 = off_10232BF80;
  _Unwind_Resume(a1);
}

uint64_t sub_1001884A4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0x100000002;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_10232BEA0;
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 2)
  {
    int v9 = "this->max_num_rows_ >= num_rows";
    int v10 = 422;
LABEL_11:
    uint64_t v11 = "cnmatrixbase.h";
    long long v12 = "SetMatrixSize";
    goto LABEL_15;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 12);
  if (v5 >= 2)
  {
    int v9 = "this->max_num_cols_ >= num_cols";
    int v10 = 423;
    goto LABEL_11;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v5;
  int v6 = v5 * v3;
  *(_DWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 20) = v3;
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 2u)
  {
    int v9 = "this->max_num_rows_ >= A.NumRows()";
    int v10 = 567;
LABEL_14:
    uint64_t v11 = "cnmatrix.h";
    long long v12 = "CNMatrix";
LABEL_15:
    __assert_rtn(v12, v11, v10, v9);
  }
  if (*(_DWORD *)(a2 + 12) > 1u)
  {
    int v9 = "this->max_num_cols_ >= A.NumCols()";
    int v10 = 568;
    goto LABEL_14;
  }
  if (v6)
  {
    uint64_t v7 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 32) + 8 * v7) = sub_1001803A0(a2, v7);
      ++v7;
    }
    while (v7 < *(int *)(a1 + 16));
  }
  return a1;
}

void sub_1001885D8(_Unwind_Exception *a1)
{
  void *v1 = off_10232BEF8;
  _Unwind_Resume(a1);
}

_DWORD *sub_1001885FC(_DWORD *result, int a2, int a3)
{
  if (a2 < 0) {
    sub_101ABA1A8();
  }
  if (a3 < 0) {
    sub_101ABA1D4();
  }
  if (a3 * a2 != result[4]) {
    sub_101ABA258();
  }
  if (result[6] < a2) {
    sub_101ABA200();
  }
  if (result[7] < a3) {
    sub_101ABA22C();
  }
  result[2] = a2;
  result[3] = a3;
  result[4] = a3 * a2;
  result[5] = a2;
  return result;
}

_DWORD *sub_10018865C(_DWORD *result, unsigned int a2, unsigned int a3)
{
  if (result[6] < a2) {
    sub_101A7DB2C();
  }
  if (result[7] < a3) {
    sub_101A7DB58();
  }
  result[2] = a2;
  result[3] = a3;
  result[4] = a3 * a2;
  result[5] = a2;
  return result;
}

_DWORD *sub_10018869C(_DWORD *result, unsigned int a2, int a3)
{
  if (result[6] < a2) {
    sub_101ABA284();
  }
  if (a3 < 0) {
    sub_101ABA2B0();
  }
  if (result[7] < a3) {
    sub_101ABA2DC();
  }
  result[2] = a2;
  result[3] = a3;
  result[4] = a3 * a2;
  result[5] = a2;
  return result;
}

unsigned __int16 *sub_1001886E4(unsigned __int16 *result, long long *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  long long v4 = &result[12 * (v3 - v2)];
  long long v5 = *a2;
  *((void *)v4 + 3) = *((void *)a2 + 2);
  *(_OWORD *)(v4 + 4) = v5;
  unsigned int v6 = result[1];
  unint64_t v7 = *((unsigned int *)result + 1);
  if (v7 <= v6)
  {
    unint64_t v8 = *result + 1;
    if (v8 < v7) {
      LOWORD(v7) = 0;
    }
    *__n128 result = v8 - v7;
  }
  else
  {
    result[1] = v6 + 1;
  }
  return result;
}

uint64_t sub_100188750(uint64_t a1, uint64_t a2)
{
  sub_10017CD78((void *)a1, (void *)a2);
  sub_10000E5C4(a1 + 48, a2 + 48);
  long long v4 = *(_OWORD *)(a2 + 648);
  *(_OWORD *)(a1 + 632) = *(_OWORD *)(a2 + 632);
  *(_OWORD *)(a1 + 648) = v4;
  long long v6 = *(_OWORD *)(a2 + 680);
  long long v5 = *(_OWORD *)(a2 + 696);
  long long v7 = *(_OWORD *)(a2 + 664);
  *(_DWORD *)(a1 + 712) = *(_DWORD *)(a2 + 712);
  *(_OWORD *)(a1 + 680) = v6;
  *(_OWORD *)(a1 + 696) = v5;
  *(_OWORD *)(a1 + 664) = v7;
  return a1;
}

void sub_1001887B4(void *a1, double *a2)
{
  while (a1[5])
  {
    if (sub_100022DBC(*(void *)(a1[1] + 8 * (a1[4] / 0x17uLL)) + 176 * (a1[4] % 0x17uLL), a2) <= 300.0) {
      break;
    }
    sub_10132D954(a1);
  }
}

void sub_100188860(int64x2_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2].u64[1];
  if (a1[41].i8[8])
  {
    if (v4 >= 6) {
      sub_10132D954(a1);
    }
  }
  else
  {
    if (v4 >= 0x1E) {
      sub_10132D954(a1);
    }
    if (!a1[40].i32[3])
    {
      int v5 = dword_102477708 + 1;
      dword_102477708 = v5;
      a1[40].i32[3] = v5;
      a1[38].i32[1] = v5;
    }
  }
  long long v6 = *(std::__shared_weak_count **)(a2 + 24);
  if (!v6)
  {
    long long v7 = 0;
LABEL_24:
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1023207F0);
    }
    unint64_t v19 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      __int32 v20 = a1[40].i32[3];
      *(_DWORD *)uint64_t buf = 67240192;
      __int32 v64 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "FusedLoc,hID,%{public}d,trying to update with unavailable location object", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1023207F0);
      }
      __int32 v54 = a1[40].i32[3];
      int v61 = 67240192;
      __int32 v62 = v54;
      long long v55 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::LCFusionLocationHypothesis::newLocationUpdate(const LCFusionFusedLocation &)", "%s\n", v55);
      if (v55 != (char *)buf) {
        free(v55);
      }
    }
    goto LABEL_29;
  }
  long long v7 = std::__shared_weak_count::lock(v6);
  if (!v7) {
    goto LABEL_24;
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  uint64_t v9 = a1[2].i64[1];
  if (!v9)
  {
    sub_10017CE48(a1, a2);
    a1[40].i32[2] = -1;
    unint64_t v21 = a1[2].i64[1] + a1[2].i64[0] - 1;
    uint64_t v22 = *(void *)(a1->i64[1] + 8 * (v21 / 0x17));
    unint64_t v23 = v21 % 0x17;
    uint64_t v24 = v22 + 176 * v23;
    int v26 = *(unsigned __int8 *)(v24 + 168);
    char v25 = (unsigned char *)(v24 + 168);
    if (v26) {
      goto LABEL_38;
    }
    *char v25 = 1;
    uint64_t v27 = v22 + 176 * v23;
    long long v28 = *(_OWORD *)(v8 + 8);
    long long v29 = *(_OWORD *)(v8 + 24);
    long long v30 = *(_OWORD *)(v8 + 40);
    *(_OWORD *)(v27 + 88) = *(_OWORD *)(v8 + 56);
    *(_OWORD *)(v27 + 72) = v30;
    *(_OWORD *)(v27 + 56) = v29;
    *(_OWORD *)(v27 + 40) = v28;
    long long v31 = *(_OWORD *)(v8 + 72);
    long long v32 = *(_OWORD *)(v8 + 88);
    long long v33 = *(_OWORD *)(v8 + 104);
    *(_OWORD *)(v27 + 148) = *(_OWORD *)(v8 + 116);
    *(_OWORD *)(v27 + 136) = v33;
    *(_OWORD *)(v27 + 120) = v32;
    *(_OWORD *)(v27 + 104) = v31;
    unint64_t v34 = a1[2].i64[1] + a1[2].i64[0] - 1;
    unint64_t v35 = *(void *)(a1->i64[1] + 8 * (v34 / 0x17)) + 176 * (v34 % 0x17);
LABEL_37:
    *(unsigned char *)(v35 + 169) = 0;
    *(_OWORD *)unint64_t v35 = *(_OWORD *)(v8 + 8);
    goto LABEL_38;
  }
  double v10 = *(double *)(a2 + 8);
  unint64_t v11 = a1[2].u64[0];
  uint64_t v12 = a1->i64[1];
  if (v10 >= *(double *)(*(void *)(v12 + 8 * ((v9 + v11 - 1) / 0x17)) + 176 * ((v9 + v11 - 1) % 0x17) + 8))
  {
    sub_10017CE48(a1, a2);
    a1[40].i32[2] = a1[2].i32[2] - 2;
    goto LABEL_38;
  }
  unint64_t v13 = *(void *)(v12 + 8 * (v11 / 0x17)) + 176 * (v11 % 0x17);
  if (v10 <= *(double *)(v13 + 8))
  {
    sub_10132D9FC((uint64_t)a1, a2);
    a1[40].i32[2] = 0;
    unint64_t v36 = a1[2].u64[0];
    uint64_t v37 = *(void *)(a1->i64[1] + 8 * (v36 / 0x17));
    unint64_t v38 = v36 % 0x17;
    uint64_t v39 = v37 + 176 * v38;
    int v41 = *(unsigned __int8 *)(v39 + 168);
    long long v40 = (unsigned char *)(v39 + 168);
    if (v41) {
      goto LABEL_38;
    }
    *long long v40 = 1;
    uint64_t v42 = v37 + 176 * v38;
    long long v43 = *(_OWORD *)(v8 + 8);
    long long v44 = *(_OWORD *)(v8 + 24);
    long long v45 = *(_OWORD *)(v8 + 40);
    *(_OWORD *)(v42 + 88) = *(_OWORD *)(v8 + 56);
    *(_OWORD *)(v42 + 72) = v45;
    *(_OWORD *)(v42 + 56) = v44;
    *(_OWORD *)(v42 + 40) = v43;
    long long v46 = *(_OWORD *)(v8 + 72);
    long long v47 = *(_OWORD *)(v8 + 88);
    long long v48 = *(_OWORD *)(v8 + 104);
    *(_OWORD *)(v42 + 148) = *(_OWORD *)(v8 + 116);
    *(_OWORD *)(v42 + 136) = v48;
    *(_OWORD *)(v42 + 120) = v47;
    *(_OWORD *)(v42 + 104) = v46;
    unint64_t v35 = *(void *)(a1->i64[1] + 8 * (a1[2].i64[0] / 0x17uLL)) + 176 * (a1[2].i64[0] % 0x17uLL);
    goto LABEL_37;
  }
  int v14 = v9 - 1;
  a1[40].i32[2] = v9 - 1;
  if (a1[1].i64[0] != v12)
  {
    unint64_t v15 = v11 + v9;
    double v16 = (uint64_t *)(v12 + 8 * (v15 / 0x17));
    uint64_t v17 = *v16;
    for (uint64_t i = *v16 + 176 * (v15 % 0x17); i != v13; i -= 176)
    {
      if (i == v17)
      {
        uint64_t v17 = *(v16 - 1);
        if (v10 >= *(double *)(v17 + 3880))
        {
LABEL_54:
          sub_10132DB24(a1, v16, i, a2);
          break;
        }
        a1[40].i32[2] = --v14;
        uint64_t i = v17 + 4048;
        --v16;
      }
      else
      {
        if (v10 >= *(double *)(i - 168)) {
          goto LABEL_54;
        }
        a1[40].i32[2] = --v14;
      }
    }
  }
LABEL_38:
  int v49 = 1;
  switch(a1[41].i32[1])
  {
    case 0:
    case 4:
      goto LABEL_42;
    case 1:
      unint64_t v50 = a1[2].u64[1];
      if (v50 < 3) {
        goto LABEL_44;
      }
      a1[41].i64[0] = 0x200000000;
      goto LABEL_49;
    case 3:
      int v49 = 2;
LABEL_42:
      a1[41].i32[1] = v49;
      goto LABEL_43;
    default:
LABEL_43:
      unint64_t v50 = a1[2].u64[1];
LABEL_44:
      a1[41].i32[0] = 0;
      if (v50 == 1)
      {
        long long v51 = *(std::__shared_weak_count **)(a2 + 24);
        uint64_t v59 = *(void *)(a2 + 16);
        std::string::size_type v60 = v51;
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        __int32 v58 = a1[24].i32[2];
        sub_100709780((uint64_t)a1[3].i64, (double *)(a2 + 8), &v59, &v58);
        long long v52 = v60;
        if (!v60) {
          break;
        }
LABEL_53:
        std::__shared_weak_count::__release_weak(v52);
        break;
      }
LABEL_49:
      if (a1[41].i8[8])
      {
        long long v53 = *(std::__shared_weak_count **)(a2 + 24);
        uint64_t v56 = *(void *)(a2 + 16);
        long long v57 = v53;
        if (v53) {
          atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100025538((uint64_t)a1[3].i64, (double *)(a2 + 8), &v56);
        long long v52 = v57;
        if (v57) {
          goto LABEL_53;
        }
      }
      break;
  }
LABEL_29:
  if (v7) {
    sub_1000DB0A0(v7);
  }
}

void sub_100188E90(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

__n128 sub_100188E9C(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a1 + 8) = result;
  *(_OWORD *)(a1 + 40) = xmmword_101D1C320;
  *(_OWORD *)(a1 + 56) = xmmword_101D1C320;
  *(_DWORD *)(a1 + 72) = -1;
  *(__n128 *)(a1 + 80) = result;
  *(__n128 *)(a1 + 96) = result;
  *(void *)(a1 + 112) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 124) = 0;
  return result;
}

void sub_100188ED8(uint64_t a1, uint64_t a2, double a3)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 76);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 4);
  if (*(double *)(a2 + 20) >= a3) {
    a3 = *(double *)(a2 + 20);
  }
  *(double *)(a1 + 40) = a3;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 28);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 44);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 + 84);
  *(void *)(a1 + 112) = *(void *)(a2 + 88);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 96);
  sub_1001C2684(*(long double *)(a1 + 24));
  sub_10005B720(*(long double *)(a1 + 32));
  if (*(double *)(a1 + 56) <= 0.0) {
    *(void *)(a1 + 48) = 0;
  }
  if (*(double *)(a1 + 88) <= 0.0) {
    *(void *)(a1 + 80) = 0xBFF0000000000000;
  }
  if (*(double *)(a1 + 104) <= 0.0)
  {
    *(void *)(a1 + 96) = 0xBFF0000000000000;
  }
  else
  {
    long double v4 = *(double *)(a1 + 96);
    if (v4 >= 0.0) {
      sub_100142F58(v4);
    }
  }
}

void sub_100188FA8(uint64_t a1, double *a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(a1 + 40);
  if (v6 >= 0x12D)
  {
    ++*(void *)(a1 + 32);
    *(void *)(a1 + 40) = v6 - 1;
    sub_10017D440(a1, 1);
  }
  *(double *)uint64_t buf = *a2;
  long long v7 = *(_OWORD *)(a3 + 64);
  long long v23 = *(_OWORD *)(a3 + 80);
  long long v8 = *(_OWORD *)(a3 + 112);
  long long v24 = *(_OWORD *)(a3 + 96);
  long long v25 = v8;
  long long v9 = *(_OWORD *)a3;
  long long v19 = *(_OWORD *)(a3 + 16);
  long long v10 = *(_OWORD *)(a3 + 48);
  long long v20 = *(_OWORD *)(a3 + 32);
  long long v21 = v10;
  long long v22 = v7;
  uint64_t v26 = *(void *)(a3 + 128);
  *(_OWORD *)&uint8_t buf[8] = v9;
  sub_10017D36C((void *)a1, (uint64_t)buf);
  int v11 = *(_DWORD *)(a1 + 72);
  sub_1000420FC(a1, a2, a3);
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022C21A0);
  }
  uint64_t v12 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    double v13 = *a2;
    int v14 = *(_DWORD *)a3;
    int v15 = *(_DWORD *)(a3 + 4);
    int v16 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)uint64_t buf = 134350080;
    *(double *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&unsigned char buf[14] = v14;
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v15;
    LOWORD(v19) = 1026;
    *(_DWORD *)((char *)&v19 + 2) = v11;
    WORD3(v19) = 1026;
    DWORD2(v19) = v16;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#motion,dynamics mode on motion update,mct,%{public}.3f,type,%{public}d,confidence,%{public}d,old dynamics mode,%{public}d,new dynamics mode,%{public}d", buf, 0x24u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022C21A0);
    }
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::LCFusionMotionActivity::motionActivityUpdate(const CFTimeInterval &, const CLMotionActivity &)", "%s\n", v17);
    if (v17 != buf) {
      free(v17);
    }
  }
}

void sub_100189250(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_10018925C(void *a1, double *a2)
{
  unint64_t v4 = a1[5];
  if (v4 >= 0x12D)
  {
    ++a1[4];
    a1[5] = v4 - 1;
    sub_10017D440((uint64_t)a1, 1);
  }
  sub_10017D36C(a1, (uint64_t)a2);

  return sub_1000420FC((uint64_t)a1, a2, (uint64_t)(a2 + 1));
}

BOOL sub_1001892D4(uint64_t a1, double *a2)
{
  if (*a2 >= 0.0)
  {
    if (*(unsigned char *)(a1 + 456) && *(unsigned char *)(a1 + 472))
    {
      uint64_t v6 = 0;
      double v7 = *(double *)(a1 + 448);
      double v8 = *(double *)(a1 + 464);
      double v9 = *(double *)(a1 + 184);
      double v10 = *(double *)(a1 + 192);
      double v11 = *(double *)(a1 + 208);
      double v12 = *(double *)(a1 + 216);
      double v13 = *(double *)(a1 + 224);
      double v14 = *(double *)(a1 + 248);
      double v15 = *(double *)(a1 + 256);
      double v16 = *(double *)(a1 + 288);
      double v17 = *(double *)(a1 + 176) + v7 * v12 + v7 * v10 + v7 * v7 * v15;
      *(double *)uint64_t buf = *(double *)(a1 + 168) + v7 * v9 * 2.0 + v7 * v7 * v14;
      double v24 = v17;
      double v18 = v7 * v8 * v14 + v8 * v9;
      double v19 = v7 * v8 * v15;
      double v25 = v18;
      double v26 = v19 + v8 * v10;
      double v29 = v19 + v8 * v12;
      double v30 = v7 * v8 * v16 + v8 * v13;
      double v33 = v8 * v8 * v14;
      double v34 = v8 * v8 * v15;
      double v27 = v17;
      double v28 = v11 + v7 * v13 * 2.0 + v7 * v7 * v16;
      double v31 = v18;
      double v32 = v29;
      double v35 = v26;
      double v36 = v30;
      double v37 = v34;
      double v38 = v8 * v8 * v16;
      do
      {
        *(float64x2_t *)(a1 + v6 + 168) = vaddq_f64(*(float64x2_t *)&buf[v6], *(float64x2_t *)(a1 + v6 + 40));
        v6 += 16;
      }
      while (v6 != 128);
      return 1;
    }
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022C5660);
    }
    long long v20 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      int v21 = *(_DWORD *)(a1 + 564);
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "KFCV:,ID,%{public}d,#Error,P propagation,elements of Phi not set", buf, 8u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 == -1)
      {
LABEL_21:
        long long v22 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::LCFusionKalmanFilterCV::propagateErrorCovMat(const double &)", "%s\n", v22);
        if (v22 != (char *)buf) {
          free(v22);
        }
        return 0;
      }
LABEL_24:
      dispatch_once(&qword_102419510, &stru_1022C5660);
      goto LABEL_21;
    }
  }
  else
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022C5660);
    }
    unint64_t v3 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      int v4 = *(_DWORD *)(a1 + 564);
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "KFCV:,ID,%{public}d,#Error,P propagation failed,dT < 0", buf, 8u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 == -1) {
        goto LABEL_21;
      }
      goto LABEL_24;
    }
  }
  return result;
}

void sub_1001896B4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_1001896C0(void *a1, uint64_t *a2, long long *a3)
{
  unint64_t v6 = a1[5];
  if (v6 >= 0xB)
  {
    ++a1[4];
    a1[5] = v6 - 1;
    sub_10017E0A8((uint64_t)a1, 1);
  }
  uint64_t v9 = *a2;
  long long v7 = a3[1];
  long long v10 = *a3;
  long long v11 = v7;
  long long v12 = a3[2];
  uint64_t v13 = *((void *)a3 + 6);
  return sub_10017D4A0(a1, (long long *)&v9);
}

__n128 sub_100189754(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)a1 = result;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = off_10232A710;
  *(__n128 *)(a1 + 40) = result;
  *(_OWORD *)(a1 + 72) = xmmword_101D1C320;
  *(_OWORD *)(a1 + 88) = xmmword_101D1C320;
  *(__n128 *)(a1 + 112) = result;
  *(__n128 *)(a1 + 128) = result;
  *(void *)(a1 + 144) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 156) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 168) = 0;
  return result;
}

uint64_t sub_1001897B4(uint64_t result, double **a2)
{
  uint64_t v2 = *(void *)(result + 56);
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = result + 56;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        long long v7 = (uint64_t *)v2;
      }
      else {
        long long v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != result + 56 && v3 >= *(_DWORD *)(v4 + 28))
    {
      double v8 = *a2;
      uint64_t v9 = a2[1];
      if (*a2 != v9)
      {
        *(unsigned char *)(v4 + 32) = 1;
        int v10 = *(_DWORD *)(v4 + 248);
        int v11 = *(_DWORD *)(v4 + 252);
        int v12 = *(_DWORD *)(v4 + 256);
        int v13 = *(_DWORD *)(v4 + 260);
        double v14 = v8;
        double v15 = *(double *)result;
        do
        {
          double v16 = *v14;
          if (*v14 <= 0.0 || v16 > v15)
          {
            double v18 = *(double *)(result + 8);
            if (v16 <= v15 || v16 > v18)
            {
              if (v16 > v18 && v16 <= *(double *)(result + 16)) {
                *(_DWORD *)(v4 + 256) = ++v12;
              }
              else {
                *(_DWORD *)(v4 + 260) = ++v13;
              }
            }
            else
            {
              *(_DWORD *)(v4 + 252) = ++v11;
            }
          }
          else
          {
            *(_DWORD *)(v4 + 248) = ++v10;
          }
          ++v14;
        }
        while (v14 != v9);
        long long v20 = v8 + 1;
        if (v8 + 1 != v9)
        {
          double v21 = *v8;
          long long v22 = v8 + 1;
          do
          {
            double v23 = *v22++;
            double v24 = v23;
            if (v21 < v23)
            {
              double v21 = v24;
              double v8 = v20;
            }
            long long v20 = v22;
          }
          while (v22 != v9);
        }
        unsigned int v25 = *v8;
        if (*(_DWORD *)(v4 + 56) < v25) {
          *(_DWORD *)(v4 + 56) = v25;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1001898DC(uint64_t result, double **a2)
{
  uint64_t v2 = *(void *)(result + 56);
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = result + 56;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        long long v7 = (uint64_t *)v2;
      }
      else {
        long long v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != result + 56 && v3 >= *(_DWORD *)(v4 + 28))
    {
      double v8 = *a2;
      uint64_t v9 = a2[1];
      if (*a2 != v9)
      {
        *(unsigned char *)(v4 + 32) = 1;
        int v10 = *(_DWORD *)(v4 + 200);
        int v11 = *(_DWORD *)(v4 + 204);
        int v12 = v8;
        int v13 = *(_DWORD *)(v4 + 208);
        __n128 result = *(unsigned int *)(v4 + 212);
        do
        {
          double v14 = *v12;
          if (*v12 <= 0.0 || v14 > 50.0)
          {
            if (v14 <= 50.0 || v14 > 100.0)
            {
              if (v14 <= 100.0 || v14 > 200.0)
              {
                __n128 result = (result + 1);
                *(_DWORD *)(v4 + 212) = result;
              }
              else
              {
                *(_DWORD *)(v4 + 208) = ++v13;
              }
            }
            else
            {
              *(_DWORD *)(v4 + 204) = ++v11;
            }
          }
          else
          {
            *(_DWORD *)(v4 + 200) = ++v10;
          }
          ++v12;
        }
        while (v12 != v9);
        double v18 = v8 + 1;
        if (v8 + 1 != v9)
        {
          double v19 = *v8;
          long long v20 = v8 + 1;
          do
          {
            double v21 = *v20++;
            double v22 = v21;
            if (v19 < v21)
            {
              double v19 = v22;
              double v8 = v18;
            }
            double v18 = v20;
          }
          while (v20 != v9);
        }
        unsigned int v23 = *v8;
        if (*(_DWORD *)(v4 + 60) < v23) {
          *(_DWORD *)(v4 + 60) = v23;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100189A0C(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 56);
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = result + 56;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        long long v7 = (uint64_t *)v2;
      }
      else {
        long long v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != result + 56 && v3 >= *(_DWORD *)(v4 + 28))
    {
      *(unsigned char *)(v4 + 32) = 1;
      switch(a2)
      {
        case 1u:
          double v8 = (_DWORD *)(v4 + 36);
          goto LABEL_18;
        case 2u:
          double v8 = (_DWORD *)(v4 + 40);
          goto LABEL_18;
        case 3u:
          double v8 = (_DWORD *)(v4 + 44);
          goto LABEL_18;
        case 4u:
          double v8 = (_DWORD *)(v4 + 48);
          goto LABEL_18;
        default:
          if (a2 < 5) {
            return result;
          }
          double v8 = (_DWORD *)(v4 + 52);
LABEL_18:
          ++*v8;
          break;
      }
    }
  }
  return result;
}

uint64_t sub_100189AC0(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 56);
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = result + 56;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        long long v7 = (uint64_t *)v2;
      }
      else {
        long long v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != result + 56 && v3 >= *(_DWORD *)(v4 + 28))
    {
      char v8 = *(unsigned char *)(v4 + 32);
      *(unsigned char *)(v4 + 32) = 1;
      switch(a2)
      {
        case 1:
          ++*(_DWORD *)(v4 + 128);
          break;
        case 2:
          ++*(_DWORD *)(v4 + 132);
          break;
        case 3:
          ++*(_DWORD *)(v4 + 136);
          break;
        case 4:
          ++*(_DWORD *)(v4 + 140);
          break;
        default:
          *(unsigned char *)(v4 + 32) = v8;
          break;
      }
    }
  }
  return result;
}

void sub_100189B88(uint64_t a1)
{
  double v2 = sub_10016C458();
  double v3 = v2;
  if (*(_DWORD *)(a1 + 24) == 4 && v2 - *(double *)(a1 + 32) > 900.0)
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 28);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022D4AB0);
    }
    uint64_t v4 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)uint64_t buf = 67240192;
      int v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#LCFusionStats,reverting visit exit likely context to,%{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022D4AB0);
      }
      double v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusionStats::submitMetrics()", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
  }
  double v6 = *(double *)(a1 + 80);
  if (v3 - *(double *)(a1 + 72) >= v6)
  {
    double v9 = *(double *)(a1 + 88);
    int v10 = *(void **)(a1 + 48);
    if (v10 != (void *)(a1 + 56))
    {
      do
      {
        sub_10095A57C(a1, (uint64_t)(v10 + 4), v6 < v9, *((_DWORD *)v10 + 7));
        int v11 = (void *)v10[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            int v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v10[2];
            BOOL v13 = *v12 == (void)v10;
            int v10 = v12;
          }
          while (!v13);
        }
        int v10 = v12;
      }
      while (v12 != (void *)(a1 + 56));
    }
    if (v6 >= v9) {
      sub_10095A4E0(a1);
    }
  }
  else
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022D4AB0);
    }
    long long v7 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#LCFusionStats,submitMetrics,less than threshold time to submit metrics", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022D4AB0);
      }
      char v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusionStats::submitMetrics()", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
}

void sub_100189F2C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_100189F38(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 56);
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = result + 56;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        long long v7 = (uint64_t *)v2;
      }
      else {
        long long v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != result + 56 && v3 >= *(_DWORD *)(v4 + 28))
    {
      char v8 = *(unsigned char *)(v4 + 32);
      *(unsigned char *)(v4 + 32) = 1;
      switch(a2)
      {
        case 0:
          ++*(_DWORD *)(v4 + 152);
          break;
        case 1:
          ++*(_DWORD *)(v4 + 156);
          break;
        case 3:
          ++*(_DWORD *)(v4 + 160);
          break;
        case 4:
          ++*(_DWORD *)(v4 + 164);
          break;
        case 5:
          ++*(_DWORD *)(v4 + 168);
          break;
        case 6:
          ++*(_DWORD *)(v4 + 172);
          break;
        case 7:
          ++*(_DWORD *)(v4 + 176);
          break;
        case 8:
          ++*(_DWORD *)(v4 + 180);
          break;
        case 9:
          ++*(_DWORD *)(v4 + 184);
          break;
        case 10:
          ++*(_DWORD *)(v4 + 188);
          break;
        default:
          *(unsigned char *)(v4 + 32) = v8;
          break;
      }
    }
  }
  return result;
}

uint64_t sub_10018A060(uint64_t result, int a2, int a3, int a4, int a5)
{
  uint64_t v5 = *(void *)(result + 56);
  if (v5)
  {
    int v6 = *(_DWORD *)(result + 24);
    uint64_t v7 = result + 56;
    do
    {
      int v8 = *(_DWORD *)(v5 + 28);
      BOOL v9 = v8 < v6;
      if (v8 >= v6) {
        int v10 = (uint64_t *)v5;
      }
      else {
        int v10 = (uint64_t *)(v5 + 8);
      }
      if (!v9) {
        uint64_t v7 = v5;
      }
      uint64_t v5 = *v10;
    }
    while (*v10);
    if (v7 != result + 56 && v6 >= *(_DWORD *)(v7 + 28))
    {
      *(unsigned char *)(v7 + 32) = 1;
      int v11 = *(_DWORD *)(v7 + 116) + a3;
      *(_DWORD *)(v7 + 112) += a2;
      *(_DWORD *)(v7 + 116) = v11;
      int v12 = *(_DWORD *)(v7 + 124) + a4;
      *(_DWORD *)(v7 + 120) += a5;
      *(_DWORD *)(v7 + 124) = v12;
    }
  }
  return result;
}

void sub_10018A0D0(uint64_t a1, uint64_t *a2)
{
  unsigned int v24 = 0;
  double v21 = 0;
  double v22 = 0;
  uint64_t v23 = 0;
  double v18 = 0;
  double v19 = 0;
  uint64_t v20 = 0;
  uint64_t v4 = a1 + 2272;
  sub_100189F38(a1 + 2272, *(_DWORD *)(a1 + 1912));
  sub_100189AC0(v4, *(_DWORD *)(*(void *)(a1 + 1696) + 392));
  sub_10018ABFC(a1, &v24, (char **)&v21, (double **)&v18);
  sub_100189A0C(v4, v24);
  sub_1001898DC(v4, (double **)&v18);
  sub_1001897B4(v4, &v21);
  uint64_t v5 = *(_DWORD **)(a1 + 1696);
  int v6 = v5[106];
  int v7 = v5[107];
  int v8 = v5[108];
  int v9 = v5[109];
  *((void *)v5 + 53) = 0;
  *((void *)v5 + 54) = 0;
  sub_10018A060(v4, v8, v9, v6, v7);
  uint64_t v10 = *a2;
  if (*a2)
  {
    int v11 = *(_DWORD *)(v10 + 128);
    if (v11 == 4)
    {
      double v15 = 0;
      int v16 = 0;
      uint64_t v17 = 0;
      long long __p = 0;
      BOOL v13 = 0;
      uint64_t v14 = 0;
      sub_100EA2464(a1, (double *)v10, (char **)&v15, (char **)&__p);
      sub_10095C5B4(v4, (double **)&v15);
      sub_10095C3C8(v4, (double **)&__p);
      if (__p)
      {
        BOOL v13 = __p;
        operator delete(__p);
      }
      if (v15)
      {
        int v16 = v15;
        operator delete(v15);
      }
    }
    else if (v11 == 1)
    {
      sub_100EA214C(a1, (double *)v10, (char **)&v21, (double **)&v18);
      sub_10095C4D0(v4, &v21, *(double *)(*a2 + 40));
      sub_10095C2C4(v4, (double **)&v18, *(double *)(*a2 + 40));
      if (*(_DWORD *)(a1 + 1096) != 1) {
        sub_10095C1B0(v4);
      }
    }
  }
  sub_100189B88(v4);
  if (v18)
  {
    double v19 = v18;
    operator delete(v18);
  }
  if (v21)
  {
    double v22 = v21;
    operator delete(v21);
  }
}

void sub_10018A27C(uint64_t a1, uint64_t *a2, int a3)
{
  if (*(_DWORD *)(a1 + 2160) != 4) {
    sub_100E9852C(a1);
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  int v6 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = *a2;
    *(_DWORD *)uint64_t buf = 134349312;
    uint64_t v10 = v7;
    __int16 v11 = 1026;
    int v12 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f, change in locationApp foreground status,isForeGround,%{public}d", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::locationAppForegroundStatusUpdate(const CFTimeInterval &, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  *(unsigned char *)(a1 + 2072) = a3;
}

void sub_10018A470(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_10018A47C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 2160) != 4) {
    sub_100E9852C(a1);
  }
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 128) = 0;
  *(unsigned char *)(a2 + 152) = 0;
  *(_DWORD *)a2 = 0xFFFF;
  *(void *)(a2 + 12) = 0;
  *(void *)(a2 + 4) = 0;
  *(_OWORD *)(a2 + 20) = xmmword_101D1C320;
  __asm { FMOV            V1.2D, #-1.0 }
  *(_OWORD *)(a2 + 36) = _Q1;
  *(_OWORD *)(a2 + 52) = _Q1;
  *(_OWORD *)(a2 + 68) = _Q1;
  *(_DWORD *)(a2 + 84) = 0;
  *(void *)(a2 + 88) = 0xBFF0000000000000;
  *(void *)(a2 + 116) = 0xBFF0000000000000;
  *(_DWORD *)(a2 + 124) = 0x7FFFFFFF;
  if (!*(_DWORD *)(a1 + 908))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v14 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "#fusion,invalid latest selected hypothesis in getting the latest predicted fused state", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    LOWORD(v22) = 0;
    double v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::getLatestPredictedFusedLocation(CLDaemonLocation &)", "%s\n", v15);
    goto LABEL_48;
  }
  long long v21 = _Q1;
  uint64_t v9 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  double v32 = sub_10016BA54(v9, buf);
  double v22 = off_10232A710;
  long long v23 = v21;
  long long v24 = xmmword_101D1C320;
  long long v25 = xmmword_101D1C320;
  long long v26 = v21;
  long long v27 = v21;
  unint64_t v28 = 0xBFF0000000000000;
  int v29 = 0;
  char v30 = 0;
  int v31 = 0;
  BOOL v10 = sub_100074400(a1 + 296, &v32);
  char v11 = sub_100070DA0(a1 + 296, (uint64_t)&v22);
  if (!v10 || (v11 & 1) == 0)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v16 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "#fusion,Failed to retrieve predicted estimate from the latest selected hypothesis.", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_47;
    }
    goto LABEL_50;
  }
  uint64_t v12 = sub_100022744(a1 + 248, &v32);
  int v31 = v12;
  if (!v12)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v17 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#fusion,,getLatestPredictedFusedLocation,fused location type is Unknown", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_47;
    }
    goto LABEL_50;
  }
  if (*(double *)&v24 <= 0.0)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v18 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "#fusion,getLatestPredictedFusedLocation failed, hunc <= 0", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_47;
    }
    goto LABEL_50;
  }
  if (!sub_1001807D0(v12, (uint64_t)&v22, a2))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v19 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "#fusion,getLatestPredictedFusedLocation,failed to convert to daemon location", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 == -1) {
      goto LABEL_47;
    }
LABEL_50:
    dispatch_once(&qword_102419510, &stru_1022FFA18);
LABEL_47:
    double v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::getLatestPredictedFusedLocation(CLDaemonLocation &)", "%s\n", v15);
LABEL_48:
    if (v15 != (char *)buf) {
      free(v15);
    }
    return 0;
  }
  uint64_t v13 = 1;
  *(_DWORD *)(a2 + 132) = 1;
  sub_1000318C0((uint64_t)&v22, (uint64_t)"#fusion,getLatestPredictedFusedLocation,output", 0);
  return v13;
}

void sub_10018ABF0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_10018ABFC(uint64_t a1, _DWORD *a2, char **a3, double **a4)
{
  *a2 = 0;
  a3[1] = *a3;
  a4[1] = *a4;
  uint64_t v4 = *(uint64_t **)(a1 + 240);
  if (v4)
  {
    uint64_t v39 = (uint64_t)(a3 + 2);
    uint64_t v40 = (uint64_t)(a4 + 2);
    __asm { FMOV            V0.2D, #-1.0 }
    long long v43 = _Q0;
    do
    {
      long long v55 = off_10232A710;
      long long v56 = v43;
      long long v57 = xmmword_101D1C320;
      long long v58 = xmmword_101D1C320;
      long long v59 = v43;
      long long v60 = v43;
      unint64_t v61 = 0xBFF0000000000000;
      int v62 = 0;
      char v63 = 0;
      int v64 = 0;
      if (*((_DWORD *)v4 + 167))
      {
        uint64_t v12 = v4[6];
        if (v12)
        {
          if (*(unsigned char *)(*(void *)(v4[2] + 8 * ((v12 + v4[5] - 1) / 0x17uLL))
                        + 176 * ((v12 + v4[5] - 1) % 0x17uLL)
                        + 168))
          {
            if (sub_100070DA0((uint64_t)(v4 + 7), (uint64_t)&v55))
            {
              if (*(double *)&v57 > 0.0)
              {
                ++*a2;
                uint64_t v13 = (uint64_t *)*v4;
                if (*v4)
                {
                  do
                  {
                    while (1)
                    {
                      long long v45 = off_10232A710;
                      long long v46 = v43;
                      long long v47 = xmmword_101D1C320;
                      long long v48 = xmmword_101D1C320;
                      long long v49 = v43;
                      long long v50 = v43;
                      unint64_t v51 = 0xBFF0000000000000;
                      int v52 = 0;
                      char v53 = 0;
                      int v54 = 0;
                      if (*((_DWORD *)v13 + 167))
                      {
                        uint64_t v14 = v13[6];
                        if (v14)
                        {
                          if (*(unsigned char *)(*(void *)(v13[2] + 8 * ((v14 + v13[5] - 1) / 0x17uLL))
                                        + 176 * ((v14 + v13[5] - 1) % 0x17uLL)
                                        + 168)
                            && sub_100070DA0((uint64_t)(v13 + 7), (uint64_t)&v45)
                            && *(double *)&v47 > 0.0)
                          {
                            break;
                          }
                        }
                      }
                      uint64_t v13 = (uint64_t *)*v13;
                      if (!v13) {
                        goto LABEL_51;
                      }
                    }
                    double v15 = sub_100EA1DFC(a1, (uint64_t)&v55, (uint64_t)&v45);
                    double v16 = v15;
                    double v44 = v15;
                    double v18 = a4[1];
                    unint64_t v17 = (unint64_t)a4[2];
                    if ((unint64_t)v18 >= v17)
                    {
                      uint64_t v20 = *a4;
                      uint64_t v21 = v18 - *a4;
                      unint64_t v22 = v21 + 1;
                      if ((unint64_t)(v21 + 1) >> 61) {
                        goto LABEL_53;
                      }
                      uint64_t v23 = v17 - (void)v20;
                      if (v23 >> 2 > v22) {
                        unint64_t v22 = v23 >> 2;
                      }
                      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v24 = v22;
                      }
                      if (v24)
                      {
                        long long v25 = (char *)sub_1000DA54C(v40, v24);
                        uint64_t v20 = *a4;
                        double v18 = a4[1];
                      }
                      else
                      {
                        long long v25 = 0;
                      }
                      long long v26 = (double *)&v25[8 * v21];
                      *long long v26 = v16;
                      double v19 = v26 + 1;
                      while (v18 != v20)
                      {
                        uint64_t v27 = *((void *)v18-- - 1);
                        *((void *)v26-- - 1) = v27;
                      }
                      *a4 = v26;
                      a4[1] = v19;
                      a4[2] = (double *)&v25[8 * v24];
                      if (v20) {
                        operator delete(v20);
                      }
                    }
                    else
                    {
                      double *v18 = v15;
                      double v19 = v18 + 1;
                    }
                    a4[1] = v19;
                    if (sub_100EA1E28(a1, (double *)&v55, (double *)&v45, &v44))
                    {
                      int v29 = a3[1];
                      unint64_t v28 = (unint64_t)a3[2];
                      if ((unint64_t)v29 >= v28)
                      {
                        int v31 = *a3;
                        uint64_t v32 = (v29 - *a3) >> 3;
                        unint64_t v33 = v32 + 1;
                        if ((unint64_t)(v32 + 1) >> 61) {
LABEL_53:
                        }
                          sub_1001D7FD4();
                        uint64_t v34 = v28 - (void)v31;
                        if (v34 >> 2 > v33) {
                          unint64_t v33 = v34 >> 2;
                        }
                        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
                          unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v35 = v33;
                        }
                        if (v35)
                        {
                          double v36 = (char *)sub_1000DA54C(v39, v35);
                          int v31 = *a3;
                          int v29 = a3[1];
                        }
                        else
                        {
                          double v36 = 0;
                        }
                        double v37 = &v36[8 * v32];
                        *(double *)double v37 = v44;
                        char v30 = v37 + 8;
                        while (v29 != v31)
                        {
                          uint64_t v38 = *((void *)v29 - 1);
                          v29 -= 8;
                          *((void *)v37 - 1) = v38;
                          v37 -= 8;
                        }
                        *a3 = v37;
                        a3[1] = v30;
                        a3[2] = &v36[8 * v35];
                        if (v31) {
                          operator delete(v31);
                        }
                      }
                      else
                      {
                        *(double *)int v29 = v44;
                        char v30 = v29 + 8;
                      }
                      a3[1] = v30;
                    }
                    uint64_t v13 = (uint64_t *)*v13;
                  }
                  while (v13);
                }
              }
            }
          }
        }
      }
LABEL_51:
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
}

BOOL sub_10018AFDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2)
  {
    uint64_t v5 = 1;
    int v6 = *(void **)(a1 + 240);
    do
    {
      int v6 = (void *)*v6;
      --v5;
    }
    while (v6);
    if (!v5)
    {
      *(_OWORD *)(v2 + 640) = xmmword_101D1C450;
      return 1;
    }
    uint64_t v7 = (uint64_t *)(a2 + 16);
    uint64_t v194 = *(void *)(a2 + 16);
    double v192 = 0.0;
    double v193 = 0.0;
    if (sub_1001BD27C((double *)(a1 + 1800), &v193, &v192, *(double *)(a2 + 24), *(double *)(a1 + 1704)))
    {
      double v12 = v192;
      double v11 = v193;
      v9.i64[0] = *(void *)(a2 + 24);
      v8.i64[0] = 0x400921FB54442D18;
      int8x16_t v188 = v8;
      if (fabs(*(double *)v9.i64) > 3.14159265)
      {
        v13.f64[0] = NAN;
        v13.f64[1] = NAN;
        double v185 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v13), v8, v9).i64;
        *(double *)v9.i64 = fmod(*(double *)v9.i64 + v185, 6.28318531) - v185;
      }
      if (*(double *)v9.i64 >= 1.57079633)
      {
        int8x16_t v14 = v188;
        *(double *)v9.i64 = *(double *)v188.i64 - *(double *)v9.i64;
      }
      else
      {
        if (*(double *)v9.i64 < -1.57079633) {
          *(double *)v9.i64 = -3.14159265 - *(double *)v9.i64;
        }
        int8x16_t v14 = v188;
      }
      v10.i64[0] = *(void *)(a2 + 32);
      double v184 = *(double *)v9.i64;
      if (fabs(*(double *)v10.i64) <= *(double *)v14.i64)
      {
        int8x16_t v187 = v10;
      }
      else
      {
        v19.f64[0] = NAN;
        v19.f64[1] = NAN;
        double v186 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v19), v14, v10).i64;
        *(double *)v20.i64 = fmod(*(double *)v10.i64 + v186, 6.28318531) - v186;
        int8x16_t v187 = v20;
      }
      BOOL v21 = sub_100E9CFB0(a1);
      double v182 = v12 * 0.0174532925;
      double v183 = v11 * 0.0174532925;
      if ((*(_DWORD *)(a2 + 128) & 0xFFFFFFFD) == 1)
      {
        *(double *)&long long __p = 0.0;
        __int16 v190 = 0;
        uint64_t v191 = 0;
        unint64_t v22 = *(uint64_t **)(a1 + 240);
        if (v22)
        {
          v23.f64[0] = NAN;
          v23.f64[1] = NAN;
          int8x16_t v165 = (int8x16_t)vnegq_f64(v23);
          double v178 = *(double *)vbslq_s8(v165, v188, v187).i64;
          int v173 = 0;
          double v24 = fmod(*(double *)v187.i64 + v178, 6.28318531) - v178;
          if (fabs(*(double *)v187.i64) <= *(double *)v188.i64) {
            double v25 = *(double *)v187.i64;
          }
          else {
            double v25 = v24;
          }
          double v162 = 0.0;
          double v26 = 25000000.0;
          __asm { FMOV            V0.2D, #-1.0 }
          long long v179 = _Q0;
          double v161 = 1.0;
          do
          {
            if ((*((_DWORD *)v22 + 167) & 0xFFFFFFFB) != 0)
            {
              uint64_t v209 = off_10232A710;
              *(_OWORD *)int v210 = v179;
              long long v211 = xmmword_101D1C320;
              long long v212 = xmmword_101D1C320;
              long long v213 = v179;
              long long v214 = v179;
              unint64_t v215 = 0xBFF0000000000000;
              int v216 = 0;
              char v217 = 0;
              int v218 = 0;
              BOOL v31 = sub_100074400((uint64_t)(v22 + 7), (double *)&v194);
              char v32 = sub_100070DA0((uint64_t)(v22 + 7), (uint64_t)&v209);
              unint64_t v33 = v22[6] + v22[5] - 1;
              *(double *)v34.i64 = sub_10132D590(*(void *)(v22[2] + 8 * (v33 / 0x17)) + 176 * (v33 % 0x17));
              if (v31 && (v32 & 1) != 0)
              {
                double v36 = *(double *)v34.i64;
                double v37 = *(double *)&v211;
                v35.i64[0] = *(void *)&v210[16];
                if (fabs(*(double *)&v210[16]) > *(double *)v188.i64)
                {
                  double v168 = *(double *)vbslq_s8(v165, v188, v35).i64;
                  *(double *)v35.i64 = fmod(*(double *)&v210[16] + v168, 6.28318531) - v168;
                }
                if (*(double *)v35.i64 >= 1.57079633)
                {
                  int8x16_t v38 = v188;
                  *(double *)v35.i64 = *(double *)v188.i64 - *(double *)v35.i64;
                }
                else
                {
                  if (*(double *)v35.i64 < -1.57079633) {
                    *(double *)v35.i64 = -3.14159265 - *(double *)v35.i64;
                  }
                  int8x16_t v38 = v188;
                }
                v34.i64[0] = *(void *)&v210[24];
                if (fabs(*(double *)&v210[24]) > *(double *)v38.i64)
                {
                  double v163 = *(double *)vbslq_s8(v165, v38, v34).i64;
                  uint64_t v169 = v35.i64[0];
                  *(double *)v34.i64 = fmod(*(double *)&v210[24] + v163, 6.28318531);
                  int8x16_t v38 = v188;
                  v35.i64[0] = v169;
                  *(double *)v34.i64 = *(double *)v34.i64 - v163;
                }
                if (vabdd_f64(*(double *)v187.i64, *(double *)v34.i64) <= *(double *)v38.i64)
                {
                  double v46 = *(double *)v187.i64 - *(double *)v34.i64;
                }
                else
                {
                  if (fabs(*(double *)v34.i64) > *(double *)v38.i64)
                  {
                    double v164 = *(double *)vbslq_s8(v165, v38, v34).i64;
                    uint64_t v170 = v35.i64[0];
                    *(double *)v34.i64 = fmod(*(double *)v34.i64 + v164, 6.28318531);
                    v38.i64[0] = v188.i64[0];
                    v35.i64[0] = v170;
                    *(double *)v34.i64 = *(double *)v34.i64 - v164;
                  }
                  double v42 = *(double *)v34.i64 - v25;
                  double v43 = dbl_101D94400[*(double *)v34.i64 - v25 > *(double *)v38.i64];
                  BOOL v44 = vabdd_f64(*(double *)v34.i64, v25) <= *(double *)v38.i64;
                  double v45 = -0.0;
                  if (!v44) {
                    double v45 = v43;
                  }
                  double v46 = *(double *)v187.i64 - (*(double *)v187.i64 + v42 + v45);
                }
                if (qword_102419510 != -1)
                {
                  uint64_t v171 = v35.i64[0];
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                  v35.i64[0] = v171;
                }
                double v47 = v36 * 50.0;
                double v48 = v183 * (v184 - *(double *)v35.i64) * (v183 * (v184 - *(double *)v35.i64))
                    + v182 * v46 * (v182 * v46);
                double v49 = sqrt(v48);
                long long v50 = qword_102419518;
                if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v51 = *(void *)(a2 + 16);
                  int v52 = *((_DWORD *)v22 + 165);
                  int v53 = *(_DWORD *)(a2 + 128);
                  uint64_t v54 = v22[80];
                  uint64_t v55 = v22[81];
                  *(_DWORD *)uint64_t buf = 134219520;
                  *(void *)uint64_t v220 = v51;
                  *(_WORD *)&v220[8] = 1024;
                  *(_DWORD *)&v220[10] = v52;
                  __int16 v221 = 2048;
                  double v222 = v49;
                  __int16 v223 = 2048;
                  double v224 = v47;
                  __int16 v225 = 1024;
                  *(_DWORD *)uint64_t v226 = v53;
                  *(_WORD *)&v226[4] = 2048;
                  *(void *)&v226[6] = v54;
                  __int16 v227 = 2048;
                  uint64_t v228 = v55;
                  _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "#selection,gps Likelihood update apriori,time_mct,%.3f,hID,%d,innov,%.5f,hypMaxInnov,%.5f,type,%d,likelihood,%.9f,logLikelihood,%.5f", buf, 0x40u);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  uint64_t v62 = *(void *)(a2 + 16);
                  int v63 = *((_DWORD *)v22 + 165);
                  int v64 = *(_DWORD *)(a2 + 128);
                  uint64_t v65 = v22[80];
                  uint64_t v66 = v22[81];
                  int v195 = 134219520;
                  uint64_t v196 = v62;
                  __int16 v197 = 1024;
                  int v198 = v63;
                  __int16 v199 = 2048;
                  double v200 = v49;
                  __int16 v201 = 2048;
                  double v202 = v47;
                  __int16 v203 = 1024;
                  int v204 = v64;
                  __int16 v205 = 2048;
                  uint64_t v206 = v65;
                  __int16 v207 = 2048;
                  uint64_t v208 = v66;
                  double v67 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v67);
                  if (v67 != (char *)buf) {
                    free(v67);
                  }
                }
                double v56 = 5000.0;
                if (v47 >= 5000.0) {
                  double v56 = v47;
                }
                if (v49 < v56)
                {
                  *(_DWORD *)uint64_t buf = *((_DWORD *)v22 + 165);
                  sub_100EA00C4((uint64_t)&__p, (char *)__p, buf);
                  double v57 = v37 * v37 * 0.5 + *(double *)(a2 + 40) * *(double *)(a2 + 40) * 0.5;
                  if (v48 < v57 * 9.0 && v48 < v26)
                  {
                    int v173 = *((_DWORD *)v22 + 165);
                    double v162 = exp(v48 * -0.5 / v57);
                    double v161 = 1.0 - *((double *)v22 + 80) * v162;
                    double v26 = v48;
                  }
                }
              }
              else
              {
                if (qword_102419510 != -1) {
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                }
                uint64_t v39 = qword_102419518;
                if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v40 = *v7;
                  int v41 = *((_DWORD *)v22 + 165);
                  *(_DWORD *)uint64_t buf = 134218240;
                  *(void *)uint64_t v220 = v40;
                  *(_WORD *)&v220[8] = 1024;
                  *(_DWORD *)&v220[10] = v41;
                  _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "#selection,time_mct,%.3f,Hypothesis %d does not have a valid estimate", buf, 0x12u);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  uint64_t v59 = *v7;
                  int v60 = *((_DWORD *)v22 + 165);
                  int v195 = 134218240;
                  uint64_t v196 = v59;
                  __int16 v197 = 1024;
                  int v198 = v60;
                  unint64_t v61 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v61);
                  if (v61 != (char *)buf) {
                    free(v61);
                  }
                }
                BOOL v21 = 0;
              }
            }
            unint64_t v22 = (uint64_t *)*v22;
          }
          while (v22);
          __int16 v130 = *(uint64_t **)(a1 + 240);
          double v132 = v161;
          double v131 = v162;
          if (v130)
          {
            double v133 = log(v161);
            double v134 = log(v161 + v162);
            do
            {
              if ((*((_DWORD *)v130 + 167) & 0xFFFFFFFB) != 0)
              {
                __int32 v135 = *((_DWORD *)v130 + 165);
                if (v135 == v173)
                {
                  *((double *)v130 + 81) = v134 + *((double *)v130 + 81);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  id v136 = qword_102419518;
                  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                  {
                    int v137 = *((_DWORD *)v130 + 165);
                    double v138 = *(double *)(a2 + 40);
                    uint64_t v139 = v130[81];
                    *(_DWORD *)uint64_t buf = 67110144;
                    *(_DWORD *)uint64_t v220 = v137;
                    *(_WORD *)&v220[4] = 2048;
                    *(double *)&v220[6] = v131;
                    __int16 v221 = 2048;
                    double v222 = v132;
                    __int16 v223 = 2048;
                    double v224 = v138;
                    __int16 v225 = 2048;
                    *(void *)uint64_t v226 = v139;
                    _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update gaussian aposteriori,hID,%d,gaussianProb,%.9f,uniformProb,%.9f,rootS,%.5f,loglikelihood,%.5f", buf, 0x30u);
                  }
                  if (!sub_10013D1A0(115, 2)) {
                    goto LABEL_203;
                  }
                  bzero(buf, 0x65CuLL);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  int v140 = *((_DWORD *)v130 + 165);
                  uint64_t v141 = *(void *)(a2 + 40);
                  uint64_t v142 = v130[81];
                  LODWORD(v209) = 67110144;
                  HIDWORD(v209) = v140;
                  *(_WORD *)int v210 = 2048;
                  *(double *)&v210[2] = v131;
                  *(_WORD *)&v210[10] = 2048;
                  *(double *)&v210[12] = v132;
                  *(_WORD *)&v210[20] = 2048;
                  *(void *)&v210[22] = v141;
                  *(_WORD *)&v210[30] = 2048;
                  *(void *)&long long v211 = v142;
                  uint64_t v143 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v143);
                  goto LABEL_195;
                }
                __int16 v144 = v190;
                unsigned int v145 = wmemchr((__int32 *)__p, v135, ((char *)v190 - (unsigned char *)__p) >> 2);
                if (v145) {
                  __int16 v146 = v145;
                }
                else {
                  __int16 v146 = v144;
                }
                if (v146 == v190)
                {
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  int v153 = qword_102419518;
                  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                  {
                    int v154 = *((_DWORD *)v130 + 165);
                    uint64_t v155 = v130[81];
                    *(_DWORD *)uint64_t buf = 67109376;
                    *(_DWORD *)uint64_t v220 = v154;
                    *(_WORD *)&v220[4] = 2048;
                    *(void *)&v220[6] = v155;
                    _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update hypothesis too far from fix,hID,%d outlier rejection for this fix,loglikelihood,%.5f", buf, 0x12u);
                  }
                  if (sub_10013D1A0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_102419510 != -1) {
                      dispatch_once(&qword_102419510, &stru_1022FFA18);
                    }
                    int v156 = *((_DWORD *)v130 + 165);
                    uint64_t v157 = v130[81];
                    LODWORD(v209) = 67109376;
                    HIDWORD(v209) = v156;
                    *(_WORD *)int v210 = 2048;
                    *(void *)&v210[2] = v157;
                    __int16 v158 = (char *)_os_log_send_and_compose_impl();
                    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v158);
                    double v132 = v161;
                    double v131 = v162;
                    if (v158 != (char *)buf) {
                      free(v158);
                    }
                  }
                  sub_10095C20C(a1 + 2272);
                  goto LABEL_203;
                }
                *((double *)v130 + 81) = v133 + *((double *)v130 + 81);
                if (qword_102419510 != -1) {
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                }
                uint64_t v147 = qword_102419518;
                if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
                {
                  int v148 = *((_DWORD *)v130 + 165);
                  double v149 = *(double *)(a2 + 40);
                  double v150 = *((double *)v130 + 81);
                  *(_DWORD *)uint64_t buf = 67109888;
                  *(_DWORD *)uint64_t v220 = v148;
                  *(_WORD *)&v220[4] = 2048;
                  *(double *)&v220[6] = v132;
                  __int16 v221 = 2048;
                  double v222 = v149;
                  __int16 v223 = 2048;
                  double v224 = v150;
                  _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update gaussian aposteriori,hID,%d,uniformProb,%.9f,rootS,%.5f,loglikelihood,%.5f", buf, 0x26u);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_102419510 != -1) {
                    dispatch_once(&qword_102419510, &stru_1022FFA18);
                  }
                  uint64_t v151 = *(void *)(a2 + 40);
                  uint64_t v152 = v130[81];
                  uint64_t v209 = (uint64_t (**)())__PAIR64__(*((_DWORD *)v130 + 165), 67109888);
                  *(_WORD *)int v210 = 2048;
                  double v132 = v161;
                  *(double *)&v210[2] = v161;
                  *(_WORD *)&v210[10] = 2048;
                  *(void *)&v210[12] = v151;
                  *(_WORD *)&v210[20] = 2048;
                  *(void *)&v210[22] = v152;
                  uint64_t v143 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v143);
                  double v131 = v162;
LABEL_195:
                  if (v143 != (char *)buf) {
                    free(v143);
                  }
                }
              }
LABEL_203:
              __int16 v130 = (uint64_t *)*v130;
            }
            while (v130);
          }
          if (*(double *)&__p != 0.0)
          {
            __int16 v190 = (__int32 *)__p;
            operator delete(__p);
          }
        }
LABEL_211:
        if (!v21 || !sub_100E9CFB0(a1))
        {
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          uint64_t v159 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update failed. Resetting all likelihoods to be equal", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            LOWORD(v209) = 0;
            __int16 v160 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v160);
            if (v160 != (char *)buf) {
              free(v160);
            }
          }
          sub_100EA0268(a1);
          return 0;
        }
        return 1;
      }
      long long v68 = *(uint64_t **)(a1 + 240);
      if (!v68) {
        goto LABEL_211;
      }
      v69.f64[0] = NAN;
      v69.f64[1] = NAN;
      int8x16_t v172 = (int8x16_t)vnegq_f64(v69);
      double v180 = *(double *)vbslq_s8(v172, v188, v187).i64;
      double v70 = fmod(*(double *)v187.i64 + v180, 6.28318531) - v180;
      if (fabs(*(double *)v187.i64) <= *(double *)v188.i64) {
        double v71 = *(double *)v187.i64;
      }
      else {
        double v71 = v70;
      }
      __asm { FMOV            V0.2D, #-1.0 }
      long long v181 = _Q0;
      while (1)
      {
        if ((*((_DWORD *)v68 + 167) & 0xFFFFFFFB) != 0)
        {
          uint64_t v209 = off_10232A710;
          *(_OWORD *)int v210 = v181;
          long long v211 = xmmword_101D1C320;
          long long v212 = xmmword_101D1C320;
          long long v213 = v181;
          long long v214 = v181;
          unint64_t v215 = 0xBFF0000000000000;
          int v216 = 0;
          char v217 = 0;
          int v218 = 0;
          BOOL v73 = sub_100074400((uint64_t)(v68 + 7), (double *)&v194);
          char v74 = sub_100070DA0((uint64_t)(v68 + 7), (uint64_t)&v209);
          unint64_t v75 = v68[6] + v68[5] - 1;
          double v78 = sub_10132D590(*(void *)(v68[2] + 8 * (v75 / 0x17)) + 176 * (v75 % 0x17)) * 50.0;
          *(double *)&long long __p = v78;
          if (!v73 || (v74 & 1) == 0)
          {
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            char v80 = qword_102419518;
            if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v81 = *v7;
              int v82 = *((_DWORD *)v68 + 165);
              *(_DWORD *)uint64_t buf = 134218240;
              *(void *)uint64_t v220 = v81;
              *(_WORD *)&v220[8] = 1024;
              *(_DWORD *)&v220[10] = v82;
              _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEBUG, "#selection,time_mct,%.3f,Hypothesis %d does not have a valid estimate", buf, 0x12u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              uint64_t v117 = *v7;
              int v118 = *((_DWORD *)v68 + 165);
              int v195 = 134218240;
              uint64_t v196 = v117;
              __int16 v197 = 1024;
              int v198 = v118;
              uint64_t v119 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v119);
              if (v119 != (char *)buf) {
                free(v119);
              }
            }
            BOOL v21 = 0;
            goto LABEL_156;
          }
          v77.i64[0] = *(void *)&v210[16];
          if (fabs(*(double *)&v210[16]) > *(double *)v188.i64)
          {
            double v174 = *(double *)vbslq_s8(v172, v188, v77).i64;
            *(double *)v77.i64 = fmod(*(double *)&v210[16] + v174, 6.28318531) - v174;
          }
          if (*(double *)v77.i64 >= 1.57079633)
          {
            int8x16_t v79 = v188;
            *(double *)v77.i64 = *(double *)v188.i64 - *(double *)v77.i64;
          }
          else
          {
            if (*(double *)v77.i64 < -1.57079633) {
              *(double *)v77.i64 = -3.14159265 - *(double *)v77.i64;
            }
            int8x16_t v79 = v188;
          }
          v76.i64[0] = *(void *)&v210[24];
          if (fabs(*(double *)&v210[24]) > *(double *)v79.i64)
          {
            double v166 = *(double *)vbslq_s8(v172, v79, v76).i64;
            uint64_t v175 = v77.i64[0];
            *(double *)v76.i64 = fmod(*(double *)&v210[24] + v166, 6.28318531);
            int8x16_t v79 = v188;
            v77.i64[0] = v175;
            *(double *)v76.i64 = *(double *)v76.i64 - v166;
          }
          if (vabdd_f64(*(double *)v187.i64, *(double *)v76.i64) <= *(double *)v79.i64)
          {
            double v86 = *(double *)v187.i64 - *(double *)v76.i64;
          }
          else
          {
            if (fabs(*(double *)v76.i64) > *(double *)v79.i64)
            {
              double v167 = *(double *)vbslq_s8(v172, v79, v76).i64;
              uint64_t v176 = v77.i64[0];
              *(double *)v76.i64 = fmod(*(double *)v76.i64 + v167, 6.28318531);
              v79.i64[0] = v188.i64[0];
              v77.i64[0] = v176;
              *(double *)v76.i64 = *(double *)v76.i64 - v167;
            }
            double v83 = *(double *)v76.i64 - v71;
            double v84 = dbl_101D94400[*(double *)v76.i64 - v71 > *(double *)v79.i64];
            BOOL v44 = vabdd_f64(*(double *)v76.i64, v71) <= *(double *)v79.i64;
            double v85 = -0.0;
            if (!v44) {
              double v85 = v84;
            }
            double v86 = *(double *)v187.i64 - (*(double *)v187.i64 + v83 + v85);
          }
          if (qword_102419510 != -1)
          {
            uint64_t v177 = v77.i64[0];
            dispatch_once(&qword_102419510, &stru_1022FFA18);
            v77.i64[0] = v177;
          }
          double v87 = sqrt(v183 * (v184 - *(double *)v77.i64) * (v183 * (v184 - *(double *)v77.i64)) + v182
                                                                                               * v86
                                                                                               * (v182
                                                                                                * v86));
          uint64_t v88 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v89 = *(void *)(a2 + 16);
            int v90 = *((_DWORD *)v68 + 165);
            int v91 = *(_DWORD *)(a2 + 128);
            uint64_t v92 = v68[80];
            uint64_t v93 = v68[81];
            *(_DWORD *)uint64_t buf = 134219520;
            *(void *)uint64_t v220 = v89;
            *(_WORD *)&v220[8] = 1024;
            *(_DWORD *)&v220[10] = v90;
            __int16 v221 = 2048;
            double v222 = v87;
            __int16 v223 = 2048;
            double v224 = v78;
            __int16 v225 = 1024;
            *(_DWORD *)uint64_t v226 = v91;
            *(_WORD *)&v226[4] = 2048;
            *(void *)&v226[6] = v92;
            __int16 v227 = 2048;
            uint64_t v228 = v93;
            _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEBUG, "#selection,non-gps Likelihood update apriori,time_mct,%.3f,hID,%d,innov,%.5f,hypMaxInnov,%.5f,type,%d,likelihood,%.9f,logLikelihood,%.5f", buf, 0x40u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            uint64_t v120 = *(void *)(a2 + 16);
            int v121 = *((_DWORD *)v68 + 165);
            int v122 = *(_DWORD *)(a2 + 128);
            uint64_t v123 = v68[80];
            uint64_t v124 = v68[81];
            int v195 = 134219520;
            uint64_t v196 = v120;
            __int16 v197 = 1024;
            int v198 = v121;
            __int16 v199 = 2048;
            double v200 = v87;
            __int16 v201 = 2048;
            double v202 = v78;
            __int16 v203 = 1024;
            int v204 = v122;
            __int16 v205 = 2048;
            uint64_t v206 = v123;
            __int16 v207 = 2048;
            uint64_t v208 = v124;
            double v125 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v125);
            if (v125 != (char *)buf) {
              free(v125);
            }
          }
          double v94 = *(double *)(a2 + 40);
          if ((*(_DWORD *)(a2 + 128) - 6) >= 3
            && (sub_100022744((uint64_t)(v68 + 1), (double *)(a2 + 16)),
                double v78 = *(double *)&__p,
                (*((_DWORD *)v68 + 180) - 6) > 2))
          {
            p_p = &__p;
            if (*(double *)&__p < 5000.0) {
              p_p = (void **)&unk_101D944E0;
            }
          }
          else
          {
            p_p = (void **)&unk_101D944D8;
            if (v78 >= 10000.0) {
              p_p = &__p;
            }
          }
          double v96 = fabs(v87);
          if (v96 < v94)
          {
            double v97 = *(double *)&v211;
            double v98 = erf((v94 - v87) / *(double *)&v211);
            long double v99 = erf((-v94 - v87) / v97);
            double v100 = log(v98 - v99);
            *((long double *)v68 + 81) = *((double *)v68 + 81) + v100 - log((v94 + v94) * v97);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            __int16 v101 = qword_102419518;
            if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v102 = *v7;
              int v103 = *((_DWORD *)v68 + 165);
              double v104 = *((double *)v68 + 81);
              *(_DWORD *)uint64_t buf = 134218496;
              *(void *)uint64_t v220 = v102;
              *(_WORD *)&v220[8] = 1024;
              *(_DWORD *)&v220[10] = v103;
              __int16 v221 = 2048;
              double v222 = v104;
              _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update uniform aposteriori,time_mct,%.3f,hID,%d,logLikelihood,%.5f", buf, 0x1Cu);
            }
            if (!sub_10013D1A0(115, 2)) {
              goto LABEL_156;
            }
            bzero(buf, 0x65CuLL);
            if (qword_102419510 == -1) {
              goto LABEL_148;
            }
LABEL_170:
            dispatch_once(&qword_102419510, &stru_1022FFA18);
LABEL_148:
            uint64_t v109 = *v7;
            int v110 = *((_DWORD *)v68 + 165);
            double v111 = *((double *)v68 + 81);
            int v195 = 134218496;
            uint64_t v196 = v109;
            __int16 v197 = 1024;
            int v198 = v110;
            __int16 v199 = 2048;
            double v200 = v111;
            uint64_t v112 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v112);
            if (v112 != (char *)buf) {
              free(v112);
            }
            goto LABEL_156;
          }
          if (v96 >= *(double *)p_p)
          {
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            long long v113 = qword_102419518;
            if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v114 = *v7;
              int v115 = *((_DWORD *)v68 + 165);
              double v116 = *((double *)v68 + 81);
              *(_DWORD *)uint64_t buf = 134218496;
              *(void *)uint64_t v220 = v114;
              *(_WORD *)&v220[8] = 1024;
              *(_DWORD *)&v220[10] = v115;
              __int16 v221 = 2048;
              double v222 = v116;
              _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update hypothesis too far from fix,time_mct,%.3f,hID,%d,outlier rejection for this fix,logLikelihood,%.5f", buf, 0x1Cu);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              uint64_t v126 = *v7;
              int v127 = *((_DWORD *)v68 + 165);
              double v128 = *((double *)v68 + 81);
              int v195 = 134218496;
              uint64_t v196 = v126;
              __int16 v197 = 1024;
              int v198 = v127;
              __int16 v199 = 2048;
              double v200 = v128;
              uint64_t v129 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v129);
              if (v129 != (char *)buf) {
                free(v129);
              }
            }
            sub_10095C20C(a1 + 2272);
            goto LABEL_156;
          }
          *((double *)v68 + 81) = *((double *)v68 + 81) + fmin(-log((v94 + v94) * *(double *)&v211), -8.0);
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          unint64_t v105 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v106 = *v7;
            int v107 = *((_DWORD *)v68 + 165);
            double v108 = *((double *)v68 + 81);
            *(_DWORD *)uint64_t buf = 134218496;
            *(void *)uint64_t v220 = v106;
            *(_WORD *)&v220[8] = 1024;
            *(_DWORD *)&v220[10] = v107;
            __int16 v221 = 2048;
            double v222 = v108;
            _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEBUG, "#selection,Likelihood update uniform walkout aposteriori,time_mct,%.3f,hID,%d,logLikelihood,%.5f", buf, 0x1Cu);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 == -1) {
              goto LABEL_148;
            }
            goto LABEL_170;
          }
        }
LABEL_156:
        long long v68 = (uint64_t *)*v68;
        if (!v68) {
          goto LABEL_211;
        }
      }
    }
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v18 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "#Error,fusion likelihood update, calc_dNdE failed", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 0);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      LOWORD(v209) = 0;
      unint64_t v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v17);
LABEL_30:
      if (v17 != (char *)buf) {
        free(v17);
      }
      return 0;
    }
  }
  else
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v15 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#selection,No valid hypothesis available for likelihood update", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      LOWORD(v209) = 0;
      unint64_t v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::updateHypothesesLikelihoods(const LCFusionProviderLocation &)", "%s\n", v17);
      goto LABEL_30;
    }
  }
  return result;
}

void sub_10018CDCC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1001C7F8C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10018CDEC(uint64_t a1)
{
  for (uint64_t i = *(uint64_t **)(a1 + 240); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 167))
    {
      unint64_t v2 = i[6];
      if (v2 >= 2)
      {
        unint64_t v3 = *((unsigned int *)i + 164);
        if ((v3 & 0x80000000) == 0 && v2 > v3 && !sub_100048BC8((uint64_t)(i + 1)))
        {
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          uint64_t v4 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_INFO))
          {
            int v5 = *((_DWORD *)i + 165);
            *(_DWORD *)uint64_t buf = 67240192;
            int v9 = v5;
            _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "#fusion,hID,%{public}d,hypothesis data fusion failed.", buf, 8u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            int v6 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "auto cllcf::CLLCFusion::performHypothesesDataFusion()::(anonymous class)::operator()(LCFusionLocationHypothesis &) const", "%s\n", v6);
            if (v6 != (char *)buf) {
              free(v6);
            }
          }
        }
      }
    }
  }
  return 1;
}

void sub_10018D004(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_10018D010(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned char **)(a1 + 2088);
  if (v4 && v4[1] && *v4)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v5 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#selection,CarPlay mode returning max likelihood hypothesis", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      *(_WORD *)int v122 = 0;
      uint64_t v106 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v106);
      if (v106 != buf) {
        free(v106);
      }
    }
    return sub_100E9D860(a1, a2);
  }
  uint64_t v7 = *(uint64_t **)(a1 + 240);
  if (!v7)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int8x16_t v10 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "#Error,#selection,No valid hypothesis available for selection,passthrough the location", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      *(_WORD *)int v122 = 0;
      unint64_t v105 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v105);
      if (v105 != buf) {
        free(v105);
      }
    }
    long long v11 = *(_OWORD *)(a2 + 8);
    long long v12 = *(_OWORD *)(a2 + 24);
    long long v13 = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 1008) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 1024) = v13;
    *(_OWORD *)(a1 + 976) = v11;
    *(_OWORD *)(a1 + 992) = v12;
    long long v14 = *(_OWORD *)(a2 + 72);
    long long v15 = *(_OWORD *)(a2 + 88);
    long long v16 = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a1 + 1084) = *(_OWORD *)(a2 + 116);
    *(_OWORD *)(a1 + 1072) = v16;
    *(_OWORD *)(a1 + 1056) = v15;
    *(_OWORD *)(a1 + 1040) = v14;
    return 1;
  }
  uint64_t v8 = 1;
  int v9 = *(void **)(a1 + 240);
  do
  {
    int v9 = (void *)*v9;
    --v8;
  }
  while (v9);
  if (!v8)
  {
    int v17 = *((_DWORD *)v7 + 167);
    if (v17
      && (uint64_t v18 = v7[6]) != 0
      && *(unsigned char *)(*(void *)(v7[2] + 8 * ((v18 + v7[5] - 1) / 0x17uLL)) + 176 * ((v18 + v7[5] - 1) % 0x17uLL) + 168))
    {
      if (v17 == 4)
      {
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        float64x2_t v19 = qword_102419518;
        if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "#selection,only available hypothesis is a gross outlier, rejecting", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          *(_WORD *)int v122 = 0;
          uint64_t v114 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v114);
          if (v114 != buf) {
            free(v114);
          }
        }
        uint64_t result = 0;
        int v20 = 5;
        goto LABEL_192;
      }
      sub_100E9CBC4((uint64_t)v122);
      if (sub_100074400((uint64_t)(v7 + 7), (double *)(a2 + 16))
        && (sub_100070DA0((uint64_t)(v7 + 7), (uint64_t)v122) & 1) != 0)
      {
        *(_DWORD *)&v123[104] = sub_100022744((uint64_t)(v7 + 1), (double *)(a2 + 16));
        uint64_t v69 = a1 + 248;
        uint64_t v70 = (uint64_t)(v7 + 1);
        goto LABEL_185;
      }
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      long long v95 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "#Error,#selection,Failed to retrieve estimate from the only available hypothesis", buf, 2u);
      }
      if (!sub_10013D1A0(115, 0)) {
        goto LABEL_191;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      unint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v22);
    }
    else
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      BOOL v21 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "#selection,only available hypothesis is invalid fused hypothesis, rejecting", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_191;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      *(_WORD *)int v122 = 0;
      unint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v22);
    }
    if (v22 != buf) {
      free(v22);
    }
    goto LABEL_191;
  }
  int v121 = 1;
  if (!*(unsigned char *)(a1 + 2096))
  {
    double v23 = *(double *)(a1 + 2104);
    if (v23 <= 0.0 || v23 + 6.0 <= *(double *)(a2 + 16)) {
      int v121 = 0;
    }
  }
  unsigned int v24 = 0;
  int v25 = 0;
  uint64_t v119 = 0;
  double v26 = (double *)(a2 + 16);
  do
  {
    unint64_t v27 = v7[5] + v7[6];
    uint64_t v28 = v7[2];
    uint64_t v29 = v7[3];
    char v30 = (void *)(v28 + 8 * (v27 / 0x17));
    if (v29 == v28) {
      unint64_t v31 = 0;
    }
    else {
      unint64_t v31 = *v30 + 176 * (v27 % 0x17);
    }
    while (1)
    {
      if (v29 == v28) {
        unint64_t v32 = 0;
      }
      else {
        unint64_t v32 = *(void *)(v28 + 8 * (v7[5] / 0x17uLL)) + 176 * (v7[5] % 0x17uLL);
      }
      if (v31 == v32) {
        goto LABEL_69;
      }
      if (v31 == *v30)
      {
        uint64_t v34 = *(v30 - 1);
        if (!*(unsigned char *)(v34 + 4040)) {
          goto LABEL_69;
        }
        unint64_t v33 = v34 + 4048;
      }
      else
      {
        unint64_t v33 = v31;
        if (!*(unsigned char *)(v31 - 8)) {
          goto LABEL_69;
        }
      }
      if (sub_100022DBC(v33 - 176, v26) > 31.0)
      {
LABEL_69:
        int v37 = *((_DWORD *)v7 + 167);
        goto LABEL_70;
      }
      if (v31 == *v30) {
        break;
      }
      unint64_t v35 = v31;
      if (*(unsigned char *)(v31 - 20)) {
        goto LABEL_64;
      }
LABEL_68:
      v31 -= 176;
      uint64_t v28 = v7[2];
      uint64_t v29 = v7[3];
    }
    uint64_t v36 = *(v30 - 1);
    if (!*(unsigned char *)(v36 + 4028)) {
      goto LABEL_67;
    }
    unint64_t v35 = v36 + 4048;
LABEL_64:
    if (*(_DWORD *)(v35 - 16) != 4 || (int v37 = *((_DWORD *)v7 + 167), v37 == 4))
    {
      if (v31 != *v30) {
        goto LABEL_68;
      }
LABEL_67:
      uint64_t v38 = *--v30;
      unint64_t v31 = v38 + 4048;
      goto LABEL_68;
    }
    ++v25;
    uint64_t v119 = v7;
LABEL_70:
    if ((v37 & 0xFFFFFFFB) != 0) {
      ++v24;
    }
    uint64_t v7 = (uint64_t *)*v7;
  }
  while (v7);
  if (v25 < 1)
  {
    uint64_t v118 = 0;
    BOOL v39 = 0;
    BOOL v46 = 0;
    double v45 = -1.0;
    uint64_t v44 = 0;
  }
  else
  {
    BOOL v39 = sub_1000171E8((void *)(a1 + 1840), &dbl_101D944D0);
    uint64_t v40 = *(void *)(a1 + 1696);
    double v41 = *(double *)(v40 + 384);
    if (v41 >= 0.0)
    {
      int v42 = *(void *)(v40 + 392) - 1 < 2 || v39;
      if (*v26 < v41 || *v26 - v41 <= 6.0) {
        BOOL v39 = v42;
      }
    }
    sub_100E9D7D0(v40, (uint64_t)buf);
    double v45 = *(double *)buf;
    uint64_t v44 = *(void *)&buf[8];
    uint64_t v118 = *(void *)v125;
    BOOL v46 = *(double *)&buf[8] <= 25.0;
    if (*(double *)buf < 0.0 || *v26 >= *(double *)buf && *v26 - *(double *)buf > 6.0)
    {
      *(void *)uint64_t buf = 0xBFF0000000000000;
      if ((sub_100031028(a1 + 1840, (double *)buf) & 1) == 0 && !sub_100180714(a1 + 1840))
      {
        *(void *)int v122 = 0xBFF0000000000000;
        if (!sub_1000171E8((void *)(a1 + 1840), (double *)v122))
        {
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          double v47 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            double v48 = *v26;
            *(_DWORD *)uint64_t buf = 134349824;
            *(double *)&uint8_t buf[4] = v48;
            *(_WORD *)&unsigned char buf[12] = 2050;
            *(double *)&unsigned char buf[14] = v45;
            *(_WORD *)&buf[22] = 2050;
            *(void *)double v125 = v44;
            *(_WORD *)&v125[8] = 2050;
            *(void *)&v125[10] = v118;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEBUG, "#selection,IO data usage timed out,location_mct,%{public}.3f,IO_mct,%{public}.3f,IO_DistanceMoved_m,%{public}.1f,DistanceMovedInterval_s,%{public}.2f", buf, 0x2Au);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            double v115 = *v26;
            *(_DWORD *)int v122 = 134349824;
            *(double *)&v122[4] = v115;
            *(_WORD *)&v122[12] = 2050;
            *(double *)&v122[14] = v45;
            *(_WORD *)&v122[22] = 2050;
            *(void *)uint64_t v123 = v44;
            *(_WORD *)&v123[8] = 2050;
            *(void *)&v123[10] = v118;
            double v116 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v116);
            if (v116 != buf) {
              free(v116);
            }
          }
          BOOL v46 = 0;
        }
      }
    }
    v121 |= v39 || v46;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  double v49 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
  {
    double v50 = *v26;
    int v51 = *(unsigned __int8 *)(a1 + 2075);
    int v52 = *(unsigned __int8 *)(a1 + 2076);
    int v53 = *(unsigned __int8 *)(a1 + 2096);
    uint64_t v54 = *(void *)(a1 + 2104);
    *(_DWORD *)uint64_t buf = 134351360;
    *(double *)&uint8_t buf[4] = v50;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&unsigned char buf[14] = v51;
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v52;
    *(_WORD *)double v125 = 1026;
    *(_DWORD *)&v125[2] = v53;
    *(_WORD *)&v125[6] = 1026;
    *(_DWORD *)&v125[8] = v121;
    *(_WORD *)&v125[12] = 1026;
    *(_DWORD *)&v125[14] = v25;
    *(_WORD *)&v125[18] = 1026;
    *(_DWORD *)&v125[20] = v24;
    *(_WORD *)uint64_t v126 = 2050;
    *(void *)&v126[2] = v54;
    LOWORD(v127) = 1026;
    *(_DWORD *)((char *)&v127 + 2) = v39;
    HIWORD(v127) = 1026;
    v128[0] = v46;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#selection,newLocation_mct,%{public}.3f,isInsideVisit,%{public}d,isLikelyOutOfAVisit,%{public}d,isWiFiAssociated,%{public}d,%{public}d,numHypoWithAPWiFi,%{public}d,NumNonOutlierHypo,%{public}d,LastWifiAssociatedTime,%{public}.3f,static,%{public}d,radialDistanceMovedWithinThreshold,%{public}d", buf, 0x46u);
  }
  uint64_t v55 = &qword_102419000;
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v99 = *v26;
    int v100 = *(unsigned __int8 *)(a1 + 2075);
    int v101 = *(unsigned __int8 *)(a1 + 2076);
    int v102 = *(unsigned __int8 *)(a1 + 2096);
    uint64_t v103 = *(void *)(a1 + 2104);
    *(_DWORD *)int v122 = 134351360;
    *(double *)&v122[4] = v99;
    *(_WORD *)&v122[12] = 1026;
    *(_DWORD *)&v122[14] = v100;
    *(_WORD *)&v122[18] = 1026;
    *(_DWORD *)&v122[20] = v101;
    *(_WORD *)uint64_t v123 = 1026;
    *(_DWORD *)&v123[2] = v102;
    *(_WORD *)&v123[6] = 1026;
    *(_DWORD *)&v123[8] = v121;
    *(_WORD *)&v123[12] = 1026;
    *(_DWORD *)&v123[14] = v25;
    *(_WORD *)&v123[18] = 1026;
    *(_DWORD *)&v123[20] = v24;
    *(_WORD *)&v123[24] = 2050;
    *(void *)&v123[26] = v103;
    *(_WORD *)&v123[34] = 1026;
    *(_DWORD *)&v123[36] = v39;
    *(_WORD *)&v123[40] = 1026;
    *(_DWORD *)&v123[42] = v46;
    double v104 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v104);
    if (v104 != buf) {
      free(v104);
    }
    uint64_t v55 = &qword_102419000;
  }
  char v56 = v121 ^ 1;
  if (v25 != 1) {
    char v56 = 1;
  }
  if ((v56 & 1) == 0 && v119 && *((_DWORD *)v119 + 167) != 4)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v63 = v55[163];
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
    {
      int v64 = *((_DWORD *)v119 + 165);
      double v65 = sub_1005B5034();
      double v66 = sub_1005B5034();
      double v67 = *(double *)(a1 + 2104);
      *(_DWORD *)uint64_t buf = 67242240;
      *(_DWORD *)&uint8_t buf[4] = v64;
      *(_WORD *)&uint8_t buf[8] = 2050;
      *(double *)&buf[10] = v65;
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v39;
      *(_WORD *)double v125 = 1026;
      *(_DWORD *)&v125[2] = v46;
      *(_WORD *)&v125[6] = 1026;
      *(_DWORD *)&v125[8] = 1;
      *(_WORD *)&v125[12] = 2050;
      *(double *)&v125[14] = v66 - v67;
      *(_WORD *)&v125[22] = 2050;
      *(double *)uint64_t v126 = v45 - v67;
      *(_WORD *)&v126[8] = 2050;
      uint64_t v127 = v44;
      LOWORD(v128[0]) = 2050;
      *(void *)((char *)v128 + 2) = v118;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEBUG, "#selection,APWiFi,hID,%{public}d,now_mct,%{public}.3f,Static,%{public}d,IODistanceBelowThreshold,%{public}d,isWiFiAssociated,%{public}d,how_long,%{public}.3f,IOAgeWrtAPWiFi_s,%{public}.2f,IODistanceMoved_m,%{public}.1f,IODistanceMovedInterval_s,%{public}.1f", buf, 0x4Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      int v108 = *((_DWORD *)v119 + 165);
      double v109 = sub_1005B5034();
      double v110 = sub_1005B5034();
      double v111 = *(double *)(a1 + 2104);
      *(_DWORD *)int v122 = 67242240;
      *(_DWORD *)&v122[4] = v108;
      *(_WORD *)&v122[8] = 2050;
      *(double *)&v122[10] = v109;
      *(_WORD *)&v122[18] = 1026;
      *(_DWORD *)&v122[20] = v39;
      *(_WORD *)uint64_t v123 = 1026;
      *(_DWORD *)&v123[2] = v46;
      *(_WORD *)&v123[6] = 1026;
      *(_DWORD *)&v123[8] = 1;
      *(_WORD *)&v123[12] = 2050;
      *(double *)&v123[14] = v110 - v111;
      *(_WORD *)&v123[22] = 2050;
      *(double *)&v123[24] = v45 - v111;
      *(_WORD *)&v123[32] = 2050;
      *(void *)&v123[34] = v44;
      *(_WORD *)&v123[42] = 2050;
      *(void *)&v123[44] = v118;
      uint64_t v112 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v112);
      if (v112 != buf) {
        free(v112);
      }
    }
    uint64_t v55 = &qword_102419000;
    if (v39 || v46)
    {
      sub_100E9CBC4((uint64_t)v122);
      *(_DWORD *)&v123[104] = sub_100022744((uint64_t)(v119 + 1), v26);
      if (sub_100074400((uint64_t)(v119 + 7), v26) && sub_100070DA0((uint64_t)(v119 + 7), (uint64_t)v122))
      {
        unint64_t v68 = v119[6] + v119[5] - 1;
        *(_OWORD *)(*(void *)(v119[2] + 8 * (v68 / 0x17)) + 176 * (v68 % 0x17)) = *(_OWORD *)(a2 + 8);
        uint64_t v69 = a1 + 248;
        uint64_t v70 = (uint64_t)(v119 + 1);
LABEL_185:
        sub_100188750(v69, v70);
        *(_OWORD *)(a1 + 1040) = *(_OWORD *)&v123[48];
        *(_OWORD *)(a1 + 1056) = *(_OWORD *)&v123[64];
        *(_OWORD *)(a1 + 1072) = *(_OWORD *)&v123[80];
        *(_OWORD *)(a1 + 1084) = *(_OWORD *)&v123[92];
        long long v92 = *(_OWORD *)v123;
        *(_OWORD *)(a1 + 976) = *(_OWORD *)&v122[8];
        *(_OWORD *)(a1 + 992) = v92;
        long long v93 = *(_OWORD *)&v123[16];
        long long v94 = *(_OWORD *)&v123[32];
        goto LABEL_194;
      }
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      double v87 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEBUG, "#selection,Failed to retrieve estimate from APWiFiFix hypothesis", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2))
      {
LABEL_168:
        uint64_t v55 = &qword_102419000;
        if (v24) {
          goto LABEL_137;
        }
LABEL_169:
        double v88 = -1.0;
        if (*(_DWORD *)(a1 + 908))
        {
          uint64_t v89 = *(void *)(a1 + 288);
          if (v89) {
            double v88 = sub_100022DBC(*(void *)(*(void *)(a1 + 256) + 8 * ((v89 + *(void *)(a1 + 280) - 1) / 0x17uLL))+ 176 * ((v89 + *(void *)(a1 + 280) - 1) % 0x17uLL), v26);
          }
        }
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        int v90 = v55[163];
        if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134349056;
          *(double *)&uint8_t buf[4] = v88;
          _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#selection,all hypotheses are marked as outliers,age of previously selected hypothesis,%{public}.3f", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          *(_DWORD *)int v122 = 134349056;
          *(double *)&v122[4] = v88;
          int v107 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v107);
          if (v107 != buf) {
            free(v107);
          }
        }
        if (v88 > 600.0)
        {
          for (uint64_t i = *(uint64_t **)(a1 + 240); i; uint64_t i = (uint64_t *)*i)
            *((_DWORD *)i + 167) = 1;
LABEL_180:
          if (sub_100E9E86C(a1, a2)) {
            return 1;
          }
        }
LABEL_191:
        uint64_t result = 0;
        int v20 = 9;
LABEL_192:
        *(_DWORD *)(a1 + 1104) = v20;
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v62 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v62);
    }
    else
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      double v71 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        double v72 = *v26;
        *(_DWORD *)uint64_t buf = 134349824;
        *(double *)&uint8_t buf[4] = v72;
        *(_WORD *)&unsigned char buf[12] = 1026;
        *(_DWORD *)&unsigned char buf[14] = 0;
        *(_WORD *)&buf[18] = 1026;
        *(_DWORD *)&buf[20] = 0;
        *(_WORD *)double v125 = 2050;
        *(void *)&v125[2] = v44;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEBUG, "#selection,mct,%{public}.3f,Selection based on APWiFiFix hypothesis is skipped,Static,%{public}d,LargeDisplacement,%{public}d,Displacement_m,%{public}.3f", buf, 0x22u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_136;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      double v113 = *v26;
      *(_DWORD *)int v122 = 134349824;
      *(double *)&v122[4] = v113;
      *(_WORD *)&v122[12] = 1026;
      *(_DWORD *)&v122[14] = 0;
      *(_WORD *)&v122[18] = 1026;
      *(_DWORD *)&v122[20] = 0;
      *(_WORD *)uint64_t v123 = 2050;
      *(void *)&v123[2] = v44;
      uint64_t v62 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v62);
    }
LABEL_223:
    if (v62 != buf) {
      free(v62);
    }
    goto LABEL_168;
  }
  int v57 = v121;
  if (v25 > 0) {
    int v57 = 1;
  }
  if (v24 >= 2 && v57)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v58 = v55[163];
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v59 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 1;
      double v60 = sub_10016BA54(v59, buf);
      *(_DWORD *)uint64_t buf = 134349568;
      *(double *)&uint8_t buf[4] = v60;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&unsigned char buf[14] = v121;
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v25;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEBUG, "#selection,now_mct,%{public}.3f,APWiFiFix override skipped in favor of hypotheses mixture,Associated,%{public}d,NumHypoWithAPWiFi,%{public}d", buf, 0x18u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      double v61 = sub_1005B5034();
      *(_DWORD *)int v122 = 134349568;
      *(double *)&v122[4] = v61;
      *(_WORD *)&v122[12] = 1026;
      *(_DWORD *)&v122[14] = v121;
      *(_WORD *)&v122[18] = 1026;
      *(_DWORD *)&v122[20] = v25;
      uint64_t v62 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v62);
      goto LABEL_223;
    }
  }
LABEL_136:
  if (!v24) {
    goto LABEL_169;
  }
LABEL_137:
  if (v24 != 1) {
    goto LABEL_180;
  }
  BOOL v73 = *(uint64_t **)(a1 + 240);
  if (!v73) {
    goto LABEL_180;
  }
  __asm { FMOV            V0.2D, #-1.0 }
  long long v120 = _Q0;
  while ((*((_DWORD *)v73 + 167) & 0xFFFFFFFB) == 0)
  {
LABEL_153:
    BOOL v73 = (uint64_t *)*v73;
    if (!v73) {
      goto LABEL_180;
    }
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  int8x16_t v79 = v55[163];
  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
  {
    int v80 = *((_DWORD *)v73 + 165);
    double v81 = *v26;
    *(_DWORD *)uint64_t buf = 67240704;
    *(_DWORD *)&uint8_t buf[4] = v80;
    *(_WORD *)&uint8_t buf[8] = 2050;
    *(double *)&buf[10] = v81;
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v121;
    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEBUG, "#selection,yield the only non-outlier hypothesis,hID,%{public}d,location_mct,%{public}.3f,isWiFiAssociated,%{public}d", buf, 0x18u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v83 = *((_DWORD *)v73 + 165);
    double v84 = *v26;
    *(_DWORD *)int v122 = 67240704;
    *(_DWORD *)&v122[4] = v83;
    *(_WORD *)&v122[8] = 2050;
    *(double *)&v122[10] = v84;
    *(_WORD *)&v122[18] = 1026;
    *(_DWORD *)&v122[20] = v121;
    double v85 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v85);
    if (v85 != buf) {
      free(v85);
    }
  }
  *(void *)int v122 = off_10232A710;
  *(_OWORD *)&v122[8] = v120;
  *(_OWORD *)&v123[16] = xmmword_101D1C320;
  *(_OWORD *)&v123[32] = xmmword_101D1C320;
  *(_OWORD *)&v123[56] = v120;
  *(_OWORD *)&v123[72] = v120;
  *(void *)&v123[88] = 0xBFF0000000000000;
  *(_DWORD *)&v123[96] = 0;
  v123[100] = 0;
  *(_DWORD *)&v123[104] = 0;
  *(_DWORD *)&v123[104] = sub_100022744((uint64_t)(v73 + 1), v26);
  if (!sub_100074400((uint64_t)(v73 + 7), v26) || !sub_100070DA0((uint64_t)(v73 + 7), (uint64_t)v122))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v82 = v55[163];
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEBUG, "#selection,Failed to retrieve estimate from the single non-outlier hypothesis", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      double v86 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesisSelection(const LCFusionProviderLocation &)", "%s\n", v86);
      if (v86 != buf) {
        free(v86);
      }
    }
    goto LABEL_153;
  }
  unint64_t v96 = v73[6] + v73[5] - 1;
  *(_OWORD *)(*(void *)(v73[2] + 8 * (v96 / 0x17)) + 176 * (v96 % 0x17)) = *(_OWORD *)(a2 + 8);
  sub_100188750(a1 + 248, (uint64_t)(v73 + 1));
  long long v97 = *(_OWORD *)&v123[64];
  *(_OWORD *)(a1 + 1040) = *(_OWORD *)&v123[48];
  *(_OWORD *)(a1 + 1056) = v97;
  *(_OWORD *)(a1 + 1072) = *(_OWORD *)&v123[80];
  *(_OWORD *)(a1 + 1084) = *(_OWORD *)&v123[92];
  long long v98 = *(_OWORD *)v123;
  *(_OWORD *)(a1 + 976) = *(_OWORD *)&v122[8];
  *(_OWORD *)(a1 + 992) = v98;
  long long v93 = *(_OWORD *)&v123[16];
  long long v94 = *(_OWORD *)&v123[32];
LABEL_194:
  uint64_t result = 1;
  *(_OWORD *)(a1 + 1008) = v93;
  *(_OWORD *)(a1 + 1024) = v94;
  return result;
}

void sub_10018EBCC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1001C7F8C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10018EBDC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 240);
  if (!v1) {
    return 1;
  }
  __int16 v146 = (uint8_t *)(a1 + 240);
  uint64_t v157 = (double *)(a1 + 1800);
  int v156 = (uint64_t **)(a1 + 192);
  __asm { FMOV            V0.2D, #-1.0 }
  float64x2_t v158 = _Q0;
  _Q0.f64[0] = NAN;
  _Q0.f64[1] = NAN;
  int8x16_t v155 = (int8x16_t)vnegq_f64(_Q0);
LABEL_3:
  if (!*((_DWORD *)v1 + 167)) {
    goto LABEL_109;
  }
  uint64_t v7 = v1[6];
  if (!v7
    || !*(unsigned char *)(*(void *)(v1[2] + 8 * ((v7 + v1[5] - 1) / 0x17uLL)) + 176 * ((v7 + v1[5] - 1) % 0x17uLL) + 168))
  {
    goto LABEL_109;
  }
  uint64_t v8 = (uint64_t *)*v1;
  if (*v1)
  {
    int v154 = (int64x2_t *)(v1 + 1);
    while (1)
    {
      if (*((_DWORD *)v8 + 167))
      {
        uint64_t v9 = v8[6];
        if (v9)
        {
          unint64_t v10 = v9 + v8[5] - 1;
          uint64_t v11 = *(void *)(v8[2] + 8 * (v10 / 0x17));
          unint64_t v12 = v10 % 0x17;
          if (*(unsigned char *)(v11 + 176 * v12 + 168))
          {
            unint64_t v13 = v1[6] + v1[5] - 1;
            if (fabs(sub_100022DBC(*(void *)(v1[2] + 8 * (v13 / 0x17)) + 176 * (v13 % 0x17), (double *)(v11 + 176 * v12 + 8))) > 0.001)
            {
              unint64_t v14 = v8[6] + v8[5] - 1;
              unint64_t v15 = *(void *)(v8[2] + 8 * (v14 / 0x17)) + 176 * (v14 % 0x17);
              double v17 = *(double *)(v15 + 8);
              long long v16 = (double *)(v15 + 8);
              double v18 = v17;
              uint64_t v19 = v1[6] + v1[5] - 1;
              uint64_t v20 = ((unint64_t)v19 * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
              uint64_t v21 = *(void *)(v1[2] + 8 * ((v20 + ((unint64_t)(v19 - v20) >> 1)) >> 4))
                  + 176 * (v19 - 23 * ((v20 + ((unint64_t)(v19 - v20) >> 1)) >> 4));
              double v23 = *(double *)(v21 + 8);
              unint64_t v22 = (double *)(v21 + 8);
              if (v18 <= v23)
              {
                uint64_t v24 = (uint64_t)(v8 + 7);
                long long v16 = v22;
              }
              else
              {
                uint64_t v24 = (uint64_t)(v1 + 7);
              }
              sub_100074400(v24, v16);
            }
            float64x2_t v174 = v158;
            *(_OWORD *)uint64_t v177 = xmmword_101D1C320;
            *(_OWORD *)&v177[2] = xmmword_101D1C320;
            *(float64x2_t *)&v177[5] = v158;
            *(float64x2_t *)&v177[7] = v158;
            int v173 = off_10232A710;
            v177[9] = 0xBFF0000000000000;
            int v178 = 0;
            char v179 = 0;
            int v180 = 0;
            if ((sub_100070DA0((uint64_t)(v1 + 7), (uint64_t)&v173) & 1) == 0)
            {
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              long long v93 = qword_102419518;
              if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEBUG, "#fusion, hypotheses merging, outer loop get filter estimate failed.", buf, 2u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419510 != -1) {
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                }
                *(_WORD *)long long v181 = 0;
                int v137 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v137);
                if (v137 != (char *)buf) {
                  free(v137);
                }
              }
LABEL_109:
              uint64_t v1 = (uint64_t *)*v1;
              if (!v1) {
                goto LABEL_157;
              }
              goto LABEL_3;
            }
            double v161 = off_10232A710;
            float64x2_t v162 = v158;
            long long v165 = xmmword_101D1C320;
            long long v166 = xmmword_101D1C320;
            float64x2_t v167 = v158;
            float64x2_t v168 = v158;
            unint64_t v169 = 0xBFF0000000000000;
            int v170 = 0;
            char v171 = 0;
            int v172 = 0;
            if ((sub_100070DA0((uint64_t)(v8 + 7), (uint64_t)&v161) & 1) == 0)
            {
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              unint64_t v33 = qword_102419518;
              if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "#fusion, hypotheses merging, inner loop get filter estimate failed.", buf, 2u);
              }
              if (!sub_10013D1A0(115, 2)) {
                goto LABEL_93;
              }
              bzero(buf, 0x65CuLL);
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              *(_WORD *)long long v181 = 0;
              uint64_t v34 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v34);
LABEL_39:
              if (v34 != (char *)buf) {
                free(v34);
              }
              goto LABEL_93;
            }
            double v159 = 0.0;
            double v160 = 0.0;
            int v25 = (double *)&v165 + 1;
            if (*(double *)&v166 <= 0.0) {
              int v25 = (double *)&v177[1];
            }
            if ((sub_1001BD27C(v157, &v160, &v159, v163, *v25) & 1) == 0)
            {
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              unint64_t v35 = qword_102419518;
              if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "#Error,fusion hypotheses merging, calc_dNdE failed.", buf, 2u);
              }
              if (!sub_10013D1A0(115, 0)) {
                goto LABEL_93;
              }
              bzero(buf, 0x65CuLL);
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              *(_WORD *)long long v181 = 0;
              uint64_t v34 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v34);
              goto LABEL_39;
            }
            double v27 = v163;
            *(double *)v26.i64 = v164 * 0.0174532925;
            double v28 = v175;
            double v29 = v176;
            v30.i64[1] = 0;
            v31.i64[1] = 0;
            if (fabs(v164 * 0.0174532925) <= 3.14159265)
            {
              int8x16_t v32 = (int8x16_t)0x400921FB54442D18uLL;
            }
            else
            {
              int8x16_t v149 = vbslq_s8(v155, (int8x16_t)0x400921FB54442D18uLL, v26);
              *(double *)v31.i64 = fmod(*(double *)v26.i64 + *(double *)v149.i64, 6.28318531);
              int8x16_t v32 = (int8x16_t)0x400921FB54442D18uLL;
              v30.i64[1] = v149.i64[1];
              *(double *)v26.i64 = *(double *)v31.i64 - *(double *)v149.i64;
            }
            *(double *)v31.i64 = v29 * 0.0174532925;
            if (fabs(v29 * 0.0174532925) > *(double *)v32.i64)
            {
              int8x16_t v147 = vbslq_s8(v155, v32, v31);
              uint64_t v150 = v26.i64[0];
              *(double *)v31.i64 = fmod(*(double *)v31.i64 + *(double *)v147.i64, 6.28318531);
              int8x16_t v32 = (int8x16_t)0x400921FB54442D18uLL;
              v30.i64[1] = v147.i64[1];
              v26.i64[0] = v150;
              *(double *)v31.i64 = *(double *)v31.i64 - *(double *)v147.i64;
            }
            *(double *)v30.i64 = *(double *)v26.i64 - *(double *)v31.i64;
            if (vabdd_f64(*(double *)v26.i64, *(double *)v31.i64) > *(double *)v32.i64)
            {
              double v151 = *(double *)vbslq_s8(v155, v32, v30).i64;
              *(double *)v30.i64 = fmod(*(double *)v30.i64 + v151, 6.28318531) - v151;
            }
            double v36 = 1.0 / (*(double *)v177 * *(double *)v177 * 0.5 + *(double *)&v165 * *(double *)&v165 * 0.5);
            double v37 = (v27 - v28) * 0.0174532925 * v160 * ((v27 - v28) * 0.0174532925 * v160) * v36
                + *(double *)v30.i64
                * 57.2957795
                * 0.0174532925
                * v159
                * (*(double *)v30.i64
                 * 57.2957795
                 * 0.0174532925
                 * v159)
                * v36;
            if (v37 <= 6.18007) {
              break;
            }
          }
        }
      }
LABEL_93:
      uint64_t v8 = (uint64_t *)*v8;
      if (!v8) {
        goto LABEL_109;
      }
    }
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v38 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v39 = *((_DWORD *)v1 + 165);
      uint64_t v40 = v1[80];
      int v41 = *((_DWORD *)v8 + 165);
      uint64_t v42 = v8[80];
      *(_DWORD *)uint64_t buf = 67241728;
      *(_DWORD *)&uint8_t buf[4] = v39;
      __int16 v190 = 2050;
      uint64_t v191 = v177[0];
      __int16 v192 = 2050;
      uint64_t v193 = v40;
      __int16 v194 = 1026;
      int v195 = v41;
      __int16 v196 = 2050;
      uint64_t v197 = v165;
      __int16 v198 = 2050;
      uint64_t v199 = v42;
      __int16 v200 = 2050;
      double v201 = v37;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "fused hypotheses are merged,hID,%{public}d,hunc,%{public}.1f,likelihood,%{public}.1f,hID,%{public}d,hunc,%{public}.1f,likelihood,%{public}.1f,squaredMD,%{public}.3f", buf, 0x40u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      int v87 = *((_DWORD *)v1 + 165);
      uint64_t v88 = v1[80];
      int v89 = *((_DWORD *)v8 + 165);
      uint64_t v90 = v8[80];
      *(_DWORD *)long long v181 = 67241728;
      *(_DWORD *)&v181[4] = v87;
      *(_WORD *)&v181[8] = 2050;
      *(void *)&v181[10] = v177[0];
      *(_WORD *)&v181[18] = 2050;
      *(void *)&v181[20] = v88;
      *(_WORD *)&v181[28] = 1026;
      *(_DWORD *)&v181[30] = v89;
      *(_WORD *)&v181[34] = 2050;
      *(void *)&v181[36] = v165;
      *(_WORD *)&v181[44] = 2050;
      *(void *)&v181[46] = v90;
      *(_WORD *)&v181[54] = 2050;
      *(double *)&long long v182 = v37;
      int v91 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v91);
      if (v91 != (char *)buf) {
        free(v91);
      }
    }
    double v43 = *(unsigned char **)(a1 + 2088);
    uint64_t v152 = (int64x2_t *)(v8 + 1);
    if (v43 && v43[1] && *v43)
    {
      if (*((double *)v1 + 80) <= *((double *)v8 + 80)) {
        goto LABEL_111;
      }
    }
    else if (*(double *)v177 >= *(double *)&v165)
    {
LABEL_111:
      unint64_t v94 = v1[6] + v1[5] - 1;
      uint64_t v95 = *(void *)(v1[2] + 8 * (v94 / 0x17));
      unint64_t v96 = v94 % 0x17;
      uint64_t v97 = v95 + 176 * v96;
      *(_OWORD *)long long v181 = *(_OWORD *)v97;
      *(void *)&v181[16] = *(void *)(v97 + 16);
      uint64_t v98 = *(void *)(v97 + 24);
      *(void *)&v181[24] = v98;
      if (v98) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v98 + 16), 1uLL, memory_order_relaxed);
      }
      *(void *)&v181[32] = off_10232A710;
      uint64_t v99 = v95 + 176 * v96;
      long long v100 = *(_OWORD *)(v99 + 40);
      long long v101 = *(_OWORD *)(v99 + 56);
      long long v102 = *(_OWORD *)(v99 + 88);
      long long v183 = *(_OWORD *)(v99 + 72);
      long long v184 = v102;
      *(_OWORD *)&v181[40] = v100;
      long long v182 = v101;
      long long v103 = *(_OWORD *)(v99 + 104);
      long long v104 = *(_OWORD *)(v99 + 120);
      long long v105 = *(_OWORD *)(v99 + 136);
      *(_OWORD *)((char *)v187 + 12) = *(_OWORD *)(v99 + 148);
      long long v186 = v104;
      v187[0] = v105;
      long long v185 = v103;
      __int16 v188 = *(_WORD *)(v99 + 168);
      uint64_t v106 = (char *)operator new(0xA0uLL);
      *((void *)v106 + 1) = 0;
      *((void *)v106 + 2) = 0;
      *(void *)uint64_t v106 = off_1022FFBB0;
      int v148 = v106 + 24;
      *((void *)v106 + 3) = off_10232A710;
      long long v107 = v186;
      *((_OWORD *)v106 + 6) = v185;
      *((_OWORD *)v106 + 7) = v107;
      *((_OWORD *)v106 + 8) = v187[0];
      *(_OWORD *)(v106 + 140) = *(_OWORD *)((char *)v187 + 12);
      long long v108 = v182;
      *((_OWORD *)v106 + 2) = *(_OWORD *)&v181[40];
      *((_OWORD *)v106 + 3) = v108;
      long long v109 = v184;
      *((_OWORD *)v106 + 4) = v183;
      *((_OWORD *)v106 + 5) = v109;
      double v110 = (int *)(v106 + 152);
      *(void *)uint64_t buf = v106 + 152;
      if (sub_10017CBA0(v156, (int *)v106 + 38, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5])
      {
        *(void *)uint64_t buf = v106 + 152;
        double v111 = sub_10017CBA0(v156, v110, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *(void *)uint64_t buf = v106 + 152;
        uint64_t v112 = sub_10017CBA0(v156, v110, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5];
        *(void *)uint64_t buf = v106 + 152;
        sub_10017CBA0(v156, v110, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        double v113 = v111 + 5;
        if (v112)
        {
          uint64_t v114 = 0;
          uint64_t v115 = 2;
          do
          {
            unint64_t v116 = v115;
            ++v114;
            uint64_t v112 = (uint64_t *)*v112;
            ++v115;
          }
          while (v112);
          do
          {
            double v113 = (void *)*v113;
            --v116;
          }
          while (v116 > 1);
        }
        *(void *)uint64_t buf = v106 + 152;
        sub_10017CBA0(v156, v110, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        uint64_t v117 = (void *)*v113;
        uint64_t v118 = operator new(0x18uLL);
        uint64_t v119 = v106 + 24;
        *uint64_t v118 = v117;
        v118[1] = v148;
        v118[2] = v106;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v106 + 1, 1uLL, memory_order_relaxed);
        *double v113 = v118;
      }
      else
      {
        *(void *)uint64_t buf = v106 + 152;
        long long v120 = sub_10017CBA0(v156, v110, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        int v121 = v120[5];
        int v122 = (uint64_t *)operator new(0x18uLL);
        uint64_t v119 = v106 + 24;
        uint64_t *v122 = (uint64_t)v121;
        v122[1] = (uint64_t)v148;
        v122[2] = (uint64_t)v106;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v106 + 1, 1uLL, memory_order_relaxed);
        v120[5] = v122;
      }
      atomic_fetch_add_explicit((atomic_ullong *volatile)v106 + 2, 1uLL, memory_order_relaxed);
      uint64_t v123 = *(std::__shared_weak_count **)&v181[24];
      *(void *)&v181[16] = v119;
      *(void *)&v181[24] = v106;
      if (v123) {
        std::__shared_weak_count::__release_weak(v123);
      }
      LOBYTE(v188) = 0;
      sub_100188860(v152, (uint64_t)v181);
      sub_100048BC8((uint64_t)v152);
      sub_10132E90C((uint64_t)v152, *((double *)v8 + 80) + *((double *)v1 + 80));
      sub_10132E90C((uint64_t)v154, 0.00000001);
      if (!sub_100E9CFB0(a1))
      {
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        uint64_t v124 = qword_102419518;
        if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "Normalize likelihood failed from hypothesis merging", buf, 2u);
        }
        if (sub_10013D1A0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          double v138 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v138);
          if (v138 != (char *)buf) {
            free(v138);
          }
        }
      }
      double v125 = (void **)v1[2];
      uint64_t v126 = (void **)v1[3];
      if (v126 == v125)
      {
        uint64_t v126 = (void **)v1[2];
      }
      else
      {
        unint64_t v127 = v1[5];
        double v128 = &v125[v127 / 0x17];
        unint64_t v129 = (unint64_t)*v128;
        unint64_t v130 = (unint64_t)*v128 + 176 * (v127 % 0x17);
        unint64_t v131 = (unint64_t)v125[(v1[6] + v127) / 0x17] + 176 * ((v1[6] + v127) % 0x17);
        if (v130 != v131)
        {
          do
          {
            double v132 = *(std::__shared_weak_count **)(v130 + 24);
            if (v132)
            {
              std::__shared_weak_count::__release_weak(v132);
              unint64_t v129 = (unint64_t)*v128;
            }
            v130 += 176;
            if (v130 - v129 == 4048)
            {
              unint64_t v133 = (unint64_t)v128[1];
              ++v128;
              unint64_t v129 = v133;
              unint64_t v130 = v133;
            }
          }
          while (v130 != v131);
          double v125 = (void **)v1[2];
          uint64_t v126 = (void **)v1[3];
        }
      }
      v1[6] = 0;
      unint64_t v134 = (char *)v126 - (char *)v125;
      if ((unint64_t)((char *)v126 - (char *)v125) >= 0x11)
      {
        do
        {
          operator delete(*v125);
          uint64_t v135 = v1[3];
          double v125 = (void **)(v1[2] + 8);
          v1[2] = (uint64_t)v125;
          unint64_t v134 = v135 - (void)v125;
        }
        while (v134 > 0x10);
      }
      if (v134 >> 3 == 1)
      {
        uint64_t v136 = 11;
LABEL_144:
        v1[5] = v136;
      }
      else if (v134 >> 3 == 2)
      {
        uint64_t v136 = 23;
        goto LABEL_144;
      }
      sub_1000DB0A0((std::__shared_weak_count *)v106);
      if (*(void *)&v181[24]) {
        std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v181[24]);
      }
      goto LABEL_109;
    }
    unint64_t v44 = v8[6] + v8[5] - 1;
    uint64_t v45 = *(void *)(v8[2] + 8 * (v44 / 0x17));
    unint64_t v46 = v44 % 0x17;
    uint64_t v47 = v45 + 176 * v46;
    *(_OWORD *)long long v181 = *(_OWORD *)v47;
    *(void *)&v181[16] = *(void *)(v47 + 16);
    uint64_t v48 = *(void *)(v47 + 24);
    *(void *)&v181[24] = v48;
    if (v48) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 16), 1uLL, memory_order_relaxed);
    }
    *(void *)&v181[32] = off_10232A710;
    uint64_t v49 = v45 + 176 * v46;
    long long v50 = *(_OWORD *)(v49 + 40);
    long long v51 = *(_OWORD *)(v49 + 56);
    long long v52 = *(_OWORD *)(v49 + 88);
    long long v183 = *(_OWORD *)(v49 + 72);
    long long v184 = v52;
    *(_OWORD *)&v181[40] = v50;
    long long v182 = v51;
    long long v53 = *(_OWORD *)(v49 + 104);
    long long v54 = *(_OWORD *)(v49 + 120);
    long long v55 = *(_OWORD *)(v49 + 136);
    *(_OWORD *)((char *)v187 + 12) = *(_OWORD *)(v49 + 148);
    long long v186 = v54;
    v187[0] = v55;
    long long v185 = v53;
    __int16 v188 = *(_WORD *)(v49 + 168);
    char v56 = (char *)operator new(0xA0uLL);
    *((void *)v56 + 1) = 0;
    *((void *)v56 + 2) = 0;
    *(void *)char v56 = off_1022FFBB0;
    int v57 = v56 + 24;
    *((void *)v56 + 3) = off_10232A710;
    long long v58 = v186;
    *((_OWORD *)v56 + 6) = v185;
    *((_OWORD *)v56 + 7) = v58;
    *((_OWORD *)v56 + 8) = v187[0];
    *(_OWORD *)(v56 + 140) = *(_OWORD *)((char *)v187 + 12);
    long long v59 = v182;
    *((_OWORD *)v56 + 2) = *(_OWORD *)&v181[40];
    *((_OWORD *)v56 + 3) = v59;
    long long v60 = v184;
    *((_OWORD *)v56 + 4) = v183;
    *((_OWORD *)v56 + 5) = v60;
    double v61 = (int *)(v56 + 152);
    *(void *)uint64_t buf = v56 + 152;
    if (sub_10017CBA0(v156, (int *)v56 + 38, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5])
    {
      *(void *)uint64_t buf = v56 + 152;
      uint64_t v62 = sub_10017CBA0(v156, v61, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      *(void *)uint64_t buf = v56 + 152;
      int v63 = sub_10017CBA0(v156, v61, (uint64_t)&unk_101D0B290, (_DWORD **)buf)[5];
      *(void *)uint64_t buf = v56 + 152;
      sub_10017CBA0(v156, v61, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      int v64 = v62 + 5;
      if (v63)
      {
        uint64_t v65 = 0;
        uint64_t v66 = 2;
        do
        {
          unint64_t v67 = v66;
          ++v65;
          int v63 = (uint64_t *)*v63;
          ++v66;
        }
        while (v63);
        do
        {
          int v64 = (void *)*v64;
          --v67;
        }
        while (v67 > 1);
      }
      *(void *)uint64_t buf = v56 + 152;
      sub_10017CBA0(v156, v61, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      unint64_t v68 = (void *)*v64;
      uint64_t v69 = operator new(0x18uLL);
      *uint64_t v69 = v68;
      v69[1] = v57;
      v69[2] = v56;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v56 + 1, 1uLL, memory_order_relaxed);
      *int v64 = v69;
    }
    else
    {
      *(void *)uint64_t buf = v56 + 152;
      uint64_t v70 = sub_10017CBA0(v156, v61, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      double v71 = v70[5];
      double v72 = (uint64_t *)operator new(0x18uLL);
      *double v72 = (uint64_t)v71;
      v72[1] = (uint64_t)v57;
      v72[2] = (uint64_t)v56;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v56 + 1, 1uLL, memory_order_relaxed);
      v70[5] = v72;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v56 + 2, 1uLL, memory_order_relaxed);
    BOOL v73 = *(std::__shared_weak_count **)&v181[24];
    *(void *)&v181[16] = v56 + 24;
    *(void *)&v181[24] = v56;
    if (v73) {
      std::__shared_weak_count::__release_weak(v73);
    }
    LOBYTE(v188) = 0;
    sub_100188860(v154, (uint64_t)v181);
    sub_100048BC8((uint64_t)v154);
    sub_10132E90C((uint64_t)v154, *((double *)v8 + 80) + *((double *)v1 + 80));
    sub_10132E90C((uint64_t)v152, 0.00000001);
    if (!sub_100E9CFB0(a1))
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      char v74 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "Normalize likelihood failed from hypothesis merging", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        long long v92 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "BOOL cllcf::CLLCFusion::performHypothesesMerging()", "%s\n", v92);
        if (v92 != (char *)buf) {
          free(v92);
        }
      }
    }
    unint64_t v75 = (void **)v8[2];
    int8x16_t v76 = (void **)v8[3];
    if (v76 == v75)
    {
      int8x16_t v76 = (void **)v8[2];
    }
    else
    {
      unint64_t v77 = v8[5];
      double v78 = &v75[v77 / 0x17];
      unint64_t v79 = (unint64_t)*v78;
      unint64_t v80 = (unint64_t)*v78 + 176 * (v77 % 0x17);
      unint64_t v81 = (unint64_t)v75[(v8[6] + v77) / 0x17] + 176 * ((v8[6] + v77) % 0x17);
      if (v80 != v81)
      {
        do
        {
          int v82 = *(std::__shared_weak_count **)(v80 + 24);
          if (v82)
          {
            std::__shared_weak_count::__release_weak(v82);
            unint64_t v79 = (unint64_t)*v78;
          }
          v80 += 176;
          if (v80 - v79 == 4048)
          {
            unint64_t v83 = (unint64_t)v78[1];
            ++v78;
            unint64_t v79 = v83;
            unint64_t v80 = v83;
          }
        }
        while (v80 != v81);
        unint64_t v75 = (void **)v8[2];
        int8x16_t v76 = (void **)v8[3];
      }
    }
    v8[6] = 0;
    unint64_t v84 = (char *)v76 - (char *)v75;
    if ((unint64_t)((char *)v76 - (char *)v75) >= 0x11)
    {
      do
      {
        operator delete(*v75);
        uint64_t v85 = v8[3];
        unint64_t v75 = (void **)(v8[2] + 8);
        v8[2] = (uint64_t)v75;
        unint64_t v84 = v85 - (void)v75;
      }
      while (v84 > 0x10);
    }
    if (v84 >> 3 == 1)
    {
      uint64_t v86 = 11;
    }
    else
    {
      if (v84 >> 3 != 2) {
        goto LABEL_91;
      }
      uint64_t v86 = 23;
    }
    v8[5] = v86;
LABEL_91:
    sub_1000DB0A0((std::__shared_weak_count *)v56);
    if (*(void *)&v181[24]) {
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v181[24]);
    }
    goto LABEL_93;
  }
LABEL_157:
  *(void *)uint64_t buf = 0;
  uint64_t v139 = v146;
  int v140 = *(uint8_t **)v146;
  if (*(void *)v146)
  {
    do
    {
      BOOL v141 = sub_10017BAD4((uint64_t)(v140 + 8));
      uint64_t v142 = *(uint8_t **)v139;
      if (v141)
      {
        do
          uint64_t v142 = *(uint8_t **)v142;
        while (v142 && sub_10017BAD4((uint64_t)(v142 + 8)));
        if (buf != v139 && v139 != v142)
        {
          uint64_t v143 = v139;
          do
          {
            __int16 v144 = v143;
            uint64_t v143 = *(uint8_t **)v143;
          }
          while (v143 != v142);
          if (v144 != v139)
          {
            *(void *)__int16 v144 = *(void *)buf;
            *(void *)uint64_t buf = *(void *)v139;
            *(void *)uint64_t v139 = v142;
          }
        }
        if (!v142) {
          break;
        }
      }
      int v140 = *(uint8_t **)v142;
      uint64_t v139 = v142;
    }
    while (*(void *)v142);
  }
  sub_100179680((void **)buf);
  return 1;
}

void sub_1001901EC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_100190220(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 2073) || *(unsigned char *)(a1 + 2074))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v4 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *(unsigned __int8 *)(a1 + 2073);
      int v6 = *(unsigned __int8 *)(a1 + 2074);
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v8 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 67240960;
      *(_DWORD *)BOOL v73 = v5;
      *(_WORD *)&v73[4] = 1026;
      *(_DWORD *)&v73[6] = v6;
      *(_WORD *)char v74 = 2050;
      *(void *)&v74[2] = v7;
      *(_WORD *)unint64_t v75 = 2050;
      *(void *)&v75[2] = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,hasAirborneClient,%{public}d,hasFitnessClient,%{public}d,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x22u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_8;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v54 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v54);
    if (v54 == (char *)buf) {
      goto LABEL_8;
    }
    goto LABEL_109;
  }
  if (*(_DWORD *)(a2 + 128) == 3)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    unint64_t v12 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = *(void *)(a2 + 8);
      uint64_t v14 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)BOOL v73 = v13;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,accessory,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_8;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v54 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v54);
    if (v54 == (char *)buf) {
      goto LABEL_8;
    }
    goto LABEL_109;
  }
  if (sub_1001805B4((void *)(a1 + 1840), &dbl_101D944D0))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    unint64_t v15 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v16 = *(void *)(a2 + 8);
      uint64_t v17 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)BOOL v73 = v16;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,vehicleConnected,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_8;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    long long v54 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v54);
    if (v54 == (char *)buf) {
      goto LABEL_8;
    }
LABEL_109:
    free(v54);
LABEL_8:
    uint64_t v9 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 1;
    double v10 = sub_10016BA54(v9, buf);
LABEL_9:
    *(double *)(a1 + 168) = v10;
    return 1;
  }
  uint64_t v18 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  double v19 = sub_10016BA54(v18, buf);
  if (sub_100178CCC((_DWORD *)(a1 + 1968), v19))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v20 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(void *)(a2 + 8);
      uint64_t v22 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)BOOL v73 = v21;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,MapsRoutingActive,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_130;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v63);
    if (v63 == (char *)buf) {
      goto LABEL_130;
    }
    goto LABEL_142;
  }
  if (sub_100031028(a1 + 1840, &dbl_101D944D0))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v23 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v24 = *(void *)(a2 + 8);
      uint64_t v25 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)BOOL v73 = v24;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v25;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,CM driving,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_130;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v63);
    if (v63 == (char *)buf) {
      goto LABEL_130;
    }
    goto LABEL_142;
  }
  if (sub_1001806D4(a1 + 1840) || sub_100180714(a1 + 1840))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int8x16_t v26 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = *(void *)(a2 + 8);
      uint64_t v28 = *(void *)(a2 + 16);
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)BOOL v73 = v27;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v28;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,Apple fitness,cfat,%{public}.3f,mct,%{public}.3f", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_130;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    int v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v63);
    if (v63 == (char *)buf) {
      goto LABEL_130;
    }
    goto LABEL_142;
  }
  if (((sub_100012848(a1 + 1840, &dbl_101D944D0) & 1) != 0 || sub_100011590(a1 + 1840, &dbl_101D944D0))
    && sub_100E9A100((void *)(a1 + 2016), &dbl_101D944C8))
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v29 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v30 = *(void *)(a2 + 8);
      uint64_t v31 = *(void *)(a2 + 16);
      BOOL v32 = sub_100E9A100((void *)(a1 + 2016), &dbl_101D944C8);
      *(_DWORD *)uint64_t buf = 134349568;
      *(void *)BOOL v73 = v30;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v31;
      *(_WORD *)&v74[8] = 1026;
      *(_DWORD *)unint64_t v75 = v32;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,highConfidenceOutdoorWalkingOrRunningOrCycling,cfat,%{public}.3f,mct,%{public}.3f,CLOutdoor,%{public}d", buf, 0x1Cu);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_130;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    sub_100E9A100((void *)(a1 + 2016), &dbl_101D944C8);
    int v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v63);
    if (v63 == (char *)buf) {
      goto LABEL_130;
    }
    goto LABEL_142;
  }
  uint64_t v33 = *(void *)(a1 + 1696);
  double v34 = *(double *)(v33 + 384);
  if (v34 < 0.0 || (v35 = *(void *)(v33 + 392), double v36 = *(double *)(a2 + 16), v36 >= v34) && v36 - v34 > 6.0) {
    LODWORD(v35) = 0;
  }
  BOOL v37 = sub_1000171E8((void *)(a1 + 1840), &dbl_101D944D0);
  int v38 = v35 == 1 || v37;
  if (v35 == 2) {
    int v39 = 1;
  }
  else {
    int v39 = v38;
  }
  if (!v37 && (v35 - 1) >= 2 && !*(unsigned char *)(a1 + 2096) && *(double *)(a1 + 1776) > 20.0)
  {
    int v40 = *(_DWORD *)(a1 + 1792);
    if (v40 >= 21 && *(int *)(a1 + 1788) <= 19 && (double)*(int *)(a1 + 1796) / (double)v40 > 0.5)
    {
      double v41 = *(double *)(a1 + 1768);
      double v42 = *(double *)(a2 + 16) - v41;
      BOOL v43 = v41 > 0.0;
      double v44 = -1.0;
      if (v43) {
        double v44 = v42;
      }
      if (v44 <= 5.0)
      {
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        int v64 = qword_102419518;
        if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v66 = *(void *)(a2 + 8);
          uint64_t v65 = *(void *)(a2 + 16);
          uint64_t v67 = *(void *)(a1 + 1776);
          int v68 = *(_DWORD *)(a1 + 1792);
          if (v68) {
            double v69 = (double)*(int *)(a1 + 1796) / (double)v68;
          }
          else {
            double v69 = 0.0;
          }
          int v70 = *(_DWORD *)(a1 + 1788);
          *(_DWORD *)uint64_t buf = 134350080;
          *(void *)BOOL v73 = v66;
          *(_WORD *)&v73[8] = 2050;
          *(void *)char v74 = v65;
          *(_WORD *)&v74[8] = 2050;
          *(void *)unint64_t v75 = v67;
          *(_WORD *)&v75[8] = 2050;
          double v76 = v69;
          __int16 v77 = 1026;
          int v78 = v70;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,GNSSNavSessionDetected,cfat,%{public}.3f,mct,%{public}.3f,GNSSSessionDuration_s,%{public}.1f,ratioOfEpochsWithGoodTrakcing,%{public}.2f,consecNumEpochsPoorTracking,%{public}d", buf, 0x30u);
        }
        if (!sub_10013D1A0(115, 2)) {
          goto LABEL_130;
        }
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        int v63 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v63);
        if (v63 == (char *)buf) {
          goto LABEL_130;
        }
LABEL_142:
        free(v63);
LABEL_130:
        double v10 = sub_1005B5034();
        goto LABEL_9;
      }
    }
  }
  if (!*(unsigned char *)(a1 + 159)) {
    return 0;
  }
  double v45 = sub_1005B5034();
  double v46 = *(double *)(a1 + 176);
  double v47 = v45 - *(double *)(a1 + 168);
  if (v46 <= 0.0)
  {
    double v46 = 5.0;
    if (!v39) {
      double v46 = 40.0;
    }
    *(double *)(a1 + 176) = v46;
  }
  if (v47 <= v46)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v48 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v49 = *(void *)(a2 + 8);
      uint64_t v50 = *(void *)(a2 + 16);
      uint64_t v51 = *(void *)(a1 + 168);
      double v52 = *(double *)(a1 + 176);
      *(_DWORD *)uint64_t buf = 134349824;
      *(void *)BOOL v73 = v49;
      *(_WORD *)&v73[8] = 2050;
      *(void *)char v74 = v50;
      *(_WORD *)&v74[8] = 2050;
      *(void *)unint64_t v75 = v51;
      *(_WORD *)&v75[8] = 2050;
      double v76 = v52;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,passthroughHysteresis,cfat,%{public}.3f,mct,%{public}.3f,last_passthrough_mct,%{public}.3f,stickinessTime_s,%{public}.1f", buf, 0x2Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      long long v53 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v53);
      if (v53 != (char *)buf) {
        free(v53);
      }
    }
    return 1;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  long long v55 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v56 = *(void *)(a1 + 168);
    uint64_t v57 = *(void *)(a1 + 176);
    *(_DWORD *)uint64_t buf = 134349568;
    *(void *)BOOL v73 = v56;
    *(_WORD *)&v73[8] = 2050;
    *(double *)char v74 = v47;
    *(_WORD *)&v74[8] = 2050;
    *(void *)unint64_t v75 = v57;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEBUG, "shouldBypassFusion,passthroughHysteresis expired,switching off passthrough mode,last_passthrough_mct,%{public}.3f,elapsed,%{public}.1f,stickinessTime_s,%{public}.1f", buf, 0x20u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    double v71 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::shouldBypassLCFusion(const LCFusionProviderLocation &)", "%s\n", v71);
    if (v71 != (char *)buf) {
      free(v71);
    }
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 159) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  return result;
}

void sub_100191438(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_100191444(uint64_t a1, double *a2, int *a3)
{
  if (*(_DWORD *)(a1 + 2160) != 4) {
    sub_100E9852C(a1);
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022FFA18);
  }
  int v5 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = CLMotionActivity::activityTypeToString();
    double v7 = *a2;
    uint64_t v8 = *((void *)a3 + 10);
    uint64_t v9 = *((void *)a3 + 5);
    int v11 = *a3;
    int v10 = a3[1];
    *(_DWORD *)uint64_t buf = 136316674;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v58 = 2050;
    double v59 = v7;
    __int16 v60 = 2050;
    uint64_t v61 = v8;
    __int16 v62 = 2050;
    uint64_t v63 = v9;
    __int16 v64 = 1026;
    int v65 = v11;
    __int16 v66 = 1026;
    int v67 = v10;
    __int16 v68 = 2080;
    uint64_t v69 = CLMotionActivity::activityConfidenceToString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#fusion,received motion state,%s,mct_now,%{public}.3f,start_time_cfat,%{public}.3f,timestamp,%{public}.3f,type,%{public}d,confidence,%{public}d,%s", buf, 0x40u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v33 = CLMotionActivity::activityTypeToString();
    uint64_t v34 = *(void *)a2;
    uint64_t v35 = *((void *)a3 + 10);
    uint64_t v36 = *((void *)a3 + 5);
    int v38 = *a3;
    int v37 = a3[1];
    *(_DWORD *)uint64_t v49 = 136316674;
    *(void *)&v49[4] = v33;
    *(_WORD *)&v49[12] = 2050;
    *(void *)&v49[14] = v34;
    *(_WORD *)&v49[22] = 2050;
    *(void *)&unsigned char v49[24] = v35;
    LOWORD(v50) = 2050;
    *(void *)((char *)&v50 + 2) = v36;
    WORD5(v50) = 1026;
    HIDWORD(v50) = v38;
    LOWORD(v51) = 1026;
    *(_DWORD *)((char *)&v51 + 2) = v37;
    WORD3(v51) = 2080;
    *((void *)&v51 + 1) = CLMotionActivity::activityConfidenceToString();
    int v39 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::motionActivityUpdate(const CFTimeInterval &, const CLMotionActivity &)", "%s\n", v39);
    if (v39 != buf) {
      free(v39);
    }
  }
  if (!*(unsigned char *)(a1 + 2208))
  {
    long long v20 = *((_OWORD *)a3 + 7);
    long long v54 = *((_OWORD *)a3 + 6);
    long long v55 = v20;
    uint64_t v56 = *((void *)a3 + 16);
    long long v21 = *((_OWORD *)a3 + 3);
    long long v50 = *((_OWORD *)a3 + 2);
    long long v51 = v21;
    long long v22 = *((_OWORD *)a3 + 5);
    long long v52 = *((_OWORD *)a3 + 4);
    long long v53 = v22;
    long long v23 = *((_OWORD *)a3 + 1);
    *(_OWORD *)uint64_t v49 = *(_OWORD *)a3;
    *(_OWORD *)&v49[16] = v23;
    if (*(unsigned char *)(a1 + 2075) || *(unsigned char *)(a1 + 2096) || *a3 != 2 || a3[1] < 1) {
      goto LABEL_12;
    }
    uint64_t v25 = *(void *)(a1 + 1696);
    long long v43 = *(_OWORD *)(v25 + 384);
    sub_100E9A034(v25, (uint64_t)v44);
    if (*(double *)&v43 < 0.0
      || *a2 >= *(double *)&v43 && *a2 - *(double *)&v43 > 6.0
      || (DWORD2(v43) - 3) > 1)
    {
      if (v44[0] < 0.0) {
        goto LABEL_12;
      }
      BOOL v30 = *a2 - v44[0] <= 6.0 || *a2 < v44[0];
      if (!v30 || v44[1] >= 0.001 || v45 <= 0.3) {
        goto LABEL_12;
      }
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v31 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v32 = *(void *)a2;
        *(_DWORD *)uint64_t buf = 134349312;
        *(void *)&uint8_t buf[4] = v32;
        __int16 v58 = 2050;
        double v59 = v45;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "#fusion,mct_now,%{public}.3f,Static motion state override to Moving based on IO PDR delta-altitude changes,delta altitude change,%{public}.2f", buf, 0x16u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_47;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v41 = *(void *)a2;
      *(_DWORD *)double v46 = 134349312;
      *(void *)&v46[4] = v41;
      __int16 v47 = 2050;
      double v48 = v45;
      double v29 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::motionActivityUpdate(const CFTimeInterval &, const CLMotionActivity &)", "%s\n", v29);
    }
    else
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      int8x16_t v26 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v27 = *(void *)a2;
        *(_DWORD *)uint64_t buf = 134349312;
        *(void *)&uint8_t buf[4] = v27;
        __int16 v58 = 1026;
        LODWORD(v59) = DWORD2(v43);
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "#fusion,mct_now,%{public}.3f,Static motion state override to Moving based on IO PDR/VDR data,IO derived Motion type,%{public}d", buf, 0x12u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_47;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v28 = *(void *)a2;
      *(_DWORD *)double v46 = 134349312;
      *(void *)&v46[4] = v28;
      __int16 v47 = 1026;
      LODWORD(v48) = DWORD2(v43);
      double v29 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::motionActivityUpdate(const CFTimeInterval &, const CLMotionActivity &)", "%s\n", v29);
    }
    if (v29 != buf) {
      free(v29);
    }
LABEL_47:
    *(_DWORD *)uint64_t v49 = 3;
LABEL_12:
    sub_100188FA8(a1 + 1840, a2, (uint64_t)v49);
    sub_100070FB0(a1, a2);
    return;
  }
  *(void *)&long long v43 = 0;
  unint64_t v12 = (__n128 *)sub_10016BA10();
  sub_100168854(v12, (__n128 *)v49);
  if (sub_100AFF4CC((uint64_t)v49, (double *)&v43))
  {
    *(double *)double v46 = *((double *)a3 + 10) - *(double *)&v43;
    *(void *)uint64_t buf = v46;
    uint64_t v13 = sub_100EA3E84((uint64_t **)(a1 + 2216), (double *)v46, (uint64_t)&unk_101D0B290, (void **)buf);
    *(_OWORD *)(v13 + 5) = *(_OWORD *)a3;
    long long v14 = *((_OWORD *)a3 + 1);
    long long v15 = *((_OWORD *)a3 + 2);
    long long v16 = *((_OWORD *)a3 + 3);
    *(_OWORD *)(v13 + 13) = *((_OWORD *)a3 + 4);
    *(_OWORD *)(v13 + 11) = v16;
    *(_OWORD *)(v13 + 9) = v15;
    *(_OWORD *)(v13 + 7) = v14;
    long long v17 = *((_OWORD *)a3 + 5);
    long long v18 = *((_OWORD *)a3 + 6);
    long long v19 = *((_OWORD *)a3 + 7);
    v13[21] = (uint64_t *)*((void *)a3 + 16);
    *(_OWORD *)(v13 + 19) = v19;
    *(_OWORD *)(v13 + 17) = v18;
    *(_OWORD *)(v13 + 15) = v17;
  }
  else
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v24 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "#fusion, cannot compute fMachContinuousToCFAbsoluteOffset_s to convert buffered motion activity sample time, discarding sample", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      *(_WORD *)double v46 = 0;
      int v40 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::motionActivityUpdate(const CFTimeInterval &, const CLMotionActivity &)", "%s\n", v40);
      if (v40 != buf) {
        free(v40);
      }
    }
  }
}

void sub_100191CDC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_100191CE8(uint64_t a1, double *a2)
{
  uint64_t v4 = *(void *)(a1 + 1696);
  uint64_t v5 = *(void *)(v4 + 392);
  double v47 = *(double *)(v4 + 384);
  uint64_t v48 = v5;
  *(void *)uint64_t buf = 0xBFF0000000000000;
  if (sub_1000171E8((void *)(a1 + 1840), (double *)buf) && (v5 - 1) <= 1)
  {
    uint64_t v6 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 1;
    double v47 = sub_10016BA54(v6, buf);
    if ((v48 - 1) <= 1)
    {
      if (v48 == 2) {
        int v7 = 2;
      }
      else {
        int v7 = 1;
      }
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v8 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(_DWORD *)(a1 + 1912);
        *(_DWORD *)uint64_t buf = 134349568;
        *(double *)&uint8_t buf[4] = v47;
        __int16 v56 = 1026;
        int v57 = v7;
        __int16 v58 = 1026;
        int v59 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f,InertialOdometry derived zupt update,IO_dynamicsMode,%{public}d,CM_dynamicsMode,%{public}d", buf, 0x18u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        int v45 = *(_DWORD *)(a1 + 1912);
        int v49 = 134349568;
        double v50 = v47;
        __int16 v51 = 1026;
        int v52 = v7;
        __int16 v53 = 1026;
        int v54 = v45;
        double v46 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::propagateHypotheses(const CFTimeInterval &)", "%s\n", v46);
        if (v46 != buf) {
          free(v46);
        }
      }
      int v10 = *(void **)(a1 + 216);
      if (v10 != (void *)(a1 + 224))
      {
        do
        {
          *((_DWORD *)v10 + 108) = v7;
          if (!sub_100071A64((uint64_t)(v10 + 11), &v47, 1.5))
          {
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            int v11 = qword_102419518;
            if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
            {
              int v12 = *((_DWORD *)v10 + 173);
              *(_DWORD *)uint64_t buf = 134349312;
              *(double *)&uint8_t buf[4] = v47;
              __int16 v56 = 1026;
              int v57 = v12;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f,provider hypothesis zupt failed,hID,%{public}d", buf, 0x12u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              int v16 = *((_DWORD *)v10 + 173);
              int v49 = 134349312;
              double v50 = v47;
              __int16 v51 = 1026;
              int v52 = v16;
              long long v17 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::propagateHypotheses(const CFTimeInterval &)", "%s\n", v17);
              if (v17 != buf) {
                free(v17);
              }
            }
          }
          uint64_t v13 = (void *)v10[1];
          if (v13)
          {
            do
            {
              long long v14 = v13;
              uint64_t v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              long long v14 = (void *)v10[2];
              BOOL v15 = *v14 == (void)v10;
              int v10 = v14;
            }
            while (!v15);
          }
          int v10 = v14;
        }
        while (v14 != (void *)(a1 + 224));
      }
      for (uint64_t i = *(uint64_t **)(a1 + 240); i; uint64_t i = (uint64_t *)*i)
      {
        *((_DWORD *)i + 100) = v7;
        if (!sub_100071A64((uint64_t)(i + 7), &v47, 1.5))
        {
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          int v40 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            int v41 = *((_DWORD *)i + 165);
            *(_DWORD *)uint64_t buf = 134349312;
            *(double *)&uint8_t buf[4] = v47;
            __int16 v56 = 1026;
            int v57 = v41;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f,fused hypothesis zupt failed,hID,%{public}d", buf, 0x12u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            int v42 = *((_DWORD *)i + 165);
            int v49 = 134349312;
            double v50 = v47;
            __int16 v51 = 1026;
            int v52 = v42;
            long long v43 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::propagateHypotheses(const CFTimeInterval &)", "%s\n", v43);
            if (v43 != buf) {
              free(v43);
            }
          }
        }
      }
    }
    char v19 = 0;
  }
  else
  {
    long long v18 = *(void **)(a1 + 216);
    if (v18 == (void *)(a1 + 224))
    {
      char v19 = 0;
    }
    else
    {
      char v19 = 0;
      do
      {
        if (!sub_100074400((uint64_t)(v18 + 11), a2))
        {
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          long long v20 = qword_102419518;
          if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
          {
            double v21 = *a2;
            int v22 = *(_DWORD *)(a1 + 1912);
            int v23 = *((_DWORD *)v18 + 173);
            *(_DWORD *)uint64_t buf = 134349568;
            *(double *)&uint8_t buf[4] = v21;
            __int16 v56 = 1026;
            int v57 = v22;
            __int16 v58 = 1026;
            int v59 = v23;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f,provider hypothesis prediction failed,%{public}d,hID,%{public}d", buf, 0x18u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419510 != -1) {
              dispatch_once(&qword_102419510, &stru_1022FFA18);
            }
            double v26 = *a2;
            int v27 = *(_DWORD *)(a1 + 1912);
            int v28 = *((_DWORD *)v18 + 173);
            int v49 = 134349568;
            double v50 = v26;
            __int16 v51 = 1026;
            int v52 = v27;
            __int16 v53 = 1026;
            int v54 = v28;
            double v29 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::propagateHypotheses(const CFTimeInterval &)", "%s\n", v29);
            if (v29 != buf) {
              free(v29);
            }
          }
          char v19 = 1;
        }
        uint64_t v24 = (void *)v18[1];
        if (v24)
        {
          do
          {
            uint64_t v25 = v24;
            uint64_t v24 = (void *)*v24;
          }
          while (v24);
        }
        else
        {
          do
          {
            uint64_t v25 = (void *)v18[2];
            BOOL v15 = *v25 == (void)v18;
            long long v18 = v25;
          }
          while (!v15);
        }
        long long v18 = v25;
      }
      while (v25 != (void *)(a1 + 224));
    }
    for (j = *(uint64_t **)(a1 + 240); j; j = (uint64_t *)*j)
    {
      if (!sub_100074400((uint64_t)(j + 7), a2))
      {
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        uint64_t v31 = qword_102419518;
        if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
        {
          double v32 = *a2;
          int v33 = *(_DWORD *)(a1 + 1912);
          int v34 = *((_DWORD *)j + 165);
          *(_DWORD *)uint64_t buf = 134349568;
          *(double *)&uint8_t buf[4] = v32;
          __int16 v56 = 1026;
          int v57 = v33;
          __int16 v58 = 1026;
          int v59 = v34;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "#fusion,mct,%{public}.3f,fused hypothesis prediction failed,%{public}d,hID,%{public}d", buf, 0x18u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419510 != -1) {
            dispatch_once(&qword_102419510, &stru_1022FFA18);
          }
          double v35 = *a2;
          int v36 = *(_DWORD *)(a1 + 1912);
          int v37 = *((_DWORD *)j + 165);
          int v49 = 134349568;
          double v50 = v35;
          __int16 v51 = 1026;
          int v52 = v36;
          __int16 v53 = 1026;
          int v54 = v37;
          int v38 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL cllcf::CLLCFusion::propagateHypotheses(const CFTimeInterval &)", "%s\n", v38);
          if (v38 != buf) {
            free(v38);
          }
        }
        char v19 = 1;
      }
    }
  }
  return v19 & 1;
}

void sub_10019265C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_100192684(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  *a4 = 0;
  *a3 = 0;
  uint64_t v8 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 0;
  double v9 = sub_10016BA54(v8, buf);
  int v10 = (long long *)(a2 + 8);
  double v11 = *(double *)(a2 + 8);
  double v12 = v9 - v11;
  if (v9 - v11 >= 0.0)
  {
    double v22 = *(double *)(a2 + 112);
    if (v12 <= v22 || (v22 >= 0.0 ? (BOOL v23 = v9 <= v11) : (BOOL v23 = 1), v23))
    {
      if (v12 <= 300.0)
      {
        if (v12 >= 2.0)
        {
          int v39 = (unsigned int *)(a2 + 128);
          *(void *)uint64_t buf = a2 + 128;
          int v40 = sub_10017CBA0((uint64_t **)(a1 + 192), (int *)(a2 + 128), (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 5;
          while (1)
          {
            int v40 = (uint64_t **)*v40;
            *(void *)uint64_t buf = a2 + 128;
            sub_10017CBA0((uint64_t **)(a1 + 192), (int *)(a2 + 128), (uint64_t)&unk_101D0B290, (_DWORD **)buf);
            if (!v40) {
              break;
            }
            int v41 = v40[1];
            if (v41 && (*(unsigned int (**)(uint64_t *, uint64_t))(*v41 + 16))(v41, a2))
            {
              if (qword_102419510 != -1) {
                dispatch_once(&qword_102419510, &stru_1022FFA18);
              }
              int v42 = qword_102419518;
              if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
              {
                double v43 = *(double *)v10;
                double v44 = sub_10003E9A4(*v39);
                uint64_t v45 = *(void *)(a2 + 24);
                double v46 = *(const char **)(a2 + 32);
                double v47 = *(double *)(a2 + 112);
                *(_DWORD *)uint64_t buf = 134350339;
                *(double *)&uint8_t buf[4] = v43;
                __int16 v54 = 2082;
                long long v55 = v44;
                __int16 v56 = 2049;
                uint64_t v57 = v45;
                __int16 v58 = 2049;
                int v59 = v46;
                __int16 v60 = 2050;
                double v61 = v47;
                __int16 v62 = 2050;
                double v63 = v12;
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "Duplicate location detected in LC Fusion,timestamp_ios,%{public}.3f,provider,%{public}s,lat,%{private}.7f,lon,%{private}.7f,lifespan,%{public}.1f,age,%{public}.3f", buf, 0x3Eu);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419510 != -1) {
                  dispatch_once(&qword_102419510, &stru_1022FFA18);
                }
                sub_10003E9A4(*v39);
                int v52 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::ageCheckLocation(LCFusionProviderLocation &, BOOL &, BOOL &)", "%s\n", v52);
                if (v52 != buf) {
                  free(v52);
                }
              }
              *a3 = 1;
              int v38 = 3;
              goto LABEL_21;
            }
          }
        }
      }
      else
      {
        *a3 = 1;
        int v38 = 4;
LABEL_21:
        *(_DWORD *)(a1 + 1104) = v38;
      }
    }
    else
    {
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      uint64_t v24 = qword_102419518;
      if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a2 + 8);
        double v26 = sub_10003E9A4(*(_DWORD *)(a2 + 128));
        uint64_t v27 = *(void *)(a2 + 24);
        int v28 = *(const char **)(a2 + 32);
        double v29 = *(double *)(a2 + 112);
        uint64_t v30 = sub_10016BA10();
        double v31 = sub_10018202C(v30);
        *(_DWORD *)uint64_t buf = 134350595;
        *(void *)&uint8_t buf[4] = v25;
        __int16 v54 = 2082;
        long long v55 = v26;
        __int16 v56 = 2049;
        uint64_t v57 = v27;
        __int16 v58 = 2049;
        int v59 = v28;
        __int16 v60 = 2050;
        double v61 = v29;
        __int16 v62 = 2050;
        double v63 = v12;
        __int16 v64 = 2050;
        double v65 = v31;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#Warning,Got expiredLocation,timestamp_ios,%{public}.3f,provider,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,lifespan,%{public}.1f,age,%{public}.3f,propagation_us,%{public}.3f", buf, 0x48u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419510 != -1) {
          dispatch_once(&qword_102419510, &stru_1022FFA18);
        }
        sub_10003E9A4(*(_DWORD *)(a2 + 128));
        uint64_t v50 = sub_10016BA10();
        sub_10018202C(v50);
        __int16 v51 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::ageCheckLocation(LCFusionProviderLocation &, BOOL &, BOOL &)", "%s\n", v51);
        if (v51 != buf) {
          free(v51);
        }
      }
      *a4 = 1;
      long long v32 = *v10;
      long long v33 = v10[1];
      long long v34 = v10[3];
      *(_OWORD *)(a1 + 1008) = v10[2];
      *(_OWORD *)(a1 + 1024) = v34;
      *(_OWORD *)(a1 + 976) = v32;
      *(_OWORD *)(a1 + 992) = v33;
      long long v35 = v10[4];
      long long v36 = v10[5];
      long long v37 = v10[6];
      *(_OWORD *)(a1 + 1084) = *(long long *)((char *)v10 + 108);
      *(_OWORD *)(a1 + 1072) = v37;
      *(_OWORD *)(a1 + 1056) = v36;
      *(_OWORD *)(a1 + 1040) = v35;
    }
  }
  else
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022FFA18);
    }
    uint64_t v13 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a2 + 16);
      long long v14 = *(const char **)(a2 + 24);
      uint64_t v16 = *(void *)(a2 + 32);
      long long v17 = sub_10003E9A4(*(_DWORD *)(a2 + 128));
      double v18 = *(double *)v10;
      uint64_t v19 = sub_10016BA10();
      double v20 = sub_10018202C(v19);
      *(_DWORD *)uint64_t buf = 134350851;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v54 = 2049;
      long long v55 = v14;
      __int16 v56 = 2049;
      uint64_t v57 = v16;
      __int16 v58 = 2082;
      int v59 = v17;
      __int16 v60 = 2050;
      double v61 = v12;
      __int16 v62 = 2050;
      double v63 = v18;
      __int16 v64 = 2050;
      double v65 = v9;
      __int16 v66 = 2050;
      double v67 = v20;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#Warning,Got location with future timestamp,mct,%{public}.3f,lat,%{private}.7f,lon,%{private}.7f,provider,%{public}s,age,%{public}.3f,timestampiOS,%{public}.3f,correcting to,%{public}.3f,propagation_us,%{public}.3f", buf, 0x52u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022FFA18);
      }
      sub_10003E9A4(*(_DWORD *)(a2 + 128));
      uint64_t v48 = sub_10016BA10();
      sub_10018202C(v48);
      int v49 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void cllcf::CLLCFusion::ageCheckLocation(LCFusionProviderLocation &, BOOL &, BOOL &)", "%s\n", v49);
      if (v49 != buf) {
        free(v49);
      }
    }
    *(double *)int v10 = v9;
    uint64_t v21 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 1;
    *(double *)(a2 + 16) = sub_10016BA54(v21, buf);
  }
}

void sub_100192E84(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1001C7F8C(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100192E94(uint64_t a1, _DWORD *a2, float *a3)
{
  sub_1001AAA04(a1, a2, a3);
  switch(*a2)
  {
    case 0:
      sub_100D4F270(a1 + 13176, (int *)a3);
      break;
    case 1:
      sub_100D4FB84(a1 + 13176);
      break;
    case 2:
      double v6 = *(double *)a3;
      sub_100D4F0A0(a1 + 13176, v6);
      break;
    case 3:
      float v7 = a3[2];
      double v8 = *(double *)a3;
      sub_10019C374(a1 + 13176, v7, v8);
      break;
    default:
      return;
  }
}

void sub_100192FA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022D75E8;
  sub_1001A4C64((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_10019300C(void *result)
{
  *uint64_t result = off_1022D75E8;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0;
  result[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[4] = 0;
  return result;
}

double sub_10019303C(uint64_t a1)
{
  *(void *)a1 = off_1022AF238;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 29) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  return result;
}

void sub_100193078(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102305208;
  sub_100193104(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void *sub_1001930E0(void *result)
{
  *double result = off_102305208;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

void *sub_100193104(void *result)
{
  if ((void *)qword_10248AF50 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    double result = (void *)v1[2];
    if (result)
    {
      unint64_t v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

uint64_t sub_1001931A4(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) |= 8u;
  if (!*(void *)(a1 + 32)) {
    operator new();
  }
  return *(void *)(a1 + 32);
}

void sub_100193200()
{
}

void sub_100193224(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102304F38;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248AF20 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_1001932B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100193224(a1);

  operator delete();
}

void *sub_1001932E8(void *result)
{
  result[1] = 0;
  result[2] = 0;
  *double result = &off_102304F38;
  return result;
}

void *sub_10019330C(void *result)
{
  *double result = off_102304CE0;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0;
  return result;
}

void sub_100193338(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102304E48;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_10019338C(uint64_t a1)
{
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)a1 = off_102304E48;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 31) = 0;
  *(void *)&double result = 0x100000001;
  *(_OWORD *)(a1 + 48) = xmmword_101D06890;
  return result;
}

void sub_1001933C8(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102305280;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248AF48 != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100193454(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1001933C8(a1);

  operator delete();
}

void *sub_10019348C(void *result)
{
  *double result = &off_102305280;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

void sub_1001934B0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102304FB0;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248AF18 != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_10019353C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1001934B0(a1);

  operator delete();
}

void *sub_100193574(void *result)
{
  *double result = &off_102304FB0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

void sub_100193598(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_1022AF760;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_102489D90 != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100193624(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100193598(a1);

  operator delete();
}

uint64_t sub_10019365C(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = &off_1022AF760;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100193688(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) |= 2u;
  if (!*(void *)(a1 + 16)) {
    operator new();
  }
  return *(void *)(a1 + 16);
}

void sub_1001936E4()
{
}

void sub_100193708(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102304D58;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248AEF0 != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100193794(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100193708(a1);

  operator delete();
}

void *sub_1001937CC(void *result)
{
  *double result = &off_102304D58;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

uint64_t sub_1001937F0(uint64_t result)
{
  *(void *)double result = off_1022AEFE0;
  *(_DWORD *)(result + 8) = 0;
  *(unsigned char *)(result + 12) = 0;
  *(void *)(result + 16) = 0;
  return result;
}

double sub_10019381C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_1022AF418;
  *(void *)(a1 + 22) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return result;
}

void *sub_100193850(void *result)
{
  if ((void *)qword_102489D58 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[8];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    double result = (void *)v1[10];
    if (result)
    {
      unint64_t v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

void sub_1001938F0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022B11A0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

double sub_100193944(uint64_t a1)
{
  *(void *)a1 = off_1022B11A0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 37) = 0;
  return result;
}

void sub_10019397C(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a2 + 44);
  if (v2 >= 0.0)
  {
    double v4 = *(double *)(a2 + 52);
    if (v4 <= 0.0)
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022B5B60);
      }
      double v8 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a2 + 44);
        *(_DWORD *)uint64_t buf = 134217984;
        uint64_t v12 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#Warning Latest speed is %lf but no information about speed uncertainty", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022B5B60);
        }
        int v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL hasValidSpeedEstimate(const CLDaemonLocation &)", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
      }
    }
    else
    {
      double v6 = *(double *)(a2 + 76);
      sub_1004B689C((void *)a1, v2 - v4, v6);
      if (sub_1004B6A04((void *)a1) >= 4.16666667 && *(_DWORD *)a1 == 1)
      {
        if (!*(unsigned char *)(a1 + 8)) {
          *(unsigned char *)(a1 + 8) = 1;
        }
        *(double *)(a1 + 16) = v6;
        *(_DWORD *)(a1 + 4) = 1;
      }
    }
  }
}

uint64_t sub_100193BA4(uint64_t a1, float *a2, float *a3, __n128 a4, __n128 a5)
{
  double v5 = a5.n128_f64[0];
  float v6 = a4.n128_f32[0];
  uint64_t v10 = *(void *)(a1 + 488);
  if (v10) {
    (*(void (**)(uint64_t, float *, float *, __n128, __n128))(*(void *)v10 + 208))(v10, a2, a3, a4, a5);
  }
  if (fabsf(*a2) > 75.0 || fabsf(a2[1]) > 75.0 || fabsf(a2[2]) > 75.0) {
    return 0;
  }
  uint64_t result = 0;
  if (*a3 <= 0.01 && a3[1] <= 0.01 && a3[2] <= 0.01)
  {
    uint64_t v12 = *(void *)(a1 + 504);
    if (*(void *)(a1 + 496) != v12
      && vabdd_f64(*(double *)(v12 - 16), v5) < 30.0
      && vabds_f32(*(float *)(v12 - 32), v6) < 2.0)
    {
      return 0;
    }
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    uint64_t v52 = 0;
    long long v48 = 0u;
    long long v47 = 0u;
    long long v46 = 0u;
    long long v45 = 0u;
    long long v44 = 0u;
    long long v43 = 0u;
    long long v42 = 0u;
    long long v41 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    double v32 = v5;
    *(float *)&long long v33 = v6;
    int v31 = 3;
    (*(void (**)(uint64_t, int *, double *, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, &v31, &v32, 1, 0xFFFFFFFFLL, 0);
    float v14 = *a2;
    int v13 = *((_DWORD *)a2 + 1);
    int v15 = *((_DWORD *)a2 + 2);
    unint64_t v16 = *(void *)(a1 + 504);
    unint64_t v17 = *(void *)(a1 + 512);
    if (v16 >= v17)
    {
      uint64_t v19 = *(void *)(a1 + 496);
      uint64_t v20 = (uint64_t)(v16 - v19) >> 5;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 59) {
        sub_1001D7FD4();
      }
      uint64_t v22 = v17 - v19;
      if (v22 >> 4 > v21) {
        unint64_t v21 = v22 >> 4;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23) {
        unint64_t v23 = (unint64_t)sub_10017EAB8(v23);
      }
      else {
        uint64_t v24 = 0;
      }
      unint64_t v25 = v23 + 32 * v20;
      unint64_t v26 = v23 + 32 * v24;
      *(float *)unint64_t v25 = v6;
      *(float *)(v25 + 4) = v14;
      *(_DWORD *)(v25 + 8) = v13;
      *(_DWORD *)(v25 + 12) = v15;
      *(double *)(v25 + 16) = v5;
      *(void *)(v25 + 24) = 0;
      unint64_t v18 = v25 + 32;
      int v28 = *(char **)(a1 + 496);
      uint64_t v27 = *(char **)(a1 + 504);
      if (v27 != v28)
      {
        do
        {
          long long v29 = *((_OWORD *)v27 - 1);
          *(_OWORD *)(v25 - 32) = *((_OWORD *)v27 - 2);
          *(_OWORD *)(v25 - 16) = v29;
          v25 -= 32;
          v27 -= 32;
        }
        while (v27 != v28);
        uint64_t v27 = *(char **)(a1 + 496);
      }
      *(void *)(a1 + 496) = v25;
      *(void *)(a1 + 504) = v18;
      *(void *)(a1 + 512) = v26;
      if (v27) {
        operator delete(v27);
      }
    }
    else
    {
      *(float *)unint64_t v16 = v6;
      *(float *)(v16 + 4) = v14;
      *(_DWORD *)(v16 + 8) = v13;
      *(_DWORD *)(v16 + 12) = v15;
      *(double *)(v16 + 16) = v5;
      unint64_t v18 = v16 + 32;
      *(void *)(v16 + 24) = 0;
    }
    *(void *)(a1 + 504) = v18;
    [*(id *)(a1 + 264) nextFireDelay];
    if (v30 == 1.79769313e308) {
      [*(id *)(a1 + 264) setNextFireDelay:*(double *)(a1 + 408)];
    }
    return 1;
  }
  return result;
}

uint64_t sub_100193EA8(uint64_t a1, const char *a2, unsigned char *a3, double a4, long double a5)
{
  uint64_t v11 = a1 + 8;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v46 = a1 + 8;
  (*(void (**)(uint64_t))(v10 + 16))(a1 + 8);
  __int16 v47 = 256;
  sub_100142F58(a5);
  double v12 = (a4 + 90.0) * 20.0;
  double v14 = v13 * 20.0;
  int v15 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 0x80000000) == 0)
  {
    int v16 = *(_DWORD *)(a1 + 4);
    if ((v16 & 0x80000000) == 0
      && v14 - (double)(v16 + 1) < 0.005
      && (double)v16 - v14 < 0.005
      && v12 - (double)(v15 + 1) < 0.005
      && (double)v15 - v12 < 0.005)
    {
      *a3 = 0;
      uint64_t v17 = *(unsigned int *)(a1 + 24);
      goto LABEL_79;
    }
  }
  int v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  memset(v52, 0, sizeof(v52));
  __int16 v56 = 0;
  char v57 = 0;
  *a3 = 1;
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_1023247F8);
  }
  unint64_t v18 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
  {
    double v19 = *(double *)&a2;
    if (a2[23] < 0) {
      double v19 = *(double *)a2;
    }
    *(_DWORD *)uint64_t buf = 136446210;
    double v51 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "CLSE,getSignalEnvironment,opening,%{public}s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    double v42 = *(double *)&a2;
    if (a2[23] < 0) {
      double v42 = *(double *)a2;
    }
    int v48 = 136446210;
    double v49 = v42;
    long long v43 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v43);
    if (v43 != (char *)buf) {
      free(v43);
    }
  }
  uint64_t v20 = a2;
  if (a2[23] < 0) {
    uint64_t v20 = *(const char **)a2;
  }
  __int16 v56 = fopen(v20, "rb");
  if (!v56)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    unint64_t v26 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      double v27 = *(double *)&a2;
      if (a2[23] < 0) {
        double v27 = *(double *)a2;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      double v51 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "#Warning,CLSE,getSignalEnvironment,could not open,%{public}s", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    if (a2[23] < 0) {
      a2 = *(const char **)a2;
    }
LABEL_40:
    int v48 = 136446210;
    double v49 = *(double *)&a2;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v28);
    goto LABEL_112;
  }
  if (!sub_1013F83A8((uint64_t)v52))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v29 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      double v30 = *(double *)&a2;
      if (a2[23] < 0) {
        double v30 = *(double *)a2;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      double v51 = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "#Warning,CLSE,getSignalEnvironment,could not read,%{public}s", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    if (a2[23] < 0) {
      a2 = *(const char **)a2;
    }
    goto LABEL_40;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v22 = *(double *)&v54;
  unsigned int v23 = DWORD2(v54);
  if (Current <= v22 + (double)v23 + (double)(random() % 86400))
  {
    *a3 = 0;
  }
  else
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    uint64_t v24 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "CLSE,getSignalEnvironment,file has expired - redownload", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1023247F8);
      }
      LOWORD(v48) = 0;
      unint64_t v25 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v25);
      if (v25 != (char *)buf) {
        free(v25);
      }
    }
  }
  if (BYTE8(v53) != 1)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v37 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "CLSE,getSignalEnvironment,file version does not match expected", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    LOWORD(v48) = 0;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v28);
    goto LABEL_112;
  }
  int v31 = (int)v14;
  int v32 = (int)v12;
  if ((double)SBYTE10(v53) > a4 || (double)SBYTE11(v53) <= a4)
  {
    *(_DWORD *)a1 = v32;
    *(_DWORD *)(a1 + 4) = v31;
    *(_DWORD *)(a1 + 24) = 0;
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v39 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 134283521;
      double v51 = a4;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "#Warning,CLSE,getSignalEnvironment,latitude,%{private}.9lf,out of range", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1023247F8);
      }
      int v48 = 134283521;
      double v49 = a4;
      long long v44 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v44);
      if (v44 != (char *)buf) {
        free(v44);
      }
    }
    uint64_t v17 = *(unsigned int *)(a1 + 24);
    goto LABEL_77;
  }
  int v33 = v31 + 7200 * (v32 - 20 * SBYTE10(v53) - 1800);
  unsigned __int8 __ptr = 0;
  if ((v33 / 2) >= HIDWORD(v54))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v40 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v51) = v33 / 2;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "#Warning,CLSE,getSignalEnvironment,byte index,%{public}d,is larger than the data available in the coarse signal environment binary file", buf, 8u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    int v48 = 67240192;
    LODWORD(v49) = v33 / 2;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v28);
    goto LABEL_112;
  }
  long long v34 = v56;
  fseek(v56, v33 / 2, 1);
  if (fread(&__ptr, 1uLL, 1uLL, v34) != 1)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v41 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_INFO, "#Warning,CLSE,getSignalEnvironment,invalid coarse signal environment file - unable to get data byte", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    LOWORD(v48) = 0;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v28);
    goto LABEL_112;
  }
  unsigned int v35 = __ptr >> 4;
  if ((v31 & 1) == 0) {
    unsigned int v35 = __ptr & 0xF;
  }
  if (v35 >= 7 || ((0x4Fu >> v35) & 1) == 0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    long long v36 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "#Error,CLSE,getSignalEnvironment,unexpected case,potential file corruption", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_76;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1023247F8);
    }
    LOWORD(v48) = 0;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, BOOL &)", "%s\n", v28);
LABEL_112:
    if (v28 != (char *)buf) {
      free(v28);
    }
LABEL_76:
    uint64_t v17 = 0;
    goto LABEL_77;
  }
  uint64_t v17 = dword_101DB6548[v35];
  *(_DWORD *)(a1 + 24) = v17;
  *(_DWORD *)a1 = v32;
  *(_DWORD *)(a1 + 4) = v31;
LABEL_77:
  if (v56) {
    fclose(v56);
  }
LABEL_79:
  (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  return v17;
}

void sub_100194CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  float v6 = *(FILE **)(v4 + 136);
  if (v6) {
    fclose(v6);
  }
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

float sub_100194D30(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1001860C8(a2);
  float v4 = 0.0;
  if (v3 && *(double *)(a2 + 600) < *(double *)a2 && (sub_1014F0628(v3, (double *)a2) & 1) == 0)
  {
    float v6 = *(float *)(a2 + 1380);
    float v7 = *(float *)(a2 + 1384);
    float v8 = 1.0;
    if (v6 > v7)
    {
      float v9 = *(double *)(a2 + 560);
      float v8 = (v6 - v9) / (v6 - v7);
    }
    float v5 = *(float *)(a2 + 1368);
    return v5 * sub_101141BD8(v8, *(float *)(a2 + 1372));
  }
  return v4;
}

void sub_100194DD0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 3;
  *(void *)(a3 + 32) = 3;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 40))(&v32);
  float v6 = (*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 48))(&v29, a1, a2);
  float v7 = sub_100194D30((uint64_t)v6, a2);
  *(float *)a3 = v7;
  float v8 = v34;
  *(_DWORD *)(a3 + 12) = v33;
  *(_DWORD *)(a3 + 36) = v36;
  float v9 = -1.0;
  if (v7 > 0.0) {
    float v9 = (float)(v7 - v8) / v8;
  }
  *(float *)(a3 + 16) = v9;
  BOOL v11 = v8 > 2.1 && *(unsigned char *)(a1 + 8) != 0;
  BOOL v12 = v9 > 0.1 && v11;
  if (v12)
  {
    float v13 = v7;
    float v14 = v7;
    if (!*(unsigned char *)(a1 + 9))
    {
      float v15 = *(float *)(a1 + 12);
      float v16 = v8 * v15;
      if (v16 >= v7) {
        float v13 = v7;
      }
      else {
        float v13 = v16;
      }
      if ((float)(v15 * v35) >= v7) {
        float v14 = v7;
      }
      else {
        float v14 = v15 * v35;
      }
    }
    *(float *)(a3 + 20) = v13;
    *(float *)(a3 + 28) = v14;
    int v17 = 1;
    *(_DWORD *)(a3 + 24) = 1;
  }
  else
  {
    float v18 = v31;
    BOOL v19 = v30 > v8;
    if (v30 >= v8) {
      float v13 = v30;
    }
    else {
      float v13 = v8;
    }
    *(float *)(a3 + 20) = v13;
    *(_DWORD *)(a3 + 24) = 4 * v19;
    BOOL v20 = v18 > v35;
    if (v18 >= v35) {
      float v14 = v18;
    }
    else {
      float v14 = v35;
    }
    *(float *)(a3 + 28) = v14;
    int v17 = 4 * v20;
  }
  *(_DWORD *)(a3 + 32) = v17;
  int v21 = *(unsigned __int8 *)(a2 + 324);
  unsigned __int8 v22 = sub_100038F68(*(_DWORD *)(a2 + 288));
  float v23 = 1.6;
  if (((v21 != 0) & v22) != 0) {
    float v23 = 2.1;
  }
  if (v14 <= v23) {
    float v24 = v23;
  }
  else {
    float v24 = *(float *)(a3 + 28);
  }
  *(float *)(a3 + 28) = v24;
  float v25 = v34;
  float v26 = v30;
  *(float *)(a3 + 4) = v34;
  *(float *)(a3 + 8) = v26;
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_10232AC70);
  }
  double v27 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134219520;
    double v52 = v25;
    __int16 v53 = 2048;
    double v54 = v26;
    __int16 v55 = 2048;
    double v56 = v7;
    __int16 v57 = 2048;
    double v58 = v9;
    __int16 v59 = 1024;
    BOOL v60 = v12;
    __int16 v61 = 2048;
    double v62 = v13;
    __int16 v63 = 2048;
    double v64 = v24;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "Pedestrian, wrMets, %f,  fmMets, %f, hrMets, %f, hrwrDiff, %f, useHrMets, %d, userMets, %f, truthMets, %f", buf, 0x44u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10232AC70);
    }
    int v37 = 134219520;
    double v38 = v25;
    __int16 v39 = 2048;
    double v40 = v26;
    __int16 v41 = 2048;
    double v42 = v7;
    __int16 v43 = 2048;
    double v44 = v9;
    __int16 v45 = 1024;
    BOOL v46 = v12;
    __int16 v47 = 2048;
    double v48 = v13;
    __int16 v49 = 2048;
    double v50 = v24;
    int v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMetsInfo CLCaloriePedestrianModelInterface::computeMETS(const CLNatalieModelInput &)", "%s\n", v28);
    if (v28 != (char *)buf) {
      free(v28);
    }
  }
}

uint64_t sub_1001951DC(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 136);
  if (result) {
    return sub_100010EC4(result, a2);
  }
  return result;
}

uint64_t sub_1001951EC(void *a1, unsigned int *a2)
{
  sub_1000B015C();
  int v4 = *a2;
  if (*a2 >= 3)
  {
    if (v4 != 9)
    {
      [*(id *)(a1[25] + 16) register:*(void *)(a1[25] + 8) forNotification:*a2 registrationInfo:0];
      uint64_t v7 = 0;
      float v8 = dword_101D95854;
      while (dword_101D95848[v7] != *a2)
      {
        if (++v7 == 3) {
          goto LABEL_9;
        }
      }
      float v8 = &dword_101D95848[v7];
LABEL_9:
      if ((char *)v8 - (char *)dword_101D95848 != 12) {
        [*(id *)(a1[26] + 16) register:*(void *)(a1[26] + 8) forNotification:];
      }
    }
  }
  else
  {
    float v5 = (uint64_t **)a1[16];
    double Current = CFAbsoluteTimeGetCurrent();
    sub_100017358(v5, v4, 1, Current);
  }
  return 1;
}

void sub_1001952B8(unsigned __int16 *a1, unsigned int a2, unsigned int a3, int a4, double a5)
{
}

void sub_1001952C0(double a1, uint64_t a2, uint64_t a3)
{
  double v3 = a1 + -2.56;
  double v4 = *(double *)(a3 + 32);
  if (v4 < a1 + -2.56) {
    double v4 = a1 + -2.56;
  }
  if (v4 <= a1) {
    double v3 = v4;
  }
  *(double *)(a3 + 24) = v3;
  *(double *)(a3 + 32) = a1;
}

uint64_t sub_1001952E8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a2, *(void *)(a1 + 8));
}

void sub_1001952F8(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a1)
  {
    case 2:
      if (1000000000 * *(void *)(a1 + 24) >= a2 - *(void *)(a1 + 8)) {
        int v4 = 2;
      }
      else {
        int v4 = 4;
      }
      goto LABEL_14;
    case 3:
      if (1000000000 * *(void *)(a1 + 16) >= a2 - *(void *)(a1 + 8)) {
        int v4 = 3;
      }
      else {
        int v4 = 4;
      }
      goto LABEL_14;
    case 5:
      if (1000000000 * *(void *)(a1 + 32) < a2 - *(void *)(a1 + 8)) {
        int v4 = 1;
      }
      else {
        int v4 = 5;
      }
      goto LABEL_14;
    case 6:
      if (1000000000 * *(void *)(a1 + 40) >= a2 - *(void *)(a1 + 8)) {
        int v4 = 6;
      }
      else {
        int v4 = 0;
      }
LABEL_14:
      if (v4 != *(_DWORD *)a1)
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_10229E280);
        }
        float v5 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
        {
          unsigned int v6 = *(_DWORD *)a1 - 1;
          if (v6 > 5) {
            uint64_t v7 = "running";
          }
          else {
            uint64_t v7 = (&off_10229E2B8)[v6];
          }
          uint64_t v8 = v4 - 1;
          if (v8 > 5) {
            float v9 = "running";
          }
          else {
            float v9 = (&off_10229E2B8)[v8];
          }
          *(_DWORD *)uint64_t buf = 136380931;
          BOOL v12 = v7;
          __int16 v13 = 2081;
          float v14 = v9;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "#indoor-fitness-classifier state change, current, %{private}s, updated, %{private}s", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_10229E280);
          }
          uint64_t v10 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorFitnessModeStateMachine::update(std::chrono::steady_clock::time_point)", "%s\n", v10);
          if (v10 != (char *)buf) {
            free(v10);
          }
        }
        *(void *)(a1 + 8) = a2;
        *(_DWORD *)a1 = v4;
      }
      break;
    default:
      return;
  }
}

double sub_100195640(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (!*a2)
  {
    double result = *(double *)a3;
    int v4 = *(_DWORD *)(a3 + 8);
    int v5 = *(_DWORD *)(a3 + 108);
    int v6 = *(_DWORD *)(a3 + 72);
    *(void *)(a1 + 162) = *(void *)a3;
    *(_DWORD *)(a1 + 170) = v4;
    *(_DWORD *)(a1 + 174) = v5;
    *(_DWORD *)(a1 + 178) = v6;
  }
  return result;
}

void sub_100195670(void **a1)
{
  uint64_t v2 = (uint64_t)a1[1];
  if (v2)
  {
    v4.n128_u64[0] = sub_100B47F88(v2, (double *)*a1);
    v4.n128_u64[1] = v3;
    sub_10111E538(*a1, &v4);
  }
}

uint64_t sub_1001956B8(uint64_t a1)
{
  return a1 + 3216;
}

uint64_t sub_1001956C0(uint64_t a1)
{
  return a1 + 3040;
}

uint64_t sub_1001956C8(uint64_t a1)
{
  return a1 + 2888;
}

uint64_t sub_1001956D0(uint64_t a1)
{
  return a1 + 2744;
}

uint64_t sub_1001956D8(uint64_t a1)
{
  return a1 + 2216;
}

uint64_t sub_1001956E8(void *a1)
{
  if (!sub_10009AD44(a1, @"activeType")) {
    sub_1001960EC((uint64_t)a1);
  }

  return sub_10009AC4C((uint64_t)a1);
}

void *sub_100195734@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "VisitMonitoring");
}

uint64_t sub_100195744(uint64_t result)
{
  if (*(unsigned char *)(result + 276))
  {
    uint64_t v1 = result;
    int v2 = *(_DWORD *)(result + 272);
    if (v2 == 1)
    {
      [*(id *)(result + 264) stopLeechingVisitsForClient:*(void *)(result + 256)];
    }
    else
    {
      if (v2)
      {
LABEL_7:
        *(unsigned char *)(v1 + 276) = 0;
LABEL_8:
        [objc_msgSend(*(id *)(v1 + 128), "vendor") proxyForService:@"CLClientManager"];
        unint64_t v3 = *(void **)(v1 + 64);
        if (v3) {
          [v3 clientName];
        }
        sub_1001C203C();
      }
      [*(id *)(result + 264) stopMonitoringVisitsForClient:*(void *)(result + 256)];
    }
    if (!*(unsigned char *)(v1 + 276)) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

void sub_100195878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100195890(uint64_t a1, double a2)
{
  if (*(void *)(a1 + 64))
  {
    __n128 v4 = (void *)(a1 + 24);
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + ((*(void *)(a1 + 56) >> 5) & 0x7FFFFFFFFFFFFF8));
      uint64_t v6 = *(void *)(a1 + 56);
      uint64_t v7 = *(void *)(v5 + 16 * v6);
      if (a2 - *(double *)(v7 + 8) <= *(double *)(a1 + 8)) {
        break;
      }
      uint64_t v8 = *(std::__shared_weak_count **)(v5 + 16 * v6 + 8);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022D7B08);
      }
      float v9 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
      {
        if (*(unsigned char *)(v7 + 24)) {
          uint64_t v10 = *(void *)(v7 + 16);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *(void *)(v7 + 8);
        *(_DWORD *)uint64_t buf = 134218240;
        uint64_t v14 = v11;
        __int16 v15 = 2048;
        uint64_t v16 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "converging state, pruning previous attempt, startTime, %f, endTime, %f", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022D7B08);
        }
        BOOL v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceConvergenceStateBudget::pruneAttemptsPredatingTime(CFAbsoluteTime)", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
      sub_1000962A4(v4);
      if (v8) {
        sub_1000DB0A0(v8);
      }
    }
    while (*(void *)(a1 + 64));
  }
}

void sub_100195B20(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1000DB0A0(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100195B3C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_10019F278(a1, a2);
  if (*(unsigned char *)(a2 + 352))
  {
    int v5 = *(_DWORD *)(a2 + 152);
    if (v5 == 8 || v5 == 12150) {
      int v7 = 12150;
    }
    else {
      int v7 = 17150;
    }
    float v8 = sub_101284E98(v7);
    uint64_t v9 = *(void *)(a2 + 336);
    if (v9 != 2 && (v9 == 1 || *(float *)(a3 + 20) < v8))
    {
      *(float *)(a3 + 20) = v8;
      *(_DWORD *)(a3 + 24) = 3;
    }
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A888);
    }
    uint64_t v10 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      double v11 = *(float *)(a3 + 20);
      int v12 = *(_DWORD *)(a3 + 24);
      *(_DWORD *)uint64_t buf = 134218752;
      double v15 = v11;
      __int16 v16 = 1024;
      int v17 = v12;
      __int16 v18 = 1024;
      int v19 = v9;
      __int16 v20 = 2048;
      double v21 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Pedestrian, mets, %.2f, metsSrc, %d, locationType, %d, fixedMets, %.2f", buf, 0x22u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A888);
      }
      __int16 v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMetsInfo CLCaloriePedestrianModelPhone::computeMETS(const CLNatalieModelInput &)", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
}

uint64_t sub_100195DB0(uint64_t a1, uint64_t a2)
{
  if ((sub_1000A68BC(*(void *)(a1 + 72)) > 0.0 || sub_1000A68BC(*(void *)(a1 + 88)) > 0.0) && *(unsigned char *)(a1 + 32))
  {
    if (*(_WORD *)a2 && *(_WORD *)(a2 + 2) && *(float *)(a2 + 4) > 0.0) {
      return 0;
    }
    uint64_t v5 = *(void *)(a1 + 24);
    goto LABEL_13;
  }
  uint64_t result = 0;
  if (*(_WORD *)a2 && *(_WORD *)(a2 + 2) && *(float *)(a2 + 4) > 0.0)
  {
    uint64_t v5 = 0;
LABEL_13:
    *(void *)a2 = v5;
    return 1;
  }
  return result;
}

void sub_100195E54(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a1 + 216) - 1) <= 1)
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1023069F0);
    }
    __n128 v4 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
    {
      double v5 = sub_1000A68BC(*(void *)(a1 + 104));
      *(_DWORD *)uint64_t buf = 134349056;
      double v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Background Stairs Escalation Manager, deescalating, remaining budget : %{public}f", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1023069F0);
      }
      sub_1000A68BC(*(void *)(a1 + 104));
      float v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLBackgroundEscalationManager::handleStairsDeescalation(CMActivityReason)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104));
    sub_100A19E7C(*(void *)(a1 + 104));
    double Current = CFAbsoluteTimeGetCurrent();
    double v7 = Current;
    if (*(void *)(a1 + 176) && !*(unsigned char *)(a1 + 34))
    {
      sub_100F6DD70(a1 + 152, 1, a2, 11, Current);
      *(unsigned char *)(a1 + 34) = 1;
    }
    if (*(_DWORD *)(a1 + 336) == 3 && v7 - *(double *)(a1 + 48) >= 30.0) {
      sub_100F6E97C(a1);
    }
    *(void *)(a1 + 48) = 0xBFF0000000000000;
    *(_DWORD *)(a1 + 216) = 0;
    *(unsigned char *)(a1 + 33) = 0;
    *(_DWORD *)(a1 + 336) = 0;
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 237) = 0;
    *(void *)(a1 + 320) = *(void *)(a1 + 312);
  }
}

void sub_1001960EC(uint64_t a1)
{
  sub_10009AFF4(a1);
  uint64_t v2 = *(void *)(a1 + 48);
  sub_10009AFB0(&v3, (void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16))(v2, &v3);
  if (v4) {
    sub_1000DB0A0(v4);
  }
}

void sub_100196160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100196178(uint64_t a1)
{
  sub_10009AFF4(a1);
  uint64_t v2 = *(void *)(a1 + 48);
  sub_10009AFB0(&v3, (void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 40))(v2, &v3);
  if (v4) {
    sub_1000DB0A0(v4);
  }
}

void sub_1001961EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100196204(uint64_t result, uint64_t a2)
{
  uint64_t v5 = a2;
  if (*(unsigned char *)(result + 248))
  {
    uint64_t v2 = (void *)result;
    uint64_t v3 = (uint64_t **)(result + 24);
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    sub_10017C814(v3, &v4);
    sub_10017F3C0(v2 + 20, &v5);
    return (*(uint64_t (**)(void *))(*v2 + 48))(v2);
  }
  return result;
}

uint64_t sub_1001962A8(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if (!*a2 || a1[6])
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_1022C5440);
    }
    uint64_t v9 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_FAULT))
    {
      BOOL v10 = a1[6] != 0;
      BOOL v11 = *a2 != 0;
      *(_DWORD *)uint64_t buf = 68290051;
      int v19 = 0;
      __int16 v20 = 2082;
      double v21 = "";
      __int16 v22 = 1026;
      BOOL v23 = v10;
      __int16 v24 = 1026;
      BOOL v25 = v11;
      __int16 v26 = 2082;
      double v27 = "assert";
      __int16 v28 = 2081;
      uint64_t v29 = "persistence && !fPersistence";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Persistent subscription persistence must be set exactly once and set to a non-null value\", \"fPersistence\":%{public}hhd, \"persistence\":%{public}hhd, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_1022C5440);
      }
    }
    int v12 = qword_102419528;
    if (os_signpost_enabled((os_log_t)qword_102419528))
    {
      BOOL v13 = a1[6] != 0;
      BOOL v14 = *a2 != 0;
      *(_DWORD *)uint64_t buf = 68290051;
      int v19 = 0;
      __int16 v20 = 2082;
      double v21 = "";
      __int16 v22 = 1026;
      BOOL v23 = v13;
      __int16 v24 = 1026;
      BOOL v25 = v14;
      __int16 v26 = 2082;
      double v27 = "assert";
      __int16 v28 = 2081;
      uint64_t v29 = "persistence && !fPersistence";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Persistent subscription persistence must be set exactly once and set to a non-null value", "{\"msg%{public}.0s\":\"Persistent subscription persistence must be set exactly once and set to a non-null value\", \"fPersistence\":%{public}hhd, \"persistence\":%{public}hhd, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_1022C5440);
      }
    }
    double v15 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_INFO))
    {
      BOOL v16 = a1[6] != 0;
      BOOL v17 = *a2 != 0;
      *(_DWORD *)uint64_t buf = 68290051;
      int v19 = 0;
      __int16 v20 = 2082;
      double v21 = "";
      __int16 v22 = 1026;
      BOOL v23 = v16;
      __int16 v24 = 1026;
      BOOL v25 = v17;
      __int16 v26 = 2082;
      double v27 = "assert";
      __int16 v28 = 2081;
      uint64_t v29 = "persistence && !fPersistence";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Persistent subscription persistence must be set exactly once and set to a non-null value\", \"fPersistence\":%{public}hhd, \"persistence\":%{public}hhd, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
  }
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[7];
  a1[6] = v4;
  a1[7] = v5;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  double v7 = *(uint64_t (**)(void *))(*a1 + 64);

  return v7(a1);
}

void sub_100196600(uint64_t a1, uint64_t a2, double a3)
{
  if (*(unsigned char *)(a1 + 258))
  {
    uint64_t v9 = *(void *)(a2 + 8);
    int v10 = *(_DWORD *)(a2 + 4);
    double v7 = a3;
    int v8 = 2;
    sub_1015131E0(a1, (uint64_t *)&v7);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v4 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67174913;
      int v16 = v10;
      __int16 v17 = 2048;
      double v18 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController_feedGnssAvailability,gnssAvailabilityEvidence,%{private}d,currentTime,%f", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      int v11 = 67174913;
      int v12 = v10;
      __int16 v13 = 2048;
      double v14 = a3;
LABEL_19:
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLOutdoorEstimatorController::feedGnssAvailability(const CLLocationProvider_Type::PredictedGnssAvailability &, const CFAbsoluteTime)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v5 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController,CLOutdoorEstimatorTurnOffGnssAvailability", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      LOWORD(v7) = 0;
      goto LABEL_19;
    }
  }
}

void sub_1001968CC(uint64_t a1, long long *a2, double a3)
{
  if (*(unsigned char *)(a1 + 260))
  {
    long long v4 = a2[1];
    long long v10 = *a2;
    long long v11 = v4;
    double v8 = a3;
    int v9 = 6;
    sub_101513DA4(a1, &v8);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v5 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134283777;
      uint64_t v17 = *((void *)&v10 + 1);
      __int16 v18 = 2048;
      double v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController_feedCMGpsModelOutput,gpsModelOutputEvidence,%{private}f,currentTime,%f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      int v12 = 134283777;
      uint64_t v13 = *((void *)&v10 + 1);
      __int16 v14 = 2048;
      double v15 = a3;
LABEL_19:
      double v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLOutdoorEstimatorController::feedCMGpsModelOutput(const CLOutdoorEstimator_Type::CMGpsModelOutput &, const CFAbsoluteTime)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v6 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController,CLOutdoorEstimatorTurnOffCMGpsModelOutput", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      LOWORD(v8) = 0;
      goto LABEL_19;
    }
  }
}

void sub_100196B90(uint64_t a1, long long *a2, double a3)
{
  if (*(unsigned char *)(a1 + 262))
  {
    long long v9 = *a2;
    double v7 = a3;
    int v8 = 5;
    sub_101514B1C(a1, &v7);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    long long v4 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134283777;
      uint64_t v15 = *((void *)&v9 + 1);
      __int16 v16 = 2048;
      double v17 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController_feedCMAlsModelOutput,alsModelOutputEvidence,%{private}f,currentTime,%f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      int v10 = 134283777;
      uint64_t v11 = *((void *)&v9 + 1);
      __int16 v12 = 2048;
      double v13 = a3;
LABEL_19:
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLOutdoorEstimatorController::feedCMAlsModelOutput(const CLOutdoorEstimator_Type::CMALSModelOutput &, const CFAbsoluteTime)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v5 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController,CLOutdoorEstimatorTurnOffCMAlsModelOutput", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      LOWORD(v7) = 0;
      goto LABEL_19;
    }
  }
}

void sub_100196E54(uint64_t a1, int a2, double a3)
{
  if (*(unsigned char *)(a1 + 257))
  {
    double v7 = a3;
    int v8 = 1;
    int v9 = a2;
    sub_10004D038(a1, (uint64_t *)&v7);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    long long v4 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67174913;
      int v15 = v9;
      __int16 v16 = 2048;
      double v17 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController_feedMotionActivity,activityStateEvidence,%{private}d,currentTime,%f", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      int v10 = 67174913;
      int v11 = v9;
      __int16 v12 = 2048;
      double v13 = a3;
LABEL_19:
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLOutdoorEstimatorController::feedMotionActivity(const CMMotionContext::MotionType, const CFAbsoluteTime)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1023217E0);
    }
    uint64_t v5 = qword_1024194F8;
    if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLOutdoorEstimatorController,CLOutdoorEstimatorTurnOffMotionActivity", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194F0 != -1) {
        dispatch_once(&qword_1024194F0, &stru_1023217E0);
      }
      LOWORD(v10) = 0;
      goto LABEL_19;
    }
  }
}

uint64_t sub_100197110(int *a1)
{
  uint64_t v1 = *a1;
  if (v1 < 6) {
    return dword_101D23BD8[v1];
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BD0F8);
  }
  long long v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67109120;
    int v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertMotionStateMediatorNotificationTypeToProtobuf,unhandled type,%d", buf, 8u);
  }
  uint64_t result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::MotionStateMediatorNotification_NotificationType CLLocationControllerRecorder::convertMotionStateMediatorNotificationTypeToProtobuf(const CLMotionStateMediator_Type::Notification &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001972E4(int *a1)
{
  uint64_t v2 = *a1;
  if v2 < 0xA && ((0x21Fu >> v2)) {
    return dword_101D23BF0[v2];
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BD0F8);
  }
  uint64_t v3 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67109120;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertAppMonitorNotificationTypeToProtobuf,unhandled type,%d", buf, 8u);
  }
  uint64_t result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::AppMonitorNotification_NotificationType CLLocationControllerRecorder::convertAppMonitorNotificationTypeToProtobuf(const CLAppMonitor_Type::Notification &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001974C0(int *a1)
{
  if (!*a1) {
    return 1;
  }
  if (*a1 == 1) {
    return 2;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BD0F8);
  }
  uint64_t v3 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67109120;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertPipelineOperatingModeTypeToProtobuf,unhandled type,%d", buf, 8u);
  }
  uint64_t result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::PipelineOperatingMode CLLocationControllerRecorder::convertPipelineOperatingModeTypeToProtobuf(const CLLocationProvider_Type::PipelineOperatingMode &)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
    return 0;
  }
  return result;
}

uint64_t sub_100197698(int *a1)
{
  int v1 = *a1;
  if (!*a1) {
    return 1;
  }
  if (v1 == 11) {
    return 3;
  }
  if (v1 == 10) {
    return 2;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BD0F8);
  }
  int v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67109120;
    int v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#locctl,#rec,convertOperatingModeTypeToProtobuf,unhandled type,%d", buf, 8u);
  }
  uint64_t result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BD0F8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static CLP::LogEntry::PrivateData::OperatingMode CLLocationControllerRecorder::convertOperatingModeTypeToProtobuf(const CLLocationProvider_Type::OperatingMode &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_100197880(uint64_t a1, _DWORD *a2)
{
  if (*a2 >= 3u) {
    [*(id *)(*(void *)(a1 + 168) + 16) register:*(void *)(*(void *)(a1 + 168) + 8) forNotification:*(void *)(*(void *)(a1 + 168) + 16)];
  }
  return 1;
}

uint64_t sub_1001978C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 72))();
}

uint64_t sub_1001978F0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(**(void **)(a1 + 32) + 120))(*(void *)(a1 + 32), *(void *)(a1 + 24), a2, *(void *)(a1 + 16));
}

void sub_100197924(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 156)
    && vabdd_f64(CFAbsoluteTimeGetCurrent(), *(double *)(a1 + 144)) > (double)*(int *)(a1 + 152) * 21.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022F9058);
    }
    uint64_t v2 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 408);
      if (*(char *)(a1 + 431) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      int v4 = (void *)(a1 + 432);
      if (*(char *)(a1 + 455) < 0) {
        int v4 = (void *)*v4;
      }
      *(_DWORD *)uint64_t buf = 136446722;
      *(void *)&uint8_t buf[4] = v3;
      __int16 v20 = 2082;
      double v21 = v4;
      __int16 v22 = 2050;
      uint64_t v23 = 0x4035000000000000;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLSE,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022F9058);
      }
      int v9 = (void *)(a1 + 408);
      if (*(char *)(a1 + 431) < 0) {
        int v9 = (void *)*v9;
      }
      int v10 = (void *)(a1 + 432);
      if (*(char *)(a1 + 455) < 0) {
        int v10 = (void *)*v10;
      }
      *(_DWORD *)__int16 v14 = 136446722;
      *(void *)&v14[4] = v9;
      __int16 v15 = 2082;
      __int16 v16 = v10;
      __int16 v17 = 2050;
      uint64_t v18 = 0x4035000000000000;
      int v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignalEnvironmentProvider::downloadFileIfNeeded()", "%s\n", v11);
      if (v11 != buf) {
        free(v11);
      }
    }
    *(CFAbsoluteTime *)(a1 + 144) = CFAbsoluteTimeGetCurrent();
    *(void *)__int16 v14 = 0x404E000000000000;
    int v5 = (const std::string::value_type *)(a1 + 408);
    if (*(char *)(a1 + 431) < 0) {
      int v5 = *(const std::string::value_type **)v5;
    }
    uint64_t v6 = (const std::string::value_type *)(a1 + 432);
    if (*(char *)(a1 + 455) < 0) {
      uint64_t v6 = *(const std::string::value_type **)v6;
    }
    if (sub_1005C653C(a1 + 160, v5, v6, (double *)v14))
    {
      *(void *)uint64_t buf = 0x414BAF7F80000000;
      if (sub_1005C6BBC(a1 + 160, &dbl_101D90288, (double *)buf))
      {
        *(double *)uint64_t buf = CFAbsoluteTimeGetCurrent() + 21.0 + -0.5;
        sub_1005C6FFC((double *)(a1 + 160), (double *)buf);
        return;
      }
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022F9058);
      }
      int v7 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "CLSE,could not setUpdateSource AVL file updater", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_1022F9058);
        }
        double v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignalEnvironmentProvider::downloadFileIfNeeded()", "%s\n", v13);
        if (v13 != buf) {
          free(v13);
        }
      }
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022F9058);
    }
    int v8 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "CLSE,could not setUpdateRate AVl file updater", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022F9058);
      }
      __int16 v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLSignalEnvironmentProvider::downloadFileIfNeeded()", "%s\n", v12);
      if (v12 != buf) {
        free(v12);
      }
    }
  }
}

uint64_t sub_100197E58(uint64_t a1)
{
  *(_DWORD *)a1 = 16777472;
  *(unsigned char *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 5) = 0;
  *(_OWORD *)(a1 + 28) = xmmword_101D2C9F0;
  *(_OWORD *)(a1 + 44) = xmmword_101D2CA00;
  *(_DWORD *)(a1 + 60) = 400;
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 80) = v2;
  *(_OWORD *)(a1 + 96) = v2;
  *(_OWORD *)(a1 + 112) = v2;
  *(_OWORD *)(a1 + 128) = v2;
  *(_DWORD *)(a1 + 144) = -1;
  *(_OWORD *)(a1 + 148) = xmmword_101D2CA10;
  *(_OWORD *)(a1 + 12) = xmmword_101D2CA20;
  if (sub_10016CCBC()) {
    *(_DWORD *)(a1 + 16) = 4233600;
  }
  *(_DWORD *)(a1 + 72) = 125000;
  *(_DWORD *)(a1 + 84) = 125000;
  *(_DWORD *)(a1 + 96) = 125000;
  *(_DWORD *)(a1 + 108) = 15000;
  *(_DWORD *)(a1 + 120) = 25000;
  *(_DWORD *)(a1 + 132) = -1;
  *(_DWORD *)(a1 + 144) = -1;
  return a1;
}

uint64_t sub_100197F20(uint64_t **a1, const void **a2, uint64_t a3)
{
  int v4 = (long long *)a2;
  if (sub_100040D3C((uint64_t)a1, a2)
    || (int v4 = (long long *)&unk_10247DA60, (result = sub_100040D3C((uint64_t)a1, (const void **)&unk_10247DA60)) != 0))
  {
    __int16 v16 = v4;
    int v7 = sub_10017CA70(a1, (const void **)v4, (uint64_t)&unk_101D0B290, &v16);
    long long v8 = *((_OWORD *)v7 + 29);
    long long v9 = *((_OWORD *)v7 + 31);
    *(_OWORD *)(a3 + 16) = *((_OWORD *)v7 + 30);
    *(_OWORD *)(a3 + 32) = v9;
    *(_OWORD *)a3 = v8;
    long long v10 = *((_OWORD *)v7 + 32);
    long long v11 = *((_OWORD *)v7 + 33);
    long long v12 = *((_OWORD *)v7 + 35);
    *(_OWORD *)(a3 + 80) = *((_OWORD *)v7 + 34);
    *(_OWORD *)(a3 + 96) = v12;
    *(_OWORD *)(a3 + 48) = v10;
    *(_OWORD *)(a3 + 64) = v11;
    long long v13 = *((_OWORD *)v7 + 36);
    long long v14 = *((_OWORD *)v7 + 37);
    long long v15 = *((_OWORD *)v7 + 38);
    *(_DWORD *)(a3 + 160) = *((_DWORD *)v7 + 156);
    *(_OWORD *)(a3 + 128) = v14;
    *(_OWORD *)(a3 + 144) = v15;
    *(_OWORD *)(a3 + 112) = v13;
    return 1;
  }
  return result;
}

void sub_100197FD4(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 384) || !*(unsigned char *)(a1 + 385))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102318208);
    }
    long long v12 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(unsigned __int8 *)(a1 + 384);
      int v14 = *(unsigned __int8 *)(a1 + 385);
      LODWORD(buf[0]) = 67240448;
      DWORD1(buf[0]) = v13;
      WORD4(buf[0]) = 1026;
      *(_DWORD *)((char *)buf + 10) = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#LCStats,homeVisit,stats not calculated,isHomeVisit,%{public}d,isStatic,%{public}d", (uint8_t *)buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102318208);
      }
      int v15 = *(unsigned __int8 *)(a1 + 384);
      int v16 = *(unsigned __int8 *)(a1 + 385);
      *(_DWORD *)double v50 = 67240448;
      *(_DWORD *)&v50[4] = v15;
      *(_WORD *)&v50[8] = 1026;
      *(_DWORD *)&v50[10] = v16;
      long long v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerCAStats::calcHomeVisitStats(const CLDaemonLocation &)", "%s\n", v11);
      goto LABEL_79;
    }
    return;
  }
  double v4 = sub_10016C458();
  double v5 = *(double *)(a1 + 400);
  sub_1000C7F88(buf);
  *(void *)double v50 = 0;
  double v6 = v4 - v5;
  if (sub_1000A699C(*(uint64_t *)&buf[0], "homeVisitAtRestThrSec", v50)) {
    double v7 = *(double *)v50;
  }
  else {
    double v7 = 300.0;
  }
  if (*((void *)&buf[0] + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&buf[0] + 1));
  }
  if (v6 < v7)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102318208);
    }
    long long v8 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      float v9 = v6;
      LODWORD(buf[0]) = 134349056;
      *(double *)((char *)buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#LCStats,homeVisit,stats not computed, duration being at rest for %{public}0.1f sec", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102318208);
      }
      float v10 = v6;
      *(_DWORD *)double v50 = 134349056;
      *(double *)&v50[4] = v10;
      long long v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerCAStats::calcHomeVisitStats(const CLDaemonLocation &)", "%s\n", v11);
LABEL_79:
      if (v11 != (char *)buf) {
        free(v11);
      }
      return;
    }
    return;
  }
  sub_1000F1268((double *)(a1 + 176), a1 + 408, a2);
  double v19 = v18;
  uint64_t v20 = *(void *)(a1 + 576);
  if (!v20) {
    goto LABEL_35;
  }
  int v21 = *(_DWORD *)(a2 + 96);
  uint64_t v22 = a1 + 576;
  do
  {
    int v23 = *(_DWORD *)(v20 + 32);
    BOOL v24 = v23 < v21;
    if (v23 >= v21) {
      BOOL v25 = (uint64_t *)v20;
    }
    else {
      BOOL v25 = (uint64_t *)(v20 + 8);
    }
    if (!v24) {
      uint64_t v22 = v20;
    }
    uint64_t v20 = *v25;
  }
  while (*v25);
  if (v22 == a1 + 576 || v21 < *(_DWORD *)(v22 + 32))
  {
LABEL_35:
    memset((char *)&buf[1] + 8, 0, 40);
    double v26 = *(double *)(a2 + 20);
    *(double *)uint64_t buf = v18;
    *((double *)buf + 1) = v26;
    LODWORD(buf[1]) = *(_DWORD *)(a2 + 140);
    DWORD1(buf[1]) = 1;
    float v27 = v18;
    if (v27 >= 100.0)
    {
      if (v27 >= 200.0) {
        LODWORD(buf[2]) = 1;
      }
      else {
        HIDWORD(buf[1]) = 1;
      }
    }
    else
    {
      DWORD2(buf[1]) = 1;
    }
    if (v26 <= 0.0)
    {
      float v49 = 0.0;
    }
    else
    {
      float v28 = v19 / v26;
      float v49 = v28;
      if (v28 >= 1.0)
      {
        if (v28 >= 3.0) {
          HIDWORD(buf[2]) = 1;
        }
        else {
          DWORD2(buf[2]) = 1;
        }
        goto LABEL_46;
      }
    }
    DWORD1(buf[2]) = 1;
LABEL_46:
    *(float *)double v50 = v19;
    sub_1011FE938(v17, buf, (float *)v50, &v49);
    *(void *)double v50 = a2 + 96;
    uint64_t v29 = sub_101202278((uint64_t **)(a1 + 568), (int *)(a2 + 96), (uint64_t)&unk_101D0B290, (_DWORD **)v50);
    long long v30 = buf[1];
    *(_OWORD *)(v29 + 5) = buf[0];
    *(_OWORD *)(v29 + 7) = v30;
    *(_OWORD *)(v29 + 9) = buf[2];
    *(_OWORD *)((char *)v29 + 84) = *(_OWORD *)((char *)&buf[2] + 12);
    goto LABEL_47;
  }
  ++*(_DWORD *)(v22 + 60);
  float v35 = v18;
  if (v35 >= 100.0)
  {
    if (v35 >= 200.0) {
      ++*(_DWORD *)(v22 + 72);
    }
    else {
      ++*(_DWORD *)(v22 + 68);
    }
  }
  else
  {
    ++*(_DWORD *)(v22 + 64);
  }
  double v36 = *(double *)(a2 + 20);
  if (v36 <= 0.0)
  {
    float v49 = 0.0;
    goto LABEL_64;
  }
  float v37 = v19 / v36;
  float v49 = v37;
  if (v37 < 1.0)
  {
LABEL_64:
    ++*(_DWORD *)(v22 + 76);
    goto LABEL_65;
  }
  if (v37 >= 3.0) {
    ++*(_DWORD *)(v22 + 84);
  }
  else {
    ++*(_DWORD *)(v22 + 80);
  }
LABEL_65:
  *(float *)uint64_t buf = v19;
  sub_1011FE938(v17, (_DWORD *)(v22 + 40), (float *)buf, &v49);
  if (v19 > *(double *)(v22 + 40))
  {
    *(double *)(v22 + 40) = v19;
    *(void *)(v22 + 48) = *(void *)(a2 + 20);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102318208);
    }
    double v38 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = *(void *)(a2 + 20);
      int v40 = *(_DWORD *)(a2 + 96);
      int v41 = *(_DWORD *)(a2 + 140);
      LODWORD(buf[0]) = 134218752;
      *(double *)((char *)buf + 4) = v19;
      WORD6(buf[0]) = 2048;
      *(void *)((char *)buf + 14) = v39;
      WORD3(buf[1]) = 1024;
      DWORD2(buf[1]) = v40;
      WORD6(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 14) = v41;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#LCStats,homeVisit,maxError,%0.2f m,estAcc,%0.2f m,posType,%d,sigEnv,%d", (uint8_t *)buf, 0x22u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102318208);
      }
      uint64_t v42 = *(void *)(a2 + 20);
      int v43 = *(_DWORD *)(a2 + 96);
      int v44 = *(_DWORD *)(a2 + 140);
      *(_DWORD *)double v50 = 134218752;
      *(double *)&v50[4] = v19;
      *(_WORD *)&v50[12] = 2048;
      *(void *)&v50[14] = v42;
      *(_WORD *)&v50[22] = 1024;
      *(_DWORD *)&v50[24] = v43;
      __int16 v51 = 1024;
      int v52 = v44;
      __int16 v45 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerCAStats::calcHomeVisitStats(const CLDaemonLocation &)", "%s\n", v45);
      if (v45 != (char *)buf) {
        free(v45);
      }
    }
  }
LABEL_47:
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102318208);
  }
  float v31 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = *(_DWORD *)(a2 + 96);
    uint64_t v33 = *(void *)(a2 + 20);
    int v34 = *(_DWORD *)(a2 + 140);
    LODWORD(buf[0]) = 67109888;
    DWORD1(buf[0]) = v32;
    WORD4(buf[0]) = 2048;
    *(double *)((char *)buf + 10) = v19;
    WORD1(buf[1]) = 2048;
    *(void *)((char *)&buf[1] + 4) = v33;
    WORD6(buf[1]) = 1024;
    *(_DWORD *)((char *)&buf[1] + 14) = v34;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#LCStats,homeVisit,posType,%d,distFromCentroid,%0.2f m,estAcc,%0.2f m,sigEnv,%d", (uint8_t *)buf, 0x22u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102318208);
    }
    int v46 = *(_DWORD *)(a2 + 96);
    uint64_t v47 = *(void *)(a2 + 20);
    int v48 = *(_DWORD *)(a2 + 140);
    *(_DWORD *)double v50 = 67109888;
    *(_DWORD *)&v50[4] = v46;
    *(_WORD *)&v50[8] = 2048;
    *(double *)&v50[10] = v19;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = v47;
    __int16 v51 = 1024;
    int v52 = v48;
    long long v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerCAStats::calcHomeVisitStats(const CLDaemonLocation &)", "%s\n", v11);
    goto LABEL_79;
  }
}

void sub_1001988CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_1000DB0A0(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001988EC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 288);
}

uint64_t sub_1001988F4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 289);
}

id sub_1001988FC(uint64_t a1)
{
  id v1 = [objc_msgSend(*(id *)(a1 + 24), "vendor") proxyForService:@"CLClientManager"];

  return _[v1 syncgetHasAuthorizedClients];
}

void sub_100198934(uint64_t a1, unsigned __int8 *a2, int a3)
{
  double v4 = sub_10016C458();
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(double *)(a1 + 6184) = v4;
  uint64_t v29 = a1;
  id v6 = [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLClientManager"), "syncgetNonSystemLocationClientKeys");
  v37[0] = 0;
  v37[1] = 0;
  double v36 = v37;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v32 objects:v46 count:16];
  if (v7)
  {
    long long v8 = (uint64_t **)(a1 + 6160);
    uint64_t v9 = *(void *)v33;
    do
    {
      float v10 = 0;
      do
      {
        if (*(void *)v33 != v9) {
          objc_enumerationMutation(v6);
        }
        sub_100134750(v30, (char *)[*(id *)(*((void *)&v32 + 1) + 8 * (void)v10) UTF8String]);
        if (SHIBYTE(v31) < 0)
        {
          sub_1000DC48C(__p, v30[0], (unint64_t)v30[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)v30;
          *(void *)&__p[16] = v31;
        }
        double v45 = v4;
        sub_100718B1C((uint64_t **)&v36, (const void **)__p, (uint64_t)__p);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        if (!sub_100040D3C((uint64_t)v8, (const void **)v30))
        {
          if (SHIBYTE(v31) < 0)
          {
            sub_1000DC48C(__p, v30[0], (unint64_t)v30[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v30;
            *(void *)&__p[16] = v31;
          }
          double v45 = v4;
          sub_100718B1C(v8, (const void **)__p, (uint64_t)__p);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          if (qword_102419360 != -1) {
            dispatch_once(&qword_102419360, &stru_1022C58B8);
          }
          long long v11 = qword_102419368;
          if (os_log_type_enabled((os_log_t)qword_102419368, OS_LOG_TYPE_DEBUG))
          {
            long long v12 = v30;
            if (v31 < 0) {
              long long v12 = (void **)v30[0];
            }
            *(_DWORD *)long long __p = 134349571;
            *(CFAbsoluteTime *)&__p[4] = Current;
            *(_WORD *)&unsigned char __p[12] = 2050;
            *(double *)&__p[14] = v4;
            *(_WORD *)&__p[22] = 2081;
            double v45 = *(double *)&v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "CLAccessoryAWD,%{public}.1lf,machContTime,%{public}.1lf,onApp,newApp,%{private}s", __p, 0x20u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(__p, 0x65CuLL);
            if (qword_102419360 != -1) {
              dispatch_once(&qword_102419360, &stru_1022C58B8);
            }
            int v13 = v30;
            if (v31 < 0) {
              int v13 = (void **)v30[0];
            }
            int v38 = 134349571;
            CFAbsoluteTime v39 = Current;
            __int16 v40 = 2050;
            double v41 = v4;
            __int16 v42 = 2081;
            int v43 = v13;
            int v14 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLAccessoryLocationProvider::updateLocationAppStatus(const std::string, const BOOL)", "%s\n", v14);
            if (v14 != __p) {
              free(v14);
            }
          }
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(v30[0]);
        }
        float v10 = (char *)v10 + 1;
      }
      while (v7 != v10);
      id v15 = [v6 countByEnumeratingWithState:&v32 objects:v46 count:16];
      id v7 = v15;
    }
    while (v15);
  }
  uint64_t v16 = *(void *)(a1 + 6160);
  uint64_t v17 = (uint64_t *)(a1 + 6168);
  if (v16 != v29 + 6168)
  {
    do
    {
      if (sub_100040D3C((uint64_t)&v36, (const void **)(v16 + 32)))
      {
        uint64_t v18 = *(unsigned __int8 *)(v16 + 55);
        if ((v18 & 0x80u) == 0) {
          uint64_t v19 = *(unsigned __int8 *)(v16 + 55);
        }
        else {
          uint64_t v19 = *(void *)(v16 + 40);
        }
        uint64_t v20 = a2[23];
        int v21 = (char)v20;
        if ((v20 & 0x80u) != 0) {
          uint64_t v20 = *((void *)a2 + 1);
        }
        if (v19 != v20) {
          goto LABEL_54;
        }
        if (v21 >= 0) {
          uint64_t v22 = a2;
        }
        else {
          uint64_t v22 = *(unsigned __int8 **)a2;
        }
        if ((v18 & 0x80) != 0)
        {
          if (memcmp(*(const void **)(v16 + 32), v22, *(void *)(v16 + 40))) {
            goto LABEL_54;
          }
        }
        else
        {
          int v23 = (unsigned __int8 *)(v16 + 32);
          if (*(unsigned char *)(v16 + 55))
          {
            while (*v23 == *v22)
            {
              ++v23;
              ++v22;
              if (!--v18) {
                goto LABEL_52;
              }
            }
LABEL_54:
            BOOL v25 = *(uint64_t **)(v16 + 8);
            if (v25)
            {
              do
              {
                BOOL v24 = v25;
                BOOL v25 = (uint64_t *)*v25;
              }
              while (v25);
            }
            else
            {
              do
              {
                BOOL v24 = *(uint64_t **)(v16 + 16);
                BOOL v26 = *v24 == v16;
                uint64_t v16 = (uint64_t)v24;
              }
              while (!v26);
            }
            goto LABEL_59;
          }
        }
LABEL_52:
        if (!a3) {
          goto LABEL_54;
        }
      }
      sub_10122701C(v29 + 2560, v16 + 32, (double *)(v16 + 56), v4);
      BOOL v24 = sub_100645C00((uint64_t **)(v29 + 6160), v16);
LABEL_59:
      uint64_t v16 = (uint64_t)v24;
    }
    while (v24 != v17);
  }
  sub_1000DB264((uint64_t)&v36, v37[0]);
}

void sub_100198E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,char *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_1000DB264((uint64_t)&a33, a34);
  _Unwind_Resume(a1);
}

void sub_100198E98(uint64_t a1, int a2, uint64_t a3, double a4)
{
  sub_100199238(a1, a4);
  if (a2)
  {
    sub_10010702C((uint64_t **)a1, (const void **)a3, a3);
    int v9 = v8 & 1;
  }
  else
  {
    int v9 = 0;
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_1022E89B0);
  }
  float v10 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = a3;
    if (*(char *)(a3 + 23) < 0) {
      uint64_t v11 = *(void *)a3;
    }
    long long v12 = "owned";
    uint64_t v13 = *(void *)(a1 + 16);
    *(_DWORD *)uint64_t buf = 136381443;
    uint64_t v17 = v11;
    int v14 = "add";
    if (a2) {
      long long v12 = "wild";
    }
    __int16 v18 = 2081;
    uint64_t v19 = v12;
    if (!v9) {
      int v14 = "skip";
    }
    __int16 v20 = 2080;
    int v21 = v14;
    __int16 v22 = 2050;
    uint64_t v23 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "TaMetricEvent, onAvengerAdvertisement, id, %{private}s, %{private}s, %s, %{public}ld", buf, 0x2Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_1022E89B0);
    }
    id v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLTrackingAvoidanceMetrics::handleOnAdvertisement(BOOL, std::string, CFAbsoluteTime)", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  if (v9) {
    sub_100B77128(a1, "unique", a4);
  }
}

__n128 sub_100199168(uint64_t a1, long long *a2, char *__src)
{
  long long v5 = *a2;
  *(_OWORD *)(a1 + 132) = a2[1];
  *(_OWORD *)(a1 + 116) = v5;
  long long v6 = a2[2];
  long long v7 = a2[3];
  long long v8 = a2[4];
  *(_OWORD *)(a1 + 196) = a2[5];
  *(_OWORD *)(a1 + 180) = v8;
  *(_OWORD *)(a1 + 164) = v7;
  *(_OWORD *)(a1 + 148) = v6;
  long long v9 = a2[6];
  long long v10 = a2[7];
  long long v11 = a2[8];
  *(_OWORD *)(a1 + 256) = *(long long *)((char *)a2 + 140);
  *(_OWORD *)(a1 + 244) = v11;
  *(_OWORD *)(a1 + 228) = v10;
  *(_OWORD *)(a1 + 212) = v9;
  memcpy((void *)(a1 + 272), __src, 0x201uLL);
  uint64_t v12 = *((void *)__src + 65);
  uint64_t v13 = *((void *)__src + 66);
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 792) = v12;
  int v14 = *(std::__shared_weak_count **)(a1 + 800);
  *(void *)(a1 + 800) = v13;
  if (v14) {
    sub_1000DB0A0(v14);
  }
  long long v15 = *(_OWORD *)(__src + 536);
  long long v16 = *(_OWORD *)(__src + 568);
  *(_OWORD *)(a1 + 824) = *(_OWORD *)(__src + 552);
  *(_OWORD *)(a1 + 840) = v16;
  *(_OWORD *)(a1 + 808) = v15;
  __n128 result = *(__n128 *)(__src + 584);
  long long v18 = *(_OWORD *)(__src + 600);
  long long v19 = *(_OWORD *)(__src + 616);
  *(void *)(a1 + 901) = *(void *)(__src + 629);
  *(_OWORD *)(a1 + 872) = v18;
  *(_OWORD *)(a1 + 888) = v19;
  *(__n128 *)(a1 + 856) = result;
  return result;
}

void sub_100199238(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 64) < a2)
  {
    double v4 = (void *)(a1 + 32);
    do
    {
      int v5 = *(_DWORD *)(a1 + 48);
      int v6 = *(_DWORD *)(a1 + 52);
      int v7 = *(_DWORD *)(a1 + 56);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_1022E89B0);
      }
      int v8 = v6 + v5 + v7;
      long long v9 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        long long v10 = *(unsigned char **)(a1 + 16);
        uint64_t v11 = *(void *)(a1 + 40);
        int v12 = *(_DWORD *)(a1 + 48);
        int v13 = *(_DWORD *)(a1 + 52);
        int v14 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)uint64_t buf = 134350336;
        __int16 v59 = v10;
        __int16 v60 = 2050;
        uint64_t v61 = v11;
        __int16 v62 = 1026;
        int v63 = v12;
        __int16 v64 = 1026;
        int v65 = v13;
        __int16 v66 = 1026;
        int v67 = v14;
        __int16 v68 = 1026;
        int v69 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TaMetric, daily, unique, %{public}ld, detected, %{public}ld, suspicious, %{public}d, %{public}d, %{public}d, %{public}d", buf, 0x2Eu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022E89B0);
        }
        uint64_t v27 = *(void *)(a1 + 16);
        uint64_t v28 = *(void *)(a1 + 40);
        int v29 = *(_DWORD *)(a1 + 48);
        int v30 = *(_DWORD *)(a1 + 52);
        int v31 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)__dst = 134350336;
        *(void *)&__dst[4] = v27;
        *(_WORD *)&__dst[12] = 2050;
        *(void *)&__dst[14] = v28;
        *(_WORD *)&__dst[22] = 1026;
        int v51 = v29;
        __int16 v52 = 1026;
        int v53 = v30;
        __int16 v54 = 1026;
        int v55 = v31;
        __int16 v56 = 1026;
        int v57 = v8;
        long long v32 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLTrackingAvoidanceMetrics::checkToSend(CFAbsoluteTime)", "%s\n", v32);
        if (v32 != (char *)buf) {
          free(v32);
        }
      }
      if (!*(unsigned char *)(a1 + 76))
      {
        __int16 v40 = _NSConcreteStackBlock;
        uint64_t v41 = 3221225472;
        __int16 v42 = sub_100B7C274;
        int v43 = &unk_1022D4610;
        uint64_t v44 = a1;
        int v45 = v8;
        AnalyticsSendEventLazy();
      }
      if (*(void *)(a1 + 40))
      {
        long long v15 = *(void **)(a1 + 24);
        if (v15 != v4)
        {
          do
          {
            if (*((char *)v15 + 55) < 0)
            {
              sub_1000DC48C(__dst, (void *)v15[4], v15[5]);
            }
            else
            {
              *(_OWORD *)__dst = *((_OWORD *)v15 + 2);
              *(void *)&__dst[16] = v15[6];
            }
            int v51 = *((_DWORD *)v15 + 14);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_1022E89B0);
            }
            long long v16 = qword_1024193A8;
            if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v17 = __dst;
              if (__dst[23] < 0) {
                uint64_t v17 = *(unsigned char **)__dst;
              }
              *(_DWORD *)uint64_t buf = 136380931;
              __int16 v59 = v17;
              __int16 v60 = 1026;
              LODWORD(v61) = v51;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "TaMetric, detecteddaily, id, %{private}s, detections, %{public}d", buf, 0x12u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193A0 != -1) {
                dispatch_once(&qword_1024193A0, &stru_1022E89B0);
              }
              int v21 = __dst;
              if (__dst[23] < 0) {
                int v21 = *(unsigned char **)__dst;
              }
              int v46 = 136380931;
              uint64_t v47 = v21;
              __int16 v48 = 1026;
              int v49 = v51;
              __int16 v22 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "void CLTrackingAvoidanceMetrics::checkToSend(CFAbsoluteTime)", "%s\n", v22);
              if (v22 != (char *)buf) {
                free(v22);
              }
            }
            if (!*(unsigned char *)(a1 + 76))
            {
              if ((__dst[23] & 0x80000000) != 0)
              {
                sub_1000DC48C(&__p, *(void **)__dst, *(unint64_t *)&__dst[8]);
              }
              else
              {
                long long __p = *(_OWORD *)__dst;
                uint64_t v38 = *(void *)&__dst[16];
              }
              int v39 = v51;
              AnalyticsSendEventLazy();
              if (SHIBYTE(v38) < 0) {
                operator delete((void *)__p);
              }
            }
            if ((__dst[23] & 0x80000000) != 0) {
              operator delete(*(void **)__dst);
            }
            long long v18 = (void *)v15[1];
            if (v18)
            {
              do
              {
                long long v19 = v18;
                long long v18 = (void *)*v18;
              }
              while (v18);
            }
            else
            {
              do
              {
                long long v19 = (void *)v15[2];
                BOOL v20 = *v19 == (void)v15;
                long long v15 = v19;
              }
              while (!v20);
            }
            long long v15 = v19;
          }
          while (v19 != v4);
        }
      }
      if (*(double *)(a1 + 80) < a2)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022E89B0);
        }
        uint64_t v23 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          int v24 = *(_DWORD *)(a1 + 88);
          *(_DWORD *)uint64_t buf = 67240192;
          LODWORD(v59) = v24;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "TaMetric, weekly, numberOfAlertsPerWeek, %{public}d", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022E89B0);
          }
          int v33 = *(_DWORD *)(a1 + 88);
          *(_DWORD *)__dst = 67240192;
          *(_DWORD *)&__dst[4] = v33;
          long long v34 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLTrackingAvoidanceMetrics::checkToSend(CFAbsoluteTime)", "%s\n", v34);
          if (v34 != (char *)buf) {
            free(v34);
          }
        }
        if (!*(unsigned char *)(a1 + 76)) {
          AnalyticsSendEventLazy();
        }
        *(double *)(a1 + 80) = *(double *)(a1 + 80) + 604800.0;
        *(_DWORD *)(a1 + 88) = 0;
      }
      if (*(double *)(a1 + 96) < a2)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_1022E89B0);
        }
        BOOL v25 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          int v26 = *(_DWORD *)(a1 + 104);
          *(_DWORD *)uint64_t buf = 67240192;
          LODWORD(v59) = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "TaMetric, monthly, numberOfAlertsPerMonth, %{public}d", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_1022E89B0);
          }
          int v35 = *(_DWORD *)(a1 + 104);
          *(_DWORD *)__dst = 67240192;
          *(_DWORD *)&__dst[4] = v35;
          double v36 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLTrackingAvoidanceMetrics::checkToSend(CFAbsoluteTime)", "%s\n", v36);
          if (v36 != (char *)buf) {
            free(v36);
          }
        }
        if (!*(unsigned char *)(a1 + 76)) {
          AnalyticsSendEventLazy();
        }
        *(double *)(a1 + 96) = *(double *)(a1 + 96) + 2592000.0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      sub_100B76BF0(a1, 1);
    }
    while (*(double *)(a1 + 64) < a2);
    sub_100B77128(a1, "sent", a2);
  }
}

void sub_100199BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  if (a59 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100199BFC(uint64_t a1, void *a2)
{
  if (a2[1] - *a2 >= 0x18uLL) {
    return AnalyticsSendEventLazy();
  }
  return result;
}

id sub_100199C80(uint64_t a1, uint64_t a2)
{
  id v3 = [objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLTelephonyService"];

  return _[v3 syncgetRefreshCellMonitorForSim:a2];
}

void sub_100199CC8(unsigned char *a1)
{
  if (a1[160])
  {
    v5[0] = 0;
    int v2 = sub_1001072EC((uint64_t)a1, v5, 1);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022F2018);
    }
    id v3 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      int v4 = a1[356];
      v5[0] = 68289538;
      v5[1] = 0;
      __int16 v6 = 2082;
      int v7 = "";
      __int16 v8 = 1026;
      int v9 = v4;
      __int16 v10 = 1026;
      BOOL v11 = v2 != 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#SLC Checking whether we should be monitoring\", \"activeNow\":%{public}hhd, \"hasNotifierClients\":%{public}hhd}", (uint8_t *)v5, 0x1Eu);
    }
    if (a1[356])
    {
      if (!v2) {
        sub_100CF4660(a1);
      }
    }
    else if (v2)
    {
      sub_100CF475C((uint64_t)a1);
    }
  }
}

BOOL sub_100199E0C(char *a1, int a2, int *a3)
{
  BOOL v4 = sub_1001AF260(a1, a2, a3);
  sub_100199CC8(a1);
  return v4;
}

BOOL sub_100199E40(unsigned char *a1, int a2, unsigned int *a3, uint64_t *a4)
{
  BOOL v5 = sub_1000ACE54((uint64_t)a1, a2, a3, a4);
  sub_100199CC8(a1);
  return v5;
}

void sub_100199E74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  sub_100178338(*(void *)(a1 + 144), v6.__d_.__rep_, a4);

  sub_100182ADC(a1, a4, a4 + 160);
}

uint64_t sub_100199ED8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100199EF4(double *a1, int *a2, uint64_t a3)
{
  if (*a2 == 2)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    uint64_t v23 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v24 = *(void *)(a3 + 112);
      uint64_t v25 = *(void *)(a3 + 16);
      uint64_t v26 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 1;
      double v27 = sub_10016BA54(v26, buf);
      uint64_t v28 = sub_10016BA10();
      double v29 = sub_10018202C(v28);
      *(_DWORD *)uint64_t buf = 67240960;
      *(_DWORD *)&uint8_t buf[4] = v24;
      LOWORD(v64) = 1026;
      *(_DWORD *)((char *)&v64 + 2) = v25;
      HIWORD(v64) = 2050;
      *(double *)int v65 = v27;
      *(_WORD *)&v65[8] = 2050;
      *(double *)&v65[10] = v29;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Received motion state mediator workout notification,workout_type,%{public}d,event_type,%{public}d,now_mct,%{public}.3f,propagation_us,%{public}.3f", buf, 0x22u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      uint64_t v49 = *(void *)(a3 + 112);
      uint64_t v50 = *(void *)(a3 + 16);
      double v51 = sub_1005B5034();
      uint64_t v52 = sub_10016BA10();
      LODWORD(v55) = 67240960;
      DWORD1(v55) = v49;
      WORD4(v55) = 1026;
      *(_DWORD *)((char *)&v55 + 10) = v50;
      HIWORD(v55) = 2050;
      *(double *)__int16 v56 = v51;
      *(_WORD *)&v56[8] = 2050;
      *(void *)&v56[10] = sub_10018202C(v52);
      int v53 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedMotionStateMediatorNotification(const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v53);
      if (v53 != (char *)buf) {
        free(v53);
      }
    }
    *(void *)uint64_t buf = *(void *)a3;
    uint64_t v30 = *(void *)(a3 + 16);
    if (v30 != 13)
    {
      if (v30 != 15) {
        return;
      }
      uint64_t v64 = 0;
LABEL_44:
      uint64_t v37 = sub_10016BA10();
      LODWORD(v55) = 1;
      *(void *)&long long v55 = sub_10016BA54(v37, &v55);
      sub_100EA046C((uint64_t)(a1 + 57), (uint64_t **)&v55, (uint64_t)buf);
      return;
    }
    uint64_t v36 = *(void *)(a3 + 112);
    if (v36 > 14)
    {
      if (v36 == 17)
      {
LABEL_41:
        uint64_t v64 = 0x800000008;
LABEL_42:
        if ((unint64_t)(v36 - 3) <= 1) {
          uint64_t v64 = 0x600000006;
        }
        goto LABEL_44;
      }
      if (v36 != 15) {
        goto LABEL_42;
      }
    }
    else if (v36 != 1)
    {
      goto LABEL_40;
    }
    uint64_t v64 = 0x400000004;
LABEL_40:
    if (v36 != 2) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (!*a2)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    BOOL v5 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *(_DWORD *)(a3 + 8);
      int v7 = *(_DWORD *)(a3 + 12);
      int v8 = *(unsigned __int8 *)(a3 + 209);
      uint64_t v9 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 1;
      double v10 = sub_10016BA54(v9, buf);
      uint64_t v11 = sub_10016BA10();
      double v12 = sub_10018202C(v11);
      *(_DWORD *)uint64_t buf = 67241216;
      *(_DWORD *)&uint8_t buf[4] = v6;
      LOWORD(v64) = 1026;
      *(_DWORD *)((char *)&v64 + 2) = v7;
      HIWORD(v64) = 1024;
      *(_DWORD *)int v65 = v8;
      *(_WORD *)&v65[4] = 2050;
      *(double *)&v65[6] = v10;
      *(_WORD *)&v65[14] = 2050;
      *(double *)&v65[16] = v12;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Received motion state mediator activity notification,activity_type,%{public}d,confidence,%{public}d,is_historical,%d,now_mct,%{public}.3f,propagation_us,%{public}.3f", buf, 0x28u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      int v43 = *(_DWORD *)(a3 + 8);
      int v44 = *(_DWORD *)(a3 + 12);
      int v45 = *(unsigned __int8 *)(a3 + 209);
      double v46 = sub_1005B5034();
      uint64_t v47 = sub_10016BA10();
      LODWORD(v55) = 67241216;
      DWORD1(v55) = v43;
      WORD4(v55) = 1026;
      *(_DWORD *)((char *)&v55 + 10) = v44;
      HIWORD(v55) = 1024;
      *(_DWORD *)__int16 v56 = v45;
      *(_WORD *)&v56[4] = 2050;
      *(double *)&v56[6] = v46;
      *(_WORD *)&v56[14] = 2050;
      *(void *)&v56[16] = sub_10018202C(v47);
      __int16 v48 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedMotionStateMediatorNotification(const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v48);
      if (v48 != (char *)buf) {
        free(v48);
      }
    }
    long long v13 = *(_OWORD *)(a3 + 88);
    long long v14 = *(_OWORD *)(a3 + 120);
    long long v60 = *(_OWORD *)(a3 + 104);
    long long v61 = v14;
    uint64_t v62 = *(void *)(a3 + 136);
    long long v15 = *(_OWORD *)(a3 + 24);
    long long v16 = *(_OWORD *)(a3 + 56);
    *(_OWORD *)&v56[16] = *(_OWORD *)(a3 + 40);
    long long v57 = v16;
    long long v58 = *(_OWORD *)(a3 + 72);
    long long v59 = v13;
    long long v55 = *(_OWORD *)(a3 + 8);
    *(_OWORD *)__int16 v56 = v15;
    uint64_t v17 = (unsigned char *)sub_10067B400();
    if (!v17) {
      goto LABEL_64;
    }
    if (!v17[1]) {
      goto LABEL_64;
    }
    if (!*v17) {
      goto LABEL_64;
    }
    uint64_t v18 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 0;
    double v19 = sub_10016BA54(v18, buf);
    double v20 = vabdd_f64(v19, a1[436]);
    if (v20 >= 1.5) {
      goto LABEL_64;
    }
    if (a1[435] != 0.0) {
      goto LABEL_16;
    }
    BOOL v21 = 0;
    if (v20 >= 0.5) {
      goto LABEL_46;
    }
    __int16 v22 = (double *)((char *)a1 + 3364);
    if (vabdd_f64(v19, *(double *)((char *)a1 + 3396)) >= 1.5) {
      goto LABEL_46;
    }
    if (*v22 >= 0.0) {
      BOOL v21 = *v22 + *(double *)((char *)a1 + 3372) * -2.0 < 0.0;
    }
    else {
LABEL_16:
    }
      BOOL v21 = 0;
LABEL_46:
    int v38 = v55;
    if ((int)v55 <= 40)
    {
      switch((int)v55)
      {
        case 1:
          int v38 = 10;
          goto LABEL_57;
        case 2:
          int v38 = 11;
LABEL_57:
          LODWORD(v55) = v38;
          if (v21) {
            goto LABEL_58;
          }
          goto LABEL_59;
        case 3:
        case 4:
        case 7:
        case 8:
        case 9:
          goto LABEL_48;
        case 5:
          goto LABEL_58;
        case 10:
        case 11:
          if (v21) {
            goto LABEL_58;
          }
          DWORD1(v55) = 0;
          goto LABEL_59;
        default:
          goto LABEL_59;
      }
    }
    if (v55 == 41)
    {
LABEL_48:
      *(void *)&long long v55 = 0x200000005;
      int v38 = 5;
    }
    else if (v55 == 52 || v55 == 56)
    {
LABEL_58:
      DWORD1(v55) = 2;
    }
LABEL_59:
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    int v39 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
    {
      int v40 = *(_DWORD *)(a3 + 8);
      int v41 = *(_DWORD *)(a3 + 12);
      *(_DWORD *)uint64_t buf = 67241216;
      *(_DWORD *)&uint8_t buf[4] = v40;
      LOWORD(v64) = 1026;
      *(_DWORD *)((char *)&v64 + 2) = v41;
      HIWORD(v64) = 1026;
      *(_DWORD *)int v65 = v38;
      *(_WORD *)&v65[4] = 1026;
      *(_DWORD *)&v65[6] = DWORD1(v55);
      *(_WORD *)&v65[10] = 1026;
      *(_DWORD *)&v65[12] = v21;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "In vehicle detected Adjusting motion state,type,%{public}d,confidence,%{public}d,to type,%{public}d,confidence,%{public}d,isSpeedZero,%{public}d", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      __int16 v54 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedMotionStateMediatorNotification(const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v54);
      if (v54 != (char *)buf) {
        free(v54);
      }
    }
LABEL_64:
    uint64_t v42 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 1;
    *(void *)uint64_t buf = sub_10016BA54(v42, buf);
    sub_100191444((uint64_t)(a1 + 57), (double *)buf, (int *)&v55);
    return;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022CF3E8);
  }
  long long v32 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_FAULT))
  {
    int v33 = *a2;
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "#Warning, Fusion Controller, received unhandled motion state mediator notification %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    int v34 = *a2;
    LODWORD(v55) = 67240192;
    DWORD1(v55) = v34;
    int v35 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLLocationControllerFusion::feedMotionStateMediatorNotification(const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v35);
    if (v35 != (char *)buf) {
      free(v35);
    }
  }
}

void sub_10019A858(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a1 + 456;
  uint64_t v7 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  *(void *)uint64_t buf = sub_10016BA54(v7, buf);
  sub_10018A27C(v6, (uint64_t *)buf, a2);
  *(unsigned char *)(a1 + 3632) = a2 & a3;
  uint64_t v8 = *(void *)(a1 + 3144);
  if (v8) {
    sub_100170410(v8, a2);
  }
  sub_10019DAB8(a1 + 3536, a2);
  uint64_t v9 = *(void **)(a1 + 3144);
  if (v9) {
    sub_1001706DC(v9, *(unsigned char *)(a1 + 3551) == 0);
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022CF408);
  }
  double v10 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v11 = *(unsigned __int8 *)(a1 + 3551);
    *(_DWORD *)uint64_t buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v14 = 1024;
    int v15 = a3;
    __int16 v16 = 1024;
    int v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "CLMM,Change in locationApp foreground status,isForeGround,%d,isAppleMaps,%d,networkusage,%d", buf, 0x14u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022CF408);
    }
    double v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationControllerFusion::setLocationApplicationIsForeground(BOOL, BOOL)", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
}

void sub_10019AAAC(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 456;
  uint64_t v4 = sub_10016BA10();
  int v6 = 1;
  double v5 = sub_10016BA54(v4, &v6);
  sub_10003E9C8(v3, (uint64_t *)&v5, a2);
}

uint64_t sub_10019AB00(uint64_t result, char a2)
{
  *(unsigned char *)(result + 612) = a2;
  return result;
}

double sub_10019AB08(uint64_t a1, uint64_t a2, unsigned char *a3, double *a4)
{
  return sub_1001A3770(a1 + 3272, a2, a3, a4);
}

void sub_10019AB10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 3576);
  if (v3) {
    sub_1001AE7F4(v3, a2, a3);
  }
}

uint64_t sub_10019AB20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a1 + 3576);
  if (result) {
    return sub_1001AED98(result, a2, a3);
  }
  return result;
}

BOOL sub_10019AB30(uint64_t a1, uint64_t a2)
{
  if (sub_10018A47C(a1 + 456, a2)) {
    return *(double *)(a2 + 20) > 0.0;
  }
  if (qword_102419510 != -1) {
    dispatch_once(&qword_102419510, &stru_1022CF3E8);
  }
  uint64_t v4 = qword_102419518;
  if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#fusion, failed to get the latest predicted fused solution.", buf, 2u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    double v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::getLatestFusedLocation(CLDaemonLocation &)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
    return 0;
  }
  return result;
}

BOOL sub_10019ACDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v4 = *(double *)(a4 + 544);
  if (v4 > 0.0)
  {
    *(void *)(a2 + 28) = *(void *)(a4 + 28);
    *(_DWORD *)(a3 + 316) = *(_DWORD *)(a4 + 476);
    *(_DWORD *)(a3 + 312) = *(_DWORD *)(a4 + 472);
    *(double *)(a3 + 384) = v4;
    *(void *)(a3 + 360) = *(void *)(a4 + 520);
    *(_OWORD *)(a3 + 368) = *(_OWORD *)(a4 + 528);
    *(void *)(a3 + 624) = *(void *)(a4 + 784);
    *(_OWORD *)(a3 + 496) = *(_OWORD *)(a4 + 656);
  }
  return v4 > 0.0;
}

void sub_10019AD30(uint64_t a1, int *a2, uint64_t a3)
{
  if (*(void *)(a1 + 3144))
  {
    int v5 = *a2;
    if ((*a2 - 1) < 3)
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CF408);
      }
      int v6 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = a3 + 8;
        if (*(char *)(a3 + 31) < 0) {
          uint64_t v7 = *(void *)(a3 + 8);
        }
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v20 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CLMM,locationApp backgrounded or terminated,%s", buf, 0xCu);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_10;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CF408);
      }
      int v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedAppNotification(const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v17);
      if (v17 == (char *)buf) {
        goto LABEL_10;
      }
      goto LABEL_51;
    }
    if (v5 == 9 || v5 == 4)
    {
      uint64_t v9 = (void *)(a3 + 8);
      if (!sub_10019B8F8(a1, (unsigned __int8 **)(a3 + 8)))
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022CF408);
        }
        long long v13 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a3 + 31) >= 0) {
            uint64_t v14 = a3 + 8;
          }
          else {
            uint64_t v14 = *(void *)(a3 + 8);
          }
          *(_DWORD *)uint64_t buf = 136315138;
          uint64_t v20 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "CLMM,locationApp is not foreground,%s", buf, 0xCu);
        }
        if (!sub_10013D1A0(115, 2)) {
          goto LABEL_10;
        }
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022CF408);
        }
        int v17 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedAppNotification(const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v17);
        if (v17 == (char *)buf) {
          goto LABEL_10;
        }
LABEL_51:
        free(v17);
LABEL_10:
        sub_10019A858(a1, 0, 0);
        return;
      }
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CF408);
      }
      double v10 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        if (*(char *)(a3 + 31) >= 0) {
          uint64_t v11 = a3 + 8;
        }
        else {
          uint64_t v11 = *(void *)(a3 + 8);
        }
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v20 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "CLMM,locationApp in foreground,%s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022CF408);
        }
        uint64_t v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLLocationControllerFusion::feedAppNotification(const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v18);
        if (v18 != (char *)buf) {
          free(v18);
        }
      }
      int v12 = *(char *)(a3 + 31);
      if (v12 < 0)
      {
        if (*(void *)(a3 + 16) != 14)
        {
LABEL_45:
          BOOL v16 = 0;
LABEL_46:
          sub_10019A858(a1, 1, v16);
          return;
        }
        uint64_t v9 = (void *)*v9;
      }
      else if (v12 != 14)
      {
        goto LABEL_45;
      }
      BOOL v16 = *v9 == 0x6C7070612E6D6F63 && *(void *)((char *)v9 + 6) == 0x7370614D2E656C70;
      goto LABEL_46;
    }
  }
}

BOOL sub_10019B2A0(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 2824) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 2840) = v4;
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 48);
  long long v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 2888) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 2904) = v7;
  *(_OWORD *)(a1 + 2856) = v5;
  *(_OWORD *)(a1 + 2872) = v6;
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 2964) = *(_OWORD *)(a2 + 140);
  *(_OWORD *)(a1 + 2936) = v9;
  *(_OWORD *)(a1 + 2952) = v10;
  *(_OWORD *)(a1 + 2920) = v8;
  uint64_t v11 = *(void *)(a1 + 3568);
  if (v11) {
    sub_10078C168(v11);
  }
  char v46 = 0;
  if (!sub_100025CB4(a1 + 456, a2, &v46) && !v46)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    int v12 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 2616);
      int v14 = *(_DWORD *)(a2 + 96);
      uint64_t v15 = *(void *)(a2 + 4);
      uint64_t v16 = *(void *)(a2 + 12);
      uint64_t v17 = *(void *)(a2 + 20);
      *(_DWORD *)uint64_t buf = 67241217;
      int v58 = v13;
      __int16 v59 = 1026;
      int v60 = v14;
      __int16 v61 = 2049;
      uint64_t v62 = v15;
      __int16 v63 = 2049;
      uint64_t v64 = v16;
      __int16 v65 = 2050;
      uint64_t v66 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#fusion,failed on locationUpdate,LCFusionExeState,%{public}d,type,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f", buf, 0x2Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      int v40 = *(_DWORD *)(a1 + 2616);
      int v41 = *(_DWORD *)(a2 + 96);
      uint64_t v42 = *(void *)(a2 + 4);
      uint64_t v43 = *(void *)(a2 + 12);
      uint64_t v44 = *(void *)(a2 + 20);
      int v47 = 67241217;
      int v48 = v40;
      __int16 v49 = 1026;
      int v50 = v41;
      __int16 v51 = 2049;
      uint64_t v52 = v42;
      __int16 v53 = 2049;
      uint64_t v54 = v43;
      __int16 v55 = 2050;
      uint64_t v56 = v44;
      int v45 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::provideLocation(const CLLocationProvider_Type::NotificationData &)", "%s\n", v45);
      if (v45 != (char *)buf) {
        free(v45);
      }
    }
    long long v18 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 2980) = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 2996) = v18;
    long long v19 = *(_OWORD *)(a2 + 32);
    long long v20 = *(_OWORD *)(a2 + 48);
    long long v21 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 3044) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 3060) = v21;
    *(_OWORD *)(a1 + 3012) = v19;
    *(_OWORD *)(a1 + 3028) = v20;
    long long v22 = *(_OWORD *)(a2 + 96);
    long long v23 = *(_OWORD *)(a2 + 112);
    long long v24 = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 3120) = *(_OWORD *)(a2 + 140);
    *(_OWORD *)(a1 + 3092) = v23;
    *(_OWORD *)(a1 + 3108) = v24;
    *(_OWORD *)(a1 + 3076) = v22;
    return 1;
  }
  if (v46)
  {
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    uint64_t v26 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *(_DWORD *)(a1 + 1560);
      int v28 = *(_DWORD *)(a2 + 96);
      uint64_t v29 = *(void *)(a2 + 4);
      uint64_t v30 = *(void *)(a2 + 12);
      uint64_t v31 = *(void *)(a2 + 20);
      *(_DWORD *)uint64_t buf = 67241217;
      int v58 = v27;
      __int16 v59 = 1026;
      int v60 = v28;
      __int16 v61 = 2049;
      uint64_t v62 = v29;
      __int16 v63 = 2049;
      uint64_t v64 = v30;
      __int16 v65 = 2050;
      uint64_t v66 = v31;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#fusion,rejected location,reason,%{public}d,type,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f", buf, 0x2Cu);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      int v32 = *(_DWORD *)(a1 + 1560);
      int v33 = *(_DWORD *)(a2 + 96);
      uint64_t v34 = *(void *)(a2 + 4);
      uint64_t v35 = *(void *)(a2 + 12);
      uint64_t v36 = *(void *)(a2 + 20);
      int v47 = 67241217;
      int v48 = v32;
      __int16 v49 = 1026;
      int v50 = v33;
      __int16 v51 = 2049;
      uint64_t v52 = v34;
      __int16 v53 = 2049;
      uint64_t v54 = v35;
      __int16 v55 = 2050;
      uint64_t v56 = v36;
      uint64_t v37 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLLocationControllerFusion::provideLocation(const CLLocationProvider_Type::NotificationData &)", "%s\n");
LABEL_36:
      if (v37 != buf) {
        free(v37);
      }
      return 0;
    }
  }
  else
  {
    if (sub_100180D18(a1 + 456, a1 + 2980))
    {
      *(void *)(a1 + 3056) = *(void *)(a2 + 76);
      *(void *)(a1 + 3136) = *(void *)(a2 + 504);
      return 1;
    }
    if (qword_102419510 != -1) {
      dispatch_once(&qword_102419510, &stru_1022CF3E8);
    }
    int v38 = qword_102419518;
    if (os_log_type_enabled((os_log_t)qword_102419518, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "#Error,LC fusion fused the location but failed to get/yield the location", buf, 2u);
    }
    BOOL v39 = sub_10013D1A0(115, 0);
    BOOL result = 0;
    if (v39)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419510 != -1) {
        dispatch_once(&qword_102419510, &stru_1022CF3E8);
      }
      LOWORD(v47) = 0;
      uint64_t v37 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLLocationControllerFusion::provideLocation(const CLLocationProvider_Type::NotificationData &)", "%s\n");
      goto LABEL_36;
    }
  }
  return result;
}

BOOL sub_10019B888(uint64_t a1, _OWORD *a2)
{
  long long v2 = *(_OWORD *)(a1 + 2996);
  *a2 = *(_OWORD *)(a1 + 2980);
  a2[1] = v2;
  long long v3 = *(_OWORD *)(a1 + 3012);
  long long v4 = *(_OWORD *)(a1 + 3028);
  long long v5 = *(_OWORD *)(a1 + 3060);
  a2[4] = *(_OWORD *)(a1 + 3044);
  a2[5] = v5;
  a2[2] = v3;
  a2[3] = v4;
  long long v6 = *(_OWORD *)(a1 + 3076);
  long long v7 = *(_OWORD *)(a1 + 3092);
  long long v8 = *(_OWORD *)(a1 + 3108);
  *(_OWORD *)((char *)a2 + 140) = *(_OWORD *)(a1 + 3120);
  a2[7] = v7;
  a2[8] = v8;
  a2[6] = v6;
  return *(double *)(a1 + 3000) > 0.0;
}

void sub_10019B8CC(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 3576);
  if (v3) {
    sub_1001AE8C0(v3, a2, a3);
  }
}

BOOL sub_10019B8DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned char *)(a1 + 3528) && (uint64_t v3 = *(unsigned char ***)(a1 + 3520)) != 0 && sub_10003208C(v3, a2, a3);
}

uint64_t sub_10019B8F8(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = *(void *)(a1 + 3680);
  if (v2
    && (long long v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2)) != 0
    && (long long v5 = v4,
        long long v26 = 0u,
        long long v27 = 0u,
        long long v24 = 0u,
        long long v25 = 0u,
        (id v6 = [v4 countByEnumeratingWithState:&v24 objects:v28 count:16]) != 0))
  {
    char v7 = 0;
    uint64_t v8 = *(void *)v25;
    while (2)
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v8) {
          objc_enumerationMutation(v5);
        }
        sub_100134750(&__p, (char *)[*(id *)(*((void *)&v24 + 1) + 8 * i) UTF8String]);
        if ((v23 & 0x80u) == 0) {
          size_t v10 = v23;
        }
        else {
          size_t v10 = __n;
        }
        uint64_t v11 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
        int v12 = (char)v11;
        if ((char)v11 < 0) {
          uint64_t v11 = a2[1];
        }
        if ((unsigned __int8 *)v10 == v11)
        {
          if (v12 >= 0) {
            int v13 = (unsigned __int8 *)a2;
          }
          else {
            int v13 = *a2;
          }
          if ((v23 & 0x80) != 0)
          {
            long long v18 = __p;
            int v19 = memcmp(__p, v13, __n);
            operator delete(v18);
            if (!v19)
            {
LABEL_35:
              char v7 = 1;
              return v7 & 1;
            }
          }
          else
          {
            if (!v23) {
              goto LABEL_35;
            }
            uint64_t v14 = 0;
            do
            {
              int v15 = *((unsigned __int8 *)&__p + v14);
              int v16 = v13[v14];
            }
            while (v15 == v16 && v23 - 1 != v14++);
            v7 |= v15 == v16;
            if (v15 == v16) {
              return v7 & 1;
            }
          }
        }
        else if ((v23 & 0x80) != 0)
        {
          operator delete(__p);
        }
      }
      id v6 = [v5 countByEnumeratingWithState:&v24 objects:v28 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  else
  {
    char v7 = 0;
  }
  return v7 & 1;
}

uint64_t sub_10019BAEC()
{
  return AnalyticsSendEventLazy();
}

uint64_t sub_10019BB60(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 1392);
  sub_100103240();
  uint64_t result = sub_10010145C();
  char v6 = 0;
  if (result && v4)
  {
    if (*(unsigned char *)(a2 + 352)) {
      BOOL v7 = *(_DWORD *)(a2 + 152) == 90603;
    }
    else {
      BOOL v7 = 1;
    }
    char v6 = v7;
  }
  *(unsigned char *)(a1 + 24) = v6;
  return result;
}

uint64_t sub_10019BBC4(uint64_t a1, uint64_t a2, double a3)
{
  if (qword_102419260 != -1) {
    dispatch_once(&qword_102419260, &stru_1022E98B8);
  }
  char v6 = qword_102419268;
  if (os_log_type_enabled((os_log_t)qword_102419268, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    double v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CLExerciseMinuteController::feedNatalie called, rawMets, %f", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419260 != -1) {
      dispatch_once(&qword_102419260, &stru_1022E98B8);
    }
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLExerciseMinuteController::feedNatalie(double, const CLNatalieModelInput &)", "%s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
  uint64_t result = sub_10019BB60(a1, a2);
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    unsigned int v9 = *(unsigned __int8 *)(a1 + 24);
    uint64_t v10 = a1 + 40;
    do
    {
      unsigned int v11 = *(unsigned __int8 *)(v8 + 32);
      BOOL v12 = v11 >= v9;
      if (v11 >= v9) {
        int v13 = (uint64_t *)v8;
      }
      else {
        int v13 = (uint64_t *)(v8 + 8);
      }
      if (v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 40 && v9 >= *(unsigned __int8 *)(v10 + 32)) {
      return (*(uint64_t (**)(void, uint64_t, double))(**(void **)(v10 + 40) + 16))(*(void *)(v10 + 40), a2, a3);
    }
  }
  return result;
}

void sub_10019BE00(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (*a3 == 4)
  {
    if (!std::string::compare((const std::string *)(a4 + 8), "com.apple.Maps"))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CE8C8);
      }
      char v6 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136380675;
        uint64_t v14 = "com.apple.Maps";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CLC: Received kNotificationForegroundRunning for %{private}s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022CE8C8);
        }
        BOOL v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
      sub_10088E41C(a1, 4);
    }
  }
  else if (*a3 == 1)
  {
    if (!std::string::compare((const std::string *)(a4 + 8), "com.apple.Maps"))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CE8C8);
      }
      long long v5 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136380675;
        uint64_t v14 = "com.apple.Maps";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CLC: Received kNotificationTerminated for %{private}s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022CE8C8);
        }
        unsigned int v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
      sub_10088E0E0(a1, 4);
    }
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022CE8C8);
    }
    uint64_t v8 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v9 = *a3;
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v14) = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "CLC: Received unknown notification %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_1022CE8C8);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
}

uint64_t sub_10019C2AC()
{
  return sub_1001B7C64() ^ 1;
}

void sub_10019C2CC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 33 && *(unsigned char *)(a4 + 672) == 0)
  {
    sub_1000EF97C((uint64_t)v6, a4);
    sub_1001951DC(*(void *)(a1 + 672), (uint64_t)v6);

    if (v11) {
      sub_1000DB0A0(v11);
    }
    if (v10 < 0) {
      operator delete(__p);
    }
    if (v8) {
      sub_1000DB0A0(v8);
    }
    if (v7) {
      sub_1000DB0A0(v7);
    }
  }
}

void sub_10019C360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100458658((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10019C374(uint64_t a1, float a2, double a3)
{
  float v13 = a2;
  if (*(unsigned char *)(a1 + 8))
  {
    double v4 = a3 - *(double *)a1;
    if (v4 < *(double *)(a1 + 200)) {
      double v4 = *(double *)(a1 + 200);
    }
    *(double *)(a1 + 200) = v4;
  }
  *(double *)a1 = a3;
  *(unsigned char *)(a1 + 8) = 1;
  float v5 = *(float *)(a1 + 176);
  float v6 = *(float *)(a1 + 180);
  if (v5 > a2) {
    float v5 = a2;
  }
  if (v6 < a2) {
    float v6 = a2;
  }
  *(float *)(a1 + 176) = v5;
  *(float *)(a1 + 180) = v6;
  ++*(_DWORD *)(a1 + 192);
  float v7 = *(float *)(a1 + 136);
  float v8 = *(float *)(a1 + 140);
  if (v7 > a2 || v8 < a2)
  {
    float v10 = vabds_f32(v7, a2);
    float v11 = vabds_f32(v8, a2);
    if (v11 >= v10) {
      float v11 = v10;
    }
    float v12 = v11;
    sub_1001A44F4(a1 + 336, &v12);
    ++*(_DWORD *)(a1 + 188);
  }
  else
  {
    ++*(_DWORD *)(a1 + 184);
  }
  sub_1001A44F4(a1 + 264, &v13);
  if (*(unsigned char *)(a1 + 232))
  {
    CFAbsoluteTimeGetCurrent();
    AnalyticsSendEventLazy();
    *(unsigned char *)(a1 + 232) = 0;
  }
}

void sub_10019C4CC(uint64_t a1, void *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 468))
  {
    double v4 = *(double *)(a1 + 384);
    if (v4 >= -180.0)
    {
      double v5 = *(double *)(a1 + 376);
      if (v5 <= 90.0 && v5 >= -90.0 && v4 <= 180.0)
      {
        uint64_t v6 = a1 + 372;
LABEL_13:
        sub_1000F1268((double *)(a1 + 160), v6, a3);
        *a2 = v9;
        return;
      }
    }
  }
  if (*(_DWORD *)(a1 + 312))
  {
    double v7 = *(double *)(a1 + 228);
    if (v7 >= -180.0)
    {
      double v8 = *(double *)(a1 + 220);
      if (v8 <= 90.0 && v8 >= -90.0 && v7 <= 180.0)
      {
        uint64_t v6 = a1 + 216;
        goto LABEL_13;
      }
    }
  }
}

void sub_10019C5A0(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  if ((*(_DWORD *)(a2 + 96) & 0xFFFFFFF7) != 1)
  {
LABEL_8:
    int v8 = 0;
    goto LABEL_9;
  }
  int v8 = 0;
  if ((*(void *)(a2 + 20) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *(double *)(a2 + 20) > 0.0)
  {
    int v8 = 0;
    if ((*(void *)(a2 + 76) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *(double *)(a2 + 76) > 0.0)
    {
      uint64_t v9 = (double *)sub_100BCE65C();
      double v10 = *(double *)(a3 + 24);
      if (v9[3] != v10)
      {
        *(double *)(a1 + 200) = v10;
        *(double *)(a1 + 208) = a4;
        int v8 = 1;
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
LABEL_9:
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102343F08);
  }
  float v11 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v12 = *(_DWORD *)(a2 + 96);
    uint64_t v13 = *(void *)(a2 + 20);
    uint64_t v14 = *(void *)(a3 + 24);
    uint64_t v16 = *(void *)(a1 + 200);
    uint64_t v15 = *(void *)(a1 + 208);
    *(_DWORD *)uint64_t buf = 134350592;
    double v19 = a4;
    __int16 v20 = 1026;
    int v21 = v8;
    __int16 v22 = 1026;
    int v23 = v12;
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    __int16 v28 = 2050;
    uint64_t v29 = v15;
    __int16 v30 = 2050;
    uint64_t v31 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "BaroAlt,time,%{public}lf,gps fix cf abs time update,success,%{public}d,type,%{public}d,horAcc,%{public}lf,inputCft,%{public}lf,fMCTOfLastGpsFix_s,%{public}lf,fCFTOfLastGpsFix_s,%{public}lf", buf, 0x40u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLBarometricAltimeterCore::storeCFTDerivedFromGpsTimeIfPossible(const CFTimeInterval, const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
}

void sub_10019C870(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = *(double *)(a3 + 12);
  if (v5 < -180.0 || (double v6 = *(double *)(a3 + 4), v6 > 90.0) || v6 < -90.0 || v5 > 180.0)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    uint64_t v14 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *(void *)(a2 + 64);
      double v16 = *(double *)(a3 + 4);
      uint64_t v17 = *(void *)(a3 + 12);
      *(_DWORD *)uint64_t buf = 134349569;
      uint64_t v35 = v15;
      __int16 v36 = 2049;
      double v37 = v16;
      __int16 v38 = 2049;
      uint64_t v39 = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "BaroAlt,#Warning,time,%{public}lf,invalid location for DMA undulation look up,lat,%{private}.8lf,lon,%{private}.8lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      uint64_t v21 = *(void *)(a2 + 64);
      double v22 = *(double *)(a3 + 4);
      uint64_t v23 = *(void *)(a3 + 12);
      int v28 = 134349569;
      uint64_t v29 = v21;
      __int16 v30 = 2049;
      double v31 = v22;
      __int16 v32 = 2049;
      uint64_t v33 = v23;
      goto LABEL_34;
    }
  }
  else
  {
    int v8 = (void *)(a1 + 144);
    uint64_t v9 = (int *)(a1 + 152);
    double v10 = fabs(*(double *)(a1 + 144));
    if ((*(_DWORD *)(a1 + 152) - 1) <= 0xFFFFFFFD && v10 > 2.22044605e-16) {
      return;
    }
    float v27 = 0.0;
    if (sub_10014933C(&v27, v6, v5))
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      int v12 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = *(void *)(a2 + 64);
        *(_DWORD *)uint64_t buf = 134349312;
        uint64_t v35 = v13;
        __int16 v36 = 2050;
        double v37 = v27;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "BaroAlt,time,%{public}lf,no undulation knowledge yet,fall back to DMA altitude,undulation,%{public}lf", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_102343F08);
        }
        uint64_t v25 = *(void *)(a2 + 64);
        int v28 = 134349312;
        uint64_t v29 = v25;
        __int16 v30 = 2050;
        double v31 = v27;
        __int16 v26 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLBarometricAltimeterCore::lookUpDMAUndulationIfNeeded(CLBaroAltEstimatorInput &, const CLDaemonLocation &)", "%s\n", v26);
        if (v26 != (char *)buf) {
          free(v26);
        }
      }
      sub_1001B1A40(*(void *)(a1 + 544), 1, v27, *(double *)(a3 + 76));
      sub_1001862F4(*(void *)(a1 + 544), v8, v9, *(double *)(a3 + 76));
      return;
    }
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102343F08);
    }
    long long v18 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(a2 + 64);
      *(_DWORD *)uint64_t buf = 134349056;
      uint64_t v35 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "BaroAlt,#Warning,time,%{public}lf,failed to get DMA altitude", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102343F08);
      }
      uint64_t v20 = *(void *)(a2 + 64);
      int v28 = 134349056;
      uint64_t v29 = v20;
LABEL_34:
      __int16 v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLBarometricAltimeterCore::lookUpDMAUndulationIfNeeded(CLBaroAltEstimatorInput &, const CLDaemonLocation &)", "%s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
  }
}

BOOL sub_10019CD88(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  double v3 = *(double *)(a2 + 384);
  return v3 > 0.0 && v3 < 12.0 && *a3 != 0;
}

double sub_10019CDB4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9, unsigned char *a10, void *a11, unsigned char *a12, void *a13, double *a14, void *a15, void *a16)
{
  *(void *)(a3 + 64) = *a2;
  uint64_t v20 = a3 + 64;
  *(double *)(a3 + 72) = sub_1000A4CE8(a1, (double *)(a3 + 64));
  *(void *)(v20 + 16) = *a6;
  *(void *)(v20 + 24) = *a7;
  *(void *)(v20 + 32) = *a8;
  *(void *)(v20 + 40) = *a9;
  *(unsigned char *)(v20 + 48) = *a12;
  *(_OWORD *)(v20 + 56) = *(_OWORD *)(a5 + 376);
  *(_OWORD *)(v20 + 72) = *(_OWORD *)(a4 + 44);
  *(void *)(v20 + 104) = *a15;
  *(unsigned char *)(v20 + 112) = *a10;
  *(void *)(v20 + 120) = *a11;
  *(void *)(v20 + 192) = *a16;
  *(void *)(v20 + 200) = *a13;
  double result = *a14;
  *(double *)(v20 + 208) = *a14;
  return result;
}

void sub_10019CEC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(_DWORD *)(a4 + 312);
  double v8 = *(float *)(a4 + 316);
  double v9 = fabs(v8);
  if ((v7 - 1) <= 0xFFFFFFFD && v9 > 2.22044605e-16)
  {
    sub_1001B1A40(*(void *)(a1 + 544), v7, v8, *(double *)(a3 + 76));
    sub_1001862F4(*(void *)(a1 + 544), (void *)(a1 + 144), (int *)(a1 + 152), *(double *)(a3 + 76));
  }

  sub_10019C870(a1, a2, a3);
}

void sub_10019CF58(double *a1, uint64_t a2)
{
  double v3 = a1[37];
  unint64_t v4 = *(unint64_t *)(a2 + 8);
  uint64_t v5 = (uint64_t)(a1 + 1);
  sub_100175C04((uint64_t)(a1 + 1), (long long *)a2);
  v6.n128_u64[0] = v4;
  sub_1000B8D4C(v5, v6);
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)a1 + 104))();
  v8.n128_u64[0] = v4;
  sub_1001B6634(v7, v8);
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)a1 + 112))();
  v10.n128_u64[0] = v4;
  sub_1001B74B4(v9, v10);
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)a1 + 120))();
  v12.n128_u64[0] = v4;
  sub_1000BB7C4(v11, v12);
  uint64_t v13 = (*(uint64_t (**)(void))(**(void **)a1 + 128))();
  v14.n128_u64[0] = v4;
  sub_1001B709C(v13, v14);
  uint64_t v15 = (*(uint64_t (**)(void))(**(void **)a1 + 136))();
  v16.n128_u64[0] = v4;
  sub_1000BA5E4(v15, v16);
  uint64_t v17 = (*(uint64_t (**)(void))(**(void **)a1 + 144))();
  v18.n128_u64[0] = v4;
  sub_1001B5E90(v17, v18);
  uint64_t v19 = (*(uint64_t (**)(void))(**(void **)a1 + 152))();
  v20.n128_u64[0] = v4;
  sub_1001B5A98(v19, v20);
  uint64_t v21 = (*(uint64_t (**)(void))(**(void **)a1 + 160))();
  v22.n128_u64[0] = v4;
  sub_1000B8954(v21, v22);
  uint64_t v23 = (*(uint64_t (**)(void))(**(void **)a1 + 168))();
  v24.n128_u64[0] = v4;
  sub_1001B786C(v23, v24);
  uint64_t v25 = (*(uint64_t (**)(void))(**(void **)a1 + 176))();
  v26.n128_u64[0] = v4;
  sub_1001B6288(v25, v26);
  uint64_t v27 = (*(uint64_t (**)(void))(**(void **)a1 + 184))();
  v28.n128_u64[0] = v4;
  sub_1001B6CB4(v27, v28);
  uint64_t v29 = (*(uint64_t (**)(void))(**(void **)a1 + 192))();
  v30.n128_u64[0] = v4;
  sub_1001B56EC(v29, v30);
  uint64_t v31 = (*(uint64_t (**)(void))(**(void **)a1 + 200))();
  v32.n128_u64[0] = v4;
  sub_1001B52F4(v31, v32);
  BOOL v33 = *(double *)&v4 <= v3 || a1[37] == -1.0;
  double v34 = *(double *)&v4 - v3;
  if (v33) {
    double v34 = 0.0;
  }
  a1[40] = v34;
  a1[37] = *(double *)&v4;
}

void sub_10019D234(uint64_t *a1)
{
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_102311F18);
  }
  uint64_t v2 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *a1;
    uint64_t v4 = a1[39];
    uint64_t v5 = a1[26];
    int v6 = *((_DWORD *)a1 + 54);
    uint64_t v7 = a1[29];
    uint64_t v8 = a1[30];
    *(_DWORD *)uint64_t buf = 134219264;
    uint64_t v11 = v3;
    __int16 v12 = 2048;
    uint64_t v13 = v4;
    __int16 v14 = 2048;
    uint64_t v15 = v7;
    __int16 v16 = 2048;
    uint64_t v17 = v5;
    __int16 v18 = 1024;
    int v19 = v6;
    __int16 v20 = 2048;
    uint64_t v21 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "ExtendedSteps,%f,firstStepTime,%f,lastStepTime,%f,rawPace,%f,incrementalSteps,%u,odometerSpeed,%f", buf, 0x3Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_102311F18);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static void CLWorkoutPredictorInputs::logExtendedStep(const CLWorkoutPredictorExtendedStep &)", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
}

void sub_10019D468(uint64_t a1)
{
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_102311F18);
  }
  uint64_t v2 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a1 + 20);
    int v6 = *(_DWORD *)(a1 + 24);
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)uint64_t buf = 134219520;
    uint64_t v11 = v3;
    __int16 v12 = 1024;
    int v13 = v4;
    __int16 v14 = 1024;
    int v15 = v5;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2048;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = v3;
    __int16 v22 = 1024;
    int v23 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Elevation,%f,ascended,%d,descended,%d,gradeType,%d,verticalSpeed,%f,startTime,%f,source,%d", buf, 0x38u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_102311F18);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static void CLWorkoutPredictorInputs::logElevation(const CLWorkoutPredictorElevation &)", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
}

void sub_10019D6AC(uint64_t a1)
{
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  sub_100052E44(a1, (uint64_t)v24);
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_102311F18);
  }
  uint64_t v2 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = *(unsigned __int8 *)(a1 + 144);
    double v5 = *(float *)(a1 + 112);
    double v6 = *(float *)(a1 + 116);
    double v7 = *(float *)(a1 + 132);
    double v8 = *(float *)(a1 + 136);
    double v9 = *(float *)(a1 + 128);
    double v10 = *(float *)(a1 + 124);
    double v11 = *(float *)(a1 + 120);
    int v12 = *(_DWORD *)(a1 + 140);
    *(_DWORD *)uint64_t buf = 134220544;
    uint64_t v49 = v3;
    __int16 v50 = 1024;
    int v51 = v24[0];
    __int16 v52 = 1024;
    int v53 = v4;
    __int16 v54 = 2048;
    double v55 = v5;
    __int16 v56 = 2048;
    double v57 = v6;
    __int16 v58 = 2048;
    double v59 = v7;
    __int16 v60 = 2048;
    double v61 = v8;
    __int16 v62 = 2048;
    double v63 = v9;
    __int16 v64 = 2048;
    double v65 = v10;
    __int16 v66 = 2048;
    double v67 = v11;
    __int16 v68 = 1024;
    int v69 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activity,%f,type,%u,standing,%d,angeX,%f,vectorMag,%f,strokeAmp,%f,strokePwr,%f,strokeFreq,%f,machineFreq,%f,pushVectorMag,%f,epochType,%d", buf, 0x64u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_102311F18);
    }
    uint64_t v13 = *(void *)(a1 + 8);
    int v14 = *(unsigned __int8 *)(a1 + 144);
    double v15 = *(float *)(a1 + 112);
    double v16 = *(float *)(a1 + 116);
    double v17 = *(float *)(a1 + 132);
    double v18 = *(float *)(a1 + 136);
    double v19 = *(float *)(a1 + 128);
    double v20 = *(float *)(a1 + 124);
    double v21 = *(float *)(a1 + 120);
    int v22 = *(_DWORD *)(a1 + 140);
    int v26 = 134220544;
    uint64_t v27 = v13;
    __int16 v28 = 1024;
    int v29 = v24[0];
    __int16 v30 = 1024;
    int v31 = v14;
    __int16 v32 = 2048;
    double v33 = v15;
    __int16 v34 = 2048;
    double v35 = v16;
    __int16 v36 = 2048;
    double v37 = v17;
    __int16 v38 = 2048;
    double v39 = v18;
    __int16 v40 = 2048;
    double v41 = v19;
    __int16 v42 = 2048;
    double v43 = v20;
    __int16 v44 = 2048;
    double v45 = v21;
    __int16 v46 = 1024;
    int v47 = v22;
    int v23 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static void CLWorkoutPredictorInputs::logActivity(const CLWorkoutPredictorActivity &)", "%s\n", v23);
    if (v23 != (char *)buf) {
      free(v23);
    }
  }
}

uint64_t sub_10019D9A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 104);
  if (!v3 || !sub_10014C3C0(v3))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_100134750(&v8, "No connection to database when attempting to open transaction.");
    std::runtime_error::runtime_error(exception, &v8);
    exception->__vftable = (std::runtime_error_vtbl *)&off_10229EDE0;
  }
  uint64_t v5 = *(void *)(a1 + 104);

  return sub_1001B0D0C(v5, a2);
}

void sub_10019DA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_10019DAA8(uint64_t *a1@<X0>, void *a2@<X8>)
{
}

uint64_t sub_10019DAB0@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10019D9A4(*a1, a2);
}

void sub_10019DAB8(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 14) != a2)
  {
    *(unsigned char *)(a1 + 14) = a2;
    sub_100F34138(a1);
    if (*(unsigned char *)(a1 + 14))
    {
      if (*(unsigned char *)(a1 + 12)) {
        *(unsigned char *)(a1 + 15) = 1;
      }
    }
  }

  sub_100183190((int *)a1);
}

BOOL sub_10019DB1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a2 + 516)) {
    BOOL v4 = *(_DWORD *)(a2 + 96) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  BOOL result = 1;
  if (!v4 && *(double *)(a3 + 20) > 0.0)
  {
    double v6 = *(double *)(a2 + 76) - *(double *)(a3 + 76);
    if (v6 >= 0.0 && v6 < 6.0)
    {
      double v8 = *(double *)(a2 + 36);
      double v9 = *(double *)(a3 + 36);
      if ((v8 <= 0.0 || v9 >= 0.0)
        && (v8 <= 0.0 || v9 <= 0.0 || vabdd_f64(*(double *)(a2 + 28), *(double *)(a3 + 28)) <= 1.0)
        && *(_DWORD *)(a2 + 84) <= *(_DWORD *)(a3 + 84))
      {
        sub_1000F1268((double *)(a1 + 11560), a2, a3);
        if (v10 > 1.0) {
          return 1;
        }
        if (*(unsigned char *)(a1 + 11672))
        {
          if (qword_1024193D0 != -1) {
            dispatch_once(&qword_1024193D0, &stru_102305D90);
          }
          uint64_t v11 = qword_1024193D8;
          BOOL v12 = os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT);
          BOOL result = 0;
          if (v12)
          {
            int v16 = 68289026;
            int v17 = 0;
            __int16 v18 = 2082;
            double v19 = "";
            uint64_t v13 = v11;
            os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
LABEL_28:
            _os_log_impl((void *)&_mh_execute_header, v13, v14, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, same location\"}", (uint8_t *)&v16, 0x12u);
            return 0;
          }
        }
        else
        {
          if (qword_1024193D0 != -1) {
            dispatch_once(&qword_1024193D0, &stru_102305D90);
          }
          uint64_t v15 = qword_1024193D8;
          BOOL result = os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG);
          if (result)
          {
            int v16 = 68289026;
            int v17 = 0;
            __int16 v18 = 2082;
            double v19 = "";
            uint64_t v13 = v15;
            os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
            goto LABEL_28;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10019DD38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a2 + 96);
  if (v3 != 11 && v3 != 4) {
    return 0;
  }
  uint64_t result = 0;
  if (*(_DWORD *)(a3 + 96) == 10 && *(double *)(a3 + 20) > 0.0)
  {
    if (vabdd_f64(*(double *)(a2 + 76), *(double *)(a3 + 76)) >= 6.0
      || sub_100BCE2EC(a2) && *(double *)(a3 + 36) > *(double *)(a2 + 36))
    {
      return 0;
    }
    if (*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v9 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      int v10 = *(_DWORD *)(a2 + 96);
      int v15 = 68289282;
      int v16 = 0;
      __int16 v17 = 2082;
      __int16 v18 = "";
      __int16 v19 = 1026;
      int v20 = v10;
      uint64_t v11 = v9;
      os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v13 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        return 1;
      }
      int v14 = *(_DWORD *)(a2 + 96);
      int v15 = 68289282;
      int v16 = 0;
      __int16 v17 = 2082;
      __int16 v18 = "";
      __int16 v19 = 1026;
      int v20 = v14;
      uint64_t v11 = v13;
      os_log_type_t v12 = OS_LOG_TYPE_DEBUG;
    }
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, Ignoring location assistance, recentGoodPipeline\", \"location.type\":%{public}d}", (uint8_t *)&v15, 0x18u);
    return 1;
  }
  return result;
}

uint64_t sub_10019DF34(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)(a1 + 11672);
  uint64_t v3 = *(unsigned int *)(a2 + 84);
  unsigned int v4 = *(_DWORD *)(a2 + 96);
  if (v4) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(unsigned char *)(a2 + 516) == 0;
  }
  if (!v5)
  {
    if (*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v13 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
        return v3;
      }
      int v31 = 68289026;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      int v14 = v13;
      os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v19 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        return v3;
      }
      int v31 = 68289026;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      int v14 = v19;
      os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
    }
    _os_log_impl((void *)&_mh_execute_header, v14, v15, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, adjust,TEPA confidence\"}", (uint8_t *)&v31, 0x12u);
    return v3;
  }
  if (!*(unsigned char *)(a1 + 11672))
  {
    if (v4 != 4 || *(double *)(a2 + 20) <= 0.0 || v3 < 0x46) {
      return v3;
    }
    if (sub_1000E6DB4(a1 + 6408))
    {
      double v16 = *(double *)(a1 + 6428);
      sub_1000F1268((double *)(a1 + 11560), a2, a1 + 6408);
      double v18 = v17;
      if (v17 >= 0.0 && v17 <= v16) {
        return v3;
      }
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      int v26 = qword_1024193D8;
      double v16 = -1.0;
      double v18 = -1.0;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_45;
      }
      int v31 = 68289026;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, No previous cell location stored\"}", (uint8_t *)&v31, 0x12u);
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
LABEL_45:
    uint64_t v27 = qword_1024193D8;
    uint64_t v20 = 69;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
      return v20;
    }
    int v31 = 68290050;
    __int16 v33 = 2082;
    int v32 = 0;
    __int16 v34 = "";
    __int16 v35 = 2050;
    *(double *)__int16 v36 = v18;
    *(_WORD *)&v36[8] = 2050;
    double v37 = v16;
    __int16 v38 = 1026;
    int v39 = v3;
    __int16 v40 = 1026;
    int v41 = 69;
    int v23 = "{\"msg%{public}.0s\":\"#GnssAssistancePosition\", \"distFromWifiToCellOrLAC\":\"%{public}f\", \"crossCheckThre"
          "shold\":\"%{public}f\", \"confPrior\":%{public}d, \"reducedConf\":%{public}d}";
    __n128 v24 = v27;
    os_log_type_t v25 = OS_LOG_TYPE_DEBUG;
    uint32_t v28 = 50;
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v24, v25, v23, (uint8_t *)&v31, v28);
    return v20;
  }
  BOOL v8 = v4 > 0xA;
  int v9 = (1 << v4) & 0x450;
  if (v8 || v9 == 0) {
    goto LABEL_35;
  }
  if ((sub_1000E6DB4(a2) & 1) == 0)
  {
    if (!*v2)
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v29 = qword_1024193D8;
      uint64_t v20 = 0xFFFFFFFFLL;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        return v20;
      }
      int v30 = *(_DWORD *)(a2 + 96);
      int v31 = 68289794;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 1026;
      *(_DWORD *)__int16 v36 = v30;
      *(_WORD *)&v36[4] = 1026;
      *(_DWORD *)&v36[6] = v3;
      LOWORD(v37) = 1026;
      *(_DWORD *)((char *)&v37 + 2) = -1;
      int v23 = "{\"msg%{public}.0s\":\"#GnssAssistancePosition, invalid assistance during emergency\", \"location type\":%{p"
            "ublic}d, \"conf\":%{public}d, \"reduced conf\":%{public}d}";
      __n128 v24 = v29;
      os_log_type_t v25 = OS_LOG_TYPE_DEBUG;
LABEL_51:
      uint32_t v28 = 36;
      goto LABEL_52;
    }
LABEL_35:
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v21 = qword_1024193D8;
    uint64_t v20 = 0xFFFFFFFFLL;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
      return v20;
    }
    int v22 = *(_DWORD *)(a2 + 96);
    int v31 = 68289794;
    int v32 = 0;
    __int16 v33 = 2082;
    __int16 v34 = "";
    __int16 v35 = 1026;
    *(_DWORD *)__int16 v36 = v22;
    *(_WORD *)&v36[4] = 1026;
    *(_DWORD *)&v36[6] = v3;
    LOWORD(v37) = 1026;
    *(_DWORD *)((char *)&v37 + 2) = -1;
    int v23 = "{\"msg%{public}.0s\":\"#GnssAssistancePosition, invalid assistance during emergency\", \"location type\":%{pub"
          "lic}d, \"conf\":%{public}d, \"reduced conf\":%{public}d}";
    __n128 v24 = v21;
    os_log_type_t v25 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_51;
  }
  uint64_t v11 = sub_100F3A0F8(a1, a2);

  return sub_100F3B454(a1, v11, a2);
}

uint64_t sub_10019E45C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_DWORD *)(a2 + 96) & 0xFFFFFFFE) != 6) {
    return 0;
  }
  int v4 = *(_DWORD *)(a3 + 96);
  if (v4 == 4 || v4 == 11)
  {
    if (*(_DWORD *)(a3 + 84) >= 0x45u) {
      goto LABEL_11;
    }
    return 0;
  }
  uint64_t v6 = 0;
  if (v4 == 10 && *(_DWORD *)(a3 + 84) > 0x44u)
  {
LABEL_11:
    if (*(double *)(a3 + 20) > 0.0 && vabdd_f64(*(double *)(a2 + 76), *(double *)(a3 + 76)) < 1.0)
    {
      if (*(unsigned char *)(a1 + 11672))
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_102305D90);
        }
        uint64_t v7 = qword_1024193D8;
        if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
          return 1;
        }
        int v8 = *(_DWORD *)(a2 + 96);
        int v14 = 68289282;
        int v15 = 0;
        __int16 v16 = 2082;
        double v17 = "";
        __int16 v18 = 1026;
        int v19 = v8;
        int v9 = v7;
        os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
      }
      else
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_102305D90);
        }
        uint64_t v12 = qword_1024193D8;
        if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
          return 1;
        }
        int v13 = *(_DWORD *)(a2 + 96);
        int v14 = 68289282;
        int v15 = 0;
        __int16 v16 = 2082;
        double v17 = "";
        __int16 v18 = 1026;
        int v19 = v13;
        int v9 = v12;
        os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
      }
      _os_log_impl((void *)&_mh_execute_header, v9, v10, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, Ignoring location assistance, recentGoodWifi\", \"location.type\":%{public}d}", (uint8_t *)&v14, 0x18u);
      return 1;
    }
    return 0;
  }
  return v6;
}

BOOL sub_10019E658(uint64_t a1, uint64_t a2, double a3)
{
  double v6 = *(double *)(a2 + 20);
  BOOL v7 = v6 > 0.0;
  if (v6 <= 0.0)
  {
    if (*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v8 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_12;
      }
      uint64_t v9 = *(void *)(a2 + 20);
      int v50 = 68289282;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2050;
      uint64_t v55 = v9;
      os_log_type_t v10 = v8;
      os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
    }
    else
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v12 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_12;
      }
      uint64_t v13 = *(void *)(a2 + 20);
      int v50 = 68289282;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2050;
      uint64_t v55 = v13;
      os_log_type_t v10 = v12;
      os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
    }
    _os_log_impl((void *)&_mh_execute_header, v10, v11, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location\", \"horizontal accuracy\":\"%{public}f\"}", (uint8_t *)&v50, 0x1Cu);
LABEL_12:
    double v6 = *(double *)(a2 + 20);
  }
  if (v6 <= 200000.0) {
    goto LABEL_25;
  }
  if (!*(unsigned char *)(a1 + 11672))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v18 = qword_1024193D8;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_24;
    }
    uint64_t v19 = *(void *)(a2 + 20);
    int v50 = 68289538;
    int v51 = 0;
    __int16 v52 = 2082;
    int v53 = "";
    __int16 v54 = 2050;
    uint64_t v55 = v19;
    __int16 v56 = 2050;
    uint64_t v57 = 0x41086A0000000000;
    __int16 v16 = v18;
    os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v16, v17, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location\", \"horizontalAccuracy\":\"%{public}f\", \"maximumAccuracy\":\"%{public}f\"}", (uint8_t *)&v50, 0x26u);
LABEL_24:
    BOOL v7 = 0;
    goto LABEL_25;
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_102305D90);
  }
  uint64_t v14 = qword_1024193D8;
  BOOL v7 = 0;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a2 + 20);
    int v50 = 68289538;
    int v51 = 0;
    __int16 v52 = 2082;
    int v53 = "";
    __int16 v54 = 2050;
    uint64_t v55 = v15;
    __int16 v56 = 2050;
    uint64_t v57 = 0x41086A0000000000;
    __int16 v16 = v14;
    os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_23;
  }
LABEL_25:
  if (a3 >= 0.0) {
    goto LABEL_37;
  }
  if (!*(unsigned char *)(a1 + 11672))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v23 = qword_1024193D8;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_36;
    }
    int v50 = 68289026;
    int v51 = 0;
    __int16 v52 = 2082;
    int v53 = "";
    uint64_t v21 = v23;
    os_log_type_t v22 = OS_LOG_TYPE_DEBUG;
LABEL_35:
    _os_log_impl((void *)&_mh_execute_header, v21, v22, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location, age < 0\"}", (uint8_t *)&v50, 0x12u);
LABEL_36:
    BOOL v7 = 0;
    goto LABEL_37;
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_102305D90);
  }
  uint64_t v20 = qword_1024193D8;
  BOOL v7 = 0;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v50 = 68289026;
    int v51 = 0;
    __int16 v52 = 2082;
    int v53 = "";
    uint64_t v21 = v20;
    os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_35;
  }
LABEL_37:
  if (sub_1000EF668(*(double *)(a2 + 4), *(double *)(a2 + 12)))
  {
    if (!*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v27 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_48;
      }
      int v50 = 68289026;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      os_log_type_t v25 = v27;
      os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
LABEL_47:
      _os_log_impl((void *)&_mh_execute_header, v25, v26, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location,null island\"}", (uint8_t *)&v50, 0x12u);
LABEL_48:
      BOOL v7 = 0;
      goto LABEL_49;
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v24 = qword_1024193D8;
    BOOL v7 = 0;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
    {
      int v50 = 68289026;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      os_log_type_t v25 = v24;
      os_log_type_t v26 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_47;
    }
  }
LABEL_49:
  double v28 = *(double *)(a2 + 4);
  if (v28 < -90.0 || v28 > 90.0)
  {
    if (!*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v33 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_61;
      }
      uint64_t v34 = *(void *)(a2 + 4);
      int v50 = 68289283;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2049;
      uint64_t v55 = v34;
      int v31 = v33;
      os_log_type_t v32 = OS_LOG_TYPE_DEBUG;
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v31, v32, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location\", \"latitude\":\"%{private}.7f\"}", (uint8_t *)&v50, 0x1Cu);
LABEL_61:
      BOOL v7 = 0;
      goto LABEL_62;
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v29 = qword_1024193D8;
    BOOL v7 = 0;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = *(void *)(a2 + 4);
      int v50 = 68289283;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2049;
      uint64_t v55 = v30;
      int v31 = v29;
      os_log_type_t v32 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_60;
    }
  }
LABEL_62:
  double v35 = *(double *)(a2 + 12);
  if (v35 < -180.0 || v35 > 180.0)
  {
    if (!*(unsigned char *)(a1 + 11672))
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v40 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_74;
      }
      uint64_t v41 = *(void *)(a2 + 12);
      int v50 = 68289283;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2049;
      uint64_t v55 = v41;
      __int16 v38 = v40;
      os_log_type_t v39 = OS_LOG_TYPE_DEBUG;
LABEL_73:
      _os_log_impl((void *)&_mh_execute_header, v38, v39, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location\", \"longitude\":\"%{private}.7f\"}", (uint8_t *)&v50, 0x1Cu);
LABEL_74:
      BOOL v7 = 0;
      goto LABEL_75;
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102305D90);
    }
    uint64_t v36 = qword_1024193D8;
    BOOL v7 = 0;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = *(void *)(a2 + 12);
      int v50 = 68289283;
      int v51 = 0;
      __int16 v52 = 2082;
      int v53 = "";
      __int16 v54 = 2049;
      uint64_t v55 = v37;
      __int16 v38 = v36;
      os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_73;
    }
  }
LABEL_75:
  if (*(double *)(a2 + 36) > 0.0)
  {
    double v42 = *(double *)(a2 + 28);
    if (v42 < -450.0 || v42 > 8850.0)
    {
      if (!*(unsigned char *)(a1 + 11672))
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_102305D90);
        }
        uint64_t v47 = qword_1024193D8;
        if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
          return 0;
        }
        uint64_t v48 = *(void *)(a2 + 28);
        int v50 = 68289283;
        int v51 = 0;
        __int16 v52 = 2082;
        int v53 = "";
        __int16 v54 = 2049;
        uint64_t v55 = v48;
        double v45 = v47;
        os_log_type_t v46 = OS_LOG_TYPE_DEBUG;
LABEL_87:
        _os_log_impl((void *)&_mh_execute_header, v45, v46, "{\"msg%{public}.0s\":\"#GnssAssistancePosition, #Warning invalid assistance location\", \"altitude\":\"%{private}.2f\"}", (uint8_t *)&v50, 0x1Cu);
        return 0;
      }
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_102305D90);
      }
      uint64_t v43 = qword_1024193D8;
      BOOL v7 = 0;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = *(void *)(a2 + 28);
        int v50 = 68289283;
        int v51 = 0;
        __int16 v52 = 2082;
        int v53 = "";
        __int16 v54 = 2049;
        uint64_t v55 = v44;
        double v45 = v43;
        os_log_type_t v46 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_87;
      }
    }
  }
  return v7;
}

BOOL sub_10019EFAC(unsigned char *a1, uint64_t a2)
{
  int v3 = *a1;
  double v4 = *(double *)(a2 + 20);
  if ((*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v4 <= 500.0 && v4 > 0.0)
  {
    int v6 = sub_1001A0BB0((float64_t *)(a2 + 4), (double *)(a2 + 12), 0);
    *a1 = v6;
    if (v3 != v6)
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022F8780);
      }
      BOOL v7 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_INFO))
      {
        int v8 = *a1;
        uint64_t v9 = *(void *)(a2 + 4);
        uint64_t v10 = *(void *)(a2 + 12);
        int v11 = *(_DWORD *)(a2 + 96);
        uint64_t v12 = *(void *)(a2 + 20);
        *(_DWORD *)uint64_t buf = 67241217;
        int v16 = v8;
        __int16 v17 = 2049;
        uint64_t v18 = v9;
        __int16 v19 = 2049;
        uint64_t v20 = v10;
        __int16 v21 = 1026;
        int v22 = v11;
        __int16 v23 = 2050;
        uint64_t v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "DEMDeweightAreaMonitor,state,%{public}d,lat,%{private}0.3f,lon,%{private}0.3f,type,%{public}d,accuracy,%{public}0.3f", buf, 0x2Cu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_1022F8780);
        }
        uint64_t v14 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLDEMDeweightAreaMonitor::didDEMDeweightAreaStatusChange(const CLDaemonLocation &)", "%s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
      }
    }
  }
  return v3 != *a1;
}

void sub_10019F240(uint64_t a1)
{
  sub_100017F64(a1);

  operator delete();
}

uint64_t sub_10019F278(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_1023020B8);
  }
  BOOL v5 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    int v6 = "Walk";
    if (v4) {
      int v6 = "Run";
    }
    *(_DWORD *)uint64_t buf = 136315138;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Pedestrian, Using %s model", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1023020B8);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMetsInfo CLCaloriePedestrianModel::computeMETS(const CLNatalieModelInput &)", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  uint64_t v7 = 24;
  if (v4) {
    uint64_t v7 = 8;
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + v7) + 16))(*(void *)(a1 + v7), a2);
}

uint64_t sub_10019F4CC()
{
  if (qword_1024823C0 != -1) {
    dispatch_once(&qword_1024823C0, &stru_1023058B8);
  }
  return qword_10248AF78;
}

uint64_t sub_10019F510()
{
  if (qword_102482290 != -1) {
    dispatch_once(&qword_102482290, &stru_102302000);
  }
  return qword_10248AE18;
}

BOOL sub_10019F554(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 8) silo];
  *(_DWORD *)(a1 + 824) = 1;
  BOOL v4 = sub_10019F650(a1);
  if (v4)
  {
    long long v5 = *(_OWORD *)(a1 + 44);
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 28);
    *(_OWORD *)(a2 + 16) = v5;
    long long v6 = *(_OWORD *)(a1 + 60);
    long long v7 = *(_OWORD *)(a1 + 76);
    long long v8 = *(_OWORD *)(a1 + 108);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 92);
    *(_OWORD *)(a2 + 80) = v8;
    *(_OWORD *)(a2 + 32) = v6;
    *(_OWORD *)(a2 + 48) = v7;
    long long v9 = *(_OWORD *)(a1 + 124);
    long long v10 = *(_OWORD *)(a1 + 140);
    long long v11 = *(_OWORD *)(a1 + 156);
    *(_OWORD *)(a2 + 140) = *(_OWORD *)(a1 + 168);
    *(_OWORD *)(a2 + 112) = v10;
    *(_OWORD *)(a2 + 128) = v11;
    *(_OWORD *)(a2 + 96) = v9;
    memcpy((void *)(a2 + 160), (const void *)(a1 + 184), 0x201uLL);
    uint64_t v12 = *(void *)(a1 + 704);
    uint64_t v13 = *(void *)(a1 + 712);
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(a2 + 680) = v12;
    uint64_t v14 = *(std::__shared_weak_count **)(a2 + 688);
    *(void *)(a2 + 688) = v13;
    if (v14) {
      sub_1000DB0A0(v14);
    }
    long long v15 = *(_OWORD *)(a1 + 720);
    long long v16 = *(_OWORD *)(a1 + 752);
    *(_OWORD *)(a2 + 712) = *(_OWORD *)(a1 + 736);
    *(_OWORD *)(a2 + 728) = v16;
    *(_OWORD *)(a2 + 696) = v15;
    long long v17 = *(_OWORD *)(a1 + 768);
    long long v18 = *(_OWORD *)(a1 + 784);
    long long v19 = *(_OWORD *)(a1 + 800);
    *(void *)(a2 + 789) = *(void *)(a1 + 813);
    *(_OWORD *)(a2 + 760) = v18;
    *(_OWORD *)(a2 + 776) = v19;
    *(_OWORD *)(a2 + 744) = v17;
  }
  return v4;
}

BOOL sub_10019F650(uint64_t a1)
{
  if (*(double *)(a1 + 48) <= 0.0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231F568);
    }
    long long v17 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Last confident location not available", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 == -1)
      {
LABEL_25:
        uint64_t v20 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLastConfidentLocation::isLastConfidentLocationValid()", "%s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
        return 0;
      }
LABEL_35:
      dispatch_once(&qword_102419630, &stru_10231F568);
      goto LABEL_25;
    }
  }
  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v3 = *(double *)(a1 + 104);
    if (Current < v3 + 1800.0)
    {
      if (Current >= v3) {
        return 1;
      }
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231F568);
      }
      BOOL v4 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = *(void *)(a1 + 104);
        *(_DWORD *)uint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#Warning Last confident location is in future, timestamp,%.03lf", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419630 != -1) {
          dispatch_once(&qword_102419630, &stru_10231F568);
        }
        uint64_t v24 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLastConfidentLocation::isLastConfidentLocationValid()", "%s\n", v24);
        if (v24 != (char *)buf) {
          free(v24);
        }
      }
      *(_DWORD *)(a1 + 28) = 0xFFFF;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = xmmword_101D1C320;
      __asm { FMOV            V0.2D, #-1.0 }
      *(_OWORD *)(a1 + 64) = _Q0;
      *(_OWORD *)(a1 + 80) = _Q0;
      *(_OWORD *)(a1 + 96) = _Q0;
      *(_DWORD *)(a1 + 112) = 0;
      *(void *)(a1 + 116) = 0xBFF0000000000000;
      *(_OWORD *)(a1 + 124) = 0u;
      *(_DWORD *)(a1 + 140) = 0;
      *(void *)(a1 + 144) = 0xBFF0000000000000;
      *(_DWORD *)(a1 + 152) = 0x7FFFFFFF;
      *(void *)(a1 + 156) = 0;
      *(_OWORD *)(a1 + 164) = 0u;
      *(unsigned char *)(a1 + 180) = 0;
      sub_1000DBC34(buf);
      memcpy((void *)(a1 + 184), buf, 0x201uLL);
      long long v11 = v26;
      long long v26 = 0u;
      uint64_t v12 = *(std::__shared_weak_count **)(a1 + 712);
      *(_OWORD *)(a1 + 704) = v11;
      if (v12)
      {
        sub_1000DB0A0(v12);
        uint64_t v13 = (std::__shared_weak_count *)*((void *)&v26 + 1);
        long long v14 = v32[0];
        *(_OWORD *)(a1 + 784) = v31;
        *(_OWORD *)(a1 + 800) = v14;
        *(void *)(a1 + 813) = *(void *)((char *)v32 + 13);
        long long v15 = v28;
        *(_OWORD *)(a1 + 720) = v27;
        *(_OWORD *)(a1 + 736) = v15;
        long long v16 = v30;
        *(_OWORD *)(a1 + 752) = v29;
        *(_OWORD *)(a1 + 768) = v16;
        if (v13) {
          sub_1000DB0A0(v13);
        }
      }
      else
      {
        long long v21 = v32[0];
        *(_OWORD *)(a1 + 784) = v31;
        *(_OWORD *)(a1 + 800) = v21;
        *(void *)(a1 + 813) = *(void *)((char *)v32 + 13);
        long long v22 = v28;
        *(_OWORD *)(a1 + 720) = v27;
        *(_OWORD *)(a1 + 736) = v22;
        long long v23 = v30;
        *(_OWORD *)(a1 + 752) = v29;
        *(_OWORD *)(a1 + 768) = v23;
      }
      return 0;
    }
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231F568);
    }
    long long v19 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = 0x409C200000000000;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Last confident location too old, maxAge = %.1lf", buf, 0xCu);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 == -1) {
        goto LABEL_25;
      }
      goto LABEL_35;
    }
  }
  return result;
}

BOOL sub_10019FB5C(uint64_t a1, uint64_t a2)
{
  double v3 = *(double *)(a2 + 20);
  BOOL v4 = v3 > 0.0;
  if (v3 <= 0.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10232F680);
    }
    uint64_t v5 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a2 + 20);
      int v20 = 68289282;
      int v21 = 0;
      __int16 v22 = 2082;
      long long v23 = "";
      __int16 v24 = 2050;
      uint64_t v25 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location\", \"horizontal accuracy\":\"%{public}f\"}", (uint8_t *)&v20, 0x1Cu);
    }
    double v3 = *(double *)(a2 + 20);
  }
  if (v3 > 200000.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10232F680);
    }
    long long v7 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a2 + 20);
      int v20 = 68289538;
      int v21 = 0;
      __int16 v22 = 2082;
      long long v23 = "";
      __int16 v24 = 2050;
      uint64_t v25 = v8;
      __int16 v26 = 2050;
      uint64_t v27 = 0x41086A0000000000;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location\", \"horizontalAccuracy\":\"%{public}f\", \"maximumAccuracy\":\"%{public}f\"}", (uint8_t *)&v20, 0x26u);
    }
    BOOL v4 = 0;
  }
  if (sub_1000EF668(*(double *)(a2 + 4), *(double *)(a2 + 12)))
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10232F680);
    }
    long long v9 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      int v20 = 68289026;
      int v21 = 0;
      __int16 v22 = 2082;
      long long v23 = "";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location,null island\"}", (uint8_t *)&v20, 0x12u);
    }
    BOOL v4 = 0;
  }
  double v10 = *(double *)(a2 + 4);
  if (v10 < -90.0 || v10 > 90.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10232F680);
    }
    long long v11 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = *(void *)(a2 + 4);
      int v20 = 68289283;
      int v21 = 0;
      __int16 v22 = 2082;
      long long v23 = "";
      __int16 v24 = 2049;
      uint64_t v25 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location\", \"latitude\":\"%{private}.7f\"}", (uint8_t *)&v20, 0x1Cu);
    }
    BOOL v4 = 0;
  }
  double v13 = *(double *)(a2 + 12);
  if (v13 < -180.0 || v13 > 180.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10232F680);
    }
    long long v14 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = *(void *)(a2 + 12);
      int v20 = 68289283;
      int v21 = 0;
      __int16 v22 = 2082;
      long long v23 = "";
      __int16 v24 = 2049;
      uint64_t v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location\", \"longitude\":\"%{private}.7f\"}", (uint8_t *)&v20, 0x1Cu);
    }
    BOOL v4 = 0;
  }
  if (*(double *)(a2 + 36) > 0.0)
  {
    double v16 = *(double *)(a2 + 28);
    if (v16 < -450.0 || v16 > 8850.0)
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10232F680);
      }
      long long v17 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = *(void *)(a2 + 28);
        int v20 = 68289283;
        int v21 = 0;
        __int16 v22 = 2082;
        long long v23 = "";
        __int16 v24 = 2049;
        uint64_t v25 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefPosMaintenance,Warning invalid assistance location\", \"altitude\":\"%{private}.2f\"}", (uint8_t *)&v20, 0x1Cu);
      }
      return 0;
    }
  }
  return v4;
}

uint64_t sub_10019FFEC(uint64_t a1, uint64_t a2)
{
  memcpy((void *)a1, (const void *)a2, 0x201uLL);
  uint64_t v4 = *(void *)(a2 + 520);
  uint64_t v5 = *(void *)(a2 + 528);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 520) = v4;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 528);
  *(void *)(a1 + 528) = v5;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  long long v7 = *(_OWORD *)(a2 + 536);
  long long v8 = *(_OWORD *)(a2 + 568);
  *(_OWORD *)(a1 + 552) = *(_OWORD *)(a2 + 552);
  *(_OWORD *)(a1 + 568) = v8;
  *(_OWORD *)(a1 + 536) = v7;
  long long v9 = *(_OWORD *)(a2 + 584);
  long long v10 = *(_OWORD *)(a2 + 600);
  long long v11 = *(_OWORD *)(a2 + 616);
  *(void *)(a1 + 629) = *(void *)(a2 + 629);
  *(_OWORD *)(a1 + 600) = v10;
  *(_OWORD *)(a1 + 616) = v11;
  *(_OWORD *)(a1 + 584) = v9;
  return a1;
}

void sub_1001A0078()
{
}

void sub_1001A0134(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_1001A0170(uint64_t a1)
{
  sub_10000DD4C(a1);

  operator delete();
}

void sub_1001A01AC(uint64_t a1)
{
  sub_10004659C(a1);

  operator delete();
}

id sub_1001A01E8(uint64_t a1, int a2)
{
  uint64_t v3 = sub_100129E3C(a1);
  uint64_t v5 = *(void *)(*(void *)v3 + 8);
  uint64_t v4 = *(void **)(*(void *)v3 + 16);
  if (a2)
  {
    return [v4 register:v5 forNotification:34 registrationInfo:0];
  }
  else
  {
    return [v4 unregister:v5 forNotification:34];
  }
}

id sub_1001A024C(uint64_t a1, int a2)
{
  uint64_t v3 = sub_100129E3C(a1);
  uint64_t v5 = *(void *)(*(void *)v3 + 8);
  uint64_t v4 = *(void **)(*(void *)v3 + 16);
  if (a2)
  {
    return [v4 register:v5 forNotification:35 registrationInfo:0];
  }
  else
  {
    return [v4 unregister:v5 forNotification:35];
  }
}

uint64_t sub_1001A02B0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (uint64_t *)(a1 + 96);
  uint64_t v4 = *(void *)(a1 + 96);
  if (a2)
  {
    if (v4) {
      sub_101AA8680((void *)(a1 + 96));
    }
  }
  else if (!v4)
  {
    return 0;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_1023192F0);
  }
  uint64_t v6 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 96);
    v9[0] = 68290562;
    v9[1] = 0;
    __int16 v10 = 2082;
    long long v11 = "";
    __int16 v12 = 2082;
    double v13 = "state_transition";
    __int16 v14 = 2082;
    uint64_t v15 = "DaemonClient";
    __int16 v16 = 2050;
    uint64_t v17 = a1;
    __int16 v18 = 2082;
    long long v19 = "visibilityAssertion";
    __int16 v20 = 2050;
    uint64_t v21 = v7;
    __int16 v22 = 2050;
    uint64_t v23 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"state transition\", \"event\":%{public, location:escape_only}s, \"state\":%{public, location:escape_only}s, \"id\":\"%{public}p\", \"property\":%{public, location:escape_only}s, \"old\":\"%{public}p\", \"new\":\"%{public}p\"}", (uint8_t *)v9, 0x4Eu);
  }
  uint64_t result = *v5;
  *uint64_t v5 = a2;
  return result;
}

uint64_t sub_1001A0414(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 72);
  if (!result)
  {
    id v3 = [[[*(id *)(a1 + 8) vendor] proxyForService:@"CLStreamingAwareLocationProvider"];
    *(void *)(a1 + 72) = v3;
    [v3 registerDelegate:*(void *)(a1 + 48) inSilo:objc_msgSend(*(id *)(a1 + 8), "silo")];
    return *(void *)(a1 + 72);
  }
  return result;
}

uint64_t sub_1001A0484(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 168);
  if (!result)
  {
    id v3 = [[objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLClientManager"];
    *(void *)(a1 + 168) = v3;
    [v3 registerDelegate:*(void *)(a1 + 48) inSilo:[*(id *)(a1 + 8) silo]];
    return *(void *)(a1 + 168);
  }
  return result;
}

BOOL sub_1001A04F4(uint64_t a1)
{
  signed int v2 = [*(id *)(a1 + 16) inUseLevel];
  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_1023192B0);
  }
  id v3 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 24);
    int v5 = *(_DWORD *)(a1 + 44);
    v7[0] = 68289794;
    v7[1] = 0;
    __int16 v8 = 2082;
    long long v9 = "";
    __int16 v10 = 2114;
    uint64_t v11 = v4;
    __int16 v12 = 1026;
    int v13 = v5;
    __int16 v14 = 1026;
    BOOL v15 = v2 < 5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"canBePaused()\", \"Client\":%{public, location:escape_only}@, \"pid\":%{public}d, \"flag\":%{public}hhd}", (uint8_t *)v7, 0x28u);
  }
  return v2 < 5;
}

BOOL sub_1001A061C(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a1 + 52) <= 0.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102307AD8);
    }
    uint64_t v4 = qword_1024193D8;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
      return 1;
    }
    int v10 = 68289026;
    int v11 = 0;
    __int16 v12 = 2082;
    int v13 = "";
    int v5 = "{\"msg%{public}.0s\":\"#GnssRefLocationCache,isNotRepeatedLocationAssistance,no cached location\"}";
    goto LABEL_14;
  }
  double v2 = *(double *)(a2 + 76) - *(double *)(a1 + 108);
  if (v2 < 0.0 || v2 > 6.0)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_102307AD8);
    }
    uint64_t v4 = qword_1024193D8;
    if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG)) {
      return 1;
    }
    int v10 = 68289026;
    int v11 = 0;
    __int16 v12 = 2082;
    int v13 = "";
    int v5 = "{\"msg%{public}.0s\":\"#GnssRefLocationCache,isNotRepeatedLocationAssistance,new assistance not recent\"}";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, v5, (uint8_t *)&v10, 0x12u);
    return 1;
  }
  if (*(double *)(a2 + 36) > 0.0)
  {
    double v7 = *(double *)(a1 + 68);
    if (v7 < 0.0 || v7 > 0.0 && vabdd_f64(*(double *)(a2 + 28), *(double *)(a1 + 60)) > 1.0) {
      return 1;
    }
  }
  if (*(_DWORD *)(a2 + 84) > *(_DWORD *)(a1 + 116)) {
    return 1;
  }
  sub_1000F1268((double *)(a1 + 1000), a2, a1 + 32);
  if (v8 > 1.0) {
    return 1;
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_102307AD8);
  }
  long long v9 = qword_1024193D8;
  BOOL result = os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    int v10 = 68289026;
    int v11 = 0;
    __int16 v12 = 2082;
    int v13 = "";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#GnssRefLocationCache,isNotRepeatedLocationAssistance,same location\"}", (uint8_t *)&v10, 0x12u);
    return 0;
  }
  return result;
}

__n128 sub_1001A0884@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 2864);
  long long v3 = *(_OWORD *)(a1 + 2896);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 2880);
  *(_OWORD *)(a2 + 112) = v3;
  *(void *)(a2 + 128) = *(void *)(a1 + 2912);
  long long v4 = *(_OWORD *)(a1 + 2800);
  long long v5 = *(_OWORD *)(a1 + 2832);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 2816);
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 2848);
  *(_OWORD *)(a2 + 80) = v2;
  __n128 result = *(__n128 *)(a1 + 2784);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

__n128 sub_1001A08C0@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 128) = *(void *)(a1 + 2776);
  long long v2 = *(_OWORD *)(a1 + 2760);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 2744);
  *(_OWORD *)(a2 + 112) = v2;
  long long v3 = *(_OWORD *)(a1 + 2696);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 2680);
  *(_OWORD *)(a2 + 48) = v3;
  long long v4 = *(_OWORD *)(a1 + 2728);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 2712);
  *(_OWORD *)(a2 + 80) = v4;
  __n128 result = *(__n128 *)(a1 + 2664);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 2648);
  *(__n128 *)(a2 + 16) = result;
  return result;
}

BOOL sub_1001A08F0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 2488) > 0;
}

void sub_1001A0900(uint64_t a1, uint64_t a2)
{
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_1022F66B8);
  }
  long long v4 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a1 + 2632);
    *(_DWORD *)uint64_t buf = 136380931;
    uint64_t v9 = a2;
    __int16 v10 = 2049;
    uint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Fence: releaseActivityAlarm, %{private}s, %{private}p", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F66B8);
    }
    double v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLFenceMonitorNotifier::releaseActivityAlarm(const char *)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  uint64_t v6 = *(void **)(a1 + 2632);
  if (v6)
  {
    [v6 invalidate];

    *(void *)(a1 + 2632) = 0;
  }
}

BOOL sub_1001A0AE8(uint64_t a1)
{
  return *(void *)(a1 + 2248) != 0;
}

BOOL sub_1001A0AF8()
{
  uint64_t v0 = sub_1000A6958();
  id v1 = off_102474608;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  return sub_10016332C(v0, v1, &Current);
}

void *sub_1001A0B44(void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = a2;
  a1[2] = a3;
  *a1 = off_102301120;
  a1[3] = objc_alloc_init(CLDaemonInUseAssertionAdapter);
  a1[4] = 0;
  return a1;
}

void sub_1001A0B98(_Unwind_Exception *a1)
{
  sub_100426880(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1001A0BB0(float64_t *a1, double *a2, _DWORD *a3)
{
  if (*a2 > -70.312522 || *a2 < -123.496142 || (v3.f64[0] = *a1, *a1 < 25.127422) || v3.f64[0] > 48.309232)
  {
    int v10 = 0;
    BOOL v5 = 0;
    if (!a3) {
      return v5;
    }
    goto LABEL_13;
  }
  unint64_t v4 = 0;
  v3.f64[1] = *a2;
  BOOL v5 = 1;
  while (1)
  {
    float32x4_t v6 = xmmword_102476AAC[v4];
    float64x2_t v7 = vcvtq_f64_f32(*(float32x2_t *)v6.f32);
    int64x2_t v8 = (int64x2_t)vmvnq_s8((int8x16_t)vcgeq_f64(vcvt_hight_f64_f32(v6), v3));
    int32x4_t v9 = (int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f64(v3, v7));
    *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)v9);
    if ((vmaxv_u16((uint16x4_t)vext_s8((int8x8_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v8.i8, v8)), (int8x8_t)vmovn_s32(v9), 4uLL)) & 1) == 0)break; {
    BOOL v5 = v4++ < 0x31;
    }
    if (v4 == 50) {
      return 0;
    }
  }
  if (a3)
  {
    int v10 = v4 + 1;
LABEL_13:
    *a3 = v10;
  }
  return v5;
}

uint64_t sub_1001A0C8C(uint64_t a1, uint64_t a2)
{
  return sub_1001A2E18(*(void *)(a1 + 8), a2, (long long *)(a1 + 176));
}

float sub_1001A0C9C(uint64_t a1, uint64_t a2, char a3, double a4)
{
  float v30 = 0.0;
  double v5 = *(double *)a2;
  if (*(double *)a2 <= a4)
  {
    float32x4_t v6 = (double *)(a1 + 8);
    double v7 = *(double *)(a1 + 8);
    if (v5 > v7)
    {
      if ((a3 & 1) == 0)
      {
        double v9 = v5 - v7;
        double v10 = fmin(v9, 60.0);
        unsigned int v11 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 16);
        if (v11 >= 0x12C) {
          int v12 = 300;
        }
        else {
          int v12 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 16);
        }
        if (v9 > 180.0) {
          unsigned int v11 = v12;
        }
        if (v10 > 0.0)
        {
          float v13 = (float)v11 / 100.0;
          float v14 = (float)(v13 * 23.94) / v10;
          float v30 = v14;
          if (qword_102418FF0 != -1) {
            dispatch_once(&qword_102418FF0, &stru_10231CFF0);
          }
          BOOL v15 = qword_102418FF8;
          if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = *(void *)(a1 + 64);
            *(_DWORD *)uint64_t buf = 134218752;
            double v40 = v13;
            __int16 v41 = 2048;
            double v42 = v10;
            __int16 v43 = 2048;
            double v44 = v14;
            __int16 v45 = 2048;
            uint64_t v46 = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Climbing,deltaElevation,%f,ascentDuration,%f,climbingMets,%f,len,%lu", buf, 0x2Au);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102418FF0 != -1) {
              dispatch_once(&qword_102418FF0, &stru_10231CFF0);
            }
            uint64_t v28 = *(void *)(a1 + 64);
            int v31 = 134218752;
            double v32 = v13;
            __int16 v33 = 2048;
            double v34 = v10;
            __int16 v35 = 2048;
            double v36 = v30;
            __int16 v37 = 2048;
            uint64_t v38 = v28;
            long long v29 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "float CLCalorieClimbingModel::estimateClimbingMETs(CFAbsoluteTime, const CLCoarseElevationChangeEntry &, BOOL)", "%s\n", v29);
            if (v29 != (char *)buf) {
              free(v29);
            }
          }
          if (*(double *)a2 - *v6 >= 180.0)
          {
            do
            {
              sub_1000A1600((void *)(a1 + 72), &v30);
              double v10 = v10 + -2.55999994;
            }
            while (v10 > 0.0);
          }
          else
          {
            do
            {
              sub_1000A1600((void *)(a1 + 24), &v30);
              double v10 = v10 + -2.55999994;
            }
            while (v10 > 0.0);
          }
        }
      }
      *(_OWORD *)float32x4_t v6 = *(_OWORD *)a2;
    }
  }
  uint64_t v17 = *(void *)(a1 + 64);
  if (v17)
  {
    float v18 = *(float *)(*(void *)(*(void *)(a1 + 32) + ((*(void *)(a1 + 56) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * (*(void *)(a1 + 56) & 0x3FFLL));
    ++*(void *)(a1 + 56);
    *(void *)(a1 + 64) = v17 - 1;
    sub_1000A1688(a1 + 24, 1);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231CFF0);
    }
    long long v19 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      double v20 = *(double *)(a1 + 64);
      *(_DWORD *)uint64_t buf = 134218240;
      double v40 = v18;
      __int16 v41 = 2048;
      double v42 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Climbing,epochMets,%f,bufferLength,%lu", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231CFF0);
      }
      double v21 = *(double *)(a1 + 64);
      int v31 = 134218240;
      double v32 = v18;
      __int16 v33 = 2048;
      double v34 = v21;
LABEL_38:
      __int16 v26 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "float CLCalorieClimbingModel::estimateClimbingMETs(CFAbsoluteTime, const CLCoarseElevationChangeEntry &, BOOL)", "%s\n", v26);
      if (v26 != (char *)buf) {
        free(v26);
      }
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 112);
    if (!v22) {
      return 0.0;
    }
    float v18 = *(float *)(*(void *)(*(void *)(a1 + 80) + ((*(void *)(a1 + 104) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * (*(void *)(a1 + 104) & 0x3FFLL));
    ++*(void *)(a1 + 104);
    *(void *)(a1 + 112) = v22 - 1;
    sub_1000A1688(a1 + 72, 1);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231CFF0);
    }
    uint64_t v23 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      double v24 = *(double *)(a1 + 112);
      *(_DWORD *)uint64_t buf = 134218240;
      double v40 = v18;
      __int16 v41 = 2048;
      double v42 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Climbing,epochMets,%f,historicalBufferLength,%lu", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231CFF0);
      }
      double v25 = *(double *)(a1 + 112);
      int v31 = 134218240;
      double v32 = v18;
      __int16 v33 = 2048;
      double v34 = v25;
      goto LABEL_38;
    }
  }
  return v18;
}

double sub_1001A12B4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)(a3 + 20) = sub_1001A0C9C(a1, a2 + 1024, *(unsigned char *)(a2 + 352), *(double *)(a2 + 112));
  *(void *)(a3 + 24) = 0;
  *(void *)&double result = 3;
  *(void *)(a3 + 32) = 3;
  return result;
}

void sub_1001A1304(uint64_t a1, double a2, double a3)
{
  BOOL v10 = a3 < 0.372823626;
  double v6 = 1.0;
  if (!v10)
  {
    double v6 = 0.0;
    if (a3 < 0.559235454)
    {
      float v7 = sub_1001BF26C(0.559235454, 0.0, 0.372823626, 1.0, a3);
      double v6 = v7;
    }
  }
  double v8 = (1.0 - v6) * 45.0 + 15.0;
  double v9 = *(double *)(a1 + 16);
  BOOL v10 = v9 + 20.0 > a2 && v9 < a2;
  if (v10) {
    double v8 = 6.66666667;
  }
  *(double *)(a1 + 8) = v8;
}

void sub_1001A13A8(void **a1, uint64_t a2, int a3, unsigned int a4, double a5)
{
  double v9 = *(double *)(a2 + 80);
  double v10 = *(double *)(a2 + 208);
  if (!*((unsigned char *)a1 + 128))
  {
    a1[6] = 0;
    a1[7] = 0;
    *((_DWORD *)a1 + 30) = 1;
    *((double *)a1 + 2) = a5 + 5.0 + 15.0;
    *((double *)a1 + 3) = a5;
    *((double *)a1 + 4) = a5;
    *((double *)a1 + 5) = a5 + -2.56;
    *((unsigned char *)a1 + 128) = 1;
  }
  if (v9 == 0.0)
  {
    int v11 = 0;
    *((_DWORD *)a1 + 30) = 0;
  }
  else
  {
    int v11 = *((_DWORD *)a1 + 30);
    if (v11 > 2)
    {
      if (a5 - *((double *)a1 + 8) <= 7.68)
      {
        int v11 = 1;
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  if (a3 < 1)
  {
LABEL_9:
    int v11 = 0;
    *((_DWORD *)a1 + 30) = 0;
  }
LABEL_10:
  double v12 = *((double *)a1 + 7);
  if (v10 == 0.0 || v12 == 0.0)
  {
    BOOL v13 = v10 != 0.0;
    if (v12 != 0.0) {
      BOOL v13 = 1;
    }
  }
  else
  {
    BOOL v13 = vabdd_f64(1.0 / v10, 1.0 / v12) > 1.0 / v12 * 0.15;
  }
  if (a3 < 1)
  {
    BOOL v16 = !v13;
    if (a3 == -1) {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      *((_DWORD *)a1 + 30) = 1;
      *((double *)a1 + 2) = a5 + 5.0 + 15.0;
      *((double *)a1 + 3) = a5;
    }
    *((double *)a1 + 4) = a5;
  }
  else
  {
    char v15 = v9 > 0.0 && v11 == 0 || v13;
    if (v15)
    {
      *((_DWORD *)a1 + 30) = 1;
      *((double *)a1 + 2) = a5 + 5.0 + 15.0;
      *((double *)a1 + 3) = a5;
    }
  }
  sub_1001A1304((uint64_t)a1, a5, v9);
  double v65 = -1.0;
  unint64_t v66 = 0xBFF0000000000000;
  double v17 = sub_100183BE8((uint64_t)a1);
  if (a3 >= 1 && v9 > 0.0)
  {
    double v18 = v17;
    if (v17 > 0.0)
    {
      double v19 = a5 - sub_100AFEE0C(v9);
      if (v19 >= v18) {
        double v20 = v19;
      }
      else {
        double v20 = v18;
      }
      double v21 = sub_100183C54(a1, a5);
      if (v21 - v20 <= 15.0)
      {
        int v26 = 2;
LABEL_61:
        *((_DWORD *)a1 + 30) = v26;
        int v37 = v26;
        goto LABEL_62;
      }
      double v22 = sub_100AFEE80((uint64_t)a1, *a1, v20, v21);
      unint64_t v66 = *(void *)&v22;
      if (v20 <= v21 + -20.0) {
        double v20 = v21 + -20.0;
      }
      double v23 = sub_100AFEE80((uint64_t)a1, *a1, v20, v21);
      double v64 = v20;
      double v65 = v23;
      double v24 = *((double *)a1 + 5);
      double v25 = *((double *)a1 + 1);
      if (*((int *)a1 + 30) >= 3) {
        double v22 = *((double *)a1 + 11);
      }
      else {
        *((double *)a1 + 14) = v23;
      }
      double v27 = a5 - v24;
      *((_DWORD *)a1 + 30) = 3;
      double v28 = 1.0;
      double v29 = 1.0;
      if (v25 != 0.0) {
        double v29 = 1.0 - exp(-v27 / v25);
      }
      *((double *)a1 + 10) = v29;
      *((double *)a1 + 11) = v22;
      *((_DWORD *)a1 + 18) = 3;
      double v30 = fmax(v25, 15.0);
      int v31 = a1[14];
      if (v30 != 0.0) {
        double v28 = 1.0 - exp(-v27 / v30);
      }
      *((double *)a1 + 13) = v28;
      a1[14] = v31;
      *((_DWORD *)a1 + 24) = 3;
      sub_1000BF84C((uint64_t)(a1 + 9), (double *)&v66);
      sub_1000BF84C((uint64_t)(a1 + 12), &v65);
      double v32 = *((double *)a1 + 11);
      double v33 = *((double *)a1 + 14);
      if (v32 == 0.0 || v33 == 0.0)
      {
        if (v32 == 0.0 && v33 == 0.0) {
          goto LABEL_57;
        }
      }
      else if (vabdd_f64(1.0 / v33, 1.0 / v32) <= 1.0 / v32 * 0.15)
      {
LABEL_57:
        *((double *)a1 + 8) = v21;
        goto LABEL_58;
      }
      double v34 = vabdd_f64(v32, v9);
      if (vabdd_f64(v33, v9) < v34 && vabdd_f64(v65, v9) < v34)
      {
        double v35 = *((double *)a1 + 1);
        double v36 = 1.0;
        if (v35 != 0.0) {
          double v36 = 1.0 - exp(-v27 / v35);
        }
        *((double *)a1 + 10) = v36;
        *((double *)a1 + 11) = v33;
        *((_DWORD *)a1 + 18) = 3;
        *((_DWORD *)a1 + 30) = 4;
        *((double *)a1 + 2) = a5;
        *((double *)a1 + 3) = v64;
      }
      goto LABEL_57;
    }
  }
LABEL_58:
  int v37 = *((_DWORD *)a1 + 30);
  if (v37 >= 3)
  {
    int v26 = 0;
    double v38 = *((double *)a1 + 11);
    if (v38 > 1.6777 || v38 < 0.0909) {
      goto LABEL_61;
    }
  }
LABEL_62:
  *((_DWORD *)a1 + 31) = 0;
  double v39 = v9;
  if (v9 > 0.0)
  {
    double v39 = v9;
    if (a3 == 2)
    {
      double v39 = v9;
      if (v37 >= 3)
      {
        *((_DWORD *)a1 + 31) = 1;
        double v39 = *((double *)a1 + 11);
      }
    }
  }
  double v40 = sub_100183B7C((uint64_t)a1);
  double v41 = v40;
  if (a5 + -120.0 >= v40) {
    double v42 = a5 + -120.0;
  }
  else {
    double v42 = v40;
  }
  double v43 = sub_100183C54(a1, a5);
  BOOL v44 = 0;
  double v45 = 0.0;
  if (a3 == 2 && v41 > 0.0 && v43 - v42 > 15.0)
  {
    double v45 = sub_100AFEE80((uint64_t)a1, *a1, v42, v43);
    BOOL v44 = v45 < 1.6777 && v45 > 0.0909;
  }
  if (qword_102419030 != -1) {
    dispatch_once(&qword_102419030, &stru_1022DE100);
  }
  uint64_t v46 = qword_102419038;
  if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEBUG))
  {
    int v47 = *((_DWORD *)a1 + 30);
    if (v47 < 3)
    {
      uint64_t v48 = 0;
      uint64_t v49 = 0;
    }
    else
    {
      uint64_t v48 = a1[11];
      uint64_t v49 = a1[14];
    }
    double v50 = (float)v47;
    double v51 = (float)*((int *)a1 + 31);
    float v52 = v45;
    __int16 v54 = a1[3];
    int v53 = a1[4];
    *(_DWORD *)uint64_t buf = 136323074;
    double v132 = "PaceFusion_Epoch_Time";
    __int16 v133 = 2048;
    double v134 = a5;
    __int16 v135 = 2080;
    uint64_t v136 = "PaceFusion_Epoch_PedometerPace";
    __int16 v137 = 2048;
    double v138 = v9;
    __int16 v139 = 2080;
    int v140 = "PaceFusion_Epoch_PedometerPaceUncalibrated";
    __int16 v141 = 2048;
    double v142 = v10;
    __int16 v143 = 2080;
    __int16 v144 = "PaceFusion_Epoch_SmoothOdometerPace";
    __int16 v145 = 2048;
    __int16 v146 = v48;
    __int16 v147 = 2080;
    int v148 = "PaceFusion_Epoch_SmoothShortOdometerPace";
    __int16 v149 = 2048;
    uint64_t v150 = v49;
    __int16 v151 = 2080;
    uint64_t v152 = "PaceFusion_Epoch_LongMeanOdometerPace";
    __int16 v153 = 2048;
    unint64_t v154 = v66;
    __int16 v155 = 2080;
    int v156 = "PaceFusion_Epoch_ShortMeanOdometerPace";
    __int16 v157 = 2048;
    double v158 = v65;
    __int16 v159 = 2080;
    double v160 = "PaceFusion_Epoch_PaceResetTime";
    __int16 v161 = 2048;
    float64x2_t v162 = v54;
    __int16 v163 = 2080;
    double v164 = "PaceFusion_Epoch_FinalFusedPace";
    __int16 v165 = 2048;
    double v166 = v39;
    __int16 v167 = 2080;
    float64x2_t v168 = "PaceFusion_Epoch_OdometerPaceQuality";
    __int16 v169 = 2048;
    double v170 = (float)a3;
    __int16 v171 = 2080;
    int v172 = "PaceFusion_Epoch_MeanPaceState";
    __int16 v173 = 2048;
    double v174 = v50;
    __int16 v175 = 2080;
    double v176 = "PaceFusion_Epoch_PaceFusionOutput";
    __int16 v177 = 2048;
    double v178 = v51;
    __int16 v179 = 2080;
    int v180 = "PaceFusion_Epoch_DoRequestPureGpsOdometerPace";
    __int16 v181 = 2048;
    double v182 = (double)a4;
    __int16 v183 = 2080;
    long long v184 = "PaceFusion_Epoch_IsPureGpsOdometerPaceAvailable";
    __int16 v185 = 2048;
    double v186 = (double)v44;
    __int16 v187 = 2080;
    __int16 v188 = "PaceFusion_Epoch_PureGpsOdometerPace";
    __int16 v189 = 2048;
    double v190 = v52;
    __int16 v191 = 2080;
    __int16 v192 = "PaceFusion_Epoch_PureGpsOdometerPaceResetTime";
    __int16 v193 = 2048;
    __int16 v194 = v53;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEBUG, "%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f", buf, 0x142u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_1022DE100);
    }
    int v55 = *((_DWORD *)a1 + 30);
    if (v55 < 3)
    {
      __int16 v56 = 0;
      uint64_t v57 = 0;
    }
    else
    {
      __int16 v56 = a1[11];
      uint64_t v57 = a1[14];
    }
    double v58 = (float)v55;
    double v59 = (float)*((int *)a1 + 31);
    float v60 = v45;
    __int16 v62 = a1[3];
    double v61 = a1[4];
    int v67 = 136323074;
    __int16 v68 = "PaceFusion_Epoch_Time";
    __int16 v69 = 2048;
    double v70 = a5;
    __int16 v71 = 2080;
    double v72 = "PaceFusion_Epoch_PedometerPace";
    __int16 v73 = 2048;
    double v74 = v9;
    __int16 v75 = 2080;
    double v76 = "PaceFusion_Epoch_PedometerPaceUncalibrated";
    __int16 v77 = 2048;
    double v78 = v10;
    __int16 v79 = 2080;
    unint64_t v80 = "PaceFusion_Epoch_SmoothOdometerPace";
    __int16 v81 = 2048;
    int v82 = v56;
    __int16 v83 = 2080;
    unint64_t v84 = "PaceFusion_Epoch_SmoothShortOdometerPace";
    __int16 v85 = 2048;
    uint64_t v86 = v57;
    __int16 v87 = 2080;
    uint64_t v88 = "PaceFusion_Epoch_LongMeanOdometerPace";
    __int16 v89 = 2048;
    unint64_t v90 = v66;
    __int16 v91 = 2080;
    long long v92 = "PaceFusion_Epoch_ShortMeanOdometerPace";
    __int16 v93 = 2048;
    double v94 = v65;
    __int16 v95 = 2080;
    unint64_t v96 = "PaceFusion_Epoch_PaceResetTime";
    __int16 v97 = 2048;
    uint64_t v98 = v62;
    __int16 v99 = 2080;
    long long v100 = "PaceFusion_Epoch_FinalFusedPace";
    __int16 v101 = 2048;
    double v102 = v39;
    __int16 v103 = 2080;
    long long v104 = "PaceFusion_Epoch_OdometerPaceQuality";
    __int16 v105 = 2048;
    double v106 = (float)a3;
    __int16 v107 = 2080;
    long long v108 = "PaceFusion_Epoch_MeanPaceState";
    __int16 v109 = 2048;
    double v110 = v58;
    __int16 v111 = 2080;
    uint64_t v112 = "PaceFusion_Epoch_PaceFusionOutput";
    __int16 v113 = 2048;
    double v114 = v59;
    __int16 v115 = 2080;
    unint64_t v116 = "PaceFusion_Epoch_DoRequestPureGpsOdometerPace";
    __int16 v117 = 2048;
    double v118 = (double)a4;
    __int16 v119 = 2080;
    long long v120 = "PaceFusion_Epoch_IsPureGpsOdometerPaceAvailable";
    __int16 v121 = 2048;
    double v122 = (double)v44;
    __int16 v123 = 2080;
    uint64_t v124 = "PaceFusion_Epoch_PureGpsOdometerPace";
    __int16 v125 = 2048;
    double v126 = v60;
    __int16 v127 = 2080;
    double v128 = "PaceFusion_Epoch_PureGpsOdometerPaceResetTime";
    __int16 v129 = 2048;
    unint64_t v130 = v61;
    double v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "double CLPedometerPaceFusion::computeFusedPace(CFAbsoluteTime, const CLExtendedStepCountEntry &, CLPedometer::FusionOdometerQuality, BOOL)", "%s\n", v63);
    if (v63 != (char *)buf) {
      free(v63);
    }
  }
  *((double *)a1 + 6) = v9;
  *((double *)a1 + 7) = v10;
  *((double *)a1 + 5) = a5;
}

void sub_1001A1DB4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];

  sub_100039318(a4, v7, a2, a3);
}

uint64_t sub_1001A1E18(uint64_t a1, uint64_t a2)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a2 + 32), "silo") assertInside];

  return sub_1000546AC(a2, a1, 0);
}

void sub_1001A1E70(uint64_t a1, uint64_t a2, int *a3, const void *a4)
{
  if (*a3 == 1)
  {
    unint64_t v4 = (void *)(a1 + 4592);
    sub_100097DD8(v4, a4);
  }
  else
  {
    if (qword_102418FD0 != -1) {
      dispatch_once(&qword_102418FD0, &stru_1022C2688);
    }
    double v6 = qword_102418FD8;
    if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_ERROR))
    {
      int v7 = *a3;
      *(_DWORD *)uint64_t buf = 67109120;
      int v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "MotionStateMediator received unhandled step count notification, %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_1022C2688);
      }
      double v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMotionStateMediator::onStepCountNotification(int, const CLStepCountNotifier_Type::Notification &, const CLStepCountNotifier_Type::NotificationData &)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
}

__n128 sub_1001A207C(uint64_t a1)
{
  if (arc4random_uniform(0x64u) == 1)
  {
    v9[0] = @"incomingLocationType";
    v10[0] = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 216)];
    v9[1] = @"incomingLocationSignalEnvironmentType";
    v10[1] = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 220)];
    _DWORD v9[2] = @"incomingLocationHorizontalAccuracy";
    v10[2] = +[NSNumber numberWithDouble:*(double *)(a1 + 224)];
    void v9[3] = @"loiLocationHorizontalAccuracy";
    v10[3] = +[NSNumber numberWithDouble:*(double *)(a1 + 232)];
    v9[4] = @"incomingLocationDistanceToLoi";
    v10[4] = +[NSNumber numberWithDouble:*(double *)(a1 + 240)];
    v9[5] = @"isValidLoi";
    v10[5] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 248)];
    v9[6] = @"isLoiHighAccuracy";
    v10[6] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 252)];
    v9[7] = @"isIncomingLocationValidLocationType";
    v10[7] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 256)];
    v9[8] = @"isIncomingLocationGreaterUncertainty";
    void v10[8] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 260)];
    v9[9] = @"isDistanceLessThanThreshold";
    v10[9] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 264)];
    v9[10] = @"isHorizontalAccuracyOverlapping";
    v10[10] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 268)];
    v9[11] = @"isWifiAssociated";
    v10[11] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 272)];
    v9[12] = @"isOverriding";
    v10[12] = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 276)];
    +[NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:13];
    AnalyticsSendEvent();
  }
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 220) = 0;
  uint64_t v2 = a1 + 216;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(v2 + 8) = _Q0;
  *(void *)(v2 + 24) = 0xBFF0000000000000;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  *(__n128 *)(v2 + 32) = result;
  *(__n128 *)(v2 + 48) = result;
  return result;
}

BOOL sub_1001A229C(uint64_t a1, uint64_t a2)
{
  if (!sub_1000E6DB4(a1)
    || ((double v4 = *(double *)(a1 + 20), *(uint64_t *)&v4 > -1)
      ? (BOOL v5 = ((*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
      : (BOOL v5 = 1),
        v5 ? (BOOL v6 = (unint64_t)(*(void *)&v4 - 1) >= 0xFFFFFFFFFFFFFLL) : (BOOL v6 = 0),
        v6))
  {
    if (qword_1024194D0 != -1) {
      dispatch_once(&qword_1024194D0, &stru_1022D6668);
    }
    double v9 = qword_1024194D8;
    if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#loiOverride no valid current location.", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194D0 != -1) {
        dispatch_once(&qword_1024194D0, &stru_1022D6668);
      }
      BOOL v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
    BOOL result = 0;
    *(_DWORD *)(a1 + 248) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 248) = 1;
    *(double *)(a1 + 232) = v4;
    unsigned int v7 = *(_DWORD *)(a2 + 96);
    if (v7 <= 8 && ((1 << v7) & 0x1D0) != 0)
    {
      *(_DWORD *)(a1 + 256) = 1;
      if (*(_DWORD *)(a1 + 156) == 2)
      {
        *(_DWORD *)(a1 + 252) = 1;
        if (*(double *)(a2 + 20) <= v4)
        {
          if (qword_1024194D0 != -1) {
            dispatch_once(&qword_1024194D0, &stru_1022D6668);
          }
          int v11 = qword_1024194D8;
          if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#loiOverride the spread of the LOI is larger than the location fix.", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024194D0 != -1) {
              dispatch_once(&qword_1024194D0, &stru_1022D6668);
            }
            double v18 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v18);
            if (v18 != (char *)buf) {
              free(v18);
            }
          }
          BOOL result = 0;
          *(_DWORD *)(a1 + 260) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 260) = 1;
          if (sub_10099C474(a1, a1, a2))
          {
            if (*(double *)(a1 + 208) + 600.0 <= *(double *)(a1 + 76) || *(unsigned char *)(a1 + 200))
            {
              BOOL result = 1;
              *(_DWORD *)(a1 + 272) = 1;
            }
            else
            {
              if (qword_1024194D0 != -1) {
                dispatch_once(&qword_1024194D0, &stru_1022D6668);
              }
              char v15 = qword_1024194D8;
              if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#loiOverride WiFi is not associated to overide Wifi1 locations.", buf, 2u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1024194D0 != -1) {
                  dispatch_once(&qword_1024194D0, &stru_1022D6668);
                }
                double v20 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v20);
                if (v20 != (char *)buf) {
                  free(v20);
                }
              }
              BOOL result = 0;
              *(_DWORD *)(a1 + 272) = 0;
            }
          }
          else
          {
            if (qword_1024194D0 != -1) {
              dispatch_once(&qword_1024194D0, &stru_1022D6668);
            }
            BOOL v13 = qword_1024194D8;
            if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#loiOverride locations are not sufficiently proximate.", buf, 2u);
            }
            BOOL result = sub_10013D1A0(115, 2);
            if (result)
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024194D0 != -1) {
                dispatch_once(&qword_1024194D0, &stru_1022D6668);
              }
              float v14 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v14);
              if (v14 != (char *)buf) {
                free(v14);
              }
              return 0;
            }
          }
        }
      }
      else
      {
        if (qword_1024194D0 != -1) {
          dispatch_once(&qword_1024194D0, &stru_1022D6668);
        }
        int v10 = qword_1024194D8;
        if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#loiOverride location source accuracy is not High to overide location.", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024194D0 != -1) {
            dispatch_once(&qword_1024194D0, &stru_1022D6668);
          }
          double v17 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v17);
          if (v17 != (char *)buf) {
            free(v17);
          }
        }
        BOOL result = 0;
        *(_DWORD *)(a1 + 252) = 0;
      }
    }
    else
    {
      if (qword_1024194D0 != -1) {
        dispatch_once(&qword_1024194D0, &stru_1022D6668);
      }
      double v12 = qword_1024194D8;
      if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#loiOverride location is not Wifi1 or Cell.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024194D0 != -1) {
          dispatch_once(&qword_1024194D0, &stru_1022D6668);
        }
        double v19 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)", "%s\n", v19);
        if (v19 != (char *)buf) {
          free(v19);
        }
      }
      BOOL result = 0;
      *(_DWORD *)(a1 + 256) = 0;
    }
  }
  return result;
}

__n128 sub_1001A2B30@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a2 + 140);
  *(void *)(a1 + 224) = *(void *)(a2 + 20);
  if (sub_1001A229C(a1, a2))
  {
    if (qword_1024194D0 != -1) {
      dispatch_once(&qword_1024194D0, &stru_1022D6668);
    }
    BOOL v6 = qword_1024194D8;
    if (os_log_type_enabled((os_log_t)qword_1024194D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#loiOverride using Loi Location", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194D0 != -1) {
        dispatch_once(&qword_1024194D0, &stru_1022D6668);
      }
      double v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "const CLDaemonLocation CLLoiLocationOverride::getBestLocation(const CLDaemonLocation &)", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
    *(_DWORD *)(a1 + 276) = 1;
    sub_1001A207C(a1);
    sub_10099BC9C(a1, a2, (uint64_t)a3);
  }
  else
  {
    *(_DWORD *)(a1 + 276) = 0;
    sub_1001A207C(a1);
    long long v8 = *(_OWORD *)(a2 + 112);
    a3[6] = *(_OWORD *)(a2 + 96);
    a3[7] = v8;
    a3[8] = *(_OWORD *)(a2 + 128);
    *(_OWORD *)((char *)a3 + 140) = *(_OWORD *)(a2 + 140);
    long long v9 = *(_OWORD *)(a2 + 48);
    a3[2] = *(_OWORD *)(a2 + 32);
    a3[3] = v9;
    long long v10 = *(_OWORD *)(a2 + 80);
    a3[4] = *(_OWORD *)(a2 + 64);
    a3[5] = v10;
    __n128 result = *(__n128 *)a2;
    long long v11 = *(_OWORD *)(a2 + 16);
    *a3 = *(_OWORD *)a2;
    a3[1] = v11;
  }
  return result;
}

double sub_1001A2D68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 104))(a1, a3);
  double result = *(double *)(a1 + 536);
  if (result == 1.79769313e308 || *(double *)(a2 + 24) < result)
  {
    long long v9 = (_OWORD *)(a1 + 512);
    if (v6 == 1)
    {
      double result = 0.0;
      *(_OWORD *)(a1 + 544) = 0u;
      *(_OWORD *)(a1 + 560) = 0u;
      *long long v9 = 0u;
      *(_OWORD *)(a1 + 528) = 0u;
    }
    else if (!v6)
    {
      double result = *(double *)(a3 + 40);
      *(void *)(a1 + 544) = 0;
      *long long v9 = 0u;
      *(_OWORD *)(a1 + 528) = 0u;
      *(double *)(a1 + 552) = result;
      *(void *)(a1 + 568) = 0;
      *(void *)(a1 + 560) = 0;
    }
  }
  return result;
}

uint64_t sub_1001A2E18(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  long long v6 = a3[1];
  long long v7 = a3[2];
  *(_OWORD *)(a1 + 92) = *(long long *)((char *)a3 + 44);
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 48) = v5;
  uint64_t result = sub_100055F90(a1, a2);
  if (result)
  {
    sub_100A0F90C(a1, *(int *)(a2 + 1056));
    sub_100A0F38C((int *)a1, a2, (uint64_t)v9);
    return (*(uint64_t (**)(void, unsigned char *))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v9);
  }
  return result;
}

void sub_1001A2EAC(uint64_t a1, void *a2, void *a3)
{
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_1022D5420);
  }
  long long v6 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 138478083;
    *(void *)double v22 = a2;
    *(_WORD *)&v22[8] = 2113;
    *(void *)&v22[10] = [a3 description];
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#ctcl,#ci,onServingCellChanged context %{private}@, info %{private}@", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
    }
    int v17 = 138478083;
    double v18 = a2;
    __int16 v19 = 2113;
    id v20 = [a3 description];
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLCoreTelephonyClient::onServingCellChanged(CTXPCServiceSubscriptionContext *, NSDictionary *)", "%s\n", v13);
    if (v13 != (char *)buf) {
      free(v13);
    }
  }
  int v7 = sub_100090424((uint64_t)[a2 slotID]);
  if (!v7)
  {
    long long v8 = &off_1022BAEA0;
    if (a3) {
      goto LABEL_9;
    }
LABEL_11:
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
    }
    long long v10 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)double v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&void v22[6] = "";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#ctcl,#cterror,#ci,onServingCellChanged nil info dict!\"}", buf, 0x12u);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_1022D5420);
      }
    }
    long long v11 = qword_1024193D8;
    if (os_signpost_enabled((os_log_t)qword_1024193D8))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)double v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&void v22[6] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#ctcl,#cterror,#ci,onServingCellChanged nil info dict!", "{\"msg%{public}.0s\":\"#ctcl,#cterror,#ci,onServingCellChanged nil info dict!\"}", buf, 0x12u);
    }
    return;
  }
  if (v7 == 1)
  {
    long long v8 = &off_1022BAEA8;
    if (a3)
    {
LABEL_9:
      long long v9 = *(void **)(a1 + 112);
      char v15 = *v8;
      BOOL v16 = a3;
      [v9 sendNotificationToClients:@"kServingCellChangedNotification" notificationData:[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v16, &v15, 1)];
      return;
    }
    goto LABEL_11;
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_1022D5420);
  }
  double v12 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#ctcl,#cterror,#ci,onServingCellChanged invalid slotdId", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_1022D5420);
    }
    LOWORD(v17) = 0;
    float v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "void CLCoreTelephonyClient::onServingCellChanged(CTXPCServiceSubscriptionContext *, NSDictionary *)", "%s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
}

void sub_1001A3344(uint64_t *a1, double *a2, uint64_t a3, double *a4, void *a5)
{
  if (*a1)
  {
    if (*((double *)a1 + 267) <= *((double *)a1 + 253)) {
      double v9 = *((double *)a1 + 253);
    }
    else {
      double v9 = *((double *)a1 + 267);
    }
    double v10 = sub_1000A4CE8(*a1, a2);
    *a4 = sub_1000A4F34(v10, v9, -1.0);
    uint64_t v11 = *a1;
    sub_10019C4CC(v11, a5, a3);
  }
  else
  {
    *a4 = -1.0;
    *a5 = 0xBFF0000000000000;
  }
}

uint64_t sub_1001A33FC(uint64_t a1, double *a2, uint64_t a3, uint64_t a4, char a5, double *a6, double *a7)
{
  char v14 = a5;
  sub_1001A3344((uint64_t *)a1, a2, a3, a6, a7);
  uint64_t result = 0;
  uint64_t v12 = 236;
  if (!*(unsigned char *)(a1 + 237)) {
    uint64_t v12 = 360;
  }
  if (*(unsigned char *)(a1 + v12))
  {
    if (*a6 > 300.0 && *a7 > 5000.0)
    {
      uint64_t result = *(void *)a1;
      if (*(void *)a1)
      {
        uint64_t result = sub_10019CD88(result, a4, &v14);
        if (result)
        {
          if (*(double *)(a1 + 2088) <= 0.0)
          {
            return 0;
          }
          else
          {
            uint64_t result = sub_10187C33C(*(void *)a1, (double *)(a1 + 1576));
            if (result)
            {
              unsigned int v13 = *(_DWORD *)(a1 + 232);
              return v13 < sub_10191F218(a1);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1001A34E0(uint64_t result, int a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (!v3) {
    return result;
  }
  uint64_t v6 = result;
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  while (1)
  {
    double v9 = (unsigned __int8 *)(*(void *)v6 + v7);
    if (*v9 != *(unsigned __int8 *)(v6 + 16) || v9[1] != a2) {
      goto LABEL_7;
    }
    int v10 = v9[2];
    uint64_t v11 = (uint64_t (*)(uint64_t, uint64_t))*((void *)v9 + 2);
    uint64_t result = (*((uint64_t (**)(uint64_t, uint64_t))v9 + 1))(v6, a3);
    if (result) {
      break;
    }
    unint64_t v3 = *(void *)(v6 + 8);
LABEL_7:
    ++v8;
    v7 += 24;
    if (v3 <= v8) {
      return result;
    }
  }
  if (*(unsigned __int8 *)(v6 + 17) <= 1u && *(unsigned __int8 *)(v6 + 16) != v10)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_102311C10);
    }
    uint64_t v12 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(unsigned __int8 *)(v6 + 17);
      int v14 = *(unsigned __int8 *)(v6 + 16);
      *(_DWORD *)uint64_t buf = 67109888;
      int v17 = v13;
      __int16 v18 = 1024;
      int v19 = a2;
      __int16 v20 = 1024;
      int v21 = v14;
      __int16 v22 = 1024;
      int v23 = v10;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "[FSM] %u,event,%u,transition,from,%u,to,%u", buf, 0x1Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_102311C10);
      }
      char v15 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CMFiniteStateMachine::signal(uint8_t, const void *)", "%s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
  }
  *(unsigned char *)(v6 + 16) = v10;
  return v11(v6, a3);
}

double sub_1001A3770(uint64_t a1, uint64_t a2, unsigned char *a3, double *a4)
{
  *a3 = 0;
  *a4 = -1.0;
  double result = *(double *)(a2 + 44);
  if (result >= 0.0)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 96);
    BOOL v6 = v5 > 9;
    int v7 = (1 << v5) & 0x20A;
    if (!v6 && v7 != 0)
    {
      *(double *)(a1 + 32) = result;
      double v9 = *(double *)(a2 + 76);
      *(double *)(a1 + 40) = v9;
      double result = vabdd_f64(v9, *(double *)(a1 + 24));
      if (result < 1.5)
      {
        *a3 = 1;
        *(_OWORD *)a1 = *(_OWORD *)(a1 + 32);
        double result = *(double *)(a2 + 44);
        *a4 = result;
      }
    }
  }
  return result;
}

void sub_1001A37EC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = CMVO2MaxRetrocomputeRecord;
  uint64_t v4 = a2;
  +[NSDictionary dictionaryWithObjects:&v4 forKeys:&v3 count:1];
  sub_100012364(a1);
}

void sub_1001A387C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v10 = a3;
  ++*(_DWORD *)(a1 + 204);
  if (!*(unsigned char *)(a1 + 88) || a3 != 5 && a3) {
    return;
  }
  int v6 = *(_DWORD *)(a4 + 96);
  if (v6 == 10
    && (sub_10018485C(a1) & 1) == 0
    && (*(double *)(a1 + 768) == 1.79769313e308
     || (*(double (**)(void))(**(void **)(a1 + 56) + 64))(*(void *)(a1 + 56)) >= *(double *)(a1 + 768)))
  {
    sub_100D06A50(a1);
    char v8 = 1;
    goto LABEL_11;
  }
  int v7 = sub_10018485C(a1);
  char v8 = 0;
  char v9 = 0;
  if (v7)
  {
LABEL_11:
    sub_101093390(a1 + 464, (uint64_t)&v10, a4, 0);
    char v9 = v8;
  }
  if (v6 == 10 && (v9 & 1) == 0) {
    sub_100D06CBC(a1);
  }
}

BOOL sub_1001A3984(void *a1, double *a2)
{
  uint64_t v4 = (uint64_t)(a1 + 66);
  sub_1000980A4(a1 + 69, a2);
  double v6 = a2[2];
  sub_10017CCF0(a1 + 60, &v6);
  (*(void (**)(void, double))(*(void *)a1[82] + 40))(a1[82], v6);
  sub_1001B8E4C(v4, v6);
  sub_1001711B4((uint64_t)(a1 + 83), v6);
  BOOL result = sub_100087E8C((uint64_t)a1);
  if (result) {
    return sub_100528B3C(a1[82], *(double *)(a1[82] + 104), *(double *)(a1[82] + 112));
  }
  return result;
}

BOOL sub_1001A3A34(uint64_t a1, double a2, double a3, double a4)
{
  double v4 = a3 / a2;
  BOOL v11 = a2 == 0.0;
  double v5 = 0.0;
  if (!v11) {
    double v5 = v4;
  }
  int v6 = *(_DWORD *)(a1 + 2016);
  switch(v6)
  {
    case 2:
      if (v5 < 2.5)
      {
        *(_DWORD *)(a1 + 2020) = 3;
        goto LABEL_25;
      }
      if (a4 == 0.0)
      {
        if (qword_102419030 != -1) {
          goto LABEL_43;
        }
        while (1)
        {
          int v14 = qword_102419038;
          if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "How can we generate pedometer distance with no time at all?", buf, 2u);
          }
          if (sub_10013D1A0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419030 != -1) {
              dispatch_once(&qword_102419030, &stru_1022F3BA0);
            }
            __int16 v18 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLStepDistanceFusion::updateVehicularStateMachine(double, double, double)", "%s\n", v18);
            if (v18 != (char *)buf) {
              free(v18);
            }
          }
          if (qword_102419030 != -1) {
            dispatch_once(&qword_102419030, &stru_1022F3BA0);
          }
          char v15 = qword_102419038;
          if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)uint64_t buf = 68289539;
            int v20 = 0;
            __int16 v21 = 2082;
            __int16 v22 = "";
            __int16 v23 = 2082;
            double v24 = "assert";
            __int16 v25 = 2081;
            int v26 = "false";
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
            if (qword_102419030 != -1) {
              dispatch_once(&qword_102419030, &stru_1022F3BA0);
            }
          }
          BOOL v16 = qword_102419038;
          if (os_signpost_enabled((os_log_t)qword_102419038))
          {
            *(_DWORD *)uint64_t buf = 68289539;
            int v20 = 0;
            __int16 v21 = 2082;
            __int16 v22 = "";
            __int16 v23 = 2082;
            double v24 = "assert";
            __int16 v25 = 2081;
            int v26 = "false";
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
            if (qword_102419030 != -1) {
              dispatch_once(&qword_102419030, &stru_1022F3BA0);
            }
          }
          int v17 = qword_102419038;
          if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)uint64_t buf = 68289539;
            int v20 = 0;
            __int16 v21 = 2082;
            __int16 v22 = "";
            __int16 v23 = 2082;
            double v24 = "assert";
            __int16 v25 = 2081;
            int v26 = "false";
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          }
          abort_report_np();
LABEL_43:
          dispatch_once(&qword_102419030, &stru_1022F3BA0);
        }
      }
      int v9 = *(_DWORD *)(a1 + 2020) - 1;
      *(_DWORD *)(a1 + 2020) = v9;
      BOOL v11 = a3 / a4 > 13.0 || v5 > 6.0 || v9 == 0;
      if (!v11) {
        goto LABEL_25;
      }
      *(void *)(a1 + 2016) = 0x800000001;
LABEL_24:
      int v6 = 1;
      return v6 == 1;
    case 1:
      if (v5 >= 2.5)
      {
        *(_DWORD *)(a1 + 2020) = 8;
      }
      else
      {
        int v8 = *(_DWORD *)(a1 + 2020) - 1;
        *(_DWORD *)(a1 + 2020) = v8;
        if (!v8)
        {
          *(void *)(a1 + 2016) = 0x300000002;
LABEL_25:
          int v6 = 2;
          return v6 == 1;
        }
      }
      goto LABEL_24;
    case 0:
      int v7 = *(_DWORD *)(a1 + 2020) - 1;
      *(_DWORD *)(a1 + 2020) = v7;
      if (v7)
      {
        int v6 = 0;
      }
      else
      {
        int8x8_t v12 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v5 < 2.5), 0x1FuLL)), (int8x8_t)0x300000002, (int8x8_t)0x800000001);
        *(int8x8_t *)(a1 + 2016) = v12;
        int v6 = v12.i32[0];
      }
      break;
  }
  return v6 == 1;
}

BOOL sub_1001A3F00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(uint64_t **)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v3 = (long long *)(a2 + 16);
  uint64_t v6 = *(void *)(a3 + 24);
  if (v5 == v6) {
    int v7 = 0;
  }
  else {
    int v7 = -858993459 * ((unint64_t)(v5 - *v4) >> 6)
  }
       + 2 * (v4 - *(void *)(a3 + 16))
       + 858993459 * ((unint64_t)(v6 - **(void **)(a3 + 16)) >> 6);
  if (v7 >= 5) {
    int v7 = 5;
  }
  long long v16 = *v3;
  sub_1000BACE4((uint64_t **)&v16, -(uint64_t)v7);
  if (v5 == *((void *)&v16 + 1)) {
    return 0;
  }
  int v8 = 0;
  uint64_t v9 = *v4;
  do
  {
    uint64_t v10 = v5;
    if (v5 == v9) {
      uint64_t v10 = *(v4 - 1) + 5120;
    }
    int v11 = *(_DWORD *)(v10 - 104);
    int v12 = *(unsigned char *)(v10 - 160) & 0xFD;
    if (v11) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v12 == 1;
    }
    if (v13) {
      ++v8;
    }
    if (v5 == v9)
    {
      uint64_t v14 = *--v4;
      uint64_t v9 = v14;
      uint64_t v5 = v14 + 5120;
    }
    v5 -= 320;
  }
  while (v5 != *((void *)&v16 + 1));
  return v8 > 2;
}

uint64_t sub_1001A4008@<X0>(int64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419030 != -1) {
    dispatch_once(&qword_102419030, &stru_1022F3BA0);
  }
  uint64_t v6 = qword_102419038;
  if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 32);
    uint64_t v10 = *(void *)(a2 + 40);
    uint64_t v11 = *(void *)(a2 + 56);
    uint64_t v12 = *(void *)(a2 + 64);
    uint64_t v13 = *(void *)(a2 + 184);
    uint64_t v14 = *(void *)(a2 + 192);
    int v15 = *(_DWORD *)(a2 + 216);
    uint64_t v16 = *(void *)(a2 + 200);
    uint64_t v17 = *(void *)(a2 + 208);
    uint64_t v18 = *(void *)(a2 + 80);
    uint64_t v19 = *(void *)(a2 + 96);
    uint64_t v20 = *(void *)(a2 + 24);
    int v21 = *(unsigned __int8 *)(a2 + 160);
    *(_DWORD *)uint64_t buf = 134221568;
    uint64_t v26 = v7;
    __int16 v27 = 2048;
    uint64_t v28 = v8;
    __int16 v29 = 1024;
    int v30 = v9;
    __int16 v31 = 2048;
    uint64_t v32 = v10;
    __int16 v33 = 2048;
    uint64_t v34 = v11;
    __int16 v35 = 2048;
    uint64_t v36 = v12;
    __int16 v37 = 2048;
    uint64_t v38 = v13;
    __int16 v39 = 2048;
    uint64_t v40 = v14;
    __int16 v41 = 2048;
    uint64_t v42 = v16;
    __int16 v43 = 1024;
    int v44 = v15;
    __int16 v45 = 2048;
    uint64_t v46 = v17;
    __int16 v47 = 2048;
    uint64_t v48 = v18;
    __int16 v49 = 2048;
    uint64_t v50 = v19;
    __int16 v51 = 2048;
    uint64_t v52 = v20;
    __int16 v53 = 1024;
    int v54 = v21;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "StepCount, %f, %f, %d, %f, %f, %f, %f, %f, %f, %u, %f, %f, %f, %f, %d", buf, 0x8Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419030 != -1) {
      dispatch_once(&qword_102419030, &stru_1022F3BA0);
    }
    double v24 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLStepDistanceFusionResult> CLStepDistanceFusion::feedStepCountEntry(const CLExtendedStepCountEntry &)", "%s\n", v24);
    if (v24 != (char *)buf) {
      free(v24);
    }
  }
  uint64_t result = sub_1001A3984(a1, (double *)a2);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  while (a1[32].i64[1])
  {
    double v23 = *(double *)(*(void *)(a1[30].i64[1] + (((unint64_t)a1[32].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * (a1[32].i64[0] & 0x1FF));
    uint64_t result = a1[29].i64[1] == 1
           ? sub_100D3ED5C((uint64_t)a1, (void **)a3, v23)
           : sub_100085288((uint64_t)a1, (char **)a3, v23);
    if (!result) {
      break;
    }
    a1[32] = vaddq_s64(a1[32], (int64x2_t)xmmword_101D0A740);
    uint64_t result = sub_10007F07C((uint64_t)a1[30].i64, 1);
  }
  return result;
}

void sub_1001A43A4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1001A43C8(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  [a4[56] assertInside];
  uint64_t v8 = (uint64_t (*)(id *, uint64_t, uint64_t, uint64_t))*((void *)*a4 + 4);

  return v8(a4, a1, a2, a3);
}

void *sub_1001A4444(void *result, uint64_t a2, _DWORD *a3, const void *a4)
{
  if (*a3 == 1) {
    return sub_100097DD8(result, a4);
  }
  return result;
}

uint64_t sub_1001A445C(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  [a4[56] assertInside];
  uint64_t v8 = (uint64_t (*)(id *, uint64_t, uint64_t, uint64_t))*((void *)*a4 + 4);

  return v8(a4, a1, a2, a3);
}

void sub_1001A44D8(uint64_t a1, uint64_t a2, _DWORD *a3, long long *a4)
{
  if ((*a3 | 4) == 7) {
    sub_1001B69EC(a1, a4);
  }
}

float sub_1001A44F4(uint64_t a1, float *a2)
{
  uint64_t v4 = a1 + 24;
  sub_1000A1600((void *)(a1 + 24), a2);
  unint64_t v5 = *(void *)(a1 + 64);
  if (v5 > *(void *)(a1 + 8))
  {
    unint64_t v6 = *(void *)(a1 + 56);
    float v7 = *(float *)(*(void *)(*(void *)(a1 + 32) + ((v6 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v6 & 0x3FF));
    float v8 = *(float *)(a1 + 16) - v7;
    float v9 = *(float *)(a1 + 20) - (float)(v7 * v7);
    *(float *)(a1 + 16) = v8;
    *(float *)(a1 + 20) = v9;
    *(void *)(a1 + 56) = v6 + 1;
    *(void *)(a1 + 64) = v5 - 1;
    sub_1000A1688(v4, 1);
  }
  float v10 = *(float *)(a1 + 20);
  *(float *)(a1 + 16) = *a2 + *(float *)(a1 + 16);
  float result = v10 + (float)(*a2 * *a2);
  *(float *)(a1 + 20) = result;
  return result;
}

uint64_t sub_1001A459C(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  if (sub_1000E6DB4(a2))
  {
    long long v8 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 48) = v8;
    long long v9 = *(_OWORD *)(a2 + 32);
    long long v10 = *(_OWORD *)(a2 + 48);
    long long v11 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 112) = v11;
    *(_OWORD *)(a1 + 64) = v9;
    *(_OWORD *)(a1 + 80) = v10;
    long long v12 = *(_OWORD *)(a2 + 96);
    long long v13 = *(_OWORD *)(a2 + 112);
    long long v14 = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 172) = *(_OWORD *)(a2 + 140);
    *(_OWORD *)(a1 + 144) = v13;
    *(_OWORD *)(a1 + 160) = v14;
    *(_OWORD *)(a1 + 128) = v12;
    *(_DWORD *)uint64_t buf = 0;
    uint64_t result = sub_100178BF0(a1 + 8, (int *)buf);
    if (result)
    {
      double v16 = sub_10016C458();
      double v17 = *(double *)(a1 + 192);
      double v18 = vabdd_f64(v16, v17);
      if (v17 < 0.0 || v18 > 600.0)
      {
        *(_DWORD *)uint64_t buf = 0;
        if (sub_100178BF0(a1 + 8, (int *)buf))
        {
          uint64_t v19 = *(void *)(a1 + 16);
          if (v19)
          {
            uint64_t v20 = a1 + 16;
            do
            {
              int v21 = *(_DWORD *)(v19 + 32);
              BOOL v22 = v21 < 0;
              if (v21 >= 0) {
                double v23 = (uint64_t *)v19;
              }
              else {
                double v23 = (uint64_t *)(v19 + 8);
              }
              if (!v22) {
                uint64_t v20 = v19;
              }
              uint64_t v19 = *v23;
            }
            while (*v23);
            if (v20 != a1 + 16 && *(int *)(v20 + 32) <= 0)
            {
              double v24 = sub_1000F1648((double *)(a1 + 208), *(double *)(v20 + 40), *(double *)(v20 + 48), *(double *)(a1 + 36), *(double *)(a1 + 44), 0.0);
              if (v24 <= a4) {
                int v25 = 1;
              }
              else {
                int v25 = 2;
              }
              *(_DWORD *)(a1 + 200) = v25;
              *(double *)(a1 + 192) = v16;
              if (qword_102419430 != -1) {
                dispatch_once(&qword_102419430, &stru_102328DC8);
              }
              uint64_t v26 = qword_102419438;
              if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
              {
                int v27 = *(_DWORD *)(a1 + 200);
                *(_DWORD *)uint64_t buf = 67174913;
                *(_DWORD *)int v67 = v27;
                *(_WORD *)&v67[4] = 2050;
                *(double *)&v67[6] = v24;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "CLGMTPS,currentServiceMode,%{private}d,distance,%{public}.1lf", buf, 0x12u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419430 != -1) {
                  dispatch_once(&qword_102419430, &stru_102328DC8);
                }
                int v52 = *(_DWORD *)(a1 + 200);
                int v56 = 67174913;
                *(_DWORD *)uint64_t v57 = v52;
                *(_WORD *)&v57[4] = 2050;
                *(double *)&v57[6] = v24;
                __int16 v53 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLRoutineManagerInfo::updateUserLocation(CLDaemonLocation &, const double, TouristModeHandler)", "%s\n", v53);
                if (v53 != (char *)buf) {
                  free(v53);
                }
              }
              long long v28 = *(_OWORD *)(a1 + 144);
              v54[6] = *(_OWORD *)(a1 + 128);
              v54[7] = v28;
              v55[0] = *(_OWORD *)(a1 + 160);
              *(_OWORD *)((char *)v55 + 12) = *(_OWORD *)(a1 + 172);
              long long v29 = *(_OWORD *)(a1 + 80);
              v54[2] = *(_OWORD *)(a1 + 64);
              v54[3] = v29;
              long long v30 = *(_OWORD *)(a1 + 112);
              v54[4] = *(_OWORD *)(a1 + 96);
              v54[5] = v30;
              long long v31 = *(_OWORD *)(a1 + 48);
              int v32 = *(_DWORD *)(a1 + 200);
              v54[0] = *(_OWORD *)(a1 + 32);
              v54[1] = v31;
              (*(void (**)(uint64_t, _OWORD *, BOOL))(a3 + 16))(a3, v54, v32 == 2);
            }
          }
        }
      }
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_102328DC8);
      }
      __int16 v33 = qword_102419438;
      if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v34 = *(void *)(a1 + 108);
        int v35 = *(_DWORD *)(a1 + 128);
        uint64_t v36 = *(void *)(a1 + 36);
        uint64_t v37 = *(void *)(a1 + 44);
        int v38 = *(_DWORD *)(a1 + 200);
        *(_DWORD *)uint64_t buf = 134284801;
        *(void *)int v67 = v34;
        *(_WORD *)&v67[8] = 1026;
        *(_DWORD *)&v67[10] = v35;
        __int16 v68 = 2049;
        uint64_t v69 = v36;
        __int16 v70 = 2049;
        uint64_t v71 = v37;
        __int16 v72 = 1025;
        int v73 = v38;
        __int16 v74 = 2049;
        double v75 = v18;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "CLGMTPS,received valid location,time,%{private}.1lf,type,%{public}d,LL,%{private}.7lf,%{private}.7lf,touristMode,%{private}d,dT,%{private}.1lf", buf, 0x36u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419430 != -1) {
          dispatch_once(&qword_102419430, &stru_102328DC8);
        }
        uint64_t v46 = *(void *)(a1 + 108);
        int v47 = *(_DWORD *)(a1 + 128);
        uint64_t v48 = *(void *)(a1 + 36);
        uint64_t v49 = *(void *)(a1 + 44);
        int v50 = *(_DWORD *)(a1 + 200);
        int v56 = 134284801;
        *(void *)uint64_t v57 = v46;
        *(_WORD *)&v57[8] = 1026;
        *(_DWORD *)&v57[10] = v47;
        __int16 v58 = 2049;
        uint64_t v59 = v48;
        __int16 v60 = 2049;
        uint64_t v61 = v49;
        __int16 v62 = 1025;
        int v63 = v50;
        __int16 v64 = 2049;
        double v65 = v18;
        __int16 v51 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLRoutineManagerInfo::updateUserLocation(CLDaemonLocation &, const double, TouristModeHandler)", "%s\n", v51);
        if (v51 != (char *)buf) {
          free(v51);
        }
      }
      return 1;
    }
  }
  else
  {
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_102328DC8);
    }
    __int16 v39 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_ERROR))
    {
      uint64_t v40 = *(void *)(a2 + 76);
      int v41 = *(_DWORD *)(a2 + 96);
      *(_DWORD *)uint64_t buf = 134283777;
      *(void *)int v67 = v40;
      *(_WORD *)&v67[8] = 1026;
      *(_DWORD *)&v67[10] = v41;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "CLGMTPS,received invalid location,time,%{private}.1lf,type,%{public}d,", buf, 0x12u);
    }
    BOOL v42 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v42)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_102328DC8);
      }
      uint64_t v43 = *(void *)(a2 + 76);
      int v44 = *(_DWORD *)(a2 + 96);
      int v56 = 134283777;
      *(void *)uint64_t v57 = v43;
      *(_WORD *)&v57[8] = 1026;
      *(_DWORD *)&v57[10] = v44;
      __int16 v45 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLRoutineManagerInfo::updateUserLocation(CLDaemonLocation &, const double, TouristModeHandler)", "%s\n", v45);
      if (v45 != (char *)buf) {
        free(v45);
      }
      return 0;
    }
  }
  return result;
}

double sub_1001A4C44(uint64_t a1, long long *a2)
{
  *(void *)&double result = sub_10017D960((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

BOOL sub_1001A4C4C(unsigned int a1)
{
  return a1 < 2;
}

BOOL sub_1001A4C58(unsigned int a1)
{
  return a1 < 6;
}

uint64_t sub_1001A4C64(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  uint64_t v3 = *(void *)(result + 24);
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1001A4D20(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1001A4D94(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  int v10 = a2;
  uint64_t v7 = sub_10016BA10();
  sub_10016BC44((uint64_t)v11);
  sub_10016BE74(v7, v11[0].i64);
  int v12 = 25;
  v11[0].i32[0] = 25;
  v11[0].i32[1] = sub_10016A9AC(&v12);
  uint64_t v8 = sub_10016AB88();
  int v12 = 4;
  sub_10003A5E4(v8, (unsigned int *)&v12, v11, (int *)(a1 + 5124), &v10, a3, a4);
  return (*(uint64_t (**)(void, int *, uint64_t))(**(void **)(a1 + 288) + 32))(*(void *)(a1 + 288), a3, a4);
}

void sub_1001A4E60(uint64_t a1, char *a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022C17A0);
  }
  uint64_t v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a2;
    *(_DWORD *)uint64_t buf = 67240192;
    int v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "lost location from kDynamicLocationProvider,%{public}d,restarting all worse providers", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    long long v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::restartLessDesirableProviders(const DynamicLocationProvider &)", "%s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
  unint64_t v6 = *(void **)(a1 + 240);
  if (v6 != (void *)(a1 + 248))
  {
    char v7 = 0;
    do
    {
      if (*((_DWORD *)v6 + 8)) {
        BOOL v8 = *((unsigned char *)v6 + 903) == 0;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8 && *((char *)v6 + 901) < *a2)
      {
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_1022C17A0);
        }
        long long v9 = qword_102419388;
        if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
        {
          int v10 = *((char *)v6 + 901);
          *(_DWORD *)uint64_t buf = 67240192;
          int v16 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "restarting worse location provider kDynamicLocationProvider,%{public}d", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419380 != -1) {
            dispatch_once(&qword_102419380, &stru_1022C17A0);
          }
          long long v13 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLLocationController::restartLessDesirableProviders(const DynamicLocationProvider &)", "%s\n", v13);
          if (v13 != (char *)buf) {
            free(v13);
          }
        }
        sub_100150F38(a1, *((_DWORD *)v6 + 8));
        char v7 = 1;
      }
      long long v11 = (void *)v6[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          long long v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v6[2];
          BOOL v8 = *v12 == (void)v6;
          unint64_t v6 = v12;
        }
        while (!v8);
      }
      unint64_t v6 = v12;
    }
    while (v12 != (void *)(a1 + 248));
    if (v7) {
      sub_10001F5E4(a1);
    }
  }
}

uint64_t sub_1001A5208(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10016BA10();
  sub_10016BC44((uint64_t)v7);
  sub_10016BE74(v4, v7[0].i64);
  int v8 = 22;
  v7[0].i32[0] = 22;
  v7[0].i32[1] = sub_10016A9AC(&v8);
  uint64_t v5 = sub_10016AB88();
  sub_10004DF88(v5, v7, (int *)(a1 + 5124), a2);
  uint64_t result = *(void *)(a1 + 288);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, a2);
  }
  return result;
}

void sub_1001A52B8(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  int v10 = a2;
  uint64_t v7 = sub_10016BA10();
  sub_10016BC44((uint64_t)v11);
  sub_10016BE74(v7, v11[0].i64);
  int v12 = 19;
  v11[0].i32[0] = 19;
  v11[0].i32[1] = sub_10016A9AC(&v12);
  uint64_t v8 = sub_10016AB88();
  int v12 = 4;
  sub_100166814(v8, (unsigned int *)&v12, v11, (int *)(a1 + 5124), &v10, a3, a4);
  sub_10015040C(a1, *(_DWORD *)(a1 + 340), v9, (unsigned int *)a3, a4);
}

uint64_t sub_1001A5368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3 = 0;
  if (*(void *)(a1 + 5112))
  {
    if (*(double *)(a3 + 384) <= 0.0 && *(_DWORD *)(a2 + 132) != 2)
    {
      if (!sub_1000E6DB4(a2)) {
        goto LABEL_19;
      }
      double v8 = *(double *)(a2 + 20);
      if (v8 <= 0.0
        || v8 >= (*(double (**)(void))(**(void **)(a1 + 288) + 112))(*(void *)(a1 + 288)))
      {
        goto LABEL_19;
      }
      int v45 = 0;
      uint64_t v44 = 0;
      *(_DWORD *)int v32 = 0xFFFF;
      *(_OWORD *)&v32[4] = 0uLL;
      *(_OWORD *)&v32[20] = xmmword_101D1C320;
      __asm { FMOV            V0.2D, #-1.0 }
      *(_OWORD *)&v32[36] = _Q0;
      *(_OWORD *)&v32[52] = _Q0;
      *(_OWORD *)&v32[68] = _Q0;
      *(_DWORD *)&v32[84] = 0;
      long long v33 = 0uLL;
      *(void *)&v32[88] = 0xBFF0000000000000;
      LODWORD(v34) = 0;
      *(void *)((char *)&v34 + 4) = 0xBFF0000000000000;
      HIDWORD(v34) = 0x7FFFFFFF;
      memset(v35, 0, 25);
      long long v13 = (void *)sub_1000DBC34(v36);
      long long v14 = *(_OWORD *)(a2 + 112);
      long long v33 = *(_OWORD *)(a2 + 96);
      long long v34 = v14;
      *(_OWORD *)int v35 = *(_OWORD *)(a2 + 128);
      *(_OWORD *)&v35[12] = *(_OWORD *)(a2 + 140);
      long long v15 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)&v32[32] = *(_OWORD *)(a2 + 32);
      *(_OWORD *)&v32[48] = v15;
      long long v16 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)&_OWORD v32[64] = *(_OWORD *)(a2 + 64);
      *(_OWORD *)&v32[80] = v16;
      long long v17 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)int v32 = *(_OWORD *)a2;
      *(_OWORD *)&v32[16] = v17;
      memcpy(v13, (const void *)a3, 0x201uLL);
      uint64_t v18 = *(void *)(a3 + 520);
      uint64_t v19 = *(std::__shared_weak_count **)(a3 + 528);
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v36[65] = v18;
      uint64_t v20 = v37;
      uint64_t v37 = v19;
      if (v20) {
        sub_1000DB0A0(v20);
      }
      long long v21 = *(_OWORD *)(a3 + 616);
      long long v42 = *(_OWORD *)(a3 + 600);
      *(_OWORD *)uint64_t v43 = v21;
      *(void *)&v43[13] = *(void *)(a3 + 629);
      long long v22 = *(_OWORD *)(a3 + 552);
      long long v38 = *(_OWORD *)(a3 + 536);
      long long v39 = v22;
      long long v23 = *(_OWORD *)(a3 + 584);
      long long v40 = *(_OWORD *)(a3 + 568);
      long long v41 = v23;
      unsigned int v24 = [*(id *)(a1 + 5112) syncgetAltitude:v32 rel:&v45 undulation:&v44];
      char v25 = v24;
      if (v24)
      {
        char v3 = (*(uint64_t (**)(void, uint64_t, uint64_t, unsigned char *))(**(void **)(a1 + 288) + 216))(*(void *)(a1 + 288), a2, a3, v32);
      }
      else
      {
        long long v26 = *(_OWORD *)(a2 + 112);
        long long v53 = *(_OWORD *)(a2 + 96);
        long long v54 = v26;
        v55[0] = *(_OWORD *)(a2 + 128);
        *(_OWORD *)((char *)v55 + 12) = *(_OWORD *)(a2 + 140);
        long long v27 = *(_OWORD *)(a2 + 48);
        long long v49 = *(_OWORD *)(a2 + 32);
        long long v50 = v27;
        long long v28 = *(_OWORD *)(a2 + 80);
        long long v51 = *(_OWORD *)(a2 + 64);
        long long v52 = v28;
        long long v29 = *(_OWORD *)(a2 + 16);
        long long v47 = *(_OWORD *)a2;
        long long v48 = v29;
        long long v30 = *(void **)(a1 + 5112);
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        v46[2] = sub_100682914;
        v46[3] = &unk_1022C1CA0;
        objc_msgSend(v30, "downloadIfNeeded:signalQuality:allowCenterOverCellular:", objc_msgSend(v46, "copy", *(void *)v32, *(void *)&v32[8], *(_OWORD *)&v32[16], *(_OWORD *)&v32[32], *(_OWORD *)&v32[48], *(_OWORD *)&v32[64], *(void *)&v32[80], *(void *)&v32[88], v33, v34, *(_OWORD *)v35, *(void *)&v35[16], *(void *)&v35[24]),
          0,
          0);
      }
      if (v37) {
        sub_1000DB0A0(v37);
      }
      if ((v25 & 1) == 0) {
LABEL_19:
      }
        char v3 = 0;
    }
  }
  return v3 & 1;
}

void sub_1001A5620(_Unwind_Exception *a1)
{
  if (STACK[0x2B0]) {
    sub_1000DB0A0((std::__shared_weak_count *)STACK[0x2B0]);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1001A563C(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  int v10 = a2;
  uint64_t v7 = sub_10016BA10();
  sub_10016BC44((uint64_t)v11);
  sub_10016BE74(v7, v11[0].i64);
  int v12 = 12;
  v11[0].i32[0] = 12;
  v11[0].i32[1] = sub_10016A9AC(&v12);
  uint64_t v8 = sub_10016AB88();
  int v12 = 4;
  sub_100065FF4(v8, (unsigned int *)&v12, v11, (int *)(a1 + 5124), &v10, a3, a4);
  return (*(uint64_t (**)(void, int *, uint64_t))(**(void **)(a1 + 288) + 72))(*(void *)(a1 + 288), a3, a4);
}

void sub_1001A5708(uint64_t a1, unsigned char *a2)
{
  sub_10015907C(a1);
  int v4 = (char)*a2;
  if (v4 != 2 && v4 < *(char *)(a1 + 161))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022C17A0);
    }
    uint64_t v5 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      int v6 = (char)*a2;
      v15[0] = 68289282;
      v15[1] = 0;
      __int16 v16 = 2082;
      long long v17 = "";
      __int16 v18 = 1026;
      int v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Stopping all location providers above threshold\", \"threshold\":%{public}d}", (uint8_t *)v15, 0x18u);
    }
    uint64_t v7 = *(void **)(a1 + 240);
    if (v7 != (void *)(a1 + 248))
    {
      char v8 = 0;
      do
      {
        int v9 = *((char *)v7 + 900);
        if (v9 <= *(char *)(a1 + 161) && v9 > (char)*a2)
        {
          sub_10067A748(a1, *((_DWORD *)v7 + 10));
          char v8 = 1;
        }
        long long v11 = (void *)v7[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            long long v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v7[2];
            BOOL v13 = *v12 == (void)v7;
            uint64_t v7 = v12;
          }
          while (!v13);
        }
        uint64_t v7 = v12;
      }
      while (v12 != (void *)(a1 + 248));
      if (v8) {
        sub_10001F5E4(a1);
      }
    }
    int v14 = *a2;
    if (v14 == 255)
    {
      [*(id *)(a1 + 656) setNextFireDelay:1.79769313e308];
      LOBYTE(v14) = *a2;
    }
    *(unsigned char *)(a1 + 161) = v14;
  }
}

uint64_t sub_1001A58C0()
{
  if (qword_102487A80 != -1) {
    dispatch_once(&qword_102487A80, &stru_1023259F0);
  }
  return qword_10248D710;
}

uint64_t sub_1001A5904(CFDictionaryRef theDict, BOOL *a2)
{
  sub_10013FA80((int)v7, theDict);
  uint64_t v3 = sub_1000D29FC((uint64_t)v7, @"kCellMonitorRefreshResultKey", a2);
  if ((v3 & 1) == 0)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102320810);
    }
    int v4 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "copyValuesFromCellMonitorRefreshResultDictionary, couldn't get dictionary values", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102320810);
      }
      int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLCoreTelephonyUtils::copyValuesFromCellMonitorRefreshResultDictionary(CFDictionaryRef, BOOL &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  sub_10013F3C4(v7);
  return v3;
}

void sub_1001A5AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10013F3C4(va);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1001A5AF4(char a1)
{
  char v2 = a1;
  values = (void *)sub_100007264(&v2);
  keys = @"kCellMonitorRefreshResultKey";
  return CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

std::string *sub_1001A5B7C(std::string *a1, const std::string *a2)
{
  if (a1[4].__r_.__value_.__s.__data_[1]) {
    return std::string::assign(a1, "root");
  }
  else {
    return std::string::operator=(a1, a2);
  }
}

char *sub_1001A5B94(char *__dst, long long *a2, long long *a3, uint64_t a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v7;
  }
  char v8 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1000DC48C(v8, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)char v8 = v9;
  }
  *((void *)__dst + 6) = a4;
  return __dst;
}

void sub_1001A5C20(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001A5C3C(uint64_t a1, double *a2, double *a3, double *a4, unsigned char *a5)
{
  uint64_t v18 = qword_10248D770;
  (*(void (**)(uint64_t))(*(void *)qword_10248D770 + 16))(qword_10248D770);
  __int16 v20 = 256;
  v10.n128_f64[0] = *a2;
  if (*a2 <= *(double *)(a1 + 32))
  {
    uint64_t v14 = 0;
    goto LABEL_19;
  }
  if (v10.n128_f64[0] < *(double *)(a1 + 40))
  {
    v10.n128_f64[0] = *a3;
    if (*a3 > *(double *)(a1 + 48) && v10.n128_f64[0] < *(double *)(a1 + 56))
    {
      uint64_t v11 = *(void *)(a1 + 64);
      uint64_t v12 = *(void *)(a1 + 72);
      if (v12 == v11)
      {
        sub_1014BE900(a1);
        uint64_t v11 = *(void *)(a1 + 64);
        uint64_t v12 = *(void *)(a1 + 72);
      }
      while (v11 != v12)
      {
        if (sub_1014BED2C(v11, *a2, *a3))
        {
          char v17 = 0;
          double v16 = 0.0;
          uint64_t v13 = sub_10065AD6C();
          if (sub_10065FC7C(v13, (sqlite3_int64 *)(v11 + 32), &v17, &v16, *a2, *a3))
          {
            if (v17 || *a5 && (v10.n128_f64[0] = v16, v16 <= *a4))
            {
              uint64_t v14 = 1;
              goto LABEL_15;
            }
          }
        }
        v11 += 40;
      }
    }
  }
  uint64_t v14 = 0;
LABEL_15:
  if (HIBYTE(v20))
  {
    if ((_BYTE)v20)
    {
      pthread_mutex_unlock(v19);
      return v14;
    }
LABEL_19:
    (*(void (**)(uint64_t, __n128))(*(void *)v18 + 24))(v18, v10);
  }
  return v14;
}

void sub_1001A5DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

id *sub_1001A5DF8(uint64_t a1, long long *a2, char a3)
{
  v30[0] = (id)os_transaction_create();
  v30[1] = 0;
  if (*(double *)(a1 + 248) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, long long *))(*(void *)a1 + 136))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)a1 + 72))(a1, a1 + 224, a2);
    return sub_1000E1098(v30);
  }
  if ((a3 & 1) == 0) {
    sub_10002B640(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 104))(a1, v39);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 120))(a1, a2, 1);
  }
  else
  {
    if (v6)
    {
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_102313528);
      }
      uint64_t v14 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Failed to insert record due to failure from reading the most recent entry.", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102313528);
        }
        LOWORD(v31) = 0;
        long long v15 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLActivityRecorderDb<CLSignificantElevation>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v15);
        if (v15 != (char *)buf) {
          free(v15);
        }
      }
      goto LABEL_43;
    }
    double v7 = *((double *)a2 + 3);
    double v8 = v40;
    double v9 = v7 - v40;
    if (v7 - v40 < 0.0) {
      double v9 = -(v7 - v40);
    }
    if (v9 > 604800.0)
    {
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_102313528);
      }
      __n128 v10 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 3);
        *(_DWORD *)uint64_t buf = 134349312;
        double v36 = v40;
        __int16 v37 = 2050;
        uint64_t v38 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102313528);
        }
        uint64_t v24 = *((void *)a2 + 3);
        int v31 = 134349312;
        double v32 = v40;
        __int16 v33 = 2050;
        uint64_t v34 = v24;
        char v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLSignificantElevation>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v25);
        if (v25 != (char *)buf) {
          free(v25);
        }
      }
      CLWriteStackshot();
      double v7 = *((double *)a2 + 3);
      double v8 = v40;
    }
    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102313528);
        }
        uint64_t v12 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 3);
          *(_DWORD *)uint64_t buf = 134217984;
          double v36 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Entry being recorded has a startTime in the recent past.  Deleting records after %f.", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102313528);
          }
          double v26 = *((double *)a2 + 3);
          int v31 = 134217984;
          double v32 = v26;
          long long v27 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLSignificantElevation>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v27);
          if (v27 != (char *)buf) {
            free(v27);
          }
        }
        (*(void (**)(uint64_t, long long *))(*(void *)a1 + 88))(a1, a2);
        goto LABEL_42;
      }
      double v16 = v7 - v8;
      double v17 = *(float *)(a1 + 136);
      if (qword_102418FD0 != -1)
      {
        double v29 = *(float *)(a1 + 136);
        dispatch_once(&qword_102418FD0, &stru_102313528);
        double v17 = v29;
      }
      double v18 = v16 - v17;
      int v19 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        double v36 = v18;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Entry being recorded has a startTime in the substantial past.  Shift records by %f.", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102313528);
        }
        int v31 = 134217984;
        double v32 = v18;
        long long v28 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLSignificantElevation>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v28);
        if (v28 != (char *)buf) {
          free(v28);
        }
      }
      (*(void (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v18);
    }
    (*(void (**)(uint64_t, unsigned char *, uint64_t, long long *))(*(void *)a1 + 144))(a1, v39, a1 + 224, a2);
    (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 120))(a1, a2, 1);
  }
LABEL_42:
  long long v20 = *a2;
  long long v21 = a2[1];
  long long v22 = a2[3];
  *(_OWORD *)(a1 + 256) = a2[2];
  *(_OWORD *)(a1 + 272) = v22;
  *(_OWORD *)(a1 + 224) = v20;
  *(_OWORD *)(a1 + 240) = v21;
LABEL_43:
  if ((a3 & 1) == 0) {
    sub_100028FB4(*(void *)(a1 + 80));
  }
  return sub_1000E1098(v30);
}

void sub_1001A6600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000E1098((id *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A662C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v19[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v20 = 256;
  v19[0] = *(double *)(a2 + 24);
  if (sub_10018360C(v6, v19))
  {
    if (sub_100082064(v6))
    {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 80))(a1, a2, 0);
    }
    else if (!*(unsigned char *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 288))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_10017E0A8(a1 + 176, 1);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022CF680);
        }
        uint64_t v14 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Maximum number of entries exceeded, throwing out oldest entry.", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_1022CF680);
          }
          double v18 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLActivityRecorderDb<CLSignificantElevation>::addSuspectRecord(const T &) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v18);
          if (v18 != (char *)buf) {
            free(v18);
          }
        }
      }
      if (qword_102419030 != -1) {
        dispatch_once(&qword_102419030, &stru_1022CF6A0);
      }
      long long v15 = qword_102419038;
      if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Buffer was added to since db was inaccesible.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_1022CF6A0);
        }
        double v17 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLActivityRecorderDb<CLSignificantElevation>::addSuspectRecord(const T &) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v17);
        if (v17 != (char *)buf) {
          free(v17);
        }
      }
      __n128 v7 = sub_1008AC7E8(v12, a2);
    }
  }
  else
  {
    if (qword_102418FD0 != -1) {
      dispatch_once(&qword_102418FD0, &stru_1022CF680);
    }
    double v8 = qword_102418FD8;
    if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_ERROR))
    {
      double v9 = (void *)(a1 + 88);
      if (*(char *)(a1 + 111) < 0) {
        double v9 = (void *)*v9;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      uint64_t v24 = "";
      __int16 v25 = 1026;
      int v26 = (int)v19[0];
      __int16 v27 = 2082;
      long long v28 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CL database error, record contains invalid time\", \"invalid time\":%{public}d, \"name\":%{public, location:escape_only}s}", buf, 0x22u);
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_1022CF680);
      }
    }
    __n128 v10 = qword_102418FD8;
    if (os_signpost_enabled((os_log_t)qword_102418FD8))
    {
      uint64_t v11 = (void *)(a1 + 88);
      if (*(char *)(a1 + 111) < 0) {
        uint64_t v11 = (void *)*v11;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      uint64_t v24 = "";
      __int16 v25 = 1026;
      int v26 = (int)v19[0];
      __int16 v27 = 2082;
      long long v28 = v11;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CL database error, record contains invalid time", "{\"msg%{public}.0s\":\"CL database error, record contains invalid time\", \"invalid time\":%{public}d, \"name\":%{public, location:escape_only}s}", buf, 0x22u);
    }
  }
  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24))(v5, v7);
}

void sub_1001A6B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

id *sub_1001A6B9C(uint64_t a1, long long *a2, char a3)
{
  v37[0] = (id)os_transaction_create();
  v37[1] = 0;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, long long *))(*(void *)a1 + 136))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)a1 + 72))(a1, a1 + 224, a2);
    return sub_1000E1098(v37);
  }
  if ((a3 & 1) == 0) {
    sub_10002B640(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 104))(a1, v35);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 120))(a1, a2, 1);
  }
  else
  {
    if (v6)
    {
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_10232E1D8);
      }
      uint64_t v14 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Failed to insert record due to failure from reading the most recent entry.", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_10232E1D8);
        }
        LOWORD(v38) = 0;
        long long v15 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLActivityRecorderDb<CLStepCountEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v15);
        if (v15 != (char *)buf) {
          free(v15);
        }
      }
      goto LABEL_43;
    }
    double v7 = *((double *)a2 + 1);
    double v8 = v36;
    double v9 = v7 - v36;
    if (v7 - v36 < 0.0) {
      double v9 = -(v7 - v36);
    }
    if (v9 > 604800.0)
    {
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_10232E1D8);
      }
      __n128 v10 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 1);
        *(_DWORD *)uint64_t buf = 134349312;
        double v43 = v36;
        __int16 v44 = 2050;
        uint64_t v45 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_10232E1D8);
        }
        uint64_t v29 = *((void *)a2 + 1);
        int v38 = 134349312;
        double v39 = v36;
        __int16 v40 = 2050;
        uint64_t v41 = v29;
        long long v30 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLStepCountEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v30);
        if (v30 != (char *)buf) {
          free(v30);
        }
      }
      CLWriteStackshot();
      double v7 = *((double *)a2 + 1);
      double v8 = v36;
    }
    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_10232E1D8);
        }
        uint64_t v12 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 1);
          *(_DWORD *)uint64_t buf = 134217984;
          double v43 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Entry being recorded has a startTime in the recent past.  Deleting records after %f.", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_10232E1D8);
          }
          double v31 = *((double *)a2 + 1);
          int v38 = 134217984;
          double v39 = v31;
          double v32 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLStepCountEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v32);
          if (v32 != (char *)buf) {
            free(v32);
          }
        }
        (*(void (**)(uint64_t, long long *))(*(void *)a1 + 88))(a1, a2);
        goto LABEL_42;
      }
      double v16 = v7 - v8;
      double v17 = *(float *)(a1 + 136);
      if (qword_102418FD0 != -1)
      {
        double v34 = *(float *)(a1 + 136);
        dispatch_once(&qword_102418FD0, &stru_10232E1D8);
        double v17 = v34;
      }
      double v18 = v16 - v17;
      int v19 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        double v43 = v18;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Entry being recorded has a startTime in the substantial past.  Shift records by %f.", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_10232E1D8);
        }
        int v38 = 134217984;
        double v39 = v18;
        __int16 v33 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLActivityRecorderDb<CLStepCountEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v33);
        if (v33 != (char *)buf) {
          free(v33);
        }
      }
      (*(void (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v18);
    }
    (*(void (**)(uint64_t, char *, uint64_t, long long *))(*(void *)a1 + 144))(a1, v35, a1 + 224, a2);
    (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 120))(a1, a2, 1);
  }
LABEL_42:
  long long v20 = *a2;
  long long v21 = a2[2];
  *(_OWORD *)(a1 + 240) = a2[1];
  *(_OWORD *)(a1 + 256) = v21;
  *(_OWORD *)(a1 + 224) = v20;
  long long v22 = a2[3];
  long long v23 = a2[4];
  long long v24 = a2[6];
  *(_OWORD *)(a1 + 304) = a2[5];
  *(_OWORD *)(a1 + 320) = v24;
  *(_OWORD *)(a1 + 272) = v22;
  *(_OWORD *)(a1 + 288) = v23;
  long long v25 = a2[7];
  long long v26 = a2[8];
  long long v27 = a2[10];
  *(_OWORD *)(a1 + 368) = a2[9];
  *(_OWORD *)(a1 + 384) = v27;
  *(_OWORD *)(a1 + 336) = v25;
  *(_OWORD *)(a1 + 352) = v26;
LABEL_43:
  if ((a3 & 1) == 0) {
    sub_100028FB4(*(void *)(a1 + 80));
  }
  return sub_1000E1098(v37);
}

void sub_1001A73D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id a35)
{
}

uint64_t sub_1001A73FC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v19[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v20 = 256;
  v19[0] = *(double *)(a2 + 8);
  if (sub_10018360C(v6, v19))
  {
    if (sub_100082064(v6))
    {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 80))(a1, a2, 0);
    }
    else if (!*(unsigned char *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 400))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_100A31F9C(a1 + 176, 1);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_10232E788);
        }
        uint64_t v14 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Maximum number of entries exceeded, throwing out oldest entry.", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_10232E788);
          }
          double v18 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLActivityRecorderDb<CLStepCountEntry>::addSuspectRecord(const T &) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v18);
          if (v18 != (char *)buf) {
            free(v18);
          }
        }
      }
      if (qword_102419030 != -1) {
        dispatch_once(&qword_102419030, &stru_10232E540);
      }
      long long v15 = qword_102419038;
      if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Buffer was added to since db was inaccesible.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10232E540);
        }
        double v17 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLActivityRecorderDb<CLStepCountEntry>::addSuspectRecord(const T &) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]", "%s\n", v17);
        if (v17 != (char *)buf) {
          free(v17);
        }
      }
      __n128 v7 = sub_1006AA720(v12, (long long *)a2);
    }
  }
  else
  {
    if (qword_102418FD0 != -1) {
      dispatch_once(&qword_102418FD0, &stru_10232E788);
    }
    double v8 = qword_102418FD8;
    if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_ERROR))
    {
      double v9 = (void *)(a1 + 88);
      if (*(char *)(a1 + 111) < 0) {
        double v9 = (void *)*v9;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      long long v24 = "";
      __int16 v25 = 1026;
      int v26 = (int)v19[0];
      __int16 v27 = 2082;
      long long v28 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CL database error, record contains invalid time\", \"invalid time\":%{public}d, \"name\":%{public, location:escape_only}s}", buf, 0x22u);
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_10232E788);
      }
    }
    __n128 v10 = qword_102418FD8;
    if (os_signpost_enabled((os_log_t)qword_102418FD8))
    {
      uint64_t v11 = (void *)(a1 + 88);
      if (*(char *)(a1 + 111) < 0) {
        uint64_t v11 = (void *)*v11;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      long long v24 = "";
      __int16 v25 = 1026;
      int v26 = (int)v19[0];
      __int16 v27 = 2082;
      long long v28 = v11;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CL database error, record contains invalid time", "{\"msg%{public}.0s\":\"CL database error, record contains invalid time\", \"invalid time\":%{public}d, \"name\":%{public, location:escape_only}s}", buf, 0x22u);
    }
  }
  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24))(v5, v7);
}

void sub_1001A7940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A796C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1001A662C(*(void *)(a1 + 24), a2);
  if (!*(unsigned char *)(a1 + 41))
  {
    uint64_t result = sub_100082064(*(void *)(a1 + 24) + 72);
    if (result)
    {
      *(unsigned char *)(a1 + 41) = 1;
      return sub_1004A0BC4(a1);
    }
  }
  return result;
}

uint64_t sub_1001A79D4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1001A73FC(*(void *)(a1 + 24), a2);
  if (!*(unsigned char *)(a1 + 41))
  {
    uint64_t result = sub_100082064(*(void *)(a1 + 24) + 72);
    if (result)
    {
      *(unsigned char *)(a1 + 41) = 1;
      return sub_10158724C(a1);
    }
  }
  return result;
}

uint64_t sub_1001A7A3C(uint64_t a1, uint64_t a2, double a3)
{
  sub_100176CA0(v14, a2);
  char v6 = (*(uint64_t (**)(uint64_t, unsigned char *, double))(*(void *)a1 + 120))(a1, v14, a3);
  if (v14[32]) {
    sub_100178B14((uint64_t)v14);
  }
  if ((v6 & 1) == 0
    || ((*(uint64_t (**)(void))(**(void **)(a1 + 40) + 80))(*(void *)(a1 + 40)) & 1) != 0)
  {
    return 0;
  }
  double v8 = *(void **)(a1 + 24);
  if (v8)
  {
    [*(id *)(a1 + 24) setArchive:[*(id *)(a1 + 32) archiveForHarvester:10 withSuffix:(*(uint64_t (**)(uint64_t, id))(*(void *)a1 + 128))(a1, objc_msgSend(v8, "index"))]];
  }
  else
  {
    id v9 = [*(id *)(a1 + 8) count];
    __n128 v10 = [[CLHarvestScoredRequestArchive alloc] initWithArchive:[*(id *)(a1 + 32) archiveForHarvester:10 withSuffix:v9] index:v9];
    *(void *)(a1 + 24) = v10;
    [*(id *)(a1 + 8) addObject:v10];
  }
  [objc_msgSend(*(id *)(a1 + 24), "archive") eraseAllData];
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
  uint64_t v12 = *(void *)(a1 + 40);
  sub_100176CA0(v13, a2);
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v11 + 16))(v11, v12, v13);
  if (v13[32]) {
    sub_100178B14((uint64_t)v13);
  }
  *(double *)(a1 + 16) = a3;
  (*(void (**)(uint64_t))(*(void *)a1 + 136))(a1);
  return 1;
}

void sub_1001A7C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a13) {
    sub_100178B14((uint64_t)&a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001A7CCC(uint64_t a1, int a2)
{
  if (a2 <= 5)
  {
    sub_10017C384(__p, 6uLL);
    *((_DWORD *)__p[0] + a2) = 1;
    sub_100199BFC(*(void *)(a1 + 920), __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1001A7D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001A7D50(uint64_t a1)
{
  uint64_t v2 = a1 + 608;
  if (sub_1001862DC(a1 + 608))
  {
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 160))(*(void *)(a1 + 56)))
    {
      uint64_t v3 = *(void *)(a1 + 1376);
      if (v3)
      {
        uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
        v6[0] = _NSConcreteStackBlock;
        v6[1] = 3221225472;
        _DWORD v6[2] = sub_100D4CAAC;
        v6[3] = &unk_1022F4440;
        v6[4] = v4;
        void v6[5] = a1;
        sub_101094C88(v2, (uint64_t)v6);
      }
    }
    else
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_1022F4580);
      }
      uint64_t v5 = qword_102419568;
      if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
      {
        sub_10012FD50(a1);
        *(_DWORD *)uint64_t buf = 68289282;
        int v8 = 0;
        __int16 v9 = 2082;
        __n128 v10 = "";
        __int16 v11 = 2050;
        uint64_t v12 = sub_10012FD50(a1);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvesting is not allowed, not harvesting\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}", buf, 0x1Cu);
      }
    }
  }
}

uint64_t sub_1001A7F0C(uint64_t a1, uint64_t a2)
{
  double v4 = (*(double (**)(void))(**(void **)(a1 + 56) + 64))(*(void *)(a1 + 56));
  sub_100176CA0(v12, a1 + 1384);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, unsigned char *, double))(*(void *)a2 + 16))(a2, v12, v4);
  if (v12[32]) {
    sub_100178B14((uint64_t)v12);
  }
  if (v5)
  {
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_1022F4580);
    }
    char v6 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
      *(_DWORD *)uint64_t buf = 138412290;
      uint64_t v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "%@ starting trace", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_1022F4580);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
      int v13 = 138412290;
      uint64_t v14 = v10;
      __int16 v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLSubHarvesterTrace::startTrace(CLTraceHarvestInterface::Archiver &)", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    *(unsigned char *)(a1 + 904) = 1;
    *(void *)(a1 + 1376) = a2;
    int v8 = (void *)(a1 + 608);
    sub_1010932AC((uint64_t)v8);
    sub_1010938DC(v8);
  }
  return v5;
}

void sub_1001A81C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a16) {
    sub_100178B14((uint64_t)&a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001A81E8(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  switch(*a3)
  {
    case 0:
      uint64_t v10 = (void *)(a1 + 1464);
      sub_10017D960(v10, (long long *)a4);
      break;
    case 1:
      uint64_t v11 = *(void *)(a1 + 6568);
      if (v11 != *(void *)(a4 + 144))
      {
        int v12 = *(_DWORD *)(a1 + 6616);
        sub_100103240();
        int v13 = sub_10010145C();
        unsigned int v14 = sub_10092C998(*(void *)(a4 + 144));
        unsigned int v15 = (0x304001u >> v14) & 1;
        if (v14 > 0x15) {
          unsigned int v15 = 0;
        }
        if (!v12) {
          unsigned int v15 = 0;
        }
        if (v13) {
          int v16 = v15;
        }
        else {
          int v16 = 0;
        }
        sub_10157C34C(*(unsigned __int8 **)(a1 + 128), v16);
        sub_10157C83C(*(void *)(a1 + 128), *(void *)(a4 + 144));
        uint64_t v11 = *(void *)(a4 + 144);
      }
      *(void *)(a1 + 6568) = v11;
      sub_100D4223C(a1 + 776, (int *)a4);
      sub_100103240();
      if (sub_10010145C()) {
        sub_101588188(a1);
      }
      if (qword_102419030 != -1) {
        dispatch_once(&qword_102419030, &stru_10232E540);
      }
      double v17 = qword_102419038;
      if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_INFO))
      {
        uint64_t v18 = *(void *)(a1 + 6568);
        LODWORD(buf[0]) = 134217984;
        *(void *)((char *)buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "step counting overrideActivityType,%lu,", (uint8_t *)buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10232E540);
        }
        __int16 v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLStepCountNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v9);
        goto LABEL_32;
      }
      break;
    case 2:
      sub_1010F7C5C(a1 + 2928, a4);
      if (*(void *)(a4 + 224) == 1 && *(void *)(a4 + 16) == 1)
      {
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10232E540);
        }
        __int16 v20 = qword_102419038;
        if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_INFO))
        {
          uint64_t v21 = *(void *)(a4 + 112);
          LODWORD(buf[0]) = 134217984;
          *(void *)((char *)buf + 4) = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Flushing buffered step distance on workout end, workout type, %lu", (uint8_t *)buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419030 != -1) {
            dispatch_once(&qword_102419030, &stru_10232E540);
          }
          int v22 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLStepCountNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v22);
          if (v22 != (char *)buf) {
            free(v22);
          }
        }
        sub_100D42140(a1 + 776, (uint64_t)buf);
        sub_100038FAC((unsigned char *)a1, (uint64_t *)buf);
        if (*(void *)&buf[0])
        {
          *((void *)&buf[0] + 1) = *(void *)&buf[0];
          operator delete(*(void **)&buf[0]);
        }
      }
      sub_100D42484(a1 + 776, a4);
      sub_101587F08(a1, a4);
      break;
    case 3:
    case 4:
    case 5:
      if (qword_102419030 != -1) {
        dispatch_once(&qword_102419030, &stru_10232E540);
      }
      uint64_t v7 = qword_102419038;
      if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_ERROR))
      {
        int v8 = *a3;
        LODWORD(buf[0]) = 67240192;
        DWORD1(buf[0]) = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unexpected CLMotionStateMediator_Type: %{public}d", (uint8_t *)buf, 8u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10232E540);
        }
        __int16 v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLStepCountNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v9);
LABEL_32:
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
      break;
    default:
      return;
  }
}

void sub_1001A8794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001A87B8(uint64_t a1)
{
  if (*(void *)a1)
  {
    if (std::uncaught_exceptions() <= *(_DWORD *)(a1 + 32)) {
      sub_1001A8968((sqlite3 **)a1);
    }
    else {
      sub_100DDEA68((sqlite3 **)a1);
    }
  }
  if (*(unsigned char *)(a1 + 25))
  {
    if (*(unsigned char *)(a1 + 24)) {
      pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 16));
    }
    else {
      (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
    }
    *(unsigned char *)(a1 + 25) = 0;
  }
  return a1;
}

uint64_t sub_1001A8898(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
  *(_WORD *)(a1 + 24) = 256;
  *(_DWORD *)(a1 + 32) = std::uncaught_exceptions();
  if (a2)
  {
    sub_1001A8B78((sqlite3 **)a1);
    return a1;
  }
  else
  {
    sub_101A8F360();
    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_1001A8950(_Unwind_Exception *a1)
{
  sub_1019DB560(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A8968(sqlite3 **a1)
{
  uint64_t result = sqlite3_exec(*a1, "COMMIT", 0, 0, 0);
  if (result)
  {
    if (qword_1024195E0 != -1) {
      dispatch_once(&qword_1024195E0, &stru_1022F87A0);
    }
    uint64_t v3 = off_1024195E8;
    if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#sqlitetransaction, commit failed", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024195E0 != -1) {
        dispatch_once(&qword_1024195E0, &stru_1022F87A0);
      }
      char v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLSqliteTransaction::commit()", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    sub_100DDEDA8(a1, *a1, (uint64_t)buf);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x48uLL);
    sub_100DDF050(exception, (uint64_t)buf);
  }
  return result;
}

void sub_1001A8B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
}

uint64_t sub_1001A8B78(sqlite3 **a1)
{
  uint64_t result = sqlite3_exec(*a1, "BEGIN EXCLUSIVE TRANSACTION", 0, 0, 0);
  if (result)
  {
    if (qword_1024195E0 != -1) {
      dispatch_once(&qword_1024195E0, &stru_1022F87A0);
    }
    uint64_t v3 = off_1024195E8;
    if (os_log_type_enabled((os_log_t)off_1024195E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#sqlitetransaction, begin exclusive transaction failed", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024195E0 != -1) {
        dispatch_once(&qword_1024195E0, &stru_1022F87A0);
      }
      char v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLSqliteTransaction::beginTransaction()", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    sub_100DDEDA8(a1, *a1, (uint64_t)buf);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x48uLL);
    sub_100DDF050(exception, (uint64_t)buf);
  }
  return result;
}

void sub_1001A8D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
}

void sub_1001A8D88(uint64_t a1, uint64_t a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102301E60);
  }
  double v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)uint64_t buf = 67240192;
    int v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#CLProactiveLoc,active,%{public}d,updateSessionInfo", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301E60);
    }
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveLocation::updateProactiveLocationSessionInfo(const CLDaemonLocation &)", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  if (sub_1000E6DB4(a2)
    && (*(_DWORD *)(a2 + 96) & 0xFFFFFFF7) == 1
    && *(unsigned char *)(a1 + 72)
    && !*(unsigned char *)(a1 + 136))
  {
    *(unsigned char *)(a1 + 136) = 1;
    uint64_t v6 = sub_10016BA10();
    *(_DWORD *)uint64_t buf = 1;
    *(double *)(a1 + 128) = sub_10016BA54(v6, buf);
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 56);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301E60);
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(unsigned __int8 *)(a1 + 72);
      int v9 = *(unsigned __int8 *)(a1 + 136);
      int v10 = *(_DWORD *)(a1 + 140);
      *(_DWORD *)uint64_t buf = 67240704;
      int v14 = v8;
      __int16 v15 = 1026;
      int v16 = v9;
      __int16 v17 = 1026;
      int v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#CLProactiveLoc,active,%{public}d,updateSessionInfo,yield,%{public}d,rateOverrideAttempts,%{public}d", buf, 0x14u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102301E60);
      }
      int v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveLocation::updateProactiveLocationSessionInfo(const CLDaemonLocation &)", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
  }
}

BOOL sub_1001A9118(uint64_t a1, uint64_t a2)
{
  if (!sub_1000E6DB4(a2) || (double v4 = *(double *)(a2 + 20), v4 <= 0.0))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301E60);
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *(unsigned __int8 *)(a1 + 72);
      *(_DWORD *)uint64_t buf = 67240192;
      int v27 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#CLProactiveLoc,active,%{public}d,isPositionFixConverged,invalid,fix", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102301E60);
      }
      __int16 v25 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLProactiveLocation::isPositionFixConverged(const CLDaemonLocation &)", "%s\n", v25);
      if (v25 != (char *)buf) {
        free(v25);
      }
    }
    return 0;
  }
  if ((*(_DWORD *)(a2 + 96) & 0xFFFFFFF7) != 1) {
    return 0;
  }
  v6 = *(double *)(a2 + 44) < 0.0 || (double v5 = *(double *)(a2 + 52), v5 <= 0.0) || v5 >= *(double *)(a1 + 16);
  v12 = *(double *)(a2 + 60) >= 0.0 && (double v11 = *(double *)(a2 + 68), v11 > 0.0) && v11 < *(double *)(a1 + 24);
  if (v4 >= *(double *)(a1 + 8)) {
    BOOL v6 = 1;
  }
  BOOL v9 = !v6;
  if (!v6 && !v12) {
    BOOL v9 = *(unsigned char *)(a1 + 74) != 0;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_102301E60);
  }
  int v13 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v14 = *(unsigned __int8 *)(a1 + 72);
    int v15 = *(_DWORD *)(a2 + 96);
    uint64_t v16 = *(void *)(a2 + 4);
    uint64_t v17 = *(void *)(a2 + 12);
    uint64_t v18 = *(void *)(a2 + 20);
    uint64_t v19 = *(void *)(a2 + 44);
    uint64_t v20 = *(void *)(a2 + 52);
    uint64_t v21 = *(void *)(a2 + 60);
    uint64_t v22 = *(void *)(a2 + 68);
    int v23 = *(unsigned __int8 *)(a1 + 73);
    *(_DWORD *)uint64_t buf = 67242753;
    int v27 = v14;
    __int16 v28 = 1026;
    int v29 = v15;
    __int16 v30 = 2049;
    uint64_t v31 = v16;
    __int16 v32 = 2049;
    uint64_t v33 = v17;
    __int16 v34 = 2049;
    uint64_t v35 = v18;
    __int16 v36 = 2049;
    uint64_t v37 = v19;
    __int16 v38 = 2049;
    uint64_t v39 = v20;
    __int16 v40 = 2049;
    uint64_t v41 = v21;
    __int16 v42 = 2049;
    uint64_t v43 = v22;
    __int16 v44 = 1025;
    int v45 = v23;
    __int16 v46 = 1026;
    BOOL v47 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#CLProactiveLoc,active,%{public}d,isPositionFixConverged,type,%{public}d,lat,%{private}0.2f,lon,%{private}0.2f,hunc,%{private}0.2f,speed,%{private}0.2f,sunc,%{private}0.2f,course,%{private}0.2f,courseunc,%{private}0.2f,outvisit,%{private}d,convergedFix,%{public}d", buf, 0x60u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301E60);
    }
    long long v24 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLProactiveLocation::isPositionFixConverged(const CLDaemonLocation &)", "%s\n", v24);
    if (v24 != (char *)buf) {
      free(v24);
    }
  }
  return v9;
}

void sub_1001A95D8(uint64_t a1, uint64_t a2, double a3)
{
  sub_1001A8D88(a1, a2);
  if (sub_1001A9118(a1, a2))
  {
    *(double *)(a1 + 96) = a3;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_102301E60);
    }
    BOOL v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(unsigned __int8 *)(a1 + 72);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 67240448;
      int v11 = v7;
      __int16 v12 = 2050;
      uint64_t v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#CLProactiveLoc,active,%{public}d,feedLocation,fixConvergedMCT,%{public}0.2f", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_102301E60);
      }
      BOOL v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveLocation::feedLocation(const CLDaemonLocation &, const CFTimeInterval)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    sub_100EDB628(a1, 7);
  }
}

void *sub_1001A97E0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  snprintf(__str, 0x200uLL, "Act Dur(s), %.2f, Step Dur(s), %.2f, Step Counts, %d, Step Begin, %.2f, Step End, %.2f, distance, %.2f, Speed, %.2f, Grade type, %d, vertical speed, %.3f, HR, %f, HRConf, %f, coarse elevation, %d, rawHR, %f, rawHRConf, %f", *(double *)(a1 + 128) - *(double *)(a1 + 120), *(double *)(a1 + 136), *(_DWORD *)(a1 + 400), *(double *)(a1 + 1336), *(double *)(a1 + 1344), *(double *)(a1 + 624), *(double *)(a1 + 648), *(_DWORD *)(a1 + 832), *(double *)(a1 + 840), *(double *)(a1 + 560), *(double *)(a1 + 568), *(_DWORD *)(a1 + 1032), *(double *)(a1 + 1312), *(double *)(a1 + 1320));
  return sub_100134750(a2, __str);
}

uint64_t sub_1001A98B4(uint64_t a1, double a2)
{
  long long v105 = 0u;
  unsigned long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  *(double *)(a1 + 120) = a2;
  *(double *)(a1 + 128) = a2;
  *(double *)(a1 + 112) = a2;
  if ((*(uint64_t (**)(void, long long *, long long *, __n128))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), &v105, &v103, (__n128)*(unint64_t *)&a2))
  {
    uint64_t v4 = *((void *)&v106 + 1);
    unsigned long long v7 = v106;
    uint64_t v6 = v7 >> 64;
    double v5 = (void *)v7;
    if (*((void *)&v106 + 1) == *(void *)v106) {
      uint64_t v6 = *(void *)(v106 - 8) + 3944;
    }
    long long v8 = *(_OWORD *)(v6 - 232);
    long long v9 = *(_OWORD *)(v6 - 200);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(v6 - 216);
    *(_OWORD *)(a1 + 176) = v9;
    *(_OWORD *)(a1 + 144) = v8;
    long long v10 = *(_OWORD *)(v6 - 184);
    long long v11 = *(_OWORD *)(v6 - 168);
    long long v12 = *(_OWORD *)(v6 - 136);
    *(_OWORD *)(a1 + 224) = *(_OWORD *)(v6 - 152);
    *(_OWORD *)(a1 + 240) = v12;
    *(_OWORD *)(a1 + 192) = v10;
    *(_OWORD *)(a1 + 208) = v11;
    long long v13 = *(_OWORD *)(v6 - 120);
    long long v14 = *(_OWORD *)(v6 - 104);
    long long v15 = *(_OWORD *)(v6 - 72);
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(v6 - 88);
    *(_OWORD *)(a1 + 304) = v15;
    *(_OWORD *)(a1 + 256) = v13;
    *(_OWORD *)(a1 + 272) = v14;
    long long v16 = *(_OWORD *)(v6 - 56);
    long long v17 = *(_OWORD *)(v6 - 40);
    long long v18 = *(_OWORD *)(v6 - 24);
    *(void *)(a1 + 368) = *(void *)(v6 - 8);
    *(_OWORD *)(a1 + 336) = v17;
    *(_OWORD *)(a1 + 352) = v18;
    *(_OWORD *)(a1 + 320) = v16;
    if (v4 == *v5)
    {
      uint64_t v21 = *--v5;
      double v19 = *(double *)(v21 + 3712);
      *(void *)&unsigned long long v106 = v5;
      uint64_t v4 = *v5 + 3944;
    }
    else
    {
      double v19 = *(double *)(v4 - 232);
    }
    *(double *)(a1 + 120) = v19;
    *(double *)(a1 + 128) = v19;
    uint64_t v22 = v4 - 232;
    *((void *)&v106 + 1) = v22;
    if (v22 == *((void *)&v104 + 1))
    {
      double v20 = v19;
    }
    else
    {
      if (v22 == *v5) {
        uint64_t v22 = *(v5 - 1) + 3944;
      }
      double v20 = *(double *)(v22 - 232);
      *(double *)(a1 + 120) = v20;
    }
  }
  else
  {
    double v20 = *(double *)(a1 + 120);
    double v19 = *(double *)(a1 + 128);
  }
  if (v19 - v20 < 0.1)
  {
    double v23 = -2.56;
LABEL_22:
    double v20 = v19 + v23;
    *(double *)(a1 + 120) = v20;
    goto LABEL_23;
  }
  if (v19 - v20 > 10.24)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022BEC00);
    }
    long long v24 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      double v25 = *(double *)(a1 + 120);
      uint64_t v26 = *(void *)(a1 + 128);
      *(_DWORD *)uint64_t buf = 134218240;
      double v118 = v25;
      __int16 v119 = 2048;
      uint64_t v120 = v26;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "ModelInput, Larger than expected gap between begin and end ts.  Setting end ts to some sane default. (%f, %f)", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022BEC00);
      }
      double v96 = *(double *)(a1 + 120);
      uint64_t v97 = *(void *)(a1 + 128);
      int v107 = 134218240;
      double v108 = v96;
      __int16 v109 = 2048;
      uint64_t v110 = v97;
      uint64_t v98 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLNatalieModelInput::setTime(CFAbsoluteTime)", "%s\n", v98);
      if (v98 != (char *)buf) {
        free(v98);
      }
    }
    double v19 = *(double *)(a1 + 128);
    double v23 = -10.24;
    goto LABEL_22;
  }
LABEL_23:
  *(double *)(a1 + 136) = v19 - v20;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  if ((*(unsigned int (**)(void, long long *, long long *, double))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v101, &v99, a2))
  {
    uint64_t v27 = *((void *)&v102 + 1);
    if (*((void *)&v102 + 1) != *((void *)&v100 + 1))
    {
      __int16 v28 = (uint64_t *)v102;
      uint64_t v29 = *(void *)v102;
      uint64_t v30 = *(void *)v102;
      uint64_t v32 = *((void *)&v102 + 1);
      uint64_t v31 = (uint64_t *)v102;
      while (1)
      {
        uint64_t v33 = *((void *)&v102 + 1);
        if (*((void *)&v102 + 1) == v29) {
          uint64_t v33 = *(void *)(v102 - 8) + 4048;
        }
        uint64_t v34 = v32;
        if (v32 == v30) {
          uint64_t v34 = *(v31 - 1) + 4048;
        }
        if (*(double *)(v33 - 168) - *(double *)(v34 - 168) > 0.0)
        {
          uint64_t v35 = *((void *)&v102 + 1);
          if (*((void *)&v102 + 1) == v29) {
            uint64_t v35 = *(void *)(v102 - 8) + 4048;
          }
          uint64_t v36 = v32;
          if (v32 == v30) {
            uint64_t v36 = *(v31 - 1) + 4048;
          }
          if (*(double *)(v35 - 168) - *(double *)(v36 - 168) < 60.0)
          {
            uint64_t v37 = *((void *)&v102 + 1);
            if (*((void *)&v102 + 1) == v29) {
              uint64_t v37 = *(void *)(v102 - 8) + 4048;
            }
            uint64_t v38 = v32;
            if (v32 == v30) {
              uint64_t v38 = *(v31 - 1) + 4048;
            }
            if (*(double *)(v37 - 168) - *(double *)(v38 - 168) > *(double *)(a1 + 128) - *(double *)(a1 + 120) + -1.0) {
              break;
            }
          }
        }
        if (v32 == v30)
        {
          uint64_t v39 = *--v31;
          uint64_t v30 = v39;
          uint64_t v32 = v39 + 4048;
        }
        v32 -= 176;
        if (v32 == *((void *)&v100 + 1)) {
          goto LABEL_93;
        }
      }
      if (*((void *)&v102 + 1) == v29)
      {
        __int16 v44 = *(void **)(v102 - 8);
        __int16 v40 = v44 + 484;
        uint64_t v41 = v44 + 485;
        __int16 v42 = v44 + 486;
        uint64_t v43 = v44 + 506;
      }
      else
      {
        __int16 v40 = (void *)(*((void *)&v102 + 1) - 176);
        uint64_t v41 = (uint64_t *)(*((void *)&v102 + 1) - 168);
        __int16 v42 = (uint64_t *)(*((void *)&v102 + 1) - 160);
        uint64_t v43 = (void *)*((void *)&v102 + 1);
      }
      uint64_t v45 = *v42;
      uint64_t v46 = *v41;
      *(void *)(a1 + 376) = *v40;
      *(void *)(a1 + 384) = v46;
      *(void *)(a1 + 392) = v45;
      uint64_t v47 = v32;
      if (v32 == v30) {
        uint64_t v47 = *(v31 - 1) + 4048;
      }
      *(_DWORD *)(a1 + 400) = *((_DWORD *)v43 - 38) - *(_DWORD *)(v47 - 152);
      uint64_t v48 = v27;
      if (v27 == v29) {
        uint64_t v48 = *(v28 - 1) + 4048;
      }
      double v49 = *(double *)(v48 - 144);
      uint64_t v50 = v32;
      if (v32 == v30) {
        uint64_t v50 = *(v31 - 1) + 4048;
      }
      *(double *)(a1 + 408) = v49 - *(double *)(v50 - 144);
      uint64_t v51 = v27;
      if (v27 == v29) {
        uint64_t v51 = *(v28 - 1) + 4048;
      }
      double v52 = *(double *)(v51 - 136);
      uint64_t v53 = v32;
      if (v32 == v30) {
        uint64_t v53 = *(v31 - 1) + 4048;
      }
      *(double *)(a1 + 416) = v52 - *(double *)(v53 - 136);
      uint64_t v54 = v27;
      if (v27 == v29) {
        uint64_t v54 = *(v28 - 1) + 4048;
      }
      int v55 = *(_DWORD *)(v54 - 112);
      uint64_t v56 = v32;
      if (v32 == v30) {
        uint64_t v56 = *(v31 - 1) + 4048;
      }
      *(_DWORD *)(a1 + 440) = v55 - *(_DWORD *)(v56 - 112);
      uint64_t v57 = v27;
      if (v27 == v29) {
        uint64_t v57 = *(v28 - 1) + 4048;
      }
      int v58 = *(_DWORD *)(v57 - 108);
      uint64_t v59 = v32;
      if (v32 == v30) {
        uint64_t v59 = *(v31 - 1) + 4048;
      }
      *(_DWORD *)(a1 + 444) = v58 - *(_DWORD *)(v59 - 108);
      if (v27 == v29)
      {
        uint64_t v63 = *(v28 - 1);
        __int16 v60 = (void *)(v63 + 3944);
        uint64_t v61 = (uint64_t *)(v63 + 3952);
        uint64_t v62 = v63 + 4048;
      }
      else
      {
        __int16 v60 = (void *)(v27 - 104);
        uint64_t v61 = (uint64_t *)(v27 - 96);
        uint64_t v62 = v27;
      }
      uint64_t v64 = *v61;
      *(void *)(a1 + 448) = *v60;
      *(void *)(a1 + 456) = v64;
      uint64_t v65 = v32;
      if (v32 == v30) {
        uint64_t v65 = *(v31 - 1) + 4048;
      }
      *(double *)(a1 + 464) = *(double *)(v62 - 88) - *(double *)(v65 - 88);
      *(_DWORD *)(a1 + 472) = -1;
      *(void *)(a1 + 480) = 0;
      if (v27 == *v28)
      {
        uint64_t v68 = *(v28 - 1);
        unint64_t v66 = (unsigned char *)(v68 + 3984);
        uint64_t v67 = v68 + 4048;
      }
      else
      {
        unint64_t v66 = (unsigned char *)(v27 - 64);
        uint64_t v67 = v27;
      }
      *(unsigned char *)(a1 + 488) = *v66;
      *(unsigned char *)(a1 + 489) = *(unsigned char *)(v67 - 63);
      *(void *)(a1 + 504) = 0;
      *(void *)(a1 + 512) = 0;
      *(void *)(a1 + 496) = 0;
      uint64_t v69 = *v28;
      uint64_t v70 = v27;
      if (v27 == *v28) {
        uint64_t v70 = *(v28 - 1) + 4048;
      }
      int v71 = *(_DWORD *)(v70 - 32);
      uint64_t v72 = *v31;
      uint64_t v73 = v32;
      if (v32 == *v31) {
        uint64_t v73 = *(v31 - 1) + 4048;
      }
      *(_DWORD *)(a1 + 520) = v71 - *(_DWORD *)(v73 - 32);
      if (v27 == v69)
      {
        uint64_t v77 = *(v28 - 1);
        __int16 v74 = (_DWORD *)(v77 + 4020);
        double v75 = (char *)(v77 + 4024);
        uint64_t v76 = v77 + 4048;
      }
      else
      {
        __int16 v74 = (_DWORD *)(v27 - 28);
        double v75 = (char *)(v27 - 24);
        uint64_t v76 = v27;
      }
      char v78 = *v75;
      *(_DWORD *)(a1 + 524) = *v74;
      *(unsigned char *)(a1 + 528) = v78;
      uint64_t v79 = v32;
      if (v32 == v72) {
        uint64_t v79 = *(v31 - 1) + 4048;
      }
      *(double *)(a1 + 136) = *(double *)(v76 - 168) - *(double *)(v79 - 168);
      uint64_t v80 = v27;
      if (v27 == v69) {
        uint64_t v80 = *(v28 - 1) + 4048;
      }
      *(void *)(a1 + 1344) = *(void *)(v80 - 168);
      uint64_t v81 = v32;
      if (v32 == v72) {
        uint64_t v81 = *(v31 - 1) + 4048;
      }
      *(void *)(a1 + 1336) = *(void *)(v81 - 168);
      if (v27 == v69)
      {
        uint64_t v83 = *(v28 - 1);
        int v82 = (unsigned char *)(v83 + 4038);
        uint64_t v27 = v83 + 4048;
      }
      else
      {
        int v82 = (unsigned char *)(v27 - 10);
      }
      *(unsigned char *)(a1 + 542) = *v82;
      int v84 = *(_DWORD *)(v27 - 32);
      if (v32 == v72) {
        uint64_t v32 = *(v31 - 1) + 4048;
      }
      *(_DWORD *)(a1 + 520) = v84 - *(_DWORD *)(v32 - 32);
    }
  }
LABEL_93:
  if (*(double *)(a1 + 136) < 0.1) {
    *(void *)(a1 + 136) = 0x3FF0000000000000;
  }
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), a1 + 552, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104), a1 + 1304, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 24) + 24))(*(void *)(a1 + 24), a1 + 808, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), a1 + 1024, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 56) + 24))(*(void *)(a1 + 56), a1 + 872, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), a1 + 616, a2);
  if (*(double *)(a1 + 616) > 0.0)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022BEC00);
    }
    __int16 v85 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v86 = *(void *)(a1 + 616);
      uint64_t v87 = *(void *)(a1 + 624);
      uint64_t v88 = *(void *)(a1 + 648);
      uint64_t v89 = *(void *)(a1 + 640);
      *(_DWORD *)uint64_t buf = 134219008;
      double v118 = a2;
      __int16 v119 = 2048;
      uint64_t v120 = v86;
      __int16 v121 = 2048;
      uint64_t v122 = v87;
      __int16 v123 = 2048;
      uint64_t v124 = v88;
      __int16 v125 = 2048;
      uint64_t v126 = v89;
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEBUG, "ModelInput, Event time, %.2f, GPS sample time, %.2f, distance, %.2f, speed, %.2f, altitude, %.2f", buf, 0x34u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022BEC00);
      }
      uint64_t v91 = *(void *)(a1 + 616);
      uint64_t v92 = *(void *)(a1 + 624);
      uint64_t v93 = *(void *)(a1 + 648);
      uint64_t v94 = *(void *)(a1 + 640);
      int v107 = 134219008;
      double v108 = a2;
      __int16 v109 = 2048;
      uint64_t v110 = v91;
      __int16 v111 = 2048;
      uint64_t v112 = v92;
      __int16 v113 = 2048;
      uint64_t v114 = v93;
      __int16 v115 = 2048;
      uint64_t v116 = v94;
      __int16 v95 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLNatalieModelInput::setTime(CFAbsoluteTime)", "%s\n", v95);
      if (v95 != (char *)buf) {
        free(v95);
      }
    }
  }
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), a1 + 1040, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), a1 + 1224, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72), a1 + 1208, a2);
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88), a1 + 1248, a2);
  return (*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 96) + 24))(*(void *)(a1 + 96), a1 + 1280, a2);
}

uint64_t sub_1001AA460(void **a1, double a2)
{
  (*(void (**)(void *))(*a1[1] + 40))(a1[1]);
  (*(void (**)(void *, double))(*a1[2] + 40))(a1[2], a2);
  (*(void (**)(void *, double))(*a1[3] + 40))(a1[3], a2);
  (*(void (**)(void *, double))(*a1[4] + 40))(a1[4], a2);
  (*(void (**)(void *, double))(*a1[5] + 40))(a1[5], a2);
  (*(void (**)(void *, double))(*a1[6] + 40))(a1[6], a2);
  (*(void (**)(void *, double))(*a1[7] + 40))(a1[7], a2);
  (*(void (**)(void *, double))(*a1[8] + 40))(a1[8], a2);
  (*(void (**)(void *, double))(*a1[9] + 40))(a1[9], a2);
  (*(void (**)(void *, double))(*a1[10] + 40))(a1[10], a2);
  (*(void (**)(void *, double))(*a1[11] + 40))(a1[11], a2);
  uint64_t v4 = *(uint64_t (**)(__n128))(*a1[12] + 40);
  v5.n128_f64[0] = a2;

  return v4(v5);
}

double sub_1001AA6A4@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_1022C05B0);
  }
  uint64_t v4 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a1 + 400);
    uint64_t v6 = *(void *)(a1 + 408);
    int v7 = *(_DWORD *)(a1 + 152);
    int v8 = *(_DWORD *)(a1 + 320);
    double v9 = *(float *)(a1 + 296);
    *(_DWORD *)uint64_t buf = 67110144;
    int v13 = v5;
    __int16 v14 = 2048;
    uint64_t v15 = v6;
    __int16 v16 = 1024;
    int v17 = v7;
    __int16 v18 = 1024;
    int v19 = v8;
    __int16 v20 = 2048;
    double v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Dummy, Static, step count: %d, step distance: %f, activity: %d, type: %d, vm: %f", buf, 0x28u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022C05B0);
    }
    long long v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMetsInfo CLNatalieDummyModel::computeMETS(const CLNatalieModelInput &)", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)&double result = 3;
  *(void *)(a2 + 32) = 3;
  return result;
}

float sub_1001AA8E8(float *a1, int a2)
{
  uint64_t v3 = (float *)((char *)&unk_101D99A00 + 20 * *(unsigned int *)a1);
  float v4 = a1[5];
  if (v4 >= 18.0) {
    float v5 = (float)((float)((float)(*v3 + (float)((float)(v3[2] * a1[2]) * 100.0)) + (float)(v3[1] * a1[3]))
  }
               + (float)(v3[3] * v4))
       / (float)(a1[3] * 24.0);
  else {
    float v5 = (float)((float)((float)((float)(*v3 + (float)((float)(v3[2] * a1[2]) * 100.0)) + (float)(v3[1] * a1[3]))
  }
                       + (float)(v3[3] * v4))
               / (float)(a1[3] * 24.0))
       + 0.001;
  unsigned int v6 = *((_DWORD *)a1 + 10);
  sub_100103240();
  if (sub_10010145C() && v6)
  {
    float v7 = fminf(v5, 1.0);
    if (a2)
    {
      char isTypeStatic = CLMotionActivity::isTypeStatic();
      float v9 = fmaxf(v7, 1.0);
      if ((isTypeStatic & 1) == 0) {
        return v9;
      }
    }
  }
  else
  {
    float v7 = fminf(v5, 2.1);
    if (a2 && (CLMotionActivity::isTypeStatic() & 1) == 0) {
      return fmaxf(v7, 1.3);
    }
  }
  return v7;
}

uint64_t sub_1001AA9D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a4 + 928))(a4);
}

void sub_1001AAA04(uint64_t a1, _DWORD *a2, void *__src)
{
  if (!*a2)
  {
    memcpy((void *)(a1 + 920), __src, 0x140uLL);
    uint64_t v4 = sub_1000D3E78();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    int v5[2] = sub_1010E0A24;
    v5[3] = &unk_1022A3020;
    v5[4] = a1;
    sub_1009E8F7C(v4, (uint64_t)v5);
  }
}

void sub_1001AAA98(uint64_t a1, int a2)
{
  LOBYTE(v6) = 80;
  HIBYTE(v6) = a2;
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_102310630);
  }
  uint64_t v4 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sending stair escalation toggle update to the AOP,should enable,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_102310630);
    }
    int v7 = 67109120;
    int v8 = a2;
    float v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMotionCoprocessor::enableStairsEscalation(BOOL)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  sub_10003B3E0(a1 + 192, &v6, 0);
}

void sub_1001AAC64(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 1272);
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[1];
    uint64_t v4 = *a2;
    float v5 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
    if (v5) {
      sub_1000DB0A0(v5);
    }
  }
}

void sub_1001AACC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001AACDC(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (*a2 == 22 || *a2 == 5) {
    sub_1001AAD48(a4, a2, a3);
  }
}

double sub_1001AACF8(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 653) && !*(unsigned char *)(a1 + 652))
  {
    sub_1010CE1FC(a1);
    *(unsigned char *)(a1 + 653) = 0;
  }
  return *(double *)(a1 + 664) + a2;
}

void sub_1001AAD48(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (*a2 == 5 || *a2 == 22 && sub_1010FB9FC(*(int **)(a3 + 800)))
  {
    long long v5 = *(_OWORD *)(a3 + 112);
    v40[6] = *(_OWORD *)(a3 + 96);
    v40[7] = v5;
    v41[0] = *(_OWORD *)(a3 + 128);
    *(_OWORD *)((char *)v41 + 12) = *(_OWORD *)(a3 + 140);
    long long v6 = *(_OWORD *)(a3 + 48);
    v40[2] = *(_OWORD *)(a3 + 32);
    v40[3] = v6;
    long long v7 = *(_OWORD *)(a3 + 80);
    v40[4] = *(_OWORD *)(a3 + 64);
    v40[5] = v7;
    long long v8 = *(_OWORD *)(a3 + 16);
    v40[0] = *(_OWORD *)a3;
    v40[1] = v8;
    unsigned int v9 = sub_1001AF22C((uint64_t)v40, *(double *)(a3 + 936));
    if (v9)
    {
      unsigned int v10 = v9;
      long long v11 = (double *)(a3 + 44);
      if (v9 == 2) {
        long long v11 = (double *)(a3 + 936);
      }
      double v12 = *v11;
      int v13 = (double *)(a3 + 952);
      if (v9 != 2) {
        int v13 = (double *)(a3 + 52);
      }
      float v14 = *v13;
      uint64_t v15 = (double *)(a3 + 944);
      if (v9 != 2) {
        uint64_t v15 = (double *)(a3 + 76);
      }
      float v16 = *v15;
      float v17 = CFAbsoluteTimeGetCurrent() - v16;
      if (v14 <= 0.0) {
        float v14 = 1.5;
      }
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_102310450);
      }
      float v18 = v12;
      float v19 = fabsf(v17);
      __int16 v20 = qword_102419018;
      if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(a3 + 76);
        uint64_t v22 = "Location derived speed";
        *(_DWORD *)uint64_t buf = 136316418;
        if (v10 == 1) {
          uint64_t v22 = "GPS speed";
        }
        uint64_t v53 = v22;
        *(_WORD *)uint64_t v54 = 2048;
        *(void *)&v54[2] = v21;
        *(_WORD *)&v54[10] = 2048;
        double v55 = v18;
        __int16 v56 = 2048;
        double v57 = v14;
        __int16 v58 = 1024;
        unsigned int v59 = v10;
        __int16 v60 = 2048;
        double v61 = v19;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%s accepted, timestamp, %f, speed, %f, speedUnc, %f, speedSource, %d, ageOfEstimation, %f", buf, 0x3Au);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419010 != -1) {
          dispatch_once(&qword_102419010, &stru_102310450);
        }
        uint64_t v36 = "Location derived speed";
        uint64_t v37 = *(void *)(a3 + 76);
        if (v10 == 1) {
          uint64_t v36 = "GPS speed";
        }
        int v42 = 136316418;
        uint64_t v43 = v36;
        *(_WORD *)__int16 v44 = 2048;
        *(void *)&v44[2] = v37;
        *(_WORD *)&v44[10] = 2048;
        double v45 = v18;
        __int16 v46 = 2048;
        double v47 = v14;
        __int16 v48 = 1024;
        unsigned int v49 = v10;
        __int16 v50 = 2048;
        double v51 = v19;
        uint64_t v38 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionCoprocessor::sendGpsSpeed(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v38);
        if (v38 != (char *)buf) {
          free(v38);
        }
      }
      double v23 = *(double *)(a3 + 116);
      if (v23 >= 0.0) {
        double v23 = sub_1004BB1CC(v23, (float)-*(float *)(a1 + 864));
      }
      float v24 = v23;
      buf[0] = 5;
      buf[1] = v10;
      *(_WORD *)&buf[2] = 0;
      if (v18 <= 128.0) {
        float v25 = v18;
      }
      else {
        float v25 = 128.0;
      }
      float v26 = v25 * 16777000.0;
      BOOL v27 = v25 < -128.0;
      float v28 = -2147500000.0;
      if (!v27) {
        float v28 = v26;
      }
      float v29 = 2147500000.0;
      if (v14 <= 128.0) {
        float v29 = v14 * 16777000.0;
      }
      int v30 = (int)v29;
      LODWORD(v53) = (int)v28;
      HIDWORD(v53) = (int)v29;
      float v31 = *(double *)(a3 + 68);
      *(float *)uint64_t v54 = v24;
      *(float *)&v54[4] = v31;
      *(float *)&_OWORD v54[8] = v19;
      sub_1010E79B0(a1 + 192, (long long *)buf, 0);
      float v39 = 0.0;
      if (sub_1010DFA50((void *)a1, v10 | ((unint64_t)LODWORD(v16) << 32), LODWORD(v18) | ((unint64_t)LODWORD(v14) << 32), &v39))
      {
        float v32 = v39;
        if (v39 > 128.0) {
          float v32 = 128.0;
        }
        float v33 = v32 * 16777000.0;
        BOOL v27 = v32 < -128.0;
        float v34 = -2147500000.0;
        if (!v27) {
          float v34 = v33;
        }
        int v42 = 1029;
        LODWORD(v43) = (int)v34;
        HIDWORD(v43) = v30;
        float v35 = *(double *)(a3 + 68);
        *(float *)__int16 v44 = v24;
        *(float *)&double v44[4] = v35;
        *(float *)&v44[8] = v19;
        sub_1010E79B0(a1 + 192, (long long *)&v42, 0);
      }
    }
  }
}

void sub_1001AB1C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 1256);
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[1];
    uint64_t v4 = *a2;
    long long v5 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
    if (v5) {
      sub_1000DB0A0(v5);
    }
  }
}

void sub_1001AB228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001AB240(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 56);
      if (v5) {
        sub_100099040(v5, (unsigned __int8 *)a1, (uint64_t *)(a1 + 24), *(_DWORD *)(a1 + 48), 0);
      }
      sub_1000DB0A0(v4);
    }
    long long v6 = *(std::__shared_weak_count **)(a1 + 64);
    if (v6) {
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

id sub_1001AB2D0(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = (uint64_t *)*a2;
  }
  uint64_t v4 = +[NSString stringWithUTF8String:v3];
  [objc_msgSend(*(id *)(a1 + 64), "objectForKeyedSubscript:", v4) invalidate];
  uint64_t v5 = *(void **)(a1 + 64);

  return [v5 setObject:0 forKeyedSubscript:v4];
}

void sub_1001AB33C(uint64_t a1, int a2, int a3, uint64_t a4)
{
  ++*(_DWORD *)(a1 + 348);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 160))(a1))
  {
    switch(a3)
    {
      case 5:
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 192))(a1, a4))
        {
          sub_1000C52B4(a1);
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472;
          _DWORD v15[2] = sub_1000D3024;
          v15[3] = &unk_1022BAA30;
          int v16 = a2;
          int v17 = 5;
          v15[4] = a1;
          v15[5] = a4;
          sub_1000C5414(a1, 1u, (uint64_t)v15);
          sub_1000C509C(a1);
        }
        break;
      case 46:
        if (qword_102419560 != -1) {
          dispatch_once(&qword_102419560, &stru_1022BABA0);
        }
        unsigned int v9 = qword_102419568;
        if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = *(_DWORD *)(a4 + 1512);
          uint64_t v11 = *(void *)(a4 + 1520);
          *(_DWORD *)uint64_t buf = 68289538;
          int v19 = 0;
          __int16 v20 = 2082;
          uint64_t v21 = "";
          __int16 v22 = 1026;
          LODWORD(v23[0]) = v10;
          WORD2(v23[0]) = 2050;
          *(void *)((char *)v23 + 6) = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLProactiveLoc ntfy\", \"sessionState\":%{public}d, \"sec_s\":\"%{public}.09f\"}", buf, 0x22u);
        }
        uint64_t v12 = *(void *)(a1 + 152);
        if (v12) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 112))(v12, a4 + 1512);
        }
        break;
      case 13:
        long long v8 = *(void (**)(uint64_t))(*(void *)a1 + 40);
        v8(a1);
        break;
      default:
        if (qword_102419560 != -1) {
          dispatch_once(&qword_102419560, &stru_1022BABA0);
        }
        int v13 = qword_102419568;
        if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)uint64_t buf = 68289283;
          int v19 = 0;
          __int16 v20 = 2082;
          uint64_t v21 = "";
          __int16 v22 = 2049;
          v23[0] = a3;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Harvester received an un-registered location notification\", \"notification\":%{private, location:CLLocationProvider_Type::Notification}lld}", buf, 0x1Cu);
          if (qword_102419560 != -1) {
            dispatch_once(&qword_102419560, &stru_1022BABA0);
          }
        }
        float v14 = qword_102419568;
        if (os_signpost_enabled((os_log_t)qword_102419568))
        {
          *(_DWORD *)uint64_t buf = 68289283;
          int v19 = 0;
          __int16 v20 = 2082;
          uint64_t v21 = "";
          __int16 v22 = 2049;
          v23[0] = a3;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Harvester received an un-registered location notification", "{\"msg%{public}.0s\":\"Harvester received an un-registered location notification\", \"notification\":%{private, location:CLLocationProvider_Type::Notification}lld}", buf, 0x1Cu);
        }
        break;
    }
  }
}

void sub_1001AB708(uint64_t *a1, uint64_t a2)
{
}

void sub_1001AB718(uint64_t a1, uint64_t *a2)
{
  int v27 = 0;
  *(_OWORD *)float v26 = *(_OWORD *)((char *)a2 + 12);
  *(void *)&v26[16] = *(uint64_t *)((char *)a2 + 28);
  LOBYTE(v27) = *((unsigned char *)a2 + 9) != 0;
  *(_DWORD *)(a1 + 1048) = *(_DWORD *)&v26[8];
  *(void *)(a1 + 1040) = *(void *)v26;
  *(_DWORD *)(a1 + 1060) = *(_DWORD *)&v26[20];
  *(void *)(a1 + 1052) = *(void *)&v26[12];
  *(unsigned char *)(a1 + 1064) = 1;
  float v4 = *((float *)a2 + 9);
  uint64_t v5 = *a2;
  uint64_t v6 = a1 + 1072;
  uint64_t v7 = *(void *)(a1 + 1080);
  if (v7 != a1 + 1072)
  {
    do
    {
      if (!*(unsigned char *)(v7 + 32))
      {
        (*(void (**)(void))(*(void *)(v7 + 24) + 16))();
        if (qword_1024190B0 != -1) {
          dispatch_once(&qword_1024190B0, &stru_10231D0A0);
        }
        long long v8 = off_1024190B8;
        if (os_log_type_enabled((os_log_t)off_1024190B8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = *(void *)(v7 + 16);
          *(_DWORD *)uint64_t buf = 134350848;
          double v45 = v4;
          __int16 v46 = 2050;
          double v47 = *(float *)v26;
          __int16 v48 = 2050;
          double v49 = *(float *)&v26[4];
          __int16 v50 = 2050;
          double v51 = *(float *)&v26[8];
          __int16 v52 = 2050;
          double v53 = *(float *)&v26[12];
          __int16 v54 = 2050;
          double v55 = *(float *)&v26[16];
          __int16 v56 = 2050;
          double v57 = *(float *)&v26[20];
          __int16 v58 = 2050;
          uint64_t v59 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "[CLGBE] SPUGyroBias,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p", buf, 0x52u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024190B0 != -1) {
            dispatch_once(&qword_1024190B0, &stru_10231D0A0);
          }
          uint64_t v10 = *(void *)(v7 + 16);
          int v28 = 134350848;
          double v29 = v4;
          __int16 v30 = 2050;
          double v31 = *(float *)v26;
          __int16 v32 = 2050;
          double v33 = *(float *)&v26[4];
          __int16 v34 = 2050;
          double v35 = *(float *)&v26[8];
          __int16 v36 = 2050;
          double v37 = *(float *)&v26[12];
          __int16 v38 = 2050;
          double v39 = *(float *)&v26[16];
          __int16 v40 = 2050;
          double v41 = *(float *)&v26[20];
          __int16 v42 = 2050;
          uint64_t v43 = v10;
          uint64_t v11 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)", "%s\n", v11);
          if (v11 != (char *)buf) {
            free(v11);
          }
        }
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v6);
  }
  if (!*(unsigned char *)(a1 + 1008))
  {
    int v12 = *((unsigned __int8 *)a2 + 10);
    if ((sub_1001B7CA8() & v12) == 1)
    {
      if (qword_1024190B0 != -1) {
        dispatch_once(&qword_1024190B0, &stru_10231D0A0);
      }
      int v13 = off_1024190B8;
      if (os_log_type_enabled((os_log_t)off_1024190B8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "[CLGBE] Ignoring bias estimate during charging", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024190B0 != -1) {
          dispatch_once(&qword_1024190B0, &stru_10231D0A0);
        }
        LOWORD(v28) = 0;
        float v14 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)", "%s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
      }
    }
    else
    {
      float v15 = *((float *)a2 + 5);
      float v16 = *((float *)a2 + 8);
      float32x2_t v17 = *(float32x2_t *)((char *)a2 + 12);
      float32x2_t v18 = (float32x2_t)a2[3];
      id v19 = [[objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLGyroCalibrationDatabase"];
      float32x2_t v20 = (float32x2_t)vdup_n_s32(0x42652EE1u);
      v21[1] = 3221225472;
      v21[0] = _NSConcreteStackBlock;
      _DWORD v21[2] = sub_10017A948;
      v21[3] = &unk_10231D070;
      void v21[5] = vmul_f32(v17, v20);
      float v22 = v15 * 57.296;
      float32x2_t v23 = vmul_f32(vmul_f32(v18, v20), v20);
      float v24 = (float)(v16 * 57.296) * 57.296;
      float v25 = v4;
      v21[4] = v5;
      [v19 doAsync:v21];
    }
  }
}

void sub_1001ABC6C(void *a1)
{
  sub_100010D2C(a1);

  operator delete();
}

uint64_t sub_1001ABCA8(uint64_t a1)
{
  if (!*(void *)(a1 + 48)) {
    sub_1001A0078();
  }
  return a1 + 48;
}

uint64_t sub_1001ABD68(uint64_t a1)
{
  if (!*(void *)(a1 + 56)) {
    sub_1001ABF24();
  }
  return a1 + 56;
}

double sub_1001ABE28(uint64_t a1, uint64_t a2, double *a3)
{
  double v4 = sub_1001ABE80((double *)(a1 + 4), a2, a3) - *(double *)(a1 + 20);
  if (*(void *)(a2 + 232) == *(void *)(a2 + 224)) {
    return v4 - sub_100044A78(a2);
  }
  return v4;
}

double sub_1001ABE80(double *a1, uint64_t a2, double *a3)
{
  if (*(void *)(a2 + 232) == *(void *)(a2 + 224)) {
    return sub_1000F1648(a3, *a1, a1[1], *(double *)(a2 + 72), *(double *)(a2 + 80), 0.0);
  }
  else {
    return sub_100BA9CFC((int8x16_t *)a1, a2 + 224, 0);
  }
}

uint64_t sub_1001ABEB0(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 96) > 0xEu) | (0x2C1Eu >> *(_DWORD *)(a1 + 96)) & 1;
}

double sub_1001ABED0(uint64_t a1)
{
  *(_DWORD *)a1 = -1;
  *(_WORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  __asm { FMOV            V1.2D, #-1.0 }
  *(_OWORD *)(a1 + 16) = xmmword_101D82D80;
  *(_OWORD *)(a1 + 32) = _Q1;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0xBFF0000000000000;
  double result = 0.0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0xBFF0000000000000;
  *(void *)(a1 + 80) = 0;
  return result;
}

BOOL sub_1001ABF10(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 96) & 0xFFFFFFFE) == 6;
}

void sub_1001ABF24()
{
}

void sub_1001ABFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_1001AC01C(uint64_t a1)
{
  sub_10000DC68(a1);

  operator delete();
}

uint64_t sub_1001AC054(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  uint64_t v7 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*v7);
  }
  long long v8 = a2[3];
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(_OWORD *)uint64_t v7 = v8;
  *((unsigned char *)a2 + 71) = 0;
  *((unsigned char *)a2 + 48) = 0;
  uint64_t v9 = *(void *)((char *)a2 + 181);
  long long v10 = *(long long *)((char *)a2 + 168);
  long long v11 = *(long long *)((char *)a2 + 152);
  *(_OWORD *)(a1 + 136) = *(long long *)((char *)a2 + 136);
  *(_OWORD *)(a1 + 152) = v11;
  *(_OWORD *)(a1 + 168) = v10;
  *(void *)(a1 + 181) = v9;
  long long v12 = *(long long *)((char *)a2 + 120);
  long long v13 = *(long long *)((char *)a2 + 104);
  long long v14 = *(long long *)((char *)a2 + 88);
  *(_OWORD *)(a1 + 72) = *(long long *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 88) = v14;
  *(_OWORD *)(a1 + 104) = v13;
  *(_OWORD *)(a1 + 120) = v12;
  float v15 = (void **)(a1 + 192);
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*v15);
  }
  long long v16 = a2[12];
  *(void *)(a1 + 208) = *((void *)a2 + 26);
  *(_OWORD *)float v15 = v16;
  *((unsigned char *)a2 + 215) = 0;
  *((unsigned char *)a2 + 192) = 0;
  float32x2_t v17 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  *((void *)a2 + 27) = 0;

  sub_1000F4EBC(a1 + 224, (__n128 *)a2 + 14);
  return a1;
}

void sub_1001AC198(uint64_t a1, uint64_t a2)
{
  sub_1001AA460(*(void ***)(a1 + 40), *(double *)a2);
  if (*(_DWORD *)(a2 + 8))
  {
    double v4 = sub_10017CCF0((void *)(a1 + 72), (double *)a2);
    (*(void (**)(void, uint64_t, double))(**(void **)(*(void *)(a1 + 40) + 48) + 32))(*(void *)(*(void *)(a1 + 40) + 48), a2, v4);
    sub_10007C1C8();
  }
}

void sub_1001AC230(uint64_t a1, int *a2)
{
  if (!*(unsigned char *)(a1 + 520) || *(unsigned char *)(a1 + 24)) {
    return;
  }
  double v4 = sub_10016C458();
  if (!*(unsigned char *)(a1 + 504) && (CLMotionActivity::isTypeWalking() & 1) == 0)
  {
    *(double *)(a1 + 496) = v4;
    *(unsigned char *)(a1 + 504) = 1;
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1022FD128);
    }
    long long v8 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(unsigned char *)(a1 + 504)) {
        goto LABEL_66;
      }
      uint64_t v9 = *(void *)(a1 + 496);
      int v10 = *a2;
      *(_DWORD *)uint64_t buf = 134218240;
      *(void *)double v33 = v9;
      *(_WORD *)&v33[8] = 1024;
      *(_DWORD *)&v33[10] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CLAS,user switched out of walking state,%.1lf,type,%d", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      if (!*(unsigned char *)(a1 + 504)) {
        sub_10020D700();
      }
      double v19 = *(double *)(a1 + 496);
      int v20 = *a2;
      int v26 = 134218240;
      double v27 = v19;
      __int16 v28 = 1024;
      LODWORD(v29) = v20;
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::reactivateEarlyWorkoutDetectionIfNecessary(const CLMotionActivity &)", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    goto LABEL_22;
  }
  if (CLMotionActivity::isTypeWalking() && *(unsigned char *)(a1 + 504))
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1022FD128);
    }
    uint64_t v5 = qword_1024191C8;
    if (!os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    if (*(unsigned char *)(a1 + 504))
    {
      uint64_t v6 = *(void *)(a1 + 496);
      int v7 = *a2;
      *(_DWORD *)uint64_t buf = 134218240;
      *(void *)double v33 = v6;
      *(_WORD *)&v33[8] = 1024;
      *(_DWORD *)&v33[10] = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CLAS,user switched back into walking state,%.1lf,type,%d", buf, 0x12u);
LABEL_13:
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191C0 != -1) {
          dispatch_once(&qword_1024191C0, &stru_1022FD128);
        }
        if (!*(unsigned char *)(a1 + 504)) {
          sub_10020D700();
        }
        double v16 = *(double *)(a1 + 496);
        int v17 = *a2;
        int v26 = 134218240;
        double v27 = v16;
        __int16 v28 = 1024;
        LODWORD(v29) = v17;
        float32x2_t v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::reactivateEarlyWorkoutDetectionIfNecessary(const CLMotionActivity &)", "%s\n", v18);
        if (v18 != (char *)buf) {
          free(v18);
        }
      }
      if (*(unsigned char *)(a1 + 504)) {
        *(unsigned char *)(a1 + 504) = 0;
      }
      goto LABEL_22;
    }
LABEL_66:
    sub_10020D700();
  }
LABEL_22:
  uint64_t v24 = 0x4088600000000000;
  uint64_t v25 = 0x405E000000000000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102481CA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102481CA8))
  {
    sub_101A1F180(buf, "kMaxTimeSinceLastWalkingStateBeforeResetEarlyWorkoutDetectionS", &v25, 0);
    qword_102481CA0 = *(void *)&v33[4];
    __cxa_guard_release(&qword_102481CA8);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102481CB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102481CB8))
  {
    sub_101A1F180(buf, "kMaxTimeSinceEscalationBeforeResetEarlyWorkoutDetectionS", &v24, 0);
    qword_102481CB0 = *(void *)&v33[4];
    __cxa_guard_release(&qword_102481CB8);
  }
  if (*(unsigned char *)(a1 + 504))
  {
    double v11 = vabdd_f64(v4, *(double *)(a1 + 496));
    if (v11 >= *(double *)&qword_102481CA0)
    {
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      long long v12 = qword_1024191C8;
      if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 134218240;
        *(double *)double v33 = v11;
        *(_WORD *)&v33[8] = 2048;
        *(void *)&v33[10] = qword_102481CA0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "CLAS,enable early workout detection due to non-walking timeout,timeSinceLastWalkingStateS,%.1lf,maxTimeSinceLastWalkingStateBeforeResetEarlyWorkoutDetectionS,%.0lf", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191C0 != -1) {
          dispatch_once(&qword_1024191C0, &stru_1022FD128);
        }
        int v26 = 134218240;
        double v27 = v11;
        __int16 v28 = 2048;
        uint64_t v29 = qword_102481CA0;
        float v15 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::reactivateEarlyWorkoutDetectionIfNecessary(const CLMotionActivity &)", "%s\n", v15);
        if (v15 != (char *)buf) {
          free(v15);
        }
      }
      sub_1004663C0(a1 + 1568, (void *)(a1 + 592), *(void *)(a1 + 512), *(void *)(a1 + 520), 0);
      sub_100E581B0(a1, 0);
      if (*(unsigned char *)(a1 + 504)) {
        *(unsigned char *)(a1 + 504) = 0;
      }
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 520)) {
      sub_10020D700();
    }
    if (v4 - *(double *)(a1 + 512) > *(double *)&qword_102481CB0)
    {
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      long long v13 = qword_1024191C8;
      if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
      {
        if (!*(unsigned char *)(a1 + 520)) {
          sub_10020D700();
        }
        uint64_t v14 = *(void *)(a1 + 512);
        *(_DWORD *)uint64_t buf = 134349568;
        *(void *)double v33 = v14;
        *(_WORD *)&v33[8] = 2050;
        *(double *)&v33[10] = v4;
        __int16 v34 = 2048;
        uint64_t v35 = qword_102481CB0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "CLAS,enable early workout detection due to time out since first escalated,last update,%{public}.1lf,current time,%{public}.1lf,maxTimeInSecondsBeforeResetEarlyWorkoutDetection,%.0lf", buf, 0x20u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191C0 != -1) {
          dispatch_once(&qword_1024191C0, &stru_1022FD128);
        }
        if (!*(unsigned char *)(a1 + 520)) {
          sub_10020D700();
        }
        double v22 = *(double *)(a1 + 512);
        int v26 = 134349568;
        double v27 = v22;
        __int16 v28 = 2050;
        uint64_t v29 = *(void *)&v4;
        __int16 v30 = 2048;
        uint64_t v31 = qword_102481CB0;
        float32x2_t v23 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::reactivateEarlyWorkoutDetectionIfNecessary(const CLMotionActivity &)", "%s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      sub_1004663C0(a1 + 1568, (void *)(a1 + 592), *(void *)(a1 + 512), *(void *)(a1 + 520), 0);
      sub_100E581B0(a1, 0);
    }
  }
}

void sub_1001ACA7C(_Unwind_Exception *a1)
{
}

uint64_t sub_1001ACAAC(uint64_t a1)
{
  uint64_t result = sub_1001BD934(*(void *)(a1 + 632));
  if (result == 2 && *(void *)(a1 + 656) != 1 && *(unsigned char *)(a1 + 24) == 2)
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1022FD128);
    }
    uint64_t v3 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Workout predictor - keeping GPS alive because we're in an outdoor run escalation", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::keepGpsAliveIfNecessary()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
    return sub_1006C1B00(v4);
  }
  return result;
}

uint64_t sub_1001ACC94(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 712);
  if (v4 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(a1 + 1388))
    {
      int v5 = *(_DWORD *)(a1 + 716) + 1;
      *(_DWORD *)(a1 + 716) = v5;
      if (v5 >= v4)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)) {
          sub_1001A34E0(a1 + 8, 13, (uint64_t)buf);
        }
      }
    }
  }
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  memset(v25, 0, sizeof(v25));
  sub_100052E44(a2, (uint64_t)v25);
  sub_1001AC230(a1, (int *)v25);
  if (*((void *)&v28 + 1) != *(void *)(a1 + 688))
  {
    *(void *)(a1 + 688) = *((void *)&v28 + 1);
    BOOL v6 = sub_100E58948(a1, a2);
    if (*(void *)(a1 + 688))
    {
      BOOL v7 = v6;
      uint64_t v8 = v28;
      uint64_t v9 = sub_1001BD934((uint64_t)+[CMWorkout CMWorkoutTypeFromCLMotionActivityType:DWORD2(v27)]);
      uint64_t v56 = v8;
      uint64_t v57 = v26;
      uint64_t v58 = v9;
      BOOL v59 = v7;
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      int v10 = qword_1024191C8;
      if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 134349568;
        *(void *)__int16 v52 = v9;
        *(_WORD *)&v52[8] = 2050;
        uint64_t v53 = v8;
        __int16 v54 = 1026;
        BOOL v55 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "CLAS,new AP escalation detected for workout type,%{public}ld,startTime,%{public}f,is early detection,%{public}d", buf, 0x1Cu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191C0 != -1) {
          dispatch_once(&qword_1024191C0, &stru_1022FD128);
        }
        int v45 = 134349568;
        uint64_t v46 = v9;
        __int16 v47 = 2050;
        uint64_t v48 = v8;
        __int16 v49 = 1026;
        BOOL v50 = v7;
        uint64_t v24 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::feedMotionStateUpdate(const CLWorkoutPredictorActivity &)", "%s\n", v24);
        if (v24 != (char *)buf) {
          free(v24);
        }
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)) {
        sub_1001A34E0(a1 + 8, 1, (uint64_t)&v56);
      }
    }
  }
  unint64_t v11 = *(void *)(a1 + 488) + 1;
  *(void *)(a1 + 488) = v11;
  if (v11 >= 0x17)
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_1022FD128);
    }
    long long v12 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(unsigned __int8 *)(a1 + 24);
      *(_DWORD *)uint64_t buf = 67240448;
      *(_DWORD *)__int16 v52 = v13;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v25[0];
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Current state of Workout Predictor: %{public}d,motiontype,%d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_1022FD128);
      }
      int v22 = *(unsigned __int8 *)(a1 + 24);
      LODWORD(v56) = 67240448;
      HIDWORD(v56) = v22;
      LOWORD(v57) = 1024;
      *(_DWORD *)((char *)&v57 + 2) = v25[0];
      float32x2_t v23 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutPredictor::feedMotionStateUpdate(const CLWorkoutPredictorActivity &)", "%s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
    *(void *)(a1 + 488) = 0;
  }
  sub_10019CF58((double *)(a1 + 32), a2);
  double v15 = *(double *)(a2 + 8);
  if (*(double *)(a1 + 480) > v15)
  {
    double v16 = *(uint64_t **)(a1 + 424);
    if (v16) {
      sub_1014435AC(v16);
    }
    int v17 = *(uint64_t **)(a1 + 472);
    if (v17) {
      sub_10077AAA4(v17);
    }
    nullsub_41(a1 + 1368, v14);
    double v15 = *(double *)(a2 + 8);
  }
  *(double *)(a1 + 480) = v15;
  sub_100195670((void **)(a1 + 1368));
  uint64_t v18 = *(void *)(a1 + 424);
  if (v18) {
    sub_101444078(v18);
  }
  uint64_t v19 = *(void *)(a1 + 432);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 16))(v19);
  }
  sub_10017261C(*(void *)(a1 + 1432), (double *)(a1 + 32));
  int v20 = *(uint64_t **)(a1 + 472);
  if (v20) {
    sub_10077ADD4(v20);
  }
  if (sub_100195DB0(*(void *)(a1 + 1432), a1 + 1392))
  {
    long long v44 = 0u;
    long long v43 = 0u;
    long long v42 = 0u;
    long long v41 = 0u;
    long long v40 = 0u;
    long long v39 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    uint64_t v30 = *(void *)(a1 + 1392);
    sub_10077AD10(a1 + 1448, 7);
  }
  return sub_1001ACAAC(a1);
}

id *sub_1001AD254(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 20) <= 0.0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231AE10);
    }
    unint64_t v11 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLWifiTilesManager.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&unsigned char buf[14] = 1757;
      __int16 v20 = 2080;
      uint64_t v21 = "location.horizontalAccuracy > 0.0";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      int v13 = 136315650;
      uint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLWifiTilesManager.mm";
      __int16 v15 = 1024;
      int v16 = 1757;
      __int16 v17 = 2080;
      uint64_t v18 = "location.horizontalAccuracy > 0.0";
      long long v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLWifiTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)", "%s\n", v12);
      if (v12 != buf) {
        free(v12);
      }
    }
    sub_1004BA578();
  }
  sub_1000E1294((uint64_t *)&v13, (uint64_t)"CLWifiTilesManager::updateTileLocationRelevancy", 0);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 224))(a1);
  if (*(unsigned char *)v4)
  {
    (*(void (**)(void))(**(void **)(a1 + 448) + 56))(*(void *)(a1 + 448));
    if (*(double *)(a2 + 20) >= 0.0 && vabdd_f64(v5, *(double *)(a2 + 76)) <= 3600.0)
    {
      sub_10014FAA4(*(void *)(a1 + 480), a2, (uint64_t)*(double *)&qword_102477288, (char **)buf, v5);
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }
    else
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      BOOL v6 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "WIFITILE: location not relevant", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419630 == -1)
        {
LABEL_20:
          uint64_t v9 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLWifiTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)", "%s\n", v9);
          if (v9 != buf) {
            free(v9);
          }
          return sub_1000E1098((id *)&v13);
        }
LABEL_35:
        dispatch_once(&qword_102419630, &stru_10231AE10);
        goto LABEL_20;
      }
    }
  }
  else
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231AE10);
    }
    BOOL v7 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = v4 + 8;
      if (*(char *)(v4 + 31) < 0) {
        uint64_t v8 = *(void *)(v4 + 8);
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "WIFITILE: tiles, %s, not active", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 == -1) {
        goto LABEL_20;
      }
      goto LABEL_35;
    }
  }
  return sub_1000E1098((id *)&v13);
}

void sub_1001AD7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000E1098((id *)va);
  _Unwind_Resume(a1);
}

void sub_1001AD7FC(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 224))(a1);
  if ((*(_DWORD *)(v6 + 148) & 0x80000000) == 0)
  {
    uint64_t v7 = v6;
    __int16 v11 = 0;
    unint64_t v13 = 0xBFF0000000000000;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    __int16 v16 = 1;
    char v12 = 0;
    int v14 = *(_DWORD *)(v7 + 148);
    LODWORD(v7) = *(_DWORD *)(v7 + 4);
    double v8 = *(double *)(a2 + 4);
    double v9 = *(double *)(a2 + 12);
    sub_100134750(&__p, "");
    sub_100091818(a1, v7, &__p, (uint64_t)&v11, v8, v9, a3);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1001AD8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001AD904(uint64_t a1, unsigned char *a2)
{
  int v4 = *(_DWORD *)(a1 + 408);
  if (v4 <= 0)
  {
    int v5 = *(unsigned __int8 *)(a1 + 412);
    BOOL v6 = *(unsigned char *)(a1 + 412) != 0;
    goto LABEL_5;
  }
  if (v4 == 1)
  {
    int v5 = *(unsigned __int8 *)(a1 + 412);
    BOOL v6 = 1;
LABEL_5:
    BOOL v7 = v5 != 0;
    goto LABEL_7;
  }
  BOOL v6 = 1;
  BOOL v7 = 1;
LABEL_7:
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 224))(a1);
  if ((*(unsigned int (**)(uint64_t, unsigned char *))(*(void *)a1 + 240))(a1, a2))
  {
    char v9 = !v6;
    if (a2[112]) {
      char v10 = !v6;
    }
    else {
      char v10 = 1;
    }
    if ((v10 & 1) == 0)
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      __int16 v11 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a2 + 16))(__p, a2);
        char v12 = v35 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "WIFITILE: checkDownloadSchedule, rule, isCurrent, isAllowCellularIfCurrent,  IsOkToDownloadRealtime, %s", buf, 0xCu);
        if (v35 < 0) {
          operator delete(__p[0]);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_102419630 != -1) {
          dispatch_once(&qword_102419630, &stru_10231AE10);
        }
        (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)a2 + 16))(buf, a2);
        if (v31 >= 0) {
          unint64_t v13 = buf;
        }
        else {
          unint64_t v13 = *(unsigned char **)buf;
        }
        int v32 = 136315138;
        long long v33 = v13;
        int v14 = (char *)_os_log_send_and_compose_impl();
        if (v31 < 0) {
          operator delete(*(void **)buf);
        }
LABEL_101:
        sub_1004BA5E4("Generic", 1, 0, 2, "int CLWifiTilesManager::getDownloadConnectionType(CLTileFile *)", "%s\n", v14);
        if (v14 != (char *)__p) {
          free(v14);
        }
        return !*(unsigned char *)(a1 + 160);
      }
      return !*(unsigned char *)(a1 + 160);
    }
    if (!*(unsigned char *)(v8 + 177)) {
      char v9 = 1;
    }
    if ((v9 & 1) == 0)
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      uint64_t v19 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a2 + 16))(__p, a2);
        __int16 v20 = v35 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "WIFITILE: checkDownloadSchedule, rule, isCurrent, fDownloadCurrentTileOverCell, IsOkToDownloadRealtime, %s", buf, 0xCu);
        if (v35 < 0) {
          operator delete(__p[0]);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_102419630 != -1) {
          dispatch_once(&qword_102419630, &stru_10231AE10);
        }
        (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)a2 + 16))(buf, a2);
        if (v31 >= 0) {
          long long v28 = buf;
        }
        else {
          long long v28 = *(unsigned char **)buf;
        }
        int v32 = 136315138;
        long long v33 = v28;
        int v14 = (char *)_os_log_send_and_compose_impl();
        if (v31 < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_101;
      }
      return !*(unsigned char *)(a1 + 160);
    }
    if (v7)
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      long long v26 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a2 + 16))(__p, a2);
        long long v27 = v35 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "WIFITILE: checkDownloadSchedule, rule, isCurrent, IsOkToDownloadLarge, %s", buf, 0xCu);
        if (v35 < 0) {
          operator delete(__p[0]);
        }
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_91;
      }
      bzero(__p, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)a2 + 16))(buf, a2);
      if (v31 >= 0) {
        uint64_t v29 = buf;
      }
      else {
        uint64_t v29 = *(unsigned char **)buf;
      }
      int v32 = 136315138;
      long long v33 = v29;
      uint64_t v25 = (char *)_os_log_send_and_compose_impl();
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
LABEL_110:
      sub_1004BA5E4("Generic", 1, 0, 2, "int CLWifiTilesManager::getDownloadConnectionType(CLTileFile *)", "%s\n", v25);
      if (v25 != (char *)__p) {
        free(v25);
      }
      goto LABEL_91;
    }
    return 0;
  }
  char v15 = !v6;
  if (!a2[113]) {
    char v15 = 1;
  }
  if ((v15 & 1) == 0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231AE10);
    }
    __int16 v16 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
    {
      (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a2 + 16))(__p, a2);
      __int16 v17 = v35 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "WIFITILE: checkDownloadSchedule, rule, isAllowCellularIfNotCurrent, IsOkToDownloadRealtime, %s", buf, 0xCu);
      if (v35 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)a2 + 16))(buf, a2);
      if (v31 >= 0) {
        uint64_t v18 = buf;
      }
      else {
        uint64_t v18 = *(unsigned char **)buf;
      }
      int v32 = 136315138;
      long long v33 = v18;
      int v14 = (char *)_os_log_send_and_compose_impl();
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_101;
    }
    return !*(unsigned char *)(a1 + 160);
  }
  if (!v7) {
    return 0;
  }
  if (qword_102419630 != -1) {
    dispatch_once(&qword_102419630, &stru_10231AE10);
  }
  int v22 = qword_102419638;
  if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(void **__return_ptr, unsigned char *))(*(void *)a2 + 16))(__p, a2);
    float32x2_t v23 = v35 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "WIFITILE: checkDownloadSchedule, rule, IsOkToDownloadLarge, %s", buf, 0xCu);
    if (v35 < 0) {
      operator delete(__p[0]);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10231AE10);
    }
    (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)a2 + 16))(buf, a2);
    if (v31 >= 0) {
      uint64_t v24 = buf;
    }
    else {
      uint64_t v24 = *(unsigned char **)buf;
    }
    int v32 = 136315138;
    long long v33 = v24;
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    if (v31 < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_110;
  }
LABEL_91:
  if (*(unsigned char *)(a1 + 192)) {
    return 0;
  }
  return 2;
}

uint64_t sub_1001AE3D8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 128);
  uint64_t v2 = (void *)(a1 + 136);
  if (v1 == (void *)(a1 + 136)) {
    return 0;
  }
  LODWORD(v3) = 0;
  do
  {
    uint64_t v4 = sub_1001BF5C0(v1[10]);
    BOOL v5 = sub_100065F70(v1[10]);
    uint64_t v3 = (v3 + v5);
    if (v5)
    {
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10231AE10);
      }
      BOOL v6 = qword_102419638;
      if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v1[10] + 16))(__p);
        BOOL v7 = __p;
        if (v20 < 0) {
          BOOL v7 = *(unsigned char **)__p;
        }
        *(_DWORD *)uint64_t buf = 136315906;
        uint64_t v24 = v7;
        __int16 v25 = 1024;
        int v26 = 1;
        __int16 v27 = 1024;
        int v28 = v3;
        __int16 v29 = 2048;
        uint64_t v30 = v4;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "WIFITILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p", buf, 0x22u);
        if (SHIBYTE(v20) < 0) {
          operator delete(*(void **)__p);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419630 != -1) {
          dispatch_once(&qword_102419630, &stru_10231AE10);
        }
        (*(void (**)(void **__return_ptr))(*(void *)v1[10] + 16))(v14);
        __int16 v11 = v14;
        if (v15 < 0) {
          __int16 v11 = (void **)v14[0];
        }
        *(_DWORD *)std::string __p = 136315906;
        *(void *)&__p[4] = v11;
        __int16 v17 = 1024;
        int v18 = 1;
        __int16 v19 = 1024;
        int v20 = v3;
        __int16 v21 = 2048;
        uint64_t v22 = v4;
        char v12 = (char *)_os_log_send_and_compose_impl();
        if (v15 < 0) {
          operator delete(v14[0]);
        }
        sub_1004BA5E4("Generic", 1, 0, 2, "unsigned int CLWifiTilesManager::getNumOfActiveDownloads()", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
    }
    uint64_t v8 = (void *)v1[1];
    if (v8)
    {
      do
      {
        char v9 = v8;
        uint64_t v8 = (void *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        char v9 = (void *)v1[2];
        BOOL v10 = *v9 == (void)v1;
        uint64_t v1 = v9;
      }
      while (!v10);
    }
    uint64_t v1 = v9;
  }
  while (v9 != v2);
  return v3;
}

void sub_1001AE6FC()
{
}

void sub_1001AE7B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_1001AE7F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 128))
  {
    if (*(unsigned char *)(a1 + 32)
      || *(unsigned char *)(a1 + 130)
      && (*(unsigned char *)(a1 + 152)
       || ((double v6 = *(double *)(a1 + 11704), v7 = vabdd_f64(*(double *)(a3 + 32), v6), v6 > 0.0)
         ? (v8 = v7 == 24.0, BOOL v9 = v7 < 24.0)
         : (v8 = 0, BOOL v9 = 0),
           v9 || v8)))
    {
      if (*(unsigned char *)(a1 + 129))
      {
        sub_10016B62C((uint64_t)v11);
        sub_100868BE8(a2, (uint64_t)v11);
        sub_10016AD54((uint64_t)v10);
        sub_100869994(a3, (uint64_t)v10);
        BOOL v5 = sub_1012F7FC4();
        sub_1012F89EC((uint64_t)v5, (uint64_t)v11, (uint64_t)v10, 1);
        sub_1003E50E4(v10);
        sub_1003E2048((wireless_diagnostics::google::protobuf::MessageLite *)v11);
      }
    }
  }
}

void sub_1001AE8C0(uint64_t a1, long long *a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 128))
  {
    if (*(unsigned char *)(a1 + 32)) {
      goto LABEL_40;
    }
    if (!*(unsigned char *)(a1 + 130)) {
      return;
    }
    if (*(unsigned char *)(a1 + 152)
      || ((v13 = *(double *)(a1 + 11704), double v14 = vabdd_f64(*(double *)(a3 + 32), v13), v13 > 0.0)
        ? (BOOL v15 = v14 <= 24.0)
        : (BOOL v15 = 0),
          v15))
    {
LABEL_40:
      if (*(unsigned char *)(a1 + 129))
      {
        sub_10016B62C((uint64_t)&v35);
        sub_100868BE8((uint64_t)a2, (uint64_t)&v35);
        sub_10016AD54((uint64_t)&buf);
        sub_100869994(a3, (uint64_t)&buf);
        double v6 = sub_1012F7FC4();
        sub_1012F89EC((uint64_t)v6, (uint64_t)&v35, (uint64_t)&buf, 0);
        sub_1003E50E4((uint64_t *)&buf);
        sub_1003E2048((wireless_diagnostics::google::protobuf::MessageLite *)&v35);
      }
      if (*(unsigned char *)(a1 + 130)) {
        sub_1011A9104((unsigned __int8 *)(a1 + 152), (uint64_t)a2, a3);
      }
      if (*(unsigned char *)(a1 + 32) && !*(unsigned char *)(a1 + 13792))
      {
        if (qword_102419420 != -1) {
          dispatch_once(&qword_102419420, &stru_1022D4F08);
        }
        double v7 = qword_102419428;
        if (os_log_type_enabled((os_log_t)qword_102419428, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "CLVC,handleLocationNotification,Download DEM tiles", (uint8_t *)&buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_102419420 != -1) {
            dispatch_once(&qword_102419420, &stru_1022D4F08);
          }
          LOWORD(v35) = 0;
          int v20 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLVisionController::handleLocationNotification(const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v20);
          if (v20 != (char *)&buf) {
            free(v20);
          }
        }
        long long v8 = a2[7];
        long long v32 = a2[6];
        long long v33 = v8;
        v34[0] = a2[8];
        *(_OWORD *)((char *)v34 + 12) = *(long long *)((char *)a2 + 140);
        long long v9 = a2[3];
        long long v28 = a2[2];
        long long v29 = v9;
        long long v10 = a2[5];
        long long v30 = a2[4];
        long long v31 = v10;
        long long v11 = a2[1];
        long long v26 = *a2;
        long long v27 = v11;
        char v12 = *(void **)(a1 + 24);
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        uint64_t v24 = sub_100969F40;
        __int16 v25 = &unk_1022C1CA0;
        [v12 downloadIfNeeded:[buf copy] signalQuality:0 allowCenterOverCellular:1 ringsToDownloadOverCellular:1];
        *(unsigned char *)(a1 + 13792) = 1;
      }
    }
    else if (v13 > 0.0)
    {
      if (*(unsigned char *)(a1 + 129))
      {
        sub_10016B62C((uint64_t)&v35);
        sub_100868BE8((uint64_t)a2, (uint64_t)&v35);
        sub_10016AD54((uint64_t)&buf);
        sub_100869994(a3, (uint64_t)&buf);
        __int16 v16 = sub_1012F7FC4();
        sub_1012F89EC((uint64_t)v16, (uint64_t)&v35, (uint64_t)&buf, 0);
        __int16 v17 = sub_1012F7FC4();
        sub_101212CAC((uint64_t)v17);
        sub_1003E50E4((uint64_t *)&buf);
        sub_1003E2048((wireless_diagnostics::google::protobuf::MessageLite *)&v35);
      }
      sub_1011A3BFC(a1 + 152);
      if (qword_102419420 != -1) {
        dispatch_once(&qword_102419420, &stru_1022D4F08);
      }
      int v18 = qword_102419428;
      if (os_log_type_enabled((os_log_t)qword_102419428, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = *(void *)(a3 + 32);
        LODWORD(buf) = 134349056;
        *(void *)((char *)&buf + 4) = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "CLVC,handleLocationNotification,manual location fuser reset,machAbsTime,%{public}.3lf", (uint8_t *)&buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_102419420 != -1) {
          dispatch_once(&qword_102419420, &stru_1022D4F08);
        }
        uint64_t v21 = *(void *)(a3 + 32);
        int v35 = 134349056;
        uint64_t v36 = v21;
        uint64_t v22 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLVisionController::handleLocationNotification(const CLDaemonLocation &, const CLDaemonLocationPrivate &)", "%s\n", v22);
        if (v22 != (char *)&buf) {
          free(v22);
        }
      }
    }
  }
}

void sub_1001AED8C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

uint64_t sub_1001AED98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 128)
    && *(unsigned char *)(a1 + 130)
    && (*(unsigned char *)(a1 + 152)
     || ((v3 = *(double *)(a1 + 11704), double v4 = vabdd_f64(*(double *)(a3 + 32), v3), v3 > 0.0)
       ? (BOOL v5 = v4 <= 24.0)
       : (BOOL v5 = 0),
         v5)))
  {
    return sub_1011A4460((unsigned __int8 *)(a1 + 152), a2, a3);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1001AEDE0(uint64_t a1, int a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BB2A8);
  }
  double v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "CLTelephonyService, Refresh Cell Monitor", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BB2A8);
    }
    double v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLTelephonyService::refreshCellMonitorForSim(SimInstance)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  sub_10002CFA0(a1 + 176, a2);
  return 1;
}

uint64_t sub_1001AEF88(uint64_t a1)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_1022BB2A8);
  }
  uint64_t v2 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLTelephonyService, Refresh Cell Monitor", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_1022BB2A8);
    }
    double v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLTelephonyService::refreshCellMonitor()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sub_10002CFA0(a1 + 176, 255);
  return 1;
}

uint64_t sub_1001AF12C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  v8[2] = (id)(a1 + 112);
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v9 = 256;
  sub_1000E1294((uint64_t *)v8, (uint64_t)"CLSensorRecorderDb::reduceFreePages", 0);
  sub_10002B640(*(void *)(a1 + 80));
  uint64_t v6 = sub_10003CC68(*(void *)(a1 + 80), a2);
  sub_100028FB4(*(void *)(a1 + 80));
  sub_1000E1098(v8);
  (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  return v6;
}

void sub_1001AF204(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  id v3 = va_arg(va1, id);
  uint64_t v5 = va_arg(va1, void);
  sub_1000E1098((id *)va);
  sub_1019DB560((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001AF22C(uint64_t a1, double a2)
{
  int v2 = *(_DWORD *)(a1 + 96);
  if (v2 == 1 && *(double *)(a1 + 44) >= 0.0) {
    return 1;
  }
  if (a2 >= 0.0 && v2 == 4) {
    return 2;
  }
  else {
    return 0;
  }
}

BOOL sub_1001AF260(char *a1, int a2, int *a3)
{
  if ((*a3 - 1) > 1)
  {
    return sub_1000ED620(a1, a2, a3);
  }
  else
  {
    int v4 = 0;
    return sub_1000ED620(a1, a2, &v4);
  }
}

uint64_t sub_1001AF2B4(uint64_t a1, _OWORD *a2)
{
  sub_1000DB3D4((uint64_t)v11);
  int v10 = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t, int *, _OWORD *))(*(void *)a1 + 128))(a1, &v10, v11);
  if (v4)
  {
    long long v5 = v11[7];
    a2[6] = v11[6];
    a2[7] = v5;
    a2[8] = v12[0];
    *(_OWORD *)((char *)a2 + 140) = *(_OWORD *)((char *)v12 + 12);
    long long v6 = v11[3];
    a2[2] = v11[2];
    a2[3] = v6;
    long long v7 = v11[5];
    a2[4] = v11[4];
    a2[5] = v7;
    long long v8 = v11[1];
    *a2 = v11[0];
    a2[1] = v8;
  }

  if (v17) {
    sub_1000DB0A0(v17);
  }
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v14) {
    sub_1000DB0A0(v14);
  }
  if (v13) {
    sub_1000DB0A0(v13);
  }
  return v4;
}

void sub_1001AF3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100458658((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1001AF3C8(long long *a1, void *a2)
{
  sub_10017DFD0((uint64_t)a2, a1);
  unint64_t v3 = a2[5];
  if (v3 >= 5)
  {
    a2[5] = v3 - 1;
    sub_10017E108(a2, 1);
  }
}

uint64_t sub_1001AF42C(uint64_t a1, unsigned char *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 2);
  if (*(unsigned char *)a1) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (*a2) {
      BOOL v4 = a2[2] == 0;
    }
    else {
      BOOL v4 = 1;
    }
    int v5 = v4;
    if (*(unsigned char *)a1) {
      BOOL v6 = v2 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      if (v5) {
        return 5;
      }
      else {
        return 4;
      }
    }
    else
    {
      if (a2[2]) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = *a2 == 0;
      }
      if (v7) {
        unsigned int v8 = 0;
      }
      else {
        unsigned int v8 = 4;
      }
      if (v5) {
        return v8;
      }
      else {
        return 3;
      }
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 8);
    if (v10 <= 1000.0)
    {
      return 1;
    }
    else if (v10 > 5000.0 || v10 <= 1000.0)
    {
      return 3;
    }
    else
    {
      return 2;
    }
  }
}

id sub_1001AF4C8(void *a1)
{
  if (*((unsigned char *)a1 + 44))
  {
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_10230DE88);
    }
    int v2 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO))
    {
      uint64_t v3 = *((unsigned int *)a1 + 10);
      v6[0] = 68289282;
      v6[1] = 0;
      __int16 v7 = 2082;
      unsigned int v8 = "";
      __int16 v9 = 2050;
      uint64_t v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"trace ending, unsubscribing from trace notifications\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}", (uint8_t *)v6, 0x1Cu);
    }
    (*(void (**)(void, void, uint64_t))(*(void *)*a1 + 32))(*a1, *((unsigned int *)a1 + 10), 2);
    (*(void (**)(void, void, uint64_t))(*(void *)*a1 + 32))(*a1, *((unsigned int *)a1 + 10), 8);
    uint64_t v4 = a1[2];
    v6[0] = 0;
    (*(void (**)(uint64_t, _DWORD *))(*(void *)v4 + 56))(v4, v6);
    (*(void (**)(void, uint64_t))(*(void *)a1[2] + 72))(a1[2], 30);
    (*(void (**)(void, void))(*(void *)a1[2] + 88))(a1[2], 0);
    if ((*(unsigned int (**)(void))(*(void *)a1[4] + 144))(a1[4])) {
      (*(void (**)(void))(*(void *)a1[2] + 104))(a1[2]);
    }
    if ((*(unsigned int (**)(void))(*(void *)a1[4] + 152))(a1[4])) {
      (*(void (**)(void))(*(void *)a1[2] + 120))(a1[2]);
    }
    *((unsigned char *)a1 + 44) = 0;
  }
  return [(id)a1[6] removeAllObjects];
}

uint64_t sub_1001AF758(float64x2_t *a1, uint64_t *a2, uint64_t *a3)
{
  float64x2_t v3 = (float64x2_t)vdupq_lane_s64(*a2, 0);
  float64x2_t v4 = vabdq_f64(v3, a1[24]);
  float64x2_t v5 = vabdq_f64(v3, a1[23]);
  float64x2_t v6 = (float64x2_t)vdupq_lane_s64(*a3, 0);
  int8x8_t v7 = vorr_s8(vand_s8((int8x8_t)vmovn_s64(vcgeq_f64(v6, v5)), (int8x8_t)0x8000000004), vand_s8((int8x8_t)vmovn_s64(vcgeq_f64(v6, v4)), (int8x8_t)0x800000100));
  return v7.i32[0] | v7.i32[1] | (16 * (vabdd_f64(*(double *)a2, a1[25].f64[0]) <= *(double *)a3));
}

uint64_t sub_1001AF7C4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 296);
}

BOOL sub_1001AF7CC(uint64_t a1, double a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 297);
  double v5 = *(double *)(a1 + 304);
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_1022F86D0);
  }
  double v6 = a2 - v5;
  int8x8_t v7 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
  {
    int v8 = *(unsigned __int8 *)(a1 + 298);
    *(_DWORD *)long long buf = 67175169;
    int v14 = v4;
    __int16 v15 = 1025;
    int v16 = v8;
    __int16 v17 = 2049;
    double v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "isRecalculate, %{private}d, fIsRecalculationPending, %{private}d, sinceLastRecalculationTrigger, %{private}.1lf", buf, 0x18u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F86D0);
    }
    long long v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitorWifi::recalculateIfNeeded(const CFAbsoluteTime)", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  if (v4)
  {
    sub_100DDA0D8((unsigned char *)a1);
    *(double *)(a1 + 304) = a2;
  }
  else if (!*(unsigned char *)(a1 + 298) && (*(unsigned int (**)(void))(**(void **)a1 + 80))())
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F86D0);
    }
    __int16 v9 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Fence: power assertion no longer needed", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F86D0);
      }
      char v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitorWifi::recalculateIfNeeded(const CFAbsoluteTime)", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
    (*(void (**)(void))(**(void **)a1 + 72))();
  }
  return v4 != 0;
}

uint64_t sub_1001AFB70(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 237);
}

__n128 sub_1001AFB78(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(_OWORD *)(a1 + 24) = a2[1];
  *(_OWORD *)(a1 + 8) = v2;
  long long v3 = a2[2];
  long long v4 = a2[3];
  long long v5 = a2[4];
  *(_OWORD *)(a1 + 88) = a2[5];
  *(_OWORD *)(a1 + 72) = v5;
  *(_OWORD *)(a1 + 56) = v4;
  *(_OWORD *)(a1 + 40) = v3;
  __n128 result = (__n128)a2[6];
  long long v7 = a2[7];
  long long v8 = a2[8];
  *(_OWORD *)(a1 + 148) = *(long long *)((char *)a2 + 140);
  *(_OWORD *)(a1 + 136) = v8;
  *(_OWORD *)(a1 + 120) = v7;
  *(__n128 *)(a1 + 104) = result;
  return result;
}

id *sub_1001AFBBC(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 20) <= 0.0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1023197E0);
    }
    long long v5 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      __int16 v15 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLCellTilesManager.mm";
      __int16 v16 = 1024;
      int v17 = 1582;
      __int16 v18 = 2080;
      uint64_t v19 = "location.horizontalAccuracy > 0.0";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1023197E0);
      }
      int v8 = 136315650;
      __int16 v9 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLCellTilesManager.mm";
      __int16 v10 = 1024;
      int v11 = 1582;
      __int16 v12 = 2080;
      double v13 = "location.horizontalAccuracy > 0.0";
      double v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLCellTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    sub_1004BA578();
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  int32x4_t v7[2] = sub_10005142C;
  v7[3] = &unk_1022C9848;
  v7[4] = a1;
  void v7[5] = a2;
  return sub_1000511A0(a1, (uint64_t)"updateTileLocationRelevancy", (uint64_t)v7);
}

void sub_1001AFE34(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 3;
  *(void *)(a3 + 32) = 3;
  if (*(unsigned char *)(a2 + 352) && CLMotionActivity::isTypeIndoorPedestrian())
  {
    double v6 = *(double *)(a2 + 1040);
    double v7 = *(double *)(a2 + 1104);
    BOOL v8 = v7 <= 0.447039278 || v7 > 7.14285711;
    float v9 = v7 * 2.23693991;
    float v10 = 0.0;
    if (v8) {
      float v11 = 0.0;
    }
    else {
      float v11 = v9;
    }
    float v12 = *(double *)(a2 + 1192) * 2.23693991;
    double v13 = 0.0;
    double v14 = 0.0;
    if (v6 > 0.0)
    {
      if (v11 >= 1.0)
      {
        if ((float)((float)((float)((float)(v11 * -0.793) + (float)((float)(v11 * 0.3564) * v11)) + 3.142)
                   * *(float *)(a1 + 16)) <= 8.0)
          float v15 = (float)((float)((float)(v11 * -0.793) + (float)((float)(v11 * 0.3564) * v11)) + 3.142)
              * *(float *)(a1 + 16);
        else {
          float v15 = 8.0;
        }
        float v10 = v15;
      }
      else
      {
        float v15 = 2.1;
      }
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 16) = 0;
      *(float *)(a3 + 20) = v15;
      *(_DWORD *)(a3 + 24) = 3;
      *(float *)(a3 + 28) = v10;
      *(void *)(a3 + 32) = 3;
      if (v12 > 0.0) {
        int v16 = 1;
      }
      else {
        int v16 = 2;
      }
      sub_100056F84(v16, v12, v11, 2.5);
      float v18 = v15 * v17;
      if (v18 <= 20.0) {
        float v19 = v18;
      }
      else {
        float v19 = 20.0;
      }
      *(float *)(a3 + 20) = v19;
      sub_100056F84(v16, v12, v11, 2.5);
      float v21 = v10 * v20;
      if (v21 > 20.0) {
        float v21 = 20.0;
      }
      *(float *)(a3 + 28) = v21;
      double v14 = v19;
      double v13 = v21;
    }
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022B1CC0);
    }
    uint64_t v22 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v23 = *(void *)(a2 + 112);
      *(_DWORD *)long long buf = 134219264;
      uint64_t v26 = v23;
      __int16 v27 = 2048;
      double v28 = v6;
      __int16 v29 = 2048;
      double v30 = v11;
      __int16 v31 = 2048;
      double v32 = v12;
      __int16 v33 = 2048;
      double v34 = v14;
      __int16 v35 = 2048;
      double v36 = v13;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "Walk,fitness machine,computeTime,%.3f,startTime,%.3f,wr,%f,vertSpeed,%f,userMets,%f,truthMets,%f", buf, 0x3Eu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022B1CC0);
      }
      uint64_t v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMetsInfo CLCalorieWalkModel::computeFitnessMachineMETS(const CLNatalieModelInput &)", "%s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
  }
}

void sub_1001B01DC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1001B01F0(uint64_t a1)
{
  if (!*(void *)(a1 + 264)) {
    sub_10000973C();
  }
  return a1 + 264;
}

void sub_1001B02B0(uint64_t a1)
{
  *(unsigned char *)(a1 + 306) = [(id)sub_10009AD44((void *)a1, @"includePrivateData") boolValue];

  sub_100099CC4(a1);
}

uint64_t sub_1001B02F8(uint64_t a1)
{
  if (!*(void *)(a1 + 256)) {
    sub_100CF51E8();
  }
  return a1 + 256;
}

void sub_1001B03BC(void *a1, int a2)
{
  __asm { FMOV            V0.2D, #-1.0 }
  long long v9 = _Q0;
  __int16 v10 = 0;
  uint64_t v11 = 0;
  if (a2)
  {
    sub_1001B01F0((uint64_t)a1);
    sub_10012F770();
  }
  [sub_10009AD44(a1, @"distanceThreshold") doubleValue];
  *((void *)&v9 + 1) = v8;
  sub_1001B02F8((uint64_t)a1);
  sub_10012F770();
}

void sub_1001B0554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1001B0568(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 97))
  {
    if (*(unsigned char *)(a1 + 112))
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_102313648);
      }
      double v6 = qword_102419568;
      if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v10 = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      double v13 = "";
      double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, prohibity by default write\"}";
      goto LABEL_36;
    }
    return 0;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1) & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 112))
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_102313648);
      }
      double v6 = qword_102419568;
      if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v10 = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      double v13 = "";
      double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, 'Traffic' system service not authorized\"}";
      goto LABEL_36;
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 144))
  {
    if (*(unsigned char *)(a1 + 112))
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_102313648);
      }
      double v6 = qword_102419568;
      if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v10 = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      double v13 = "";
      double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, battery criteria not met\"}";
      goto LABEL_36;
    }
    return 0;
  }
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 16) + 104))(*(void *)(a1 + 16)) & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 112))
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_102313648);
      }
      double v6 = qword_102419568;
      if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v10 = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      double v13 = "";
      double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, device is ineligible\"}";
      goto LABEL_36;
    }
    return 0;
  }
  double v2 = *(double *)(a1 + 120);
  double v3 = *(double *)&qword_102476050;
  if (v2 >= *(double *)(a1 + 104) && v2 < *(double *)&qword_102476050)
  {
    if (!(*(unsigned int (**)(void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32)))
    {
      if (*(unsigned char *)(a1 + 112))
      {
        if (qword_102419560 != -1) {
          dispatch_once(&qword_102419560, &stru_102313648);
        }
        double v6 = qword_102419568;
        if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
          goto LABEL_37;
        }
        int v10 = 68289026;
        int v11 = 0;
        __int16 v12 = 2082;
        double v13 = "";
        double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, high CPU thermal criteria not met\"}";
        goto LABEL_36;
      }
      return 0;
    }
    double v2 = *(double *)(a1 + 120);
    double v3 = *(double *)&qword_102476050;
  }
  if (v2 >= v3 && ((*(uint64_t (**)(void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32)) & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 112))
    {
      if (qword_102419560 != -1) {
        dispatch_once(&qword_102419560, &stru_102313648);
      }
      double v6 = qword_102419568;
      if (!os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v10 = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      double v13 = "";
      double v7 = "{\"msg%{public}.0s\":\"#proactive not allowed, low CPU thermal criteria not met\"}";
LABEL_36:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, v7, (uint8_t *)&v10, 0x12u);
LABEL_37:
      uint64_t v5 = 0;
      *(unsigned char *)(a1 + 112) = 0;
      return v5;
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 112)) {
    return 1;
  }
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102313648);
  }
  uint64_t v8 = qword_102419568;
  uint64_t v5 = 1;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_INFO))
  {
    int v10 = 68289026;
    int v11 = 0;
    __int16 v12 = 2082;
    double v13 = "";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#proactive now allowed\"}", (uint8_t *)&v10, 0x12u);
  }
  *(unsigned char *)(a1 + 112) = 1;
  return v5;
}

id sub_1001B0A78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  id result = [*(id *)(a1 + 24) assertInside];
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    unint64_t v6 = *(void *)(a1 + 40);
    return sub_1000DC48C((unsigned char *)a2, v5, v6);
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 32);
    *(void *)(a2 + 16) = *(void *)(a1 + 48);
  }
  return result;
}

id sub_1001B0AE4(uint64_t a1)
{
  [*(id *)(a1 + 24) assertInside];
  if (qword_102419600 != -1) {
    dispatch_once(&qword_102419600, &stru_1022D6570);
  }
  double v2 = qword_102419608;
  if (os_log_type_enabled((os_log_t)qword_102419608, OS_LOG_TYPE_DEBUG))
  {
    double v3 = (void *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      double v3 = (void *)*v3;
    }
    *(_DWORD *)long long buf = 136315138;
    double v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Invalidate, %s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419600 != -1) {
      dispatch_once(&qword_102419600, &stru_1022D6570);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLPersistentTimer::invalidate()", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return [*(id *)a1 invalidate];
}

uint64_t sub_1001B0CC0(uint64_t result)
{
  if (!*(unsigned char *)(result + 24)) {
    *(unsigned char *)(result + 24) = 1;
  }
  if (*(double *)(result + 32) == 0.0) {
    return (*(uint64_t (**)(void))(*(void *)result + 944))();
  }
  return result;
}

uint64_t sub_1001B0D0C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_100134750(&v6, "No valid connection to CLSqliteDatabase database.");
    std::runtime_error::runtime_error(exception, &v6);
    exception->__vftable = (std::runtime_error_vtbl *)&off_10229EDE0;
  }
  uint64_t v3 = *(void *)(a1 + 16);

  return sub_1001A8964(a2, v2, v3);
}

void sub_1001B0DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_1001B0E00(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_DWORD *)(a3 + 124) = 0;
  *(_WORD *)(a3 + 128) = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  *(unsigned char *)(a3 + 120) = 0;
  *(_DWORD *)(a3 + 132) = 1000;
  sub_100103240();
  if (sub_10010145C())
  {
    os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
    if (*(unsigned char *)(a2 + 352))
    {
      if (sub_100DE61A4(*(void *)(a2 + 344))) {
        os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
      }
      else {
        os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
      }
    }
    sub_10108D8B8(a1, a2, (uint64_t)buf, v6, v7);
    long long v9 = *(_OWORD *)&v40[16];
    *(_OWORD *)(a3 + 96) = *(_OWORD *)v40;
    *(_OWORD *)(a3 + 112) = v9;
    *(void *)(a3 + 128) = v41;
    long long v10 = v38;
    *(_OWORD *)(a3 + 32) = v37;
    *(_OWORD *)(a3 + 48) = v10;
    long long v11 = *(_OWORD *)&v39[16];
    *(_OWORD *)(a3 + 64) = *(_OWORD *)v39;
    *(_OWORD *)(a3 + 80) = v11;
    long long v12 = *(_OWORD *)&buf[16];
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(_OWORD *)(a3 + 16) = v12;
    if (qword_102419230 != -1) {
      dispatch_once(&qword_102419230, &stru_10230DBC8);
    }
    double v13 = qword_102419238;
    if (os_log_type_enabled((os_log_t)qword_102419238, v8))
    {
      uint64_t v15 = *(void *)a3;
      uint64_t v14 = *(void *)(a3 + 8);
      uint64_t v16 = *(void *)(a3 + 24);
      uint64_t v17 = *(void *)(a3 + 32);
      int v18 = *(unsigned __int8 *)(a3 + 40);
      uint64_t v19 = *(void *)(a3 + 48);
      int v20 = *(_DWORD *)(a3 + 56);
      int v21 = *(_DWORD *)(a3 + 60);
      int v22 = *(unsigned __int8 *)(a3 + 64);
      uint64_t v23 = *(void *)(a3 + 72);
      uint64_t v24 = *(void *)(a3 + 80);
      uint64_t v25 = *(void *)(a3 + 88);
      uint64_t v26 = *(void *)(a3 + 96);
      uint64_t v27 = *(void *)(a3 + 104);
      uint64_t v28 = *(void *)(a3 + 112);
      int v29 = *(unsigned __int8 *)(a3 + 16);
      int v30 = *(unsigned __int8 *)(a3 + 120);
      int v31 = *(_DWORD *)(a3 + 124);
      int v32 = *(unsigned __int8 *)(a3 + 129);
      int v33 = *(unsigned __int8 *)(a3 + 128);
      int v34 = *(_DWORD *)(a3 + 132);
      *(_DWORD *)long long buf = 134354176;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&unsigned char buf[14] = v15;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&unsigned char buf[24] = v16;
      LOWORD(v37) = 2048;
      *(void *)((char *)&v37 + 2) = v17;
      WORD5(v37) = 1026;
      HIDWORD(v37) = v18;
      LOWORD(v38) = 2048;
      *(void *)((char *)&v38 + 2) = v19;
      WORD5(v38) = 1026;
      HIDWORD(v38) = v20;
      *(_WORD *)long long v39 = 1026;
      *(_DWORD *)&v39[2] = v21;
      *(_WORD *)&v39[6] = 1026;
      *(_DWORD *)&v39[8] = v22;
      *(_WORD *)&v39[12] = 2050;
      *(void *)&v39[14] = v23;
      *(_WORD *)&v39[22] = 2050;
      *(void *)&unsigned char v39[24] = v24;
      *(_WORD *)long long v40 = 2050;
      *(void *)&v40[2] = v25;
      *(_WORD *)&v40[10] = 2050;
      *(void *)&unsigned char v40[12] = v26;
      *(_WORD *)&v40[20] = 2050;
      *(void *)&v40[22] = v27;
      *(_WORD *)&v40[30] = 2050;
      uint64_t v41 = v28;
      __int16 v42 = 1026;
      int v43 = v29;
      __int16 v44 = 1026;
      int v45 = v30;
      __int16 v46 = 1026;
      int v47 = v31;
      __int16 v48 = 1026;
      int v49 = v32;
      __int16 v50 = 1026;
      int v51 = v33;
      __int16 v52 = 1026;
      int v53 = v34;
      _os_log_impl((void *)&_mh_execute_header, v13, v8, "RunningPower,startTime,%{public}.2f,powerWattage,%.2f,userWeight,%.2f,userHeight,%.2f,isWeightSet,%{public}d,workrateMETs,%.2f,activityTypeWithoutOverride,%{public}d,activityType,%{public}d,isWorkoutSelected,%{public}d,currentPace,%{public}.2f,currentCadence,%{public}.2f,horizSpeed,%{public}.3f,verticalSpeed,%{public}.3f,grade,%{public}.2f,eta,%{public}.2f,isValid,%{public}d,isGradeOnsetEscalated,%{public}d,gradeOnsetCounter,%{public}d,isRunning,%{public}d,isArmConstrainedStateValid,%{public}d,elevationSource,%{public}d", buf, 0xACu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419230 != -1) {
        dispatch_once(&qword_102419230, &stru_10230DBC8);
      }
      __int16 v35 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLPower::ModelOutput CLPowerEstimator::computeAndLogPower(const CLNatalieModelInput &)", "%s\n", v35);
      if (v35 != buf) {
        free(v35);
      }
    }
    sub_10068D32C(a3, (uint64_t)buf);
    if (*(unsigned char *)(a1 + 64))
    {
      if (qword_10248AF88 != -1) {
        dispatch_once(&qword_10248AF88, &stru_10230DBE8);
      }
      if (qword_10248AF90) {
        operator new();
      }
    }
    PB::Base::~Base((PB::Base *)buf);
  }
}

void sub_1001B1308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void *sub_1001B133C(uint64_t a1, const void *a2)
{
  return sub_100097DD8((void *)(a1 + 488), a2);
}

id sub_1001B1344(uint64_t a1, int a2, void *a3)
{
  id result = sub_100040DBC(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0, &v6, result, *(void *)(a1 + 32));
  }
  return result;
}

uint64_t sub_1001B1394(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

BOOL sub_1001B13A0(__IOHIDServiceClient *a1, void *a2)
{
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v4 = [a2 countByEnumeratingWithState:&v19 objects:v35 count:16];
  if (!v4) {
    return 1;
  }
  id v5 = v4;
  uint64_t v6 = *(void *)v20;
  while (2)
  {
    for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v20 != v6) {
        objc_enumerationMutation(a2);
      }
      CFStringRef v8 = *(const __CFString **)(*((void *)&v19 + 1) + 8 * i);
      id v9 = [a2 objectForKeyedSubscript:v8];
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_1022DAA18);
      }
      long long v10 = qword_102418FD8;
      if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543875;
        CFStringRef v30 = v8;
        __int16 v31 = 2113;
        id v32 = v9;
        __int16 v33 = 2049;
        int v34 = a1;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] Checking matching property %{public}@ = %{private}@ for service ref %{private}p", buf, 0x20u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022DAA18);
        }
        int v23 = 138543875;
        CFStringRef v24 = v8;
        __int16 v25 = 2113;
        id v26 = v9;
        __int16 v27 = 2049;
        uint64_t v28 = a1;
        double v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)", "%s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
      CFTypeRef v11 = IOHIDServiceClientCopyProperty(a1, v8);
      if (!v11)
      {
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022DAA18);
        }
        uint64_t v15 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543875;
          CFStringRef v30 = v8;
          __int16 v31 = 2114;
          id v32 = v9;
          __int16 v33 = 2049;
          int v34 = a1;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] Invalid matching property %{public}@ = %{public}@ for service ref %{private}p", buf, 0x20u);
        }
        BOOL result = sub_10013D1A0(115, 2);
        if (!result) {
          return result;
        }
        bzero(buf, 0x65CuLL);
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022DAA18);
        }
        int v23 = 138543875;
        CFStringRef v24 = v8;
        __int16 v25 = 2114;
        id v26 = v9;
        __int16 v27 = 2049;
        uint64_t v28 = a1;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
        return 0;
      }
      long long v12 = (void *)v11;
      if (!CFEqual(v11, v9))
      {
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022DAA18);
        }
        uint64_t v17 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543875;
          CFStringRef v30 = v8;
          __int16 v31 = 2114;
          id v32 = v12;
          __int16 v33 = 2049;
          int v34 = a1;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] Property mismatch! %{public}@ = %{public}@ for service ref %{private}p", buf, 0x20u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_1022DAA18);
          }
          int v23 = 138543875;
          CFStringRef v24 = v8;
          __int16 v25 = 2114;
          id v26 = v12;
          __int16 v27 = 2049;
          uint64_t v28 = a1;
          int v18 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)", "%s\n", v18);
          if (v18 != (char *)buf) {
            free(v18);
          }
        }
        CFRelease(v12);
        return 0;
      }
      CFRelease(v12);
    }
    id v5 = [a2 countByEnumeratingWithState:&v19 objects:v35 count:16];
    BOOL result = 1;
    if (v5) {
      continue;
    }
    break;
  }
  return result;
}

id sub_1001B1938(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v3 = *(void **)(a1 + 160);
  id result = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (result)
  {
    id v5 = result;
    uint64_t v6 = *(void *)v9;
    do
    {
      unint64_t v7 = 0;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(v3);
        }
        [objc_msgSend(*(id *)(a1 + 160), "objectForKeyedSubscript:", *(void *)(*((void *)&v8 + 1) + 8 * (void)v7)) setDirty:1];
        unint64_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id result = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
      id v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1001B1A40(uint64_t result, int a2, double a3, double a4)
{
  int v4 = *(_DWORD *)(result + 8);
  if (v4 == -1
    || vabdd_f64(*(double *)(result + 16), a4) >= 5400.0
    || (fabs(*(double *)result) > 2.22044605e-16 ? (BOOL v5 = a2 == 1) : (BOOL v5 = 0), v5 ? (v6 = v4 == 2) : (v6 = 0), !v6))
  {
    *(double *)id result = a3;
    *(_DWORD *)(result + 8) = a2;
    *(double *)(result + 16) = a4;
  }
  return result;
}

void *sub_1001B1A94(void *result, uint64_t a2)
{
  ++result[23];
  switch(*(_DWORD *)(a2 + 96))
  {
    case 1:
    case 3:
      uint64_t v2 = result + 24;
      goto LABEL_7;
    case 4:
      uint64_t v2 = result + 27;
      goto LABEL_7;
    case 6:
    case 7:
      uint64_t v2 = result + 28;
      goto LABEL_7;
    case 0xA:
      uint64_t v2 = result + 25;
      goto LABEL_7;
    case 0xB:
      uint64_t v2 = result + 26;
LABEL_7:
      ++*v2;
      break;
    default:
      return result;
  }
  return result;
}

double sub_1001B1B04(uint64_t a1)
{
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 136);
  double result = *(double *)(a1 + 116);
  *(double *)(a1 + 60) = result;
  return result;
}

char *sub_1001B1B20()
{
  return &byte_102478C20;
}

void sub_1001B1B2C(uint64_t *a1, uint64_t a2)
{
  uint64_t v28 = 0;
  memset(v27, 0, sizeof(v27));
  sub_100052E44(a2, (uint64_t)v27);
  if (qword_1024194F0 != -1) {
    dispatch_once(&qword_1024194F0, &stru_1022DCC88);
  }
  int v4 = qword_1024194F8;
  if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEBUG))
  {
    BOOL v5 = a1;
    if (*((char *)a1 + 23) < 0) {
      BOOL v5 = (uint64_t *)*a1;
    }
    uint64_t v6 = *(void *)(a2 + 8);
    int v7 = *(unsigned __int8 *)(a2 + 144);
    double v8 = *(float *)(a2 + 112);
    double v9 = *(float *)(a2 + 116);
    double v10 = *(float *)(a2 + 132);
    double v11 = *(float *)(a2 + 136);
    double v12 = *(float *)(a2 + 128);
    double v13 = *(float *)(a2 + 124);
    double v14 = *(float *)(a2 + 120);
    int v15 = *(_DWORD *)(a2 + 140);
    *(_DWORD *)long long buf = 136317954;
    __int16 v54 = v5;
    __int16 v55 = 2048;
    uint64_t v56 = v6;
    __int16 v57 = 1024;
    int v58 = v27[0];
    __int16 v59 = 1024;
    int v60 = v7;
    __int16 v61 = 2048;
    double v62 = v8;
    __int16 v63 = 2048;
    double v64 = v9;
    __int16 v65 = 2048;
    double v66 = v10;
    __int16 v67 = 2048;
    double v68 = v11;
    __int16 v69 = 2048;
    double v70 = v12;
    __int16 v71 = 2048;
    double v72 = v13;
    __int16 v73 = 2048;
    double v74 = v14;
    __int16 v75 = 1024;
    int v76 = v15;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Activity,context,%s,startTime,%f,type,%u,standing,%d,angeX,%f,vectorMag,%f,strokeAmp,%f,strokePwr,%f,strokeFreq,%f,machineFreq,%f,pushVectorMag,%f,epochType,%d", buf, 0x6Eu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_1022DCC88);
    }
    if (*((char *)a1 + 23) < 0) {
      a1 = (uint64_t *)*a1;
    }
    uint64_t v16 = *(void *)(a2 + 8);
    int v17 = *(unsigned __int8 *)(a2 + 144);
    double v18 = *(float *)(a2 + 112);
    double v19 = *(float *)(a2 + 116);
    double v20 = *(float *)(a2 + 132);
    double v21 = *(float *)(a2 + 136);
    double v22 = *(float *)(a2 + 128);
    double v23 = *(float *)(a2 + 124);
    double v24 = *(float *)(a2 + 120);
    int v25 = *(_DWORD *)(a2 + 140);
    int v29 = 136317954;
    CFStringRef v30 = a1;
    __int16 v31 = 2048;
    uint64_t v32 = v16;
    __int16 v33 = 1024;
    int v34 = v27[0];
    __int16 v35 = 1024;
    int v36 = v17;
    __int16 v37 = 2048;
    double v38 = v18;
    __int16 v39 = 2048;
    double v40 = v19;
    __int16 v41 = 2048;
    double v42 = v20;
    __int16 v43 = 2048;
    double v44 = v21;
    __int16 v45 = 2048;
    double v46 = v22;
    __int16 v47 = 2048;
    double v48 = v23;
    __int16 v49 = 2048;
    double v50 = v24;
    __int16 v51 = 1024;
    int v52 = v25;
    id v26 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLOutdoorInputs::logActivity(const CLOutdoorActivity &)", "%s\n", v26);
    if (v26 != (char *)buf) {
      free(v26);
    }
  }
}

void sub_1001B1E60(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v31 = Current;
  double v30 = 0.0;
  uint64_t v3 = sub_1000A6958();
  sub_1000A699C(v3, "CLIgneousScheduledEnableLastRenewTime", &v30);
  if (Current - v30 > *(double *)(a1 + 440))
  {
    double v4 = drand48() * *(double *)(a1 + 440);
    uint64_t v5 = sub_1000A6958();
    sub_10016332C(v5, "CLIgneousScheduledEnableLastRenewTime", &v31);
    uint64_t v6 = sub_1000A6958();
    *(double *)long long buf = v4 + v31;
    sub_10016332C(v6, "CLIgneousScheduledEnableStartTime", buf);
    if (qword_102419320 != -1) {
      dispatch_once(&qword_102419320, &stru_10232C798);
    }
    int v7 = qword_102419328;
    if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = v4 + v31 + *(double *)(a1 + 432);
      *(_DWORD *)long long buf = 134349824;
      *(double *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(double *)&unsigned char buf[14] = v4;
      *(_WORD *)&buf[22] = 2050;
      double v39 = v4 + v31;
      LOWORD(v40) = 2050;
      *(double *)((char *)&v40 + 2) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "renewed Igneous random arm session,now,%{public}f,delay,%{public}f,startTime,%{public}f,endTime,%{public}f", buf, 0x2Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10232C798);
      }
      double v21 = v4 + v31 + *(double *)(a1 + 432);
      int v32 = 134349824;
      *(double *)__int16 v33 = v31;
      *(_WORD *)&v33[8] = 2050;
      *(double *)int v34 = v4;
      *(_WORD *)&v34[8] = 2050;
      double v35 = v4 + v31;
      __int16 v36 = 2050;
      double v37 = v21;
      double v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::scheduleRandomArmSessionIgneous()", "%s\n", v22);
      if (v22 != buf) {
        free(v22);
      }
    }
    uint64_t v9 = sub_1000A6958();
    sub_1000EA838(v9, "CLIgneousArmMinutes", (const void *)(a1 + 424));
    uint64_t v10 = *(void *)sub_1000A6958();
    (*(void (**)(void))(v10 + 944))();
    *(_DWORD *)(a1 + 420) = 0;
    sub_101535DE4(a1, 0);
    if (qword_102419320 != -1) {
      dispatch_once(&qword_102419320, &stru_10232C798);
    }
    double v11 = qword_102419328;
    if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)(a1 + 424);
      int v13 = *(_DWORD *)(a1 + 428);
      *(_DWORD *)long long buf = 67240704;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v13;
      *(_WORD *)&unsigned char buf[14] = 2050;
      *(double *)&uint8_t buf[16] = v31;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "replenish Igneous arm minutes,%{public}d,max motion trigger count,%{public}d,timestamp,%{public}f", buf, 0x18u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10232C798);
      }
      int v23 = *(_DWORD *)(a1 + 424);
      int v24 = *(_DWORD *)(a1 + 428);
      int v32 = 67240704;
      *(_DWORD *)__int16 v33 = v23;
      *(_WORD *)&v33[4] = 1026;
      *(_DWORD *)&v33[6] = v24;
      *(_WORD *)int v34 = 2050;
      *(double *)&v34[2] = v31;
      int v25 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::scheduleRandomArmSessionIgneous()", "%s\n", v25);
      if (v25 != buf) {
        free(v25);
      }
    }
    if (*(unsigned char *)(a1 + 418))
    {
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10232C798);
      }
      double v14 = qword_102419328;
      if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a1 + 408);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "unregister on DAS,%s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419320 != -1) {
          dispatch_once(&qword_102419320, &stru_10232C798);
        }
        uint64_t v26 = *(void *)(a1 + 408);
        int v32 = 136315138;
        *(void *)__int16 v33 = v26;
        __int16 v27 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::scheduleRandomArmSessionIgneous()", "%s\n", v27);
        if (v27 != buf) {
          free(v27);
        }
      }
      xpc_activity_unregister(*(const char **)(a1 + 408));
    }
    uint64_t v16 = *(const char **)(a1 + 408);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_101537890;
    double v39 = COERCE_DOUBLE(&unk_10232C7D8);
    *(void *)&long long v40 = a1;
    *((void *)&v40 + 1) = vcvtpd_s64_f64(v4);
    __int16 v41 = v16;
    xpc_activity_register(v16, XPC_ACTIVITY_CHECK_IN, buf);
    *(unsigned char *)(a1 + 418) = 1;
    if (*(unsigned char *)(a1 + 417))
    {
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10232C798);
      }
      int v17 = qword_102419328;
      if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(void *)(a1 + 400);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "unregister on DAS,%s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419320 != -1) {
          dispatch_once(&qword_102419320, &stru_10232C798);
        }
        uint64_t v28 = *(void *)(a1 + 400);
        int v32 = 136315138;
        *(void *)__int16 v33 = v28;
        int v29 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::scheduleRandomArmSessionIgneous()", "%s\n", v29);
        if (v29 != buf) {
          free(v29);
        }
      }
      xpc_activity_unregister(*(const char **)(a1 + 400));
    }
    unint64_t v19 = vcvtpd_s64_f64(v4 + *(double *)(a1 + 432));
    double v20 = *(const char **)(a1 + 400);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_101537890;
    double v39 = COERCE_DOUBLE(&unk_10232C7D8);
    *(void *)&long long v40 = a1;
    *((void *)&v40 + 1) = v19;
    __int16 v41 = v20;
    xpc_activity_register(v20, XPC_ACTIVITY_CHECK_IN, buf);
    *(unsigned char *)(a1 + 417) = 1;
  }
}

BOOL sub_1001B2658(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v5 = 0.0;
  uint64_t v3 = sub_1000A6958();
  sub_1000A699C(v3, "CLIgneousScheduledEnableStartTime", &v5);
  return Current > v5 && Current < v5 + *(double *)(a1 + 432);
}

void sub_1001B26D4(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current - *(double *)(a1 + 456) > *(double *)(a1 + 448))
  {
    *(double *)(a1 + 456) = Current;
    id v3 = +[SafetyAlerts sharedInterface];
    id v4 = [objc_msgSend(*(id *)(a1 + 32), "silo") queue];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    int v5[2] = sub_1015372F8;
    v5[3] = &unk_10232C778;
    v5[4] = a1;
    [v3 fetchIsSaewEnabledOnQueue:v4 withReply:v5];
  }
}

void sub_1001B2788(uint64_t a1, int a2)
{
  __int16 v17 = a2;
  char v18 = BYTE2(a2);
  sub_1000D2D08(a1, 10, &v17, 3uLL);
  buf[0] = 0;
  uint64_t v3 = sub_1000A6958();
  sub_1000D2988(v3, "CLIgneousArmStatus", (BOOL *)buf);
  if (buf[0]) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v18 == 0;
  }
  if (!v4)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v8 = Current;
    double v16 = Current;
    if (qword_102419320 != -1) {
      dispatch_once(&qword_102419320, &stru_10232C798);
    }
    uint64_t v9 = qword_102419328;
    if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(unsigned __int8 *)(a1 + 314);
      *(_DWORD *)long long buf = 134218240;
      double v24 = v8;
      __int16 v25 = 1024;
      int v26 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "save Igneous arm session startTime,%f,isCharging,%d", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10232C798);
      }
      int v14 = *(unsigned __int8 *)(a1 + 314);
      int v19 = 134218240;
      double v20 = v8;
      __int16 v21 = 1024;
      int v22 = v14;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::_updateAOPArmStatus(CMMotionCoprocessorCommand::Kappa::EnableClient)", "%s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
    uint64_t v11 = sub_1000A6958();
    sub_10016332C(v11, "CLIgneousArmSessionStartTime", &v16);
    uint64_t v12 = sub_1000A6958();
    sub_1000EA238(v12, "CLIgneousArmSessionIsCharging", (unsigned char *)(a1 + 314));
    uint64_t v13 = *(void *)sub_1000A6958();
    (*(void (**)(void))(v13 + 944))();
    *(CFAbsoluteTime *)(a1 + 464) = CFAbsoluteTimeGetCurrent();
    uint64_t v5 = a1;
    unsigned __int8 v6 = 1;
    goto LABEL_15;
  }
  if (buf[0] && !v18)
  {
    *(void *)(a1 + 464) = 0;
    uint64_t v5 = a1;
    unsigned __int8 v6 = 0;
LABEL_15:
    sub_1015370FC(v5, v6);
  }
  sub_10001A084(a1);
}

void sub_1001B2A4C(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 8;
  buf[0] = 0;
  uint64_t v5 = sub_1000A6958();
  sub_1000D2988(v5, "CLIgneousArmStatus", (BOOL *)buf);
  int v6 = buf[0];
  if (buf[0]) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = (*(void *)&v2 & 0xFF0000) == 0;
  }
  if (!v7)
  {
    if (!*(unsigned char *)(a1 + 416))
    {
      uint64_t v9 = *(const char **)(a1 + 392);
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v13 = 3221225472;
      *(void *)&long long v14 = sub_101537890;
      *((void *)&v14 + 1) = &unk_10232C7D8;
      uint64_t v15 = a1;
      uint64_t v16 = 0;
      __int16 v17 = v9;
      xpc_activity_register(v9, XPC_ACTIVITY_CHECK_IN, buf);
      *(unsigned char *)(a1 + 416) = 1;
    }
    sub_1001B2788(a1, (unsigned __int16)v2);
    if (qword_102419320 != -1) {
      dispatch_once(&qword_102419320, &stru_10232C798);
    }
    int v10 = qword_102419328;
    if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67240960;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v13) = 1026;
      *(_DWORD *)((char *)&v13 + 2) = v2;
      HIWORD(v13) = 1026;
      LODWORD(v14) = v4;
      WORD2(v14) = 1026;
      *(_DWORD *)((char *)&v14 + 6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "update AOP arm status,%{public}u, %{public}u, %{public}u, %{public}u", buf, 0x1Au);
    }
    if (!sub_10013D1A0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419320 == -1)
    {
LABEL_22:
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::updateAOPArmStatus(CMMotionCoprocessorCommand::Kappa::EnableClient)", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
      return;
    }
LABEL_24:
    dispatch_once(&qword_102419320, &stru_10232C798);
    goto LABEL_22;
  }
  sub_1001B2788(a1, v2 & 0xFFFFFF);
  if (qword_102419320 != -1) {
    dispatch_once(&qword_102419320, &stru_10232C798);
  }
  double v8 = qword_102419328;
  if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67240960;
    *(_DWORD *)&uint8_t buf[4] = v6;
    LOWORD(v13) = 1026;
    *(_DWORD *)((char *)&v13 + 2) = v2;
    HIWORD(v13) = 1026;
    LODWORD(v14) = v4;
    WORD2(v14) = 1026;
    *(_DWORD *)((char *)&v14 + 6) = BYTE2(v2);
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "update AOP arm status,%{public}u, %{public}u, %{public}u, %{public}u", buf, 0x1Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419320 == -1) {
      goto LABEL_22;
    }
    goto LABEL_24;
  }
}

void sub_1001B2E48(unsigned char *a1)
{
  BOOL v2 = sub_10000A8A4(a1);
  BOOL v3 = sub_1000085CC(a1);
  int v4 = sub_10006A7CC((uint64_t)a1);
  uint64_t v5 = 0x10000;
  if (!v4) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = 256;
  if (!v3) {
    uint64_t v6 = 0;
  }
  sub_1001B2A4C((uint64_t)a1, v6 | v2 | v5);
  if (qword_102419100 != -1) {
    dispatch_once(&qword_102419100, &stru_10232C638);
  }
  BOOL v7 = qword_102419108;
  if (os_log_type_enabled((os_log_t)qword_102419108, OS_LOG_TYPE_DEBUG))
  {
    int v8 = a1[328];
    *(_DWORD *)long long buf = 67109120;
    int v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "timeout fClientArmedRemotely %d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419100 != -1) {
      dispatch_once(&qword_102419100, &stru_10232C638);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLKappaNotifier::onSlowTimer()", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  if (a1[328]) {
    sub_10152BA04((uint64_t)a1);
  }
}

id sub_1001B3054(uint64_t a1, uint64_t a2)
{
  id v3 = [[-[NSArray objectAtIndexedSubscript:](sub_100122964(a1, a2)) objectAtIndexedSubscript:2] intValue];
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_1022C9768);
  }
  int v4 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    int v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = a2;
    __int16 v11 = 2050;
    uint64_t v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Client Effective registration result with TransientAwareness\", \"Client\":%{public, location:escape_only}@, \"registration\":%{public, location:CLClientRegistrationResult}lld}", (uint8_t *)v6, 0x26u);
  }
  return v3;
}

void sub_1001B316C(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(void *)a2;
  }
  id v7 = [[*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:+[CLClientKeyPath clientKeyPathWithLegacyClientKey:](CLClientKeyPath, "clientKeyPathWithLegacyClientKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6))];
  id v8 = +[NSMutableDictionary dictionary];
  __int16 v9 = *(void **)(a1 + 136);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472;
  id v30[2] = sub_10017AE04;
  v30[3] = &unk_1022C96B0;
  double v24 = v8;
  uint64_t v25 = a1;
  v30[4] = v8;
  void v30[5] = a3;
  v30[6] = a1;
  v30[7] = a2;
  [v9 iterateIdentitiesRelatedToKeyPath:v7 withBlock:v30];
  if ([a3 count])
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    uint64_t v10 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v11 = a2;
      }
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v32 = 2082;
      __int16 v33 = "";
      __int16 v34 = 2082;
      uint64_t v35 = v11;
      __int16 v36 = 2114;
      id v37 = a3;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"final info.plist zones for #pla registeration\", \"ClientKey\":%{public, location:escape_only}s, \"InfoPlistZones\":%{public, location:escape_only}@}", buf, 0x26u);
    }
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v12 = [a3 countByEnumeratingWithState:&v26 objects:v40 count:16];
    if (v12)
    {
      uint64_t v14 = *(void *)v27;
      *(void *)&long long v13 = 68289794;
      long long v23 = v13;
      do
      {
        uint64_t v15 = 0;
        do
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(a3);
          }
          uint64_t v16 = *(void **)(*((void *)&v26 + 1) + 8 * (void)v15);
          id v17 = [a3 objectForKeyedSubscript:v16, v23];
          if (sub_1007DF370(v17))
          {
            sub_100134750(buf, (char *)[v16 UTF8String]);
            sub_1007C8160(v25, a2, (std::string *)buf, v17, 1u, v24);
            if (SBYTE3(v35) < 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            if (qword_102419530 != -1) {
              dispatch_once(&qword_102419530, &stru_1022C9768);
            }
            char v18 = qword_102419538;
            if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(a2 + 23) >= 0) {
                uint64_t v19 = a2;
              }
              else {
                uint64_t v19 = *(void *)a2;
              }
              id v20 = [v16 UTF8String];
              *(_DWORD *)long long buf = v23;
              *(_DWORD *)&uint8_t buf[4] = 0;
              __int16 v32 = 2082;
              __int16 v33 = "";
              __int16 v34 = 2082;
              uint64_t v35 = v19;
              __int16 v36 = 2082;
              id v37 = v20;
              __int16 v38 = 2114;
              id v39 = v17;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#warning Info.plist zone registration failed. Invalid zone.\", \"ClientKey\":%{public, location:escape_only}s, \"ZoneId\":%{public, location:escape_only}s, \"Info.PlistZone\":%{public, location:escape_only}@}", buf, 0x30u);
            }
          }
          uint64_t v15 = (char *)v15 + 1;
        }
        while (v12 != v15);
        id v12 = [a3 countByEnumeratingWithState:&v26 objects:v40 count:16];
      }
      while (v12);
    }
  }
  else
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    __int16 v21 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v22 = a2;
      }
      else {
        uint64_t v22 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v32 = 2082;
      __int16 v33 = "";
      __int16 v34 = 2082;
      uint64_t v35 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#pla no-eligible info-plist zones for registeration\", \"ClientKey\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
  }
}

void sub_1001B3590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1001B35B4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 8) + 136) persist];
}

void sub_1001B35C0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = sub_100103D58(a1, a2);
  id v8 = [*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v7 defaultValue:0];
  int v9 = (int)v8;
  uint64_t v10 = (uint64_t)v8;
  if (a4 && !v8)
  {
    sub_100103240();
    if (sub_10010145C())
    {
      [*(id *)(a1 + 136) setInt:2 forKey:@"CorrectiveCompensationEnabled" atKeyPath:v7];
      uint64_t v10 = (uint64_t)[*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v7 defaultValue:0];
    }
    else
    {
      uint64_t v10 = 2;
    }
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    uint64_t v11 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 68289282;
      *(_DWORD *)__int16 v21 = 0;
      *(_WORD *)&v21[4] = 2082;
      *(void *)&void v21[6] = "";
      *(_WORD *)&v21[14] = 2114;
      *(void *)&v21[16] = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Sliding CorrectiveCompensationUnspecified(0) to CorrectiveCompensationOn(2)\", \"Client\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
  }
  [*(id *)(a1 + 136) setInt:a3 forKey:@"SupportedAuthorizationMask" atKeyPath:v7];
  sub_100103240();
  if ((sub_10010145C() & 1) == 0)
  {
    uint64_t v12 = sub_100101E40([objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v7) dictionary]);
    if (v12 == 4) {
      unint64_t v13 = a3 & 2;
    }
    else {
      unint64_t v13 = 0;
    }
    if ((v12 & a3) != 0) {
      unint64_t v14 = v12;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14 == v12)
    {
      if (v10 == v9) {
        return;
      }
    }
    else
    {
      uint64_t v15 = v12;
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      uint64_t v16 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138413058;
        *(void *)__int16 v21 = v7;
        *(_WORD *)&v21[8] = 2048;
        *(void *)&v21[10] = a3;
        *(_WORD *)&v21[18] = 2048;
        *(void *)&v21[20] = v15;
        __int16 v22 = 2048;
        unint64_t v23 = v14;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Client %@ allowable mask (%lu) no longer contains authorization level (%lu) downgrading to (%lu)", buf, 0x2Au);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022C9768);
        }
        char v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLClientManager::updateClientAllowableAuthorizationMask(CLClientKeyPath *, CLLocationDictionaryUtilitiesAuthorizationMask, BOOL)", "%s\n", v18);
        if (v18 != (char *)buf) {
          free(v18);
        }
      }
    }
    if ((sub_1007C1F6C(a1, (uint64_t)v7, v14, v10, 0, 1, 1) & 1) == 0)
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      id v17 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)__int16 v21 = v7;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Client %{public}@ missing for authorization update, but didn't we just create it?", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022C9768);
        }
        uint64_t v19 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLClientManager::updateClientAllowableAuthorizationMask(CLClientKeyPath *, CLLocationDictionaryUtilitiesAuthorizationMask, BOOL)", "%s\n", v19);
        if (v19 != (char *)buf) {
          free(v19);
        }
      }
    }
  }
}

uint64_t sub_1001B3AA0(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (![v3 bundleId] && !objc_msgSend(v3, "bundlePath"))
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    uint64_t v6 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Error no bundle ID or bundle path found - enabling background indicator %{public}@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      id v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLClientManager::getClientBackgroundIndicatorEnabled(CLClientKeyPath *)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    return 1;
  }
  if (![v3 isValidCKP]) {
    return 1;
  }
  int v4 = *(void **)(a1 + 136);

  return (uint64_t)[v4 BOOLForKey:@"BackgroundIndicatorEnabled" atKeyPath:v3 defaultValue:1];
}

id sub_1001B3CD8(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 136) dataForKey:@"ClientStorageToken" atKeyPath:a2 defaultValue:0];
  if (!v4)
  {
    id v4 = [objc_alloc((Class)NSMutableData) initWithLength:32];
    if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, [v4 mutableBytes])) {
      sub_101A6E1C0();
    }
    [*(id *)(a1 + 136) setData:v4 forKey:@"ClientStorageToken" atKeyPath:a2];
  }
  return v4;
}

void sub_1001B3D90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100103240();
  if ((sub_10010145C() & 1) != 0 || *(unsigned char *)(a1 + 1056)) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 1032);
  uint64_t v7 = *(void *)(a1 + 1040);
  if (v6 != v7)
  {
    while (*(void *)v6 != a2)
    {
      v6 += 32;
      if (v6 == v7) {
        goto LABEL_18;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_18:
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    uint64_t v10 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = "Unknown";
      if (a2 == 1) {
        uint64_t v11 = "Bluetooth";
      }
      if (a2) {
        uint64_t v12 = (char *)v11;
      }
      else {
        uint64_t v12 = "Wifi";
      }
      sub_100134750(&__p, v12);
      if (v43 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "ImproveAccuracyNotification object not created for technology, %{public}s", buf, 0xCu);
      if (SHIBYTE(v43) < 0) {
        operator delete(__p);
      }
    }
    if (!sub_10013D1A0(115, 0)) {
      return;
    }
    bzero(&__p, 0x65CuLL);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    unint64_t v14 = "Unknown";
    if (a2 == 1) {
      unint64_t v14 = "Bluetooth";
    }
    if (a2) {
      uint64_t v15 = (char *)v14;
    }
    else {
      uint64_t v15 = "Wifi";
    }
    sub_100134750(buf, v15);
    if (SBYTE3(v37) >= 0) {
      uint64_t v16 = buf;
    }
    else {
      uint64_t v16 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v33 = 136446210;
    *(void *)&v33[4] = v16;
    id v17 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE3(v37) < 0) {
      operator delete(*(void **)buf);
    }
    sub_1004BA5E4("Generic", 1, 0, 0, "void CLClientManager::ensureTechnologyEnabled(CLClientManagerTechnology, CLDaemonClient *)", "%s\n", v17);
    goto LABEL_102;
  }
  if (*(double *)(v6 + 16) < 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(v6 + 8) <= *(double *)(v6 + 16))
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    char v18 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v19 = "Unknown";
      if (a2 == 1) {
        uint64_t v19 = "Bluetooth";
      }
      if (a2) {
        id v20 = (char *)v19;
      }
      else {
        id v20 = "Wifi";
      }
      sub_100134750(&__p, v20);
      if (v43 >= 0) {
        __int16 v21 = &__p;
      }
      else {
        __int16 v21 = __p;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "improve accuracy notification for %s is not eligible to post.", buf, 0xCu);
      if (SHIBYTE(v43) < 0) {
        operator delete(__p);
      }
    }
    if (!sub_10013D1A0(115, 2)) {
      return;
    }
    bzero(&__p, 0x65CuLL);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_1022C9768);
    }
    double v30 = "Unknown";
    if (a2 == 1) {
      double v30 = "Bluetooth";
    }
    if (a2) {
      double v31 = (char *)v30;
    }
    else {
      double v31 = "Wifi";
    }
    sub_100134750(buf, v31);
    if (SBYTE3(v37) >= 0) {
      __int16 v32 = buf;
    }
    else {
      __int16 v32 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v33 = 136315138;
    *(void *)&v33[4] = v32;
    id v17 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE3(v37) < 0) {
      operator delete(*(void **)buf);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLClientManager::ensureTechnologyEnabled(CLClientManagerTechnology, CLDaemonClient *)", "%s\n", v17);
LABEL_102:
    if (v17 != (char *)&__p) {
      free(v17);
    }
    return;
  }
  if (*(void *)v6 != 1)
  {
    if (*(void *)v6 || !*(unsigned char *)(a1 + 1057)) {
      return;
    }
    if (sub_1007403DC())
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      id v8 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
      {
        std::string __p = (void *)68289026;
        LOWORD(v43) = 2082;
        *(void *)((char *)&v43 + 2) = "";
        id v9 = "{\"msg%{public}.0s\":\"WiFi is disabled, but the prompt will be suppressed because we're in demo mode\"}";
LABEL_88:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, v9, (uint8_t *)&__p, 0x12u);
        return;
      }
      return;
    }
    if (!*(unsigned char *)(a1 + 1568))
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_1022C9768);
      }
      id v8 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
      {
        std::string __p = (void *)68289026;
        LOWORD(v43) = 2082;
        *(void *)((char *)&v43 + 2) = "";
        id v9 = "{\"msg%{public}.0s\":\"WiFi is disabled, but the device has yet to be unlocked, so we will suppress the prompt for now\"}";
        goto LABEL_88;
      }
      return;
    }
LABEL_66:
    LODWORD(__p) = -1;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    __int16 v49 = 0;
    if (objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLAppMonitor"), "syncgetForegroundApp:", &__p))
    {
      int v22 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 192))(a3);
      if (v22 == __p && !*(void *)(a1 + 272) && !*(void *)(v6 + 24))
      {
        id v23 = sub_100138248(a3, 0);
        BOOL v24 = sub_1007B1D80(a1, (uint64_t)v23, a2, v6);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022C9768);
        }
        uint64_t v25 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
        {
          id v26 = sub_100138248(a3, 0);
          long long v27 = "Unknown";
          if (a2 == 1) {
            long long v27 = "Bluetooth";
          }
          if (a2) {
            long long v28 = (char *)v27;
          }
          else {
            long long v28 = "Wifi";
          }
          sub_100134750(v33, v28);
          if (v34 >= 0) {
            long long v29 = v33;
          }
          else {
            long long v29 = *(unsigned char **)v33;
          }
          *(_DWORD *)long long buf = 68289794;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          __int16 v36 = 2114;
          id v37 = v26;
          __int16 v38 = 2082;
          id v39 = v29;
          __int16 v40 = 1026;
          BOOL v41 = v24;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#AuthPrompt posted improve accuracy notification\", \"client\":%{public, location:escape_only}@, \"technology\":%{public, location:escape_only}s, \"status\":%{public}hhd}", buf, 0x2Cu);
          if (v34 < 0) {
            operator delete(*(void **)v33);
          }
        }
      }
    }
    sub_100783674((uint64_t)&__p);
    return;
  }
  if (*(unsigned char *)(a1 + 1058)) {
    goto LABEL_66;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_1022C9768);
  }
  id v8 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO))
  {
    std::string __p = (void *)68289026;
    LOWORD(v43) = 2082;
    *(void *)((char *)&v43 + 2) = "";
    id v9 = "{\"msg%{public}.0s\":\"bluetooth not disabled, suppress improve accuracy notification\"}";
    goto LABEL_88;
  }
}

void sub_1001B45B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_100783674((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001B45D8(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  uint64_t v1 = *(void **)(a1 + 136);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _OWORD v4[2] = sub_1000ABC60;
  v4[3] = &unk_1022C8E70;
  v4[4] = &v5;
  v4[5] = a1;
  [v1 iterateAllAnchorKeyPathsWithBlock:v4];
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1001B4684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001B469C(uint64_t a1, CLConnection *this)
{
  id v4 = *(void **)(a1 + 824);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = a1 + 824;
  do
  {
    unint64_t v6 = v4[4];
    BOOL v7 = v6 >= (unint64_t)this;
    if (v6 >= (unint64_t)this) {
      char v8 = v4;
    }
    else {
      char v8 = v4 + 1;
    }
    if (v7) {
      uint64_t v5 = (uint64_t)v4;
    }
    id v4 = (void *)*v8;
  }
  while (*v8);
  if (v5 != a1 + 824 && *(void *)(v5 + 32) <= (unint64_t)this)
  {
    sub_100036F24(a1, this);
  }
  else
  {
LABEL_12:
    id v9 = *(void **)(a1 + 848);
    if (!v9) {
      goto LABEL_23;
    }
    uint64_t v10 = a1 + 848;
    do
    {
      unint64_t v11 = v9[4];
      BOOL v12 = v11 >= (unint64_t)this;
      if (v11 >= (unint64_t)this) {
        unint64_t v13 = v9;
      }
      else {
        unint64_t v13 = v9 + 1;
      }
      if (v12) {
        uint64_t v10 = (uint64_t)v9;
      }
      id v9 = (void *)*v13;
    }
    while (*v13);
    if (v10 != a1 + 848 && *(void *)(v10 + 32) <= (unint64_t)this)
    {
      sub_1007B371C(a1, this);
    }
    else
    {
LABEL_23:
      unint64_t v14 = *(void **)(a1 + 896);
      if (v14)
      {
        uint64_t v15 = a1 + 896;
        do
        {
          unint64_t v16 = v14[4];
          BOOL v17 = v16 >= (unint64_t)this;
          if (v16 >= (unint64_t)this) {
            char v18 = v14;
          }
          else {
            char v18 = v14 + 1;
          }
          if (v17) {
            uint64_t v15 = (uint64_t)v14;
          }
          unint64_t v14 = (void *)*v18;
        }
        while (*v18);
        if (v15 != a1 + 896 && *(void *)(v15 + 32) <= (unint64_t)this)
        {
          std::string __p = *(void **)(v15 + 40);
          sub_1011C2140(__p);
          sub_1002F9B84((uint64_t **)(a1 + 912), (unint64_t *)&__p, (uint64_t *)&__p);
          sub_1000F0A30((uint64_t **)(a1 + 888), (uint64_t *)v15);
          double v30 = (void *)v15;
LABEL_82:
          operator delete(v30);
          return;
        }
      }
      if (*(CLConnection **)(a1 + 936) == this)
      {
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022C9768);
        }
        long long v28 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
        {
          CLConnection::getName((uint64_t *)&__p, *(CLConnection **)(a1 + 936));
          long long v29 = SBYTE3(v45) >= 0 ? &__p : (void **)__p;
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Client %{public}s disconnected", buf, 0xCu);
          if (SBYTE3(v45) < 0) {
            operator delete(__p);
          }
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(&__p, 0x65CuLL);
          if (qword_102419530 != -1) {
            dispatch_once(&qword_102419530, &stru_1022C9768);
          }
          CLConnection::getName((uint64_t *)buf, *(CLConnection **)(a1 + 936));
          if (v40 >= 0) {
            uint64_t v35 = buf;
          }
          else {
            uint64_t v35 = *(unsigned char **)buf;
          }
          *(_DWORD *)id v37 = 136446210;
          *(void *)&v37[4] = v35;
          __int16 v36 = (char *)_os_log_send_and_compose_impl();
          if (v40 < 0) {
            operator delete(*(void **)buf);
          }
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLClientManager::handleDisconnection(CLConnection *)", "%s\n", v36);
          if (v36 != (char *)&__p) {
            free(v36);
          }
        }
        CLConnection::deferredDelete(*(CLConnection **)(a1 + 936));
        *(void *)(a1 + 936) = 0;
      }
      else
      {
        CLConnection::getUserName((uint64_t *)&__p, this);
        uint64_t v19 = (uint64_t **)(a1 + 864);
        uint64_t v20 = sub_10012FFE0(a1 + 864, (const void **)&__p);
        uint64_t v21 = a1 + 872;
        if (SBYTE3(v45) < 0) {
          operator delete(__p);
        }
        if (v21 != v20)
        {
          CLConnection::getUserName((uint64_t *)buf, this);
          uint64_t v22 = sub_10012FFE0((uint64_t)v19, (const void **)buf);
          sub_100645C00(v19, v22);
          if (qword_102419530 != -1) {
            dispatch_once(&qword_102419530, &stru_1022C9768);
          }
          id v23 = qword_102419538;
          if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
          {
            int v24 = v40;
            uint64_t v25 = *(unsigned char **)buf;
            CLConnection::getName((uint64_t *)v37, this);
            id v26 = buf;
            if (v24 < 0) {
              id v26 = v25;
            }
            if (v38 >= 0) {
              long long v27 = v37;
            }
            else {
              long long v27 = *(unsigned char **)v37;
            }
            std::string __p = (void *)68289538;
            __int16 v42 = 2082;
            long long v43 = "";
            __int16 v44 = 2082;
            long long v45 = v26;
            __int16 v46 = 2082;
            long long v47 = v27;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#CoreLocationAgent disconnected\", \"UserName\":%{public, location:escape_only}s, \"Connection\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
            if (v38 < 0) {
              operator delete(*(void **)v37);
            }
          }
          goto LABEL_80;
        }
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_1022C9768);
        }
        double v31 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
        {
          CLConnection::getName((uint64_t *)buf, this);
          if (v40 >= 0) {
            __int16 v32 = buf;
          }
          else {
            __int16 v32 = *(unsigned char **)buf;
          }
          std::string __p = (void *)68289282;
          __int16 v42 = 2082;
          long long v43 = "";
          __int16 v44 = 2082;
          long long v45 = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Got disconnection for unknown client\", \"Connection\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
          if (v40 < 0) {
            operator delete(*(void **)buf);
          }
          if (qword_102419530 != -1) {
            dispatch_once(&qword_102419530, &stru_1022C9768);
          }
        }
        __int16 v33 = qword_102419538;
        if (os_signpost_enabled((os_log_t)qword_102419538))
        {
          CLConnection::getName((uint64_t *)buf, this);
          if (v40 >= 0) {
            char v34 = buf;
          }
          else {
            char v34 = *(unsigned char **)buf;
          }
          std::string __p = (void *)68289282;
          __int16 v42 = 2082;
          long long v43 = "";
          __int16 v44 = 2082;
          long long v45 = v34;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v33, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Got disconnection for unknown client", "{\"msg%{public}.0s\":\"Got disconnection for unknown client\", \"Connection\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
LABEL_80:
          if ((v40 & 0x80000000) == 0) {
            return;
          }
          double v30 = *(void **)buf;
          goto LABEL_82;
        }
      }
    }
  }
}

void sub_1001B4D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001B4D58(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 20) <= 0.0)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10230D040);
    }
    id v4 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      unint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTilesManager.mm";
      __int16 v15 = 1024;
      int v16 = 2700;
      __int16 v17 = 2080;
      char v18 = "location.horizontalAccuracy > 0.0";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10230D040);
      }
      int v7 = 136315650;
      char v8 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTilesManager.mm";
      __int16 v9 = 1024;
      int v10 = 2700;
      __int16 v11 = 2080;
      BOOL v12 = "location.horizontalAccuracy > 0.0";
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    sub_1004BA578();
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_100142F90;
  v6[3] = &unk_1022C9848;
  v6[4] = a1;
  void v6[5] = a2;
  sub_10015E8B0(a1, (uint64_t)"updateTileLocationRelevancy", (uint64_t)v6);
}

uint64_t sub_1001B4FD0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 112);
  uint64_t v2 = (void *)(a1 + 120);
  if (v1 == (void *)(a1 + 120)) {
    return 0;
  }
  LODWORD(v3) = 0;
  do
  {
    uint64_t v4 = sub_1001BF5C0(v1[10]);
    BOOL v5 = sub_100065F70(v1[10]);
    uint64_t v3 = (v3 + v5);
    if (v5)
    {
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230D000);
      }
      unint64_t v6 = qword_102419388;
      if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v1[10] + 16))(__p);
        int v7 = __p;
        if (v20 < 0) {
          int v7 = *(unsigned char **)__p;
        }
        *(_DWORD *)long long buf = 136315906;
        int v24 = v7;
        __int16 v25 = 1024;
        int v26 = 1;
        __int16 v27 = 1024;
        int v28 = v3;
        __int16 v29 = 2048;
        uint64_t v30 = v4;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "TILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p", buf, 0x22u);
        if (SHIBYTE(v20) < 0) {
          operator delete(*(void **)__p);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419380 != -1) {
          dispatch_once(&qword_102419380, &stru_10230D000);
        }
        (*(void (**)(void **__return_ptr))(*(void *)v1[10] + 16))(v14);
        __int16 v11 = v14;
        if (v15 < 0) {
          __int16 v11 = (void **)v14[0];
        }
        *(_DWORD *)std::string __p = 136315906;
        *(void *)&__p[4] = v11;
        __int16 v17 = 1024;
        int v18 = 1;
        __int16 v19 = 1024;
        int v20 = v3;
        __int16 v21 = 2048;
        uint64_t v22 = v4;
        BOOL v12 = (char *)_os_log_send_and_compose_impl();
        if (v15 < 0) {
          operator delete(v14[0]);
        }
        sub_1004BA5E4("Generic", 1, 0, 2, "unsigned int CLTilesManager::getNumOfActiveDownloads()", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
    }
    char v8 = (void *)v1[1];
    if (v8)
    {
      do
      {
        __int16 v9 = v8;
        char v8 = (void *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        __int16 v9 = (void *)v1[2];
        BOOL v10 = *v9 == (void)v1;
        uint64_t v1 = v9;
      }
      while (!v10);
    }
    uint64_t v1 = v9;
  }
  while (v9 != v2);
  return v3;
}

void sub_1001B52F4(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 51;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 96) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111B5B0(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLMotionCoprocessorInterface::Tier1CyclingFeatures>::update(CFAbsoluteTime) [T = CLMotionCoprocessorInterface::Tier1CyclingFeatures]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 102;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 96) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = (void *)(v11 + 8 * (v10 / 0x66));
    if (v12 == v11)
    {
      unint64_t v14 = 0;
      int v18 = 0;
      char v15 = (void *)(a1 + 56);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) / 0x66));
    }
    else
    {
      unint64_t v14 = (long long *)(*(void *)(v11 + 8 * (v10 / 0x66)) + 40 * (v10 % 0x66));
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 / 0x66));
      int v18 = (long long *)(*v17 + 40 * (v16 % 0x66));
    }
    id v23 = sub_10112299C(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0x66));
    __int16 v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 40 * (v24 % 0x66));
    sub_1010A3AD4((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 96) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B56EC(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 128;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 96) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111B418(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLCyclingStateDetector_Type::CyclingResult>::update(CFAbsoluteTime) [T = CLCyclingStateDetector_Type::CyclingResult]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 256;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 96) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = (void *)(v11 + 8 * (v10 >> 8));
    if (v12 == v11)
    {
      char v15 = 0;
      int v18 = 0;
      unint64_t v14 = (void *)(a1 + 56);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) >> 8));
    }
    else
    {
      unint64_t v14 = (void *)(a1 + 56);
      char v15 = (double *)(*v13 + 16 * v10);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 >> 8));
      int v18 = (double *)(*v17 + 16 * v16);
    }
    id v23 = (char *)sub_10017C060(v13, v15, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (char *)(v25 + 8 * (v24 >> 8));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : *(void *)v26 + 16 * v24;
    sub_100065154((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v14) {
      *(void *)(a1 + 96) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B5A98(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 51;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 96) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111B1C0(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLWorkoutClassifier_Type::SmoothedTier2ClassifierResult>::update(CFAbsoluteTime) [T = CLWorkoutClassifier_Type::SmoothedTier2ClassifierResult]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 102;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 96) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = (void *)(v11 + 8 * (v10 / 0x66));
    if (v12 == v11)
    {
      unint64_t v14 = 0;
      int v18 = 0;
      char v15 = (void *)(a1 + 56);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) / 0x66));
    }
    else
    {
      unint64_t v14 = (long long *)(*(void *)(v11 + 8 * (v10 / 0x66)) + 40 * (v10 % 0x66));
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 / 0x66));
      int v18 = (long long *)(*v17 + 40 * (v16 % 0x66));
    }
    id v23 = sub_101122264(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0x66));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 40 * (v24 % 0x66));
    sub_100176970((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 96) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B5E90(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 28;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 96) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_1006AC0E8(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLWorkoutClassifier_Type::WorkoutClassifierResult>::update(CFAbsoluteTime) [T = CLWorkoutClassifier_Type::WorkoutClassifierResult]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 56;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 96) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = (void *)(v11 + 8 * (v10 / 0x38));
    if (v12 == v11)
    {
      uint64_t v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 56);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) / 0x38));
    }
    else
    {
      uint64_t v14 = *(void *)(v11 + 8 * (v10 / 0x38)) + 72 * (v10 % 0x38);
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 / 0x38));
      uint64_t v18 = *v17 + 72 * (v16 % 0x38);
    }
    id v23 = sub_100AD9184(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0x38));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 72 * (v24 % 0x38));
    sub_101121C74((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 96) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B6288(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 128;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 96) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_1006BFA44(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLWorkoutPredictorWatchPressure>::update(CFAbsoluteTime) [T = CLWorkoutPredictorWatchPressure]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 256;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 96) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = (void *)(v11 + 8 * (v10 >> 8));
    if (v12 == v11)
    {
      char v15 = 0;
      uint64_t v18 = 0;
      uint64_t v14 = (void *)(a1 + 56);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) >> 8));
    }
    else
    {
      uint64_t v14 = (void *)(a1 + 56);
      char v15 = (double *)(*v13 + 16 * v10);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 >> 8));
      uint64_t v18 = (double *)(*v17 + 16 * v16);
    }
    id v23 = (char *)sub_10017C060(v13, v15, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (char *)(v25 + 8 * (v24 >> 8));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : *(void *)v26 + 16 * v24;
    sub_100065154((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v14) {
      *(void *)(a1 + 96) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B6634(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 320);
  *(double *)(a1 + 320) = v2;
  if (*(unsigned char *)(a1 + 264) && *(double *)(a1 + 328) < v2)
  {
    *(unsigned char *)(a1 + 264) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    BOOL v5 = *(void ***)(a1 + 280);
    uint64_t v6 = *(void *)(a1 + 288);
    *(void *)(a1 + 312) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 288);
        BOOL v5 = (void **)(*(void *)(a1 + 280) + 8);
        *(void *)(a1 + 280) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 32;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 360) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 264)) {
          sub_10111ABE0(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 320);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLElevationChangeEntry>::update(CFAbsoluteTime) [T = CLElevationChangeEntry]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 64;
    }
    *(void *)(a1 + 304) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 360) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 304);
    uint64_t v11 = *(void *)(a1 + 280);
    uint64_t v12 = *(void *)(a1 + 288);
    unint64_t v13 = (void *)(v11 + 8 * (v10 >> 6));
    if (v12 == v11)
    {
      uint64_t v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 312);
      __int16 v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 312) + v10) >> 6));
    }
    else
    {
      uint64_t v14 = (double *)(*v13 + ((v10 & 0x3F) << 6));
      char v15 = (void *)(a1 + 312);
      unint64_t v16 = *(void *)(a1 + 312) + v10;
      __int16 v17 = (void *)(v11 + 8 * (v16 >> 6));
      uint64_t v18 = (long long *)(*v17 + ((v16 & 0x3F) << 6));
    }
    id v23 = (char *)sub_10017C1C0(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 304) + *(void *)(a1 + 312);
    uint64_t v25 = *(void *)(a1 + 280);
    int v26 = (char *)(v25 + 8 * (v24 >> 6));
    uint64_t v27 = *(void *)(a1 + 288) == v25 ? 0 : *(void *)v26 + ((v24 & 0x3F) << 6);
    sub_100170EA4((void *)(a1 + 272), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 360) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B69EC(uint64_t a1, long long *a2)
{
  if (sub_1000A026C(a1 + 8, a2, v16))
  {
    uint64_t v3 = *(void *)(a1 + 440);
    if (v3) {
      (*(void (**)(uint64_t, long long *))(*(void *)v3 + 48))(v3, v16);
    }
    uint64_t v4 = *(void *)(a1 + 312);
    if (!v4) {
      goto LABEL_18;
    }
    unint64_t v5 = v4 + *(void *)(a1 + 304) - 1;
    uint64_t v6 = *(void ***)(a1 + 280);
    double v7 = (*(double **)((char *)v6 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)))[8 * (v5 & 0x3F) + 1];
    if (v7 <= *((double *)v16 + 1)) {
      goto LABEL_18;
    }
    uint64_t v8 = *(void *)(a1 + 288);
    *(void *)(a1 + 312) = 0;
    unint64_t v9 = v8 - (void)v6;
    if (v9 >= 0x11)
    {
      do
      {
        operator delete(*v6);
        uint64_t v10 = *(void *)(a1 + 288);
        uint64_t v6 = (void **)(*(void *)(a1 + 280) + 8);
        *(void *)(a1 + 280) = v6;
        unint64_t v9 = v10 - (void)v6;
      }
      while (v9 > 0x10);
    }
    if (v9 >> 3 == 1)
    {
      uint64_t v11 = 32;
    }
    else
    {
      if (v9 >> 3 != 2)
      {
LABEL_13:
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_1022C2688);
        }
        uint64_t v12 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 134218240;
          uint64_t v22 = *((void *)&v16[0] + 1);
          __int16 v23 = 2048;
          double v24 = v7;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "time rollback on add, newItemTime, %f, lastItemTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_1022C2688);
          }
          int v17 = 134218240;
          uint64_t v18 = *((void *)&v16[0] + 1);
          __int16 v19 = 2048;
          double v20 = v7;
          char v15 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLElevationChangeEntry>::add(const T &) [T = CLElevationChangeEntry]", "%s\n", v15);
          if (v15 != (char *)buf) {
            free(v15);
          }
        }
LABEL_18:
        sub_1000A01D4((void *)(a1 + 272), (uint64_t)v16);
        long long v13 = v16[1];
        *(_OWORD *)(a1 + 352) = v16[0];
        *(_OWORD *)(a1 + 368) = v13;
        long long v14 = v16[3];
        *(_OWORD *)(a1 + 384) = v16[2];
        *(_OWORD *)(a1 + 400) = v14;
        return;
      }
      uint64_t v11 = 64;
    }
    *(void *)(a1 + 304) = v11;
    goto LABEL_13;
  }
}

void sub_1001B6CB4(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    unint64_t v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        unint64_t v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 85;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 104) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_1006BFAD8(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLExerciseMinuteData>::update(CFAbsoluteTime) [T = CLExerciseMinuteData]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 170;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 104) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    long long v13 = (void *)(v11 + 8 * (v10 / 0xAA));
    if (v12 == v11)
    {
      long long v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 56);
      int v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) / 0xAA));
    }
    else
    {
      long long v14 = (long long *)(*(void *)(v11 + 8 * (v10 / 0xAA)) + 24 * (v10 % 0xAA));
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      int v17 = (void *)(v11 + 8 * (v16 / 0xAA));
      uint64_t v18 = (long long *)(*v17 + 24 * (v16 % 0xAA));
    }
    __int16 v23 = sub_1011225B0(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0xAA));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 24 * (v24 % 0xAA));
    sub_100057798((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 104) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B709C(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    unint64_t v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        unint64_t v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 11;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 104) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111AF14(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLStepCountEntry>::update(CFAbsoluteTime) [T = CLStepCountEntry]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 23;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 104) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    long long v13 = (void *)(v11 + 8 * (v10 / 0x17));
    if (v12 == v11)
    {
      long long v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 56);
      int v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) / 0x17));
    }
    else
    {
      long long v14 = (double *)(*(void *)(v11 + 8 * (v10 / 0x17)) + 176 * (v10 % 0x17));
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      int v17 = (void *)(v11 + 8 * (v16 / 0x17));
      uint64_t v18 = (long long *)(*v17 + 176 * (v16 % 0x17));
    }
    __int16 v23 = sub_101121B98(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0x17));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 176 * (v24 % 0x17));
    sub_100173D90((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 104) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B74B4(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    unint64_t v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        unint64_t v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 32;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 136) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111AD50(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLCatherineData>::update(CFAbsoluteTime) [T = CLCatherineData]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 64;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 136) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    long long v13 = (void *)(v11 + 8 * (v10 >> 6));
    if (v12 == v11)
    {
      long long v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 56);
      int v17 = (void *)(v11 + 8 * ((*(void *)(a1 + 56) + v10) >> 6));
    }
    else
    {
      long long v14 = (double *)(*v13 + ((v10 & 0x3F) << 6));
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      int v17 = (void *)(v11 + 8 * (v16 >> 6));
      uint64_t v18 = (long long *)(*v17 + ((v16 & 0x3F) << 6));
    }
    __int16 v23 = (char *)sub_101121AE0(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (char *)(v25 + 8 * (v24 >> 6));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : *(void *)v26 + ((v24 & 0x3F) << 6);
    sub_100170EA4((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 136) = 0xBFF0000000000000;
    }
  }
}

void sub_1001B786C(uint64_t a1, __n128 a2)
{
  double v2 = a2.n128_f64[0];
  a2.n128_u64[0] = *(void *)(a1 + 64);
  *(double *)(a1 + 64) = v2;
  if (*(unsigned char *)(a1 + 8) && *(double *)(a1 + 72) < v2)
  {
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(void (**)(__n128))(*(void *)a1 + 24);
    v4(a2);
    return;
  }
  if (a2.n128_f64[0] > v2)
  {
    unint64_t v5 = *(void ***)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 56) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(a1 + 32);
        unint64_t v5 = (void **)(*(void *)(a1 + 24) + 8);
        *(void *)(a1 + 24) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 13;
    }
    else
    {
      if (v7 >> 3 != 2)
      {
LABEL_17:
        *(void *)(a1 + 136) = 0xBFF0000000000000;
        if (*(unsigned char *)(a1 + 8)) {
          sub_10111B384(a1);
        }
        if (qword_102418FD0 != -1) {
          dispatch_once(&qword_102418FD0, &stru_102312878);
        }
        __int16 v19 = qword_102418FD8;
        if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 134218240;
          double v29 = v2;
          __int16 v30 = 2048;
          uint64_t v31 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "time rollback on update, currentTime, %f, lastUpdateTime, %f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FD0 != -1) {
            dispatch_once(&qword_102418FD0, &stru_102312878);
          }
          __int16 v21 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSourceBuffer<CLSwimEntry>::update(CFAbsoluteTime) [T = CLSwimEntry]", "%s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        return;
      }
      uint64_t v9 = 26;
    }
    *(void *)(a1 + 48) = v9;
    goto LABEL_17;
  }
  if (*(double *)(a1 + 136) != -1.0)
  {
    unint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    long long v13 = (void *)(v11 + 8 * (v10 / 0x1A));
    if (v12 == v11)
    {
      uint64_t v14 = 0;
      uint64_t v18 = 0;
      char v15 = (void *)(a1 + 56);
      int v17 = (void *)(v11
                     + ((((*(void *)(a1 + 56) + v10) * (unsigned __int128)0x4EC4EC4EC4EC4EC5uLL) >> 64) & 0x7FFFFFFFFFFFFFF8));
    }
    else
    {
      uint64_t v14 = *(void *)(v11 + 8 * (v10 / 0x1A)) + 152 * (v10 % 0x1A);
      char v15 = (void *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56) + v10;
      int v17 = (void *)(v11 + 8 * (v16 / 0x1A));
      uint64_t v18 = *v17 + 152 * (v16 % 0x1A);
    }
    __int16 v23 = sub_1011224D4(v13, v14, (uint64_t)v17, v18, *(uint64_t *)&v2, a1);
    unint64_t v24 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 24);
    int v26 = (void *)(v25 + 8 * (v24 / 0x1A));
    uint64_t v27 = *(void *)(a1 + 32) == v25 ? 0 : (char *)(*v26 + 152 * (v24 % 0x1A));
    sub_100174118((void *)(a1 + 16), v23, v22, v26, v27);
    if (!*v15) {
      *(void *)(a1 + 136) = 0xBFF0000000000000;
    }
  }
}

uint64_t sub_1001B7C64()
{
  if (qword_10247D488 != -1) {
    dispatch_once(&qword_10247D488, &stru_1022C66D0);
  }
  return byte_10247D480;
}

BOOL sub_1001B7CA8()
{
  if (qword_10247D348 != -1) {
    dispatch_once(&qword_10247D348, &stru_1022C65D0);
  }
  return dword_10247D340 == 143;
}

void *sub_1001B7CF4(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryFunctionalStrengthDMFeatures]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 8));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + 16 * v9;
  }
  uint64_t v14 = v10 + 8 * (v9 >> 8);
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*(unsigned char *)(a1 + 64) + v9);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 2;
    v13 += 16;
    if (*(void *)v14 + 4096 == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)v12 + 16 * v9;
  }
  return sub_100065154((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

unint64_t sub_1001B8040(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCalorimetryKickboxingDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryKickboxingDMFeatures]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0xAA));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0xAA));
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0xAA)) + 24 * ((*(void *)(a1 + 64) + v9) % 0xAA);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 3;
    v13 += 24;
    if ((char *)(*v14 + 4080) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  return sub_100057798((void *)(a1 + 24), v12, v18, v14, v13);
}

void *sub_1001B83BC(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCalorimetryRowingDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryRowingDMFeatures]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 7));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 7);
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*(void *)(a1 + 64) + v9) & 0x7F);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 4;
    v13 += 32;
    if (*(void *)v14 + 4096 == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  return sub_100173080((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

void *sub_1001B8714(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 121) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 122);
      *(_DWORD *)long long buf = 134218752;
      double v25 = v7 - v4;
      __int16 v26 = 2048;
      double v27 = v4;
      __int16 v28 = 2048;
      double v29 = v7;
      __int16 v30 = 1024;
      int v31 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, all-day elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      __int16 v23 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCoarseElevationChangeEntry>::update(CFAbsoluteTime)", "%s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 122)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 121))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 8));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + 16 * v9;
  }
  uint64_t v14 = v10 + 8 * (v9 >> 8);
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*(unsigned char *)(a1 + 64) + v9);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 2;
    v13 += 16;
    if (*(void *)v14 + 4096 == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)v12 + 16 * v9;
  }
  double result = sub_100065154((void *)(a1 + 24), v12, v18, (char *)v14, v13);
  uint64_t v20 = *(void *)(a1 + 64);
  if (v20) {
    double v21 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
                                + (((unint64_t)(v20 + *(void *)(a1 + 56) - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                    + 16 * (v20 + *(unsigned char *)(a1 + 56) - 1))
        + 180.0
        + 20.0;
  else {
    double v21 = -1.79769313e308;
  }
  BOOL v22 = v21 > a2 && !*(unsigned char *)(a1 + 123);
  *(unsigned char *)(a1 + 120) = v22;
  return result;
}

unint64_t sub_1001B8AD0(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCalorimetryDanceDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryDanceDMFeatures]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0xAA));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0xAA));
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0xAA)) + 24 * ((*(void *)(a1 + 64) + v9) % 0xAA);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 3;
    v13 += 24;
    if ((char *)(*v14 + 4080) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  return sub_100057798((void *)(a1 + 24), v12, v18, v14, v13);
}

unint64_t sub_1001B8E4C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_1022F3D80);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_1022F3D80);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLExtendedStepCountEntry>::update(CFAbsoluteTime) [T = CLExtendedStepCountEntry]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 4));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*(void *)v12 + 320 * (*(void *)(a1 + 56) & 0xFLL));
  }
  uint64_t v14 = (char *)(v10 + 8 * (v9 >> 4));
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 320 * ((*(_DWORD *)(a1 + 64) + v9) & 0xF);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 40;
    v13 += 320;
    if ((char *)(*(void *)v14 + 5120) == v13)
    {
      uint64_t v17 = (char *)*((void *)v14 + 1);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*(void *)v12 + 320 * (*(void *)(a1 + 56) & 0xFLL));
  }
  return sub_1000BAAB8((void *)(a1 + 24), v12, v18, v14, v13);
}

unint64_t sub_1001B91B4(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<_CLFitnessMachineData>::update(CFAbsoluteTime) [Data_T = _CLFitnessMachineData]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0x18));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 168 * (v9 % 0x18));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0x18));
LABEL_15:
  char v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x18)) + 168 * ((*(void *)(a1 + 64) + v9) % 0x18);
    if (v15 == (double *)v16 || vabdd_f64(*(double *)(a1 + 104), *v15) <= 1200.0) {
      break;
    }
    v15 += 21;
    v13 += 168;
    if ((char *)(*v14 + 4032) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 168 * (v9 % 0x18));
  }
  return sub_100173A58((void *)(a1 + 24), v12, v18, v14, v13);
}

unint64_t sub_1001B9530(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLStepCountEntry>::update(CFAbsoluteTime) [Data_T = CLStepCountEntry]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0x17));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 176 * (v9 % 0x17));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0x17));
LABEL_15:
  char v15 = v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x17)) + 176 * ((*(void *)(a1 + 64) + v9) % 0x17);
    if (v15 == (char *)v16 || vabdd_f64(*(double *)(a1 + 104), *((double *)v15 + 1)) <= 1200.0) {
      break;
    }
    v13 += 176;
    v15 += 176;
    if ((char *)(*v14 + 4048) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 176 * (v9 % 0x17));
  }
  return sub_100173D90((void *)(a1 + 24), v12, v18, v14, v13);
}

BOOL sub_1001B98C4(uint64_t a1, double a2)
{
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
                               + (((unint64_t)(v4 + *(void *)(a1 + 56) - 1) >> 3) & 0x1FFFFFFFFFFFFFF8))
                   + (((v4 + *(void *)(a1 + 56) - 1) & 0x3F) << 6)
                   + 40);
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    if (sub_10007E234(a1, (uint64_t)v11, v10, a2)) {
      return 1;
    }
    uint64_t v6 = (unsigned char *)(a1 + 80);
    goto LABEL_11;
  }
  uint64_t v6 = (unsigned char *)(a1 + 80);
  if (*(unsigned char *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
      if (v8 - (*(double (**)(uint64_t, double))(*(void *)a1 + 56))(a1, a2) < a2) {
        return 0;
      }
    }
LABEL_11:
    if (*v6) {
      return 1;
    }
  }
  return *(unsigned char *)(a1 + 120) || *(double *)(a1 + 104) + -2.0 >= a2;
}

void *sub_1001B9A04(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLCatherineData>::update(CFAbsoluteTime) [Data_T = CLCatherineData]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 6));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 6);
LABEL_15:
  uint64_t v15 = v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 3) & 0x1FFFFFFFFFFFFFF8))
        + (((*(void *)(a1 + 64) + v9) & 0x3F) << 6);
    if (v15 == v16 || vabdd_f64(*(double *)(a1 + 104), *(double *)(v15 + 40)) <= 1200.0) {
      break;
    }
    v13 += 64;
    v15 += 64;
    if (*(void *)v14 + 4096 == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  return sub_100170EA4((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

unint64_t sub_1001B9D5C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(unsigned char *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10231B970);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)long long buf = 134218752;
      double v22 = v7 - v4;
      __int16 v23 = 2048;
      double v24 = v4;
      __int16 v25 = 2048;
      double v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10231B970);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNatalieInput<CLSwimEntry>::update(CFAbsoluteTime) [Data_T = CLSwimEntry]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80)
    && !*(unsigned char *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(unsigned char *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    *(unsigned char *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0x1A));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 152 * (v9 % 0x1A));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0x1A));
LABEL_15:
  uint64_t v15 = v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x1A)) + 152 * ((*(void *)(a1 + 64) + v9) % 0x1A);
    if (v15 == (char *)v16 || vabdd_f64(*(double *)(a1 + 104), *((double *)v15 + 5)) <= 1200.0) {
      break;
    }
    v13 += 152;
    v15 += 152;
    if ((char *)(*v14 + 3952) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }
  if (v11 == v10) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 152 * (v9 % 0x1A));
  }
  return sub_100174118((void *)(a1 + 24), v12, v18, v14, v13);
}

uint64_t sub_1001BA0E0(long long *a1, uint64_t a2)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a2 + 32), "silo") assertInside];

  return sub_100037B78(a2, a1);
}

uint64_t sub_1001BA134(uint64_t result, int a2, char a3)
{
  uint64_t v3 = result;
  if (a2)
  {
    double result = sub_1000A16E8();
    if ((result & 0x1000000) != 0)
    {
      int v5 = 1;
    }
    else
    {
      int v5 = *(unsigned char *)(v3 + 534) != 0;
      if (!*(unsigned char *)(v3 + 534)) {
        goto LABEL_9;
      }
    }
    if (a3)
    {
LABEL_9:
      int v6 = v5;
      goto LABEL_10;
    }
    int v6 = *(unsigned char *)(v3 + 533) != 0;
  }
  else
  {
    int v5 = 0;
    int v6 = 0;
  }
LABEL_10:
  if (*(unsigned __int8 *)(v3 + 531) != v5 || *(unsigned __int8 *)(v3 + 532) != v6)
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_102325788);
    }
    double v7 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v5;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Authorization changed, authorized for location, %d, active scanning, %d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_102325788);
      }
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionState7::updateStateOnAuthorization(BOOL, BOOL)", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    uint64_t v8 = *(void *)(v3 + 616);
    if (v8)
    {
      *(void *)(v3 + 616) = 0;
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    [*(id *)(*(void *)(v3 + 608) + 16) unregister:*(void *)(*(void *)(v3 + 608) + 8) forNotification:22];
    if (v5)
    {
      __asm { FMOV            V0.2D, #-1.0 }
      *(_OWORD *)long long buf = _Q0;
      char v17 = 0;
      int v18 = 0;
      int v19 = 0;
      char v16 = v6;
      sub_10012F770();
    }
    double result = (uint64_t)[[(id)[(id)[(id)[*(id *)(v3 + 32) vendor] proxyForService:@"CLVehicleStateNotifier"] resetVehicularFalsePositiveSuppressionDnd]];
    *(unsigned char *)(v3 + 531) = 0;
    *(unsigned char *)(v3 + 532) = v6;
  }
  return result;
}

BOOL sub_1001BA49C(uint64_t a1, double a2, double a3)
{
  double v9 = a2;
  double v4 = a3 - a2;
  BOOL v5 = v4 > -60.0 && fabs(v4) < *(double *)(a1 + 544);
  if (*(double *)(a1 + 536) != a2)
  {
    uint64_t v6 = sub_1000A6958();
    sub_10016332C(v6, "LastMotionStateQuery", &v9);
    uint64_t v7 = *(void *)sub_1000A6958();
    (*(void (**)(void))(v7 + 944))();
    *(double *)(a1 + 536) = v9;
  }
  return v5;
}

uint64_t sub_1001BA55C()
{
  if (qword_10247E1E0 != -1) {
    dispatch_once(&qword_10247E1E0, &stru_1022CA790);
  }
  return qword_10248A3B8;
}

void sub_1001BA5A0(uint64_t a1, double a2)
{
  int v4 = sub_1001AF7C4(a1 + 904);
  if (*(unsigned char *)(a1 + 612) && ((int v5 = v4, !*(unsigned char *)(a1 + 730)) || *(unsigned char *)(a1 + 731)))
  {
    if (v4)
    {
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v6 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Fence: FenceMonitorWifi needs tracking", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        }
        double v22 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::engageContinuousTrackingIfNeeded(const CFAbsoluteTime)", "%s\n", v22);
        if (v22 != (char *)buf) {
          free(v22);
        }
      }
    }
    int v7 = *(_DWORD *)(a1 + 256);
    BOOL v8 = sub_1001BAE50(a1);
    BOOL v9 = v8;
    if (v7 < 1) {
      int v10 = 1;
    }
    else {
      int v10 = v5;
    }
    if (v10) {
      int v11 = v5;
    }
    else {
      int v11 = v8 | v5;
    }
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    uint64_t v12 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67240704;
      *(_DWORD *)__int16 v25 = v11;
      *(_WORD *)&v25[4] = 1026;
      *(_DWORD *)&void v25[6] = v7;
      __int16 v26 = 1026;
      BOOL v27 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Fence: engageContinuousTrackingIfNeeded, isEngageContinousTracking, %{public}d, numOfMonitoredFences, %{public}d, %{public}d", buf, 0x14u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      double v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::engageContinuousTrackingIfNeeded(const CFAbsoluteTime)", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    *(unsigned char *)(a1 + 623) = v11;
    if (v11)
    {
      double v13 = *(double *)(a1 + 624);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      double v14 = v13 - a2;
      uint64_t v15 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 134349056;
        *(double *)__int16 v25 = v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "engageContinuousTrackingIfNeeded, timeToNextTimer, %{public}lf", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        }
        __int16 v23 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::engageContinuousTrackingIfNeeded(const CFAbsoluteTime)", "%s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      if (v14 <= 0.0 || v14 >= *(double *)(a1 + 720) * 1.2) {
        sub_100DC2530(a1, a2);
      }
      (*(void (**)(void, const char *))(**(void **)(a1 + 1768) + 312))(*(void *)(a1 + 1768), "engageContinuousTrackingIfNeeded");
    }
    else
    {
      *(double *)(a1 + 624) = (*(double (**)(void))(**(void **)(a1 + 1768) + 144))(*(void *)(a1 + 1768));
      (*(void (**)(void))(**(void **)(a1 + 1768) + 320))();
    }
  }
  else
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    char v16 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(unsigned __int8 *)(a1 + 612);
      int v18 = *(unsigned __int8 *)(a1 + 728);
      int v19 = *(unsigned __int8 *)(a1 + 730);
      *(_DWORD *)long long buf = 67240704;
      *(_DWORD *)__int16 v25 = v17;
      *(_WORD *)&v25[4] = 1026;
      *(_DWORD *)&void v25[6] = v18;
      __int16 v26 = 1026;
      BOOL v27 = v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Fence: location services disabled, no continous tracking, %{public}d, isAirplaneMode, %{public}d, cConnected, %{public}d", buf, 0x14u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::engageContinuousTrackingIfNeeded(const CFAbsoluteTime)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    *(unsigned char *)(a1 + 623) = 0;
    *(double *)(a1 + 624) = (*(double (**)(void))(**(void **)(a1 + 1768) + 144))(*(void *)(a1 + 1768));
  }
}

void sub_1001BACE0(uint64_t a1, int *a2, char a3, double a4)
{
  int v4 = *a2;
  if (*a2 > 0xD) {
    return;
  }
  if (((1 << v4) & 0x2C1E) != 0) {
    goto LABEL_3;
  }
  if (((1 << v4) & 0x240) != 0)
  {
    if ((a3 & 1) == 0) {
      return;
    }
LABEL_3:
    sub_100DC2530(a1, a4);
    return;
  }
  if (v4 == 5)
  {
    uint64_t v5 = sub_101A8F02C();
    sub_1001BAD4C(v5);
  }
}

uint64_t sub_1001BAD4C(uint64_t a1, double a2)
{
  double v15 = *(double *)(a1 + 712) * ((double)*(int *)(a1 + 708) + 1.0);
  double v16 = a2;
  BOOL v2 = vabdd_f64(a2, *(double *)(a1 + 840)) <= v15;
  float64x2_t v3 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a2, 0);
  float64x2_t v4 = vabdq_f64(v3, *(float64x2_t *)(a1 + 864));
  float64x2_t v5 = vabdq_f64(v3, *(float64x2_t *)(a1 + 848));
  float64x2_t v6 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v15, 0);
  int8x8_t v7 = (int8x8_t)vmovn_s64(vcgeq_f64(v6, v5));
  int8x8_t v8 = (int8x8_t)vmovn_s64(vcgeq_f64(v6, v4));
  int v9 = vabdd_f64(a2, *(double *)(a1 + 880)) <= v15;
  int v10 = vabdd_f64(a2, *(double *)(a1 + 888)) <= v15;
  int v11 = (vabdd_f64(a2, *(double *)(a1 + 896)) <= v15) << 12;
  int v12 = sub_1001AF758((float64x2_t *)(a1 + 904), (uint64_t *)&v16, (uint64_t *)&v15);
  int8x8_t v13 = vorr_s8(vand_s8(v7, (int8x8_t)0x2000000002), vand_s8(v8, (int8x8_t)0x20000000040));
  return v13.i32[0] | v13.i32[1] | (v9 << 10) | v11 | (v10 << 11) | v12 | v2;
}

BOOL sub_1001BAE50(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 240);
  BOOL v2 = (void *)(a1 + 248);
  if (v1 == (void *)(a1 + 248)) {
    return 0;
  }
  do
  {
    BOOL result = (v1[24] & 0x20) == 0;
    if ((v1[24] & 0x20) == 0) {
      break;
    }
    float64x2_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        float64x2_t v5 = v4;
        float64x2_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        float64x2_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }
      while (!v6);
    }
    uint64_t v1 = v5;
  }
  while (v5 != v2);
  return result;
}

void sub_1001BAEB4(void *a1, int *a2, uint64_t a3, double a4)
{
  int v6 = *a2;
  if (!*a2) {
    goto LABEL_4;
  }
  if (v6 == 22)
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    int8x8_t v13 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = sub_1010FB9FC(*(int **)(a3 + 800));
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Fence: received WSB, %lu", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      sub_1010FB9FC(*(int **)(a3 + 800));
      int v60 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocationNotification(const CFAbsoluteTime, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v60);
      if (v60 != buf) {
        free(v60);
      }
    }
    double v15 = (char **)(a1 + 18);
    a1[19] = a1[18];
    if (sub_1010FB9FC(*(int **)(a3 + 800)) && sub_1010FB9FC(*(int **)(a3 + 800)))
    {
      unint64_t v16 = 0;
      do
      {
        sub_1010FB258(*(void *)(a3 + 800), v16, (uint64_t)buf);
        int v17 = (_OWORD *)a1[19];
        unint64_t v18 = a1[20];
        if ((unint64_t)v17 >= v18)
        {
          uint64_t v27 = 0x6F96F96F96F96F97 * (((char *)v17 - *v15) >> 2);
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) > 0x1A41A41A41A41A4) {
            sub_1001D7FD4();
          }
          unint64_t v29 = 0x6F96F96F96F96F97 * ((uint64_t)(v18 - (void)*v15) >> 2);
          if (2 * v29 > v28) {
            unint64_t v28 = 2 * v29;
          }
          if (v29 >= 0xD20D20D20D20D2) {
            unint64_t v30 = 0x1A41A41A41A41A4;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30) {
            int v31 = (char *)sub_10050FC98((uint64_t)(a1 + 20), v30);
          }
          else {
            int v31 = 0;
          }
          __int16 v32 = &v31[156 * v27];
          long long v33 = *(_OWORD *)&buf[16];
          *(_OWORD *)__int16 v32 = *(_OWORD *)buf;
          *((_OWORD *)v32 + 1) = v33;
          long long v34 = *(_OWORD *)v64;
          long long v35 = *(_OWORD *)&v64[16];
          long long v36 = v66;
          *((_OWORD *)v32 + 4) = v65;
          *((_OWORD *)v32 + 5) = v36;
          *((_OWORD *)v32 + 2) = v34;
          *((_OWORD *)v32 + 3) = v35;
          long long v37 = v67;
          long long v38 = v68;
          long long v39 = v69[0];
          *(_OWORD *)(v32 + 140) = *(_OWORD *)((char *)v69 + 12);
          *((_OWORD *)v32 + 7) = v38;
          *((_OWORD *)v32 + 8) = v39;
          *((_OWORD *)v32 + 6) = v37;
          BOOL v41 = (char *)a1[18];
          char v40 = (char *)a1[19];
          __int16 v42 = v32;
          if (v40 != v41)
          {
            do
            {
              long long v43 = *(_OWORD *)(v40 - 156);
              *(_OWORD *)((char *)v42 - 140) = *(_OWORD *)(v40 - 140);
              *(_OWORD *)((char *)v42 - 156) = v43;
              long long v44 = *(_OWORD *)(v40 - 124);
              long long v45 = *(_OWORD *)(v40 - 108);
              long long v46 = *(_OWORD *)(v40 - 92);
              *(_OWORD *)((char *)v42 - 76) = *(_OWORD *)(v40 - 76);
              *(_OWORD *)((char *)v42 - 92) = v46;
              *(_OWORD *)((char *)v42 - 108) = v45;
              *(_OWORD *)((char *)v42 - 124) = v44;
              long long v47 = *(_OWORD *)(v40 - 60);
              long long v48 = *(_OWORD *)(v40 - 44);
              long long v49 = *(_OWORD *)(v40 - 28);
              *(v42 - 1) = *((_OWORD *)v40 - 1);
              *(_OWORD *)((char *)v42 - 28) = v49;
              *(_OWORD *)((char *)v42 - 44) = v48;
              *(_OWORD *)((char *)v42 - 60) = v47;
              __int16 v42 = (_OWORD *)((char *)v42 - 156);
              v40 -= 156;
            }
            while (v40 != v41);
            char v40 = *v15;
          }
          __int16 v26 = v32 + 156;
          a1[18] = v42;
          a1[19] = v32 + 156;
          a1[20] = &v31[156 * v30];
          if (v40) {
            operator delete(v40);
          }
        }
        else
        {
          long long v19 = *(_OWORD *)&buf[16];
          *int v17 = *(_OWORD *)buf;
          v17[1] = v19;
          long long v20 = *(_OWORD *)v64;
          long long v21 = *(_OWORD *)&v64[16];
          long long v22 = v66;
          v17[4] = v65;
          v17[5] = v22;
          void v17[2] = v20;
          v17[3] = v21;
          long long v23 = v67;
          long long v24 = v68;
          long long v25 = v69[0];
          *(_OWORD *)((char *)v17 + 140) = *(_OWORD *)((char *)v69 + 12);
          v17[7] = v24;
          v17[8] = v25;
          void v17[6] = v23;
          __int16 v26 = (char *)v17 + 156;
        }
        a1[19] = v26;
        ++v16;
      }
      while (v16 < sub_1010FB9FC(*(int **)(a3 + 800)));
    }
    return;
  }
  if (v6 != 3)
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    __int16 v57 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      int v58 = *a2;
      *(_DWORD *)long long buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v58;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#Warning Fence: Got unknown location notification %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 == -1) {
        goto LABEL_63;
      }
      goto LABEL_66;
    }
  }
  else
  {
LABEL_4:
    double v7 = *(double *)(a3 + 88);
    double v8 = *(double *)(a3 + 76);
    if (v7 >= 0.0 && v7 + v8 < a4)
    {
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      double v50 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v51 = *(void *)(a3 + 4);
        uint64_t v52 = *(void *)(a3 + 12);
        uint64_t v53 = *(void *)(a3 + 20);
        uint64_t v54 = *(void *)(a3 + 76);
        uint64_t v55 = *(void *)(a3 + 88);
        *(_DWORD *)long long buf = 134284545;
        *(void *)&uint8_t buf[4] = v51;
        *(_WORD *)&unsigned char buf[12] = 2049;
        *(void *)&unsigned char buf[14] = v52;
        *(_WORD *)&buf[22] = 2050;
        *(void *)&unsigned char buf[24] = v53;
        *(_WORD *)double v64 = 2050;
        *(void *)&v64[2] = v54;
        *(_WORD *)&v64[10] = 2050;
        *(void *)&v64[12] = v55;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "Fence: Ignoring expired location <%{private}+.8f, %{private}.8f>, acc %{public}.2f, timestamp %{public}.2f, lifespan %{public}.2f", buf, 0x34u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 == -1)
        {
LABEL_63:
          __int16 v61 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocationNotification(const CFAbsoluteTime, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v61);
          if (v61 != buf) {
            free(v61);
          }
          return;
        }
LABEL_66:
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        goto LABEL_63;
      }
    }
    else if (vabdd_f64(a4, v8) <= 10.0)
    {
      uint64_t v59 = a3 + 160;
      sub_10015FB88((uint64_t)a1, a3, v59, a4);
    }
    else
    {
      if (qword_1024193C0 != -1)
      {
        double v62 = a4;
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        a4 = v62;
      }
      double v10 = a4 - v8;
      int v11 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
      {
        int v12 = *(_DWORD *)(a3 + 96);
        *(_DWORD *)long long buf = 67240448;
        *(_DWORD *)&uint8_t buf[4] = v12;
        *(_WORD *)&uint8_t buf[8] = 2050;
        *(double *)&buf[10] = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Fence: Ignoring old location, type, %{public}d, age, %{public}.1f", buf, 0x12u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 == -1) {
          goto LABEL_63;
        }
        goto LABEL_66;
      }
    }
  }
}

void sub_1001BB78C(uint64_t a1, double a2)
{
  if (!*sub_10016363C()) {
    return;
  }
  sub_100110970((char *)v69);
  sub_1001ABED0((uint64_t)v65);
  int v4 = sub_100186E4C(a1, (uint64_t)v69, (uint64_t)v65);
  uint64_t v5 = v68;
  sub_100195890(a1 + 48, a2);
  BOOL v6 = sub_10018252C((void *)(a1 + 48));
  if (v6)
  {
    sub_100182574((void *)(a1 + 48), &v63);
    sub_100AC281C((_OWORD *)(v63 + 48), a1 + 288);
    BOOL v7 = sub_1009C52F0(a1 + 48, a2);
    if (v4)
    {
      sub_100AC27DC(v63 + 48, v5, a2);
      BOOL v8 = v5 < 2;
      BOOL v9 = v5 == 4;
    }
    else
    {
      BOOL v9 = 0;
      BOOL v8 = 0;
    }
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    unint64_t v18 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v19 = sub_1009C5290((void *)(a1 + 48));
      if (!v20) {
        sub_10020D700();
      }
      unint64_t v21 = v19;
      int v22 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 176))(*(void *)(a1 + 1768));
      *(_DWORD *)long long buf = 134219520;
      unint64_t v94 = v21;
      __int16 v95 = 1024;
      *(_DWORD *)double v96 = v7;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)&v96[6] = v8;
      *(_WORD *)uint64_t v97 = 1024;
      *(_DWORD *)&v97[2] = v9;
      __int16 v98 = 1024;
      int v99 = v5;
      __int16 v100 = 1024;
      int v101 = v4;
      __int16 v102 = 1024;
      int v103 = v22;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "converging state, evaluating ongoing, current attempt, %zu, expired, %d, exited area, %d, reached inside, %d, mostEnergeticProximityState, %d, wasProximityStateUpdated, %d, isConvergingStateGNSSInitialized, %d", buf, 0x30u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      unint64_t v40 = sub_1009C5290((void *)(a1 + 48));
      if (!v41) {
        sub_10020D700();
      }
      unint64_t v42 = v40;
      int v43 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 176))(*(void *)(a1 + 1768));
      int v82 = 134219520;
      unint64_t v83 = v42;
      __int16 v84 = 1024;
      *(_DWORD *)__int16 v85 = v7;
      *(_WORD *)&v85[4] = 1024;
      *(_DWORD *)&v85[6] = v8;
      *(_WORD *)uint64_t v86 = 1024;
      *(_DWORD *)&v86[2] = v9;
      __int16 v87 = 1024;
      int v88 = v5;
      __int16 v89 = 1024;
      int v90 = v4;
      __int16 v91 = 1024;
      int v92 = v43;
      long long v44 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v44);
      if (v44 != (char *)buf) {
        free(v44);
      }
    }
    if (v7)
    {
      (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 1768) + 208))(*(void *)(a1 + 1768), 3, a2);
    }
    else if (!v8 && !v9)
    {
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v27 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v28 = sub_1009C5290((void *)(a1 + 48));
        if (!v29) {
          sub_10020D700();
        }
        unint64_t v30 = v28;
        sub_1009C5348(a1 + 48, a2);
        if (!v32) {
          sub_10020D700();
        }
        *(_DWORD *)long long buf = 134218240;
        unint64_t v94 = v30;
        __int16 v95 = 2048;
        *(void *)double v96 = v31;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "converging state, current attempt, %zu, remaining time, %f, continuing", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193C0 != -1) {
          dispatch_once(&qword_1024193C0, &stru_1022F7C40);
        }
        unint64_t v48 = sub_1009C5290((void *)(a1 + 48));
        if (!v49) {
          sub_10020D700();
        }
        unint64_t v50 = v48;
        sub_1009C5348(a1 + 48, a2);
        if (!v52) {
          sub_10020D700();
        }
        int v82 = 134218240;
        unint64_t v83 = v50;
        __int16 v84 = 2048;
        *(void *)__int16 v85 = v51;
        uint64_t v53 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v53);
        if (v53 != (char *)buf) {
          free(v53);
        }
      }
      if (v4)
      {
        int v33 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 176))(*(void *)(a1 + 1768));
        int v34 = v68;
        if (v68 == 3) {
          int v35 = 0;
        }
        else {
          int v35 = v33;
        }
        if (v35 == 1)
        {
          if (qword_1024193C0 != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          long long v36 = qword_1024193C8;
          if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "converging state, tearing down gnss session after exiting adjacent", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            LOWORD(v82) = 0;
            int v58 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v58);
            if (v58 != (char *)buf) {
              free(v58);
            }
          }
          (*(void (**)(void))(**(void **)(a1 + 1768) + 192))(*(void *)(a1 + 1768));
          sub_1009C5070(v63, a2);
          int v34 = v68;
        }
        sub_100DC9540(a1, v34, a2, v66);
      }
      uint64_t v12 = 0;
      goto LABEL_71;
    }
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    long long v23 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v24 = sub_1009C5290((void *)(a1 + 48));
      if (!v25) {
        sub_10020D700();
      }
      *(_DWORD *)long long buf = 134217984;
      unint64_t v94 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "converging state, current attempt, %zu, ending", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      unint64_t v45 = sub_1009C5290((void *)(a1 + 48));
      if (!v46) {
        sub_10020D700();
      }
      int v82 = 134217984;
      unint64_t v83 = v45;
      long long v47 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v47);
      if (v47 != (char *)buf) {
        free(v47);
      }
    }
    double v26 = sub_1000A3D9C(v75, v76, *(double *)(a1 + 292), *(double *)(a1 + 300));
    *(double *)(v63 + 136) = v26;
    sub_1009C5710((void *)(a1 + 48), a2);
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 1768) + 176))(*(void *)(a1 + 1768)))
    {
      (*(void (**)(void))(**(void **)(a1 + 1768) + 192))(*(void *)(a1 + 1768));
      sub_1009C5070(v63, a2);
    }
    (*(void (**)(void))(**(void **)(a1 + 1768) + 168))(*(void *)(a1 + 1768));
    sub_10096317C();
    double v62 = v64;
    if (v64) {
      atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1009631C8();
    if (v7)
    {
      uint64_t v12 = 4;
    }
    else if (v8)
    {
      (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 1768) + 208))(*(void *)(a1 + 1768), 4, a2);
      uint64_t v12 = 3;
    }
    else if (v9)
    {
      uint64_t v12 = 2;
    }
    else
    {
      uint64_t v12 = 0;
    }
    if (v62) {
      sub_1000DB0A0(v62);
    }
LABEL_71:
    if (v64) {
      sub_1000DB0A0(v64);
    }
    goto LABEL_73;
  }
  if (!v4)
  {
    uint64_t v12 = 0;
    goto LABEL_73;
  }
  int v10 = *(_DWORD *)(a1 + 128);
  BOOL v11 = sub_1009C527C((int *)(a1 + 48));
  uint64_t v12 = 0;
  if (v10 != 1 || (v5 & 0xFFFFFFFE) != 2)
  {
LABEL_73:
    if (!v12 && (v4 & v6) == 0) {
      goto LABEL_76;
    }
    goto LABEL_75;
  }
  BOOL v13 = v11;
  if (v11 && !*(unsigned char *)(a1 + 729))
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    long long v37 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      long long v38 = (void **)v69[0];
      if (v70 >= 0) {
        long long v38 = v69;
      }
      long long v39 = v71;
      if (v72 < 0) {
        long long v39 = (void **)v71[0];
      }
      *(_DWORD *)long long buf = 136380931;
      unint64_t v94 = (unint64_t)v38;
      __int16 v95 = 2081;
      *(void *)double v96 = v39;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "converging state, starting new attempt. fence %{private}s/%{private}s", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v59 = (void **)v69[0];
      if (v70 >= 0) {
        uint64_t v59 = v69;
      }
      int v60 = v71;
      if (v72 < 0) {
        int v60 = (void **)v71[0];
      }
      int v82 = 136380931;
      unint64_t v83 = (unint64_t)v59;
      __int16 v84 = 2081;
      *(void *)__int16 v85 = v60;
      __int16 v61 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v61);
      if (v61 != (char *)buf) {
        free(v61);
      }
    }
    sub_1009C53A8((void *)(a1 + 48), (uint64_t *)v69, (uint64_t *)v71, a2);
    (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 1768) + 208))(*(void *)(a1 + 1768), 1, a2);
    sub_100DC9540(a1, v5, a2, v66);
    uint64_t v12 = 1;
  }
  else
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    uint64_t v14 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
    {
      double v15 = (void **)v69[0];
      if (v70 >= 0) {
        double v15 = v69;
      }
      unint64_t v16 = v71;
      if (v72 < 0) {
        unint64_t v16 = (void **)v71[0];
      }
      int v17 = *(unsigned __int8 *)(a1 + 729);
      *(_DWORD *)long long buf = 136381187;
      unint64_t v94 = (unint64_t)v15;
      __int16 v95 = 2081;
      *(void *)double v96 = v16;
      *(_WORD *)&v96[8] = 1024;
      *(_DWORD *)uint64_t v97 = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "converging state, out-of-budget, cannot start new attempt. fence %{private}s/%{private}s, lowPowerModeEnabled, %d", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v54 = (void **)v69[0];
      if (v70 >= 0) {
        uint64_t v54 = v69;
      }
      uint64_t v55 = v71;
      if (v72 < 0) {
        uint64_t v55 = (void **)v71[0];
      }
      int v56 = *(unsigned __int8 *)(a1 + 729);
      int v82 = 136381187;
      unint64_t v83 = (unint64_t)v54;
      __int16 v84 = 2081;
      *(void *)__int16 v85 = v55;
      *(_WORD *)&v85[8] = 1024;
      *(_DWORD *)uint64_t v86 = v56;
      __int16 v57 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::evaluateConvergingState(const CFAbsoluteTime)", "%s\n", v57);
      if (v57 != (char *)buf) {
        free(v57);
      }
    }
    uint64_t v12 = 5;
    if (!v13) {
      (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 1768) + 208))(*(void *)(a1 + 1768), 5, a2);
    }
  }
LABEL_75:
  (*(void (**)(void, uint64_t, uint64_t, void **))(**(void **)(a1 + 1768) + 200))(*(void *)(a1 + 1768), v5, v12, v69);
LABEL_76:
  if (v4)
  {
    *(_DWORD *)(a1 + 128) = v5;
    *(void *)(a1 + 136) = v67;
  }
  if (__p)
  {
    uint64_t v81 = __p;
    operator delete(__p);
  }

  if (v78 < 0) {
    operator delete(v77);
  }
  if (v74 < 0) {
    operator delete(v73);
  }
  if (v72 < 0) {
    operator delete(v71[0]);
  }
  if (v70 < 0) {
    operator delete(v69[0]);
  }
}

void sub_1001BC72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t sub_1001BC7DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 80))();
}

uint64_t sub_1001BC804(uint64_t a1, uint64_t a2, double a3)
{
  if (!*(unsigned char *)(a1 + 615) && sub_1001ABF10(a2))
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    BOOL v6 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Fence: handleLocation, Ignoring cell or LAC position as per defaults", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 == -1)
    {
LABEL_52:
      char v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceMonitor::shouldIgnoreLocation(const CFAbsoluteTime, const CLDaemonLocation &)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
      return 1;
    }
LABEL_54:
    dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    goto LABEL_52;
  }
  if (!*(unsigned char *)(a1 + 616))
  {
    int v10 = *(_DWORD *)(a2 + 96);
    if (v10 == 11 || v10 == 4)
    {
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_1022F7C40);
      }
      uint64_t v12 = qword_1024193C8;
      if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Fence: handleLocation, Ignoring WiFi position as per defaults", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return 1;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 == -1) {
        goto LABEL_52;
      }
      goto LABEL_54;
    }
  }
  int v7 = *(_DWORD *)(a2 + 96);
  if (*(unsigned char *)(a1 + 617)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = (v7 & 0xFFFFFFF7) == 1;
  }
  if (v8)
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    BOOL v13 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Fence: handleLocation, Ignoring GPS position as per defaults", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 == -1) {
      goto LABEL_52;
    }
    goto LABEL_54;
  }
  if (!*(unsigned char *)(a1 + 618) && v7 == 10)
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    BOOL v9 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Fence: handleLocation, Ignoring Pipeline position as per defaults", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 == -1) {
      goto LABEL_52;
    }
    goto LABEL_54;
  }
  if (*(double *)(a2 + 76) == *(double *)(a1 + 672))
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    uint64_t v14 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Fence: handleLocation, Ignoring duplicate location", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 1;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 == -1) {
      goto LABEL_52;
    }
    goto LABEL_54;
  }
  int v16 = *(_DWORD *)(a1 + 684);
  int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 400))(*(void *)(a1 + 1768));
  int v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 16))(*(void *)(a1 + 1768));
  char v19 = sub_1001AFB70(a1 + 904);
  return sub_1000069C4((double *)(a1 + 664), (int *)(a1 + 680), a1 + 288, a1 + 448, a2, v16, v17, v18, a3, v19);
}

void sub_1001BCE30(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  uint64_t v7 = sub_10001A4C4(a1 + 240, a4);
  if (a1 + 248 != v7)
  {
    uint64_t v8 = v7;
    if (*(unsigned char *)(a1 + 730))
    {
      if (*(void *)(v7 + 264) == *(void *)(v7 + 256))
      {
        if (_os_feature_enabled_impl())
        {
LABEL_23:
          if (qword_1024193C0 != -1) {
            dispatch_once(&qword_1024193C0, &stru_1022F7C40);
          }
          int v17 = qword_1024193C8;
          if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Processing location when not supposed to", buf, 2u);
          }
          if (sub_10013D1A0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193C0 != -1) {
              dispatch_once(&qword_1024193C0, &stru_1022F7C40);
            }
            int v18 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "void CLFenceMonitor::handleLocationFence(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &, const CLFenceManager_Type::Fence &)", "%s\n", v18);
            if (v18 != (char *)buf) {
              free(v18);
            }
          }
          goto LABEL_28;
        }
        uint64_t v9 = 64;
      }
      else
      {
        uint64_t v9 = 8;
      }
      if ((*(void *)(v8 + 192) & v9) == 0) {
        goto LABEL_23;
      }
    }
LABEL_28:
    sub_100013C58(a1);
    return;
  }
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_1022F7C40);
  }
  int v10 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a2 + 4);
    uint64_t v12 = *(void *)(a2 + 12);
    uint64_t v13 = *(void *)(a2 + 20);
    if ((a4[23] & 0x80u) == 0) {
      uint64_t v14 = (uint64_t *)a4;
    }
    else {
      uint64_t v14 = *(uint64_t **)a4;
    }
    if ((a4[47] & 0x80u) == 0) {
      double v15 = (uint64_t *)(a4 + 24);
    }
    else {
      double v15 = (uint64_t *)*((void *)a4 + 3);
    }
    *(_DWORD *)long long buf = 134284547;
    uint64_t v20 = v11;
    __int16 v21 = 2049;
    uint64_t v22 = v12;
    __int16 v23 = 2050;
    uint64_t v24 = v13;
    __int16 v25 = 2082;
    double v26 = v14;
    __int16 v27 = 2081;
    unint64_t v28 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Warning Fence: Attempt to handle location <%{private}+.8f,%{private}+.8f> acc %{public}.2f for non-present fence %{public}s/%{private}s", buf, 0x34u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_1022F7C40);
    }
    int v16 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLFenceMonitor::handleLocationFence(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemonLocationPrivate &, const CLFenceManager_Type::Fence &)", "%s\n", v16);
    if (v16 != (char *)buf) {
      free(v16);
    }
  }
}

uint64_t sub_1001BD27C(double *a1, double *a2, double *a3, double a4, double a5)
{
  double v10 = -450.0;
  if (a5 >= -450.0)
  {
    double v10 = 1000000.0;
    if (a5 <= 1000000.0)
    {
      double v10 = a5;
      goto LABEL_19;
    }
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_102314CD8);
    }
    uint64_t v12 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      double v25 = 1000000.0;
      __int16 v26 = 2048;
      double v27 = a5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#Warning refAlt > %.1lf,refAlt,%.1lf,using the max", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 == -1) {
        goto LABEL_16;
      }
      goto LABEL_39;
    }
  }
  else
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_102314CD8);
    }
    uint64_t v11 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      double v25 = -450.0;
      __int16 v26 = 2048;
      double v27 = a5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#Warning refAlt < %.1lf,refAlt,%.1lf,using the min", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 == -1)
      {
LABEL_16:
        uint64_t v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLDistanceCalc::calc_dNdE(double, double, double &, double &)", "%s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
        goto LABEL_19;
      }
LABEL_39:
      dispatch_once(&qword_102419630, &stru_102314CD8);
      goto LABEL_16;
    }
  }
LABEL_19:
  double v14 = a1[3];
  if (v14 != 0.0 && vabdd_f64(a4, v14) <= 0.005)
  {
    double v18 = *a1;
    goto LABEL_35;
  }
  if (a4 <= 90.0 && a4 >= -90.0)
  {
    a1[2] = a4 * 0.0174532925;
    a1[3] = a4;
    __double2 v15 = __sincos_stret(a4 * 0.0174532925);
    double v16 = v15.__sinval * -0.00669437999 * v15.__sinval + 1.0;
    double v17 = sqrt(v16);
    double v18 = 6335439.33 / (v16 * v17);
    *a1 = v18;
    a1[1] = 6378137.0 / v17;
    a1[4] = v15.__cosval;
LABEL_35:
    *a2 = v10 + v18;
    double v23 = (v10 + a1[1]) * a1[4];
    if (v23 < 10.0) {
      double v23 = 10.0;
    }
    *a3 = v23;
    return 1;
  }
  if (qword_102419630 != -1) {
    dispatch_once(&qword_102419630, &stru_102314CD8);
  }
  char v19 = qword_102419638;
  if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v25 = a4;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "latitude,%.7lf,is out of bounds", buf, 0xCu);
  }
  BOOL v20 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v20)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_102314CD8);
    }
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLDistanceCalc::calc_dNdE(double, double, double &, double &)", "%s\n", v22);
    if (v22 != (char *)buf) {
      free(v22);
    }
    return 0;
  }
  return result;
}

void sub_1001BD7C8(uint64_t a1)
{
  sub_10002B34C(a1);

  operator delete();
}

void sub_1001BD800(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
}

void sub_1001BD808(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 120) = a2;
  float64x2_t v3 = sub_1000E9974(a1);
  if (v3)
  {
    int v4 = *(unsigned __int8 *)(a1 + 120);
    sub_10002B890((uint64_t)v3, v4);
  }
}

void sub_1001BD854()
{
}

void sub_1001BD8C8(_Unwind_Exception *a1)
{
  *BOOL v2 = 0;
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1001BD920(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1001BD92C(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_1001BD934(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0x40) {
    return 26;
  }
  else {
    return qword_101D9CFF8[a1 - 1];
  }
}

uint64_t sub_1001BD958(uint64_t result)
{
  if (!*(unsigned char *)(result + 536))
  {
    uint64_t v1 = result;
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_1022BBB38);
    }
    BOOL v2 = qword_1024193B8;
    if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "WifiService, power mismatch", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_1022BBB38);
      }
      float64x2_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLWifiService::handlePowerMismatch()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
    return sub_100570468(v1);
  }
  return result;
}

void sub_1001BDAFC(uint64_t a1, NSObject *a2, char *a3)
{
  if ([*(id *)(a1 + 8) state] != 2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v9 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (a3[23] >= 0) {
        double v10 = a3;
      }
      else {
        double v10 = *(char **)a3;
      }
      int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v31 = 1024;
      LODWORD(v32) = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%s -- we're not in a runnable state (i.e. no clients; clients = %d)",
        buf,
        0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      (*(void (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24));
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v8);
      goto LABEL_83;
    }
    return;
  }
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    BOOL v6 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] >= 0) {
        uint64_t v7 = a3;
      }
      else {
        uint64_t v7 = *(char **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Already seeded - ignoring request to start due to %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v8);
LABEL_83:
      if (v8 != buf) {
        free(v8);
      }
      return;
    }
    return;
  }
  uint64_t v12 = sub_1001C8554(a1, (uint64_t)a2);
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v13 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    if (a3[23] >= 0) {
      double v14 = a3;
    }
    else {
      double v14 = *(char **)a3;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v14;
    __int16 v31 = 2082;
    char v32 = sub_1001D7758(v12);
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "@IndoorFlow, turnon, %{public}s, %{public}s", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    sub_1001D7758(v12);
    __int16 v26 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v26);
    if (v26 != buf) {
      free(v26);
    }
  }
  __double2 v15 = *(void **)(a1 + 8);
  if (v12)
  {
    if ([v15 latestReason] != v12)
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      double v16 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        if (a3[23] >= 0) {
          double v17 = a3;
        }
        else {
          double v17 = *(char **)a3;
        }
        double v18 = sub_1001D7758(v12);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v17;
        __int16 v31 = 2080;
        char v32 = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "%s - cannot start indoor: %s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        sub_1001D7758(v12);
        double v27 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v27);
        if (v27 != buf) {
          free(v27);
        }
      }
      [*(id *)(a1 + 8) setLatestReason:v12];
    }
    return;
  }
  [v15 setLatestReason:0];
  sub_1001CD058(a1, (uint64_t)a2, a3);
  if (!objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "count"))
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    a2 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (a3[23] >= 0) {
        double v25 = a3;
      }
      else {
        double v25 = *(char **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s - not in a recognized venue, not launching pipelined", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      a2 = buf;
      a3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", a3);
      if (a3 != buf) {
        free(a3);
      }
    }
    if (![*(id *)(a1 + 8) pipelinedSeeded])
    {
      sub_100134750(buf, "startIndoorIfPossible but no venues");
      sub_1001C95FC(a1, (uint64_t *)buf);
      if (v33 < 0) {
        operator delete(*(void **)buf);
      }
      return;
    }
    sub_101A50A00();
    __break(1u);
    goto LABEL_102;
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  char v19 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    if (a3[23] >= 0) {
      BOOL v20 = a3;
    }
    else {
      BOOL v20 = *(char **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "%s - starting pipelined via startDaemonLocalizingImpl", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v28 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v28);
    if (v28 != buf) {
      free(v28);
    }
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 24) + 104))(*(void *)(a1 + 24)))
  {
    if (qword_1024193A0 == -1)
    {
LABEL_53:
      __int16 v21 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#Warning daemon is loaded but pipelined is not seeded", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        char v29 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v29);
        if (v29 != buf) {
          free(v29);
        }
      }
      goto LABEL_56;
    }
LABEL_102:
    dispatch_once(&qword_1024193A0, &stru_10229E160);
    goto LABEL_53;
  }
LABEL_56:
  if (!sub_1001D7924(a1, (uint64_t)a2))
  {
    sub_1001C9A08(a1);
    return;
  }
  [*(id *)(a1 + 8) setLatestReason:5];
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v22 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    if (a3[23] >= 0) {
      double v23 = a3;
    }
    else {
      double v23 = *(char **)a3;
    }
    uint64_t v24 = sub_1001D7758([*(id *)(a1 + 8) latestReason]);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v23;
    __int16 v31 = 2080;
    char v32 = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "%s - cannot start indoor: %s", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    sub_1001D7758([*(id *)(a1 + 8) latestReason]);
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startIndoorIfPossible(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v8);
    goto LABEL_83;
  }
}

void sub_1001BE838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1001BE85C(uint64_t a1)
{
  id result = [*(id *)(a1 + 8) pipelinedSeeded];
  if (result)
  {
    float64x2_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 152);
    return (id)v3();
  }
  return result;
}

uint64_t sub_1001BE8D0(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = a1 + 128;
  (*(void (**)(uint64_t))(*(void *)(a1 + 128) + 16))(a1 + 128);
  sub_1000EA7C8((CFMutableDictionaryRef *)a1, a2, a3);
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
}

void sub_1001BE97C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1019DB560((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001BE990(_DWORD *a1, unsigned int (*a2)(uint64_t, uint64_t (***)()), uint64_t a3)
{
  if (!a1[30]) {
    sub_100063168((uint64_t)(a1 + 16), (uint64_t)(a1 + 2));
  }
  unsigned int v6 = a1[18];
  unsigned int v7 = a1[19];
  if (v6 <= v7) {
    int v8 = a1[19];
  }
  else {
    int v8 = a1[18];
  }
  if (v7) {
    BOOL v9 = v6 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int v10 = 0;
  }
  else {
    int v10 = v8;
  }

  return sub_10006246C((uint64_t)a1, v10, (uint64_t)(a1 + 16), a2, a3);
}

id sub_1001BEA0C(uint64_t a1)
{
  return [*(id *)(a1 + 8) setNextFireTime:];
}

uint64_t sub_1001BEA14()
{
  return *(void *)qword_10248A7D0;
}

id sub_1001BEA24(void *a1)
{
  if ((objc_msgSend(+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace"), "applicationIsInstalled:", a1) & 1) == 0)
  {
    id v2 = [objc_alloc((Class)LSApplicationExtensionRecord) initWithBundleIdentifier:a1 error:0];
    if (v2) {
      goto LABEL_3;
    }
    return 0;
  }
  id v2 = sub_10001C058(a1);
  if (!v2) {
    return 0;
  }
LABEL_3:

  return [v2 URL];
}

BOOL sub_1001BEAA8(uint64_t a1)
{
  return *(double *)(a1 + 80) <= 2.33333325 && (*(unsigned char *)(a1 + 152) & 0xFD) == 1;
}

BOOL sub_1001BEACC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 1152);
  if (v2 == 2)
  {
    if (a2)
    {
      *(void *)(a1 + 1160) = 3;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 1160) - 1;
      *(void *)(a1 + 1160) = v8;
      if (!v8)
      {
        int v2 = 1;
        *(_DWORD *)(a1 + 1152) = 1;
        uint64_t v7 = 12;
        goto LABEL_21;
      }
    }
    int v2 = 2;
    return v2 == 2;
  }
  if (v2 == 1)
  {
    if (a2)
    {
      uint64_t v6 = *(void *)(a1 + 1160) - 1;
      *(void *)(a1 + 1160) = v6;
      if (!v6)
      {
        int v2 = 2;
        *(_DWORD *)(a1 + 1152) = 2;
        uint64_t v7 = 3;
LABEL_21:
        *(void *)(a1 + 1160) = v7;
        return v2 == 2;
      }
    }
    else
    {
      *(void *)(a1 + 1160) = 12;
    }
    int v2 = 1;
    return v2 == 2;
  }
  if (v2) {
    return v2 == 2;
  }
  uint64_t v3 = *(void *)(a1 + 1160) - 1;
  *(void *)(a1 + 1160) = v3;
  if (!v3)
  {
    if (a2) {
      int v4 = 2;
    }
    else {
      int v4 = 1;
    }
    *(_DWORD *)(a1 + 1152) = v4;
    uint64_t v5 = 12;
    if (a2) {
      uint64_t v5 = 3;
    }
    *(void *)(a1 + 1160) = v5;
  }
  return a2;
}

uint64_t sub_1001BEB94(uint64_t result)
{
  *(_DWORD *)(result + 1152) = 0;
  *(void *)(result + 1160) = 8;
  return result;
}

uint64_t sub_1001BEBA4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1168) = a2;
  return result;
}

void sub_1001BEBAC(uint64_t a1, double *a2)
{
  sub_100103240();
  if (sub_10010145C())
  {
    sub_10118A0B8((double *)(a1 + 144), (uint64_t)a2);
    if (sub_100DE6158(a1 + 912))
    {
      uint64_t v29 = *(void *)(a1 + 648);
      long long v4 = *(_OWORD *)(a1 + 616);
      long long v26 = *(_OWORD *)(a1 + 600);
      long long v27 = v4;
      long long v28 = *(_OWORD *)(a1 + 632);
      long long v5 = *(_OWORD *)(a1 + 552);
      long long v22 = *(_OWORD *)(a1 + 536);
      long long v23 = v5;
      long long v6 = *(_OWORD *)(a1 + 584);
      long long v24 = *(_OWORD *)(a1 + 568);
      long long v25 = v6;
      long long v7 = *(_OWORD *)(a1 + 488);
      int8x16_t v18 = *(int8x16_t *)(a1 + 472);
      long long v19 = v7;
      long long v8 = *(_OWORD *)(a1 + 520);
      long long v20 = *(_OWORD *)(a1 + 504);
      long long v21 = v8;
      if (BYTE8(v19))
      {
        BOOL v9 = +[NSDate dateWithTimeIntervalSinceReferenceDate:*a2];
        [*(id *)(a1 + 1176) writeToHealthRunningSpeed:v9 startDate:v9 endDate:*(double *)&v19];
      }
      else
      {
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10230E560);
        }
        int v10 = qword_102419038;
        if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "[PaceController] Not writing to HK, invalid running speed", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419030 != -1) {
            dispatch_once(&qword_102419030, &stru_10230E560);
          }
          LOWORD(v30[0]) = 0;
          double v17 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLPedometer::PaceController::feedStepCountEntry(const CLExtendedStepCountEntry &)", "%s\n", v17);
          if (v17 != (char *)buf) {
            free(v17);
          }
        }
      }
      if (*(unsigned char *)(a1 + 1184))
      {
        sub_10068D654(&v18, (uint64_t)buf);
        if (qword_10248AF88 != -1) {
          dispatch_once(&qword_10248AF88, &stru_10230E580);
        }
        if (qword_10248AF90) {
          operator new();
        }
        PB::Base::~Base((PB::Base *)buf);
      }
      if (qword_102419030 != -1) {
        dispatch_once(&qword_102419030, &stru_10230E560);
      }
      int v11 = qword_102419038;
      if (os_log_type_enabled((os_log_t)qword_102419038, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134223872;
        uint64_t v78 = v18.i64[0];
        __int16 v79 = 2048;
        uint64_t v80 = v18.i64[1];
        __int16 v81 = 2048;
        uint64_t v82 = v19;
        __int16 v83 = 2048;
        uint64_t v84 = *((void *)&v21 + 1);
        __int16 v85 = 2048;
        uint64_t v86 = *((void *)&v22 + 1);
        __int16 v87 = 2048;
        uint64_t v88 = v23;
        __int16 v89 = 2048;
        uint64_t v90 = *((void *)&v23 + 1);
        __int16 v91 = 2048;
        uint64_t v92 = v20;
        __int16 v93 = 2048;
        uint64_t v94 = *((void *)&v20 + 1);
        __int16 v95 = 2048;
        uint64_t v96 = v24;
        __int16 v97 = 2048;
        uint64_t v98 = *((void *)&v24 + 1);
        __int16 v99 = 1026;
        int v100 = BYTE1(v21);
        __int16 v101 = 1026;
        int v102 = v21;
        __int16 v103 = 2048;
        uint64_t v104 = v25;
        __int16 v105 = 2048;
        uint64_t v106 = *((void *)&v25 + 1);
        __int16 v107 = 2048;
        uint64_t v108 = *((void *)&v26 + 1);
        __int16 v109 = 2048;
        uint64_t v110 = v26;
        __int16 v111 = 1026;
        int v112 = BYTE8(v19);
        __int16 v113 = 2048;
        uint64_t v114 = v22;
        __int16 v115 = 2048;
        uint64_t v116 = v27;
        __int16 v117 = 2048;
        uint64_t v118 = *((void *)&v27 + 1);
        __int16 v119 = 2048;
        uint64_t v120 = v28;
        __int16 v121 = 2048;
        uint64_t v122 = *((void *)&v28 + 1);
        __int16 v123 = 1026;
        int v124 = HIBYTE(v29);
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[RunningSpeedKF],startTime,%.2f,endTime,%.2f,runningSpeed,%.2f,deltaPedDist,%.2f,deltaOdoDist,%.2f,deltaPedTime,%.2f,deltaOdoTime,%.2f,pedSpeed,%.2f,odoSpeed,%.2f,algDelay,%.2f,biasFactor,%.2f,isValidPedometerSpeed,%{public}d,isValidOdometerSpeed,%{public}d,stateCovariance,%.2f,processNoise,%.2f,epsPed,%.2f,epsOdo,%.2f,isValidRunningSpeed,%{public}d,deltaCalPedDist,%.2f,measNoiseOdo,%.3f,measNoisePed,%.3f,kalmanGainOdo,%.2f,kalmanGainPed,%.2f,isTrackRunOdometer,%{public}d", buf, 0xE2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419030 != -1) {
          dispatch_once(&qword_102419030, &stru_10230E560);
        }
        v30[0] = 134223872;
        *(void *)&v30[1] = v18.i64[0];
        __int16 v31 = 2048;
        uint64_t v32 = v18.i64[1];
        __int16 v33 = 2048;
        uint64_t v34 = v19;
        __int16 v35 = 2048;
        uint64_t v36 = *((void *)&v21 + 1);
        __int16 v37 = 2048;
        uint64_t v38 = *((void *)&v22 + 1);
        __int16 v39 = 2048;
        uint64_t v40 = v23;
        __int16 v41 = 2048;
        uint64_t v42 = *((void *)&v23 + 1);
        __int16 v43 = 2048;
        uint64_t v44 = v20;
        __int16 v45 = 2048;
        uint64_t v46 = *((void *)&v20 + 1);
        __int16 v47 = 2048;
        uint64_t v48 = v24;
        __int16 v49 = 2048;
        uint64_t v50 = *((void *)&v24 + 1);
        __int16 v51 = 1026;
        int v52 = BYTE1(v21);
        __int16 v53 = 1026;
        int v54 = v21;
        __int16 v55 = 2048;
        uint64_t v56 = v25;
        __int16 v57 = 2048;
        uint64_t v58 = *((void *)&v25 + 1);
        __int16 v59 = 2048;
        uint64_t v60 = *((void *)&v26 + 1);
        __int16 v61 = 2048;
        uint64_t v62 = v26;
        __int16 v63 = 1026;
        int v64 = BYTE8(v19);
        __int16 v65 = 2048;
        uint64_t v66 = v22;
        __int16 v67 = 2048;
        uint64_t v68 = v27;
        __int16 v69 = 2048;
        uint64_t v70 = *((void *)&v27 + 1);
        __int16 v71 = 2048;
        uint64_t v72 = v28;
        __int16 v73 = 2048;
        uint64_t v74 = *((void *)&v28 + 1);
        __int16 v75 = 1026;
        int v76 = HIBYTE(v29);
        double v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLPedometer::PaceController::feedStepCountEntry(const CLExtendedStepCountEntry &)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
    }
  }
  double v12 = *a2;
  int v13 = *(_DWORD *)(a1 + 1168);
  unsigned int v14 = sub_1001BEAA8((uint64_t)(a2 + 1));
  sub_1001A13A8((void **)(a1 + 8), (uint64_t)a2, v13, v14, v12);
  *(void *)(a1 + 1144) = v15;
}

void sub_1001BF238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  PB::Base::~Base((PB::Base *)&a65);
  _Unwind_Resume(a1);
}

double sub_1001BF26C(double a1, double a2, double a3, double a4, double a5)
{
  return (a5 - a1) / (a3 - a1) * a4 + (1.0 - (a5 - a1) / (a3 - a1)) * a2;
}

void sub_1001BF28C(uint64_t a1, int a2)
{
  char v18 = a2;
  int v2 = (char *)(a1 + 240);
  if (a2 != 68 && *(unsigned __int8 *)(a1 + 240) != a2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10230CB28);
    }
    long long v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      long long v5 = sub_100147F50(*(_DWORD *)(a1 + 48));
      double v6 = sub_10013DAC0(a1 + 48);
      double v7 = sub_10013DA9C(a1 + 48);
      *(void *)long long buf = &v18;
      long long v8 = sub_10104DE0C((uint64_t **)&unk_10248B168, &v18, (uint64_t)&unk_101D0B290, (unsigned char **)buf)[5];
      *(void *)long long buf = v2;
      BOOL v9 = sub_10104DE0C((uint64_t **)&unk_10248B168, v2, (uint64_t)&unk_101D0B290, (unsigned char **)buf)[5];
      *(_DWORD *)long long buf = 136447235;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v29 = 2049;
      double v30 = v6;
      __int16 v31 = 2049;
      double v32 = v7;
      __int16 v33 = 2082;
      uint64_t v34 = v8;
      __int16 v35 = 2082;
      uint64_t v36 = v9;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "@TileReq, %{public}s, skip, llsw, %{private}.2lf, %{private}.2lf, reason, %{public}s, last, %{public}s", buf, 0x34u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10230CB28);
      }
      unsigned int v11 = *(_DWORD *)(a1 + 48);
      uint64_t v10 = a1 + 48;
      double v12 = sub_100147F50(v11);
      double v13 = sub_10013DAC0(v10);
      double v14 = sub_10013DA9C(v10);
      *(void *)long long v19 = &v18;
      uint64_t v15 = sub_10104DE0C((uint64_t **)&unk_10248B168, &v18, (uint64_t)&unk_101D0B290, (unsigned char **)v19)[5];
      *(void *)long long v19 = v2;
      double v16 = sub_10104DE0C((uint64_t **)&unk_10248B168, v2, (uint64_t)&unk_101D0B290, (unsigned char **)v19)[5];
      *(_DWORD *)long long v19 = 136447235;
      *(void *)&v19[4] = v12;
      __int16 v20 = 2049;
      double v21 = v13;
      __int16 v22 = 2049;
      double v23 = v14;
      __int16 v24 = 2082;
      long long v25 = v15;
      __int16 v26 = 2082;
      long long v27 = v16;
      double v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLTileFile::setSkipDownloadReason(char)", "%s\n", v17);
      if (v17 != buf) {
        free(v17);
      }
    }
  }
  *int v2 = v18;
}

uint64_t sub_1001BF5C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  uint64_t v3 = *(void *)(a1 + 104);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  return v3;
}

void sub_1001BF644(void *a1, int *a2, void *a3)
{
  if (!*((unsigned char *)a1 + 108))
  {
    long long v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      BOOL v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          double v12 = (uint64_t *)v4;
        }
        else {
          double v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          BOOL v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        __int16 v49 = v9;
        id v13 = sub_100040DBC(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184))(a1, a2, v13, v9 + 10);
        double v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          uint64_t v15 = a1 + 11;
          double v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            long long v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                __int16 v22 = (uint64_t *)v17;
              }
              else {
                __int16 v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                long long v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v48 = v19;
              sub_1001BFA34(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              __int16 v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  double v32 = (uint64_t *)v27;
                }
                else {
                  double v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  __int16 v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              __int16 v49 = v29;
              uint64_t v34 = v29[6];
              double v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    __int16 v39 = (uint64_t *)v36;
                  }
                  else {
                    __int16 v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      double v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  __int16 v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      double v14 = v43;
                      __int16 v43 = (void *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      double v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              uint64_t v48 = a1 + 11;
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_10234C6A8);
              }
              __int16 v24 = qword_102419588;
              if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
              {
                long long v25 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  long long v25 = (void *)*v16;
                }
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)long long buf = 136446466;
                __int16 v55 = v25;
                __int16 v56 = 1026;
                int v57 = v26;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_10013D1A0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419580 != -1) {
                  dispatch_once(&qword_102419580, &stru_10234C6A8);
                }
                __int16 v45 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  __int16 v45 = (void *)*v16;
                }
                int v46 = *((_DWORD *)v14 + 7);
                int v50 = 136446466;
                __int16 v51 = v45;
                __int16 v52 = 1026;
                int v53 = v46;
                __int16 v47 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 0, "void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "%s\n", v47);
                if (v47 != (char *)buf) {
                  free(v47);
                }
              }
            }
          }
          while (v14 != v49 + 6);
        }
      }
    }
  }
}

unsigned char *sub_1001BFA34(unsigned char *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    double v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32);
    id v9 = sub_100040DBC(a4);
    uint64_t v10 = *(void *)a3 + 80;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40);
    double v14 = (int *)(*(void *)a2 + 32);
    double v12 = sub_1000EB1B8(v11, v14, (uint64_t)&unk_101D0B290, &v14);
    id result = (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192))(v7, v8, &v13, v9, v10, v12 + 4);
    if (result) {
      return [*(id *)(*(void *)a2 + 64) onNotification:*(unsigned int *)(*(void *)a3 + 32) withData:a4, v13];
    }
  }
  return result;
}

uint64_t sub_1001BFB2C()
{
  return 1;
}

BOOL sub_1001BFB34(char *a1, int a2, int *a3)
{
  int v32 = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      uint64_t v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          BOOL v11 = (uint64_t *)v6;
        }
        else {
          BOOL v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        double v14 = (char *)*((void *)v8 + 6);
        double v12 = v8 + 48;
        uint64_t v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          double v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              long long v19 = (char **)v13;
            }
            else {
              long long v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              double v16 = v13;
            }
            uint64_t v13 = *v19;
          }
          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1000ED9F4((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            __int16 v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                long long v25 = (uint64_t *)v20;
              }
              else {
                long long v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                __int16 v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }
            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_10017C890((uint64_t)(v22 + 40), &v32);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176))(a1, a3);
              }
            }
            else
            {
LABEL_33:
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_1022BDF28);
              }
              int v26 = qword_102419588;
              if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
              {
                uint64_t v27 = a1 + 8;
                if (a1[31] < 0) {
                  uint64_t v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160))(__p, a1, a3);
                if (v42 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v34 = 2082;
                __int16 v35 = v28;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v42 < 0) {
                  operator delete(__p[0]);
                }
              }
              if (sub_10013D1A0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_102419580 != -1) {
                  dispatch_once(&qword_102419580, &stru_1022BDF28);
                }
                __int16 v29 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v29 = (void *)*v29;
                }
                (*(void (**)(unsigned char *__return_ptr, char *, int *))(*(void *)a1 + 160))(buf, a1, a3);
                if (v36 >= 0) {
                  int v30 = buf;
                }
                else {
                  int v30 = *(unsigned char **)buf;
                }
                int v37 = 136446466;
                BOOL v38 = v29;
                __int16 v39 = 2082;
                int v40 = v30;
                BOOL v31 = (char *)_os_log_send_and_compose_impl();
                if (v36 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]", "%s\n", v31);
                if (v31 != (char *)__p) {
                  free(v31);
                }
              }
            }
          }
        }
      }
    }
  }
  return v3 == 0;
}

void sub_1001BFF08(uint64_t a1, uint64_t a2)
{
  v14[0] = a2;
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        int v9 = (uint64_t *)v4;
      }
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)long long buf = *(_DWORD *)(*(void *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112))(a1, a2, buf);
      }
      sub_10006DA64(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_1022BDF28);
      }
      BOOL v10 = qword_102419588;
      if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
      {
        BOOL v11 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          BOOL v11 = (void *)*v11;
        }
        *(_DWORD *)long long buf = 136446466;
        long long v19 = v11;
        __int16 v20 = 1026;
        int v21 = a2;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419580 != -1) {
          dispatch_once(&qword_102419580, &stru_1022BDF28);
        }
        double v12 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          double v12 = (void *)*v12;
        }
        v14[1] = 136446466;
        int v15 = v12;
        __int16 v16 = 1026;
        int v17 = a2;
        uint64_t v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::removeClient(int) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]", "%s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
    }
  }
}

void sub_1001C0198(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000DB3D4((uint64_t)v8);
  (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, a2, v8, a3, a4, 0);

  if (v13) {
    sub_1000DB0A0(v13);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  if (v10) {
    sub_1000DB0A0(v10);
  }
  if (v9) {
    sub_1000DB0A0(v9);
  }
}

void sub_1001C0260(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100458658((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1001C0274(uint64_t a1, uint64_t a2)
{
  sub_1001C02D0(a1 + 48, 1u, *(double *)(a2 + 80));
  double v4 = *(double *)(a2 + 80) + -300.0;

  sub_1001C02D0(a1 + 216, 1u, v4);
}

void sub_1001C02D0(uint64_t a1, unsigned int a2, double a3)
{
  double v3 = *(double *)(a1 + 80);
  if (v3 != 0.0)
  {
    if (*(_DWORD *)(a1 + 32)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = a2 == 2;
    }
    if (v7) {
      double v8 = a3;
    }
    else {
      double v8 = a3 + -7.0;
    }
    sub_100134750(&v19, "unknown");
    if (a2 < 3) {
      std::string::assign(&v19, off_1022E9A70[a2]);
    }
    if (v8 - v3 >= *(double *)(a1 + 24))
    {
      if (qword_1024191F0 != -1) {
        dispatch_once(&qword_1024191F0, &stru_1022E9A50);
      }
      int v9 = qword_1024191F8;
      if (os_log_type_enabled((os_log_t)qword_1024191F8, OS_LOG_TYPE_INFO))
      {
        if (*(char *)(a1 + 63) < 0)
        {
          sub_1000DC48C(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
          *(void *)&__p[16] = *(void *)(a1 + 56);
        }
        BOOL v10 = __p;
        if (__p[23] < 0) {
          BOOL v10 = *(unsigned char **)__p;
        }
        uint64_t v11 = *(void *)(a1 + 72);
        char v12 = &v19;
        if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          char v12 = (std::string *)v19.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446978;
        long long v25 = v10;
        __int16 v26 = 2050;
        uint64_t v27 = v11;
        __int16 v28 = 2082;
        __int16 v29 = v12;
        __int16 v30 = 2050;
        double v31 = a3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "BoutDetector (%{public}s): Ending bout (%{public}.2f) due to maxTimeSinceEndOfBout from %{public}s time (%{public}.2f)", buf, 0x2Au);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024191F0 != -1) {
          dispatch_once(&qword_1024191F0, &stru_1022E9A50);
        }
        if (*(char *)(a1 + 63) < 0)
        {
          sub_1000DC48C(__dst, *(void **)(a1 + 40), *(void *)(a1 + 48));
        }
        else
        {
          *(_OWORD *)__dst = *(_OWORD *)(a1 + 40);
          uint64_t v18 = *(void *)(a1 + 56);
        }
        uint64_t v13 = __dst;
        if (v18 < 0) {
          uint64_t v13 = (void **)__dst[0];
        }
        uint64_t v14 = *(void *)(a1 + 72);
        int v15 = &v19;
        if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v15 = (std::string *)v19.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string __p = 136446978;
        *(void *)&__p[4] = v13;
        *(_WORD *)&unsigned char __p[12] = 2050;
        *(void *)&__p[14] = v14;
        *(_WORD *)&__p[22] = 2082;
        int v21 = v15;
        __int16 v22 = 2050;
        double v23 = a3;
        __int16 v16 = (char *)_os_log_send_and_compose_impl();
        if (SHIBYTE(v18) < 0) {
          operator delete(__dst[0]);
        }
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMobility::BoutDetector::checkBoutEndWithPacketTime(CFAbsoluteTime, PacketType)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
      sub_100BA644C(a1, 1);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1001C0624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1001C0654(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0664(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0674(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0684(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0694(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C06A4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C06B4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C06C4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C06D4(int a1, unsigned int *a2, void *__src, void *a4)
{
  uint64_t v5 = *a2;
  memcpy(__dst, __src, sizeof(__dst));
  return [a4 onMotionStateMediatorNotification:v5 data:__dst];
}

id sub_1001C0754(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0764(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0774(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0784(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1001C0794(uint64_t a1, void *a2)
{
  return _[a2 onMotionStateCoprocessorData:a1];
}

id sub_1001C07A0(uint64_t a1, void *a2)
{
  return [a2 onOutdoorUpdate:a1];
}

uint64_t sub_1001C07AC(int *a1)
{
  if (*a1 < 5) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  double v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)long long buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled vehicle confidence type: %{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::MotionActivity_VehicularConfidenceType ConvertCLMotionActivityVehicularConfidenceTypeToProtobuf(const CLMotionActivity::VehicularConfidence &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001C0980(int *a1)
{
  if (*a1 < 3) {
    return (*a1 + 1);
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  double v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)long long buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled vehicle exit state type: %{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::MotionActivity_VehicleExitStateType ConvertCLMotionActivityVehicleExitStateTypeToProtobuf(const CLMotionActivity::VehicleExitState &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1001C0B54(int *a1)
{
  if (!*a1) {
    return 1;
  }
  if (*a1 == 1) {
    return 2;
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  double v3 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)long long buf = 67240192;
    int v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled mounted state type: %{public}d", buf, 8u);
  }
  BOOL v5 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::MotionActivity_MountedStateType ConvertCLMotionActivityMountedStateTypeToProtobuf(const CLMotionActivity::MountedState &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
    return 0;
  }
  return result;
}

id sub_1001C0D34(int a1, unsigned int *a2, void *__src, void *a4)
{
  uint64_t v5 = *a2;
  memcpy(__dst, __src, sizeof(__dst));
  return [a4 onMotionStateMediatorNotification:v5 data:__dst];
}

uint64_t sub_1001C0DB4(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    BOOL v10 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    LOWORD(v25) = 0;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)long long buf = 134349056;
      double v28 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Mach absolute time cannot be negative or infinite: %{public}lf", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v8 = *a1;
    int v25 = 134349056;
    double v26 = v8;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  *(_DWORD *)(a2 + 36) |= 2u;
  *(double *)(a2 + 16) = v4;
  if (a3) {
    return 1;
  }
  if (!qword_102487C40) {
    operator new();
  }
  unint64_t v24 = 0xBFF0000000000000;
  BOOL v11 = sub_100B01398(qword_102487C40, a1, (double *)&v24);
  if (v11)
  {
    unint64_t v14 = v24;
    *(_DWORD *)(a2 + 36) |= 4u;
    *(void *)(a2 + 24) = v14;
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v15 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
    {
      double v16 = *a1;
      *(_DWORD *)long long buf = 134217984;
      double v28 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Mach absolute to mach continuous time conversion failed: %lf", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      double v21 = *a1;
      int v25 = 134217984;
      double v26 = v21;
      __int16 v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
  }
  unint64_t v23 = 0xBFF0000000000000;
  if (sub_100B01790(qword_102487C40, a1, (double *)&v23))
  {
    unint64_t v17 = v23;
    *(_DWORD *)(a2 + 36) |= 1u;
    *(void *)(a2 + 8) = v17;
    return v11;
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v18 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
  {
    double v19 = *a1;
    *(_DWORD *)long long buf = 134217984;
    double v28 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Mach absolute to CF absolute time conversion failed: %lf", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v20 = *a1;
    int v25 = 134217984;
    double v26 = v20;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
LABEL_45:
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return 0;
}

float sub_1001C1428(float a1, float a2, float a3)
{
  return (float)((float)((float)(a3 * -287.05) / 101320.0) / 9.8067)
       * powf(a1 / 101320.0, (float)((float)(a2 * 287.05) / 9.8067) + -1.0);
}

uint64_t sub_1001C148C(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)long long buf = 67240192;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received unhandled signal quality type: %{public}d", buf, 8u);
    }
    BOOL v5 = sub_10013D1A0(115, 0);
    uint64_t result = 0;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLP::LogEntry::PrivateData::Location_SignalQualityType ConvertCLSignalQualityTypeToProtobuf(const CLLocationProvider_Type::SignalQuality &)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1001C1658(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    BOOL v10 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    LOWORD(v23) = 0;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    uint64_t v6 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)long long buf = 134349056;
      double v26 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "CF absolute time cannot be negative or infinite: %{public}lf", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v8 = *a1;
    int v23 = 134349056;
    double v24 = v8;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
    goto LABEL_45;
  }
  *(_DWORD *)(a2 + 36) |= 1u;
  *(double *)(a2 + 8) = v4;
  if (a3) {
    return 1;
  }
  if (!qword_102487C40) {
    operator new();
  }
  *(double *)&unint64_t v22 = -1.0;
  BOOL v11 = sub_100B0198C(qword_102487C40, a1, (double *)&v22);
  if (v11)
  {
    unint64_t v14 = v22;
    *(_DWORD *)(a2 + 36) |= 2u;
    *(void *)(a2 + 16) = v14;
  }
  else
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v15 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
    {
      double v16 = *a1;
      *(_DWORD *)long long buf = 134217984;
      double v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Error: CF absolute to mach absolute time conversion failed: %lf", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      double v19 = *a1;
      int v23 = 134217984;
      double v24 = v19;
      double v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  unint64_t v21 = 0xBFF0000000000000;
  if (sub_100B01398(qword_102487C40, (double *)&v22, (double *)&v21))
  {
    unint64_t v17 = v21;
    *(_DWORD *)(a2 + 36) |= 4u;
    *(void *)(a2 + 24) = v17;
    return v11;
  }
  if (qword_1024194C0 != -1) {
    dispatch_once(&qword_1024194C0, &stru_102327520);
  }
  uint64_t v18 = qword_1024194C8;
  if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    double v26 = *(double *)&v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Error: Mach absolute to mach continuous time conversion failed: %lf", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    int v23 = 134217984;
    double v24 = *(double *)&v22;
    int v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)", "%s\n", v9);
LABEL_45:
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return 0;
}

unint64_t sub_1001C1CCC(unint64_t *a1)
{
  unint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_1024194C0 != -1) {
      dispatch_once(&qword_1024194C0, &stru_102327520);
    }
    double v3 = qword_1024194C8;
    if (os_log_type_enabled((os_log_t)qword_1024194C8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v4 = *a1;
      *(_DWORD *)long long buf = 67240192;
      int v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "ConvertIndoorOutdoorTypeToProtobuf,unhandled type,%{public}d", buf, 8u);
    }
    unint64_t result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024194C0 != -1) {
        dispatch_once(&qword_1024194C0, &stru_102327520);
      }
      BOOL v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLP::LogEntry::PrivateData::IndoorOutdoorType ConvertIndoorOutdoorTypeToProtobuf(const CMIndoorOutdoorType &)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
      return 0;
    }
  }
  return result;
}

int8x16_t sub_1001C1E90(int8x16_t *a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 28) |= 3u;
  int8x16_t result = vextq_s8(*a1, *a1, 8uLL);
  *(int8x16_t *)(a2 + 8) = result;
  return result;
}

id sub_1001C1EAC(uint64_t a1, unsigned int *a2, _OWORD *a3, void *a4)
{
  uint64_t v4 = *a2;
  long long v5 = a3[9];
  v12[8] = a3[8];
  v12[9] = v5;
  long long v6 = a3[11];
  v12[10] = a3[10];
  v12[11] = v6;
  long long v7 = a3[5];
  v12[4] = a3[4];
  v12[5] = v7;
  long long v8 = a3[7];
  v12[6] = a3[6];
  v12[7] = v8;
  long long v9 = a3[1];
  v12[0] = *a3;
  v12[1] = v9;
  long long v10 = a3[3];
  _OWORD v12[2] = a3[2];
  v12[3] = v10;
  return [a4 onOdometerNotification:v4 data:v12];
}

__n128 sub_1001C1F0C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 44);
  *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
  *(_DWORD *)(a2 + 44) = v2 | 0xF;
  __n128 result = *(__n128 *)(a1 + 16);
  *(__n128 *)(a2 + 24) = result;
  return result;
}

float sub_1001C1F30(float a1, float a2)
{
  return (float)(1.0 - powf(a1 / a2, 0.19026)) * 44331.0;
}

void sub_1001C1F68()
{
}

void sub_1001C2018()
{
}

void sub_1001C203C()
{
}

void sub_1001C219C()
{
}

void sub_1001C224C()
{
}

id sub_1001C2270(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (v2)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_1022C99A8);
      }
      double v3 = qword_102418F98;
      if (os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134218498;
        id v8 = v2;
        __int16 v9 = 2048;
        uint64_t v10 = 0;
        __int16 v11 = 2080;
        unint64_t v12 = 0x8000000101D2DF2DLL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102418F90 == -1)
      {
LABEL_20:
        long long v6 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLClientManager_Type::Name, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]", "%s\n", v6);
        if (v6 != (char *)buf) {
          free(v6);
        }
        return 0;
      }
    }
    else
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_1022C99A8);
      }
      long long v5 = qword_102418F98;
      if (os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 134218498;
        id v8 = v2;
        __int16 v9 = 2048;
        uint64_t v10 = 0;
        __int16 v11 = 2080;
        unint64_t v12 = 0x8000000101D2DF2DLL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_10013D1A0(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102418F90 == -1) {
        goto LABEL_20;
      }
    }
    dispatch_once(&qword_102418F90, &stru_1022C99A8);
    goto LABEL_20;
  }

  return [a1 cppObjectPtr];
}

double sub_1001C2630(int a1)
{
  double result = 60.0;
  if (a1 != 2) {
    double result = 0.0;
  }
  if (a1 == 1) {
    return 10.0;
  }
  return result;
}

id sub_1001C2654(void *a1)
{
  id v1 = [a1 objectForKey:@"IncidentalUseMode"];

  return [v1 unsignedIntValue];
}

void sub_1001C2684(long double a1)
{
}

uint64_t sub_1001C2710()
{
  if (!qword_10247AD40)
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_1022B5E98);
    }
    uint64_t v0 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "***no run loop available***", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_1022B5E98);
      }
      id v2 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CFRunLoopRef CLCommonGetRunLoop()", "%s\n", v2);
      if (v2 != (char *)buf) {
        free(v2);
      }
    }
  }
  return qword_10247AD40;
}

const char *sub_1001C28B0(unsigned int a1)
{
  if (a1 > 4) {
    return "UNKNOWN";
  }
  else {
    return off_1022B5F20[a1];
  }
}

void sub_1001C32F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void sub_1001C4ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001C59AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
}

void sub_1001C604C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001C6D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1001C6E78(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 68))
  {
    if (!*(unsigned char *)(a2 + 68))
    {
      int v5 = *(_DWORD *)(a1 + 64);
      int v6 = *(_DWORD *)(a2 + 64);
      BOOL v4 = v5 < v6;
      if (v5 == v6)
      {
        if (!*(unsigned char *)(a1 + 32)) {
          sub_101A50394();
        }
        if (!*(unsigned char *)(a2 + 32)) {
          sub_101A50394();
        }
        return *(void *)(a1 + 40) < *(void *)(a2 + 40);
      }
      return v4;
    }
    return 1;
  }
  if (!*(unsigned char *)(a2 + 68)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(unsigned char *)(a2 + 48))
    {
      uint64_t v2 = *(void *)(a1 + 56);
      uint64_t v3 = *(void *)(a2 + 56);
      if (v2 != v3) {
        return v3 < v2;
      }
      goto LABEL_13;
    }
    return 0;
  }
  if (*(unsigned char *)(a2 + 48)) {
    return 1;
  }
LABEL_13:
  if (!*(unsigned char *)(a1 + 32))
  {
    if (!*(unsigned char *)(a2 + 32)) {
      return *(_DWORD *)(a1 + 64) < *(_DWORD *)(a2 + 64);
    }
    return 1;
  }
  if (!*(unsigned char *)(a2 + 32)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a2 + 40);
  BOOL v4 = v7 < v8;
  if (v7 == v8) {
    return *(_DWORD *)(a1 + 64) < *(_DWORD *)(a2 + 64);
  }
  return v4;
}

uint64_t sub_1001C6F4C(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 32))
  {
    if (*(unsigned char *)(result + 32))
    {
      uint64_t v2 = *(void *)(result + 40);
      if (v2 <= *(void *)(a2 + 40)) {
        uint64_t v2 = *(void *)(a2 + 40);
      }
      *(void *)(result + 40) = v2;
    }
    else
    {
      *(void *)(result + 40) = *(void *)(a2 + 40);
      *(unsigned char *)(result + 32) = 1;
    }
  }
  if (*(unsigned char *)(a2 + 48))
  {
    if (*(unsigned char *)(result + 48))
    {
      uint64_t v3 = *(void *)(a2 + 56);
      if (v3 >= *(void *)(result + 56)) {
        uint64_t v3 = *(void *)(result + 56);
      }
      *(void *)(result + 56) = v3;
    }
    else
    {
      *(void *)(result + 56) = *(void *)(a2 + 56);
      *(unsigned char *)(result + 48) = 1;
    }
  }
  *(unsigned char *)(result + 68) = (*(unsigned __int8 *)(result + 68) | *(unsigned __int8 *)(a2 + 68)) != 0;
  return result;
}

uint64_t sub_1001C6FD8(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1001C700C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1001C7134()
{
}

void sub_1001C71F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1001C7E50(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_10229DFF0;
  *(void *)(a1 + 24) = a2;
  *(unsigned char *)(a1 + 40) = 0;
  sub_100134750(__p, "CLIndoorLogicOSTransaction");
  sub_100DEE064(a1 + 48, __p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  *(void *)(a1 + 8) = objc_alloc_init(CLIndoorState);
  *(void *)(a1 + 16) = objc_alloc_init((Class)CLIndoorSettings);
  return a1;
}

void sub_1001C7EF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001C7F28(uint64_t a1)
{
  *(void *)a1 = off_10229DFF0;

  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  sub_100DEE0E0(a1 + 48);
  return a1;
}

void sub_1001C7F8C(void *a1)
{
}

void sub_1001C7FA4(uint64_t a1)
{
  sub_1001C7F28(a1);

  operator delete();
}

id sub_1001C7FDC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ([*(id *)(a1 + 8) pipelinedSeeded] == a2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v6 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
      if (*((char *)a3 + 23) >= 0) {
        uint64_t v8 = a3;
      }
      else {
        uint64_t v8 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136446466;
      double v16 = v7;
      __int16 v17 = 2082;
      uint64_t v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "@IndoorSeed, same, %{public}s, %{public}s", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
LABEL_25:
      unint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::setSeedState(PipelinedSeeded, const std::string &)", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    __int16 v9 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = sub_1001C8388(a2);
      if (*((char *)a3 + 23) >= 0) {
        __int16 v11 = a3;
      }
      else {
        __int16 v11 = (uint64_t *)*a3;
      }
      unint64_t v12 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
      *(_DWORD *)long long buf = 136446722;
      double v16 = v10;
      __int16 v17 = 2082;
      uint64_t v18 = v11;
      __int16 v19 = 2082;
      double v20 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "@IndoorSeed, set, %{public}s, %{public}s, was, %{public}s", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      sub_1001C8388(a2);
      sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
      goto LABEL_25;
    }
  }
  return [*(id *)(a1 + 8) setPipelinedSeeded:a2];
}

const char *sub_1001C8388(unsigned int a1)
{
  if (a1 < 3) {
    return (&off_10229E1A0)[a1];
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v3 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    unsigned int v6 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Corrupt PipelinedSeeded: got %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "const char *to_string(PipelinedSeeded)", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return "Unknown pipelinedSeeded";
}

uint64_t sub_1001C8554(uint64_t a1, uint64_t a2)
{
  if (![*(id *)(a1 + 16) pipelinedEnabled]) {
    return 1;
  }
  if (![*(id *)(a1 + 8) wifiPowered]) {
    return 2;
  }
  if (!*(unsigned char *)[*(id *)(a1 + 8) latestPosition]) {
    return 3;
  }
  [*(id *)(a1 + 8) latestNavModeEstimate];
  if (v4 == 2 && !*(unsigned char *)(a1 + 40)) {
    return 4;
  }
  if (*(unsigned char *)[*(id *)(a1 + 8) lastIndoorError])
  {
    char v5 = [*(id *)(a1 + 8) lastIndoorError];
    if (!*v5) {
      sub_101A503C0();
    }
    unsigned int v6 = v5;
    id v7 = sub_1001D1A5C(a1) ? (id)300000000000 : [*(id *)(a1 + 16) errorBackoffDuration];
    if ((uint64_t)v7 + *((void *)v6 + 1) > a2) {
      return 5;
    }
  }
  if ([*(id *)(a1 + 8) isStreamingClientInFitnessSession]) {
    return 6;
  }
  if ([*(id *)(a1 + 8) isVehicleConnected] && !*(unsigned char *)(a1 + 40)) {
    return 7;
  }
  if ([*(id *)(a1 + 8) isInVehicleNavigation] && !*(unsigned char *)(a1 + 40)) {
    return 8;
  }
  if ([*(id *)(a1 + 8) hasAtLeastOneClientWithCLActivityTypeFitness]) {
    return 9;
  }
  if (sub_100182064([*(id *)(a1 + 8) fitnessModeStateMachine])) {
    return 10;
  }
  return 0;
}

uint64_t sub_1001C86BC(uint64_t a1)
{
  if (sub_1001D1A5C(a1)) {
    return 300000000000;
  }
  uint64_t v3 = *(void **)(a1 + 16);

  return (uint64_t)[v3 errorBackoffDuration];
}

uint64_t sub_1001C8710(uint64_t a1, uint64_t a2)
{
  if (![*(id *)(a1 + 8) pipelinedSeeded])
  {
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10229E180);
    }
    unint64_t v21 = qword_102419638;
    if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Indoor/CLIndoorStateMachine.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&unsigned char buf[14] = 829;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = "isPipelinedSeeded()";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419630 != -1) {
        dispatch_once(&qword_102419630, &stru_10229E180);
      }
      int v32 = 136315650;
      *(void *)uint64_t v33 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Indoor/CLIndoorStateMachine.mm";
      *(_WORD *)&v33[8] = 1024;
      *(_DWORD *)&unsigned char v33[10] = 829;
      *(_WORD *)&v33[14] = 2080;
      *(void *)&v33[16] = "isPipelinedSeeded()";
      double v28 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "TurnOffReason CLIndoorLogic::isRequiredToTurnOff(std::chrono::steady_clock::time_point)", "%s\n", v28);
      if (v28 != (char *)buf) {
        free(v28);
      }
    }
    sub_1004BA578();
  }
  if (![*(id *)(a1 + 16) pipelinedEnabled]) {
    return 1;
  }
  if (*(unsigned char *)[*(id *)(a1 + 8) latestPosition])
  {
    int v4 = [*(id *)(a1 + 8) latestPosition];
    if (!*v4) {
      sub_101A503C0();
    }
    if (!sub_1001DC488((uint64_t)(v4 + 8), a2))
    {
      if (([*(id *)(a1 + 8) locationGroupsLoaded] & 1) == 0)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        __int16 v19 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
        {
          unsigned int v20 = [*(id *)(a1 + 8) pipelinedSeeded];
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Seeded = %{public}d & trying to turn off but availability tiles not loaded?!", buf, 8u);
        }
        if (sub_10013D1A0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          unsigned int v26 = [*(id *)(a1 + 8) pipelinedSeeded];
          int v32 = 67240192;
          *(_DWORD *)uint64_t v33 = v26;
          uint64_t v27 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "TurnOffReason CLIndoorLogic::isRequiredToTurnOff(std::chrono::steady_clock::time_point)", "%s\n", v27);
          if (v27 != (char *)buf) {
            free(v27);
          }
        }
        return 8;
      }
      id v7 = sub_1001C8F84(a1);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v8 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
        uint64_t v10 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        *(_DWORD *)long long buf = 134349570;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(void *)&unsigned char buf[14] = v9;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&unsigned char buf[24] = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "@IndoorAvl, load, stalecheck, %{public}lu, total, %{public}lu, state, %{public}s", buf, 0x20u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        id v23 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
        double v24 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        int v32 = 134349570;
        *(void *)uint64_t v33 = v7;
        *(_WORD *)&v33[8] = 2050;
        *(void *)&unsigned char v33[10] = v23;
        *(_WORD *)&unsigned char v33[18] = 2082;
        *(void *)&v33[20] = v24;
        int v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "TurnOffReason CLIndoorLogic::isRequiredToTurnOff(std::chrono::steady_clock::time_point)", "%s\n", v25);
        if (v25 != (char *)buf) {
          free(v25);
        }
      }
      __int16 v11 = (char *)[*(id *)(a1 + 8) latestPosition];
      if (!*v11) {
        sub_101A503EC();
      }
      uint64_t v12 = *(void *)(v11 + 28);
      uint64_t v13 = *((void *)v11 + 12);
      *(_OWORD *)double v31 = *(_OWORD *)(v11 + 104);
      *(_DWORD *)&v31[16] = *((_DWORD *)v11 + 30);
      long long v35 = *(_OWORD *)&v31[4];
      *(_OWORD *)uint64_t v33 = *(_OWORD *)&v31[4];
      *(void *)&v33[16] = v12;
      uint64_t v34 = v13;
      memcpy(buf, &unk_101D216A0, 0x230uLL);
      id v14 = [objc_alloc((Class)CLGpsPosition) initWithLocation:&v32 andPrivateLocation:buf];
      v29[0] = [*(id *)(a1 + 16) forcedVenues];
      [*(id *)(a1 + 16) venueGroupDistance];
      v29[1] = v15;
      v29[2] = [*(id *)(a1 + 16) fakeLastFix];
      char v30 = sub_10016CCBC();
      id v16 = [*(id *)(a1 + 8) locationGroups];
      [*(id *)(a1 + 8) availabilityZScoreConfidenceInterval];
      id v17 = +[CLIndoorCommonHooks nearestVenues:availableVenues:latestPosition:availabilityZScoreConfidenceInterval:settings:isAllowedMultipleVenues:](CLIndoorCommonHooks, "nearestVenues:availableVenues:latestPosition:availabilityZScoreConfidenceInterval:settings:isAllowedMultipleVenues:", a2, v16, v14, v29, 1);

      if (!v17 || ![v17 count]) {
        return 2;
      }
    }
  }
  [*(id *)(a1 + 8) latestNavModeEstimate];
  if (v5)
  {
    if (v5 == 2 && !*(unsigned char *)(a1 + 40)) {
      return 3;
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v18 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Uninitialized outdoor classification while pipeline is active", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      LOWORD(v32) = 0;
      unint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "TurnOffReason CLIndoorLogic::isRequiredToTurnOff(std::chrono::steady_clock::time_point)", "%s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
  }
  if (![*(id *)(a1 + 8) wifiPowered]) {
    return 4;
  }
  if ([*(id *)(a1 + 8) isStreamingClientInFitnessSession]) {
    return 5;
  }
  if ([*(id *)(a1 + 8) isVehicleConnected] && !*(unsigned char *)(a1 + 40)) {
    return 6;
  }
  if ([*(id *)(a1 + 8) isInVehicleNavigation] && !*(unsigned char *)(a1 + 40)) {
    return 7;
  }
  if ([*(id *)(a1 + 8) hasAtLeastOneClientWithCLActivityTypeFitness]) {
    return 9;
  }
  if (sub_100182064([*(id *)(a1 + 8) fitnessModeStateMachine])) {
    return 10;
  }
  return 0;
}

id sub_1001C8F84(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSAutoreleasePool);
  id v3 = [[objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") lastFix];
  if (*(unsigned char *)[*(id *)(a1 + 8) latestPosition])
  {
    int v4 = (char *)[*(id *)(a1 + 8) latestPosition];
    if (!*v4) {
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    id v3 = [objc_alloc((Class)GeographicCoordinate) initWithLatitude:*(double *)(v4 + 108) longitude:*(double *)(v4 + 116) andAltitude:*(double *)(v4 + 36)];
  }
  unsigned int v5 = [objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") shouldRecompute:v3];
  if (([*(id *)(a1 + 8) locationGroupsLoaded] ^ 1 | v5))
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unsigned int v6 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = [*(id *)(a1 + 8) locationGroupsLoaded];
      *(_DWORD *)long long buf = 67240448;
      unsigned int v24 = v5;
      __int16 v25 = 1026;
      unsigned int v26 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "@IndoorAvl, load, must recompute, %{public}d, locationGroupsLoaded, %{public}d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      [*(id *)(a1 + 8) locationGroupsLoaded];
      LODWORD(v21) = 14;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "unsigned long CLIndoorLogic::reloadAvailabilityGroupsIfNecessary()", "%s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    uint64_t v8 = (id *)(a1 + 48);
    sub_100DEE0E4(a1 + 48);
    if ([*(id *)(a1 + 8) avlTilePathOverrideForTest]) {
      id v9 = (NSURL *)[*(id *)(a1 + 8) avlTilePathOverrideForTest];
    }
    else {
      id v9 = sub_1001CE15C();
    }
    uint64_t v12 = v9;
    if (([*(id *)(a1 + 8) locationGroupsLoaded] & 1) == 0) {
      [objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") clearLastFix];
    }
    id v13 = [objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") getNearbyLocationGroups:v12 withUpdatedPos:v3];
    if (!v13)
    {
      id v11 = 0;
LABEL_29:
      sub_100DEE0B0(v8);
      goto LABEL_30;
    }
    if (objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "availableVenuesState"), "availabilityTileParams"))
    {
      id v14 = *(void **)(a1 + 8);
      [objc_msgSend(objc_msgSend(objc_msgSend(v14, "availableVenuesState"), "availabilityTileParams"), "availabilityZScoreConfidenceInterval"];
      [v14 setAvailabilityTiles:v13];
      [*(id *)(a1 + 8) updatePrefetchParameters:[objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") availabilityTileParams]];
      (*(void (**)(void))(**(void **)(a1 + 24) + 88))(*(void *)(a1 + 24));
      if (qword_1024193A0 == -1)
      {
LABEL_24:
        uint64_t v15 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "contents on disk have changed, or we moved really far away, re-read availability tiles into memory", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          LODWORD(v21) = 2;
          __int16 v19 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "unsigned long CLIndoorLogic::reloadAvailabilityGroupsIfNecessary()", "%s\n", v19);
          if (v19 != (char *)buf) {
            free(v19);
          }
        }
        id v11 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups", v20, v21, v22) count];
        goto LABEL_29;
      }
    }
    else
    {
      sub_101A50418();
      uint64_t v21 = 1470;
      unint64_t v22 = "reloadAvailabilityGroupsIfNecessary";
      unsigned int v20 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Indoor/CLIndoorStateMachine.mm";
      abort_report_np();
      __break(1u);
    }
    dispatch_once(&qword_1024193A0, &stru_10229E160);
    goto LABEL_24;
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v10 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Not necessary to reload availability groups, skipping", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "unsigned long CLIndoorLogic::reloadAvailabilityGroupsIfNecessary()", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
  id v11 = 0;
LABEL_30:

  return v11;
}

void sub_1001C95A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1001C95F4(uint64_t a1)
{
  return [*(id *)(a1 + 16) pipelinedEnabled];
}

uint64_t sub_1001C95FC(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (uint64_t)[*(id *)(a1 + 8) fSpectatingLocation];
  if ((result & 1) == 0)
  {
    [*(id *)(a1 + 8) setFSpectatingLocation:1];
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unsigned int v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        unsigned int v6 = a2;
      }
      else {
        unsigned int v6 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "@ClxIndoor, state, 1, spectate, starting to spectate location because %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::ensureSpectatingLocation(const std::string &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    if (sub_10016CCBC())
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unsigned int v7 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          uint64_t v8 = a2;
        }
        else {
          uint64_t v8 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v12 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "@ClxWifi2, state, 1, spectate, starting to spectate location because %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        uint64_t v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::ensureSpectatingLocation(const std::string &)", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
      }
    }
    return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))(*(void *)(a1 + 24));
  }
  return result;
}

uint64_t sub_1001C997C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))(*(void *)(a1 + 24));
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 168);
    return v3();
  }
  return result;
}

uint64_t sub_1001C9A08(uint64_t a1)
{
  if ([*(id *)(a1 + 8) state] != 2)
  {
    sub_101A5088C();
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }
  if (!objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "count"))
  {
    sub_101A505A4();
    goto LABEL_37;
  }
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    sub_101A50718();
    goto LABEL_37;
  }
  sub_100134750(__p, "startdeamon");
  sub_1001C7FDC(a1, 1, (uint64_t *)__p);
  if (v15 < 0) {
    operator delete(*(void **)__p);
  }
  [*(id *)(a1 + 8) setPipelinedDidStartLocalizing:0];
  id v1 = &qword_102419000;
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  id v2 = &qword_102419000;
  int v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "@ClxIndoor, state, 1, start", __p, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startDaemonLocalizingImpl()", "%s\n", v11);
    if (v11 != __p) {
      free(v11);
    }
  }
  if (sub_10016CCBC())
  {
    if (qword_1024193A0 == -1)
    {
LABEL_13:
      unsigned int v5 = v2[117];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "@ClxWifi2, state, 1, start", __p, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (v1[116] != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        id v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startDaemonLocalizingImpl()", "%s\n", v13);
        if (v13 != __p) {
          free(v13);
        }
      }
      goto LABEL_16;
    }
LABEL_38:
    dispatch_once(&qword_1024193A0, &stru_10229E160);
    goto LABEL_13;
  }
LABEL_16:
  sub_100134750(__p, "startDaemonLocalizingImpl");
  sub_1001C9FD4(a1, (uint64_t *)__p);
  if (v15 < 0) {
    operator delete(*(void **)__p);
  }
  (*(void (**)(void))(**(void **)(a1 + 24) + 160))(*(void *)(a1 + 24));
  if (v1[116] != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unsigned int v6 = v2[117];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    id v7 = [[[objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "description"), "componentsSeparatedByCharactersInSet:", +[NSCharacterSet whitespaceAndNewlineCharacterSet](NSCharacterSet, "whitespaceAndNewlineCharacterSet")), "componentsJoinedByString:", @",") UTF8String];
    *(_DWORD *)std::string __p = 136380675;
    *(void *)&__p[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "'Seeding pipelined' i.e. setVenuesAndStartLocalizer, with venues %{private}s", __p, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (v1[116] != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "description"), "componentsSeparatedByCharactersInSet:", +[NSCharacterSet whitespaceAndNewlineCharacterSet](NSCharacterSet, "whitespaceAndNewlineCharacterSet")), "componentsJoinedByString:", @",") UTF8String];
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startDaemonLocalizingImpl()", "%s\n", v12);
    if (v12 != __p) {
      free(v12);
    }
  }
  uint64_t v8 = *(void *)(a1 + 24);
  id v9 = [*(id *)(a1 + 8) latestPosition];
  if (!*v9) {
    sub_101A503EC();
  }
  return (*(uint64_t (**)(uint64_t, unsigned char *, id))(*(void *)v8 + 120))(v8, v9 + 8, [*(id *)(a1 + 8) lastARSessionState]);
}

void sub_1001C9FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001C9FD4(uint64_t a1, uint64_t *a2)
{
  if ([*(id *)(a1 + 8) fSpectatingLocation])
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a2 + 23) >= 0) {
        unsigned int v5 = a2;
      }
      else {
        unsigned int v5 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "stopping location spectating because %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::ensureNotSpectatingLocation(const std::string &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    [*(id *)(a1 + 8) setFSpectatingLocation:0];
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24));
}

void sub_1001CA1E4(uint64_t a1, NSObject *a2)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24));
    unsigned int v6 = sub_1001CA8D0([*(id *)(a1 + 8) state]);
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v5;
    __int16 v24 = 2080;
    __int16 v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "request start pipelined provider, we have %d clients, ProviderState::%s", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24));
    id v14 = sub_1001CA8D0([*(id *)(a1 + 8) state]);
    int v19 = 67109378;
    int v20 = v13;
    __int16 v21 = 2080;
    unint64_t v22 = v14;
    char v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startProviderImmediately(std::chrono::steady_clock::time_point)", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  unsigned int v7 = [*(id *)(a1 + 8) state];
  [*(id *)(a1 + 8) setState:2];
  if (!v7)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v10 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "was stopped, starting pipelined provider", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      LOWORD(v19) = 0;
      id v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startProviderImmediately(std::chrono::steady_clock::time_point)", "%s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
LABEL_23:
    id v11 = *(void **)(a1 + 8);
    v18[0] = 0;
    [v11 setLastIndoorError:v18];
    if (v18[0]) {
      v18[0] = 0;
    }
    sub_100134750(buf, "startprovider");
    sub_1001C7FDC(a1, 0, (uint64_t *)buf);
    if (v26 < 0) {
      operator delete(*(void **)buf);
    }
    sub_100134750(buf, "client/wake");
    sub_1001BDAFC(a1, a2, (char *)buf);
    goto LABEL_28;
  }
  if (v7 != 1)
  {
    if (v7 == 2)
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v8 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "ignoring request to start provider - already running", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        LOWORD(v19) = 0;
        id v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startProviderImmediately(std::chrono::steady_clock::time_point)", "%s\n", v9);
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
      return;
    }
    goto LABEL_23;
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v12 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "interrupting debounce - resuming provider", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    LOWORD(v19) = 0;
    id v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::startProviderImmediately(std::chrono::steady_clock::time_point)", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24));
  if (![*(id *)(a1 + 8) pipelinedSeeded])
  {
    sub_100134750(buf, "interrupting debounce");
    sub_1001C95FC(a1, (uint64_t *)buf);
LABEL_28:
    if (v26 < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_1001CA8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_1001CA8D0(unsigned int a1)
{
  if (a1 < 3) {
    return (&off_10229E1B8)[a1];
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  id v3 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    unsigned int v6 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Corrupt Run: got %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "const char *to_string(ProviderState)", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return "Unknown ProviderState";
}

uint64_t sub_1001CAA9C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)[*(id *)(a1 + 8) gpsAssistanceRequested];
  if (result != a2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109120;
      int v8 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "onGpsAssistanceRequest, %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onGpsAssistanceRequest(BOOL)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    [*(id *)(a1 + 8) setGpsAssistanceRequested:a2];
    uint64_t result = (uint64_t)[*(id *)(a1 + 8) gpsFusionRequested];
    if ((result & 1) == 0) {
      return (*(uint64_t (**)(void, id))(**(void **)(a1 + 24) + 192))(*(void *)(a1 + 24), [*(id *)(a1 + 8) gpsAssistanceRequested]);
    }
  }
  return result;
}

uint64_t sub_1001CACAC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)[*(id *)(a1 + 8) gpsFusionRequested];
  if (result != a2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67240192;
      int v8 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "onGpsFusionRequest, %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unsigned int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onGpsFusionRequest(BOOL)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    [*(id *)(a1 + 8) setGpsFusionRequested:a2];
    uint64_t result = (uint64_t)[*(id *)(a1 + 8) gpsAssistanceRequested];
    if ((result & 1) == 0) {
      return (*(uint64_t (**)(void, id))(**(void **)(a1 + 24) + 192))(*(void *)(a1 + 24), [*(id *)(a1 + 8) gpsFusionRequested]);
    }
  }
  return result;
}

void sub_1001CAEBC(uint64_t a1, uint64_t a2, void *a3)
{
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    if ([*(id *)(a1 + 8) pipelinedDidStartLocalizing])
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unsigned int v6 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "We got a pipelined error, but believe it's still running", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        unsigned int v7 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::afterIndoorError(std::chrono::steady_clock::time_point, NSError *)", "%s\n", v7);
        if (v7 != (char *)buf) {
          free(v7);
        }
      }
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 24);
      sub_100134750(buf, "pipeline error, seeded not started");
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 16))(v11, buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
      sub_100134750(buf, "afterError");
      sub_1001C7FDC(a1, 0, (uint64_t *)buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
    }
    sub_100134750(buf, "afterIndoorError");
    sub_1001C95FC(a1, (uint64_t *)buf);
    if (v18 < 0)
    {
      operator delete(*(void **)buf);
      if (a3) {
        goto LABEL_29;
      }
    }
    else if (a3)
    {
LABEL_29:
      unsigned int v12 = [a3 code];
LABEL_32:
      int v13 = *(void **)(a1 + 8);
      uint64_t v15 = a2;
      unsigned int v16 = v12;
      v14[0] = 1;
      [v13 setLastIndoorError:v14];
      return;
    }
    unsigned int v12 = -1;
    goto LABEL_32;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  sub_100134750(buf, "pipeline error, not seeded");
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 16))(v8, buf);
  if (v18 < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  id v9 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "We got a pipelined error after we decided to shut things down.", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::afterIndoorError(std::chrono::steady_clock::time_point, NSError *)", "%s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
}

void sub_1001CB2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CB30C(uint64_t a1)
{
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    id v2 = *(void **)(a1 + 8);
    v5[0] = 0;
    [v2 setLastIndoorError:v5];
    if (v5[0]) {
      v5[0] = 0;
    }
    [*(id *)(a1 + 8) setPipelinedDidStartLocalizing:1];
    sub_100134750(__p, "transient");
    sub_1001C7FDC(a1, 1, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    sub_100134750(__p, "onNoGoodIndoorEstimate_Transient");
    sub_1001C9FD4(a1, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v3 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "We got an update after we decided to shut things down.", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      int v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onNoGoodIndoorEstimate_Transient()", "%s\n", v4);
      if (v4 != (char *)__p) {
        free(v4);
      }
    }
  }
}

void sub_1001CB52C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CB554(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  sub_100134750(__p, "no yield");
  (*(void (**)(uint64_t, void **))(*(void *)v4 + 16))(v4, __p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  [*(id *)(a1 + 8) setPipelinedDidStartLocalizing:1];
  int v5 = *(void **)(a1 + 8);
  v10[0] = 0;
  [v5 setLastIndoorError:v10];
  if (v10[0]) {
    v10[0] = 0;
  }
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    sub_100134750(__p, "onNoGoodIndoorEstimate_Permanent");
    sub_1001C95FC(a1, (uint64_t *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    sub_100134750(__p, "outdoor");
    sub_1001C7FDC(a1, 2, (uint64_t *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    sub_100134750(__p, "CoarseIndoor says outdoor");
    sub_1001CB82C(a1, a2, (uint64_t *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unsigned int v6 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "We thought pipeline reported YIELD_FAILURE_GIVE_UP even though it is not seeded. This means we got an update after we decided to shut things down. ", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      char v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onNoGoodIndoorEstimate_Permanent(std::chrono::steady_clock::time_point)", "%s\n", v7);
      if (v7 != (char *)__p) {
        free(v7);
      }
    }
  }
}

void sub_1001CB7FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CB82C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v6 = [*(id *)(a1 + 8) pipelinedSeeded];
  if (v6 == 1)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v10 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a3 + 23) >= 0) {
        uint64_t v11 = a3;
      }
      else {
        uint64_t v11 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Shutdown not permitted by pipelined - ignoring: request to turn off due to %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 == -1) {
        goto LABEL_12;
      }
      goto LABEL_84;
    }
  }
  else if (v6)
  {
    unsigned int v12 = sub_1001C8710(a1, a2);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v13 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        id v14 = a3;
      }
      else {
        id v14 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v29 = 2082;
      char v30 = sub_1001D7CE4(v12);
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "@IndoorFlow, turnoff, %{public}s, %{public}s", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      sub_1001D7CE4(v12);
      __int16 v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v24);
      if (v24 != buf) {
        free(v24);
      }
    }
    if (v12)
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v15 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "@ClxIndoor, state, 0, required", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        __int16 v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v25);
        if (v25 != buf) {
          free(v25);
        }
      }
      if (sub_10016CCBC())
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        unsigned int v16 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "@ClxWifi2, state, 0, required", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          uint64_t v27 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v27);
          if (v27 != buf) {
            free(v27);
          }
        }
      }
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v17 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        if (*((char *)a3 + 23) >= 0) {
          char v18 = a3;
        }
        else {
          char v18 = (uint64_t *)*a3;
        }
        int v19 = sub_1001D7CE4(v12);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        __int16 v29 = 2080;
        char v30 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "%s - must stop indoor immediately (no debounce): %s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        sub_1001D7CE4(v12);
        char v26 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v26);
        if (v26 != buf) {
          free(v26);
        }
      }
      uint64_t v20 = *(void *)(a1 + 24);
      sub_100134750(buf, "stop required");
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v20 + 16))(v20, buf);
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1001C997C(a1);
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      __int16 v21 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        if (*((char *)a3 + 23) >= 0) {
          unint64_t v22 = a3;
        }
        else {
          unint64_t v22 = (uint64_t *)*a3;
        }
        id v23 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v22;
        __int16 v29 = 2080;
        char v30 = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "%s and %s; but no need to turn off at this time",
          buf,
          0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        char v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v9);
        goto LABEL_78;
      }
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    char v7 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a3 + 23) >= 0) {
        uint64_t v8 = a3;
      }
      else {
        uint64_t v8 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Not seeded - ignoring: request to turn off due to %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 == -1)
      {
LABEL_12:
        char v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::stopIndoorIfRequired(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v9);
LABEL_78:
        if (v9 != buf) {
          free(v9);
        }
        return;
      }
LABEL_84:
      dispatch_once(&qword_1024193A0, &stru_10229E160);
      goto LABEL_12;
    }
  }
}

void sub_1001CC2C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001CC2EC(uint64_t a1, NSObject *a2, _DWORD *a3)
{
  if (!*a3)
  {
    if ((*(int (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24)) < 1)
    {
      if (![*(id *)(a1 + 8) state]
        && ([*(id *)(a1 + 8) locationGroupsLoaded] & 1) == 0)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        int v5 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "No more clients but availability tiles still loaded - clearing", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          char v7 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "virtual BOOL CLIndoorLogic::registerForNotificationInternal(std::chrono::steady_clock::time_point, const CLLocationProvider_Type::Notification &)", "%s\n", v7);
          if (v7 != (char *)buf) {
            free(v7);
          }
        }
        [*(id *)(a1 + 8) clearLocationGroups];
      }
    }
    else
    {
      sub_1001CA1E4(a1, a2);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 24) + 208))(*(void *)(a1 + 24))) {
      sub_1001CACAC(a1, 1);
    }
  }
  return 1;
}

uint64_t sub_1001CC528(uint64_t a1)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24)))
  {
    id v3 = *(void **)(a1 + 8);
    id v2 = *(void **)(a1 + 16);
    uint64_t v4 = *(void *)(a1 + 24);
    unsigned int v5 = [v3 state];
    if (v5)
    {
      if (v5 == 2)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        char v9 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 200))(v4);
          *(_DWORD *)long long buf = 67109120;
          int v14 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "requesting provider to stop, clients = %d", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          (*(void (**)(uint64_t))(*(void *)v4 + 200))(v4);
          unsigned int v12 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void stopProviderRequest(CLIndoorState *, CLIndoorSettings *, CLIndoorLogicDelegate *)", "%s\n", v12);
          if (v12 != (char *)buf) {
            free(v12);
          }
        }
      }
      else if (v5 == 1)
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        unsigned int v6 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "ignoring request to stop - already stopping", buf, 2u);
        }
        if (!sub_10013D1A0(115, 2)) {
          goto LABEL_26;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 == -1) {
          goto LABEL_18;
        }
LABEL_34:
        dispatch_once(&qword_1024193A0, &stru_10229E160);
LABEL_18:
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void stopProviderRequest(CLIndoorState *, CLIndoorSettings *, CLIndoorLogicDelegate *)", "%s\n", v8);
        if (v8 != (char *)buf) {
          free(v8);
        }
        goto LABEL_26;
      }
      [v3 setState:1];
      [v2 debounceInterval];
      (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
LABEL_26:
      [*(id *)(a1 + 8) setLatestReason:0];
      goto LABEL_27;
    }
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    char v7 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "ignoring request to stop. already stopped", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 == -1) {
      goto LABEL_18;
    }
    goto LABEL_34;
  }
LABEL_27:
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 208))(*(void *)(a1 + 24)) & 1) == 0) {
    sub_1001CACAC(a1, 0);
  }
  return 1;
}

id sub_1001CCA08(uint64_t a1, NSObject *a2, void *a3)
{
  id v6 = *(id *)(a1 + 16);
  *(void *)(a1 + 16) = [objc_alloc((Class)CLIndoorSettings) initWithSettings:a3];
  if ((objc_msgSend(objc_msgSend(v6, "disabledVenues"), "isEqualToSet:", objc_msgSend(*(id *)(a1 + 16), "disabledVenues")) & 1) == 0)
  {
    [*(id *)(a1 + 8) clearLocationGroups];
    if ([*(id *)(a1 + 8) state] == 2
      && (*(unsigned int (**)(void))(**(void **)(a1 + 24) + 112))(*(void *)(a1 + 24)))
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      char v7 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        id v9 = [[[[[objc_msgSend(*(id *)(a1 + 16), "disabledVenues") description] componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] componentsJoinedByString:@"," UTF8String];
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = v8;
        __int16 v16 = 2082;
        id v17 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#Notice Reloading availability tiles (currently seeded = %{public}s). Set of disabled venues has changed to %{public}s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
        [(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([
        int v14 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::resetSettings(std::chrono::steady_clock::time_point, NSDictionary *)", "%s\n", v14);
        if (v14 != buf) {
          free(v14);
        }
      }
      sub_100134750(buf, "reset");
      sub_1001C7FDC(a1, 0, (uint64_t *)buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
      sub_100134750(buf, "settings reset, disabledVenues changed");
      sub_1001C95FC(a1, (uint64_t *)buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
      sub_100134750(buf, "settings reset, disabledVenues changed");
      sub_1001CD058(a1, (uint64_t)a2, buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
      sub_100134750(buf, "settings reset, disabledVenues changed");
      sub_100178250(a1, a2, (uint64_t *)buf);
      if (v18 < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      int v10 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = [[[[[objc_msgSend(*(id *)(a1 + 16), "disabledVenues"), "description") componentsSeparatedByCharactersInSet:+[NSCharacterSet whitespaceAndNewlineCharacterSet](NSCharacterSet, "whitespaceAndNewlineCharacterSet")] componentsJoinedByString:@","] UTF8String];
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Notice Set of disabled venues has changed to %{public}s.", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        [(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([(([
        int v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::resetSettings(std::chrono::steady_clock::time_point, NSDictionary *)", "%s\n", v13);
        if (v13 != buf) {
          free(v13);
        }
      }
    }
  }
  if (([*(id *)(a1 + 16) pipelinedEnabled] & 1) == 0)
  {
    sub_100134750(buf, "settings reset, pipelined disabled\n");
    sub_1001CB82C(a1, (uint64_t)a2, (uint64_t *)buf);
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if ([objc_msgSend(objc_msgSend(v6, "indoorAvailabilityTilesServerUrl"), "isEqualToString:", objc_msgSend(*(id *)(a1 + 16), "indoorAvailabilityTilesServerUrl")] == 0) {
  id result = [a3 objectForKeyedSubscript:off_102419730[0]];
  }
  if (result) {
    id result = [result BOOLValue];
  }
  *(unsigned char *)(a1 + 40) = (_BYTE)result;
  return result;
}

void sub_1001CD024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CD058(uint64_t a1, uint64_t a2, char *a3)
{
  id v6 = sub_1001C8F84(a1);
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  char v7 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    if (a3[23] >= 0) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = *(char **)a3;
    }
    id v9 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
    int v10 = sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
    *(_DWORD *)long long buf = 136446978;
    int v13 = v8;
    __int16 v14 = 2050;
    id v15 = v6;
    __int16 v16 = 2050;
    id v17 = v9;
    __int16 v18 = 2082;
    int v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "@IndoorAvl, load, %{public}s, %{public}lu, total, %{public}lu, state, %{public}s", buf, 0x2Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    [objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
    sub_1001C8388([*(id *)(a1 + 8) pipelinedSeeded]);
    id v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::loadAvailabilityTiles(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  sub_1001CE368(a1, a2, a3);
}

id sub_1001CD2D0(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 16) setTilePrefetchRelevancyWindow:a2];
}

void sub_1001CD2DC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  sub_100134750(__p, (char *)[objc_msgSend(*(id *)(a1 + 16), "indoorAvailabilityTilesServerUrl") UTF8String]);
  if ((v9 & 0x80u) == 0) {
    size_t v3 = v9;
  }
  else {
    size_t v3 = (size_t)__p[1];
  }
  uint64_t v4 = &v7;
  sub_1001110E4((uint64_t)&v7, v3 + 1);
  if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v4 = (std::string *)v7.__r_.__value_.__r.__words[0];
  }
  if (v3)
  {
    if ((v9 & 0x80u) == 0) {
      unsigned int v5 = __p;
    }
    else {
      unsigned int v5 = (void **)__p[0];
    }
    memmove(v4, v5, v3);
  }
  *(_WORD *)((char *)&v4->__r_.__value_.__l.__data_ + v3) = 47;
  id v6 = std::string::append(&v7, "availability.pb.gz");
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1001CD3D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CD404(std::string *a1@<X8>)
{
  sub_100134750(&v8, "/");
  sub_100134750(__p, "availability.pb");
  sub_1001D68B4();
  std::operator+<char>();
  if ((v7 & 0x80u) == 0) {
    id v2 = __p;
  }
  else {
    id v2 = (void **)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    std::string::size_type v3 = v7;
  }
  else {
    std::string::size_type v3 = (std::string::size_type)__p[1];
  }
  uint64_t v4 = std::string::append(&v5, (const std::string::value_type *)v2, v3);
  *a1 = *v4;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
}

void sub_1001CD4C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 - 17) < 0) {
    operator delete(*(void **)(v21 - 40));
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CD514(std::string *a1@<X8>)
{
  sub_100134750(&v8, "/");
  sub_100134750(__p, "availability.pb.gz");
  sub_1001D68B4();
  std::operator+<char>();
  if ((v7 & 0x80u) == 0) {
    id v2 = __p;
  }
  else {
    id v2 = (void **)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    std::string::size_type v3 = v7;
  }
  else {
    std::string::size_type v3 = (std::string::size_type)__p[1];
  }
  uint64_t v4 = std::string::append(&v5, (const std::string::value_type *)v2, v3);
  *a1 = *v4;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
}

void sub_1001CD5D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 - 17) < 0) {
    operator delete(*(void **)(v21 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001CD624()
{
  return 60;
}

uint64_t sub_1001CD62C()
{
  return 168;
}

uint64_t sub_1001CD634()
{
  return 24;
}

id sub_1001CD63C(uint64_t a1)
{
  return _[*(id *)(a1 + 16) tilePrefetchActivityInterval];
}

uint64_t sub_1001CD644(uint64_t a1)
{
  unint64_t v2 = (unint64_t)[*(id *)(a1 + 16) tilePrefetchPredictionActivityCycleAllowance];
  char v3 = v2;
  unint64_t v4 = HIDWORD(v2);
  LODWORD(result) = [*(id *)(a1 + 8) tilePrefetchPredictionActivityCycleAllowance];
  if (v3) {
    return v4;
  }
  else {
    return result;
  }
}

void sub_1001CD68C(uint64_t a1)
{
  [*(id *)(a1 + 8) setPipelinedVenues:0];
  sub_100134750(__p, "killdaemon");
  sub_1001C7FDC(a1, 0, (uint64_t *)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  sub_1001CAA9C(a1, 0);
  if ([*(id *)(a1 + 8) state] == 2)
  {
    sub_100134750(__p, "pipelined killed");
    sub_1001C95FC(a1, (uint64_t *)__p);
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1001CD738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1001CD758(uint64_t a1)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unint64_t v2 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Clearing cached last fix", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::clearLocationData()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  uint64_t result = [*(id *)(a1 + 8) latestPosition];
  if (*result) {
    *uint64_t result = 0;
  }
  return result;
}

id sub_1001CD904(uint64_t a1)
{
  id result = [*(id *)(a1 + 8) state];
  if (!result) {
    return result;
  }
  if (result == 2)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "stopping immediately", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_16;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 == -1) {
      goto LABEL_40;
    }
    goto LABEL_42;
  }
  if (result != 1) {
    goto LABEL_16;
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  char v3 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "stop while stopping - likely debounce expired", buf, 2u);
  }
  if (!sub_10013D1A0(115, 2)) {
    goto LABEL_16;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1024193A0 != -1) {
LABEL_42:
  }
    dispatch_once(&qword_1024193A0, &stru_10229E160);
LABEL_40:
  char v9 = (char *)_os_log_send_and_compose_impl();
  sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::requestStopProviderImmediately()", "%s\n", v9);
  if (v9 != (char *)buf) {
    free(v9);
  }
LABEL_16:
  [*(id *)(a1 + 8) setState:0];
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  std::string v5 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "@ClxIndoor, state, 0, request", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unsigned __int8 v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::requestStopProviderImmediately()", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  if (sub_10016CCBC())
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v6 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "@ClxWifi2, state, 0, request", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::requestStopProviderImmediately()", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
  sub_100134750(buf, "PROVIDER shutting down");
  sub_1001C9FD4(a1, (uint64_t *)buf);
  if (v11 < 0) {
    operator delete(*(void **)buf);
  }
  return [*(id *)(a1 + 8) clearLocationGroups];
}

void sub_1001CDE8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001CDEB0(uint64_t a1, NSObject *a2, CLMotionActivity *a3)
{
  [*(id *)(a1 + 8) latestNavModeEstimate];
  int v7 = v6;
  uint64_t v8 = sub_1004B6360((uint64_t)[*(id *)(a1 + 8) navModeEstimator], (uint64_t)a3);
  [*(id *)(a1 + 8) setLatestNavModeEstimate:v8, v9];
  [*(id *)(a1 + 8) latestNavModeEstimate];
  int v11 = v10;
  if (v7 != v10)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unsigned int v12 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67174657;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "updateLatestMotionActivity state,%{private}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      __int16 v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::updateLatestMotionActivity(std::chrono::steady_clock::time_point, const CLMotionActivity &)", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    unsigned int v13 = [*(id *)(a1 + 8) pipelinedSeeded];
    if (v11 == 2)
    {
      if (v13)
      {
        sub_100134750(buf, "motion");
        sub_1001C7FDC(a1, 2, (uint64_t *)buf);
        if (v16 < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
  }
  sub_1001DB9BC((uint64_t)[*(id *)(a1 + 8) fitnessModeStateMachine], a3, (uint64_t)a2);
  sub_100134750(buf, "updateLatestMotionActivity");
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v16 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001CE134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NSURL *sub_1001CE15C()
{
  uint64_t v0 = sub_1001D68B4();
  id v1 = +[NSString stringWithUTF8String:v0];
  if (!v1)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v2 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      int v6 = v0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "availabilityDir_nsstr is nil which will cause a NSInvalidArgumentException due to -[NSURL initFileURLWithPath:isDirectory:]: nil string parameter;  availabiltyDir_cstr = %{public}s",
        buf,
        0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "static NSURL *CLIndoorLogic::getPathToAvailabilityTile()", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  return +[NSURL URLWithString:relativeToURL:](NSURL, "URLWithString:relativeToURL:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "availability.pb"), +[NSURL fileURLWithPath:v1 isDirectory:1]);
}

void sub_1001CE368(uint64_t a1, uint64_t a2, char *a3)
{
  if ([*(id *)(a1 + 8) state] == 2)
  {
    if (*(unsigned char *)[*(id *)(a1 + 8) latestPosition])
    {
      int v6 = [*(id *)(a1 + 8) latestPosition];
      if (!*v6) {
        sub_101A503C0();
      }
      if (sub_1001DC488((uint64_t)(v6 + 8), a2))
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        int v7 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          if (a3[23] >= 0) {
            uint64_t v8 = a3;
          }
          else {
            uint64_t v8 = *(char **)a3;
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v68 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "latest position is stale - skipping pipelined venue availability update, after %s", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          if (a3[23] >= 0) {
            uint64_t v9 = a3;
          }
          else {
            uint64_t v9 = *(char **)a3;
          }
          __dst[0] = 136315138;
          *(void *)&__dst[1] = v9;
LABEL_47:
          unsigned int v13 = (uint8_t *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::updateNearbyVenues(std::chrono::steady_clock::time_point, const std::string &)", "%s\n");
LABEL_48:
          if (v13 != buf) {
            free(v13);
          }
        }
      }
      else if (![*(id *)(a1 + 8) pipelinedSeeded])
      {
        id v17 = (char *)[*(id *)(a1 + 8) latestPosition];
        if (!*v17) {
          sub_101A503EC();
        }
        uint64_t v18 = *(void *)(v17 + 28);
        uint64_t v19 = *((void *)v17 + 12);
        *(_OWORD *)int v53 = *(_OWORD *)(v17 + 104);
        *(_DWORD *)&v53[16] = *((_DWORD *)v17 + 30);
        long long v52 = *(_OWORD *)&v53[4];
        long long v49 = *(_OWORD *)&v53[4];
        uint64_t v50 = v18;
        uint64_t v51 = v19;
        memcpy(__dst, &unk_101D216A0, sizeof(__dst));
        id v20 = [objc_alloc((Class)CLGpsPosition) initWithLocation:v48 andPrivateLocation:__dst];
        v45[0] = 0;
        id v46 = 0;
        char v47 = 0;
        v45[0] = [*(id *)(a1 + 16) forcedVenues];
        [*(id *)(a1 + 16) venueGroupDistance];
        v45[1] = v21;
        id v46 = [*(id *)(a1 + 16) fakeLastFix];
        char v47 = sub_10016CCBC();
        id v22 = [*(id *)(a1 + 8) locationGroups];
        [*(id *)(a1 + 8) availabilityZScoreConfidenceInterval];
        [*(id *)(a1 + 8) setPipelinedVenues:+[CLIndoorCommonHooks nearestVenues:availableVenues:latestPosition:availabilityZScoreConfidenceInterval:settings:isAllowedMultipleVenues:](CLIndoorCommonHooks, "nearestVenues:availableVenues:latestPosition:availabilityZScoreConfidenceInterval:settings:isAllowedMultipleVenues:", a2, v22, v20, v45, 1)];

        if ([*(id *)(a1 + 8) locationGroupsLoaded])
        {
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          id v23 = qword_1024193A8;
          if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
          {
            __int16 v24 = (char *)[[*(id *)(a1 + 8) pipelinedVenues] count];
            id v25 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
            char v26 = (char *)[*(id *)(a1 + 8) latestPosition];
            if (!*v26) {
              sub_101A503C0();
            }
            uint64_t v27 = *(void *)(v26 + 108);
            double v28 = (char *)[*(id *)(a1 + 8) latestPosition];
            if (!*v28) {
              sub_101A503C0();
            }
            uint64_t v29 = *(void *)(v28 + 116);
            int v30 = sub_10016CCBC();
            if (a3[23] >= 0) {
              char v31 = a3;
            }
            else {
              char v31 = *(char **)a3;
            }
            *(_DWORD *)long long buf = 134350339;
            uint64_t v68 = v24;
            __int16 v69 = 2050;
            id v70 = v25;
            __int16 v71 = 2049;
            uint64_t v72 = v27;
            __int16 v73 = 2049;
            uint64_t v74 = v29;
            __int16 v75 = 1026;
            int v76 = v30;
            __int16 v77 = 2081;
            uint64_t v78 = v31;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "selected %{public}zu out of %{public}lu candidates near lat,lng = %{private}lf,%{private}lf, wifi2enabled = %{public}d, because %{private}s", buf, 0x3Au);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            id v32 = [[objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues") count];
            id v33 = [[objc_msgSend(*(id *)(a1 + 8), "locationGroups") count];
            uint64_t v34 = (char *)[*(id *)(a1 + 8) latestPosition];
            if (!*v34) {
              sub_101A503C0();
            }
            uint64_t v35 = *(void *)(v34 + 108);
            char v36 = (char *)[*(id *)(a1 + 8) latestPosition];
            if (!*v36) {
              sub_101A503C0();
            }
            uint64_t v37 = *(void *)(v36 + 116);
            int v38 = sub_10016CCBC();
            if (a3[23] >= 0) {
              __int16 v39 = a3;
            }
            else {
              __int16 v39 = *(char **)a3;
            }
            int v54 = 134350339;
            id v55 = v32;
            __int16 v56 = 2050;
            id v57 = v33;
            __int16 v58 = 2049;
            uint64_t v59 = v35;
            __int16 v60 = 2049;
            uint64_t v61 = v37;
            __int16 v62 = 1026;
            int v63 = v38;
            __int16 v64 = 2081;
            __int16 v65 = v39;
            int v40 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::updateNearbyVenues(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v40);
            if (v40 != (char *)buf) {
              free(v40);
            }
          }
        }
        else
        {
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          BOOL v41 = qword_1024193A8;
          if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#Warning Why are we calling updateNearbyVenues but availability tiles are not loaded?", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            LOWORD(v54) = 0;
            __int16 v43 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::updateNearbyVenues(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v43);
            if (v43 != (char *)buf) {
              free(v43);
            }
          }
        }
        if (!objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "count")
          && ((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))(*(void *)(a1 + 24)) & 1) == 0)
        {
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          char v42 = qword_1024193A8;
          if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "No venues to use for pipelined - disconnecting", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            LOWORD(v54) = 0;
            BOOL v44 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::updateNearbyVenues(std::chrono::steady_clock::time_point, const std::string &)", "%s\n", v44);
            if (v44 != (char *)buf) {
              free(v44);
            }
          }
          (*(void (**)(void))(**(void **)(a1 + 24) + 168))(*(void *)(a1 + 24));
        }
      }
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      __int16 v14 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        if (a3[23] >= 0) {
          id v15 = a3;
        }
        else {
          id v15 = *(char **)a3;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v68 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "no position yet to update venue availability with, after %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        if (a3[23] >= 0) {
          char v16 = a3;
        }
        else {
          char v16 = *(char **)a3;
        }
        __dst[0] = 136315138;
        *(void *)&__dst[1] = v16;
        goto LABEL_47;
      }
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v10 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] >= 0) {
        int v11 = a3;
      }
      else {
        int v11 = *(char **)a3;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v68 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Attempt to update venue availability because %{public}s; but not running",
        buf,
        0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      if (a3[23] >= 0) {
        unsigned int v12 = a3;
      }
      else {
        unsigned int v12 = *(char **)a3;
      }
      __dst[0] = 136446210;
      *(void *)&__dst[1] = v12;
      unsigned int v13 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLIndoorLogic::updateNearbyVenues(std::chrono::steady_clock::time_point, const std::string &)", "%s\n");
      goto LABEL_48;
    }
  }
}

uint64_t sub_1001CEE50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(void **)(a1 + 8);
  v14[0] = 0;
  [v7 setLastIndoorError:v14];
  if (v14[0]) {
    v14[0] = 0;
  }
  sub_1001CAA9C(a1, a4);
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    sub_100134750(__p, "pipelined YIELD OK");
    sub_1001C9FD4(a1, (uint64_t *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    sub_100134750(__p, "pipelineyeild");
    sub_1001C7FDC(a1, 1, (uint64_t *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#Warning We thought pipeline couldn't figure out it's position but it did. This means we got an update after we decided to shut things down. ", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      int v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onUpdateFromPipeline(std::chrono::steady_clock::time_point, const CLLocationProvider_Type::NotificationData &, BOOL)", "%s\n", v11);
      if (v11 != (char *)__p) {
        free(v11);
      }
    }
  }
  [*(id *)(a1 + 8) setPipelinedDidStartLocalizing:1];
  uint64_t v9 = *(void *)(a1 + 24);
  LODWORD(__p[0]) = 0;
  return (*(uint64_t (**)(uint64_t, void **, uint64_t, void, uint64_t, void))(*(void *)v9 + 184))(v9, __p, a3, 0, 0xFFFFFFFFLL, 0);
}

void sub_1001CF0CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1001CF0F4(uint64_t a1)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unint64_t v2 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "kNotificationSleep - stopLocationImmediately()", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onStatusNotification_Sleep(int, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return sub_1001CD904(a1);
}

void sub_1001CF290(uint64_t a1, NSObject *a2)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unint64_t v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "kNotificationWake - startProvider()", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    int v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onStatusNotification_Wake(std::chrono::steady_clock::time_point, int, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  [*(id *)(a1 + 8) resetNavModeEstimator];
  if ((*(int (**)(void))(**(void **)(a1 + 24) + 200))(*(void *)(a1 + 24)) >= 1)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    std::string v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Start location in wake notification", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onStatusNotification_Wake(std::chrono::steady_clock::time_point, int, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    sub_1001CA1E4(a1, a2);
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "kNotificationWake - startProvider() done", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onStatusNotification_Wake(std::chrono::steady_clock::time_point, int, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
}

void sub_1001CF6C4(uint64_t a1, NSObject *a2, uint64_t *a3, uint64_t *a4, int a5)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v10 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v11 = [*(id *)(a1 + 8) state];
    *(_DWORD *)long long buf = 67240448;
    *(_DWORD *)&uint8_t buf[4] = a5;
    *(_WORD *)&uint8_t buf[8] = 1026;
    *(_DWORD *)&buf[10] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "@IndoorAvl, update, %{public}d, state, %{public}d", buf, 0xEu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    [*(id *)(a1 + 8) state];
    id v23 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onAvlFileUpdated(std::chrono::steady_clock::time_point, std::string, std::string, CLFileUpdate::UpdateStatus)", "%s\n", v23);
    if (v23 != buf) {
      free(v23);
    }
  }
  switch(a5)
  {
    case 0:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unsigned int v12 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        char v13 = a3;
        if (*((char *)a3 + 23) < 0) {
          char v13 = (uint64_t *)*a3;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#Warning Got status update none from: %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          goto LABEL_68;
        }
        goto LABEL_66;
      }
      break;
    case 1:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      __int16 v14 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        id v15 = a3;
        if (*((char *)a3 + 23) < 0) {
          id v15 = (uint64_t *)*a3;
        }
        char v16 = a4;
        if (*((char *)a4 + 23) < 0) {
          char v16 = (uint64_t *)*a4;
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v15;
        *(_WORD *)&unsigned char buf[12] = 2080;
        uint64_t v27 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Started downloading %s to %s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          goto LABEL_68;
        }
        goto LABEL_66;
      }
      break;
    case 2:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v17 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = a4;
        if (*((char *)a4 + 23) < 0) {
          uint64_t v18 = (uint64_t *)*a4;
        }
        *(_DWORD *)long long buf = 136380675;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Downloaded availability tile to %{private}s - decompressing", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        __int16 v24 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onAvlFileUpdated(std::chrono::steady_clock::time_point, std::string, std::string, CLFileUpdate::UpdateStatus)", "%s\n", v24);
        if (v24 != buf) {
          free(v24);
        }
      }
      [*(id *)(a1 + 8) clearLocationGroups];
      if ([*(id *)(a1 + 8) state])
      {
        sub_100134750(buf, "onAvlFileUpdated CLFileUpdate::kUpdateStatusCompleted");
        sub_1001CD058(a1, (uint64_t)a2, buf);
        if (v28 < 0) {
          operator delete(*(void **)buf);
        }
        if ([*(id *)(a1 + 8) state] == 2)
        {
          sub_100134750(buf, "onAvlFileUpdateStatusCompleted");
          sub_100178250(a1, a2, (uint64_t *)buf);
          if (v28 < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
      else
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        id v22 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "Don't need to reload availability tile - not running", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            goto LABEL_68;
          }
          goto LABEL_66;
        }
      }
      break;
    case 3:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v19 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        id v20 = a3;
        if (*((char *)a3 + 23) < 0) {
          id v20 = (uint64_t *)*a3;
        }
        uint64_t v21 = a4;
        if (*((char *)a4 + 23) < 0) {
          uint64_t v21 = (uint64_t *)*a4;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = v20;
        *(_WORD *)&unsigned char buf[12] = 2082;
        uint64_t v27 = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#Warning Failed to download %{public}s to %{public}s", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
LABEL_68:
        }
          dispatch_once(&qword_1024193A0, &stru_10229E160);
LABEL_66:
        id v25 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onAvlFileUpdated(std::chrono::steady_clock::time_point, std::string, std::string, CLFileUpdate::UpdateStatus)", "%s\n", v25);
        if (v25 != buf) {
          free(v25);
        }
      }
      break;
    default:
      return;
  }
}

void sub_1001D0044(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D007C(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "WiFi power state changed to %d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::setWifiPowered(std::chrono::steady_clock::time_point, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  [*(id *)(a1 + 8) setWifiPowered:a3];
  if (a3) {
    int v7 = "setWifiPowered:ON";
  }
  else {
    int v7 = "setWifiPowered:OFF";
  }
  sub_100134750(buf, v7);
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D0284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D02A8(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "WiFi association state changed to %d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::setWifiAssociated(std::chrono::steady_clock::time_point, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  [*(id *)(a1 + 8) setWifiAssociated:a3];
  if (a3) {
    int v7 = "setWifiAssociated:ON";
  }
  else {
    int v7 = "setWifiAssociated:OFF";
  }
  sub_100134750(buf, v7);
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D04B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D04D4(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Streaming Client in fitness session changed to %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::setStreamingClientInFitnessSession(std::chrono::steady_clock::time_point, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  [*(id *)(a1 + 8) setIsStreamingClientInFitnessSession:a3];
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    if (a3)
    {
      sub_100134750(buf, "streaming");
      sub_1001C7FDC(a1, 2, (uint64_t *)buf);
      if (v10 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  if (a3) {
    int v7 = "setInFitnessSession:ON";
  }
  else {
    int v7 = "setInFitnessSession:OFF";
  }
  sub_100134750(buf, v7);
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D0720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D0748(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Vehicle connection changed to %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::setVehicleConnected(std::chrono::steady_clock::time_point, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  [*(id *)(a1 + 8) setIsVehicleConnected:a3];
  if ([*(id *)(a1 + 8) pipelinedSeeded] && a3)
  {
    if (*(unsigned char *)(a1 + 40))
    {
      sub_100134750(buf, "vehicleconnect");
      sub_1001C7FDC(a1, 1, (uint64_t *)buf);
    }
    else
    {
      sub_100134750(buf, "vehicleconnect");
      sub_1001C7FDC(a1, 2, (uint64_t *)buf);
    }
    if (v10 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (a3) {
    int v7 = "setVehicleConnected:ON";
  }
  else {
    int v7 = "setVehicleConnected:OFF";
  }
  sub_100134750(buf, v7);
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D09C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D09EC(uint64_t a1, NSObject *a2, int a3)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  int v6 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Vehicle navigation mode changed to %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLIndoorLogic::setVehicleNavigation(std::chrono::steady_clock::time_point, BOOL)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  if ([*(id *)(a1 + 8) pipelinedSeeded] && a3)
  {
    if (*(unsigned char *)(a1 + 40))
    {
      sub_100134750(buf, "vehiclenav");
      sub_1001C7FDC(a1, 1, (uint64_t *)buf);
    }
    else
    {
      sub_100134750(buf, "vehiclenav");
      sub_1001C7FDC(a1, 2, (uint64_t *)buf);
    }
    if (v10 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (a3) {
    int v7 = "setVehicleNavigation:ON";
  }
  else {
    int v7 = "setVehicleNavigation:OFF";
  }
  sub_100134750(buf, v7);
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D0C54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D0C80(uint64_t a1, NSObject *a2)
{
  (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
  if (([*(id *)(a1 + 8) isInVehicleNavigation] & 1) == 0)
  {
    [*(id *)(a1 + 8) setIsInVehicleNavigation:1];
    sub_1001D09EC(a1, a2, 1);
  }
}

void sub_1001D0D0C(uint64_t a1, NSObject *a2)
{
  [*(id *)(a1 + 8) setIsInVehicleNavigation:0];

  sub_1001D09EC(a1, a2, 0);
}

void sub_1001D0D58(uint64_t a1, NSObject *a2)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unint64_t v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "New pipelined client", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    std::string v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onClientAddition(std::chrono::steady_clock::time_point)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 24) + 208))(*(void *)(a1 + 24))) {
    sub_1001CACAC(a1, 1);
  }
  sub_100134750(buf, "onClientAddition");
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v7 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D0F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D0F7C(uint64_t a1, NSObject *a2)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  unint64_t v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Removed pipelined client", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    std::string v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onClientRemoval(std::chrono::steady_clock::time_point)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 208))(*(void *)(a1 + 24)) & 1) == 0) {
    sub_1001CACAC(a1, 0);
  }
  sub_100134750(buf, "onClientRemoval");
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v7 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D117C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D11A0(uint64_t a1, NSObject *a2)
{
  if (([*(id *)(a1 + 8) hasAtLeastOneClientWithCLActivityTypeFitness] & 1) == 0)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "At least 1 client using a fitness CLActivityType", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      std::string v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onAtLeastOneClientHasCLActivityTypeFitness(std::chrono::steady_clock::time_point)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  [*(id *)(a1 + 8) setHasAtLeastOneClientWithCLActivityTypeFitness:1];
  if ([*(id *)(a1 + 8) pipelinedSeeded])
  {
    sub_100134750(buf, "fitness");
    sub_1001C7FDC(a1, 2, (uint64_t *)buf);
    if (v7 < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_100134750(buf, "onAtLeastOneClientHasCLActivityTypeFitness");
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v7 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D13C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D13E8(uint64_t a1, NSObject *a2)
{
  if ([*(id *)(a1 + 8) hasAtLeastOneClientWithCLActivityTypeFitness])
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v4 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "no clients using a fitness CLActivityType", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      std::string v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onNoClientsHaveCLActivityTypeFitness(std::chrono::steady_clock::time_point)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  [*(id *)(a1 + 8) setHasAtLeastOneClientWithCLActivityTypeFitness:0];
  sub_100134750(buf, "onNoClientsHaveCLActivityTypeFitness");
  sub_100178250(a1, a2, (uint64_t *)buf);
  if (v7 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1001D15C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1001D15EC(uint64_t a1)
{
  [*(id *)(a1 + 8) setLastARSessionState:];
  id result = [*(id *)(a1 + 8) pipelinedSeeded];
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    id v4 = [*(id *)(a1 + 8) lastARSessionState];
    std::string v5 = *(uint64_t (**)(uint64_t, id))(*(void *)v3 + 128);
    return (id)v5(v3, v4);
  }
  return result;
}

id sub_1001D1670(uint64_t a1)
{
  id result = [*(id *)(a1 + 8) pipelinedSeeded];
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 136);
    return (id)v3();
  }
  return result;
}

id sub_1001D16E4(uint64_t a1)
{
  id result = [*(id *)(a1 + 8) pipelinedSeeded];
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 144);
    return (id)v3();
  }
  return result;
}

void sub_1001D1758(uint64_t a1)
{
  if ([*(id *)(a1 + 8) state] == 1)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    unint64_t v2 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "debounce timer triggered", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      std::string v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onDebounceHandler()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    sub_1001CD904(a1);
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v3 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v4 = [*(id *)(a1 + 8) state];
      *(_DWORD *)long long buf = 67109120;
      unsigned int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Ignoring debounce timer trigger - pipelined is currently in state %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      [*(id *)(a1 + 8) state];
      int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onDebounceHandler()", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

BOOL sub_1001D1A5C(uint64_t a1)
{
  if (!*(unsigned char *)[*(id *)(a1 + 8) lastIndoorError]) {
    return 0;
  }
  unint64_t v2 = [*(id *)(a1 + 8) lastIndoorError];
  if (!*(unsigned char *)v2) {
    sub_101A503C0();
  }
  return v2[4] == 4;
}

void sub_1001D1AB4(uint64_t *a1@<X0>, void *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int8 *a5@<X4>, uint64_t a6@<X5>, std::string *a7@<X8>, double a8@<D0>, double a9@<D1>)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  __int16 v14 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134349824;
    *(double *)&uint8_t buf[4] = a8;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&unsigned char buf[14] = a3;
    *(_WORD *)&buf[22] = 2050;
    *(double *)&unsigned char buf[24] = a9;
    *(_WORD *)&unsigned char buf[32] = 1026;
    *(_DWORD *)&buf[34] = (int)((double)a4 / 86400.0);
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SelectIndoor, params, radius, %{public}lf ,maxFloors, %{public}zu, clusterRadius, %{public}lf, loiMaxAge, %{public}d", buf, 0x26u);
  }
  uint64_t v174 = a4;
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    *(_DWORD *)uint64_t v209 = 134349824;
    *(double *)&v209[4] = a8;
    *(_WORD *)&v209[12] = 2050;
    *(void *)&v209[14] = a3;
    *(_WORD *)&v209[22] = 2050;
    *(double *)&v209[24] = a9;
    *(_WORD *)int v210 = 1026;
    *(_DWORD *)&v210[2] = (int)((double)a4 / 86400.0);
    __int16 v155 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v155);
    if (v155 != buf) {
      free(v155);
    }
  }
  double v202 = 0;
  double v202 = +[NSMutableArray arrayWithCapacity:0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3)];
  double v201 = 0;
  double v201 = +[NSMutableArray arrayWithCapacity:0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3)];
  v200[0] = &v202;
  v200[1] = &v201;
  *(double *)&v200[2] = a9;
  uint64_t v15 = *a1;
  if (a1[1] != *a1)
  {
    uint64_t v16 = a1[1] - 72;
    do
    {
      double v17 = *(double *)(v16 + 16);
      if (v17 <= a9)
      {
        long long v219 = *(_OWORD *)v16;
        double v220 = v17;
        uint64_t v221 = *(void *)(v16 + 24);
        char v222 = 0;
        if (*(unsigned char *)(v16 + 32))
        {
          uint64_t v223 = *(void *)(v16 + 40);
          char v222 = 1;
        }
        char v224 = 0;
        if (*(unsigned char *)(v16 + 48))
        {
          uint64_t v225 = *(void *)(v16 + 56);
          char v224 = 1;
        }
        int v226 = *(_DWORD *)(v16 + 64);
        char v227 = *(unsigned char *)(v16 + 68);
        sub_1001D3F7C((uint64_t)v200, (uint64_t *)&v219);
        if (v224) {
          char v224 = 0;
        }
        if (v222) {
          char v222 = 0;
        }
      }
      else
      {
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        uint64_t v18 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = *(void *)v16;
          uint64_t v20 = *(void *)(v16 + 8);
          *(_DWORD *)long long buf = 134283777;
          *(void *)&uint8_t buf[4] = v19;
          *(_WORD *)&unsigned char buf[12] = 2049;
          *(void *)&unsigned char buf[14] = v20;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "SelectIndoor, loi, skipradius, %{private}.7f, %{private}.7f", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          uint64_t v21 = *(void *)v16;
          uint64_t v22 = *(void *)(v16 + 8);
          *(_DWORD *)uint64_t v209 = 134283777;
          *(void *)&v209[4] = v21;
          *(_WORD *)&v209[12] = 2049;
          *(void *)&v209[14] = v22;
          id v23 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v23);
          if (v23 != buf) {
            free(v23);
          }
        }
      }
      BOOL v24 = v16 == v15;
      v16 -= 72;
    }
    while (!v24);
  }
  if (*a5)
  {
    uint64_t v25 = *(void *)(a5 + 108);
    uint64_t v26 = *(void *)(a5 + 116);
    uint64_t v27 = *(void *)(a5 + 28);
    uint64_t v28 = sub_1001DC498((uint64_t)(a5 + 8));
    v213[0] = v25;
    v213[1] = v26;
    v213[2] = v27;
    v213[3] = 0x3FF0000000000000;
    uint64_t v215 = v28;
    char v214 = 1;
    char v216 = 0;
    int v217 = 1;
    char v218 = 0;
    sub_1001D3F7C((uint64_t)v200, v213);
    if (v216) {
      char v216 = 0;
    }
    if (v214) {
      char v214 = 0;
    }
  }
  uint64_t v29 = (char *)[(NSMutableArray *)v202 count];
  int v30 = +[NSMutableArray arrayWithCapacity:&v29[(void)[(NSMutableArray *)v201 count]]];
  [(NSMutableArray *)v30 addObjectsFromArray:v202];
  [(NSMutableArray *)v30 addObjectsFromArray:v201];
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  char v31 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    id v32 = [(NSMutableArray *)v30 count];
    uint64_t v34 = *a1;
    uint64_t v33 = a1[1];
    id v35 = [(NSMutableArray *)v201 count];
    id v36 = [(NSMutableArray *)v202 count];
    int v37 = *a5;
    *(_DWORD *)long long buf = 134350080;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&unsigned char buf[14] = 0x8E38E38E38E38E39 * ((v33 - v34) >> 3);
    *(_WORD *)&buf[22] = 2050;
    *(void *)&unsigned char buf[24] = v35;
    *(_WORD *)&unsigned char buf[32] = 2050;
    *(void *)&buf[34] = v36;
    __int16 v229 = 1026;
    int v230 = v37;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "SelectIndoor, clusters, %{public}ld, LOIs, %{public}ld, historical, %{public}ld, predicted, %{public}ld, lastFix, %{public}d", buf, 0x30u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v156 = [(NSMutableArray *)v30 count];
    uint64_t v158 = *a1;
    uint64_t v157 = a1[1];
    id v159 = [(NSMutableArray *)v201 count];
    id v160 = [(NSMutableArray *)v202 count];
    int v161 = *a5;
    *(_DWORD *)uint64_t v209 = 134350080;
    *(void *)&v209[4] = v156;
    *(_WORD *)&v209[12] = 2050;
    *(void *)&v209[14] = 0x8E38E38E38E38E39 * ((v157 - v158) >> 3);
    *(_WORD *)&v209[22] = 2050;
    *(void *)&v209[24] = v159;
    *(_WORD *)int v210 = 2050;
    *(void *)&v210[2] = v160;
    __int16 v211 = 1026;
    int v212 = v161;
    float64x2_t v162 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v162);
    if (v162 != buf) {
      free(v162);
    }
  }
  int v38 = +[NSMutableArray arrayWithCapacity:[(NSMutableArray *)v30 count]];
  long long v198 = 0u;
  long long v199 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  id v39 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v196 objects:v208 count:16];
  if (v39)
  {
    uint64_t v40 = 1000000 * v174;
    uint64_t v41 = *(void *)v197;
    do
    {
      char v42 = 0;
      do
      {
        if (*(void *)v197 != v41) {
          objc_enumerationMutation(v30);
        }
        __int16 v43 = *(void **)(*((void *)&v196 + 1) + 8 * (void)v42);
        uint64_t v44 = a6 - (void)[v43 relevancy:a6];
        if (v40 < v44) {
          [(NSMutableArray *)v38 addObject:v43];
        }
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        __int16 v45 = qword_1024193A8;
        if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
        {
          [objc_msgSend(v43, "latlon") latitude];
          uint64_t v47 = v46;
          [objc_msgSend(v43, "latlon") longitude];
          *(_DWORD *)long long buf = 134284033;
          *(void *)&uint8_t buf[4] = v47;
          *(_WORD *)&unsigned char buf[12] = 2049;
          *(void *)&unsigned char buf[14] = v48;
          *(_WORD *)&buf[22] = 1026;
          *(_DWORD *)&unsigned char buf[24] = v40 >= v44;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "SelectIndoor, cluster, %{private}.7f, %{private}.7f, relevant, %{public}d", buf, 0x1Cu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          [objc_msgSend(v43, "latlon") latitude];
          uint64_t v50 = v49;
          [objc_msgSend(v43, "latlon") longitude];
          *(_DWORD *)uint64_t v209 = 134284033;
          *(void *)&v209[4] = v50;
          *(_WORD *)&v209[12] = 2049;
          *(void *)&v209[14] = v51;
          *(_WORD *)&v209[22] = 1026;
          *(_DWORD *)&v209[24] = v40 >= v44;
          long long v52 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v52);
          if (v52 != buf) {
            free(v52);
          }
        }
        char v42 = (char *)v42 + 1;
      }
      while (v39 != v42);
      id v53 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v196 objects:v208 count:16];
      id v39 = v53;
    }
    while (v53);
  }
  [(NSMutableArray *)v30 removeObjectsInArray:v38];
  id v54 = [(NSMutableArray *)v30 count];
  if (v30 && v54)
  {
    uint64_t v193 = 0;
    __int16 v194 = 0;
    unint64_t v195 = 0;
    sub_1001D447C(&v193, (unint64_t)[(NSMutableArray *)v30 count]);
    long long v191 = 0u;
    long long v192 = 0u;
    long long v189 = 0u;
    long long v190 = 0u;
    id v55 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v189 objects:v207 count:16];
    if (v55)
    {
      uint64_t v56 = *(void *)v190;
      do
      {
        for (uint64_t i = 0; i != v55; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v190 != v56) {
            objc_enumerationMutation(v30);
          }
          __int16 v58 = *(void **)(*((void *)&v189 + 1) + 8 * i);
          [objc_msgSend(v58, "latlon") latitude];
          std::to_string(&v187, v59);
          __int16 v60 = std::string::insert(&v187, 0, "(");
          long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
          v188.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v188.__r_.__value_.__l.__data_ = v61;
          v60->__r_.__value_.__l.__size_ = 0;
          v60->__r_.__value_.__r.__words[2] = 0;
          v60->__r_.__value_.__r.__words[0] = 0;
          __int16 v62 = std::string::append(&v188, ",");
          long long v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
          *(void *)&v203[16] = *((void *)&v62->__r_.__value_.__l + 2);
          *(_OWORD *)__int16 v203 = v63;
          v62->__r_.__value_.__l.__size_ = 0;
          v62->__r_.__value_.__r.__words[2] = 0;
          v62->__r_.__value_.__r.__words[0] = 0;
          [objc_msgSend(v58, "latlon") longitude];
          std::to_string(&v186, v64);
          if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            __int16 v65 = &v186;
          }
          else {
            __int16 v65 = (std::string *)v186.__r_.__value_.__r.__words[0];
          }
          if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v186.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v186.__r_.__value_.__l.__size_;
          }
          __int16 v67 = std::string::append((std::string *)v203, (const std::string::value_type *)v65, size);
          long long v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          *(void *)&v209[16] = *((void *)&v67->__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v209 = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          __int16 v69 = std::string::append((std::string *)v209, ")");
          std::string::size_type v70 = v69->__r_.__value_.__r.__words[0];
          v206[0] = v69->__r_.__value_.__l.__size_;
          *(void *)((char *)v206 + 7) = *(std::string::size_type *)((char *)&v69->__r_.__value_.__r.__words[1] + 7);
          char v71 = HIBYTE(v69->__r_.__value_.__r.__words[2]);
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          uint64_t v72 = v194;
          if ((unint64_t)v194 >= v195)
          {
            unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v194 - v193) >> 3);
            unint64_t v76 = v75 + 1;
            if (v75 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1001D7FD4();
            }
            if (0x5555555555555556 * ((uint64_t)(v195 - v193) >> 3) > v76) {
              unint64_t v76 = 0x5555555555555556 * ((uint64_t)(v195 - v193) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v195 - v193) >> 3) >= 0x555555555555555) {
              unint64_t v77 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v77 = v76;
            }
            *(void *)&unsigned char buf[32] = &v195;
            if (v77) {
              uint64_t v78 = (char *)sub_1000DA5D8((uint64_t)&v195, v77);
            }
            else {
              uint64_t v78 = 0;
            }
            __int16 v79 = &v78[24 * v75];
            *(void *)long long buf = v78;
            *(void *)&uint8_t buf[8] = v79;
            *(void *)&unsigned char buf[24] = &v78[24 * v77];
            uint64_t v80 = v206[0];
            *(void *)__int16 v79 = v70;
            *((void *)v79 + 1) = v80;
            *(void *)(v79 + 15) = *(void *)((char *)v206 + 7);
            v79[23] = v71;
            v206[0] = 0;
            *(void *)((char *)v206 + 7) = 0;
            *(void *)&uint8_t buf[16] = v79 + 24;
            sub_1001D7FEC(&v193, buf);
            uint64_t v74 = v194;
            sub_1001D8184((uint64_t)buf);
          }
          else
          {
            std::string::size_type v73 = v206[0];
            std::string::size_type *v194 = v70;
            v72[1] = v73;
            *(std::string::size_type *)((char *)v72 + 15) = *(void *)((char *)v206 + 7);
            *((unsigned char *)v72 + 23) = v71;
            v206[0] = 0;
            *(void *)((char *)v206 + 7) = 0;
            uint64_t v74 = v72 + 3;
          }
          __int16 v194 = v74;
          if ((v209[23] & 0x80000000) != 0) {
            operator delete(*(void **)v209);
          }
          if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v186.__r_.__value_.__l.__data_);
          }
          if ((v203[23] & 0x80000000) != 0) {
            operator delete(*(void **)v203);
          }
          if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v188.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v187.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v187.__r_.__value_.__l.__data_);
          }
        }
        id v55 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v189 objects:v207 count:16];
      }
      while (v55);
    }
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    __int16 v81 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      id v82 = [(NSMutableArray *)v30 count];
      sub_1001D4530(", ", &v193, (uint64_t)buf);
      __int16 v83 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)uint64_t v209 = 134218242;
      *(void *)&v209[4] = v82;
      *(_WORD *)&v209[12] = 2080;
      *(void *)&v209[14] = v83;
      _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEBUG, "%zu clusters to evaluate prefetch across: %s", v209, 0x16u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v164 = [(NSMutableArray *)v30 count];
      sub_1001D4530(", ", &v193, (uint64_t)v209);
      if (v209[23] >= 0) {
        __int16 v165 = v209;
      }
      else {
        __int16 v165 = *(unsigned char **)v209;
      }
      *(_DWORD *)__int16 v203 = 134218242;
      *(void *)&v203[4] = v164;
      *(_WORD *)&v203[12] = 2080;
      *(void *)&v203[14] = v165;
      double v166 = (char *)_os_log_send_and_compose_impl();
      if ((v209[23] & 0x80000000) != 0) {
        operator delete(*(void **)v209);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v166);
      if (v166 != buf) {
        free(v166);
      }
    }
    memset(&v188, 0, sizeof(v188));
    memset(v209, 0, sizeof(v209));
    *(_DWORD *)int v210 = 1065353216;
    id v84 = [a2 count];
    sub_100100330((uint64_t)v209, vcvtps_u32_f32((float)(unint64_t)v84 / *(float *)v210));
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    __int16 v85 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      id v86 = [a2 count];
      id v87 = [(NSMutableArray *)v30 count];
      *(_DWORD *)long long buf = 134349312;
      *(void *)&uint8_t buf[4] = v86;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(void *)&unsigned char buf[14] = v87;
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "SelectIndoor, selection, groups, %{public}ld, clusters, %{public}ld", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v167 = [a2 count];
      id v168 = [(NSMutableArray *)v30 count];
      *(_DWORD *)__int16 v203 = 134349312;
      *(void *)&v203[4] = v167;
      *(_WORD *)&v203[12] = 2050;
      *(void *)&v203[14] = v168;
      __int16 v169 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v169);
      if (v169 != buf) {
        free(v169);
      }
    }
    long long v184 = 0u;
    long long v185 = 0u;
    long long v182 = 0u;
    long long v183 = 0u;
    id v88 = [a2 countByEnumeratingWithState:&v182 objects:v205 count:16];
    if (v88)
    {
      uint64_t v89 = *(void *)v183;
      do
      {
        uint64_t v90 = 0;
        do
        {
          if (*(void *)v183 != v89) {
            objc_enumerationMutation(a2);
          }
          __int16 v91 = *(void **)(*((void *)&v182 + 1) + 8 * (void)v90);
          uint64_t v92 = (long long **)[v91 getLocationIds];
          memset(&v187, 0, sizeof(v187));
          sub_1001D857C((char *)&v187, *v92, v92[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v92[1] - (char *)*v92) >> 3));
          if (v187.__r_.__value_.__r.__words[0] == v187.__r_.__value_.__l.__size_)
          {
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            __int16 v113 = qword_1024193A8;
            if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
            {
              id v114 = [[objc_msgSend(v91, "groupId") UTF8String];
              *(_DWORD *)long long buf = 136380675;
              *(void *)&uint8_t buf[4] = v114;
              _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "SelectIndoor, group, %{private}s, #Warning", buf, 0xCu);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193A0 != -1) {
                dispatch_once(&qword_1024193A0, &stru_10229E160);
              }
              id v132 = [[objc_msgSend(v91, "groupId") UTF8String];
              *(_DWORD *)__int16 v203 = 136380675;
              *(void *)&v203[4] = v132;
              int v112 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v112);
              goto LABEL_171;
            }
          }
          else
          {
            long long v180 = 0u;
            long long v181 = 0u;
            long long v178 = 0u;
            long long v179 = 0u;
            id v93 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v178 objects:v204 count:16];
            if (v93)
            {
              uint64_t v94 = 0;
              uint64_t v95 = *(void *)v179;
              double v96 = INFINITY;
              do
              {
                for (j = 0; j != v93; j = (char *)j + 1)
                {
                  if (*(void *)v179 != v95) {
                    objc_enumerationMutation(v30);
                  }
                  uint64_t v98 = *(void **)(*((void *)&v178 + 1) + 8 * (void)j);
                  [v91 distance:[v98 ecef]];
                  if (v99 < v96)
                  {
                    double v96 = v99;
                    uint64_t v94 = v98;
                  }
                }
                id v93 = [(NSMutableArray *)v30 countByEnumeratingWithState:&v178 objects:v204 count:16];
              }
              while (v93);
              if (v96 < a8)
              {
                sub_100134750(buf, (char *)[v91 groupId]);
                *(void *)__int16 v203 = buf;
                int v100 = sub_1001D870C((uint64_t)v209, buf, (uint64_t)&unk_101D0B290, (long long **)v203);
                if ((buf[23] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
                if (*((unsigned char *)v100 + 40))
                {
                  uint64_t v101 = v100[6];
                  if (v96 < *(double *)(v101 + 8))
                  {
                    *(double *)(v101 + 8) = v96;
                    id v102 = [v94 relevancy:a6];
                    if (!*((unsigned char *)v100 + 40)) {
                      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
                    }
                    *(void *)(v100[6] + 16) = v102;
                    if (qword_1024193A0 != -1) {
                      dispatch_once(&qword_1024193A0, &stru_10229E160);
                    }
                    __int16 v103 = qword_1024193A8;
                    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
                    {
                      id v104 = [[[v91 groupId] UTF8String];
                      [objc_msgSend(v94, "latlon") latitude];
                      uint64_t v106 = v105;
                      [objc_msgSend(v94, "latlon") longitude];
                      *(_DWORD *)long long buf = 136381187;
                      *(void *)&uint8_t buf[4] = v104;
                      *(_WORD *)&unsigned char buf[12] = 2049;
                      *(void *)&unsigned char buf[14] = v106;
                      *(_WORD *)&buf[22] = 2049;
                      *(void *)&unsigned char buf[24] = v107;
                      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEBUG, "SelectIndoor, group, disjoint, %{private}s, cluster, %{private}.7f, %{private}.7f", buf, 0x20u);
                    }
                    if (sub_10013D1A0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1024193A0 != -1) {
                        goto LABEL_173;
                      }
                      goto LABEL_135;
                    }
                  }
                }
                else
                {
                  id v115 = [v94 relevancy:a6];
                  id v116 = v115;
                  std::string::size_type v117 = v188.__r_.__value_.__l.__size_;
                  if (v188.__r_.__value_.__l.__size_ >= v188.__r_.__value_.__r.__words[2])
                  {
                    __int16 v119 = (void *)v188.__r_.__value_.__r.__words[0];
                    unint64_t v120 = 0xAAAAAAAAAAAAAAABLL
                         * ((uint64_t)(v188.__r_.__value_.__l.__size_ - v188.__r_.__value_.__r.__words[0]) >> 3);
                    unint64_t v121 = v120 + 1;
                    if (v120 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      sub_1001D7FD4();
                    }
                    if (0x5555555555555556
                       * ((uint64_t)(v188.__r_.__value_.__r.__words[2] - v188.__r_.__value_.__r.__words[0]) >> 3) > v121)
                      unint64_t v121 = 0x5555555555555556
                           * ((uint64_t)(v188.__r_.__value_.__r.__words[2] - v188.__r_.__value_.__r.__words[0]) >> 3);
                    if (0xAAAAAAAAAAAAAAABLL
                       * ((uint64_t)(v188.__r_.__value_.__r.__words[2] - v188.__r_.__value_.__r.__words[0]) >> 3) >= 0x555555555555555)
                      unint64_t v122 = 0xAAAAAAAAAAAAAAALL;
                    else {
                      unint64_t v122 = v121;
                    }
                    if (v122)
                    {
                      __int16 v123 = (char *)sub_1000DA5D8((uint64_t)&v188.__r_.__value_.__r.__words[2], v122);
                      std::string::size_type v117 = v188.__r_.__value_.__l.__size_;
                      __int16 v119 = (void *)v188.__r_.__value_.__r.__words[0];
                    }
                    else
                    {
                      __int16 v123 = 0;
                    }
                    int v124 = (double *)&v123[24 * v120];
                    *(void *)int v124 = v91;
                    v124[1] = v96;
                    *((void *)v124 + 2) = v116;
                    std::string::size_type v125 = (std::string::size_type)v124;
                    if ((void *)v117 != v119)
                    {
                      do
                      {
                        long long v126 = *(_OWORD *)(v117 - 24);
                        *(void *)(v125 - 8) = *(void *)(v117 - 8);
                        *(_OWORD *)(v125 - 24) = v126;
                        v125 -= 24;
                        v117 -= 24;
                      }
                      while ((void *)v117 != v119);
                      __int16 v119 = (void *)v188.__r_.__value_.__r.__words[0];
                    }
                    std::string::size_type v118 = (std::string::size_type)(v124 + 3);
                    v188.__r_.__value_.__r.__words[0] = v125;
                    v188.__r_.__value_.__l.__size_ = (std::string::size_type)(v124 + 3);
                    v188.__r_.__value_.__r.__words[2] = (std::string::size_type)&v123[24 * v122];
                    if (v119) {
                      operator delete(v119);
                    }
                  }
                  else
                  {
                    *(void *)v188.__r_.__value_.__l.__size_ = v91;
                    *(double *)(v117 + 8) = v96;
                    std::string::size_type v118 = v117 + 24;
                    *(void *)(v117 + 16) = v115;
                  }
                  v188.__r_.__value_.__l.__size_ = v118;
                  if (!*((unsigned char *)v100 + 40)) {
                    *((unsigned char *)v100 + 40) = 1;
                  }
                  v100[6] = v118 - 24;
                  if (qword_1024193A0 != -1) {
                    dispatch_once(&qword_1024193A0, &stru_10229E160);
                  }
                  __int16 v127 = qword_1024193A8;
                  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
                  {
                    id v128 = [[objc_msgSend(v91, "groupId") UTF8String];
                    [objc_msgSend(v94, "latlon") latitude];
                    uint64_t v130 = v129;
                    [objc_msgSend(v94, "latlon") longitude];
                    *(_DWORD *)long long buf = 136381187;
                    *(void *)&uint8_t buf[4] = v128;
                    *(_WORD *)&unsigned char buf[12] = 2049;
                    *(void *)&unsigned char buf[14] = v130;
                    *(_WORD *)&buf[22] = 2049;
                    *(void *)&unsigned char buf[24] = v131;
                    _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEBUG, "SelectIndoor, group, new, %{private}s, cluster, %{private}.7f, %{private}.7f", buf, 0x20u);
                  }
                  if (sub_10013D1A0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1024193A0 == -1) {
                      goto LABEL_135;
                    }
LABEL_173:
                    dispatch_once(&qword_1024193A0, &stru_10229E160);
LABEL_135:
                    id v108 = [[objc_msgSend(v91, "groupId") UTF8String];
                    [objc_msgSend(v94, "latlon") latitude];
                    uint64_t v110 = v109;
                    [objc_msgSend(v94, "latlon") longitude];
                    *(_DWORD *)__int16 v203 = 136381187;
                    *(void *)&v203[4] = v108;
                    *(_WORD *)&v203[12] = 2049;
                    *(void *)&v203[14] = v110;
                    *(_WORD *)&v203[22] = 2049;
                    *(void *)&v203[24] = v111;
                    int v112 = (char *)_os_log_send_and_compose_impl();
                    sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v112);
LABEL_171:
                    if (v112 != buf) {
                      free(v112);
                    }
                  }
                }
              }
            }
          }
          *(void *)long long buf = &v187;
          sub_1000A7B4C((void ***)buf);
          uint64_t v90 = (char *)v90 + 1;
        }
        while (v90 != v88);
        id v133 = [a2 countByEnumeratingWithState:&v182 objects:v205 count:16];
        id v88 = v133;
      }
      while (v133);
    }
    unint64_t v134 = 126
         - 2
         * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v188.__r_.__value_.__l.__size_ - v188.__r_.__value_.__r.__words[0]) >> 3));
    if (v188.__r_.__value_.__l.__size_ == v188.__r_.__value_.__r.__words[0]) {
      uint64_t v135 = 0;
    }
    else {
      uint64_t v135 = v134;
    }
    sub_1001D8A04((uint64_t)v188.__r_.__value_.__l.__data_, (double *)v188.__r_.__value_.__l.__size_, (uint64_t)buf, v135, 1);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v136 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349056;
      *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL
                         * ((uint64_t)(v188.__r_.__value_.__l.__size_ - v188.__r_.__value_.__r.__words[0]) >> 3);
      _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "SelectIndoor, candidates, %{public}ld", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      *(_DWORD *)__int16 v203 = 134349056;
      *(void *)&v203[4] = 0xAAAAAAAAAAAAAAABLL
                          * ((uint64_t)(v188.__r_.__value_.__l.__size_ - v188.__r_.__value_.__r.__words[0]) >> 3);
      double v170 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v170);
      if (v170 != buf) {
        free(v170);
      }
    }
    memset(&v187, 0, sizeof(v187));
    std::string::size_type v138 = v188.__r_.__value_.__l.__size_;
    std::string::size_type v137 = v188.__r_.__value_.__r.__words[0];
    if (v188.__r_.__value_.__r.__words[0] == v188.__r_.__value_.__l.__size_) {
      goto LABEL_214;
    }
    unint64_t v139 = 0;
    do
    {
      int v140 = [*(id *)v137 getLocationIds];
      unint64_t v141 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v140[1] - *v140) >> 3);
      unint64_t v142 = v139;
      if (v139 < a3)
      {
        *(void *)long long buf = [objc_msgSend(*(id *)v137, "groupId") UTF8String];
        id v143 = [*(id *)v137 getLocationIds];
        *(void *)__int16 v203 = [*(id *)v137 locationContext];
        std::string::size_type v144 = v187.__r_.__value_.__l.__size_;
        if (v187.__r_.__value_.__l.__size_ >= v187.__r_.__value_.__r.__words[2])
        {
          std::string::size_type v146 = sub_1001D9B3C((uint64_t *)&v187, (char **)buf, (uint64_t)v143, (void *)(v137 + 16), v203, &dword_101D047D0);
        }
        else
        {
          sub_100134750((void *)v187.__r_.__value_.__l.__size_, *(char **)buf);
          *(void *)(v144 + 24) = v143;
          uint64_t v145 = *(void *)v203;
          *(void *)(v144 + 32) = *(void *)(v137 + 16);
          *(void *)(v144 + 40) = v145;
          *(_DWORD *)(v144 + 48) = 0;
          std::string::size_type v146 = v144 + 56;
        }
        v187.__r_.__value_.__l.__size_ = v146;
        unint64_t v142 = v141 + v139;
      }
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      __int16 v147 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
      {
        id v148 = [[objc_msgSend(*(id *)v137, "groupId") UTF8String];
        *(_DWORD *)long long buf = 136381443;
        *(void *)&uint8_t buf[4] = v148;
        *(_WORD *)&unsigned char buf[12] = 1026;
        *(_DWORD *)&unsigned char buf[14] = v139 < a3;
        *(_WORD *)&unsigned char buf[18] = 2050;
        *(void *)&buf[20] = v141;
        *(_WORD *)&buf[28] = 2050;
        *(void *)&buf[30] = v142;
        _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEBUG, "SelectIndoor, candidate, %{private}s, added, %{public}d, floors, %{public}ld, total, %{public}ld", buf, 0x26u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        id v149 = [[objc_msgSend(*(id *)v137, "groupId") UTF8String];
        *(_DWORD *)__int16 v203 = 136381443;
        *(void *)&v203[4] = v149;
        *(_WORD *)&v203[12] = 1026;
        *(_DWORD *)&v203[14] = v139 < a3;
        *(_WORD *)&v203[18] = 2050;
        *(void *)&v203[20] = v141;
        *(_WORD *)&v203[28] = 2050;
        *(void *)&v203[30] = v142;
        uint64_t v150 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v150);
        if (v150 != buf) {
          free(v150);
        }
      }
      v137 += 24;
      unint64_t v139 = v142;
    }
    while (v137 != v138);
    if (v187.__r_.__value_.__r.__words[0] == v187.__r_.__value_.__l.__size_)
    {
LABEL_214:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      unint64_t v154 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "SelectIndoor, selected, none", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        *(_WORD *)__int16 v203 = 0;
        __int16 v171 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v171);
        if (v171 != buf) {
          free(v171);
        }
      }
      __int16 v153 = a7;
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v152 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134349312;
        *(void *)&uint8_t buf[4] = 0x6DB6DB6DB6DB6DB7
                           * ((uint64_t)(v187.__r_.__value_.__l.__size_ - v187.__r_.__value_.__r.__words[0]) >> 3);
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(void *)&unsigned char buf[14] = v142;
        _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "SelectIndoor, selected, venues, %{public}ld, floors, %{public}ld", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        *(_DWORD *)__int16 v203 = 134349312;
        *(void *)&v203[4] = 0x6DB6DB6DB6DB6DB7
                            * ((uint64_t)(v187.__r_.__value_.__l.__size_ - v187.__r_.__value_.__r.__words[0]) >> 3);
        *(_WORD *)&v203[12] = 2050;
        *(void *)&v203[14] = v142;
        int v172 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v172);
        if (v172 != buf) {
          free(v172);
        }
      }
      *a7 = v187;
      __int16 v153 = &v187;
    }
    v153->__r_.__value_.__r.__words[0] = 0;
    v153->__r_.__value_.__l.__size_ = 0;
    v153->__r_.__value_.__r.__words[2] = 0;
    *(void *)long long buf = &v187;
    sub_1001D9A98((void ***)buf);
    sub_1001D84E8((uint64_t)v209);
    if (v188.__r_.__value_.__r.__words[0])
    {
      v188.__r_.__value_.__l.__size_ = v188.__r_.__value_.__r.__words[0];
      operator delete(v188.__r_.__value_.__l.__data_);
    }
    *(void *)long long buf = &v193;
    sub_1000A7B4C((void ***)buf);
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    __int16 v151 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "SelectIndoor, noclusters, #Warning", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      *(_WORD *)uint64_t v209 = 0;
      __int16 v163 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v163);
      if (v163 != buf) {
        free(v163);
      }
    }
    a7->__r_.__value_.__r.__words[0] = 0;
    a7->__r_.__value_.__l.__size_ = 0;
    a7->__r_.__value_.__r.__words[2] = 0;
  }
}

void sub_1001D3D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  STACK[0x520] = (unint64_t)&a41;
  sub_1001D9A98((void ***)&STACK[0x520]);
  sub_1001D84E8((uint64_t)&STACK[0x450]);
  if (__p)
  {
    a46 = (uint64_t)__p;
    operator delete(__p);
  }
  STACK[0x450] = (unint64_t)&a58;
  sub_1000A7B4C((void ***)&STACK[0x450]);
  _Unwind_Resume(a1);
}

void sub_1001D3F7C(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 68))
  {
    id v4 = [[CLIndoorPrefetchRegion alloc] initFromLOI:a2];
    [**(id **)a1 addObject:v4];

    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    std::string v5 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *a2;
      uint64_t v7 = a2[1];
      *(_DWORD *)long long buf = 134283777;
      uint64_t v33 = v6;
      __int16 v34 = 2049;
      uint64_t v35 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "SelectIndoor, loi, predicted, %{private}.7f, %{private}.7f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
LABEL_31:
      uint64_t v20 = *a2;
      uint64_t v21 = a2[1];
      int v28 = 134283777;
      uint64_t v29 = v20;
      __int16 v30 = 2049;
      uint64_t v31 = v21;
      uint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "auto selectIndoorPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)::(anonymous class)::operator()(CLIndoorPrefetchLocationOfInterest) const", "%s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
  }
  else
  {
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    unsigned int v8 = **(void ***)(a1 + 8);
    id v9 = [v8 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v24;
LABEL_11:
      uint64_t v12 = 0;
      while (1)
      {
        if (*(void *)v24 != v11) {
          objc_enumerationMutation(v8);
        }
        if ([*(id *)(*((void *)&v23 + 1) + 8 * v12) mergeLocationOfInterest:a2 clusterRadius:*(double *)(a1 + 16)])break; {
        if (v10 == (id)++v12)
        }
        {
          id v10 = [v8 countByEnumeratingWithState:&v23 objects:v27 count:16];
          if (v10) {
            goto LABEL_11;
          }
          goto LABEL_17;
        }
      }
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      double v17 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *a2;
        uint64_t v19 = a2[1];
        *(_DWORD *)long long buf = 134283777;
        uint64_t v33 = v18;
        __int16 v34 = 2049;
        uint64_t v35 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SelectIndoor, loi, skiphist, %{private}.7f, %{private}.7f", buf, 0x16u);
      }
      if (!sub_10013D1A0(115, 2)) {
        return;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        goto LABEL_34;
      }
      goto LABEL_31;
    }
LABEL_17:
    id v13 = [[CLIndoorPrefetchRegion alloc] initFromLOI:a2];
    [**(id **)(a1 + 8) addObject:v13];

    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    __int16 v14 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = *a2;
      uint64_t v16 = a2[1];
      *(_DWORD *)long long buf = 134283777;
      uint64_t v33 = v15;
      __int16 v34 = 2049;
      uint64_t v35 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "SelectIndoor, loi, historical, %{private}.7f, %{private}.7f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
LABEL_34:
      }
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      goto LABEL_31;
    }
  }
}

uint64_t sub_1001D447C(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      sub_1001D7FD4();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_1000DA5D8(result, a2);
    v7[1] = v7[0] + v5;
    int32x4_t v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    sub_1001D7FEC(a1, v7);
    return sub_1001D8184((uint64_t)v7);
  }
  return result;
}

void sub_1001D451C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001D8184((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1001D4530@<X0>(char *__s@<X1>, uint64_t *result@<X0>, uint64_t a3@<X8>)
{
  uint64_t v5 = *result;
  uint64_t v6 = result[1];
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  if (v5 == v6) {
    goto LABEL_10;
  }
  int v7 = *(char *)(v5 + 23);
  if (v7 >= 0) {
    unsigned int v8 = (std::string::value_type *)v5;
  }
  else {
    unsigned int v8 = *(std::string::value_type **)v5;
  }
  if (v7 >= 0) {
    std::string::size_type v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    std::string::size_type v9 = *(void *)(v5 + 8);
  }
  for (uint64_t result = (uint64_t *)sub_1001D8214((std::string *)a3, a3, v8, &v8[v9], v9);
        ;
        uint64_t result = (uint64_t *)sub_1001D8214((std::string *)a3, v16, v18, &v18[v19], v19))
  {
    v5 += 24;
LABEL_10:
    if (v5 == v6) {
      break;
    }
    uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = a3;
    }
    else {
      uint64_t v11 = *(void *)a3;
    }
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *(void *)(a3 + 8);
    }
    uint64_t v12 = v11 + v10;
    std::string::size_type v13 = strlen(__s);
    sub_1001D8214((std::string *)a3, v12, __s, &__s[v13], v13);
    uint64_t v14 = *(unsigned __int8 *)(a3 + 23);
    if ((v14 & 0x80u) == 0) {
      uint64_t v15 = a3;
    }
    else {
      uint64_t v15 = *(void *)a3;
    }
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *(void *)(a3 + 8);
    }
    uint64_t v16 = v15 + v14;
    int v17 = *(char *)(v5 + 23);
    if (v17 >= 0) {
      uint64_t v18 = (std::string::value_type *)v5;
    }
    else {
      uint64_t v18 = *(std::string::value_type **)v5;
    }
    if (v17 >= 0) {
      std::string::size_type v19 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      std::string::size_type v19 = *(void *)(v5 + 8);
    }
  }
  return result;
}

void sub_1001D4634(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

void sub_1001D4654(uint64_t *a1@<X0>, void *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int8 *a5@<X4>, uint64_t a6@<X5>, long long *a7@<X8>, double a8@<D0>, double a9@<D1>)
{
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  __int16 v169 = a5;
  std::string::size_type v13 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134349824;
    *(double *)&uint8_t buf[4] = a8;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&unsigned char buf[14] = a3;
    *(_WORD *)&buf[22] = 2050;
    double v213 = a9;
    __int16 v214 = 1026;
    *(_DWORD *)uint64_t v215 = (int)((double)a4 / 86400.0);
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SelectWifi2, params, radius, %{public}lf, maxFloors, %{public}zu, clusterRadius, %{public}lf, loiMaxDays, %{public}d", buf, 0x26u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    *(_DWORD *)__int16 v203 = 134349824;
    *(double *)&v203[4] = a8;
    __int16 v204 = 2050;
    unint64_t v205 = a3;
    __int16 v206 = 2050;
    double v207 = a9;
    __int16 v208 = 1026;
    *(_DWORD *)uint64_t v209 = (int)((double)a4 / 86400.0);
    id v149 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v149);
    if (v149 != buf) {
      free(v149);
    }
  }
  __int16 v171 = +[NSMutableArray arrayWithCapacity:0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3)];
  obj = +[NSMutableArray arrayWithCapacity:0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3)];
  uint64_t v14 = a1[1];
  uint64_t v15 = *a1;
  if (v14 != *a1)
  {
    do
    {
      uint64_t v16 = v14 - 72;
      if (*(unsigned char *)(v14 - 4) || *(int *)(v14 - 8) >= 1)
      {
        id v17 = [[CLIndoorPrefetchRegion alloc] initFromLOI:v14 - 72];
        uint64_t v18 = v171;
        if (!*(unsigned char *)(v14 - 4))
        {
          long long v199 = 0u;
          long long v200 = 0u;
          long long v197 = 0u;
          long long v198 = 0u;
          id v20 = [(NSMutableArray *)obj countByEnumeratingWithState:&v197 objects:v211 count:16];
          uint64_t v18 = obj;
          if (v20)
          {
            uint64_t v21 = *(void *)v198;
            while (2)
            {
              for (uint64_t i = 0; i != v20; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v198 != v21) {
                  objc_enumerationMutation(obj);
                }
                if ([*(id *)(*((void *)&v197 + 1) + 8 * i) mergeLocationOfInterest:v14 - 72 clusterRadius:a9])
                {
                  int v19 = 77;
                  goto LABEL_21;
                }
              }
              id v20 = [(NSMutableArray *)obj countByEnumeratingWithState:&v197 objects:v211 count:16];
              if (v20) {
                continue;
              }
              break;
            }
            uint64_t v18 = obj;
          }
        }
        [(NSMutableArray *)v18 addObject:v17];
        int v19 = 65;
LABEL_21:
      }
      else
      {
        int v19 = 83;
      }
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      long long v23 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        long long v24 = "predicted";
        if (*(unsigned char *)(v14 - 4))
        {
          double v25 = *(double *)(v14 - 48);
        }
        else
        {
          long long v24 = "historical";
          double v25 = (double)*(int *)(v14 - 8);
        }
        uint64_t v26 = *(void *)(v14 - 72);
        double v27 = *(double *)(v14 - 64);
        *(_DWORD *)long long buf = 136447235;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 2049;
        *(void *)&unsigned char buf[14] = v26;
        *(_WORD *)&buf[22] = 2049;
        double v213 = v27;
        __int16 v214 = 2050;
        *(double *)uint64_t v215 = v25;
        *(_WORD *)&v215[8] = 1026;
        *(_DWORD *)&v215[10] = v19;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "SelectWifi2, loi, %{public}s, %{private}.7f, %{private}.7f, visitconf, %{public}.1f, action, %{public}c", buf, 0x30u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        if (*(unsigned char *)(v14 - 4)) {
          int v28 = "predicted";
        }
        else {
          int v28 = "historical";
        }
        unint64_t v30 = *(void *)(v14 - 72);
        double v29 = *(double *)(v14 - 64);
        if (*(unsigned char *)(v14 - 4)) {
          double v31 = *(double *)(v14 - 48);
        }
        else {
          double v31 = (double)*(int *)(v14 - 8);
        }
        *(_DWORD *)__int16 v203 = 136447235;
        *(void *)&v203[4] = v28;
        __int16 v204 = 2049;
        unint64_t v205 = v30;
        __int16 v206 = 2049;
        double v207 = v29;
        __int16 v208 = 2050;
        *(double *)uint64_t v209 = v31;
        *(_WORD *)&v209[8] = 1026;
        *(_DWORD *)&v209[10] = v19;
        id v32 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v32);
        if (v32 != buf) {
          free(v32);
        }
      }
      v14 -= 72;
    }
    while (v16 != v15);
  }
  if (*v169)
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v33 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*v169) {
        sub_101A50B74();
      }
      uint64_t v34 = *(void *)(v169 + 108);
      uint64_t v35 = *(void *)(v169 + 116);
      *(_DWORD *)long long buf = 134283777;
      *(void *)&uint8_t buf[4] = v34;
      *(_WORD *)&unsigned char buf[12] = 2049;
      *(void *)&unsigned char buf[14] = v35;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "SelectWifi2, loi, historical, %{private}.7f, %{private}.7f, visitconf, 0, action, A", buf, 0x16u);
    }
    id v36 = v169;
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      if (!*v169) {
        sub_101A50B74();
      }
      uint64_t v157 = *(void *)(v169 + 108);
      unint64_t v158 = *(void *)(v169 + 116);
      *(_DWORD *)__int16 v203 = 134283777;
      *(void *)&v203[4] = v157;
      __int16 v204 = 2049;
      unint64_t v205 = v158;
      id v159 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v159);
      if (v159 != buf) {
        free(v159);
      }
      id v36 = v169;
    }
    if (!*v36) {
      sub_101A50B74();
    }
    uint64_t v37 = *(void *)(v36 + 108);
    uint64_t v38 = *(void *)(v36 + 116);
    uint64_t v39 = *(void *)(v36 + 28);
    uint64_t v40 = sub_1001DC498((uint64_t)(v36 + 8));
    *(void *)long long buf = v37;
    *(void *)&uint8_t buf[8] = v38;
    *(void *)&uint8_t buf[16] = v39;
    double v213 = 1.0;
    *(void *)&v215[6] = v40;
    LOBYTE(v214) = 1;
    v215[14] = 0;
    int v216 = 1;
    char v217 = 0;
    id v41 = [[CLIndoorPrefetchRegion alloc] initFromLOI:buf];
    [(NSMutableArray *)obj addObject:v41];
  }
  double v176 = +[NSMutableArray arrayWithCapacity:(char *)[(NSMutableArray *)v171 count] + (void)[(NSMutableArray *)obj count]];
  [(NSMutableArray *)v176 addObjectsFromArray:obj];
  [(NSMutableArray *)v176 addObjectsFromArray:v171];
  char v42 = +[NSMutableArray arrayWithCapacity:[(NSMutableArray *)v176 count]];
  long long v195 = 0u;
  long long v196 = 0u;
  long long v193 = 0u;
  long long v194 = 0u;
  id v43 = [(NSMutableArray *)v176 countByEnumeratingWithState:&v193 objects:v210 count:16];
  if (v43)
  {
    uint64_t v44 = *(void *)v194;
    do
    {
      __int16 v45 = 0;
      do
      {
        if (*(void *)v194 != v44) {
          objc_enumerationMutation(v176);
        }
        uint64_t v46 = *(void **)(*((void *)&v193 + 1) + 8 * (void)v45);
        double v47 = COERCE_DOUBLE([v46 relevancy:a6]);
        if (1000000 * a4 < a6 - *(void *)&v47)
        {
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10229E160);
          }
          uint64_t v48 = qword_1024193A8;
          if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
          {
            [objc_msgSend(v46, "latlon") latitude];
            uint64_t v50 = v49;
            [objc_msgSend(v46, "latlon") longitude];
            *(_DWORD *)long long buf = 134284033;
            *(void *)&uint8_t buf[4] = v50;
            *(_WORD *)&unsigned char buf[12] = 2049;
            *(void *)&unsigned char buf[14] = v51;
            *(_WORD *)&buf[22] = 2050;
            double v213 = v47;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, "SelectWifi2, irrelevant, %{private}.7f, %{private}.7f, relevancy, %{public}ld", buf, 0x20u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            [objc_msgSend(v46, "latlon") latitude];
            uint64_t v53 = v52;
            [objc_msgSend(v46, "latlon") longitude];
            *(_DWORD *)__int16 v203 = 134284033;
            *(void *)&v203[4] = v53;
            __int16 v204 = 2049;
            unint64_t v205 = v54;
            __int16 v206 = 2050;
            double v207 = v47;
            id v55 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v55);
            if (v55 != buf) {
              free(v55);
            }
          }
          [(NSMutableArray *)v42 addObject:v46];
        }
        __int16 v45 = (char *)v45 + 1;
      }
      while (v43 != v45);
      id v56 = [(NSMutableArray *)v176 countByEnumeratingWithState:&v193 objects:v210 count:16];
      id v43 = v56;
    }
    while (v56);
  }
  [(NSMutableArray *)v176 removeObjectsInArray:v42];
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  id v57 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    id v58 = [(NSMutableArray *)v176 count];
    id v59 = [(NSMutableArray *)obj count];
    double v60 = COERCE_DOUBLE([(NSMutableArray *)v171 count]);
    id v61 = [(NSMutableArray *)v42 count];
    unint64_t v62 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
    int v63 = *v169;
    *(_DWORD *)long long buf = 134350336;
    *(void *)&uint8_t buf[4] = v58;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&unsigned char buf[14] = v59;
    *(_WORD *)&buf[22] = 2050;
    double v213 = v60;
    __int16 v214 = 2050;
    *(void *)uint64_t v215 = v61;
    *(_WORD *)&v215[8] = 2050;
    *(void *)&v215[10] = v62;
    *(_WORD *)&v215[18] = 1026;
    *(_DWORD *)&v215[20] = v63;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "SelectWifi2, clusters, %{public}ld, historical, %{public}ld, predicted, %{public}ld, irrelevant, %{public}ld, inputLOIs, %{public}ld, lastFix, %{public}d", buf, 0x3Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v150 = [(NSMutableArray *)v176 count];
    id v151 = [(NSMutableArray *)obj count];
    double v152 = COERCE_DOUBLE([(NSMutableArray *)v171 count]);
    id v153 = [(NSMutableArray *)v42 count];
    unint64_t v154 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
    int v155 = *v169;
    *(_DWORD *)__int16 v203 = 134350336;
    *(void *)&v203[4] = v150;
    __int16 v204 = 2050;
    unint64_t v205 = (unint64_t)v151;
    __int16 v206 = 2050;
    double v207 = v152;
    __int16 v208 = 2050;
    *(void *)uint64_t v209 = v153;
    *(_WORD *)&v209[8] = 2050;
    *(void *)&v209[10] = v154;
    *(_WORD *)&v209[18] = 1026;
    *(_DWORD *)&v209[20] = v155;
    id v156 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v156);
    if (v156 != buf) {
      free(v156);
    }
  }
  id v64 = [(NSMutableArray *)v176 count];
  if (v176 && v64)
  {
    long long v190 = 0;
    long long v191 = 0;
    unint64_t v192 = 0;
    memset(v188, 0, sizeof(v188));
    float v189 = 1.0;
    id v65 = [a2 count];
    sub_100100330((uint64_t)v188, vcvtps_u32_f32((float)(unint64_t)v65 / v189));
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v66 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      id v67 = [a2 count];
      id v68 = [(NSMutableArray *)v176 count];
      *(_DWORD *)long long buf = 134349568;
      *(void *)&uint8_t buf[4] = v67;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(void *)&unsigned char buf[14] = v68;
      *(_WORD *)&buf[22] = 2050;
      double v213 = a8;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "SelectWifi2, selection, avlgroups, %{public}ld, visitlois, %{public}ld, radius, %{public}lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v161 = [a2 count];
      id v162 = [(NSMutableArray *)v176 count];
      *(_DWORD *)__int16 v203 = 134349568;
      *(void *)&v203[4] = v161;
      __int16 v204 = 2050;
      unint64_t v205 = (unint64_t)v162;
      __int16 v206 = 2050;
      double v207 = a8;
      __int16 v163 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v163);
      if (v163 != buf) {
        free(v163);
      }
    }
    long long v186 = 0u;
    long long v187 = 0u;
    long long v184 = 0u;
    long long v185 = 0u;
    id v69 = [a2 countByEnumeratingWithState:&v184 objects:v202 count:16];
    if (v69)
    {
      uint64_t v175 = *(void *)v185;
      do
      {
        std::string::size_type v70 = 0;
        do
        {
          if (*(void *)v185 != v175) {
            objc_enumerationMutation(a2);
          }
          char v71 = *(void **)(*((void *)&v184 + 1) + 8 * (void)v70);
          uint64_t v72 = (long long **)[v71 getLocationIds];
          long long v182 = 0uLL;
          unint64_t v183 = 0;
          sub_1001D857C((char *)&v182, *v72, v72[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v72[1] - (char *)*v72) >> 3));
          if ((void)v182 == *((void *)&v182 + 1))
          {
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            uint64_t v94 = qword_1024193A8;
            if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
            {
              id v95 = [[objc_msgSend(v71, "groupId") UTF8String];
              *(_DWORD *)long long buf = 136380675;
              *(void *)&uint8_t buf[4] = v95;
              _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "SelectWifi2, group, %{private}s, #Warning", buf, 0xCu);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1024193A0 != -1) {
                dispatch_once(&qword_1024193A0, &stru_10229E160);
              }
              id v96 = [[objc_msgSend(v71, "groupId") UTF8String];
              *(_DWORD *)__int16 v203 = 136380675;
              *(void *)&v203[4] = v96;
              id v93 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v93);
LABEL_145:
              if (v93 != buf) {
                free(v93);
              }
            }
          }
          else
          {
            long long v180 = 0u;
            long long v181 = 0u;
            long long v178 = 0u;
            long long v179 = 0u;
            id v73 = [(NSMutableArray *)v176 countByEnumeratingWithState:&v178 objects:v201 count:16];
            if (v73)
            {
              int v74 = 0;
              uint64_t v75 = *(void *)v179;
LABEL_91:
              uint64_t v76 = a6;
              id v77 = v69;
              uint64_t v78 = 0;
              int v79 = v74 + v73;
              while (1)
              {
                if (*(void *)v179 != v75) {
                  objc_enumerationMutation(v176);
                }
                uint64_t v80 = *(void **)(*((void *)&v178 + 1) + 8 * v78);
                [v71 distance:[v80 ecef]];
                double v82 = v81;
                if (v81 <= a8) {
                  break;
                }
                if (v73 == (id)++v78)
                {
                  id v73 = [(NSMutableArray *)v176 countByEnumeratingWithState:&v178 objects:v201 count:16];
                  int v74 = v79;
                  id v69 = v77;
                  a6 = v76;
                  if (v73) {
                    goto LABEL_91;
                  }
                  goto LABEL_140;
                }
              }
              sub_100134750(buf, (char *)[v71 groupId]);
              *(void *)__int16 v203 = buf;
              __int16 v83 = sub_1001D870C((uint64_t)v188, buf, (uint64_t)&unk_101D0B290, (long long **)v203);
              id v69 = v77;
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              a6 = v76;
              if (v83[40])
              {
                if (qword_1024193A0 != -1) {
                  dispatch_once(&qword_1024193A0, &stru_10229E160);
                }
                id v84 = qword_1024193A8;
                if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
                {
                  id v85 = [[objc_msgSend(v71, "groupId") UTF8String];
                  [objc_msgSend(v80, "latlon") latitude];
                  uint64_t v87 = v86;
                  [objc_msgSend(v80, "latlon") longitude];
                  *(_DWORD *)long long buf = 136381187;
                  *(void *)&uint8_t buf[4] = v85;
                  *(_WORD *)&unsigned char buf[12] = 2049;
                  *(void *)&unsigned char buf[14] = v87;
                  *(_WORD *)&buf[22] = 2049;
                  double v213 = v88;
                  _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_INFO, "SelectWifi2, overlap, %{private}s, loi, %{private}.7f, %{private}.7f", buf, 0x20u);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1024193A0 != -1) {
                    dispatch_once(&qword_1024193A0, &stru_10229E160);
                  }
                  id v89 = [[objc_msgSend(v71, "groupId") UTF8String];
                  [objc_msgSend(v80, "latlon") latitude];
                  unint64_t v91 = v90;
                  [objc_msgSend(v80, "latlon") longitude];
                  *(_DWORD *)__int16 v203 = 136381187;
                  *(void *)&v203[4] = v89;
                  __int16 v204 = 2049;
                  unint64_t v205 = v91;
                  __int16 v206 = 2049;
                  double v207 = v92;
                  id v93 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v93);
                  goto LABEL_145;
                }
              }
              else
              {
                id v97 = [v80 relevancy:v76];
                id v98 = v97;
                int v99 = v74 + 1 + v78;
                int v100 = v191;
                if ((unint64_t)v191 >= v192)
                {
                  id v102 = v190;
                  int64_t v103 = (v191 - v190) >> 5;
                  unint64_t v104 = v103 + 1;
                  if ((unint64_t)(v103 + 1) >> 59) {
                    sub_1001D7FD4();
                  }
                  uint64_t v105 = v192 - (void)v190;
                  if ((uint64_t)(v192 - (void)v190) >> 4 > v104) {
                    unint64_t v104 = v105 >> 4;
                  }
                  if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFE0) {
                    unint64_t v106 = 0x7FFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v106 = v104;
                  }
                  if (v106)
                  {
                    uint64_t v107 = (char *)sub_1001D9EDC((uint64_t)&v192, v106);
                    id v102 = v190;
                    int v100 = v191;
                  }
                  else
                  {
                    uint64_t v107 = 0;
                  }
                  id v108 = &v107[32 * v103];
                  *(void *)id v108 = v71;
                  *((double *)v108 + 1) = v82;
                  *((void *)v108 + 2) = v98;
                  *((_DWORD *)v108 + 6) = v99;
                  if (v100 == v102)
                  {
                    uint64_t v110 = &v107[32 * v103];
                  }
                  else
                  {
                    uint64_t v109 = &v107[32 * v103];
                    do
                    {
                      uint64_t v110 = v109 - 32;
                      long long v111 = *((_OWORD *)v100 - 1);
                      *((_OWORD *)v109 - 2) = *((_OWORD *)v100 - 2);
                      *((_OWORD *)v109 - 1) = v111;
                      v100 -= 32;
                      v109 -= 32;
                    }
                    while (v100 != v102);
                  }
                  uint64_t v101 = (uint64_t *)(v108 + 32);
                  long long v190 = v110;
                  long long v191 = v108 + 32;
                  unint64_t v192 = (unint64_t)&v107[32 * v106];
                  if (v102) {
                    operator delete(v102);
                  }
                }
                else
                {
                  *(void *)long long v191 = v71;
                  *((double *)v100 + 1) = v82;
                  *((void *)v100 + 2) = v97;
                  uint64_t v101 = (uint64_t *)(v100 + 32);
                  *((_DWORD *)v100 + 6) = v99;
                }
                long long v191 = (char *)v101;
                if (qword_1024193A0 != -1) {
                  dispatch_once(&qword_1024193A0, &stru_10229E160);
                }
                int v112 = qword_1024193A8;
                if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
                {
                  id v113 = [[[v71 groupId] UTF8String];
                  [objc_msgSend(v80, "latlon") latitude];
                  uint64_t v115 = v114;
                  [objc_msgSend(v80, "latlon") longitude];
                  double v117 = v116;
                  id v118 = [v80 relevancy:v76];
                  *(_DWORD *)long long buf = 136381955;
                  *(void *)&uint8_t buf[4] = v113;
                  *(_WORD *)&unsigned char buf[12] = 2049;
                  *(void *)&unsigned char buf[14] = v115;
                  *(_WORD *)&buf[22] = 2049;
                  double v213 = v117;
                  __int16 v214 = 1026;
                  *(_DWORD *)uint64_t v215 = v99;
                  *(_WORD *)&v215[4] = 2050;
                  *(void *)&v215[6] = v118;
                  *(_WORD *)&v215[14] = 2050;
                  *(void *)&v215[16] = (v191 - v190) >> 5;
                  _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "SelectWifi2, cluster, %{private}s, loi, %{private}.7f, %{private}.7f, priority, %{public}d, relevancy, %{public}llu, n, %{public}ld", buf, 0x3Au);
                }
                if (sub_10013D1A0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1024193A0 != -1) {
                    dispatch_once(&qword_1024193A0, &stru_10229E160);
                  }
                  id v119 = [[objc_msgSend(v71, "groupId") UTF8String];
                  [objc_msgSend(v80, "latlon") latitude];
                  unint64_t v121 = v120;
                  [objc_msgSend(v80, "latlon") longitude];
                  double v123 = v122;
                  id v124 = [v80 relevancy:v76];
                  *(_DWORD *)__int16 v203 = 136381955;
                  *(void *)&v203[4] = v119;
                  __int16 v204 = 2049;
                  unint64_t v205 = v121;
                  __int16 v206 = 2049;
                  double v207 = v123;
                  __int16 v208 = 1026;
                  *(_DWORD *)uint64_t v209 = v99;
                  *(_WORD *)&v209[4] = 2050;
                  *(void *)&v209[6] = v124;
                  *(_WORD *)&v209[14] = 2050;
                  *(void *)&v209[16] = (v191 - v190) >> 5;
                  id v93 = (char *)_os_log_send_and_compose_impl();
                  sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v93);
                  goto LABEL_145;
                }
              }
            }
          }
LABEL_140:
          *(void *)long long buf = &v182;
          sub_1000A7B4C((void ***)buf);
          std::string::size_type v70 = (char *)v70 + 1;
        }
        while (v70 != v69);
        id v125 = [a2 countByEnumeratingWithState:&v184 objects:v202 count:16];
        id v69 = v125;
      }
      while (v125);
    }
    unint64_t v126 = 126 - 2 * __clz((v191 - v190) >> 5);
    if (v191 == v190) {
      uint64_t v127 = 0;
    }
    else {
      uint64_t v127 = v126;
    }
    sub_1001D9F14((double *)v190, (uint64_t *)v191, (uint64_t)buf, v127, 1);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    id v128 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349056;
      *(void *)&uint8_t buf[4] = (v191 - v190) >> 5;
      _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "SelectWifi2, candidates, %{public}ld", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      *(_DWORD *)__int16 v203 = 134349056;
      *(void *)&v203[4] = (v191 - v190) >> 5;
      id v164 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v164);
      if (v164 != buf) {
        free(v164);
      }
    }
    long long v182 = 0uLL;
    unint64_t v183 = 0;
    uint64_t v129 = v191;
    if (v190 == v191) {
      goto LABEL_189;
    }
    double v130 = 0.0;
    uint64_t v131 = (id *)(v190 + 16);
    do
    {
      id v132 = (uint64_t *)[*(v131 - 2) getLocationIds];
      uint64_t v133 = *v132;
      uint64_t v134 = v132[1];
      int v177 = *((_DWORD *)v131 + 2);
      *(void *)long long buf = [objc_msgSend(*(v131 - 2), "groupId") UTF8String];
      id v135 = [*(v131 - 2) getLocationIds];
      *(void *)__int16 v203 = [*(v131 - 2) locationContext];
      uint64_t v136 = *((void *)&v182 + 1);
      if (*((void *)&v182 + 1) >= v183)
      {
        uint64_t v138 = sub_1001D9B3C((uint64_t *)&v182, (char **)buf, (uint64_t)v135, v131, v203, &v177);
      }
      else
      {
        sub_100134750(*((void **)&v182 + 1), *(char **)buf);
        *(void *)(v136 + 24) = v135;
        uint64_t v137 = *(void *)v203;
        *(void *)(v136 + 32) = *v131;
        *(void *)(v136 + 40) = v137;
        *(_DWORD *)(v136 + 48) = v177;
        uint64_t v138 = v136 + 56;
      }
      *((void *)&v182 + 1) = v138;
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      *(void *)&v130 += 0xAAAAAAAAAAAAAAABLL * ((v134 - v133) >> 3);
      unint64_t v139 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        id v140 = [[objc_msgSend(*(v131 - 2), "groupId") UTF8String];
        *(_DWORD *)long long buf = 136381443;
        *(void *)&uint8_t buf[4] = v140;
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(void *)&unsigned char buf[14] = 0xAAAAAAAAAAAAAAABLL * ((v134 - v133) >> 3);
        *(_WORD *)&buf[22] = 2050;
        double v213 = v130;
        __int16 v214 = 1026;
        *(_DWORD *)uint64_t v215 = v177;
        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "SelectWifi2, tile, %{private}s, floors, %{public}ld, total, %{public}ld, priority, %{public}d", buf, 0x26u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        id v143 = [[objc_msgSend(*(v131 - 2), "groupId") UTF8String];
        *(_DWORD *)__int16 v203 = 136381443;
        *(void *)&v203[4] = v143;
        __int16 v204 = 2050;
        unint64_t v205 = 0xAAAAAAAAAAAAAAABLL * ((v134 - v133) >> 3);
        __int16 v206 = 2050;
        double v207 = v130;
        __int16 v208 = 1026;
        *(_DWORD *)uint64_t v209 = v177;
        std::string::size_type v144 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v144);
        if (v144 != buf) {
          free(v144);
        }
      }
      unint64_t v141 = (char *)(v131 + 2);
      v131 += 4;
    }
    while (*(void *)&v130 <= a3 && v141 != v129);
    if ((void)v182 == *((void *)&v182 + 1))
    {
LABEL_189:
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v148 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "SelectWifi2, selected, none", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        *(_WORD *)__int16 v203 = 0;
        __int16 v165 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v165);
        if (v165 != buf) {
          free(v165);
        }
      }
      __int16 v147 = a7;
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      std::string::size_type v146 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134349312;
        *(void *)&uint8_t buf[4] = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v182 + 1) - v182) >> 3);
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(double *)&unsigned char buf[14] = v130;
        _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "SelectWifi2, selected, venues, %{public}ld, floors, %{public}ld", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        *(_DWORD *)__int16 v203 = 134349312;
        *(void *)&v203[4] = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v182 + 1) - v182) >> 3);
        __int16 v204 = 2050;
        unint64_t v205 = *(void *)&v130;
        double v166 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v166);
        if (v166 != buf) {
          free(v166);
        }
      }
      *a7 = v182;
      *((void *)a7 + 2) = v183;
      __int16 v147 = &v182;
    }
    *(void *)__int16 v147 = 0;
    *((void *)v147 + 1) = 0;
    *((void *)v147 + 2) = 0;
    *(void *)long long buf = &v182;
    sub_1001D9A98((void ***)buf);
    sub_1001D84E8((uint64_t)v188);
    if (v190)
    {
      long long v191 = v190;
      operator delete(v190);
    }
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v145 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "SelectWifi2, noclusters, #Warning", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      *(_WORD *)__int16 v203 = 0;
      id v160 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "vector<tuple<string, const vector<string> &, system_clock::time_point, CLPipelinedLocationContext, int>> selectRegionalPrefetchVenues(const std::vector<CLIndoorPrefetchLocationOfInterest> &, NSArray<CLLocationGroup *> *, double, size_t, double, std::chrono::seconds, const boost::optional<CLLastFix> &, std::chrono::system_clock::time_point)", "%s\n", v160);
      if (v160 != buf) {
        free(v160);
      }
    }
    *(void *)a7 = 0;
    *((void *)a7 + 1) = 0;
    *((void *)a7 + 2) = 0;
  }
}

void sub_1001D6794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,void *a55)
{
  STACK[0x440] = (unint64_t)&a37;
  sub_1001D9A98((void ***)&STACK[0x440]);
  sub_1001D84E8((uint64_t)&a49);
  if (a54)
  {
    a55 = a54;
    operator delete(a54);
  }
  _Unwind_Resume(a1);
}

void *sub_1001D68B4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419758, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419758))
  {
    operator new();
  }
  uint64_t result = off_102419750;
  if (*((char *)off_102419750 + 23) < 0) {
    return *(void **)off_102419750;
  }
  return result;
}

void sub_1001D69AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_1001D69FC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ([*(id *)(a1 + 8) avlTilePathOverrideForTest]) {
    uint64_t v5 = (NSURL *)[*(id *)(a1 + 8) avlTilePathOverrideForTest];
  }
  else {
    uint64_t v5 = sub_1001CE15C();
  }
  uint64_t v6 = v5;
  id v7 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0x8E38E38E38E38E39 * ((a3[1] - *a3) >> 3)];
  unsigned int v8 = (double *)*a3;
  std::string::size_type v9 = (double *)a3[1];
  int v63 = a3;
  if ((double *)*a3 != v9)
  {
    do
    {
      id v10 = objc_alloc((Class)GeographicCoordinate);
      double v11 = *v8;
      double v12 = v8[1];
      v8 += 9;
      id v13 = [v10 initWithLatitude:v11 longitude:v12 andAltitude:0.0];
      [v7 addObject:v13];
    }
    while (v8 != v9);
  }
  id v14 = [objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") getNearbyLocationGroups:v6 withUpdatedPos:0 nearLocationsOfInterest:v7];

  if (v14)
  {
    uint64_t v65 = a1;
    [*(id *)(a1 + 8) updatePrefetchParameters:[objc_msgSend(*(id *)(a1 + 8), "availableVenuesState") availabilityTileParams]];
    uint64_t v15 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v14 count]);
    uint64_t v16 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v14 count]);
    long long v69 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    id v17 = [v14 countByEnumeratingWithState:&v69 objects:v87 count:16];
    if (v17)
    {
      uint64_t v18 = *(void *)v70;
      do
      {
        int v19 = 0;
        do
        {
          if (*(void *)v70 != v18) {
            objc_enumerationMutation(v14);
          }
          id v20 = *(void **)(*((void *)&v69 + 1) + 8 * (void)v19);
          if (+[CLLocationContextUtil isRegional:](CLLocationContextUtil, "isRegional:", [v20 locationContext]))
          {
            [(NSMutableArray *)v16 addObject:v20];
          }
          else if (+[CLLocationContextUtil isIndoor:](CLLocationContextUtil, "isIndoor:", [v20 locationContext]))
          {
            [(NSMutableArray *)v15 addObject:v20];
          }
          else
          {
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10229E160);
            }
            uint64_t v21 = qword_1024193A8;
            if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_ERROR))
            {
              if (v20)
              {
                [v20 getGroupId];
                uint64_t v22 = __p;
                if (SHIBYTE(__p[2]) < 0) {
                  uint64_t v22 = (void **)__p[0];
                }
              }
              else
              {
                memset(__p, 0, 24);
                uint64_t v22 = __p;
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Group %s has neither indoor nor regional locations", (uint8_t *)&buf, 0xCu);
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
            }
            if (sub_10013D1A0(115, 0))
            {
              bzero(__p, 0x65CuLL);
              if (qword_1024193A0 != -1) {
                dispatch_once(&qword_1024193A0, &stru_10229E160);
              }
              if (v20)
              {
                [v20 getGroupId];
                p_std::string buf = &buf;
                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                }
              }
              else
              {
                memset(&buf, 0, sizeof(buf));
                p_std::string buf = &buf;
              }
              LODWORD(v75) = 136315138;
              *(void *)((char *)&v75 + 4) = p_buf;
              long long v24 = (char *)_os_log_send_and_compose_impl();
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLIndoorLogic::onPrefetchRequested(std::chrono::system_clock::time_point, const std::vector<CLIndoorPrefetchLocationOfInterest> &)", "%s\n", v24);
              if (v24 != (char *)__p) {
                free(v24);
              }
            }
          }
          int v19 = (char *)v19 + 1;
        }
        while (v17 != v19);
        id v25 = [v14 countByEnumeratingWithState:&v69 objects:v87 count:16];
        id v17 = v25;
      }
      while (v25);
    }
    uint64_t v26 = (id *)(v65 + 16);
    unsigned __int8 v27 = [*(id *)(v65 + 16) indoorTilePrefetchRadius];
    double v29 = v28;
    unint64_t v30 = (id *)(v65 + 8);
    [*(id *)(v65 + 8) indoorPrefetchRadiusMeters];
    if (v27) {
      id v32 = v29;
    }
    else {
      id v32 = v31;
    }
    unsigned __int8 v33 = [*v26 indoorTilePrefetchMaxCount];
    uint64_t v35 = v34;
    id v36 = [*v30 indoorPrefetchMaxFloorsPerPrefetch];
    if (!v33) {
      uint64_t v35 = v36;
    }
    unsigned __int8 v37 = [*v26 indoorPrefetchClusterMergeRadius];
    uint64_t v39 = v38;
    [*v30 indoorPrefetchClusterMergeRadius];
    if (v37) {
      id v41 = v39;
    }
    else {
      id v41 = v40;
    }
    unsigned __int8 v42 = [*v26 regionalTilePrefetchMaxCount];
    unint64_t v44 = v43;
    id v45 = [*v30 regionalPrefetchMaxFloorsPerPrefetch];
    if (!v42) {
      unint64_t v44 = (unint64_t)v45;
    }
    id v46 = [*v26 tilePrefetchRelevancyWindow];
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v47 = (uint64_t)v46 - 64800;
    uint64_t v48 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(__p[0]) = 134219520;
      *(void **)((char *)__p + 4) = v32;
      WORD2(__p[1]) = 2048;
      *(void **)((char *)&__p[1] + 6) = v35;
      HIWORD(__p[2]) = 2048;
      __p[3] = v41;
      __int16 v89 = 2048;
      uint64_t v90 = 0x4085180000000000;
      __int16 v91 = 2048;
      unint64_t v92 = v44;
      __int16 v93 = 2048;
      uint64_t v94 = 0x4049000000000000;
      __int16 v95 = 2048;
      double v96 = (double)v47 / 86400.0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, "Prefetch parameters: indoor={radius=%lf,max-floors=%zu,cluster-merge-radius=%lf},regional={radius=%lf,max-floors=%zu,cluster-merge-radius=%lf},loi-max-age=%Lf", (uint8_t *)__p, 0x48u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 134219520;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
      uint64_t v78 = v41;
      __int16 v79 = 2048;
      uint64_t v80 = 0x4085180000000000;
      __int16 v81 = 2048;
      unint64_t v82 = v44;
      __int16 v83 = 2048;
      uint64_t v84 = 0x4049000000000000;
      __int16 v85 = 2048;
      double v86 = (double)v47 / 86400.0;
      double v60 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onPrefetchRequested(std::chrono::system_clock::time_point, const std::vector<CLIndoorPrefetchLocationOfInterest> &)", "%s\n", v60);
      if (v60 != (char *)__p) {
        free(v60);
      }
    }
    sub_1001D1AB4(v63, v15, (unint64_t)v35, v47, (unsigned __int8 *)[*(id *)(v65 + 8) latestPosition], a2, &buf, *(double *)&v32, *(double *)&v41);
    long long v75 = 0uLL;
    uint64_t v76 = 0;
    if (sub_10016CCBC())
    {
      sub_1001D4654(v63, v16, v44, v47, (unsigned __int8 *)[*(id *)(v65 + 8) latestPosition], a2, (long long *)__p, 675.0, 50.0);
      sub_1001DB0D8((uint64_t *)&v75);
      long long v75 = *(_OWORD *)__p;
      uint64_t v76 = __p[2];
      memset(__p, 0, 24);
      uint64_t v66 = __p;
      sub_1001D9A98(&v66);
      uint64_t v49 = v65;
    }
    else
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      uint64_t v52 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "SelectWifi2, unsupported device", (uint8_t *)__p, 2u);
      }
      uint64_t v49 = v65;
      if (sub_10013D1A0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        LOWORD(v66) = 0;
        id v61 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onPrefetchRequested(std::chrono::system_clock::time_point, const std::vector<CLIndoorPrefetchLocationOfInterest> &)", "%s\n", v61);
        if (v61 != (char *)__p) {
          free(v61);
        }
      }
    }
    uint64_t v66 = 0;
    id v67 = 0;
    unint64_t v68 = 0;
    std::string::size_type size = buf.__r_.__value_.__l.__size_;
    unint64_t v54 = (long long *)buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0] == buf.__r_.__value_.__l.__size_)
    {
      id v55 = 0;
    }
    else
    {
      id v55 = 0;
      do
      {
        if ((unint64_t)v55 >= v68)
        {
          id v55 = (char *)sub_1001DB114((uint64_t *)&v66, v54);
        }
        else
        {
          sub_1001DB234(v55, v54);
          v55 += 56;
        }
        id v67 = v55;
        unint64_t v54 = (long long *)((char *)v54 + 56);
      }
      while (v54 != (long long *)size);
    }
    id v56 = (long long *)*((void *)&v75 + 1);
    for (uint64_t i = (long long *)v75; i != v56; uint64_t i = (long long *)((char *)i + 56))
    {
      if ((unint64_t)v55 >= v68)
      {
        id v55 = (char *)sub_1001DB114((uint64_t *)&v66, i);
      }
      else
      {
        sub_1001DB234(v55, i);
        v55 += 56;
      }
      id v67 = v55;
    }
    if (v66 == (void **)v55)
    {
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      id v59 = qword_1024193A8;
      if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "IndoorPreFetch, skipall, No venues around clusters, #Warning", (uint8_t *)__p, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_1024193A0 != -1) {
          dispatch_once(&qword_1024193A0, &stru_10229E160);
        }
        unint64_t v62 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onPrefetchRequested(std::chrono::system_clock::time_point, const std::vector<CLIndoorPrefetchLocationOfInterest> &)", "%s\n", v62);
        if (v62 != (char *)__p) {
          free(v62);
        }
      }
    }
    else
    {
      id v58 = *(void **)(v49 + 8);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = std::chrono::steady_clock::now().__d_.__rep_;
      v73[0] = 1;
      [v58 setLastPrefetchTimestamp:v73];
      if (v73[0]) {
        v73[0] = 0;
      }
      (*(void (**)(void, void ***))(**(void **)(v49 + 24) + 176))(*(void *)(v49 + 24), &v66);
    }
    __p[0] = &v66;
    sub_1001D9A98((void ***)__p);
    __p[0] = &v75;
    sub_1001D9A98((void ***)__p);
    __p[0] = &buf;
    sub_1001D9A98((void ***)__p);
  }
  else
  {
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v50 = qword_1024193A8;
    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_INFO))
    {
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)[(NSString *)[(NSURL *)v6 path] UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_INFO, "#warning, no location groups returned from %s during prefetch, possibly due to missing tile", (uint8_t *)__p, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193A0 != -1) {
        dispatch_once(&qword_1024193A0, &stru_10229E160);
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)[(NSString *)[(NSURL *)v6 path] UTF8String];
      uint64_t v51 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLIndoorLogic::onPrefetchRequested(std::chrono::system_clock::time_point, const std::vector<CLIndoorPrefetchLocationOfInterest> &)", "%s\n", v51);
      if (v51 != (char *)__p) {
        free(v51);
      }
    }
  }
}

void sub_1001D76D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void **a63)
{
  a63 = (void **)&a19;
  sub_1001D9A98(&a63);
  a63 = (void **)&a33;
  sub_1001D9A98(&a63);
  a63 = (void **)&a37;
  sub_1001D9A98(&a63);
  _Unwind_Resume(a1);
}

const char *sub_1001D7758(unsigned int a1)
{
  if (a1 < 0xB) {
    return (&off_10229E1D0)[a1];
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v3 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::string buf = 67240192;
    unsigned int v6 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Corrupt KeepOffReason (short): got %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "const char *to_string(KeepOffReason)", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return "Unknown";
}

BOOL sub_1001D7924(uint64_t a1, uint64_t a2)
{
  BOOL result = sub_1001D1A5C(a1);
  if (result)
  {
    if ([*(id *)(a1 + 8) wifiAssociated]) {
      return 0;
    }
    uint64_t v5 = *(void **)(a1 + 8);
    if (!v5) {
      goto LABEL_45;
    }
    [v5 lastPrefetchTimestamp];
    if (!buf[0]) {
      goto LABEL_45;
    }
    unsigned int v6 = *(void **)(a1 + 8);
    if (v6)
    {
      [v6 lastPrefetchTimestamp];
      unsigned int v6 = *(void **)(a1 + 8);
    }
    else
    {
      long long v28 = 0uLL;
    }
    id v7 = [v6 lastIndoorError];
    if (!*(unsigned char *)v7) {
      sub_101A503C0();
    }
    if ((_BYTE)v28 && v7[1] < *((uint64_t *)&v28 + 1))
    {
      return 0;
    }
    else
    {
LABEL_45:
      if ([*(id *)(a1 + 8) pipelinedVenues])
      {
        if ([*(id *)(a1 + 8) locationGroupsLoaded])
        {
          id v8 = [*(id *)(a1 + 8) locationGroups];
          long long v23 = 0u;
          long long v24 = 0u;
          long long v21 = 0u;
          long long v22 = 0u;
          id v9 = [v8 countByEnumeratingWithState:&v21 objects:v27 count:16];
          if (v9)
          {
            uint64_t v10 = *(void *)v22;
            do
            {
              double v11 = 0;
              do
              {
                if (*(void *)v22 != v10) {
                  objc_enumerationMutation(v8);
                }
                double v12 = *(void **)(*((void *)&v21 + 1) + 8 * (void)v11);
                if (objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "pipelinedVenues"), "containsObject:", objc_msgSend(@"G", "stringByAppendingString:", objc_msgSend(v12, "groupId"))))
                {
                  id v13 = [v12 getLocationIds];
                  if (*v13 == v13[1])
                  {
                    if (qword_1024193A0 != -1) {
                      dispatch_once(&qword_1024193A0, &stru_10229E160);
                    }
                    id v14 = qword_1024193A8;
                    if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
                    {
                      id v15 = [v12 groupId];
                      *(_DWORD *)std::string buf = 138412290;
                      id v26 = v15;
                      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#Warning Skipping location group %@ - it has no floors", buf, 0xCu);
                    }
                    if (sub_10013D1A0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1024193A0 != -1) {
                        dispatch_once(&qword_1024193A0, &stru_10229E160);
                      }
                      id v16 = [v12 groupId];
                      LODWORD(v28) = 138412290;
                      *(void *)((char *)&v28 + 4) = v16;
                      id v17 = (char *)_os_log_send_and_compose_impl();
                      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLIndoorLogic::shouldBackoffFromWifiOnlyDownloadError(std::chrono::steady_clock::time_point) const", "%s\n", v17);
                      if (v17 != (char *)buf) {
                        free(v17);
                      }
                    }
                  }
                  else if (+[CLLocationContextUtil isIndoor:](CLLocationContextUtil, "isIndoor:", [v12 locationContext]))
                  {
                    return 0;
                  }
                }
                double v11 = (char *)v11 + 1;
              }
              while (v9 != v11);
              id v18 = [v8 countByEnumeratingWithState:&v21 objects:v27 count:16];
              id v9 = v18;
            }
            while (v18);
          }
        }
      }
      int v19 = [*(id *)(a1 + 8) lastIndoorError];
      if (!*(unsigned char *)v19) {
        sub_101A503C0();
      }
      if (sub_1001D1A5C(a1)) {
        uint64_t v20 = 300000000000;
      }
      else {
        uint64_t v20 = (uint64_t)[*(id *)(a1 + 16) errorBackoffDuration];
      }
      return v19[1] + v20 > a2;
    }
  }
  return result;
}

const char *sub_1001D7CE4(unsigned int a1)
{
  if (a1 < 0xB) {
    return (&off_10229E228)[a1];
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10229E160);
  }
  uint64_t v3 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::string buf = 67240192;
    unsigned int v6 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Corrupt TurnOffReason: got %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10229E160);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "const char *to_string(TurnOffReason)", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return "Unknown";
}

void sub_1001D7EB0(id a1)
{
  qword_1024193A8 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_1001D7EE0(id a1)
{
  qword_102419638 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_1001D7F10(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1001D7F6C(exception, a1);
}

void sub_1001D7F58(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1001D7F6C(std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  return result;
}

void sub_1001D7FA0()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void sub_1001D7FD4()
{
}

uint64_t sub_1001D7FEC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1001D8064((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1001D8064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _OWORD v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  sub_1001D8104((uint64_t)v12);
  return a6;
}

uint64_t sub_1001D8104(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1001D813C(a1);
  }
  return a1;
}

void sub_1001D813C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_1001D8184(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1001D81BC(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_1001D8214(std::string *this, uint64_t a2, std::string::value_type *a3, std::string::value_type *a4, std::string::size_type __n_add)
{
  uint64_t v6 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v9 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::size_type v7 = a2 - this->__r_.__value_.__r.__words[0];
    if (__n_add)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    uint64_t v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    return (uint64_t)v6 + v7;
  }
  std::string::size_type v7 = a2 - (void)this;
  if (!__n_add) {
    return (uint64_t)v6 + v7;
  }
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  uint64_t v9 = this;
LABEL_6:
  if (v9 <= (std::string *)a3 && (char *)&v9->__r_.__value_.__l.__data_ + size + 1 > a3)
  {
    sub_1001D8460(&__p, a3, a4);
    std::string::size_type v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v10 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v12 = sub_1001D8344(v6, __n_add, v7, (char *)p_p, (char *)p_p + v10);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return v12;
  }

  return sub_1001D8344(this, __n_add, v7, a3, a4);
}

void sub_1001D8328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001D8344(std::string *this, std::string::size_type __n_add, std::string::size_type __n_copy, char *a4, char *a5)
{
  uint64_t v9 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    std::string::size_type v11 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v11 - size >= __n_add)
    {
      uint64_t v12 = (std::string *)this->__r_.__value_.__r.__words[0];
      goto LABEL_7;
    }
  }
  else
  {
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v11 = 22;
    uint64_t v12 = this;
    if (22 - size >= __n_add)
    {
LABEL_7:
      size_t v13 = size - __n_copy;
      if (size == __n_copy) {
        std::string::size_type size = __n_copy;
      }
      else {
        memmove((char *)v12 + __n_copy + __n_add, (char *)v12 + __n_copy, v13);
      }
      goto LABEL_10;
    }
  }
  std::string::__grow_by(this, v11, size + __n_add - v11, size, __n_copy, 0, __n_add);
  v9->__r_.__value_.__l.__size_ = size + __n_add;
  uint64_t v12 = (std::string *)v9->__r_.__value_.__r.__words[0];
LABEL_10:
  std::string::size_type v14 = size + __n_add;
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0) {
    v9->__r_.__value_.__l.__size_ = v14;
  }
  else {
    *((unsigned char *)&v9->__r_.__value_.__s + 23) = v14 & 0x7F;
  }
  v12->__r_.__value_.__s.__data_[v14] = 0;
  if (a4 != a5)
  {
    long long v15 = (char *)v12 + __n_copy;
    do
    {
      char v16 = *a4++;
      *v15++ = v16;
    }
    while (a4 != a5);
  }
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0) {
    uint64_t v9 = (std::string *)v9->__r_.__value_.__r.__words[0];
  }
  return (uint64_t)v9 + __n_copy;
}

void sub_1001D8460(std::string *this, std::string::value_type *a2, std::string::value_type *a3)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
      std::string::push_back(this, *v4++);
    while (v4 != a3);
  }
}

void sub_1001D84B8(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __cxa_rethrow();
}

void sub_1001D84D4(_Unwind_Exception *a1)
{
}

uint64_t sub_1001D84E8(uint64_t a1)
{
  sub_1001D8524(a1, *(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1001D8524(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      if (*((unsigned char *)v2 + 40)) {
        *((unsigned char *)v2 + 40) = 0;
      }
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

char *sub_1001D857C(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1000DA584(result, a4);
    uint64_t result = sub_1001D8604((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }
  return result;
}

void sub_1001D85E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1000A7B4C(&a9);
  _Unwind_Resume(a1);
}

char *sub_1001D8604(uint64_t a1, long long *a2, long long *a3, char *__dst)
{
  uint64_t v4 = __dst;
  std::string::size_type v11 = __dst;
  uint64_t v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_1000DC48C(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v4 = v12;
      }
      else
      {
        long long v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
      }
      uint64_t v6 = (long long *)((char *)v6 + 24);
      v4 += 24;
      uint64_t v12 = v4;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_1000DC52C((uint64_t)v9);
  return v4;
}

void sub_1001D86B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1001D86C4(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0) {
      operator delete(*(void **)(v1 - 24));
    }
    v1 -= 24;
  }
}

void *sub_1001D870C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    std::string::size_type v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(void **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (sub_100103744(a1 + 32, (unsigned __int8 *)i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  id v17 = (void *)(a1 + 16);
  uint64_t i = operator new(0x38uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v10;
  id v18 = *a4;
  long long v19 = **a4;
  *((void *)i + 4) = *((void *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *(void *)id v18 = 0;
  *((unsigned char *)i + 40) = 0;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100100330(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v26 = *(void *)a1;
  unsigned __int8 v27 = *(void **)(*(void *)a1 + 8 * v4);
  if (v27)
  {
    *(void *)uint64_t i = *v27;
LABEL_38:
    *unsigned __int8 v27 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v17;
  *id v17 = i;
  *(void *)(v26 + 8 * v4) = v17;
  if (*(void *)i)
  {
    unint64_t v28 = *(void *)(*(void *)i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11) {
        v28 %= v11;
      }
    }
    else
    {
      v28 &= v11 - 1;
    }
    unsigned __int8 v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_38;
  }
LABEL_39:
  ++*v8;
  return i;
}

void sub_1001D897C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_1001D8998(v11, v10);
  _Unwind_Resume(a1);
}

void sub_1001D8998(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((unsigned char *)__p + 40)) {
      *((unsigned char *)__p + 40) = 0;
    }
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_1001D8A04(uint64_t a1, double *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (uint64_t)a2 - v11;
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v11) >> 3);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*(a2 - 2) < *(double *)(v11 + 8))
          {
            uint64_t v28 = *(void *)v11;
            *(double *)unint64_t v11 = *(a2 - 3);
            *((void *)a2 - 3) = v28;
            uint64_t v29 = *(void *)(v11 + 8);
            *(double *)(v11 + 8) = *(a2 - 2);
            *((void *)a2 - 2) = v29;
            uint64_t v30 = *(void *)(v11 + 16);
            *(double *)(v11 + 16) = *(a2 - 1);
            *((void *)a2 - 1) = v30;
          }
          break;
        case 3uLL:
          sub_1001D8F48((void *)v11, (uint64_t *)(v11 + 24), (uint64_t *)a2 - 3);
          break;
        case 4uLL:
          sub_1001D9498(v11, (uint64_t *)(v11 + 24), (uint64_t *)(v11 + 48), (uint64_t)(a2 - 3));
          break;
        case 5uLL:
          sub_1001D9594(v11, (uint64_t *)(v11 + 24), (uint64_t *)(v11 + 48), (double *)(v11 + 72), a2 - 3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 575) {
      break;
    }
    if (v13 == 1)
    {
      if ((double *)v11 != a2)
      {
        sub_1001D96DC(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    id v17 = (uint64_t *)(v11 + 24 * (v15 >> 1));
    if ((unint64_t)v14 >= 0xC01)
    {
      sub_1001D8F48((void *)v11, (uint64_t *)(v11 + 24 * (v15 >> 1)), (uint64_t *)a2 - 3);
      uint64_t v18 = 3 * v16;
      long long v19 = (uint64_t *)(v11 + 24 * v16 - 24);
      sub_1001D8F48((void *)(v11 + 24), v19, (uint64_t *)a2 - 6);
      float v20 = (void *)(v11 + 48);
      float v21 = (uint64_t *)(v11 + 24 + 8 * v18);
      sub_1001D8F48(v20, v21, (uint64_t *)a2 - 9);
      sub_1001D8F48(v19, v17, v21);
      double v22 = *(double *)a1;
      *(void *)a1 = *v17;
      *(double *)id v17 = v22;
      uint64_t v23 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v17[1];
      v17[1] = v23;
      uint64_t v24 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v17[2];
      void v17[2] = v24;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_1001D8F48((void *)(v11 + 24 * (v15 >> 1)), (uint64_t *)v11, (uint64_t *)a2 - 3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(double *)(a1 - 16) >= *(double *)(a1 + 8))
    {
      unint64_t v11 = sub_1001D9090((double *)a1, a2);
      goto LABEL_18;
    }
LABEL_13:
    unint64_t v25 = sub_1001D919C((double *)a1, a2);
    if ((v26 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v27 = sub_1001D92AC(a1, v25);
    unint64_t v11 = v25 + 24;
    if (sub_1001D92AC(v25 + 24, (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (double *)v25;
      if (v27) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v27)
    {
LABEL_16:
      sub_1001D8A04(a1, v25, a3, -v13, a5 & 1);
      unint64_t v11 = v25 + 24;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1001D8E24(v11, a2);
  }
  else
  {
    sub_1001D8EC4((void *)v11, a2);
  }
}

  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 5;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 3) < v11[1])
          {
            uint64_t v24 = *(void *)v11;
            *(void *)unint64_t v11 = *(a2 - 4);
            *(a2 - 4) = v24;
            unint64_t v25 = *((void *)v11 + 1);
            *((void *)v11 + 1) = *(a2 - 3);
            *(a2 - 3) = v25;
            char v26 = *((void *)v11 + 2);
            *((void *)v11 + 2) = *(a2 - 2);
            *(a2 - 2) = v26;
            LODWORD(v26) = *((_DWORD *)v11 + 6);
            *((_DWORD *)v11 + 6) = *((_DWORD *)a2 - 2);
            *((_DWORD *)a2 - 2) = v26;
          }
          break;
        case 3uLL:
          sub_1001DA478((uint64_t *)v11, (uint64_t *)v11 + 4, a2 - 4);
          break;
        case 4uLL:
          sub_1001DAA6C((uint64_t)v11, (uint64_t)(v11 + 4), (uint64_t)(v11 + 8), (uint64_t)(a2 - 4));
          break;
        case 5uLL:
          sub_1001DAB98((uint64_t)v11, (uint64_t)(v11 + 4), (uint64_t)(v11 + 8), (uint64_t)(v11 + 12), (uint64_t)(a2 - 4));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 767) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != (double *)a2)
      {
        sub_1001DAD20((uint64_t)v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    id v17 = &v11[4 * (v15 >> 1)];
    if ((unint64_t)v14 > 0x1000)
    {
      sub_1001DA478((uint64_t *)v11, (uint64_t *)&v11[4 * (v15 >> 1)], a2 - 4);
      sub_1001DA478((uint64_t *)v11 + 4, (uint64_t *)v17 - 4, a2 - 8);
      sub_1001DA478((uint64_t *)v11 + 8, (uint64_t *)&v11[4 * v16 + 4], a2 - 12);
      sub_1001DA478((uint64_t *)v17 - 4, (uint64_t *)v17, (uint64_t *)&v11[4 * v16 + 4]);
      uint64_t v18 = *(void *)v11;
      *unint64_t v11 = *v17;
      *(void *)id v17 = v18;
      long long v19 = *((void *)v11 + 1);
      v11[1] = v17[1];
      *((void *)v17 + 1) = v19;
      float v20 = *((void *)v11 + 2);
      _OWORD v11[2] = v17[2];
      *((void *)v17 + 2) = v20;
      LODWORD(v20) = *((_DWORD *)v11 + 6);
      *((_DWORD *)v11 + 6) = *((_DWORD *)v17 + 6);
      *((_DWORD *)v17 + 6) = v20;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_1001DA478((uint64_t *)&v11[4 * (v15 >> 1)], (uint64_t *)v11, a2 - 4);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(v11 - 3) >= v11[1])
    {
      unint64_t v11 = sub_1001DA610((uint64_t *)v11, (unint64_t)a2);
      goto LABEL_18;
    }
LABEL_13:
    float v21 = sub_1001DA73C(v11, (unint64_t)a2);
    if ((v22 & 1) == 0) {
      goto LABEL_16;
    }
    uint64_t v23 = sub_1001DA86C((uint64_t)v11, (uint64_t)v21);
    unint64_t v11 = (double *)(v21 + 4);
    if (sub_1001DA86C((uint64_t)(v21 + 4), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = v21;
      if (v23) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v23)
    {
LABEL_16:
      sub_1001D9F14(a1, v21, a3, -v13, a5 & 1);
      unint64_t v11 = (double *)(v21 + 4);
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1001DA334((uint64_t)v11, a2);
  }
  else
  {
    sub_1001DA3E4(v11, a2);
  }
}

  uint64_t v8 = (long long *)a2;
  unint64_t v9 = a2 - 30;
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (char *)v8 - (char *)v10;
    uint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v8 - (char *)v10) >> 4);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          id v102 = bswap64(*(a2 - 30));
          int64_t v103 = bswap64(*a1);
          if (v102 != v103 || (v102 = bswap64(*(a2 - 29)), int64_t v103 = bswap64(a1[1]), v102 != v103))
          {
            if (v102 < v103) {
              int v212 = -1;
            }
            else {
              int v212 = 1;
            }
            if (v212 < 0) {
              sub_10028B0FC((long long *)a1, (long long *)a2 - 15);
            }
          }
          break;
        case 3uLL:
          sub_10028D1C0(a1, a1 + 30, v9);
          break;
        case 4uLL:
          sub_10028D7B4(a1, a1 + 30, a1 + 60, v9);
          break;
        case 5uLL:
          sub_10028D000(a1, a1 + 30, a1 + 60, a1 + 90, v9);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5759) {
      break;
    }
    if (!a3)
    {
      if (a1 != (unint64_t *)v8)
      {
        uint64_t v127 = (v12 - 2) >> 1;
        id v128 = v127;
        do
        {
          uint64_t v129 = v128;
          if (v127 >= v128)
          {
            double v130 = (2 * v128) | 1;
            uint64_t v131 = &a1[30 * v130];
            if (2 * v128 + 2 < (uint64_t)v12)
            {
              id v132 = bswap64(*v131);
              uint64_t v133 = bswap64(v131[30]);
              if (v132 == v133 && (v132 = bswap64(v131[1]), uint64_t v133 = bswap64(v131[31]), v132 == v133)) {
                uint64_t v134 = 0;
              }
              else {
                uint64_t v134 = v132 < v133 ? -1 : 1;
              }
              if (v134 < 0)
              {
                v131 += 30;
                double v130 = 2 * v128 + 2;
              }
            }
            id v135 = &a1[30 * v128];
            uint64_t v136 = bswap64(*v131);
            uint64_t v137 = bswap64(*v135);
            if (v136 == v137 && (uint64_t v136 = bswap64(v131[1]), v137 = bswap64(v135[1]), v136 == v137)
              || (v136 < v137 ? (uint64_t v138 = -1) : (uint64_t v138 = 1), (v138 & 0x80000000) == 0))
            {
              unint64_t v139 = *(_OWORD *)v135;
              uint64_t v244 = v135[2];
              __int16 v243 = v139;
              id v140 = &a1[30 * v129];
              unint64_t v141 = *(_OWORD *)(v140 + 3);
              double v246 = v140[5];
              std::string __p = v141;
              v140[4] = 0;
              v140[5] = 0;
              v140[3] = 0;
              unint64_t v142 = *((_OWORD *)v140 + 3);
              *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v140 + 60);
              v247[0] = v142;
              sub_1002660C8(v248);
              id v143 = &a1[30 * v129];
              std::string::size_type v144 = *(_OWORD *)(v143 + 27);
              double v250 = *((unsigned char *)v143 + 232);
              __int16 v249 = v144;
              do
              {
                uint64_t v145 = v131;
                std::string::size_type v146 = *(_OWORD *)v131;
                v135[2] = v131[2];
                *(_OWORD *)id v135 = v146;
                __int16 v147 = (void **)(v135 + 3);
                if (*((char *)v135 + 47) < 0) {
                  operator delete(*v147);
                }
                id v148 = *(_OWORD *)(v145 + 3);
                v135[5] = v145[5];
                *(_OWORD *)__int16 v147 = v148;
                *((unsigned char *)v145 + 47) = 0;
                *((unsigned char *)v145 + 24) = 0;
                id v149 = *((_OWORD *)v145 + 3);
                *(_OWORD *)((char *)v135 + 60) = *(_OWORD *)((char *)v145 + 60);
                *((_OWORD *)v135 + 3) = v149;
                sub_100267D64((uint64_t)(v135 + 10), (uint64_t)(v145 + 10));
                id v150 = *(_OWORD *)(v145 + 27);
                *((unsigned char *)v135 + 232) = *((unsigned char *)v145 + 232);
                *(_OWORD *)(v135 + 27) = v150;
                if (v127 < v130) {
                  break;
                }
                uint64_t v131 = &a1[30 * ((2 * v130) | 1)];
                if (2 * v130 + 2 < (uint64_t)v12)
                {
                  id v151 = bswap64(*v131);
                  double v152 = bswap64(v131[30]);
                  if (v151 == v152 && (id v151 = bswap64(v131[1]), v152 = bswap64(v131[31]), v151 == v152)) {
                    id v153 = 0;
                  }
                  else {
                    id v153 = v151 < v152 ? -1 : 1;
                  }
                  if (v153 >= 0)
                  {
                    double v130 = (2 * v130) | 1;
                  }
                  else
                  {
                    v131 += 30;
                    double v130 = 2 * v130 + 2;
                  }
                }
                else
                {
                  double v130 = (2 * v130) | 1;
                }
                unint64_t v154 = bswap64(*v131);
                int v155 = bswap64(v243);
                if (v154 == v155
                  && (unint64_t v154 = bswap64(v131[1]), v155 = bswap64(*((unint64_t *)&v243 + 1)), v154 == v155))
                {
                  id v156 = 0;
                }
                else
                {
                  id v156 = v154 < v155 ? -1 : 1;
                }
                id v135 = v145;
              }
              while ((v156 & 0x80000000) == 0);
              uint64_t v157 = (void **)(v145 + 3);
              unint64_t v158 = v243;
              v145[2] = v244;
              *(_OWORD *)uint64_t v145 = v158;
              if (*((char *)v145 + 47) < 0) {
                operator delete(*v157);
              }
              id v159 = __p;
              v145[5] = v246;
              *(_OWORD *)uint64_t v157 = v159;
              HIBYTE(v246) = 0;
              LOBYTE(__p) = 0;
              id v160 = *(_OWORD *)((char *)v247 + 12);
              *((_OWORD *)v145 + 3) = v247[0];
              *(_OWORD *)((char *)v145 + 60) = v160;
              sub_100267D64((uint64_t)(v145 + 10), (uint64_t)v248);
              id v161 = v249;
              *((unsigned char *)v145 + 232) = v250;
              *(_OWORD *)(v145 + 27) = v161;
              sub_10026633C(v248);
              if (SHIBYTE(v246) < 0) {
                operator delete((void *)__p);
              }
            }
          }
          id v128 = v129 - 1;
        }
        while (v129);
        id v162 = v11 / 0xF0uLL;
        v231 = (long long *)(a1 + 3);
        do
        {
          v236 = a1[2];
          __int16 v235 = *(_OWORD *)a1;
          __int16 v237 = *v231;
          double v238 = a1[5];
          a1[4] = 0;
          a1[5] = 0;
          *(void *)v231 = 0;
          *(_OWORD *)__int16 v239 = *((_OWORD *)a1 + 3);
          *(_OWORD *)&v239[12] = *(_OWORD *)((char *)a1 + 60);
          sub_1002660C8(v240);
          __int16 v163 = 0;
          id v164 = *(_OWORD *)(a1 + 27);
          uint64_t v242 = *((unsigned char *)a1 + 232);
          __int16 v241 = v164;
          __int16 v165 = (uint64_t)a1;
          do
          {
            double v166 = v165 + 240 * v163 + 240;
            id v167 = 2 * v163;
            __int16 v163 = (2 * v163) | 1;
            if (v167 + 2 < v162)
            {
              id v168 = bswap64(*(void *)v166);
              __int16 v169 = bswap64(*(void *)(v166 + 240));
              if (v168 == v169
                && (id v168 = bswap64(*(void *)(v166 + 8)), v169 = bswap64(*(void *)(v166 + 248)), v168 == v169))
              {
                double v170 = 0;
              }
              else
              {
                double v170 = v168 < v169 ? -1 : 1;
              }
              if (v170 < 0)
              {
                v166 += 240;
                __int16 v163 = v167 + 2;
              }
            }
            __int16 v171 = *(_OWORD *)v166;
            *(void *)(v165 + 16) = *(void *)(v166 + 16);
            *(_OWORD *)__int16 v165 = v171;
            int v172 = (void **)(v165 + 24);
            if (*(char *)(v165 + 47) < 0) {
              operator delete(*v172);
            }
            __int16 v173 = *(_OWORD *)(v166 + 24);
            *(void *)(v165 + 40) = *(void *)(v166 + 40);
            *(_OWORD *)int v172 = v173;
            *(unsigned char *)(v166 + 47) = 0;
            *(unsigned char *)(v166 + 24) = 0;
            uint64_t v174 = *(_OWORD *)(v166 + 48);
            *(_OWORD *)(v165 + 60) = *(_OWORD *)(v166 + 60);
            *(_OWORD *)(v165 + 48) = v174;
            sub_100267D64(v165 + 80, v166 + 80);
            uint64_t v175 = *(_OWORD *)(v166 + 216);
            *(unsigned char *)(v165 + 232) = *(unsigned char *)(v166 + 232);
            *(_OWORD *)(v165 + 216) = v175;
            __int16 v165 = v166;
          }
          while (v163 <= (uint64_t)((unint64_t)(v162 - 2) >> 1));
          double v176 = (void **)(v166 + 24);
          int v177 = (long long *)(v166 + 48);
          v233 = (long long *)(v166 + 216);
          if ((unint64_t *)v166 == a2 - 30)
          {
            *(void *)(v166 + 16) = v236;
            *(_OWORD *)double v166 = v235;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            *(void *)(v166 + 40) = v238;
            *(_OWORD *)double v176 = v237;
            *(_OWORD *)(v166 + 60) = *(_OWORD *)&v239[12];
            *int v177 = *(_OWORD *)v239;
            sub_100267D64(v166 + 80, (uint64_t)v240);
            long long v191 = v241;
            *(unsigned char *)(v166 + 232) = v242;
            *v233 = v191;
          }
          else
          {
            long long v178 = *((_OWORD *)a2 - 15);
            *(void *)(v166 + 16) = *(a2 - 28);
            *(_OWORD *)double v166 = v178;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            long long v179 = *(_OWORD *)(a2 - 27);
            *(void *)(v166 + 40) = *(a2 - 25);
            *(_OWORD *)double v176 = v179;
            *((unsigned char *)a2 - 193) = 0;
            *((unsigned char *)a2 - 216) = 0;
            long long v180 = *((_OWORD *)a2 - 12);
            *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)a2 - 180);
            *int v177 = v180;
            sub_100267D64(v166 + 80, (uint64_t)(a2 - 20));
            long long v181 = (void **)(a2 - 27);
            long long v182 = *(_OWORD *)(a2 - 3);
            *(unsigned char *)(v166 + 232) = *((unsigned char *)a2 - 8);
            *v233 = v182;
            *(a2 - 28) = v236;
            *((_OWORD *)a2 - 15) = v235;
            if (*((char *)a2 - 193) < 0) {
              operator delete(*v181);
            }
            unint64_t v183 = a2 - 24;
            *(a2 - 25) = v238;
            *(_OWORD *)long long v181 = v237;
            *(_OWORD *)((char *)v183 + 12) = *(_OWORD *)&v239[12];
            *(_OWORD *)unint64_t v183 = *(_OWORD *)v239;
            sub_100267D64((uint64_t)(a2 - 20), (uint64_t)v240);
            long long v184 = a2 - 3;
            long long v185 = v241;
            *((unsigned char *)v184 + 16) = v242;
            *(_OWORD *)long long v184 = v185;
            long long v186 = v166 - (void)a1 + 240;
            if (v186 >= 241)
            {
              long long v187 = (v186 / 0xF0uLL - 2) >> 1;
              std::string v188 = &a1[30 * v187];
              float v189 = bswap64(*v188);
              long long v190 = bswap64(*(void *)v166);
              if (v189 != v190 || (float v189 = bswap64(v188[1]), v190 = bswap64(*(void *)(v166 + 8)), v189 != v190))
              {
                unint64_t v192 = v189 < v190 ? -1 : 1;
                if (v192 < 0)
                {
                  long long v193 = *(_OWORD *)v166;
                  uint64_t v244 = *(void *)(v166 + 16);
                  __int16 v243 = v193;
                  long long v194 = *(_OWORD *)v176;
                  double v246 = *(void *)(v166 + 40);
                  std::string __p = v194;
                  *(void *)(v166 + 32) = 0;
                  *(void *)(v166 + 40) = 0;
                  *double v176 = 0;
                  long long v195 = *v177;
                  *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)(v166 + 60);
                  v247[0] = v195;
                  sub_1002660C8(v248);
                  long long v196 = *v233;
                  double v250 = *(unsigned char *)(v166 + 232);
                  __int16 v249 = v196;
                  do
                  {
                    long long v197 = (uint64_t)v188;
                    long long v198 = *(_OWORD *)v188;
                    *(void *)(v166 + 16) = v188[2];
                    *(_OWORD *)double v166 = v198;
                    long long v199 = (void **)(v166 + 24);
                    if (*(char *)(v166 + 47) < 0) {
                      operator delete(*v199);
                    }
                    long long v200 = *(_OWORD *)(v188 + 3);
                    *(void *)(v166 + 40) = v188[5];
                    *(_OWORD *)long long v199 = v200;
                    *((unsigned char *)v188 + 47) = 0;
                    *((unsigned char *)v188 + 24) = 0;
                    double v201 = *((_OWORD *)v188 + 3);
                    *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)v188 + 60);
                    *(_OWORD *)(v166 + 48) = v201;
                    sub_100267D64(v166 + 80, (uint64_t)(v188 + 10));
                    double v202 = *(_OWORD *)(v188 + 27);
                    *(unsigned char *)(v166 + 232) = *((unsigned char *)v188 + 232);
                    *(_OWORD *)(v166 + 216) = v202;
                    if (!v187) {
                      break;
                    }
                    long long v187 = (v187 - 1) >> 1;
                    std::string v188 = &a1[30 * v187];
                    __int16 v203 = bswap64(*v188);
                    __int16 v204 = bswap64(v243);
                    if (v203 == v204
                      && (v203 = bswap64(v188[1]), __int16 v204 = bswap64(*((unint64_t *)&v243 + 1)), v203 == v204))
                    {
                      unint64_t v205 = 0;
                    }
                    else
                    {
                      unint64_t v205 = v203 < v204 ? -1 : 1;
                    }
                    double v166 = v197;
                  }
                  while (v205 < 0);
                  __int16 v206 = (void **)(v197 + 24);
                  double v207 = v243;
                  *(void *)(v197 + 16) = v244;
                  *(_OWORD *)long long v197 = v207;
                  if (*(char *)(v197 + 47) < 0) {
                    operator delete(*v206);
                  }
                  __int16 v208 = __p;
                  *(void *)(v197 + 40) = v246;
                  *(_OWORD *)__int16 v206 = v208;
                  HIBYTE(v246) = 0;
                  LOBYTE(__p) = 0;
                  uint64_t v209 = *(_OWORD *)((char *)v247 + 12);
                  *(_OWORD *)(v197 + 48) = v247[0];
                  *(_OWORD *)(v197 + 60) = v209;
                  sub_100267D64(v197 + 80, (uint64_t)v248);
                  int v210 = v249;
                  *(unsigned char *)(v197 + 232) = v250;
                  *(_OWORD *)(v197 + 216) = v210;
                  sub_10026633C(v248);
                  if (SHIBYTE(v246) < 0) {
                    operator delete((void *)__p);
                  }
                }
              }
            }
          }
          sub_10026633C(v240);
          a2 -= 30;
        }
        while (v162-- > 2);
      }
      return;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = &a1[30 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0x7801)
    {
      sub_10028D1C0(a1, &a1[30 * (v12 >> 1)], v9);
      sub_10028D1C0(a1 + 30, &a1[30 * v13 - 30], a2 - 60);
      sub_10028D1C0(a1 + 60, &a1[30 * v13 + 30], a2 - 90);
      sub_10028D1C0(&a1[30 * v13 - 30], v14, &a1[30 * v13 + 30]);
      sub_10028B0FC((long long *)a1, (long long *)v14);
    }
    else
    {
      sub_10028D1C0(&a1[30 * (v12 >> 1)], a1, v9);
    }
    --a3;
    if ((a4 & 1) == 0
      && ((v15 = bswap64(*(a1 - 30)), unint64_t v16 = bswap64(*a1), v15 == v16)
       && (v15 = bswap64(*(a1 - 29)), unint64_t v16 = bswap64(a1[1]), v15 == v16)
       || (v15 < v16 ? (uint64_t v24 = -1) : (uint64_t v24 = 1), (v24 & 0x80000000) == 0)))
    {
      id v17 = *(_OWORD *)a1;
      uint64_t v244 = a1[2];
      __int16 v243 = v17;
      uint64_t v18 = a1[5];
      std::string __p = *(_OWORD *)(a1 + 3);
      double v246 = v18;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v19 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v19;
      sub_1002660C8(v248);
      float v20 = *(_OWORD *)(a1 + 27);
      double v250 = *((unsigned char *)a1 + 232);
      __int16 v249 = v20;
      float v21 = bswap64(v243);
      double v22 = bswap64(*v9);
      if (v21 == v22 && (float v21 = bswap64(*((unint64_t *)&v243 + 1)), v22 = bswap64(*(a2 - 29)), v21 == v22))
      {
        uint64_t v23 = 0;
      }
      else if (v21 < v22)
      {
        uint64_t v23 = -1;
      }
      else
      {
        uint64_t v23 = 1;
      }
      if (v23 < 0)
      {
        long long v70 = a1;
        unint64_t v10 = a1;
        do
        {
          long long v71 = v10[30];
          v10 += 30;
          long long v72 = bswap64(v243);
          id v73 = bswap64(v71);
          if (v72 == v73 && (long long v72 = bswap64(*((unint64_t *)&v243 + 1)), v73 = bswap64(v70[31]), v72 == v73))
          {
            int v74 = 0;
          }
          else if (v72 < v73)
          {
            int v74 = -1;
          }
          else
          {
            int v74 = 1;
          }
          long long v70 = v10;
        }
        while ((v74 & 0x80000000) == 0);
      }
      else
      {
        uint64_t v66 = a1 + 30;
        do
        {
          unint64_t v10 = v66;
          if (v66 >= (unint64_t *)v8) {
            break;
          }
          id v67 = bswap64(v243);
          unint64_t v68 = bswap64(*v10);
          if (v67 == v68 && (id v67 = bswap64(*((unint64_t *)&v243 + 1)), v68 = bswap64(v10[1]), v67 == v68)) {
            long long v69 = 0;
          }
          else {
            long long v69 = v67 < v68 ? -1 : 1;
          }
          uint64_t v66 = v10 + 30;
        }
        while ((v69 & 0x80000000) == 0);
      }
      long long v75 = v8;
      if (v10 < (unint64_t *)v8)
      {
        uint64_t v76 = v8;
        long long v75 = v8;
        do
        {
          id v77 = *((void *)v75 - 30);
          v75 -= 15;
          uint64_t v78 = bswap64(v243);
          __int16 v79 = bswap64(v77);
          if (v78 == v79
            && (uint64_t v78 = bswap64(*((unint64_t *)&v243 + 1)), v79 = bswap64(*((void *)v76 - 29)), v78 == v79))
          {
            uint64_t v80 = 0;
          }
          else if (v78 < v79)
          {
            uint64_t v80 = -1;
          }
          else
          {
            uint64_t v80 = 1;
          }
          uint64_t v76 = v75;
        }
        while (v80 < 0);
      }
      while (v10 < (unint64_t *)v75)
      {
        sub_10028B0FC((long long *)v10, v75);
        __int16 v81 = v10;
        do
        {
          unint64_t v82 = v10[30];
          v10 += 30;
          __int16 v83 = bswap64(v243);
          uint64_t v84 = bswap64(v82);
          if (v83 == v84 && (v83 = bswap64(*((unint64_t *)&v243 + 1)), uint64_t v84 = bswap64(v81[31]), v83 == v84))
          {
            __int16 v85 = 0;
          }
          else if (v83 < v84)
          {
            __int16 v85 = -1;
          }
          else
          {
            __int16 v85 = 1;
          }
          __int16 v81 = v10;
        }
        while ((v85 & 0x80000000) == 0);
        double v86 = v75;
        do
        {
          uint64_t v87 = *((void *)v75 - 30);
          v75 -= 15;
          double v88 = bswap64(v243);
          __int16 v89 = bswap64(v87);
          if (v88 == v89
            && (v88 = bswap64(*((unint64_t *)&v243 + 1)), __int16 v89 = bswap64(*((void *)v86 - 29)), v88 == v89))
          {
            uint64_t v90 = 0;
          }
          else if (v88 < v89)
          {
            uint64_t v90 = -1;
          }
          else
          {
            uint64_t v90 = 1;
          }
          double v86 = v75;
        }
        while (v90 < 0);
      }
      __int16 v91 = v10 - 30;
      if (v10 - 30 != a1)
      {
        unint64_t v92 = (void **)(a1 + 3);
        __int16 v93 = *(_OWORD *)v91;
        a1[2] = *(v10 - 28);
        *(_OWORD *)a1 = v93;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v92);
        }
        uint64_t v94 = *(_OWORD *)(v10 - 27);
        a1[5] = *(v10 - 25);
        *(_OWORD *)unint64_t v92 = v94;
        *((unsigned char *)v10 - 193) = 0;
        *((unsigned char *)v10 - 216) = 0;
        __int16 v95 = *((_OWORD *)v10 - 12);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 180);
        *((_OWORD *)a1 + 3) = v95;
        sub_100267D64((uint64_t)(a1 + 10), (uint64_t)(v10 - 20));
        double v96 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 232) = *((unsigned char *)v10 - 8);
        *(_OWORD *)(a1 + 27) = v96;
      }
      id v97 = v243;
      *(v10 - 28) = v244;
      *(_OWORD *)__int16 v91 = v97;
      id v98 = (void **)(v10 - 27);
      if (*((char *)v10 - 193) < 0) {
        operator delete(*v98);
      }
      int v99 = __p;
      *(v10 - 25) = v246;
      *(_OWORD *)id v98 = v99;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      int v100 = v247[0];
      *(_OWORD *)((char *)v10 - 180) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v10 - 12) = v100;
      sub_100267D64((uint64_t)(v10 - 20), (uint64_t)v248);
      uint64_t v101 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v101;
      sub_10026633C(v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
LABEL_78:
      a4 = 0;
    }
    else
    {
      unint64_t v25 = *(_OWORD *)a1;
      uint64_t v244 = a1[2];
      __int16 v243 = v25;
      char v26 = a1[5];
      std::string __p = *(_OWORD *)(a1 + 3);
      double v246 = v26;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      BOOL v27 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v27;
      sub_1002660C8(v248);
      uint64_t v28 = 0;
      uint64_t v29 = (void **)(a1 + 3);
      uint64_t v30 = *(_OWORD *)(a1 + 27);
      double v250 = *((unsigned char *)a1 + 232);
      __int16 v249 = v30;
      do
      {
        double v31 = bswap64(a1[v28 + 30]);
        id v32 = bswap64(v243);
        if (v31 == v32 && (double v31 = bswap64(a1[v28 + 31]), v32 = bswap64(*((unint64_t *)&v243 + 1)), v31 == v32))
        {
          unsigned __int8 v33 = 0;
        }
        else if (v31 < v32)
        {
          unsigned __int8 v33 = -1;
        }
        else
        {
          unsigned __int8 v33 = 1;
        }
        v28 += 30;
      }
      while (v33 < 0);
      uint64_t v34 = &a1[v28];
      uint64_t v35 = v8;
      if (v28 == 30)
      {
        uint64_t v40 = a2;
        while (v34 < v40)
        {
          id v36 = (long long *)(v40 - 30);
          id v41 = bswap64(*(v40 - 30));
          unsigned __int8 v42 = bswap64(v243);
          if (v41 == v42 && (id v41 = bswap64(*(v40 - 29)), v42 = bswap64(*((unint64_t *)&v243 + 1)), v41 == v42))
          {
            unint64_t v43 = 0;
          }
          else if (v41 < v42)
          {
            unint64_t v43 = -1;
          }
          else
          {
            unint64_t v43 = 1;
          }
          v40 -= 30;
          if (v43 < 0) {
            goto LABEL_46;
          }
        }
        id v36 = (long long *)v40;
      }
      else
      {
        do
        {
          id v36 = v35 - 15;
          unsigned __int8 v37 = bswap64(*((void *)v35 - 30));
          uint64_t v38 = bswap64(v243);
          if (v37 == v38
            && (unsigned __int8 v37 = bswap64(*((void *)v35 - 29)), v38 = bswap64(*((unint64_t *)&v243 + 1)), v37 == v38))
          {
            uint64_t v39 = 0;
          }
          else if (v37 < v38)
          {
            uint64_t v39 = -1;
          }
          else
          {
            uint64_t v39 = 1;
          }
          v35 -= 15;
        }
        while ((v39 & 0x80000000) == 0);
      }
LABEL_46:
      unint64_t v10 = v34;
      if (v34 < (unint64_t *)v36)
      {
        unint64_t v44 = v36;
        do
        {
          sub_10028B0FC((long long *)v10, v44);
          id v45 = v10;
          do
          {
            id v46 = v10[30];
            v10 += 30;
            uint64_t v47 = bswap64(v46);
            uint64_t v48 = bswap64(v243);
            if (v47 == v48 && (uint64_t v47 = bswap64(v45[31]), v48 = bswap64(*((unint64_t *)&v243 + 1)), v47 == v48))
            {
              uint64_t v49 = 0;
            }
            else if (v47 < v48)
            {
              uint64_t v49 = -1;
            }
            else
            {
              uint64_t v49 = 1;
            }
            id v45 = v10;
          }
          while (v49 < 0);
          uint64_t v50 = v44;
          do
          {
            uint64_t v51 = *((void *)v44 - 30);
            v44 -= 15;
            uint64_t v52 = bswap64(v51);
            uint64_t v53 = bswap64(v243);
            if (v52 == v53
              && (uint64_t v52 = bswap64(*((void *)v50 - 29)), v53 = bswap64(*((unint64_t *)&v243 + 1)), v52 == v53))
            {
              unint64_t v54 = 0;
            }
            else if (v52 < v53)
            {
              unint64_t v54 = -1;
            }
            else
            {
              unint64_t v54 = 1;
            }
            uint64_t v50 = v44;
          }
          while ((v54 & 0x80000000) == 0);
        }
        while (v10 < (unint64_t *)v44);
      }
      id v55 = v10 - 30;
      if (v10 - 30 != a1)
      {
        id v56 = *(_OWORD *)v55;
        a1[2] = *(v10 - 28);
        *(_OWORD *)a1 = v56;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v29);
        }
        id v57 = *(_OWORD *)(v10 - 27);
        a1[5] = *(v10 - 25);
        *(_OWORD *)uint64_t v29 = v57;
        *((unsigned char *)v10 - 193) = 0;
        *((unsigned char *)v10 - 216) = 0;
        id v58 = *((_OWORD *)v10 - 12);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 180);
        *((_OWORD *)a1 + 3) = v58;
        sub_100267D64((uint64_t)(a1 + 10), (uint64_t)(v10 - 20));
        id v59 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 232) = *((unsigned char *)v10 - 8);
        *(_OWORD *)(a1 + 27) = v59;
      }
      double v60 = v243;
      *(v10 - 28) = v244;
      *(_OWORD *)id v55 = v60;
      id v61 = (void **)(v10 - 27);
      if (*((char *)v10 - 193) < 0) {
        operator delete(*v61);
      }
      unint64_t v62 = __p;
      *(v10 - 25) = v246;
      *(_OWORD *)id v61 = v62;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      int v63 = v247[0];
      *(_OWORD *)((char *)v10 - 180) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v10 - 12) = v63;
      sub_100267D64((uint64_t)(v10 - 20), (uint64_t)v248);
      id v64 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v64;
      sub_10026633C(v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
      unint64_t v4 = v34 >= (unint64_t *)v36;
      uint64_t v8 = (long long *)a2;
      if (!v4) {
        goto LABEL_77;
      }
      uint64_t v65 = sub_10028D368(a1, v10 - 30);
      if (sub_10028D368(v10, a2))
      {
        a2 = v10 - 30;
        if (v65) {
          return;
        }
        goto LABEL_1;
      }
      if (!v65)
      {
LABEL_77:
        sub_10028B790(a1, v10 - 30, a3, a4 & 1);
        goto LABEL_78;
      }
    }
  }
  if ((a4 & 1) == 0)
  {
    if (a1 == (unint64_t *)v8) {
      return;
    }
    double v213 = a1 + 30;
    if (a1 + 30 == a2) {
      return;
    }
    for (uint64_t i = a1 - 30; ; i += 30)
    {
      uint64_t v215 = v213;
      int v216 = bswap64(a1[30]);
      char v217 = bswap64(*a1);
      if (v216 != v217) {
        break;
      }
      int v216 = bswap64(v215[1]);
      char v217 = bswap64(a1[1]);
      char v218 = a2;
      if (v216 != v217) {
        goto LABEL_279;
      }
LABEL_297:
      double v213 = v215 + 30;
      a1 = v215;
      if (v215 + 30 == v218) {
        return;
      }
    }
    char v218 = a2;
LABEL_279:
    if (v216 < v217) {
      long long v219 = -1;
    }
    else {
      long long v219 = 1;
    }
    if (v219 < 0)
    {
      double v220 = *(_OWORD *)v215;
      uint64_t v244 = v215[2];
      __int16 v243 = v220;
      double v246 = a1[35];
      std::string __p = *(_OWORD *)(a1 + 33);
      a1[34] = 0;
      a1[35] = 0;
      a1[33] = 0;
      v247[0] = *((_OWORD *)a1 + 18);
      *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)a1 + 300);
      sub_1002660C8(v248);
      double v250 = *((unsigned char *)a1 + 472);
      __int16 v249 = *(_OWORD *)(a1 + 57);
      uint64_t v221 = i;
      do
      {
        *((_OWORD *)v221 + 30) = *((_OWORD *)v221 + 15);
        v221[62] = v221[32];
        char v222 = (void **)(v221 + 63);
        if (*((char *)v221 + 527) < 0) {
          operator delete(*v222);
        }
        v221[65] = v221[35];
        *(_OWORD *)char v222 = *(_OWORD *)(v221 + 33);
        *((unsigned char *)v221 + 287) = 0;
        *((unsigned char *)v221 + 264) = 0;
        *((_OWORD *)v221 + 33) = *((_OWORD *)v221 + 18);
        *(_OWORD *)((char *)v221 + 540) = *(_OWORD *)((char *)v221 + 300);
        sub_100267D64((uint64_t)(v221 + 70), (uint64_t)(v221 + 40));
        *((unsigned char *)v221 + 712) = *((unsigned char *)v221 + 472);
        *(_OWORD *)(v221 + 87) = *(_OWORD *)(v221 + 57);
        uint64_t v223 = bswap64(v243);
        char v224 = bswap64(*v221);
        if (v223 == v224 && (uint64_t v223 = bswap64(*((unint64_t *)&v243 + 1)), v224 = bswap64(v221[1]), v223 == v224))
        {
          uint64_t v225 = 0;
        }
        else if (v223 < v224)
        {
          uint64_t v225 = -1;
        }
        else
        {
          uint64_t v225 = 1;
        }
        v221 -= 30;
      }
      while (v225 < 0);
      int v226 = v243;
      v221[62] = v244;
      *((_OWORD *)v221 + 30) = v226;
      char v227 = (void **)(v221 + 63);
      if (*((char *)v221 + 527) < 0) {
        operator delete(*v227);
      }
      uint64_t v228 = __p;
      v221[65] = v246;
      *(_OWORD *)char v227 = v228;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      __int16 v229 = v247[0];
      *(_OWORD *)((char *)v221 + 540) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v221 + 33) = v229;
      sub_100267D64((uint64_t)(v221 + 70), (uint64_t)v248);
      int v230 = v249;
      *((unsigned char *)v221 + 712) = v250;
      *(_OWORD *)(v221 + 87) = v230;
      sub_10026633C(v248);
      char v218 = a2;
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
    }
    goto LABEL_297;
  }
  if (a1 != (unint64_t *)v8)
  {
    unint64_t v104 = a1 + 30;
    if (a1 + 30 != a2)
    {
      uint64_t v105 = 0;
      unint64_t v106 = v248;
      uint64_t v107 = a1;
      do
      {
        id v108 = v104;
        uint64_t v109 = bswap64(v107[30]);
        uint64_t v110 = bswap64(*v107);
        if (v109 != v110 || (uint64_t v109 = bswap64(v108[1]), v110 = bswap64(v107[1]), v109 != v110))
        {
          long long v111 = v109 < v110 ? -1 : 1;
          if (v111 < 0)
          {
            int v112 = *(_OWORD *)v108;
            uint64_t v244 = v108[2];
            __int16 v243 = v112;
            double v246 = v107[35];
            std::string __p = *(_OWORD *)(v107 + 33);
            v107[34] = 0;
            v107[35] = 0;
            v107[33] = 0;
            v247[0] = *((_OWORD *)v107 + 18);
            *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v107 + 300);
            id v113 = (uint64_t)v106;
            sub_1002660C8(v106);
            double v250 = *((unsigned char *)v107 + 472);
            __int16 v249 = *(_OWORD *)(v107 + 57);
            uint64_t v114 = v105;
            while (1)
            {
              uint64_t v115 = (char *)a1 + v114;
              *((_OWORD *)v115 + 15) = *(_OWORD *)((char *)a1 + v114);
              *((void *)v115 + 32) = *(unint64_t *)((char *)a1 + v114 + 16);
              double v116 = (void **)((char *)a1 + v114 + 264);
              if (*((char *)a1 + v114 + 287) < 0) {
                operator delete(*v116);
              }
              *(_OWORD *)double v116 = *(_OWORD *)(v115 + 24);
              *(unint64_t *)((char *)a1 + v114 + 280) = *((void *)v115 + 5);
              v115[47] = 0;
              v115[24] = 0;
              *((_OWORD *)v115 + 18) = *((_OWORD *)v115 + 3);
              *(_OWORD *)(v115 + 300) = *(_OWORD *)(v115 + 60);
              sub_100267D64((uint64_t)(v115 + 320), (uint64_t)(v115 + 80));
              double v117 = (char *)a1 + v114;
              *(_OWORD *)((char *)a1 + v114 + 456) = *(_OWORD *)((char *)a1 + v114 + 216);
              *((unsigned char *)a1 + v114 + 472) = *((unsigned char *)a1 + v114 + 232);
              if (!v114) {
                break;
              }
              id v118 = bswap64(v243);
              id v119 = bswap64(*((void *)v117 - 30));
              if (v118 == v119
                && (id v118 = bswap64(*((unint64_t *)&v243 + 1)),
                    id v119 = bswap64(*((void *)v117 - 29)),
                    v118 == v119))
              {
                unint64_t v120 = 0;
              }
              else if (v118 < v119)
              {
                unint64_t v120 = -1;
              }
              else
              {
                unint64_t v120 = 1;
              }
              v114 -= 240;
              if ((v120 & 0x80000000) == 0)
              {
                unint64_t v121 = (uint64_t)a1 + v114 + 240;
                goto LABEL_168;
              }
            }
            unint64_t v121 = (uint64_t)a1;
LABEL_168:
            double v122 = v243;
            *(void *)(v121 + 16) = v244;
            *(_OWORD *)unint64_t v121 = v122;
            double v123 = (void **)(v117 + 24);
            if (*(char *)(v121 + 47) < 0) {
              operator delete(*v123);
            }
            id v124 = __p;
            *((void *)v117 + 5) = v246;
            *(_OWORD *)double v123 = v124;
            HIBYTE(v246) = 0;
            LOBYTE(__p) = 0;
            id v125 = v247[0];
            *(_OWORD *)(v117 + 60) = *(_OWORD *)((char *)v247 + 12);
            *((_OWORD *)v117 + 3) = v125;
            unint64_t v106 = (unsigned char *)v113;
            sub_100267D64((uint64_t)(v117 + 80), v113);
            unint64_t v126 = v249;
            v117[232] = v250;
            *(_OWORD *)(v117 + 216) = v126;
            sub_10026633C(v113);
            if (SHIBYTE(v246) < 0) {
              operator delete((void *)__p);
            }
          }
        }
        unint64_t v104 = v108 + 30;
        v105 += 240;
        uint64_t v107 = v108;
      }
      while (v108 + 30 != a2);
    }
  }
}

  uint64_t v8 = (long long *)a2;
  unint64_t v9 = a2 - 30;
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (char *)v8 - (char *)v10;
    uint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v8 - (char *)v10) >> 4);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          id v102 = bswap64(*(a2 - 30));
          int64_t v103 = bswap64(*a1);
          if (v102 != v103 || (v102 = bswap64(*(a2 - 29)), int64_t v103 = bswap64(a1[1]), v102 != v103))
          {
            if (v102 < v103) {
              int v212 = -1;
            }
            else {
              int v212 = 1;
            }
            if (v212 < 0) {
              sub_10028B0FC((long long *)a1, (long long *)a2 - 15);
            }
          }
          break;
        case 3uLL:
          sub_10028D1C0(a1, a1 + 30, v9);
          break;
        case 4uLL:
          sub_10028D7B4(a1, a1 + 30, a1 + 60, v9);
          break;
        case 5uLL:
          sub_10028D000(a1, a1 + 30, a1 + 60, a1 + 90, v9);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5759) {
      break;
    }
    if (!a3)
    {
      if (a1 != (unint64_t *)v8)
      {
        uint64_t v127 = (v12 - 2) >> 1;
        id v128 = v127;
        do
        {
          uint64_t v129 = v128;
          if (v127 >= v128)
          {
            double v130 = (2 * v128) | 1;
            uint64_t v131 = &a1[30 * v130];
            if (2 * v128 + 2 < (uint64_t)v12)
            {
              id v132 = bswap64(*v131);
              uint64_t v133 = bswap64(v131[30]);
              if (v132 == v133 && (v132 = bswap64(v131[1]), uint64_t v133 = bswap64(v131[31]), v132 == v133)) {
                uint64_t v134 = 0;
              }
              else {
                uint64_t v134 = v132 < v133 ? -1 : 1;
              }
              if (v134 < 0)
              {
                v131 += 30;
                double v130 = 2 * v128 + 2;
              }
            }
            id v135 = &a1[30 * v128];
            uint64_t v136 = bswap64(*v131);
            uint64_t v137 = bswap64(*v135);
            if (v136 == v137 && (uint64_t v136 = bswap64(v131[1]), v137 = bswap64(v135[1]), v136 == v137)
              || (v136 < v137 ? (uint64_t v138 = -1) : (uint64_t v138 = 1), (v138 & 0x80000000) == 0))
            {
              unint64_t v139 = *(_OWORD *)v135;
              uint64_t v244 = v135[2];
              __int16 v243 = v139;
              id v140 = &a1[30 * v129];
              unint64_t v141 = *(_OWORD *)(v140 + 3);
              double v246 = v140[5];
              std::string __p = v141;
              v140[4] = 0;
              v140[5] = 0;
              v140[3] = 0;
              unint64_t v142 = *((_OWORD *)v140 + 3);
              *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v140 + 60);
              v247[0] = v142;
              sub_1002660C8(v248);
              id v143 = &a1[30 * v129];
              std::string::size_type v144 = *(_OWORD *)(v143 + 27);
              double v250 = *((unsigned char *)v143 + 232);
              __int16 v249 = v144;
              do
              {
                uint64_t v145 = v131;
                std::string::size_type v146 = *(_OWORD *)v131;
                v135[2] = v131[2];
                *(_OWORD *)id v135 = v146;
                __int16 v147 = (void **)(v135 + 3);
                if (*((char *)v135 + 47) < 0) {
                  operator delete(*v147);
                }
                id v148 = *(_OWORD *)(v145 + 3);
                v135[5] = v145[5];
                *(_OWORD *)__int16 v147 = v148;
                *((unsigned char *)v145 + 47) = 0;
                *((unsigned char *)v145 + 24) = 0;
                id v149 = *((_OWORD *)v145 + 3);
                *(_OWORD *)((char *)v135 + 60) = *(_OWORD *)((char *)v145 + 60);
                *((_OWORD *)v135 + 3) = v149;
                sub_100267D64((uint64_t)(v135 + 10), (uint64_t)(v145 + 10));
                id v150 = *(_OWORD *)(v145 + 27);
                *((unsigned char *)v135 + 232) = *((unsigned char *)v145 + 232);
                *(_OWORD *)(v135 + 27) = v150;
                if (v127 < v130) {
                  break;
                }
                uint64_t v131 = &a1[30 * ((2 * v130) | 1)];
                if (2 * v130 + 2 < (uint64_t)v12)
                {
                  id v151 = bswap64(*v131);
                  double v152 = bswap64(v131[30]);
                  if (v151 == v152 && (id v151 = bswap64(v131[1]), v152 = bswap64(v131[31]), v151 == v152)) {
                    id v153 = 0;
                  }
                  else {
                    id v153 = v151 < v152 ? -1 : 1;
                  }
                  if (v153 >= 0)
                  {
                    double v130 = (2 * v130) | 1;
                  }
                  else
                  {
                    v131 += 30;
                    double v130 = 2 * v130 + 2;
                  }
                }
                else
                {
                  double v130 = (2 * v130) | 1;
                }
                unint64_t v154 = bswap64(*v131);
                int v155 = bswap64(v243);
                if (v154 == v155
                  && (unint64_t v154 = bswap64(v131[1]), v155 = bswap64(*((unint64_t *)&v243 + 1)), v154 == v155))
                {
                  id v156 = 0;
                }
                else
                {
                  id v156 = v154 < v155 ? -1 : 1;
                }
                id v135 = v145;
              }
              while ((v156 & 0x80000000) == 0);
              uint64_t v157 = (void **)(v145 + 3);
              unint64_t v158 = v243;
              v145[2] = v244;
              *(_OWORD *)uint64_t v145 = v158;
              if (*((char *)v145 + 47) < 0) {
                operator delete(*v157);
              }
              id v159 = __p;
              v145[5] = v246;
              *(_OWORD *)uint64_t v157 = v159;
              HIBYTE(v246) = 0;
              LOBYTE(__p) = 0;
              id v160 = *(_OWORD *)((char *)v247 + 12);
              *((_OWORD *)v145 + 3) = v247[0];
              *(_OWORD *)((char *)v145 + 60) = v160;
              sub_100267D64((uint64_t)(v145 + 10), (uint64_t)v248);
              id v161 = v249;
              *((unsigned char *)v145 + 232) = v250;
              *(_OWORD *)(v145 + 27) = v161;
              sub_10026633C(v248);
              if (SHIBYTE(v246) < 0) {
                operator delete((void *)__p);
              }
            }
          }
          id v128 = v129 - 1;
        }
        while (v129);
        id v162 = v11 / 0xF0uLL;
        v231 = (long long *)(a1 + 3);
        do
        {
          v236 = a1[2];
          __int16 v235 = *(_OWORD *)a1;
          __int16 v237 = *v231;
          double v238 = a1[5];
          a1[4] = 0;
          a1[5] = 0;
          *(void *)v231 = 0;
          *(_OWORD *)__int16 v239 = *((_OWORD *)a1 + 3);
          *(_OWORD *)&v239[12] = *(_OWORD *)((char *)a1 + 60);
          sub_1002660C8(v240);
          __int16 v163 = 0;
          id v164 = *(_OWORD *)(a1 + 27);
          uint64_t v242 = *((unsigned char *)a1 + 232);
          __int16 v241 = v164;
          __int16 v165 = (uint64_t)a1;
          do
          {
            double v166 = v165 + 240 * v163 + 240;
            id v167 = 2 * v163;
            __int16 v163 = (2 * v163) | 1;
            if (v167 + 2 < v162)
            {
              id v168 = bswap64(*(void *)v166);
              __int16 v169 = bswap64(*(void *)(v166 + 240));
              if (v168 == v169
                && (id v168 = bswap64(*(void *)(v166 + 8)), v169 = bswap64(*(void *)(v166 + 248)), v168 == v169))
              {
                double v170 = 0;
              }
              else
              {
                double v170 = v168 < v169 ? -1 : 1;
              }
              if (v170 < 0)
              {
                v166 += 240;
                __int16 v163 = v167 + 2;
              }
            }
            __int16 v171 = *(_OWORD *)v166;
            *(void *)(v165 + 16) = *(void *)(v166 + 16);
            *(_OWORD *)__int16 v165 = v171;
            int v172 = (void **)(v165 + 24);
            if (*(char *)(v165 + 47) < 0) {
              operator delete(*v172);
            }
            __int16 v173 = *(_OWORD *)(v166 + 24);
            *(void *)(v165 + 40) = *(void *)(v166 + 40);
            *(_OWORD *)int v172 = v173;
            *(unsigned char *)(v166 + 47) = 0;
            *(unsigned char *)(v166 + 24) = 0;
            uint64_t v174 = *(_OWORD *)(v166 + 48);
            *(_OWORD *)(v165 + 60) = *(_OWORD *)(v166 + 60);
            *(_OWORD *)(v165 + 48) = v174;
            sub_100267D64(v165 + 80, v166 + 80);
            uint64_t v175 = *(_OWORD *)(v166 + 216);
            *(unsigned char *)(v165 + 232) = *(unsigned char *)(v166 + 232);
            *(_OWORD *)(v165 + 216) = v175;
            __int16 v165 = v166;
          }
          while (v163 <= (uint64_t)((unint64_t)(v162 - 2) >> 1));
          double v176 = (void **)(v166 + 24);
          int v177 = (long long *)(v166 + 48);
          v233 = (long long *)(v166 + 216);
          if ((unint64_t *)v166 == a2 - 30)
          {
            *(void *)(v166 + 16) = v236;
            *(_OWORD *)double v166 = v235;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            *(void *)(v166 + 40) = v238;
            *(_OWORD *)double v176 = v237;
            *(_OWORD *)(v166 + 60) = *(_OWORD *)&v239[12];
            *int v177 = *(_OWORD *)v239;
            sub_100267D64(v166 + 80, (uint64_t)v240);
            long long v191 = v241;
            *(unsigned char *)(v166 + 232) = v242;
            *v233 = v191;
          }
          else
          {
            long long v178 = *((_OWORD *)a2 - 15);
            *(void *)(v166 + 16) = *(a2 - 28);
            *(_OWORD *)double v166 = v178;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            long long v179 = *(_OWORD *)(a2 - 27);
            *(void *)(v166 + 40) = *(a2 - 25);
            *(_OWORD *)double v176 = v179;
            *((unsigned char *)a2 - 193) = 0;
            *((unsigned char *)a2 - 216) = 0;
            long long v180 = *((_OWORD *)a2 - 12);
            *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)a2 - 180);
            *int v177 = v180;
            sub_100267D64(v166 + 80, (uint64_t)(a2 - 20));
            long long v181 = (void **)(a2 - 27);
            long long v182 = *(_OWORD *)(a2 - 3);
            *(unsigned char *)(v166 + 232) = *((unsigned char *)a2 - 8);
            *v233 = v182;
            *(a2 - 28) = v236;
            *((_OWORD *)a2 - 15) = v235;
            if (*((char *)a2 - 193) < 0) {
              operator delete(*v181);
            }
            unint64_t v183 = a2 - 24;
            *(a2 - 25) = v238;
            *(_OWORD *)long long v181 = v237;
            *(_OWORD *)((char *)v183 + 12) = *(_OWORD *)&v239[12];
            *(_OWORD *)unint64_t v183 = *(_OWORD *)v239;
            sub_100267D64((uint64_t)(a2 - 20), (uint64_t)v240);
            long long v184 = a2 - 3;
            long long v185 = v241;
            *((unsigned char *)v184 + 16) = v242;
            *(_OWORD *)long long v184 = v185;
            long long v186 = v166 - (void)a1 + 240;
            if (v186 >= 241)
            {
              long long v187 = (v186 / 0xF0uLL - 2) >> 1;
              std::string v188 = &a1[30 * v187];
              float v189 = bswap64(*v188);
              long long v190 = bswap64(*(void *)v166);
              if (v189 != v190 || (float v189 = bswap64(v188[1]), v190 = bswap64(*(void *)(v166 + 8)), v189 != v190))
              {
                unint64_t v192 = v189 < v190 ? -1 : 1;
                if (v192 < 0)
                {
                  long long v193 = *(_OWORD *)v166;
                  uint64_t v244 = *(void *)(v166 + 16);
                  __int16 v243 = v193;
                  long long v194 = *(_OWORD *)v176;
                  double v246 = *(void *)(v166 + 40);
                  std::string __p = v194;
                  *(void *)(v166 + 32) = 0;
                  *(void *)(v166 + 40) = 0;
                  *double v176 = 0;
                  long long v195 = *v177;
                  *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)(v166 + 60);
                  v247[0] = v195;
                  sub_1002660C8(v248);
                  long long v196 = *v233;
                  double v250 = *(unsigned char *)(v166 + 232);
                  __int16 v249 = v196;
                  do
                  {
                    long long v197 = (uint64_t)v188;
                    long long v198 = *(_OWORD *)v188;
                    *(void *)(v166 + 16) = v188[2];
                    *(_OWORD *)double v166 = v198;
                    long long v199 = (void **)(v166 + 24);
                    if (*(char *)(v166 + 47) < 0) {
                      operator delete(*v199);
                    }
                    long long v200 = *(_OWORD *)(v188 + 3);
                    *(void *)(v166 + 40) = v188[5];
                    *(_OWORD *)long long v199 = v200;
                    *((unsigned char *)v188 + 47) = 0;
                    *((unsigned char *)v188 + 24) = 0;
                    double v201 = *((_OWORD *)v188 + 3);
                    *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)v188 + 60);
                    *(_OWORD *)(v166 + 48) = v201;
                    sub_100267D64(v166 + 80, (uint64_t)(v188 + 10));
                    double v202 = *(_OWORD *)(v188 + 27);
                    *(unsigned char *)(v166 + 232) = *((unsigned char *)v188 + 232);
                    *(_OWORD *)(v166 + 216) = v202;
                    if (!v187) {
                      break;
                    }
                    long long v187 = (v187 - 1) >> 1;
                    std::string v188 = &a1[30 * v187];
                    __int16 v203 = bswap64(*v188);
                    __int16 v204 = bswap64(v243);
                    if (v203 == v204
                      && (v203 = bswap64(v188[1]), __int16 v204 = bswap64(*((unint64_t *)&v243 + 1)), v203 == v204))
                    {
                      unint64_t v205 = 0;
                    }
                    else
                    {
                      unint64_t v205 = v203 < v204 ? -1 : 1;
                    }
                    double v166 = v197;
                  }
                  while (v205 < 0);
                  __int16 v206 = (void **)(v197 + 24);
                  double v207 = v243;
                  *(void *)(v197 + 16) = v244;
                  *(_OWORD *)long long v197 = v207;
                  if (*(char *)(v197 + 47) < 0) {
                    operator delete(*v206);
                  }
                  __int16 v208 = __p;
                  *(void *)(v197 + 40) = v246;
                  *(_OWORD *)__int16 v206 = v208;
                  HIBYTE(v246) = 0;
                  LOBYTE(__p) = 0;
                  uint64_t v209 = *(_OWORD *)((char *)v247 + 12);
                  *(_OWORD *)(v197 + 48) = v247[0];
                  *(_OWORD *)(v197 + 60) = v209;
                  sub_100267D64(v197 + 80, (uint64_t)v248);
                  int v210 = v249;
                  *(unsigned char *)(v197 + 232) = v250;
                  *(_OWORD *)(v197 + 216) = v210;
                  sub_10026633C(v248);
                  if (SHIBYTE(v246) < 0) {
                    operator delete((void *)__p);
                  }
                }
              }
            }
          }
          sub_10026633C(v240);
          a2 -= 30;
        }
        while (v162-- > 2);
      }
      return;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = &a1[30 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0x7801)
    {
      sub_10028D1C0(a1, &a1[30 * (v12 >> 1)], v9);
      sub_10028D1C0(a1 + 30, &a1[30 * v13 - 30], a2 - 60);
      sub_10028D1C0(a1 + 60, &a1[30 * v13 + 30], a2 - 90);
      sub_10028D1C0(&a1[30 * v13 - 30], v14, &a1[30 * v13 + 30]);
      sub_10028B0FC((long long *)a1, (long long *)v14);
    }
    else
    {
      sub_10028D1C0(&a1[30 * (v12 >> 1)], a1, v9);
    }
    --a3;
    if ((a4 & 1) == 0
      && ((v15 = bswap64(*(a1 - 30)), unint64_t v16 = bswap64(*a1), v15 == v16)
       && (v15 = bswap64(*(a1 - 29)), unint64_t v16 = bswap64(a1[1]), v15 == v16)
       || (v15 < v16 ? (uint64_t v24 = -1) : (uint64_t v24 = 1), (v24 & 0x80000000) == 0)))
    {
      id v17 = *(_OWORD *)a1;
      uint64_t v244 = a1[2];
      __int16 v243 = v17;
      uint64_t v18 = a1[5];
      std::string __p = *(_OWORD *)(a1 + 3);
      double v246 = v18;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v19 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v19;
      sub_1002660C8(v248);
      float v20 = *(_OWORD *)(a1 + 27);
      double v250 = *((unsigned char *)a1 + 232);
      __int16 v249 = v20;
      float v21 = bswap64(v243);
      double v22 = bswap64(*v9);
      if (v21 == v22 && (float v21 = bswap64(*((unint64_t *)&v243 + 1)), v22 = bswap64(*(a2 - 29)), v21 == v22))
      {
        uint64_t v23 = 0;
      }
      else if (v21 < v22)
      {
        uint64_t v23 = -1;
      }
      else
      {
        uint64_t v23 = 1;
      }
      if (v23 < 0)
      {
        long long v70 = a1;
        unint64_t v10 = a1;
        do
        {
          long long v71 = v10[30];
          v10 += 30;
          long long v72 = bswap64(v243);
          id v73 = bswap64(v71);
          if (v72 == v73 && (long long v72 = bswap64(*((unint64_t *)&v243 + 1)), v73 = bswap64(v70[31]), v72 == v73))
          {
            int v74 = 0;
          }
          else if (v72 < v73)
          {
            int v74 = -1;
          }
          else
          {
            int v74 = 1;
          }
          long long v70 = v10;
        }
        while ((v74 & 0x80000000) == 0);
      }
      else
      {
        uint64_t v66 = a1 + 30;
        do
        {
          unint64_t v10 = v66;
          if (v66 >= (unint64_t *)v8) {
            break;
          }
          id v67 = bswap64(v243);
          unint64_t v68 = bswap64(*v10);
          if (v67 == v68 && (id v67 = bswap64(*((unint64_t *)&v243 + 1)), v68 = bswap64(v10[1]), v67 == v68)) {
            long long v69 = 0;
          }
          else {
            long long v69 = v67 < v68 ? -1 : 1;
          }
          uint64_t v66 = v10 + 30;
        }
        while ((v69 & 0x80000000) == 0);
      }
      long long v75 = v8;
      if (v10 < (unint64_t *)v8)
      {
        uint64_t v76 = v8;
        long long v75 = v8;
        do
        {
          id v77 = *((void *)v75 - 30);
          v75 -= 15;
          uint64_t v78 = bswap64(v243);
          __int16 v79 = bswap64(v77);
          if (v78 == v79
            && (uint64_t v78 = bswap64(*((unint64_t *)&v243 + 1)), v79 = bswap64(*((void *)v76 - 29)), v78 == v79))
          {
            uint64_t v80 = 0;
          }
          else if (v78 < v79)
          {
            uint64_t v80 = -1;
          }
          else
          {
            uint64_t v80 = 1;
          }
          uint64_t v76 = v75;
        }
        while (v80 < 0);
      }
      while (v10 < (unint64_t *)v75)
      {
        sub_10028B0FC((long long *)v10, v75);
        __int16 v81 = v10;
        do
        {
          unint64_t v82 = v10[30];
          v10 += 30;
          __int16 v83 = bswap64(v243);
          uint64_t v84 = bswap64(v82);
          if (v83 == v84 && (v83 = bswap64(*((unint64_t *)&v243 + 1)), uint64_t v84 = bswap64(v81[31]), v83 == v84))
          {
            __int16 v85 = 0;
          }
          else if (v83 < v84)
          {
            __int16 v85 = -1;
          }
          else
          {
            __int16 v85 = 1;
          }
          __int16 v81 = v10;
        }
        while ((v85 & 0x80000000) == 0);
        double v86 = v75;
        do
        {
          uint64_t v87 = *((void *)v75 - 30);
          v75 -= 15;
          double v88 = bswap64(v243);
          __int16 v89 = bswap64(v87);
          if (v88 == v89
            && (v88 = bswap64(*((unint64_t *)&v243 + 1)), __int16 v89 = bswap64(*((void *)v86 - 29)), v88 == v89))
          {
            uint64_t v90 = 0;
          }
          else if (v88 < v89)
          {
            uint64_t v90 = -1;
          }
          else
          {
            uint64_t v90 = 1;
          }
          double v86 = v75;
        }
        while (v90 < 0);
      }
      __int16 v91 = v10 - 30;
      if (v10 - 30 != a1)
      {
        unint64_t v92 = (void **)(a1 + 3);
        __int16 v93 = *(_OWORD *)v91;
        a1[2] = *(v10 - 28);
        *(_OWORD *)a1 = v93;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v92);
        }
        uint64_t v94 = *(_OWORD *)(v10 - 27);
        a1[5] = *(v10 - 25);
        *(_OWORD *)unint64_t v92 = v94;
        *((unsigned char *)v10 - 193) = 0;
        *((unsigned char *)v10 - 216) = 0;
        __int16 v95 = *((_OWORD *)v10 - 12);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 180);
        *((_OWORD *)a1 + 3) = v95;
        sub_100267D64((uint64_t)(a1 + 10), (uint64_t)(v10 - 20));
        double v96 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 232) = *((unsigned char *)v10 - 8);
        *(_OWORD *)(a1 + 27) = v96;
      }
      id v97 = v243;
      *(v10 - 28) = v244;
      *(_OWORD *)__int16 v91 = v97;
      id v98 = (void **)(v10 - 27);
      if (*((char *)v10 - 193) < 0) {
        operator delete(*v98);
      }
      int v99 = __p;
      *(v10 - 25) = v246;
      *(_OWORD *)id v98 = v99;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      int v100 = v247[0];
      *(_OWORD *)((char *)v10 - 180) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v10 - 12) = v100;
      sub_100267D64((uint64_t)(v10 - 20), (uint64_t)v248);
      uint64_t v101 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v101;
      sub_10026633C(v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
LABEL_78:
      a4 = 0;
    }
    else
    {
      unint64_t v25 = *(_OWORD *)a1;
      uint64_t v244 = a1[2];
      __int16 v243 = v25;
      char v26 = a1[5];
      std::string __p = *(_OWORD *)(a1 + 3);
      double v246 = v26;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      BOOL v27 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v27;
      sub_1002660C8(v248);
      uint64_t v28 = 0;
      uint64_t v29 = (void **)(a1 + 3);
      uint64_t v30 = *(_OWORD *)(a1 + 27);
      double v250 = *((unsigned char *)a1 + 232);
      __int16 v249 = v30;
      do
      {
        double v31 = bswap64(a1[v28 + 30]);
        id v32 = bswap64(v243);
        if (v31 == v32 && (double v31 = bswap64(a1[v28 + 31]), v32 = bswap64(*((unint64_t *)&v243 + 1)), v31 == v32))
        {
          unsigned __int8 v33 = 0;
        }
        else if (v31 < v32)
        {
          unsigned __int8 v33 = -1;
        }
        else
        {
          unsigned __int8 v33 = 1;
        }
        v28 += 30;
      }
      while (v33 < 0);
      uint64_t v34 = &a1[v28];
      uint64_t v35 = v8;
      if (v28 == 30)
      {
        uint64_t v40 = a2;
        while (v34 < v40)
        {
          id v36 = (long long *)(v40 - 30);
          id v41 = bswap64(*(v40 - 30));
          unsigned __int8 v42 = bswap64(v243);
          if (v41 == v42 && (id v41 = bswap64(*(v40 - 29)), v42 = bswap64(*((unint64_t *)&v243 + 1)), v41 == v42))
          {
            unint64_t v43 = 0;
          }
          else if (v41 < v42)
          {
            unint64_t v43 = -1;
          }
          else
          {
            unint64_t v43 = 1;
          }
          v40 -= 30;
          if (v43 < 0) {
            goto LABEL_46;
          }
        }
        id v36 = (long long *)v40;
      }
      else
      {
        do
        {
          id v36 = v35 - 15;
          unsigned __int8 v37 = bswap64(*((void *)v35 - 30));
          uint64_t v38 = bswap64(v243);
          if (v37 == v38
            && (unsigned __int8 v37 = bswap64(*((void *)v35 - 29)), v38 = bswap64(*((unint64_t *)&v243 + 1)), v37 == v38))
          {
            uint64_t v39 = 0;
          }
          else if (v37 < v38)
          {
            uint64_t v39 = -1;
          }
          else
          {
            uint64_t v39 = 1;
          }
          v35 -= 15;
        }
        while ((v39 & 0x80000000) == 0);
      }
LABEL_46:
      unint64_t v10 = v34;
      if (v34 < (unint64_t *)v36)
      {
        unint64_t v44 = v36;
        do
        {
          sub_10028B0FC((long long *)v10, v44);
          id v45 = v10;
          do
          {
            id v46 = v10[30];
            v10 += 30;
            uint64_t v47 = bswap64(v46);
            uint64_t v48 = bswap64(v243);
            if (v47 == v48 && (uint64_t v47 = bswap64(v45[31]), v48 = bswap64(*((unint64_t *)&v243 + 1)), v47 == v48))
            {
              uint64_t v49 = 0;
            }
            else if (v47 < v48)
            {
              uint64_t v49 = -1;
            }
            else
            {
              uint64_t v49 = 1;
            }
            id v45 = v10;
          }
          while (v49 < 0);
          uint64_t v50 = v44;
          do
          {
            uint64_t v51 = *((void *)v44 - 30);
            v44 -= 15;
            uint64_t v52 = bswap64(v51);
            uint64_t v53 = bswap64(v243);
            if (v52 == v53
              && (uint64_t v52 = bswap64(*((void *)v50 - 29)), v53 = bswap64(*((unint64_t *)&v243 + 1)), v52 == v53))
            {
              unint64_t v54 = 0;
            }
            else if (v52 < v53)
            {
              unint64_t v54 = -1;
            }
            else
            {
              unint64_t v54 = 1;
            }
            uint64_t v50 = v44;
          }
          while ((v54 & 0x80000000) == 0);
        }
        while (v10 < (unint64_t *)v44);
      }
      id v55 = v10 - 30;
      if (v10 - 30 != a1)
      {
        id v56 = *(_OWORD *)v55;
        a1[2] = *(v10 - 28);
        *(_OWORD *)a1 = v56;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v29);
        }
        id v57 = *(_OWORD *)(v10 - 27);
        a1[5] = *(v10 - 25);
        *(_OWORD *)uint64_t v29 = v57;
        *((unsigned char *)v10 - 193) = 0;
        *((unsigned char *)v10 - 216) = 0;
        id v58 = *((_OWORD *)v10 - 12);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 180);
        *((_OWORD *)a1 + 3) = v58;
        sub_100267D64((uint64_t)(a1 + 10), (uint64_t)(v10 - 20));
        id v59 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 232) = *((unsigned char *)v10 - 8);
        *(_OWORD *)(a1 + 27) = v59;
      }
      double v60 = v243;
      *(v10 - 28) = v244;
      *(_OWORD *)id v55 = v60;
      id v61 = (void **)(v10 - 27);
      if (*((char *)v10 - 193) < 0) {
        operator delete(*v61);
      }
      unint64_t v62 = __p;
      *(v10 - 25) = v246;
      *(_OWORD *)id v61 = v62;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      int v63 = v247[0];
      *(_OWORD *)((char *)v10 - 180) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v10 - 12) = v63;
      sub_100267D64((uint64_t)(v10 - 20), (uint64_t)v248);
      id v64 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v64;
      sub_10026633C(v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
      unint64_t v4 = v34 >= (unint64_t *)v36;
      uint64_t v8 = (long long *)a2;
      if (!v4) {
        goto LABEL_77;
      }
      uint64_t v65 = sub_10028FCD0(a1, v10 - 30);
      if (sub_10028FCD0(v10, a2))
      {
        a2 = v10 - 30;
        if (v65) {
          return;
        }
        goto LABEL_1;
      }
      if (!v65)
      {
LABEL_77:
        sub_10028E460(a1, v10 - 30, a3, a4 & 1);
        goto LABEL_78;
      }
    }
  }
  if ((a4 & 1) == 0)
  {
    if (a1 == (unint64_t *)v8) {
      return;
    }
    double v213 = a1 + 30;
    if (a1 + 30 == a2) {
      return;
    }
    for (uint64_t i = a1 - 30; ; i += 30)
    {
      uint64_t v215 = v213;
      int v216 = bswap64(a1[30]);
      char v217 = bswap64(*a1);
      if (v216 != v217) {
        break;
      }
      int v216 = bswap64(v215[1]);
      char v217 = bswap64(a1[1]);
      char v218 = a2;
      if (v216 != v217) {
        goto LABEL_279;
      }
LABEL_297:
      double v213 = v215 + 30;
      a1 = v215;
      if (v215 + 30 == v218) {
        return;
      }
    }
    char v218 = a2;
LABEL_279:
    if (v216 < v217) {
      long long v219 = -1;
    }
    else {
      long long v219 = 1;
    }
    if (v219 < 0)
    {
      double v220 = *(_OWORD *)v215;
      uint64_t v244 = v215[2];
      __int16 v243 = v220;
      double v246 = a1[35];
      std::string __p = *(_OWORD *)(a1 + 33);
      a1[34] = 0;
      a1[35] = 0;
      a1[33] = 0;
      v247[0] = *((_OWORD *)a1 + 18);
      *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)a1 + 300);
      sub_1002660C8(v248);
      double v250 = *((unsigned char *)a1 + 472);
      __int16 v249 = *(_OWORD *)(a1 + 57);
      uint64_t v221 = i;
      do
      {
        *((_OWORD *)v221 + 30) = *((_OWORD *)v221 + 15);
        v221[62] = v221[32];
        char v222 = (void **)(v221 + 63);
        if (*((char *)v221 + 527) < 0) {
          operator delete(*v222);
        }
        v221[65] = v221[35];
        *(_OWORD *)char v222 = *(_OWORD *)(v221 + 33);
        *((unsigned char *)v221 + 287) = 0;
        *((unsigned char *)v221 + 264) = 0;
        *((_OWORD *)v221 + 33) = *((_OWORD *)v221 + 18);
        *(_OWORD *)((char *)v221 + 540) = *(_OWORD *)((char *)v221 + 300);
        sub_100267D64((uint64_t)(v221 + 70), (uint64_t)(v221 + 40));
        *((unsigned char *)v221 + 712) = *((unsigned char *)v221 + 472);
        *(_OWORD *)(v221 + 87) = *(_OWORD *)(v221 + 57);
        uint64_t v223 = bswap64(v243);
        char v224 = bswap64(*v221);
        if (v223 == v224 && (uint64_t v223 = bswap64(*((unint64_t *)&v243 + 1)), v224 = bswap64(v221[1]), v223 == v224))
        {
          uint64_t v225 = 0;
        }
        else if (v223 < v224)
        {
          uint64_t v225 = -1;
        }
        else
        {
          uint64_t v225 = 1;
        }
        v221 -= 30;
      }
      while (v225 < 0);
      int v226 = v243;
      v221[62] = v244;
      *((_OWORD *)v221 + 30) = v226;
      char v227 = (void **)(v221 + 63);
      if (*((char *)v221 + 527) < 0) {
        operator delete(*v227);
      }
      uint64_t v228 = __p;
      v221[65] = v246;
      *(_OWORD *)char v227 = v228;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      __int16 v229 = v247[0];
      *(_OWORD *)((char *)v221 + 540) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v221 + 33) = v229;
      sub_100267D64((uint64_t)(v221 + 70), (uint64_t)v248);
      int v230 = v249;
      *((unsigned char *)v221 + 712) = v250;
      *(_OWORD *)(v221 + 87) = v230;
      sub_10026633C(v248);
      char v218 = a2;
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
    }
    goto LABEL_297;
  }
  if (a1 != (unint64_t *)v8)
  {
    unint64_t v104 = a1 + 30;
    if (a1 + 30 != a2)
    {
      uint64_t v105 = 0;
      unint64_t v106 = v248;
      uint64_t v107 = a1;
      do
      {
        id v108 = v104;
        uint64_t v109 = bswap64(v107[30]);
        uint64_t v110 = bswap64(*v107);
        if (v109 != v110 || (uint64_t v109 = bswap64(v108[1]), v110 = bswap64(v107[1]), v109 != v110))
        {
          long long v111 = v109 < v110 ? -1 : 1;
          if (v111 < 0)
          {
            int v112 = *(_OWORD *)v108;
            uint64_t v244 = v108[2];
            __int16 v243 = v112;
            double v246 = v107[35];
            std::string __p = *(_OWORD *)(v107 + 33);
            v107[34] = 0;
            v107[35] = 0;
            v107[33] = 0;
            v247[0] = *((_OWORD *)v107 + 18);
            *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v107 + 300);
            id v113 = (uint64_t)v106;
            sub_1002660C8(v106);
            double v250 = *((unsigned char *)v107 + 472);
            __int16 v249 = *(_OWORD *)(v107 + 57);
            uint64_t v114 = v105;
            while (1)
            {
              uint64_t v115 = (char *)a1 + v114;
              *((_OWORD *)v115 + 15) = *(_OWORD *)((char *)a1 + v114);
              *((void *)v115 + 32) = *(unint64_t *)((char *)a1 + v114 + 16);
              double v116 = (void **)((char *)a1 + v114 + 264);
              if (*((char *)a1 + v114 + 287) < 0) {
                operator delete(*v116);
              }
              *(_OWORD *)double v116 = *(_OWORD *)(v115 + 24);
              *(unint64_t *)((char *)a1 + v114 + 280) = *((void *)v115 + 5);
              v115[47] = 0;
              v115[24] = 0;
              *((_OWORD *)v115 + 18) = *((_OWORD *)v115 + 3);
              *(_OWORD *)(v115 + 300) = *(_OWORD *)(v115 + 60);
              sub_100267D64((uint64_t)(v115 + 320), (uint64_t)(v115 + 80));
              double v117 = (char *)a1 + v114;
              *(_OWORD *)((char *)a1 + v114 + 456) = *(_OWORD *)((char *)a1 + v114 + 216);
              *((unsigned char *)a1 + v114 + 472) = *((unsigned char *)a1 + v114 + 232);
              if (!v114) {
                break;
              }
              id v118 = bswap64(v243);
              id v119 = bswap64(*((void *)v117 - 30));
              if (v118 == v119
                && (id v118 = bswap64(*((unint64_t *)&v243 + 1)),
                    id v119 = bswap64(*((void *)v117 - 29)),
                    v118 == v119))
              {
                unint64_t v120 = 0;
              }
              else if (v118 < v119)
              {
                unint64_t v120 = -1;
              }
              else
              {
                unint64_t v120 = 1;
              }
              v114 -= 240;
              if ((v120 & 0x80000000) == 0)
              {
                unint64_t v121 = (uint64_t)a1 + v114 + 240;
                goto LABEL_168;
              }
            }
            unint64_t v121 = (uint64_t)a1;
LABEL_168:
            double v122 = v243;
            *(void *)(v121 + 16) = v244;
            *(_OWORD *)unint64_t v121 = v122;
            double v123 = (void **)(v117 + 24);
            if (*(char *)(v121 + 47) < 0) {
              operator delete(*v123);
            }
            id v124 = __p;
            *((void *)v117 + 5) = v246;
            *(_OWORD *)double v123 = v124;
            HIBYTE(v246) = 0;
            LOBYTE(__p) = 0;
            id v125 = v247[0];
            *(_OWORD *)(v117 + 60) = *(_OWORD *)((char *)v247 + 12);
            *((_OWORD *)v117 + 3) = v125;
            unint64_t v106 = (unsigned char *)v113;
            sub_100267D64((uint64_t)(v117 + 80), v113);
            unint64_t v126 = v249;
            v117[232] = v250;
            *(_OWORD *)(v117 + 216) = v126;
            sub_10026633C(v113);
            if (SHIBYTE(v246) < 0) {
              operator delete((void *)__p);
            }
          }
        }
        unint64_t v104 = v108 + 30;
        v105 += 240;
        uint64_t v107 = v108;
      }
      while (v108 + 30 != a2);
    }
  }
}

  unint64_t v11 = a2 - 5;
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    unint64_t v15 = (char *)a2 - (char *)v12;
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (a2 - v12);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unsigned __int8 v42 = *a3;
          v60[0] = a2[-5];
          unint64_t v43 = a2[-1];
          id v45 = a2[-4];
          unint64_t v44 = a2[-3];
          void v60[3] = a2[-2];
          v60[4] = v43;
          v60[1] = v45;
          v60[2] = v44;
          uint64_t v47 = v12[1];
          id v46 = v12[2];
          uint64_t v48 = v12[4];
          v59[3] = v12[3];
          v59[4] = v48;
          v59[1] = v47;
          v59[2] = v46;
          v59[0] = *v12;
          if (v42(v60, v59))
          {
            id v61 = *v12;
            uint64_t v49 = v12[1];
            uint64_t v50 = v12[2];
            uint64_t v51 = v12[4];
            id v64 = v12[3];
            uint64_t v65 = v51;
            unint64_t v62 = v49;
            int v63 = v50;
            uint64_t v52 = a2[-1];
            unint64_t v54 = a2[-4];
            uint64_t v53 = a2[-3];
            void v12[3] = a2[-2];
            v12[4] = v52;
            v12[1] = v54;
            _OWORD v12[2] = v53;
            *uint64_t v12 = *v11;
            id v55 = v64;
            a2[-3] = v63;
            a2[-2] = v55;
            a2[-1] = v65;
            id v56 = v62;
            *unint64_t v11 = v61;
            a2[-4] = v56;
          }
          break;
        case 3uLL:
          sub_1004B4630(v12, (__n128 *)v12[5].n128_u64, (__n128 *)a2[-5].n128_u64, a3);
          break;
        case 4uLL:
          sub_1004B5228((long long *)v12, (long long *)&v12[5], (long long *)&v12[10], (long long *)&a2[-5], a3);
          break;
        case 5uLL:
          sub_1004B5440((long long *)v12, (long long *)&v12[5], (long long *)&v12[10], (long long *)&v12[15], (long long *)&a2[-5], a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 1919)
    {
      if (a5) {
        sub_1004B432C((uint64_t)v12, a2, (uint64_t (**)(void, void))a3);
      }
      else {
        sub_1004B44C4((uint64_t)v12, a2, (uint64_t (**)(void, void))a3);
      }
      return;
    }
    if (v14 == 1) {
      break;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = &v12[5 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0x2801)
    {
      sub_1004B4630(v12, (__n128 *)v12[5 * (v16 >> 1)].n128_u64, (__n128 *)a2[-5].n128_u64, a3);
      long long v19 = 5 * v17;
      float v20 = &v12[5 * v17 - 5];
      sub_1004B4630((__n128 *)v12[5].n128_u64, v20, (__n128 *)a2[-10].n128_u64, a3);
      float v21 = v12 + 10;
      double v22 = &v12[v19 + 5];
      sub_1004B4630(v21, v22, (__n128 *)a2[-15].n128_u64, a3);
      sub_1004B4630(v20, v18, v22, a3);
      id v61 = *a1;
      uint64_t v23 = a1[1];
      uint64_t v24 = a1[2];
      unint64_t v25 = a1[4];
      id v64 = a1[3];
      uint64_t v65 = v25;
      unint64_t v62 = v23;
      int v63 = v24;
      char v26 = v18[4];
      uint64_t v28 = v18[1];
      BOOL v27 = v18[2];
      a1[3] = v18[3];
      a1[4] = v26;
      a1[1] = v28;
      a1[2] = v27;
      *a1 = *v18;
      uint64_t v29 = v65;
      double v31 = v62;
      uint64_t v30 = v63;
      v18[3] = v64;
      v18[4] = v29;
      v18[1] = v31;
      v18[2] = v30;
      long long *v18 = v61;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_1004B4630((__n128 *)v12[5 * (v16 >> 1)].n128_u64, v12, (__n128 *)a2[-5].n128_u64, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    id v32 = *a3;
    v58[0] = a1[-5];
    unsigned __int8 v33 = a1[-1];
    uint64_t v35 = a1[-4];
    uint64_t v34 = a1[-3];
    v58[3] = a1[-2];
    v58[4] = v33;
    v58[1] = v35;
    v58[2] = v34;
    unsigned __int8 v37 = a1[1];
    id v36 = a1[2];
    uint64_t v38 = a1[4];
    v57[3] = a1[3];
    v57[4] = v38;
    v57[1] = v37;
    v57[2] = v36;
    v57[0] = *a1;
    if ((((uint64_t (*)(_OWORD *, _OWORD *))v32)(v58, v57) & 1) == 0)
    {
      uint64_t v12 = (__n128 *)sub_1004B4968(a1, a2, (uint64_t (**)(void, void))a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v39 = sub_1004B4C4C((long long *)a1, (long long *)a2, (uint64_t (**)(void, void))a3);
    if ((v40 & 1) == 0) {
      goto LABEL_16;
    }
    id v41 = sub_1004B4F18((long long *)a1, v39, a3);
    uint64_t v12 = (__n128 *)(v39 + 5);
    if (sub_1004B4F18(v39 + 5, (long long *)a2, a3))
    {
      a4 = -v14;
      a2 = (__n128 *)v39;
      if (v41) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v41)
    {
LABEL_16:
      sub_1004B3F38(a1, v39, a3, -v14, a5 & 1);
      uint64_t v12 = (__n128 *)(v39 + 5);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (v12 != a2) {
    sub_1004B56EC((uint64_t)v12, a2, a2, a3);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*(a2 - 9) < *(double *)(v10 + 8))
          {
            id v150 = *(_OWORD *)v10;
            long long v186 = *(_OWORD *)(v10 + 48);
            long long v198 = *(_OWORD *)(v10 + 64);
            id v162 = *(_OWORD *)(v10 + 16);
            uint64_t v174 = *(_OWORD *)(v10 + 32);
            id v57 = *((_OWORD *)a2 - 1);
            id v59 = *((_OWORD *)a2 - 4);
            id v58 = *((_OWORD *)a2 - 3);
            *(_OWORD *)(v10 + 48) = *((_OWORD *)a2 - 2);
            *(_OWORD *)(v10 + 64) = v57;
            *(_OWORD *)(v10 + 16) = v59;
            *(_OWORD *)(v10 + 32) = v58;
            *(_OWORD *)unint64_t v10 = *((_OWORD *)a2 - 5);
            *((_OWORD *)a2 - 2) = v186;
            *((_OWORD *)a2 - 1) = v198;
            *((_OWORD *)a2 - 4) = v162;
            *((_OWORD *)a2 - 3) = v174;
            *((_OWORD *)a2 - 5) = v150;
          }
          break;
        case 3uLL:
          sub_100537F58(v10, v10 + 80, (uint64_t)(a2 - 10));
          break;
        case 4uLL:
          sub_1005384F4(v10, v10 + 80, v10 + 160, (uint64_t)(a2 - 10));
          break;
        case 5uLL:
          double v60 = (long long *)(v10 + 80);
          id v61 = (long long *)(v10 + 160);
          unint64_t v62 = (long long *)(v10 + 240);
          sub_1005384F4(v10, v10 + 80, v10 + 160, v10 + 240);
          if (*(a2 - 9) < *(double *)(v10 + 248))
          {
            uint64_t v175 = *(_OWORD *)(v10 + 272);
            long long v187 = *(_OWORD *)(v10 + 288);
            long long v199 = *(_OWORD *)(v10 + 304);
            id v151 = *v62;
            __int16 v163 = *(_OWORD *)(v10 + 256);
            id v64 = *((_OWORD *)a2 - 4);
            int v63 = *((_OWORD *)a2 - 3);
            uint64_t v65 = *((_OWORD *)a2 - 1);
            *(_OWORD *)(v10 + 288) = *((_OWORD *)a2 - 2);
            *(_OWORD *)(v10 + 304) = v65;
            *(_OWORD *)(v10 + 256) = v64;
            *(_OWORD *)(v10 + 272) = v63;
            *unint64_t v62 = *((_OWORD *)a2 - 5);
            *((_OWORD *)a2 - 5) = v151;
            *((_OWORD *)a2 - 2) = v187;
            *((_OWORD *)a2 - 1) = v199;
            *((_OWORD *)a2 - 4) = v163;
            *((_OWORD *)a2 - 3) = v175;
            if (*(double *)(v10 + 248) < *(double *)(v10 + 168))
            {
              double v176 = *(_OWORD *)(v10 + 192);
              std::string v188 = *(_OWORD *)(v10 + 208);
              long long v200 = *(_OWORD *)(v10 + 224);
              double v152 = *v61;
              id v164 = *(_OWORD *)(v10 + 176);
              uint64_t v66 = *(_OWORD *)(v10 + 288);
              *(_OWORD *)(v10 + 192) = *(_OWORD *)(v10 + 272);
              *(_OWORD *)(v10 + 208) = v66;
              *(_OWORD *)(v10 + 224) = *(_OWORD *)(v10 + 304);
              id v67 = *(_OWORD *)(v10 + 256);
              *id v61 = *v62;
              *(_OWORD *)(v10 + 176) = v67;
              *(_OWORD *)(v10 + 288) = v188;
              *(_OWORD *)(v10 + 304) = v200;
              *(_OWORD *)(v10 + 256) = v164;
              *(_OWORD *)(v10 + 272) = v176;
              unint64_t v68 = *(double *)(v10 + 168);
              long long v69 = *(double *)(v10 + 88);
              *unint64_t v62 = v152;
              if (v68 < v69)
              {
                int v177 = *(_OWORD *)(v10 + 112);
                float v189 = *(_OWORD *)(v10 + 128);
                double v201 = *(_OWORD *)(v10 + 144);
                id v153 = *v60;
                __int16 v165 = *(_OWORD *)(v10 + 96);
                long long v70 = *(_OWORD *)(v10 + 208);
                *(_OWORD *)(v10 + 112) = *(_OWORD *)(v10 + 192);
                *(_OWORD *)(v10 + 128) = v70;
                *(_OWORD *)(v10 + 144) = *(_OWORD *)(v10 + 224);
                long long v71 = *(_OWORD *)(v10 + 176);
                *double v60 = *v61;
                *(_OWORD *)(v10 + 96) = v71;
                *(_OWORD *)(v10 + 208) = v189;
                *(_OWORD *)(v10 + 224) = v201;
                *(_OWORD *)(v10 + 176) = v165;
                *(_OWORD *)(v10 + 192) = v177;
                long long v72 = *(double *)(v10 + 88);
                id v73 = *(double *)(v10 + 8);
                *id v61 = v153;
                if (v72 < v73)
                {
                  unint64_t v154 = *(_OWORD *)v10;
                  long long v190 = *(_OWORD *)(v10 + 48);
                  double v202 = *(_OWORD *)(v10 + 64);
                  double v166 = *(_OWORD *)(v10 + 16);
                  long long v178 = *(_OWORD *)(v10 + 32);
                  int v74 = *(_OWORD *)(v10 + 144);
                  long long v75 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)(v10 + 48) = *(_OWORD *)(v10 + 128);
                  *(_OWORD *)(v10 + 64) = v74;
                  uint64_t v76 = *v60;
                  *(_OWORD *)(v10 + 16) = *(_OWORD *)(v10 + 96);
                  *(_OWORD *)(v10 + 32) = v75;
                  *(_OWORD *)unint64_t v10 = v76;
                  *(_OWORD *)(v10 + 128) = v190;
                  *(_OWORD *)(v10 + 144) = v202;
                  *(_OWORD *)(v10 + 96) = v166;
                  *(_OWORD *)(v10 + 112) = v178;
                  *double v60 = v154;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 1919) {
      break;
    }
    if (!a3)
    {
      if ((double *)v10 == a2) {
        return;
      }
      uint64_t v90 = (v12 - 2) >> 1;
      __int16 v91 = v90;
      do
      {
        unint64_t v92 = v91;
        if (v90 >= v91)
        {
          __int16 v93 = (2 * v91) | 1;
          uint64_t v94 = v10 + 80 * v93;
          if (2 * v92 + 2 < (uint64_t)v12 && *(double *)(v10 + 80 * v93 + 8) < *(double *)(v94 + 88))
          {
            v94 += 80;
            __int16 v93 = 2 * v92 + 2;
          }
          __int16 v95 = *(double *)(v10 + 80 * v92 + 8);
          if (*(double *)(v94 + 8) >= v95)
          {
            double v96 = v10 + 80 * v92;
            id v97 = *(void *)v96;
            long long v180 = *(_OWORD *)(v96 + 48);
            unint64_t v192 = *(_OWORD *)(v96 + 64);
            id v156 = *(_OWORD *)(v96 + 16);
            id v168 = *(_OWORD *)(v96 + 32);
            do
            {
              id v98 = (_OWORD *)v96;
              double v96 = v94;
              void *v98 = *(_OWORD *)v94;
              int v99 = *(_OWORD *)(v94 + 16);
              int v100 = *(_OWORD *)(v94 + 32);
              uint64_t v101 = *(_OWORD *)(v94 + 64);
              v98[3] = *(_OWORD *)(v94 + 48);
              v98[4] = v101;
              v98[1] = v99;
              v98[2] = v100;
              if (v90 < v93) {
                break;
              }
              id v102 = (2 * v93) | 1;
              uint64_t v94 = v10 + 80 * v102;
              int64_t v103 = 2 * v93 + 2;
              if (v103 < (uint64_t)v12 && *(double *)(v10 + 80 * v102 + 8) < *(double *)(v94 + 88))
              {
                v94 += 80;
                id v102 = v103;
              }
              __int16 v93 = v102;
            }
            while (*(double *)(v94 + 8) >= v95);
            *(void *)double v96 = v97;
            *(double *)(v96 + 8) = v95;
            *(_OWORD *)(v96 + 16) = v156;
            *(_OWORD *)(v96 + 32) = v168;
            *(_OWORD *)(v96 + 48) = v180;
            *(_OWORD *)(v96 + 64) = v192;
          }
        }
        __int16 v91 = v92 - 1;
      }
      while (v92);
      unint64_t v104 = v11 / 0x50uLL;
      while (2)
      {
        uint64_t v105 = 0;
        uint64_t v157 = *(_OWORD *)v10;
        long long v193 = *(_OWORD *)(v10 + 48);
        __int16 v203 = *(_OWORD *)(v10 + 64);
        __int16 v169 = *(_OWORD *)(v10 + 16);
        long long v181 = *(_OWORD *)(v10 + 32);
        unint64_t v106 = v10;
        do
        {
          uint64_t v107 = (_OWORD *)v106;
          id v108 = v105 + 1;
          v106 += 80 * (v105 + 1);
          uint64_t v109 = 2 * v105;
          uint64_t v105 = (2 * v105) | 1;
          uint64_t v110 = v109 + 2;
          if (v110 < v104 && *((double *)&v107[5 * v108] + 1) < *(double *)(v106 + 88))
          {
            v106 += 80;
            uint64_t v105 = v110;
          }
          *uint64_t v107 = *(_OWORD *)v106;
          long long v111 = *(_OWORD *)(v106 + 16);
          int v112 = *(_OWORD *)(v106 + 32);
          id v113 = *(_OWORD *)(v106 + 64);
          v107[3] = *(_OWORD *)(v106 + 48);
          v107[4] = v113;
          v107[1] = v111;
          v107[2] = v112;
        }
        while (v105 <= (uint64_t)((unint64_t)(v104 - 2) >> 1));
        a2 -= 10;
        if ((double *)v106 != a2)
        {
          *(_OWORD *)unint64_t v106 = *(_OWORD *)a2;
          uint64_t v114 = *((_OWORD *)a2 + 1);
          uint64_t v115 = *((_OWORD *)a2 + 2);
          double v116 = *((_OWORD *)a2 + 4);
          *(_OWORD *)(v106 + 48) = *((_OWORD *)a2 + 3);
          *(_OWORD *)(v106 + 64) = v116;
          *(_OWORD *)(v106 + 16) = v114;
          *(_OWORD *)(v106 + 32) = v115;
          *((_OWORD *)a2 + 3) = v193;
          *((_OWORD *)a2 + 4) = v203;
          *((_OWORD *)a2 + 1) = v169;
          *((_OWORD *)a2 + 2) = v181;
          *(_OWORD *)a2 = v157;
          double v117 = v106 - v10 + 80;
          if (v117 >= 81)
          {
            id v118 = (v117 / 0x50uLL - 2) >> 1;
            id v119 = *(double *)(v106 + 8);
            if (*(double *)(v10 + 80 * v118 + 8) < v119)
            {
              unint64_t v120 = *(void *)v106;
              id v143 = *(_OWORD *)(v106 + 48);
              std::string::size_type v146 = *(_OWORD *)(v106 + 64);
              uint64_t v137 = *(_OWORD *)(v106 + 16);
              id v140 = *(_OWORD *)(v106 + 32);
              do
              {
                unint64_t v121 = (_OWORD *)v106;
                unint64_t v106 = v10 + 80 * v118;
                uint64_t *v121 = *(_OWORD *)v106;
                double v122 = *(_OWORD *)(v106 + 16);
                double v123 = *(_OWORD *)(v106 + 32);
                id v124 = *(_OWORD *)(v106 + 64);
                v121[3] = *(_OWORD *)(v106 + 48);
                v121[4] = v124;
                v121[1] = v122;
                v121[2] = v123;
                if (!v118) {
                  break;
                }
                id v118 = (v118 - 1) >> 1;
              }
              while (*(double *)(v10 + 80 * v118 + 8) < v119);
              *(void *)unint64_t v106 = v120;
              *(double *)(v106 + 8) = v119;
              id v125 = v137;
              unint64_t v126 = v140;
              uint64_t v127 = v143;
              id v128 = v146;
LABEL_115:
              *(_OWORD *)(v106 + 48) = v127;
              *(_OWORD *)(v106 + 64) = v128;
              *(_OWORD *)(v106 + 16) = v125;
              *(_OWORD *)(v106 + 32) = v126;
            }
          }
          if (v104-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)unint64_t v106 = v157;
      id v125 = v169;
      unint64_t v126 = v181;
      uint64_t v127 = v193;
      id v128 = v203;
      goto LABEL_115;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (_OWORD *)(v10 + 80 * (v12 >> 1));
    if ((unint64_t)v11 >= 0x2801)
    {
      sub_100537F58(a1, a1 + 80 * (v12 >> 1), (uint64_t)(a2 - 10));
      unint64_t v15 = 5 * v13;
      unint64_t v16 = a1 + 80 * v13 - 80;
      sub_100537F58(a1 + 80, v16, (uint64_t)(a2 - 20));
      id v17 = a1 + 80 + 16 * v15;
      sub_100537F58(a1 + 160, v17, (uint64_t)(a2 - 30));
      sub_100537F58(v16, (uint64_t)v14, v17);
      __int16 v147 = *(_OWORD *)a1;
      unint64_t v183 = *(_OWORD *)(a1 + 48);
      long long v195 = *(_OWORD *)(a1 + 64);
      id v159 = *(_OWORD *)(a1 + 16);
      __int16 v171 = *(_OWORD *)(a1 + 32);
      uint64_t v18 = v14[4];
      float v20 = v14[1];
      long long v19 = v14[2];
      *(_OWORD *)(a1 + 48) = v14[3];
      *(_OWORD *)(a1 + 64) = v18;
      *(_OWORD *)(a1 + 16) = v20;
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)a1 = *v14;
      v14[3] = v183;
      v14[4] = v195;
      v14[1] = v159;
      int v14[2] = v171;
      *uint64_t v14 = v147;
    }
    else
    {
      sub_100537F58(a1 + 80 * (v12 >> 1), a1, (uint64_t)(a2 - 10));
    }
    --a3;
    if (a4)
    {
      float v21 = *(double *)(a1 + 8);
LABEL_12:
      double v22 = 0;
      uint64_t v23 = *(void *)a1;
      unint64_t v141 = *(_OWORD *)(a1 + 48);
      std::string::size_type v144 = *(_OWORD *)(a1 + 64);
      id v135 = *(_OWORD *)(a1 + 16);
      uint64_t v138 = *(_OWORD *)(a1 + 32);
      do
      {
        uint64_t v24 = *(double *)(a1 + v22 + 88);
        v22 += 80;
      }
      while (v24 < v21);
      unint64_t v25 = a1 + v22;
      char v26 = a2;
      if (v22 == 80)
      {
        uint64_t v29 = a2;
        while (v25 < (unint64_t)v29)
        {
          BOOL v27 = v29 - 10;
          uint64_t v30 = *(v29 - 9);
          v29 -= 10;
          if (v30 < v21) {
            goto LABEL_22;
          }
        }
        BOOL v27 = v29;
      }
      else
      {
        do
        {
          BOOL v27 = v26 - 10;
          uint64_t v28 = *(v26 - 9);
          v26 -= 10;
        }
        while (v28 >= v21);
      }
LABEL_22:
      unint64_t v10 = v25;
      if (v25 < (unint64_t)v27)
      {
        double v31 = v27;
        do
        {
          id v148 = *(_OWORD *)v10;
          long long v184 = *(_OWORD *)(v10 + 48);
          long long v196 = *(_OWORD *)(v10 + 64);
          id v160 = *(_OWORD *)(v10 + 16);
          int v172 = *(_OWORD *)(v10 + 32);
          id v32 = *((_OWORD *)v31 + 4);
          uint64_t v34 = *((_OWORD *)v31 + 1);
          unsigned __int8 v33 = *((_OWORD *)v31 + 2);
          *(_OWORD *)(v10 + 48) = *((_OWORD *)v31 + 3);
          *(_OWORD *)(v10 + 64) = v32;
          *(_OWORD *)(v10 + 16) = v34;
          *(_OWORD *)(v10 + 32) = v33;
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v31;
          *((_OWORD *)v31 + 3) = v184;
          *((_OWORD *)v31 + 4) = v196;
          *((_OWORD *)v31 + 1) = v160;
          *((_OWORD *)v31 + 2) = v172;
          *(_OWORD *)double v31 = v148;
          do
          {
            uint64_t v35 = *(double *)(v10 + 88);
            v10 += 80;
          }
          while (v35 < v21);
          do
          {
            id v36 = *(v31 - 9);
            v31 -= 10;
          }
          while (v36 >= v21);
        }
        while (v10 < (unint64_t)v31);
      }
      if (v10 - 80 != a1)
      {
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 80);
        unsigned __int8 v37 = *(_OWORD *)(v10 - 64);
        uint64_t v38 = *(_OWORD *)(v10 - 48);
        uint64_t v39 = *(_OWORD *)(v10 - 16);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 64) = v39;
        *(_OWORD *)(a1 + 16) = v37;
        *(_OWORD *)(a1 + 32) = v38;
      }
      *(void *)(v10 - 80) = v23;
      *(double *)(v10 - 72) = v21;
      *(_OWORD *)(v10 - 32) = v141;
      *(_OWORD *)(v10 - 16) = v144;
      *(_OWORD *)(v10 - 64) = v135;
      *(_OWORD *)(v10 - 48) = v138;
      if (v25 < (unint64_t)v27) {
        goto LABEL_33;
      }
      uint64_t v40 = sub_10053813C(a1, v10 - 80);
      if (sub_10053813C(v10, (uint64_t)a2))
      {
        a2 = (double *)(v10 - 80);
        if (v40) {
          return;
        }
        goto LABEL_1;
      }
      if (!v40)
      {
LABEL_33:
        sub_10053742C(a1, v10 - 80, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      float v21 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 72) < v21) {
        goto LABEL_12;
      }
      id v41 = *(void *)a1;
      unint64_t v142 = *(_OWORD *)(a1 + 48);
      uint64_t v145 = *(_OWORD *)(a1 + 64);
      uint64_t v136 = *(_OWORD *)(a1 + 16);
      unint64_t v139 = *(_OWORD *)(a1 + 32);
      if (v21 >= *(a2 - 9))
      {
        unint64_t v44 = a1 + 80;
        do
        {
          unint64_t v10 = v44;
          if (v44 >= (unint64_t)a2) {
            break;
          }
          id v45 = *(double *)(v44 + 8);
          v44 += 80;
        }
        while (v21 >= v45);
      }
      else
      {
        unsigned __int8 v42 = a1;
        do
        {
          unint64_t v10 = v42 + 80;
          unint64_t v43 = *(double *)(v42 + 88);
          v42 += 80;
        }
        while (v21 >= v43);
      }
      id v46 = a2;
      if (v10 < (unint64_t)a2)
      {
        uint64_t v47 = a2;
        do
        {
          id v46 = v47 - 10;
          uint64_t v48 = *(v47 - 9);
          v47 -= 10;
        }
        while (v21 < v48);
      }
      while (v10 < (unint64_t)v46)
      {
        id v149 = *(_OWORD *)v10;
        long long v185 = *(_OWORD *)(v10 + 48);
        long long v197 = *(_OWORD *)(v10 + 64);
        id v161 = *(_OWORD *)(v10 + 16);
        __int16 v173 = *(_OWORD *)(v10 + 32);
        uint64_t v49 = *((_OWORD *)v46 + 4);
        uint64_t v51 = *((_OWORD *)v46 + 1);
        uint64_t v50 = *((_OWORD *)v46 + 2);
        *(_OWORD *)(v10 + 48) = *((_OWORD *)v46 + 3);
        *(_OWORD *)(v10 + 64) = v49;
        *(_OWORD *)(v10 + 16) = v51;
        *(_OWORD *)(v10 + 32) = v50;
        *(_OWORD *)unint64_t v10 = *(_OWORD *)v46;
        *((_OWORD *)v46 + 3) = v185;
        *((_OWORD *)v46 + 4) = v197;
        *((_OWORD *)v46 + 1) = v161;
        *((_OWORD *)v46 + 2) = v173;
        *(_OWORD *)id v46 = v149;
        do
        {
          uint64_t v52 = *(double *)(v10 + 88);
          v10 += 80;
        }
        while (v21 >= v52);
        do
        {
          uint64_t v53 = *(v46 - 9);
          v46 -= 10;
        }
        while (v21 < v53);
      }
      unint64_t v4 = v10 - 80 >= a1;
      char v5 = v10 - 80 == a1;
      if (v10 - 80 != a1)
      {
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 80);
        unint64_t v54 = *(_OWORD *)(v10 - 64);
        id v55 = *(_OWORD *)(v10 - 48);
        id v56 = *(_OWORD *)(v10 - 16);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 64) = v56;
        *(_OWORD *)(a1 + 16) = v54;
        *(_OWORD *)(a1 + 32) = v55;
      }
      a4 = 0;
      *(void *)(v10 - 80) = v41;
      *(double *)(v10 - 72) = v21;
      *(_OWORD *)(v10 - 32) = v142;
      *(_OWORD *)(v10 - 16) = v145;
      *(_OWORD *)(v10 - 64) = v136;
      *(_OWORD *)(v10 - 48) = v139;
    }
  }
  id v77 = (double *)(v10 + 80);
  __int16 v79 = (double *)v10 == a2 || v77 == a2;
  if (a4)
  {
    if (!v79)
    {
      uint64_t v80 = 0;
      __int16 v81 = v10;
      do
      {
        unint64_t v82 = v77;
        __int16 v83 = *(double *)(v81 + 88);
        if (v83 < *(double *)(v81 + 8))
        {
          uint64_t v84 = *(void *)v77;
          int v155 = *(_OWORD *)(v81 + 96);
          id v167 = *(_OWORD *)(v81 + 112);
          long long v179 = *(_OWORD *)(v81 + 128);
          long long v191 = *(_OWORD *)(v81 + 144);
          __int16 v85 = v80;
          while (1)
          {
            double v86 = (double *)(v10 + v85);
            uint64_t v87 = *(_OWORD *)(v10 + v85 + 48);
            *((_OWORD *)v86 + 7) = *(_OWORD *)(v10 + v85 + 32);
            *((_OWORD *)v86 + 8) = v87;
            *((_OWORD *)v86 + 9) = *(_OWORD *)(v10 + v85 + 64);
            double v88 = *(_OWORD *)(v10 + v85 + 16);
            *((_OWORD *)v86 + 5) = *(_OWORD *)(v10 + v85);
            *((_OWORD *)v86 + 6) = v88;
            if (!v85) {
              break;
            }
            v85 -= 80;
            if (v83 >= *(v86 - 9))
            {
              __int16 v89 = v10 + v85 + 80;
              goto LABEL_83;
            }
          }
          __int16 v89 = v10;
LABEL_83:
          *(void *)__int16 v89 = v84;
          *(double *)(v89 + 8) = v83;
          *(_OWORD *)(v89 + 16) = v155;
          *(_OWORD *)(v89 + 32) = v167;
          *(_OWORD *)(v89 + 48) = v179;
          *(_OWORD *)(v89 + 64) = v191;
        }
        id v77 = v82 + 10;
        v80 += 80;
        __int16 v81 = (unint64_t)v82;
      }
      while (v82 + 10 != a2);
    }
  }
  else if (!v79)
  {
    do
    {
      double v130 = (unint64_t)v77;
      uint64_t v131 = *(double *)(a1 + 88);
      if (v131 < *(double *)(a1 + 8))
      {
        id v132 = *(void *)v77;
        unint64_t v158 = *(_OWORD *)(a1 + 96);
        double v170 = *(_OWORD *)(a1 + 112);
        long long v182 = *(_OWORD *)(a1 + 128);
        long long v194 = *(_OWORD *)(a1 + 144);
        do
        {
          uint64_t v133 = *((_OWORD *)v77 - 2);
          *((_OWORD *)v77 + 2) = *((_OWORD *)v77 - 3);
          *((_OWORD *)v77 + 3) = v133;
          *((_OWORD *)v77 + 4) = *((_OWORD *)v77 - 1);
          uint64_t v134 = *((_OWORD *)v77 - 4);
          *(_OWORD *)id v77 = *((_OWORD *)v77 - 5);
          *((_OWORD *)v77 + 1) = v134;
          *(double *)&uint64_t v134 = *(v77 - 19);
          v77 -= 10;
        }
        while (v131 < *(double *)&v134);
        *(void *)id v77 = v132;
        v77[1] = v131;
        *((_OWORD *)v77 + 3) = v182;
        *((_OWORD *)v77 + 4) = v194;
        *((_OWORD *)v77 + 1) = v158;
        *((_OWORD *)v77 + 2) = v170;
      }
      id v77 = (double *)(v130 + 80);
      a1 = v130;
    }
    while ((double *)(v130 + 80) != a2);
  }
}

  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (a2[-1].n128_f64[1] < v11->n128_f64[1])
          {
            uint64_t v28 = *v11;
            *unint64_t v11 = a2[-1];
            a2[-1] = v28;
          }
          break;
        case 3uLL:
          sub_1005B11CC(v11->n128_f64, v11[1].n128_f64, a2[-1].n128_f64);
          break;
        case 4uLL:
          sub_1005B1600(v11->n128_f64, (uint64_t)&v11[1], (uint64_t)&v11[2], (uint64_t)&a2[-1]);
          break;
        case 5uLL:
          sub_1005B16A4(v11->n128_f64, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        sub_1005B1774(v11->n128_f64, a2->n128_f64, a2->n128_f64, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    n128_f64 = v11[v15 >> 1].n128_f64;
    if ((unint64_t)v14 >= 0x801)
    {
      sub_1005B11CC(v11->n128_f64, v11[v15 >> 1].n128_f64, a2[-1].n128_f64);
      sub_1005B11CC(v11[1].n128_f64, n128_f64 - 2, a2[-2].n128_f64);
      sub_1005B11CC(v11[2].n128_f64, v11[v16 + 1].n128_f64, a2[-3].n128_f64);
      sub_1005B11CC(n128_f64 - 2, n128_f64, v11[v16 + 1].n128_f64);
      BOOL v27 = *v11;
      *unint64_t v11 = *(__n128 *)n128_f64;
      *(__n128 *)n128_f64 = v27;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_1005B11CC(v11[v15 >> 1].n128_f64, v11->n128_f64, a2[-1].n128_f64);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (v11[-1].n128_f64[1] >= v11->n128_f64[1])
    {
      unint64_t v11 = (__n128 *)sub_1005B1288(v11->n128_f64, a2->n128_f64);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v18 = (__n128 *)sub_1005B136C(v11->n128_f64, a2->n128_f64);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    float v20 = sub_1005B1450(v11, v18);
    unint64_t v11 = v18 + 1;
    if (sub_1005B1450(v18 + 1, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      sub_1005B0D54(a1, v18, a3, -v13, a5 & 1);
      unint64_t v11 = v18 + 1;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1005B1148((uint64_t)v11, a2);
  }
  else if (v11 != a2)
  {
    while (&a1[1] != a2)
    {
      double v22 = a1[1].n128_f64[1];
      uint64_t v23 = a1->n128_f64[1];
      float v21 = ++a1;
      if (v22 < v23)
      {
        uint64_t v24 = v21->n128_u64[0];
        unint64_t v25 = a1;
        do
        {
          *unint64_t v25 = v25[-1];
          char v26 = v25[-2].n128_f64[1];
          --v25;
        }
        while (v22 < v26);
        v25->n128_u64[0] = v24;
        v25->n128_f64[1] = v22;
      }
    }
  }
}

  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v23 = *(a2 - 2);
          uint64_t v24 = *v11;
          if (v23 < *v11 || v24 >= v23 && *(a2 - 1) < v11[1])
          {
            *unint64_t v11 = v23;
            *(a2 - 2) = v24;
            unint64_t v25 = *((void *)v11 + 1);
            v11[1] = *(a2 - 1);
            *((void *)a2 - 1) = v25;
          }
          break;
        case 3uLL:
          sub_10064345C(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          sub_100643A5C(v11, (uint64_t)(v11 + 2), (uint64_t)(v11 + 4), (uint64_t)(a2 - 2));
          break;
        case 5uLL:
          sub_100643B60(v11, (uint64_t)(v11 + 2), (uint64_t)(v11 + 4), (uint64_t)(v11 + 6), (uint64_t)(a2 - 2));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        sub_100643CB8((uint64_t)v11, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    id v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      sub_10064345C(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      sub_10064345C(v11 + 2, v17 - 2, a2 - 4);
      sub_10064345C(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      sub_10064345C(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(_OWORD *)v11;
      *(_OWORD *)unint64_t v11 = *(_OWORD *)v17;
      *(_OWORD *)id v17 = v18;
      if (a5) {
        goto LABEL_15;
      }
    }
    else
    {
      sub_10064345C(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_15;
      }
    }
    long long v19 = *(v11 - 2);
    if (v19 >= *v11 && (*v11 < v19 || *(v11 - 1) >= v11[1]))
    {
      unint64_t v11 = sub_1006435B0(v11, a2);
      goto LABEL_20;
    }
LABEL_15:
    float v20 = (double *)sub_1006436F4(v11, a2);
    if ((v21 & 1) == 0) {
      goto LABEL_18;
    }
    double v22 = sub_100643838((uint64_t)v11, v20);
    unint64_t v11 = v20 + 2;
    if (sub_100643838((uint64_t)(v20 + 2), a2))
    {
      a4 = -v13;
      a2 = v20;
      if (v22) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_18:
      sub_100642EF0(a1, v20, a3, -v13, a5 & 1);
      unint64_t v11 = v20 + 2;
LABEL_20:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1006432E8(v11, a2);
  }
  else
  {
    sub_1006433C0(v11, a2);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = a2 - v10;
    uint64_t v12 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(a2 - v10) >> 3);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          id v56 = *(double *)(a2 - 104);
          id v57 = *(double *)v10;
          if (v56 > *(double *)v10)
          {
            *(double *)unint64_t v10 = v56;
            *(double *)(a2 - 104) = v57;
            id v162 = *(_OWORD *)(v10 + 8);
            uint64_t v174 = *(_OWORD *)(v10 + 24);
            *(_OWORD *)int v210 = *(_OWORD *)(v10 + 72);
            *(_OWORD *)&v210[16] = *(_OWORD *)(v10 + 88);
            long long v186 = *(_OWORD *)(v10 + 40);
            long long v198 = *(_OWORD *)(v10 + 56);
            id v59 = *(_OWORD *)(a2 - 48);
            id v58 = *(_OWORD *)(a2 - 32);
            double v60 = *(_OWORD *)(a2 - 23);
            *(_OWORD *)(v10 + 40) = *(_OWORD *)(a2 - 64);
            *(_OWORD *)(v10 + 81) = v60;
            *(_OWORD *)(v10 + 72) = v58;
            *(_OWORD *)(v10 + 56) = v59;
            id v61 = *(_OWORD *)(a2 - 96);
            *(_OWORD *)(v10 + 24) = *(_OWORD *)(a2 - 80);
            *(_OWORD *)(v10 + 8) = v61;
            *(_OWORD *)(a2 - 96) = v162;
            *(_OWORD *)(a2 - 80) = v174;
            *(_OWORD *)(a2 - 23) = *(_OWORD *)&v210[9];
            *(_OWORD *)(a2 - 48) = v198;
            *(_OWORD *)(a2 - 32) = *(_OWORD *)v210;
            *(_OWORD *)(a2 - 64) = v186;
          }
          break;
        case 3uLL:
          sub_100645230(v10, v10 + 104, a2 - 104);
          break;
        case 4uLL:
          sub_1006458F4(v10, v10 + 104, v10 + 208, a2 - 104);
          break;
        case 5uLL:
          sub_1006458F4(v10, v10 + 104, v10 + 208, v10 + 312);
          unint64_t v62 = *(double *)(a2 - 104);
          int v63 = *(double *)(v10 + 312);
          if (v62 > v63)
          {
            *(double *)(v10 + 312) = v62;
            *(double *)(a2 - 104) = v63;
            long long v187 = *(_OWORD *)(v10 + 352);
            long long v199 = *(_OWORD *)(v10 + 368);
            *(_OWORD *)__int16 v211 = *(_OWORD *)(v10 + 384);
            *(_OWORD *)&v211[16] = *(_OWORD *)(v10 + 400);
            __int16 v163 = *(_OWORD *)(v10 + 320);
            uint64_t v175 = *(_OWORD *)(v10 + 336);
            id v64 = *(_OWORD *)(a2 - 80);
            *(_OWORD *)(v10 + 320) = *(_OWORD *)(a2 - 96);
            *(_OWORD *)(v10 + 336) = v64;
            uint64_t v66 = *(_OWORD *)(a2 - 48);
            uint64_t v65 = *(_OWORD *)(a2 - 32);
            id v67 = *(_OWORD *)(a2 - 64);
            *(_OWORD *)(v10 + 393) = *(_OWORD *)(a2 - 23);
            *(_OWORD *)(v10 + 368) = v66;
            *(_OWORD *)(v10 + 384) = v65;
            *(_OWORD *)(v10 + 352) = v67;
            *(_OWORD *)(a2 - 96) = v163;
            *(_OWORD *)(a2 - 80) = v175;
            *(_OWORD *)(a2 - 23) = *(_OWORD *)&v211[9];
            *(_OWORD *)(a2 - 48) = v199;
            *(_OWORD *)(a2 - 32) = *(_OWORD *)v211;
            *(_OWORD *)(a2 - 64) = v187;
            unint64_t v68 = *(double *)(v10 + 312);
            long long v69 = *(double *)(v10 + 208);
            if (v68 > v69)
            {
              *(double *)(v10 + 208) = v68;
              *(double *)(v10 + 312) = v69;
              std::string v188 = *(_OWORD *)(v10 + 248);
              long long v200 = *(_OWORD *)(v10 + 264);
              *(_OWORD *)int v212 = *(_OWORD *)(v10 + 280);
              *(_OWORD *)&v212[16] = *(_OWORD *)(v10 + 296);
              id v164 = *(_OWORD *)(v10 + 216);
              double v176 = *(_OWORD *)(v10 + 232);
              long long v70 = *(_OWORD *)(v10 + 368);
              *(_OWORD *)(v10 + 248) = *(_OWORD *)(v10 + 352);
              *(_OWORD *)(v10 + 264) = v70;
              *(_OWORD *)(v10 + 280) = *(_OWORD *)(v10 + 384);
              *(_OWORD *)(v10 + 289) = *(_OWORD *)(v10 + 393);
              long long v71 = *(_OWORD *)(v10 + 336);
              *(_OWORD *)(v10 + 216) = *(_OWORD *)(v10 + 320);
              *(_OWORD *)(v10 + 232) = v71;
              *(_OWORD *)(v10 + 320) = v164;
              *(_OWORD *)(v10 + 336) = v176;
              *(_OWORD *)(v10 + 393) = *(_OWORD *)&v212[9];
              *(_OWORD *)(v10 + 368) = v200;
              *(_OWORD *)(v10 + 384) = *(_OWORD *)v212;
              *(_OWORD *)(v10 + 352) = v188;
              long long v72 = *(double *)(v10 + 104);
              if (v68 > v72)
              {
                *(double *)(v10 + 208) = v72;
                float v189 = *(_OWORD *)(v10 + 144);
                double v201 = *(_OWORD *)(v10 + 160);
                *(_OWORD *)double v213 = *(_OWORD *)(v10 + 176);
                *(_OWORD *)&v213[16] = *(_OWORD *)(v10 + 192);
                __int16 v165 = *(_OWORD *)(v10 + 112);
                int v177 = *(_OWORD *)(v10 + 128);
                id v73 = *(_OWORD *)(v10 + 264);
                *(_OWORD *)(v10 + 144) = *(_OWORD *)(v10 + 248);
                *(_OWORD *)(v10 + 160) = v73;
                *(_OWORD *)(v10 + 176) = *(_OWORD *)(v10 + 280);
                *(_OWORD *)(v10 + 185) = *(_OWORD *)(v10 + 289);
                int v74 = *(_OWORD *)(v10 + 232);
                *(_OWORD *)(v10 + 112) = *(_OWORD *)(v10 + 216);
                *(_OWORD *)(v10 + 128) = v74;
                *(_OWORD *)(v10 + 216) = v165;
                *(_OWORD *)(v10 + 232) = v177;
                *(_OWORD *)(v10 + 289) = *(_OWORD *)&v213[9];
                *(_OWORD *)(v10 + 264) = v201;
                *(_OWORD *)(v10 + 280) = *(_OWORD *)v213;
                *(_OWORD *)(v10 + 248) = v189;
                long long v75 = *(double *)v10;
                uint64_t v76 = v68 <= *(double *)v10;
                *(double *)(v10 + 104) = v68;
                if (!v76)
                {
                  *(double *)unint64_t v10 = v68;
                  *(double *)(v10 + 104) = v75;
                  double v166 = *(_OWORD *)(v10 + 8);
                  long long v178 = *(_OWORD *)(v10 + 24);
                  *(_OWORD *)__int16 v214 = *(_OWORD *)(v10 + 72);
                  *(_OWORD *)&v214[16] = *(_OWORD *)(v10 + 88);
                  long long v190 = *(_OWORD *)(v10 + 40);
                  double v202 = *(_OWORD *)(v10 + 56);
                  *(_OWORD *)(v10 + 81) = *(_OWORD *)(v10 + 185);
                  *(_OWORD *)(v10 + 72) = *(_OWORD *)(v10 + 176);
                  id v77 = *(_OWORD *)(v10 + 144);
                  *(_OWORD *)(v10 + 56) = *(_OWORD *)(v10 + 160);
                  *(_OWORD *)(v10 + 40) = v77;
                  uint64_t v78 = *(_OWORD *)(v10 + 128);
                  *(_OWORD *)(v10 + 8) = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)(v10 + 24) = v78;
                  *(_OWORD *)(v10 + 112) = v166;
                  *(_OWORD *)(v10 + 128) = v178;
                  *(_OWORD *)(v10 + 185) = *(_OWORD *)&v214[9];
                  *(_OWORD *)(v10 + 160) = v202;
                  *(_OWORD *)(v10 + 176) = *(_OWORD *)v214;
                  *(_OWORD *)(v10 + 144) = v190;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 2495) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return;
      }
      unint64_t v92 = (v12 - 2) >> 1;
      __int16 v93 = v92;
      do
      {
        uint64_t v94 = v93;
        if (v92 >= v93)
        {
          __int16 v95 = (2 * v93) | 1;
          double v96 = v10 + 104 * v95;
          if (2 * v94 + 2 < (uint64_t)v12 && *(double *)v96 > *(double *)(v96 + 104))
          {
            v96 += 104;
            __int16 v95 = 2 * v94 + 2;
          }
          id v97 = v10 + 104 * v94;
          id v98 = *(double *)v96;
          int v99 = *(double *)v97;
          if (*(double *)v96 <= *(double *)v97)
          {
            id v168 = *(_OWORD *)(v97 + 8);
            long long v180 = *(_OWORD *)(v97 + 24);
            *(_OWORD *)&v216[9] = *(_OWORD *)(v97 + 81);
            __int16 v204 = *(_OWORD *)(v97 + 56);
            *(_OWORD *)int v216 = *(_OWORD *)(v97 + 72);
            unint64_t v192 = *(_OWORD *)(v97 + 40);
            do
            {
              int v100 = v97;
              id v97 = v96;
              *(double *)int v100 = v98;
              uint64_t v101 = *(_OWORD *)(v96 + 8);
              *(_OWORD *)(v100 + 24) = *(_OWORD *)(v96 + 24);
              *(_OWORD *)(v100 + 8) = v101;
              id v102 = *(_OWORD *)(v96 + 40);
              int64_t v103 = *(_OWORD *)(v96 + 56);
              unint64_t v104 = *(_OWORD *)(v96 + 72);
              *(_OWORD *)(v100 + 81) = *(_OWORD *)(v96 + 81);
              *(_OWORD *)(v100 + 72) = v104;
              *(_OWORD *)(v100 + 56) = v103;
              *(_OWORD *)(v100 + 40) = v102;
              if (v92 < v95) {
                break;
              }
              uint64_t v105 = 2 * v95;
              __int16 v95 = (2 * v95) | 1;
              double v96 = v10 + 104 * v95;
              unint64_t v106 = v105 + 2;
              if (v106 < (uint64_t)v12 && *(double *)v96 > *(double *)(v96 + 104))
              {
                v96 += 104;
                __int16 v95 = v106;
              }
              id v98 = *(double *)v96;
            }
            while (*(double *)v96 <= v99);
            *(double *)id v97 = v99;
            *(_OWORD *)(v97 + 8) = v168;
            *(_OWORD *)(v97 + 24) = v180;
            *(_OWORD *)(v97 + 81) = *(_OWORD *)&v216[9];
            *(_OWORD *)(v97 + 56) = v204;
            *(_OWORD *)(v97 + 72) = *(_OWORD *)v216;
            *(_OWORD *)(v97 + 40) = v192;
          }
        }
        __int16 v93 = v94 - 1;
      }
      while (v94);
      uint64_t v107 = v11 / 0x68uLL;
      while (2)
      {
        id v108 = 0;
        uint64_t v109 = *(double *)v10;
        std::string::size_type v146 = *(_OWORD *)(v10 + 8);
        id v149 = *(_OWORD *)(v10 + 24);
        *(_OWORD *)&v158[9] = *(_OWORD *)(v10 + 81);
        int v155 = *(_OWORD *)(v10 + 56);
        *(_OWORD *)unint64_t v158 = *(_OWORD *)(v10 + 72);
        double v152 = *(_OWORD *)(v10 + 40);
        uint64_t v110 = v10;
        do
        {
          long long v111 = v110;
          v110 += 104 * v108 + 104;
          int v112 = 2 * v108;
          id v108 = (2 * v108) | 1;
          id v113 = v112 + 2;
          if (v113 < v107 && *(double *)v110 > *(double *)(v110 + 104))
          {
            v110 += 104;
            id v108 = v113;
          }
          *(void *)long long v111 = *(void *)v110;
          uint64_t v114 = *(_OWORD *)(v110 + 8);
          *(_OWORD *)(v111 + 24) = *(_OWORD *)(v110 + 24);
          *(_OWORD *)(v111 + 8) = v114;
          uint64_t v115 = *(_OWORD *)(v110 + 40);
          double v116 = *(_OWORD *)(v110 + 56);
          double v117 = *(_OWORD *)(v110 + 72);
          *(_OWORD *)(v111 + 81) = *(_OWORD *)(v110 + 81);
          *(_OWORD *)(v111 + 72) = v117;
          *(_OWORD *)(v111 + 56) = v116;
          *(_OWORD *)(v111 + 40) = v115;
        }
        while (v108 <= (uint64_t)((unint64_t)(v107 - 2) >> 1));
        id v118 = (long long *)(v110 + 8);
        if (v110 != a2 - 104)
        {
          *(void *)uint64_t v110 = *(void *)(a2 - 104);
          id v119 = *(_OWORD *)(a2 - 80);
          *id v118 = *(_OWORD *)(a2 - 96);
          *(_OWORD *)(v110 + 24) = v119;
          unint64_t v120 = *(_OWORD *)(a2 - 64);
          unint64_t v121 = *(_OWORD *)(a2 - 48);
          double v122 = *(_OWORD *)(a2 - 32);
          *(_OWORD *)(v110 + 81) = *(_OWORD *)(a2 - 23);
          *(_OWORD *)(v110 + 56) = v121;
          *(_OWORD *)(v110 + 72) = v122;
          *(_OWORD *)(v110 + 40) = v120;
          *(double *)(a2 - 104) = v109;
          *(_OWORD *)(a2 - 96) = v146;
          *(_OWORD *)(a2 - 80) = v149;
          *(_OWORD *)(a2 - 23) = *(_OWORD *)&v158[9];
          *(_OWORD *)(a2 - 48) = v155;
          *(_OWORD *)(a2 - 32) = *(_OWORD *)v158;
          *(_OWORD *)(a2 - 64) = v152;
          double v123 = v110 - v10 + 104;
          if (v123 >= 105)
          {
            id v124 = (v123 / 0x68uLL - 2) >> 1;
            id v125 = v10 + 104 * v124;
            unint64_t v126 = *(double *)v125;
            uint64_t v127 = *(double *)v110;
            if (*(double *)v125 > *(double *)v110)
            {
              __int16 v169 = *v118;
              long long v181 = *(_OWORD *)(v110 + 24);
              *(_OWORD *)&v217[9] = *(_OWORD *)(v110 + 81);
              unint64_t v205 = *(_OWORD *)(v110 + 56);
              *(_OWORD *)char v217 = *(_OWORD *)(v110 + 72);
              long long v193 = *(_OWORD *)(v110 + 40);
              do
              {
                id v128 = v110;
                uint64_t v110 = v125;
                *(double *)id v128 = v126;
                uint64_t v129 = *(_OWORD *)(v125 + 8);
                *(_OWORD *)(v128 + 24) = *(_OWORD *)(v125 + 24);
                *(_OWORD *)(v128 + 8) = v129;
                double v130 = *(_OWORD *)(v125 + 40);
                uint64_t v131 = *(_OWORD *)(v125 + 56);
                id v132 = *(_OWORD *)(v125 + 72);
                *(_OWORD *)(v128 + 81) = *(_OWORD *)(v125 + 81);
                *(_OWORD *)(v128 + 72) = v132;
                *(_OWORD *)(v128 + 56) = v131;
                *(_OWORD *)(v128 + 40) = v130;
                if (!v124) {
                  break;
                }
                id v124 = (v124 - 1) >> 1;
                id v125 = v10 + 104 * v124;
                unint64_t v126 = *(double *)v125;
              }
              while (*(double *)v125 > v127);
              id v118 = (long long *)(v110 + 8);
              *(double *)uint64_t v110 = v127;
              *(_OWORD *)(v110 + 8) = v169;
              *(_OWORD *)(v110 + 24) = v181;
              uint64_t v133 = v193;
              uint64_t v134 = v205;
              id v135 = *(_OWORD *)v217;
              uint64_t v136 = *(_OWORD *)&v217[9];
LABEL_115:
              *(long long *)((char *)v118 + 73) = v136;
              v118[3] = v134;
              int v118[4] = v135;
              v118[2] = v133;
            }
          }
          a2 -= 104;
          uint64_t v76 = v107-- <= 2;
          if (v76) {
            return;
          }
          continue;
        }
        break;
      }
      *(double *)uint64_t v110 = v109;
      *id v118 = v146;
      *(_OWORD *)(v110 + 24) = v149;
      uint64_t v133 = v152;
      uint64_t v134 = v155;
      id v135 = *(_OWORD *)v158;
      uint64_t v136 = *(_OWORD *)&v158[9];
      goto LABEL_115;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = v10 + 104 * (v12 >> 1);
    if ((unint64_t)v11 >= 0x3401)
    {
      sub_100645230(a1, a1 + 104 * (v12 >> 1), a2 - 104);
      sub_100645230(a1 + 104, 104 * v13 + a1 - 104, a2 - 208);
      sub_100645230(a1 + 208, a1 + 104 + 104 * v13, a2 - 312);
      sub_100645230(104 * v13 + a1 - 104, v14, a1 + 104 + 104 * v13);
      unint64_t v15 = *(double *)a1;
      *(void *)a1 = *(void *)v14;
      *(double *)uint64_t v14 = v15;
      id v159 = *(_OWORD *)(a1 + 8);
      __int16 v171 = *(_OWORD *)(a1 + 24);
      *(_OWORD *)double v207 = *(_OWORD *)(a1 + 72);
      *(_OWORD *)&v207[16] = *(_OWORD *)(a1 + 88);
      unint64_t v183 = *(_OWORD *)(a1 + 40);
      long long v195 = *(_OWORD *)(a1 + 56);
      unint64_t v16 = *(_OWORD *)(v14 + 56);
      id v17 = *(_OWORD *)(v14 + 72);
      uint64_t v18 = *(_OWORD *)(v14 + 81);
      *(_OWORD *)(a1 + 40) = *(_OWORD *)(v14 + 40);
      *(_OWORD *)(a1 + 81) = v18;
      *(_OWORD *)(a1 + 72) = v17;
      *(_OWORD *)(a1 + 56) = v16;
      long long v19 = *(_OWORD *)(v14 + 8);
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(v14 + 24);
      *(_OWORD *)(a1 + 8) = v19;
      *(_OWORD *)(v14 + 24) = v171;
      *(_OWORD *)(v14 + 8) = v159;
      *(_OWORD *)(v14 + 81) = *(_OWORD *)&v207[9];
      *(_OWORD *)(v14 + 72) = *(_OWORD *)v207;
      *(_OWORD *)(v14 + 56) = v195;
      *(_OWORD *)(v14 + 40) = v183;
    }
    else
    {
      sub_100645230(a1 + 104 * (v12 >> 1), a1, a2 - 104);
    }
    --a3;
    float v20 = *(double *)a1;
    if ((a4 & 1) != 0 || *(double *)(a1 - 104) > v20)
    {
      float v21 = 0;
      std::string::size_type v144 = *(_OWORD *)(a1 + 8);
      __int16 v147 = *(_OWORD *)(a1 + 24);
      *(_OWORD *)&v156[9] = *(_OWORD *)(a1 + 81);
      id v153 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)id v156 = *(_OWORD *)(a1 + 72);
      id v150 = *(_OWORD *)(a1 + 40);
      do
      {
        double v22 = *(double *)(a1 + v21 + 104);
        v21 += 104;
      }
      while (v22 > v20);
      uint64_t v23 = a1 + v21;
      uint64_t v24 = (double *)a2;
      if (v21 == 104)
      {
        uint64_t v24 = (double *)a2;
        do
        {
          if (v23 >= (unint64_t)v24) {
            break;
          }
          char v26 = *(v24 - 13);
          v24 -= 13;
        }
        while (v26 <= v20);
      }
      else
      {
        do
        {
          unint64_t v25 = *(v24 - 13);
          v24 -= 13;
        }
        while (v25 <= v20);
      }
      if (v23 >= (unint64_t)v24)
      {
        unint64_t v10 = a1 + v21;
      }
      else
      {
        BOOL v27 = *v24;
        unint64_t v10 = a1 + v21;
        uint64_t v28 = v24;
        do
        {
          *(double *)unint64_t v10 = v27;
          *uint64_t v28 = v22;
          id v160 = *(_OWORD *)(v10 + 8);
          int v172 = *(_OWORD *)(v10 + 24);
          *(_OWORD *)__int16 v208 = *(_OWORD *)(v10 + 72);
          *(_OWORD *)&v208[16] = *(_OWORD *)(v10 + 88);
          long long v184 = *(_OWORD *)(v10 + 40);
          long long v196 = *(_OWORD *)(v10 + 56);
          uint64_t v29 = *(_OWORD *)(v28 + 7);
          uint64_t v30 = *(_OWORD *)(v28 + 9);
          double v31 = *(_OWORD *)((char *)v28 + 81);
          *(_OWORD *)(v10 + 40) = *(_OWORD *)(v28 + 5);
          *(_OWORD *)(v10 + 81) = v31;
          *(_OWORD *)(v10 + 72) = v30;
          *(_OWORD *)(v10 + 56) = v29;
          id v32 = *(_OWORD *)(v28 + 1);
          *(_OWORD *)(v10 + 24) = *(_OWORD *)(v28 + 3);
          *(_OWORD *)(v10 + 8) = v32;
          *(_OWORD *)(v28 + 3) = v172;
          *(_OWORD *)(v28 + 1) = v160;
          *(_OWORD *)((char *)v28 + 81) = *(_OWORD *)&v208[9];
          *(_OWORD *)(v28 + 9) = *(_OWORD *)v208;
          *(_OWORD *)(v28 + 7) = v196;
          *(_OWORD *)(v28 + 5) = v184;
          do
          {
            unsigned __int8 v33 = *(double *)(v10 + 104);
            v10 += 104;
            double v22 = v33;
          }
          while (v33 > v20);
          do
          {
            uint64_t v34 = *(v28 - 13);
            v28 -= 13;
            BOOL v27 = v34;
          }
          while (v34 <= v20);
        }
        while (v10 < (unint64_t)v28);
      }
      if (v10 - 104 != a1)
      {
        *(void *)a1 = *(void *)(v10 - 104);
        uint64_t v35 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 24) = v35;
        id v36 = *(_OWORD *)(v10 - 64);
        unsigned __int8 v37 = *(_OWORD *)(v10 - 48);
        uint64_t v38 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 81) = *(_OWORD *)(v10 - 23);
        *(_OWORD *)(a1 + 56) = v37;
        *(_OWORD *)(a1 + 72) = v38;
        *(_OWORD *)(a1 + 40) = v36;
      }
      *(double *)(v10 - 104) = v20;
      *(_OWORD *)(v10 - 96) = v144;
      *(_OWORD *)(v10 - 80) = v147;
      *(_OWORD *)(v10 - 23) = *(_OWORD *)&v156[9];
      *(_OWORD *)(v10 - 48) = v153;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v156;
      *(_OWORD *)(v10 - 64) = v150;
      if (v23 < (unint64_t)v24) {
        goto LABEL_32;
      }
      uint64_t v39 = sub_100645474(a1, v10 - 104);
      if (sub_100645474(v10, a2))
      {
        a2 = v10 - 104;
        if (v39) {
          return;
        }
        goto LABEL_1;
      }
      if (!v39)
      {
LABEL_32:
        sub_100644450(a1, v10 - 104, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v145 = *(_OWORD *)(a1 + 8);
      id v148 = *(_OWORD *)(a1 + 24);
      *(_OWORD *)&v157[9] = *(_OWORD *)(a1 + 81);
      unint64_t v154 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)uint64_t v157 = *(_OWORD *)(a1 + 72);
      id v151 = *(_OWORD *)(a1 + 40);
      if (v20 <= *(double *)(a2 - 104))
      {
        id v41 = a1 + 104;
        do
        {
          unint64_t v10 = v41;
          if (v41 >= a2) {
            break;
          }
          v41 += 104;
        }
        while (v20 <= *(double *)v10);
      }
      else
      {
        unint64_t v10 = a1;
        do
        {
          uint64_t v40 = *(double *)(v10 + 104);
          v10 += 104;
        }
        while (v20 <= v40);
      }
      unsigned __int8 v42 = a2;
      if (v10 < a2)
      {
        unsigned __int8 v42 = a2;
        do
        {
          unint64_t v43 = *(double *)(v42 - 104);
          v42 -= 104;
        }
        while (v20 > v43);
      }
      if (v10 < v42)
      {
        unint64_t v44 = *(double *)v10;
        id v45 = *(double *)v42;
        do
        {
          *(double *)unint64_t v10 = v45;
          *(double *)unsigned __int8 v42 = v44;
          id v161 = *(_OWORD *)(v10 + 8);
          __int16 v173 = *(_OWORD *)(v10 + 24);
          *(_OWORD *)uint64_t v209 = *(_OWORD *)(v10 + 72);
          *(_OWORD *)&v209[16] = *(_OWORD *)(v10 + 88);
          long long v185 = *(_OWORD *)(v10 + 40);
          long long v197 = *(_OWORD *)(v10 + 56);
          id v46 = *(_OWORD *)(v42 + 56);
          uint64_t v47 = *(_OWORD *)(v42 + 72);
          uint64_t v48 = *(_OWORD *)(v42 + 81);
          *(_OWORD *)(v10 + 40) = *(_OWORD *)(v42 + 40);
          *(_OWORD *)(v10 + 81) = v48;
          *(_OWORD *)(v10 + 72) = v47;
          *(_OWORD *)(v10 + 56) = v46;
          uint64_t v49 = *(_OWORD *)(v42 + 8);
          *(_OWORD *)(v10 + 24) = *(_OWORD *)(v42 + 24);
          *(_OWORD *)(v10 + 8) = v49;
          *(_OWORD *)(v42 + 24) = v173;
          *(_OWORD *)(v42 + 8) = v161;
          *(_OWORD *)(v42 + 81) = *(_OWORD *)&v209[9];
          *(_OWORD *)(v42 + 72) = *(_OWORD *)v209;
          *(_OWORD *)(v42 + 56) = v197;
          *(_OWORD *)(v42 + 40) = v185;
          do
          {
            uint64_t v50 = *(double *)(v10 + 104);
            v10 += 104;
            unint64_t v44 = v50;
          }
          while (v20 <= v50);
          do
          {
            uint64_t v51 = *(double *)(v42 - 104);
            v42 -= 104;
            id v45 = v51;
          }
          while (v20 > v51);
        }
        while (v10 < v42);
      }
      unint64_t v4 = v10 - 104 >= a1;
      char v5 = v10 - 104 == a1;
      if (v10 - 104 != a1)
      {
        *(void *)a1 = *(void *)(v10 - 104);
        uint64_t v52 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 24) = v52;
        uint64_t v53 = *(_OWORD *)(v10 - 64);
        unint64_t v54 = *(_OWORD *)(v10 - 48);
        id v55 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 81) = *(_OWORD *)(v10 - 23);
        *(_OWORD *)(a1 + 56) = v54;
        *(_OWORD *)(a1 + 72) = v55;
        *(_OWORD *)(a1 + 40) = v53;
      }
      a4 = 0;
      *(double *)(v10 - 104) = v20;
      *(_OWORD *)(v10 - 96) = v145;
      *(_OWORD *)(v10 - 80) = v148;
      *(_OWORD *)(v10 - 23) = *(_OWORD *)&v157[9];
      *(_OWORD *)(v10 - 48) = v154;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v157;
      *(_OWORD *)(v10 - 64) = v151;
    }
  }
  __int16 v79 = v10 + 104;
  __int16 v81 = v10 == a2 || v79 == a2;
  if (a4)
  {
    if (!v81)
    {
      unint64_t v82 = 0;
      __int16 v83 = v10;
      do
      {
        uint64_t v84 = v79;
        __int16 v85 = *(double *)(v83 + 104);
        if (v85 > *(double *)v83)
        {
          id v167 = *(_OWORD *)(v83 + 112);
          long long v179 = *(_OWORD *)(v83 + 128);
          *(_OWORD *)&v215[9] = *(_OWORD *)(v83 + 185);
          __int16 v203 = *(_OWORD *)(v83 + 160);
          *(_OWORD *)uint64_t v215 = *(_OWORD *)(v83 + 176);
          long long v191 = *(_OWORD *)(v83 + 144);
          double v86 = v82;
          uint64_t v87 = *(double *)v83;
          while (1)
          {
            double v88 = v10 + v86;
            *(double *)(v88 + 104) = v87;
            __int16 v89 = *(_OWORD *)(v10 + v86 + 56);
            *(_OWORD *)(v88 + 144) = *(_OWORD *)(v10 + v86 + 40);
            *(_OWORD *)(v88 + 160) = v89;
            *(_OWORD *)(v88 + 176) = *(_OWORD *)(v10 + v86 + 72);
            *(_OWORD *)(v88 + 185) = *(_OWORD *)(v10 + v86 + 81);
            uint64_t v90 = *(_OWORD *)(v10 + v86 + 24);
            *(_OWORD *)(v88 + 112) = *(_OWORD *)(v10 + v86 + 8);
            *(_OWORD *)(v88 + 128) = v90;
            if (!v86) {
              break;
            }
            uint64_t v87 = *(double *)(v88 - 104);
            v86 -= 104;
            if (v85 <= v87)
            {
              __int16 v91 = (double *)(v10 + v86 + 104);
              goto LABEL_83;
            }
          }
          __int16 v91 = (double *)v10;
LABEL_83:
          *__int16 v91 = v85;
          *(_OWORD *)(v88 + 24) = v179;
          *(_OWORD *)(v88 + 8) = v167;
          *(_OWORD *)(v88 + 81) = *(_OWORD *)&v215[9];
          *(_OWORD *)(v88 + 72) = *(_OWORD *)v215;
          *(_OWORD *)(v88 + 56) = v203;
          *(_OWORD *)(v88 + 40) = v191;
        }
        __int16 v79 = v84 + 104;
        v82 += 104;
        __int16 v83 = v84;
      }
      while (v84 + 104 != a2);
    }
  }
  else if (!v81)
  {
    uint64_t v137 = (_OWORD *)(v10 + 112);
    do
    {
      uint64_t v138 = v79;
      unint64_t v139 = *(double *)(a1 + 104);
      if (v139 > *(double *)a1)
      {
        double v170 = *(_OWORD *)(a1 + 112);
        long long v182 = *(_OWORD *)(a1 + 128);
        *(_OWORD *)&v218[9] = *(_OWORD *)(a1 + 185);
        __int16 v206 = *(_OWORD *)(a1 + 160);
        *(_OWORD *)char v218 = *(_OWORD *)(a1 + 176);
        long long v194 = *(_OWORD *)(a1 + 144);
        id v140 = v137;
        unint64_t v141 = *(double *)a1;
        do
        {
          *((double *)v140 - 1) = v141;
          unint64_t v142 = *(_OWORD *)((char *)v140 - 56);
          v140[2] = *(_OWORD *)((char *)v140 - 72);
          v140[3] = v142;
          v140[4] = *(_OWORD *)((char *)v140 - 40);
          *(_OWORD *)((char *)v140 + 73) = *(_OWORD *)((char *)v140 - 31);
          id v143 = *(_OWORD *)((char *)v140 - 88);
          *id v140 = *(_OWORD *)((char *)v140 - 104);
          v140[1] = v143;
          unint64_t v141 = *((double *)v140 - 27);
          id v140 = (_OWORD *)((char *)v140 - 104);
        }
        while (v139 > v141);
        *((double *)v140 - 1) = v139;
        *id v140 = v170;
        v140[1] = v182;
        *(_OWORD *)((char *)v140 + 73) = *(_OWORD *)&v218[9];
        v140[3] = v206;
        v140[4] = *(_OWORD *)v218;
        v140[2] = v194;
      }
      __int16 v79 = v138 + 104;
      uint64_t v137 = (_OWORD *)((char *)v137 + 104);
      a1 = v138;
    }
    while (v138 + 104 != a2);
  }
}

  unint64_t v10 = a2 - 6;
  uint64_t i = a1;
  while (1)
  {
    a1 = i;
    uint64_t v12 = (uint64_t)a2 - i;
    uint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - i) >> 5);
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          double v86 = *((_DWORD *)a2 - 10);
          uint64_t v87 = *(_DWORD *)(i + 56);
          if (v86 > v87
            || v86 == v87
            && ((v88 = *((_DWORD *)a2 - 18), __int16 v89 = *(_DWORD *)(i + 24), v88 > v89)
             || v88 == v89 && *((double *)a2 - 7) < *(double *)(i + 40)))
          {
            int v230 = *(_OWORD *)i;
            double v238 = *(_OWORD *)(i + 16);
            *(_OWORD *)__int16 v253 = *(_OWORD *)(i + 64);
            *(_OWORD *)&v253[16] = *(_OWORD *)(i + 80);
            __int16 v243 = *(_OWORD *)(i + 32);
            int v248 = *(_OWORD *)(i + 48);
            __int16 v91 = *(a2 - 3);
            uint64_t v90 = *(a2 - 2);
            unint64_t v92 = *(a2 - 4);
            *(_OWORD *)(i + 73) = *(_OWORD *)((char *)a2 - 23);
            *(_OWORD *)(i + 48) = v91;
            *(_OWORD *)(i + 64) = v90;
            *(_OWORD *)(i + 32) = v92;
            __int16 v93 = *(a2 - 5);
            *(_OWORD *)uint64_t i = *v10;
            *(_OWORD *)(i + 16) = v93;
            *unint64_t v10 = v230;
            *(a2 - 5) = v238;
            *(_OWORD *)((char *)a2 - 23) = *(_OWORD *)&v253[9];
            *(a2 - 3) = v248;
            *(a2 - 2) = *(_OWORD *)v253;
            *(a2 - 4) = v243;
          }
          break;
        case 3uLL:
          sub_1006475F4(i, i + 96, (uint64_t)(a2 - 6));
          break;
        case 4uLL:
          sub_100647BF0(i, i + 96, i + 192, (uint64_t)(a2 - 6));
          break;
        case 5uLL:
          sub_100647364(i, i + 96, i + 192, i + 288, (uint64_t)(a2 - 6));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v12 <= 2303)
    {
      uint64_t v94 = (_OWORD *)(i + 96);
      double v96 = (_OWORD *)i == a2 || v94 == a2;
      if (a4)
      {
        if (v96) {
          return;
        }
        id v97 = 0;
        id v98 = i;
        while (2)
        {
          int v99 = v98;
          id v98 = (unint64_t)v94;
          int v100 = *(_DWORD *)(v99 + 152);
          uint64_t v101 = *(_DWORD *)(v99 + 56);
          if (v100 > v101)
          {
            id v102 = *(_DWORD *)(v99 + 120);
            goto LABEL_154;
          }
          if (v100 == v101)
          {
            id v102 = *(_DWORD *)(v99 + 120);
            int64_t v103 = *(_DWORD *)(v99 + 24);
            if (v102 > v103 || v102 == v103 && *(double *)(v99 + 136) < *(double *)(v99 + 40))
            {
LABEL_154:
              __int16 v206 = *(void *)(v98 + 16);
              double v202 = *(_OWORD *)v98;
              char v217 = *(void *)(v99 + 124);
              uint64_t v221 = *(_DWORD *)(v99 + 132);
              unint64_t v104 = *(double *)(v99 + 136);
              uint64_t v105 = *(void *)(v99 + 144);
              *(_OWORD *)v231 = *(_OWORD *)(v99 + 156);
              *(_OWORD *)&v231[16] = *(_OWORD *)(v99 + 172);
              unint64_t v106 = *(_OWORD *)(v99 + 64);
              *(_OWORD *)(v98 + 48) = *(_OWORD *)(v99 + 48);
              *(_OWORD *)(v98 + 64) = v106;
              *(_OWORD *)(v98 + 73) = *(_OWORD *)(v99 + 73);
              uint64_t v107 = *(_OWORD *)(v99 + 32);
              *(_OWORD *)(v98 + 16) = *(_OWORD *)(v99 + 16);
              *(_OWORD *)(v98 + 32) = v107;
              id v108 = i;
              *(_OWORD *)id v98 = *(_OWORD *)v99;
              if (v99 != i)
              {
                uint64_t v109 = v97;
                while (1)
                {
                  uint64_t v110 = (_OWORD *)(i + v109);
                  long long v111 = *(_DWORD *)(i + v109 - 40);
                  if (v100 <= v111)
                  {
                    if (v100 != v111)
                    {
                      id v108 = i + v109;
                      goto LABEL_165;
                    }
                    int v112 = *(_DWORD *)(i + v109 - 72);
                    if (v102 <= v112 && (v102 != v112 || v104 >= *(double *)(i + v109 - 56))) {
                      break;
                    }
                  }
                  v99 -= 96;
                  id v113 = *(v110 - 3);
                  v110[2] = *(v110 - 4);
                  v110[3] = v113;
                  v110[4] = *(v110 - 2);
                  *(_OWORD *)((char *)v110 + 73) = *(_OWORD *)((char *)v110 - 23);
                  uint64_t v114 = *(v110 - 5);
                  *uint64_t v110 = *(v110 - 6);
                  v110[1] = v114;
                  v109 -= 96;
                  if (!v109)
                  {
                    id v108 = i;
                    goto LABEL_165;
                  }
                }
                id v108 = v99;
              }
LABEL_165:
              *(void *)(v108 + 16) = v206;
              *(_OWORD *)id v108 = v202;
              *(_DWORD *)(v108 + 24) = v102;
              *(void *)(v108 + 28) = v217;
              *(_DWORD *)(v108 + 36) = v221;
              *(double *)(v108 + 40) = v104;
              *(void *)(v108 + 48) = v105;
              *(_DWORD *)(v108 + 56) = v100;
              *(_OWORD *)(v108 + 60) = *(_OWORD *)v231;
              *(_OWORD *)(v108 + 73) = *(_OWORD *)&v231[13];
            }
          }
          uint64_t v94 = (_OWORD *)(v98 + 96);
          v97 += 96;
          if ((_OWORD *)(v98 + 96) == a2) {
            return;
          }
          continue;
        }
      }
      if (v96) {
        return;
      }
      while (2)
      {
        long long v186 = a1;
        a1 = (unint64_t)v94;
        long long v187 = *(_DWORD *)(v186 + 152);
        std::string v188 = *(_DWORD *)(v186 + 56);
        if (v187 <= v188)
        {
          if (v187 == v188)
          {
            float v189 = *(_DWORD *)(v186 + 120);
            long long v190 = *(_DWORD *)(v186 + 24);
            if (v189 > v190 || v189 == v190 && *(double *)(v186 + 136) < *(double *)(v186 + 40)) {
              goto LABEL_241;
            }
          }
        }
        else
        {
          float v189 = *(_DWORD *)(v186 + 120);
LABEL_241:
          __int16 v208 = *(void *)(a1 + 16);
          unint64_t v205 = *(_OWORD *)a1;
          double v220 = *(void *)(v186 + 124);
          uint64_t v223 = *(_DWORD *)(v186 + 132);
          long long v191 = *(double *)(v186 + 136);
          unint64_t v192 = *(void *)(v186 + 144);
          long long v193 = *(_OWORD *)(v186 + 156);
          long long v194 = *(_OWORD *)(v186 + 172);
          long long v195 = (_OWORD *)a1;
          *(_DWORD *)v234 = HIDWORD(v193);
          *(_OWORD *)&v234[4] = v194;
          while (1)
          {
            long long v196 = *(v195 - 3);
            v195[2] = *(v195 - 4);
            v195[3] = v196;
            v195[4] = *(v195 - 2);
            *(_OWORD *)((char *)v195 + 73) = *(_OWORD *)((char *)v195 - 23);
            long long v197 = *(v195 - 5);
            const char *v195 = *(v195 - 6);
            v195[1] = v197;
            long long v198 = *((_DWORD *)v195 - 34);
            if (v187 <= v198)
            {
              if (v187 != v198) {
                break;
              }
              long long v199 = *((_DWORD *)v195 - 42);
              if (v189 <= v199 && (v189 != v199 || v191 >= *((double *)v195 - 19))) {
                break;
              }
            }
            v195 -= 6;
          }
          *((void *)v195 - 10) = v208;
          *(v195 - 6) = v205;
          *((_DWORD *)v195 - 18) = v189;
          *((_DWORD *)v195 - 15) = v223;
          *(void *)((char *)v195 - 68) = v220;
          *((double *)v195 - 7) = v191;
          *((void *)v195 - 6) = v192;
          *((_DWORD *)v195 - 10) = v187;
          *(_OWORD *)((char *)v195 - 23) = *(_OWORD *)&v234[1];
          *(_OWORD *)((char *)v195 - 36) = v193;
        }
        uint64_t v94 = (_OWORD *)(a1 + 96);
        if ((_OWORD *)(a1 + 96) == a2) {
          return;
        }
        continue;
      }
    }
    if (!a3) {
      break;
    }
    uint64_t v14 = v13 >> 1;
    unint64_t v15 = (_OWORD *)(i + 96 * (v13 >> 1));
    if ((unint64_t)v12 > 0x3000)
    {
      sub_1006475F4(a1, a1 + 96 * (v13 >> 1), (uint64_t)(a2 - 6));
      unint64_t v16 = 3 * v14;
      id v17 = a1 + 96 * v14 - 96;
      sub_1006475F4(a1 + 96, v17, (uint64_t)(a2 - 12));
      uint64_t v18 = a1 + 96 + 32 * v16;
      sub_1006475F4(a1 + 192, v18, (uint64_t)(a2 - 18));
      sub_1006475F4(v17, (uint64_t)v15, v18);
      char v227 = *(_OWORD *)a1;
      __int16 v235 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)double v250 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v250[16] = *(_OWORD *)(a1 + 80);
      uint64_t v240 = *(_OWORD *)(a1 + 32);
      __int16 v245 = *(_OWORD *)(a1 + 48);
      float v20 = v15[3];
      long long v19 = v15[4];
      float v21 = v15[2];
      *(_OWORD *)(a1 + 73) = *(_OWORD *)((char *)v15 + 73);
      *(_OWORD *)(a1 + 48) = v20;
      *(_OWORD *)(a1 + 64) = v19;
      *(_OWORD *)(a1 + 32) = v21;
      double v22 = v15[1];
      *(_OWORD *)a1 = *v15;
      *(_OWORD *)(a1 + 16) = v22;
      unsigned char *v15 = v227;
      v15[1] = v235;
      *(_OWORD *)((char *)v15 + 73) = *(_OWORD *)&v250[9];
      v15[3] = v245;
      v15[4] = *(_OWORD *)v250;
      _DWORD v15[2] = v240;
    }
    else
    {
      sub_1006475F4(a1 + 96 * (v13 >> 1), a1, (uint64_t)(a2 - 6));
    }
    --a3;
    if (a4)
    {
      uint64_t v23 = *(_DWORD *)(a1 + 56);
LABEL_18:
      char v26 = 0;
      char v224 = *(void *)(a1 + 16);
      uint64_t v215 = *(_OWORD *)a1;
      BOOL v27 = *(_DWORD *)(a1 + 24);
      uint64_t v209 = *(void *)(a1 + 28);
      int v212 = *(_DWORD *)(a1 + 36);
      uint64_t v28 = *(double *)(a1 + 40);
      uint64_t v29 = *(void *)(a1 + 48);
      *(_OWORD *)long long v200 = *(_OWORD *)(a1 + 60);
      *(_OWORD *)&v200[16] = *(_OWORD *)(a1 + 76);
      while (1)
      {
        uint64_t v30 = *(_DWORD *)(a1 + v26 + 152);
        if (v30 <= v23)
        {
          if (v30 != v23) {
            break;
          }
          double v31 = *(_DWORD *)(a1 + v26 + 120);
          if (v31 <= v27 && (v31 != v27 || *(double *)(a1 + v26 + 136) >= v28)) {
            break;
          }
        }
        v26 += 96;
      }
      id v32 = a1 + v26 + 96;
      if (v26)
      {
        unsigned __int8 v33 = *((_DWORD *)a2 - 10);
        uint64_t v34 = (double *)a2 - 7;
        uint64_t v35 = (double *)(a2 - 6);
        if (v33 <= v23)
        {
          do
          {
            if (v33 == v23)
            {
              id v36 = *((_DWORD *)v34 - 4);
              if (v36 > v27) {
                goto LABEL_49;
              }
              if (v36 == v27 && *v34 < v28) {
                break;
              }
            }
            v35 -= 12;
            unsigned __int8 v33 = *((_DWORD *)v34 - 20);
            v34 -= 12;
          }
          while (v33 <= v23);
LABEL_32:
          uint64_t v35 = v34 - 5;
        }
      }
      else
      {
        uint64_t v35 = (double *)a2;
        if (v32 < (unint64_t)a2)
        {
          unsigned __int8 v37 = *((_DWORD *)a2 - 10);
          uint64_t v35 = (double *)(a2 - 6);
          if (v37 <= v23)
          {
            uint64_t v34 = (double *)a2 - 7;
            uint64_t v35 = (double *)(a2 - 6);
            while (1)
            {
              uint64_t v38 = v34 - 5;
              if (v37 != v23) {
                goto LABEL_45;
              }
              uint64_t v39 = *((_DWORD *)v34 - 4);
              if (v39 > v27) {
                break;
              }
              if (v39 == v27)
              {
                if (*v34 < v28 || v32 >= (unint64_t)v38) {
                  break;
                }
              }
              else
              {
LABEL_45:
                if (v32 >= (unint64_t)v38)
                {
                  uint64_t v35 = v34 - 5;
                  break;
                }
              }
              v35 -= 12;
              unsigned __int8 v37 = *((_DWORD *)v34 - 20);
              v34 -= 12;
              if (v37 > v23) {
                goto LABEL_32;
              }
            }
          }
        }
      }
LABEL_49:
      uint64_t i = v32;
      if (v32 < (unint64_t)v35)
      {
        id v41 = v35;
        do
        {
          uint64_t v228 = *(_OWORD *)i;
          v236 = *(_OWORD *)(i + 16);
          *(_OWORD *)__int16 v251 = *(_OWORD *)(i + 64);
          *(_OWORD *)&v251[16] = *(_OWORD *)(i + 80);
          __int16 v241 = *(_OWORD *)(i + 32);
          double v246 = *(_OWORD *)(i + 48);
          unint64_t v43 = *((_OWORD *)v41 + 3);
          unsigned __int8 v42 = *((_OWORD *)v41 + 4);
          unint64_t v44 = *((_OWORD *)v41 + 2);
          *(_OWORD *)(i + 73) = *(_OWORD *)((char *)v41 + 73);
          *(_OWORD *)(i + 48) = v43;
          *(_OWORD *)(i + 64) = v42;
          *(_OWORD *)(i + 32) = v44;
          id v45 = *((_OWORD *)v41 + 1);
          *(_OWORD *)uint64_t i = *(_OWORD *)v41;
          *(_OWORD *)(i + 16) = v45;
          *(_OWORD *)id v41 = v228;
          *((_OWORD *)v41 + 1) = v236;
          *(_OWORD *)((char *)v41 + 73) = *(_OWORD *)&v251[9];
          *((_OWORD *)v41 + 3) = v246;
          *((_OWORD *)v41 + 4) = *(_OWORD *)v251;
          *((_OWORD *)v41 + 2) = v241;
          do
          {
            do
            {
              i += 96;
              id v46 = *(_DWORD *)(i + 56);
            }
            while (v46 > v23);
            if (v46 != v23) {
              break;
            }
            uint64_t v47 = *(_DWORD *)(i + 24);
          }
          while (v47 > v27 || v47 == v27 && *(double *)(i + 40) < v28);
          uint64_t v48 = v41 - 12;
          uint64_t v49 = *((_DWORD *)v41 - 10);
          if (v49 <= v23)
          {
            uint64_t v50 = v41 - 7;
            do
            {
              if (v49 == v23)
              {
                uint64_t v51 = *((_DWORD *)v50 - 4);
                if (v51 > v27) {
                  break;
                }
                if (v51 == v27 && *v50 < v28) {
                  goto LABEL_65;
                }
              }
              v48 -= 12;
              uint64_t v49 = *((_DWORD *)v50 - 20);
              v50 -= 12;
            }
            while (v49 <= v23);
            uint64_t v48 = v50 - 5;
          }
LABEL_65:
          id v41 = v48;
        }
        while (i < (unint64_t)v48);
      }
      uint64_t v52 = (_OWORD *)(i - 96);
      if (i - 96 != a1)
      {
        uint64_t v53 = *(_OWORD *)(i - 80);
        *(_OWORD *)a1 = *v52;
        *(_OWORD *)(a1 + 16) = v53;
        unint64_t v54 = *(_OWORD *)(i - 64);
        id v55 = *(_OWORD *)(i - 48);
        id v56 = *(_OWORD *)(i - 32);
        *(_OWORD *)(a1 + 73) = *(_OWORD *)(i - 23);
        *(_OWORD *)(a1 + 48) = v55;
        *(_OWORD *)(a1 + 64) = v56;
        *(_OWORD *)(a1 + 32) = v54;
      }
      *(void *)(i - 80) = v224;
      *uint64_t v52 = v215;
      *(_DWORD *)(i - 72) = v27;
      *(_DWORD *)(i - 60) = v212;
      *(void *)(i - 68) = v209;
      *(double *)(i - 56) = v28;
      *(void *)(i - 48) = v29;
      *(_DWORD *)(i - 40) = v23;
      *(_OWORD *)(i - 23) = *(_OWORD *)&v200[13];
      *(_OWORD *)(i - 36) = *(_OWORD *)v200;
      if (v32 < (unint64_t)v35) {
        goto LABEL_71;
      }
      id v57 = sub_1006478B0(a1, i - 96);
      if (sub_1006478B0(i, (uint64_t)a2))
      {
        a2 = (_OWORD *)(i - 96);
        if (v57) {
          return;
        }
        goto LABEL_1;
      }
      if (!v57)
      {
LABEL_71:
        sub_100646260(a1, i - 96, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v23 = *(_DWORD *)(a1 - 40);
      uint64_t v24 = *(_DWORD *)(a1 + 56);
      if (v23 > v24)
      {
        uint64_t v23 = *(_DWORD *)(a1 + 56);
        goto LABEL_18;
      }
      if (v23 == v24)
      {
        unint64_t v25 = *(_DWORD *)(a1 - 72);
        id v58 = *(_DWORD *)(a1 + 24);
        if (v25 > v58) {
          goto LABEL_18;
        }
        if (v25 == v58)
        {
          if (*(double *)(a1 - 56) < *(double *)(a1 + 40)) {
            goto LABEL_18;
          }
          id v58 = *(_DWORD *)(a1 - 72);
        }
      }
      else
      {
        id v58 = *(_DWORD *)(a1 + 24);
      }
      uint64_t v225 = *(void *)(a1 + 16);
      int v216 = *(_OWORD *)a1;
      double v213 = *(_DWORD *)(a1 + 36);
      int v210 = *(void *)(a1 + 28);
      id v59 = *(double *)(a1 + 40);
      double v60 = *(void *)(a1 + 48);
      *(_OWORD *)double v201 = *(_OWORD *)(a1 + 60);
      *(_OWORD *)&v201[16] = *(_OWORD *)(a1 + 76);
      id v61 = *((_DWORD *)a2 - 10);
      if (v24 > v61
        || v24 == v61 && ((unint64_t v68 = *((_DWORD *)a2 - 18), v58 > v68) || v58 == v68 && v59 < *((double *)a2 - 7)))
      {
        uint64_t i = a1 + 96;
        unint64_t v62 = *(_DWORD *)(a1 + 152);
        if (v24 <= v62)
        {
          int v63 = a1 + 136;
          do
          {
            if (v24 == v62)
            {
              id v64 = *(_DWORD *)(v63 - 16);
              if (v58 > v64) {
                goto LABEL_82;
              }
              if (v58 == v64 && v59 < *(double *)v63) {
                break;
              }
            }
            i += 96;
            unint64_t v62 = *(_DWORD *)(v63 + 112);
            v63 += 96;
          }
          while (v24 <= v62);
          uint64_t i = v63 - 40;
        }
      }
      else
      {
        for (uint64_t i = a1 + 96; i < (unint64_t)a2; i += 96)
        {
          long long v69 = *(_DWORD *)(i + 56);
          if (v24 > v69) {
            break;
          }
          if (v24 == v69)
          {
            long long v70 = *(_DWORD *)(i + 24);
            if (v58 > v70 || v58 == v70 && v59 < *(double *)(i + 40)) {
              break;
            }
          }
        }
      }
LABEL_82:
      uint64_t v65 = (double *)a2;
      if (i < (unint64_t)a2)
      {
        for (j = (double *)a2 - 7; ; j -= 12)
        {
          if (v24 <= v61)
          {
            if (v24 != v61) {
              break;
            }
            id v67 = *((_DWORD *)j - 4);
            if (v58 <= v67 && (v58 != v67 || v59 >= *j)) {
              break;
            }
          }
          id v61 = *((_DWORD *)j - 20);
        }
        uint64_t v65 = j - 5;
      }
      while (i < (unint64_t)v65)
      {
        __int16 v229 = *(_OWORD *)i;
        __int16 v237 = *(_OWORD *)(i + 16);
        *(_OWORD *)double v252 = *(_OWORD *)(i + 64);
        *(_OWORD *)&v252[16] = *(_OWORD *)(i + 80);
        uint64_t v242 = *(_OWORD *)(i + 32);
        __int16 v247 = *(_OWORD *)(i + 48);
        long long v72 = *((_OWORD *)v65 + 3);
        long long v71 = *((_OWORD *)v65 + 4);
        id v73 = *((_OWORD *)v65 + 2);
        *(_OWORD *)(i + 73) = *(_OWORD *)((char *)v65 + 73);
        *(_OWORD *)(i + 48) = v72;
        *(_OWORD *)(i + 64) = v71;
        *(_OWORD *)(i + 32) = v73;
        int v74 = *((_OWORD *)v65 + 1);
        *(_OWORD *)uint64_t i = *(_OWORD *)v65;
        *(_OWORD *)(i + 16) = v74;
        *(_OWORD *)uint64_t v65 = v229;
        *((_OWORD *)v65 + 1) = v237;
        *(_OWORD *)((char *)v65 + 73) = *(_OWORD *)&v252[9];
        *((_OWORD *)v65 + 3) = v247;
        *((_OWORD *)v65 + 4) = *(_OWORD *)v252;
        *((_OWORD *)v65 + 2) = v242;
        long long v75 = i + 96;
        uint64_t v76 = *(_DWORD *)(i + 152);
        if (v24 <= v76)
        {
          id v77 = i + 136;
          do
          {
            if (v24 == v76)
            {
              uint64_t v78 = *(_DWORD *)(v77 - 16);
              if (v58 > v78) {
                break;
              }
              if (v58 == v78 && v59 < *(double *)v77) {
                goto LABEL_104;
              }
            }
            v75 += 96;
            uint64_t v76 = *(_DWORD *)(v77 + 112);
            v77 += 96;
          }
          while (v24 <= v76);
          uint64_t i = v77 - 40;
        }
        else
        {
LABEL_104:
          uint64_t i = v75;
        }
        do
        {
          do
          {
            v65 -= 12;
            __int16 v79 = *((_DWORD *)v65 + 14);
          }
          while (v24 > v79);
          if (v24 != v79) {
            break;
          }
          uint64_t v80 = *((_DWORD *)v65 + 6);
        }
        while (v58 > v80 || v58 == v80 && v59 < v65[5]);
      }
      __int16 v81 = (_OWORD *)(i - 96);
      unint64_t v4 = i - 96 >= a1;
      char v5 = i - 96 == a1;
      if (i - 96 != a1)
      {
        unint64_t v82 = *(_OWORD *)(i - 80);
        *(_OWORD *)a1 = *v81;
        *(_OWORD *)(a1 + 16) = v82;
        __int16 v83 = *(_OWORD *)(i - 64);
        uint64_t v84 = *(_OWORD *)(i - 48);
        __int16 v85 = *(_OWORD *)(i - 32);
        *(_OWORD *)(a1 + 73) = *(_OWORD *)(i - 23);
        *(_OWORD *)(a1 + 48) = v84;
        *(_OWORD *)(a1 + 64) = v85;
        *(_OWORD *)(a1 + 32) = v83;
      }
      a4 = 0;
      *(void *)(i - 80) = v225;
      *__int16 v81 = v216;
      *(_DWORD *)(i - 72) = v58;
      *(_DWORD *)(i - 60) = v213;
      *(void *)(i - 68) = v210;
      *(double *)(i - 56) = v59;
      *(void *)(i - 48) = v60;
      *(_DWORD *)(i - 40) = v24;
      *(_OWORD *)(i - 23) = *(_OWORD *)&v201[13];
      *(_OWORD *)(i - 36) = *(_OWORD *)v201;
    }
  }
  if ((_OWORD *)i != a2)
  {
    uint64_t v115 = (v13 - 2) >> 1;
    double v116 = v115;
    while (2)
    {
      double v117 = v116;
      if (v115 >= v116)
      {
        id v118 = (2 * v116) | 1;
        id v119 = i + 96 * v118;
        if (2 * v117 + 2 < (uint64_t)v13)
        {
          unint64_t v120 = *(_DWORD *)(i + 96 * v118 + 56);
          unint64_t v121 = *(_DWORD *)(v119 + 152);
          if (v120 > v121
            || v120 == v121
            && ((v122 = *(_DWORD *)(i + 96 * v118 + 24), double v123 = *(_DWORD *)(v119 + 120), v122 > v123)
             || v122 == v123 && *(double *)(i + 96 * v118 + 40) < *(double *)(v119 + 136)))
          {
            v119 += 96;
            id v118 = 2 * v117 + 2;
          }
        }
        id v124 = *(_DWORD *)(v119 + 56);
        id v125 = *(_DWORD *)(i + 96 * v117 + 56);
        if (v124 <= v125)
        {
          unint64_t v126 = i + 96 * v117;
          if (v124 == v125)
          {
            uint64_t v127 = *(_DWORD *)(v119 + 24);
            id v128 = *(_DWORD *)(i + 96 * v117 + 24);
            if (v127 <= v128)
            {
              if (v127 != v128) {
                goto LABEL_184;
              }
              id v128 = *(_DWORD *)(v119 + 24);
              if (*(double *)(v119 + 40) >= *(double *)(i + 96 * v117 + 40)) {
                goto LABEL_184;
              }
            }
          }
          else
          {
            id v128 = *(_DWORD *)(v126 + 24);
LABEL_184:
            double v207 = *(void *)(v126 + 16);
            __int16 v203 = *(_OWORD *)v126;
            char v222 = *(_DWORD *)(v126 + 36);
            char v218 = *(void *)(v126 + 28);
            uint64_t v129 = *(double *)(v126 + 40);
            double v130 = *(void *)(v126 + 48);
            *(_OWORD *)int v232 = *(_OWORD *)(v126 + 60);
            *(_OWORD *)&v232[16] = *(_OWORD *)(v126 + 76);
            uint64_t v131 = *(_OWORD *)(v119 + 16);
            *(_OWORD *)unint64_t v126 = *(_OWORD *)v119;
            for (*(_OWORD *)(v126 + 16) = v131; ; *(_OWORD *)(v126 + 16) = v143)
            {
              id v132 = *(_OWORD *)(v119 + 32);
              uint64_t v133 = *(_OWORD *)(v119 + 48);
              uint64_t v134 = *(_OWORD *)(v119 + 64);
              *(_OWORD *)(v126 + 73) = *(_OWORD *)(v119 + 73);
              *(_OWORD *)(v126 + 48) = v133;
              *(_OWORD *)(v126 + 64) = v134;
              *(_OWORD *)(v126 + 32) = v132;
              if (v115 < v118) {
                goto LABEL_200;
              }
              unint64_t v126 = v119;
              id v135 = 2 * v118;
              id v118 = (2 * v118) | 1;
              id v119 = i + 96 * v118;
              uint64_t v136 = v135 + 2;
              if (v136 < (uint64_t)v13)
              {
                uint64_t v137 = *(_DWORD *)(i + 96 * v118 + 56);
                uint64_t v138 = *(_DWORD *)(v119 + 152);
                if (v137 > v138
                  || v137 == v138
                  && ((unint64_t v139 = *(_DWORD *)(i + 96 * v118 + 24), v140 = *(_DWORD *)(v119 + 120), v139 > v140)
                   || v139 == v140 && *(double *)(i + 96 * v118 + 40) < *(double *)(v119 + 136)))
                {
                  v119 += 96;
                  id v118 = v136;
                }
              }
              unint64_t v141 = *(_DWORD *)(v119 + 56);
              if (v141 > v125) {
                break;
              }
              if (v141 == v125)
              {
                unint64_t v142 = *(_DWORD *)(v119 + 24);
                if (v142 > v128 || v142 == v128 && *(double *)(v119 + 40) < v129) {
                  break;
                }
              }
              id v143 = *(_OWORD *)(v119 + 16);
              *(_OWORD *)unint64_t v126 = *(_OWORD *)v119;
            }
            id v119 = v126;
LABEL_200:
            *(void *)(v119 + 16) = v207;
            *(_OWORD *)id v119 = v203;
            *(_DWORD *)(v119 + 24) = v128;
            *(void *)(v119 + 28) = v218;
            *(_DWORD *)(v119 + 36) = v222;
            *(double *)(v119 + 40) = v129;
            *(void *)(v119 + 48) = v130;
            *(_DWORD *)(v119 + 56) = v125;
            *(_OWORD *)(v119 + 60) = *(_OWORD *)v232;
            *(_OWORD *)(v119 + 73) = *(_OWORD *)&v232[13];
          }
        }
      }
      double v116 = v117 - 1;
      if (v117) {
        continue;
      }
      break;
    }
    std::string::size_type v144 = v12 / 0x60uLL;
    while (2)
    {
      uint64_t v145 = 0;
      v233 = *(_OWORD *)i;
      __int16 v239 = *(_OWORD *)(i + 16);
      *(_OWORD *)double v254 = *(_OWORD *)(i + 64);
      *(_OWORD *)&v254[16] = *(_OWORD *)(i + 80);
      uint64_t v244 = *(_OWORD *)(i + 32);
      __int16 v249 = *(_OWORD *)(i + 48);
      std::string::size_type v146 = i;
      do
      {
        __int16 v147 = (_OWORD *)v146;
        id v148 = v145 + 1;
        v146 += 96 * (v145 + 1);
        id v149 = 2 * v145;
        uint64_t v145 = (2 * v145) | 1;
        id v150 = v149 + 2;
        if (v150 < v144)
        {
          id v151 = DWORD2(v147[6 * v148 + 3]);
          double v152 = *(_DWORD *)(v146 + 152);
          if (v151 > v152
            || v151 == v152
            && ((id v153 = DWORD2(v147[6 * v148 + 1]), v154 = *(_DWORD *)(v146 + 120), v153 > v154)
             || v153 == v154 && *((double *)&v147[6 * v148 + 2] + 1) < *(double *)(v146 + 136)))
          {
            v146 += 96;
            uint64_t v145 = v150;
          }
        }
        int v155 = *(_OWORD *)(v146 + 16);
        *__int16 v147 = *(_OWORD *)v146;
        v147[1] = v155;
        id v156 = *(_OWORD *)(v146 + 32);
        uint64_t v157 = *(_OWORD *)(v146 + 48);
        unint64_t v158 = *(_OWORD *)(v146 + 64);
        *(_OWORD *)((char *)v147 + 73) = *(_OWORD *)(v146 + 73);
        v147[3] = v157;
        v147[4] = v158;
        v147[2] = v156;
      }
      while (v145 <= (uint64_t)((unint64_t)(v144 - 2) >> 1));
      a2 -= 6;
      if ((_OWORD *)v146 == a2)
      {
        *(_OWORD *)std::string::size_type v146 = v233;
        *(_OWORD *)(v146 + 16) = v239;
        *(_OWORD *)(v146 + 73) = *(_OWORD *)&v254[9];
        *(_OWORD *)(v146 + 48) = v249;
        *(_OWORD *)(v146 + 64) = *(_OWORD *)v254;
        *(_OWORD *)(v146 + 32) = v244;
      }
      else
      {
        id v159 = a2[1];
        *(_OWORD *)std::string::size_type v146 = *a2;
        *(_OWORD *)(v146 + 16) = v159;
        id v160 = a2[2];
        id v161 = a2[3];
        id v162 = a2[4];
        *(_OWORD *)(v146 + 73) = *(_OWORD *)((char *)a2 + 73);
        *(_OWORD *)(v146 + 48) = v161;
        *(_OWORD *)(v146 + 64) = v162;
        *(_OWORD *)(v146 + 32) = v160;
        *(_OWORD *)((char *)a2 + 73) = *(_OWORD *)&v254[9];
        a2[3] = v249;
        a2[4] = *(_OWORD *)v254;
        a2[2] = v244;
        *a2 = v233;
        a2[1] = v239;
        __int16 v163 = v146 - i + 96;
        if (v163 >= 97)
        {
          id v164 = v163 / 0x60uLL - 2;
          __int16 v165 = v164 >> 1;
          double v166 = i + 96 * (v164 >> 1);
          id v167 = *(_DWORD *)(v166 + 56);
          id v168 = *(_DWORD *)(v146 + 56);
          if (v167 > v168)
          {
            __int16 v169 = *(_DWORD *)(v146 + 24);
            goto LABEL_216;
          }
          if (v167 == v168)
          {
            long long v185 = *(_DWORD *)(i + 96 * v165 + 24);
            __int16 v169 = *(_DWORD *)(v146 + 24);
            if (v185 > v169
              || v185 == v169
              && (__int16 v169 = *(_DWORD *)(i + 96 * v165 + 24), *(double *)(i + 96 * v165 + 40) < *(double *)(v146 + 40)))
            {
LABEL_216:
              int v226 = *(void *)(v146 + 16);
              long long v219 = *(_OWORD *)v146;
              __int16 v214 = *(_DWORD *)(v146 + 36);
              __int16 v211 = *(void *)(v146 + 28);
              double v170 = *(double *)(v146 + 40);
              __int16 v171 = *(void *)(v146 + 48);
              *(_OWORD *)__int16 v204 = *(_OWORD *)(v146 + 60);
              *(_OWORD *)&v204[16] = *(_OWORD *)(v146 + 76);
              int v172 = *(_OWORD *)(v166 + 16);
              *(_OWORD *)std::string::size_type v146 = *(_OWORD *)v166;
              *(_OWORD *)(v146 + 16) = v172;
              __int16 v173 = *(_OWORD *)(v166 + 32);
              uint64_t v174 = *(_OWORD *)(v166 + 48);
              uint64_t v175 = *(_OWORD *)(v166 + 64);
              *(_OWORD *)(v146 + 73) = *(_OWORD *)(v166 + 73);
              *(_OWORD *)(v146 + 48) = v174;
              *(_OWORD *)(v146 + 64) = v175;
              *(_OWORD *)(v146 + 32) = v173;
              if (v164 >= 2)
              {
                while (1)
                {
                  int v177 = v165 - 1;
                  __int16 v165 = (v165 - 1) >> 1;
                  double v176 = i + 96 * v165;
                  long long v178 = *(_DWORD *)(v176 + 56);
                  if (v178 <= v168)
                  {
                    if (v178 != v168) {
                      break;
                    }
                    long long v179 = *(_DWORD *)(i + 96 * v165 + 24);
                    if (v179 <= v169 && (v179 != v169 || *(double *)(i + 96 * v165 + 40) >= v170)) {
                      break;
                    }
                  }
                  long long v180 = *(_OWORD *)(v176 + 16);
                  *(_OWORD *)double v166 = *(_OWORD *)v176;
                  *(_OWORD *)(v166 + 16) = v180;
                  long long v181 = *(_OWORD *)(v176 + 32);
                  long long v182 = *(_OWORD *)(v176 + 48);
                  unint64_t v183 = *(_OWORD *)(v176 + 64);
                  *(_OWORD *)(v166 + 73) = *(_OWORD *)(v176 + 73);
                  *(_OWORD *)(v166 + 48) = v182;
                  *(_OWORD *)(v166 + 64) = v183;
                  *(_OWORD *)(v166 + 32) = v181;
                  double v166 = i + 96 * v165;
                  if (v177 <= 1) {
                    goto LABEL_224;
                  }
                }
              }
              double v176 = v166;
LABEL_224:
              *(void *)(v176 + 16) = v226;
              *(_OWORD *)double v176 = v219;
              *(_DWORD *)(v176 + 24) = v169;
              *(void *)(v176 + 28) = v211;
              *(_DWORD *)(v176 + 36) = v214;
              *(double *)(v176 + 40) = v170;
              *(void *)(v176 + 48) = v171;
              *(_DWORD *)(v176 + 56) = v168;
              *(_OWORD *)(v176 + 60) = *(_OWORD *)v204;
              *(_OWORD *)(v176 + 73) = *(_OWORD *)&v204[13];
            }
          }
        }
      }
      if (v144-- <= 2) {
        return;
      }
      continue;
    }
  }
}

  unint64_t v10 = a2 - 6;
  uint64_t i = a1;
  while (1)
  {
    a1 = i;
    uint64_t v12 = (uint64_t)a2 - i;
    uint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - i) >> 5);
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          __int16 v85 = *((_DWORD *)a2 - 10);
          double v86 = *(_DWORD *)(i + 56);
          if (v85 > v86
            || v85 == v86
            && ((uint64_t v87 = *((_DWORD *)a2 - 18), v88 = *(_DWORD *)(i + 24), v87 > v88)
             || v87 == v88 && *((double *)a2 - 8) < *(double *)(i + 32)))
          {
            int v226 = *(_OWORD *)i;
            v234 = *(_OWORD *)(i + 16);
            *(_OWORD *)__int16 v249 = *(_OWORD *)(i + 64);
            *(_OWORD *)&v249[16] = *(_OWORD *)(i + 80);
            __int16 v239 = *(_OWORD *)(i + 32);
            uint64_t v244 = *(_OWORD *)(i + 48);
            uint64_t v90 = *(a2 - 3);
            __int16 v89 = *(a2 - 2);
            __int16 v91 = *(a2 - 4);
            *(_OWORD *)(i + 73) = *(_OWORD *)((char *)a2 - 23);
            *(_OWORD *)(i + 48) = v90;
            *(_OWORD *)(i + 64) = v89;
            *(_OWORD *)(i + 32) = v91;
            unint64_t v92 = *(a2 - 5);
            *(_OWORD *)uint64_t i = *v10;
            *(_OWORD *)(i + 16) = v92;
            *unint64_t v10 = v226;
            *(a2 - 5) = v234;
            *(_OWORD *)((char *)a2 - 23) = *(_OWORD *)&v249[9];
            *(a2 - 3) = v244;
            *(a2 - 2) = *(_OWORD *)v249;
            *(a2 - 4) = v239;
          }
          break;
        case 3uLL:
          sub_100649100(i, i + 96, (uint64_t)(a2 - 6));
          break;
        case 4uLL:
          sub_1006496E4(i, i + 96, i + 192, (uint64_t)(a2 - 6));
          break;
        case 5uLL:
          sub_100648E70(i, i + 96, i + 192, i + 288, (uint64_t)(a2 - 6));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v12 <= 2303)
    {
      __int16 v93 = (_OWORD *)(i + 96);
      __int16 v95 = (_OWORD *)i == a2 || v93 == a2;
      if (a4)
      {
        if (v95) {
          return;
        }
        double v96 = 0;
        id v97 = i;
        while (2)
        {
          id v98 = v97;
          id v97 = (unint64_t)v93;
          int v99 = *(_DWORD *)(v98 + 152);
          int v100 = *(_DWORD *)(v98 + 56);
          if (v99 > v100)
          {
            uint64_t v101 = *(_DWORD *)(v98 + 120);
            goto LABEL_154;
          }
          if (v99 == v100)
          {
            uint64_t v101 = *(_DWORD *)(v98 + 120);
            id v102 = *(_DWORD *)(v98 + 24);
            if (v101 > v102 || v101 == v102 && *(double *)(v98 + 128) < *(double *)(v98 + 32))
            {
LABEL_154:
              __int16 v208 = *(void *)(v97 + 16);
              __int16 v204 = *(_OWORD *)v97;
              int64_t v103 = *(_DWORD *)(v98 + 124);
              unint64_t v104 = *(double *)(v98 + 128);
              int v216 = *(_OWORD *)(v98 + 136);
              *(_OWORD *)char v227 = *(_OWORD *)(v98 + 156);
              *(_OWORD *)&v227[16] = *(_OWORD *)(v98 + 172);
              uint64_t v105 = *(_OWORD *)(v98 + 16);
              *(_OWORD *)id v97 = *(_OWORD *)v98;
              *(_OWORD *)(v97 + 16) = v105;
              *(_OWORD *)(v97 + 73) = *(_OWORD *)(v98 + 73);
              unint64_t v106 = *(_OWORD *)(v98 + 64);
              uint64_t v107 = *(_OWORD *)(v98 + 32);
              id v108 = i;
              *(_OWORD *)(v97 + 48) = *(_OWORD *)(v98 + 48);
              *(_OWORD *)(v97 + 64) = v106;
              *(_OWORD *)(v97 + 32) = v107;
              if (v98 != i)
              {
                uint64_t v109 = v96;
                while (1)
                {
                  uint64_t v110 = (_OWORD *)(i + v109);
                  long long v111 = *(_DWORD *)(i + v109 - 40);
                  if (v99 <= v111)
                  {
                    if (v99 != v111)
                    {
                      id v108 = i + v109;
                      goto LABEL_165;
                    }
                    int v112 = *(_DWORD *)(i + v109 - 72);
                    if (v101 <= v112 && (v101 != v112 || v104 >= *(double *)(i + v109 - 64))) {
                      break;
                    }
                  }
                  v98 -= 96;
                  id v113 = *(v110 - 3);
                  v110[2] = *(v110 - 4);
                  v110[3] = v113;
                  v110[4] = *(v110 - 2);
                  *(_OWORD *)((char *)v110 + 73) = *(_OWORD *)((char *)v110 - 23);
                  uint64_t v114 = *(v110 - 5);
                  *uint64_t v110 = *(v110 - 6);
                  v110[1] = v114;
                  v109 -= 96;
                  if (!v109)
                  {
                    id v108 = i;
                    goto LABEL_165;
                  }
                }
                id v108 = v98;
              }
LABEL_165:
              *(_OWORD *)id v108 = v204;
              *(void *)(v108 + 16) = v208;
              *(_DWORD *)(v108 + 24) = v101;
              *(_DWORD *)(v108 + 28) = v103;
              *(double *)(v108 + 32) = v104;
              *(_OWORD *)(v108 + 40) = v216;
              *(_DWORD *)(v108 + 56) = v99;
              *(_OWORD *)(v108 + 60) = *(_OWORD *)v227;
              *(_OWORD *)(v108 + 73) = *(_OWORD *)&v227[13];
            }
          }
          __int16 v93 = (_OWORD *)(v97 + 96);
          v96 += 96;
          if ((_OWORD *)(v97 + 96) == a2) {
            return;
          }
          continue;
        }
      }
      if (v95) {
        return;
      }
      while (2)
      {
        long long v190 = a1;
        a1 = (unint64_t)v93;
        long long v191 = *(_DWORD *)(v190 + 152);
        unint64_t v192 = *(_DWORD *)(v190 + 56);
        if (v191 <= v192)
        {
          if (v191 == v192)
          {
            long long v193 = *(_DWORD *)(v190 + 120);
            long long v194 = *(_DWORD *)(v190 + 24);
            if (v193 > v194 || v193 == v194 && *(double *)(v190 + 128) < *(double *)(v190 + 32)) {
              goto LABEL_241;
            }
          }
        }
        else
        {
          long long v193 = *(_DWORD *)(v190 + 120);
LABEL_241:
          int v210 = *(void *)(a1 + 16);
          double v207 = *(_OWORD *)a1;
          long long v195 = *(_DWORD *)(v190 + 124);
          long long v196 = *(double *)(v190 + 128);
          long long v219 = *(_OWORD *)(v190 + 136);
          *(_OWORD *)int v230 = *(_OWORD *)(v190 + 156);
          *(_OWORD *)&v230[16] = *(_OWORD *)(v190 + 172);
          do
          {
            do
            {
              long long v197 = v190;
              long long v198 = *(_OWORD *)(v190 + 48);
              *(_OWORD *)(v190 + 128) = *(_OWORD *)(v190 + 32);
              *(_OWORD *)(v190 + 144) = v198;
              *(_OWORD *)(v190 + 160) = *(_OWORD *)(v190 + 64);
              *(_OWORD *)(v190 + 169) = *(_OWORD *)(v190 + 73);
              long long v199 = *(_OWORD *)(v190 + 16);
              *(_OWORD *)(v190 + 96) = *(_OWORD *)v190;
              *(_OWORD *)(v190 + 112) = v199;
              v190 -= 96;
              long long v200 = *(_DWORD *)(v197 - 40);
            }
            while (v191 > v200);
            if (v191 != v200) {
              break;
            }
            double v201 = *(_DWORD *)(v197 - 72);
          }
          while (v193 > v201 || v193 == v201 && v196 < *(double *)(v197 - 64));
          *(_OWORD *)long long v197 = v207;
          *(void *)(v197 + 16) = v210;
          *(_DWORD *)(v197 + 24) = v193;
          *(_DWORD *)(v197 + 28) = v195;
          *(double *)(v197 + 32) = v196;
          *(_OWORD *)(v197 + 40) = v219;
          *(_DWORD *)(v197 + 56) = v191;
          *(_OWORD *)(v197 + 60) = *(_OWORD *)v230;
          *(_OWORD *)(v197 + 73) = *(_OWORD *)&v230[13];
        }
        __int16 v93 = (_OWORD *)(a1 + 96);
        if ((_OWORD *)(a1 + 96) == a2) {
          return;
        }
        continue;
      }
    }
    if (!a3) {
      break;
    }
    uint64_t v14 = v13 >> 1;
    unint64_t v15 = (_OWORD *)(i + 96 * (v13 >> 1));
    if ((unint64_t)v12 > 0x3000)
    {
      sub_100649100(a1, a1 + 96 * (v13 >> 1), (uint64_t)(a2 - 6));
      unint64_t v16 = 3 * v14;
      id v17 = a1 + 96 * v14 - 96;
      sub_100649100(a1 + 96, v17, (uint64_t)(a2 - 12));
      uint64_t v18 = a1 + 96 + 32 * v16;
      sub_100649100(a1 + 192, v18, (uint64_t)(a2 - 18));
      sub_100649100(v17, (uint64_t)v15, v18);
      uint64_t v223 = *(_OWORD *)a1;
      v231 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)double v246 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v246[16] = *(_OWORD *)(a1 + 80);
      v236 = *(_OWORD *)(a1 + 32);
      __int16 v241 = *(_OWORD *)(a1 + 48);
      float v20 = v15[3];
      long long v19 = v15[4];
      float v21 = v15[2];
      *(_OWORD *)(a1 + 73) = *(_OWORD *)((char *)v15 + 73);
      *(_OWORD *)(a1 + 48) = v20;
      *(_OWORD *)(a1 + 64) = v19;
      *(_OWORD *)(a1 + 32) = v21;
      double v22 = v15[1];
      *(_OWORD *)a1 = *v15;
      *(_OWORD *)(a1 + 16) = v22;
      unsigned char *v15 = v223;
      v15[1] = v231;
      *(_OWORD *)((char *)v15 + 73) = *(_OWORD *)&v246[9];
      v15[3] = v241;
      v15[4] = *(_OWORD *)v246;
      _DWORD v15[2] = v236;
    }
    else
    {
      sub_100649100(a1 + 96 * (v13 >> 1), a1, (uint64_t)(a2 - 6));
    }
    --a3;
    if (a4)
    {
      uint64_t v23 = *(_DWORD *)(a1 + 56);
LABEL_18:
      char v26 = 0;
      double v220 = *(void *)(a1 + 16);
      BOOL v27 = *(void *)(a1 + 24);
      uint64_t v28 = *(double *)(a1 + 32);
      __int16 v211 = *(_OWORD *)(a1 + 40);
      __int16 v214 = *(_OWORD *)a1;
      *(_OWORD *)double v202 = *(_OWORD *)(a1 + 60);
      *(_OWORD *)&v202[16] = *(_OWORD *)(a1 + 76);
      while (1)
      {
        uint64_t v29 = *(_DWORD *)(a1 + v26 + 152);
        if (v29 <= v23)
        {
          if (v29 != v23) {
            break;
          }
          uint64_t v30 = *(_DWORD *)(a1 + v26 + 120);
          if (v30 <= (int)v27 && (v30 != v27 || *(double *)(a1 + v26 + 128) >= v28)) {
            break;
          }
        }
        v26 += 96;
      }
      double v31 = a1 + v26 + 96;
      if (v26)
      {
        id v32 = *((_DWORD *)a2 - 10);
        unsigned __int8 v33 = (double *)(a2 - 4);
        uint64_t v34 = (double *)(a2 - 6);
        if (v32 <= v23)
        {
          do
          {
            if (v32 == v23)
            {
              uint64_t v35 = *((_DWORD *)v33 - 2);
              if (v35 > (int)v27) {
                goto LABEL_49;
              }
              if (v35 == v27 && *v33 < v28) {
                break;
              }
            }
            v34 -= 12;
            id v32 = *((_DWORD *)v33 - 18);
            v33 -= 12;
          }
          while (v32 <= v23);
LABEL_32:
          uint64_t v34 = v33 - 4;
        }
      }
      else
      {
        uint64_t v34 = (double *)a2;
        if (v31 < (unint64_t)a2)
        {
          id v36 = *((_DWORD *)a2 - 10);
          uint64_t v34 = (double *)(a2 - 6);
          if (v36 <= v23)
          {
            unsigned __int8 v33 = (double *)(a2 - 4);
            uint64_t v34 = (double *)(a2 - 6);
            while (1)
            {
              unsigned __int8 v37 = v33 - 4;
              if (v36 != v23) {
                goto LABEL_45;
              }
              uint64_t v38 = *((_DWORD *)v33 - 2);
              if (v38 > (int)v27) {
                break;
              }
              if (v38 == v27)
              {
                if (*v33 < v28 || v31 >= (unint64_t)v37) {
                  break;
                }
              }
              else
              {
LABEL_45:
                if (v31 >= (unint64_t)v37)
                {
                  uint64_t v34 = v33 - 4;
                  break;
                }
              }
              v34 -= 12;
              id v36 = *((_DWORD *)v33 - 18);
              v33 -= 12;
              if (v36 > v23) {
                goto LABEL_32;
              }
            }
          }
        }
      }
LABEL_49:
      uint64_t i = v31;
      if (v31 < (unint64_t)v34)
      {
        uint64_t v40 = v34;
        do
        {
          char v224 = *(_OWORD *)i;
          int v232 = *(_OWORD *)(i + 16);
          *(_OWORD *)__int16 v247 = *(_OWORD *)(i + 64);
          *(_OWORD *)&v247[16] = *(_OWORD *)(i + 80);
          __int16 v237 = *(_OWORD *)(i + 32);
          uint64_t v242 = *(_OWORD *)(i + 48);
          unsigned __int8 v42 = *((_OWORD *)v40 + 3);
          id v41 = *((_OWORD *)v40 + 4);
          unint64_t v43 = *((_OWORD *)v40 + 2);
          *(_OWORD *)(i + 73) = *(_OWORD *)((char *)v40 + 73);
          *(_OWORD *)(i + 48) = v42;
          *(_OWORD *)(i + 64) = v41;
          *(_OWORD *)(i + 32) = v43;
          unint64_t v44 = *((_OWORD *)v40 + 1);
          *(_OWORD *)uint64_t i = *(_OWORD *)v40;
          *(_OWORD *)(i + 16) = v44;
          *(_OWORD *)uint64_t v40 = v224;
          *((_OWORD *)v40 + 1) = v232;
          *(_OWORD *)((char *)v40 + 73) = *(_OWORD *)&v247[9];
          *((_OWORD *)v40 + 3) = v242;
          *((_OWORD *)v40 + 4) = *(_OWORD *)v247;
          *((_OWORD *)v40 + 2) = v237;
          do
          {
            do
            {
              i += 96;
              id v45 = *(_DWORD *)(i + 56);
            }
            while (v45 > v23);
            if (v45 != v23) {
              break;
            }
            id v46 = *(_DWORD *)(i + 24);
          }
          while (v46 > (int)v27 || v46 == v27 && *(double *)(i + 32) < v28);
          uint64_t v47 = v40 - 12;
          uint64_t v48 = *((_DWORD *)v40 - 10);
          if (v48 <= v23)
          {
            uint64_t v49 = v40 - 8;
            do
            {
              if (v48 == v23)
              {
                uint64_t v50 = *((_DWORD *)v49 - 2);
                if (v50 > (int)v27) {
                  break;
                }
                if (v50 == v27 && *v49 < v28) {
                  goto LABEL_65;
                }
              }
              v47 -= 12;
              uint64_t v48 = *((_DWORD *)v49 - 18);
              v49 -= 12;
            }
            while (v48 <= v23);
            uint64_t v47 = v49 - 4;
          }
LABEL_65:
          uint64_t v40 = v47;
        }
        while (i < (unint64_t)v47);
      }
      uint64_t v51 = (_OWORD *)(i - 96);
      if (i - 96 != a1)
      {
        uint64_t v52 = *(_OWORD *)(i - 80);
        *(_OWORD *)a1 = *v51;
        *(_OWORD *)(a1 + 16) = v52;
        uint64_t v53 = *(_OWORD *)(i - 64);
        unint64_t v54 = *(_OWORD *)(i - 48);
        id v55 = *(_OWORD *)(i - 32);
        *(_OWORD *)(a1 + 73) = *(_OWORD *)(i - 23);
        *(_OWORD *)(a1 + 48) = v54;
        *(_OWORD *)(a1 + 64) = v55;
        *(_OWORD *)(a1 + 32) = v53;
      }
      char *v51 = v214;
      *(void *)(i - 80) = v220;
      *(void *)(i - 72) = v27;
      *(double *)(i - 64) = v28;
      *(_OWORD *)(i - 56) = v211;
      *(_DWORD *)(i - 40) = v23;
      *(_OWORD *)(i - 23) = *(_OWORD *)&v202[13];
      *(_OWORD *)(i - 36) = *(_OWORD *)v202;
      if (v31 < (unint64_t)v34) {
        goto LABEL_71;
      }
      id v56 = sub_1006493BC(a1, i - 96);
      if (sub_1006493BC(i, (uint64_t)a2))
      {
        a2 = (_OWORD *)(i - 96);
        if (v56) {
          return;
        }
        goto LABEL_1;
      }
      if (!v56)
      {
LABEL_71:
        sub_100647DE0(a1, i - 96, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v23 = *(_DWORD *)(a1 - 40);
      uint64_t v24 = *(_DWORD *)(a1 + 56);
      if (v23 > v24)
      {
        uint64_t v23 = *(_DWORD *)(a1 + 56);
        goto LABEL_18;
      }
      if (v23 == v24)
      {
        unint64_t v25 = *(_DWORD *)(a1 - 72);
        id v57 = *(_DWORD *)(a1 + 24);
        if (v25 > v57) {
          goto LABEL_18;
        }
        if (v25 == v57)
        {
          if (*(double *)(a1 - 64) < *(double *)(a1 + 32)) {
            goto LABEL_18;
          }
          id v57 = *(_DWORD *)(a1 - 72);
        }
      }
      else
      {
        id v57 = *(_DWORD *)(a1 + 24);
      }
      uint64_t v221 = *(void *)(a1 + 16);
      id v58 = *(_DWORD *)(a1 + 28);
      id v59 = *(double *)(a1 + 32);
      int v212 = *(_OWORD *)(a1 + 40);
      uint64_t v215 = *(_OWORD *)a1;
      *(_OWORD *)__int16 v203 = *(_OWORD *)(a1 + 60);
      *(_OWORD *)&v203[16] = *(_OWORD *)(a1 + 76);
      double v60 = *((_DWORD *)a2 - 10);
      if (v24 > v60
        || v24 == v60 && ((id v67 = *((_DWORD *)a2 - 18), v57 > v67) || v57 == v67 && v59 < *((double *)a2 - 8)))
      {
        uint64_t i = a1 + 96;
        id v61 = *(_DWORD *)(a1 + 152);
        if (v24 <= v61)
        {
          unint64_t v62 = a1 + 128;
          do
          {
            if (v24 == v61)
            {
              int v63 = *(_DWORD *)(v62 - 8);
              if (v57 > v63) {
                goto LABEL_82;
              }
              if (v57 == v63 && v59 < *(double *)v62) {
                break;
              }
            }
            i += 96;
            id v61 = *(_DWORD *)(v62 + 120);
            v62 += 96;
          }
          while (v24 <= v61);
          uint64_t i = v62 - 32;
        }
      }
      else
      {
        for (uint64_t i = a1 + 96; i < (unint64_t)a2; i += 96)
        {
          unint64_t v68 = *(_DWORD *)(i + 56);
          if (v24 > v68) {
            break;
          }
          if (v24 == v68)
          {
            long long v69 = *(_DWORD *)(i + 24);
            if (v57 > v69 || v57 == v69 && v59 < *(double *)(i + 32)) {
              break;
            }
          }
        }
      }
LABEL_82:
      id v64 = (double *)a2;
      if (i < (unint64_t)a2)
      {
        for (j = (double *)(a2 - 4); ; j -= 12)
        {
          if (v24 <= v60)
          {
            if (v24 != v60) {
              break;
            }
            uint64_t v66 = *((_DWORD *)j - 2);
            if (v57 <= v66 && (v57 != v66 || v59 >= *j)) {
              break;
            }
          }
          double v60 = *((_DWORD *)j - 18);
        }
        id v64 = j - 4;
      }
      while (i < (unint64_t)v64)
      {
        uint64_t v225 = *(_OWORD *)i;
        v233 = *(_OWORD *)(i + 16);
        *(_OWORD *)int v248 = *(_OWORD *)(i + 64);
        *(_OWORD *)&v248[16] = *(_OWORD *)(i + 80);
        double v238 = *(_OWORD *)(i + 32);
        __int16 v243 = *(_OWORD *)(i + 48);
        long long v71 = *((_OWORD *)v64 + 3);
        long long v70 = *((_OWORD *)v64 + 4);
        long long v72 = *((_OWORD *)v64 + 2);
        *(_OWORD *)(i + 73) = *(_OWORD *)((char *)v64 + 73);
        *(_OWORD *)(i + 48) = v71;
        *(_OWORD *)(i + 64) = v70;
        *(_OWORD *)(i + 32) = v72;
        id v73 = *((_OWORD *)v64 + 1);
        *(_OWORD *)uint64_t i = *(_OWORD *)v64;
        *(_OWORD *)(i + 16) = v73;
        *(_OWORD *)id v64 = v225;
        *((_OWORD *)v64 + 1) = v233;
        *(_OWORD *)((char *)v64 + 73) = *(_OWORD *)&v248[9];
        *((_OWORD *)v64 + 3) = v243;
        *((_OWORD *)v64 + 4) = *(_OWORD *)v248;
        *((_OWORD *)v64 + 2) = v238;
        int v74 = i + 96;
        long long v75 = *(_DWORD *)(i + 152);
        if (v24 <= v75)
        {
          uint64_t v76 = i + 128;
          do
          {
            if (v24 == v75)
            {
              id v77 = *(_DWORD *)(v76 - 8);
              if (v57 > v77) {
                break;
              }
              if (v57 == v77 && v59 < *(double *)v76) {
                goto LABEL_104;
              }
            }
            v74 += 96;
            long long v75 = *(_DWORD *)(v76 + 120);
            v76 += 96;
          }
          while (v24 <= v75);
          uint64_t i = v76 - 32;
        }
        else
        {
LABEL_104:
          uint64_t i = v74;
        }
        do
        {
          do
          {
            v64 -= 12;
            uint64_t v78 = *((_DWORD *)v64 + 14);
          }
          while (v24 > v78);
          if (v24 != v78) {
            break;
          }
          __int16 v79 = *((_DWORD *)v64 + 6);
        }
        while (v57 > v79 || v57 == v79 && v59 < v64[4]);
      }
      uint64_t v80 = (_OWORD *)(i - 96);
      unint64_t v4 = i - 96 >= a1;
      char v5 = i - 96 == a1;
      if (i - 96 != a1)
      {
        __int16 v81 = *(_OWORD *)(i - 80);
        *(_OWORD *)a1 = *v80;
        *(_OWORD *)(a1 + 16) = v81;
        unint64_t v82 = *(_OWORD *)(i - 64);
        __int16 v83 = *(_OWORD *)(i - 48);
        uint64_t v84 = *(_OWORD *)(i - 32);
        *(_OWORD *)(a1 + 73) = *(_OWORD *)(i - 23);
        *(_OWORD *)(a1 + 48) = v83;
        *(_OWORD *)(a1 + 64) = v84;
        *(_OWORD *)(a1 + 32) = v82;
      }
      a4 = 0;
      *(void *)(i - 80) = v221;
      *uint64_t v80 = v215;
      *(_DWORD *)(i - 72) = v57;
      *(_DWORD *)(i - 68) = v58;
      *(double *)(i - 64) = v59;
      *(_OWORD *)(i - 56) = v212;
      *(_DWORD *)(i - 40) = v24;
      *(_OWORD *)(i - 23) = *(_OWORD *)&v203[13];
      *(_OWORD *)(i - 36) = *(_OWORD *)v203;
    }
  }
  if ((_OWORD *)i != a2)
  {
    uint64_t v115 = (v13 - 2) >> 1;
    double v116 = v115;
    while (2)
    {
      double v117 = v116;
      if (v115 >= v116)
      {
        id v118 = (2 * v116) | 1;
        id v119 = (_OWORD *)(i + 96 * v118);
        if (2 * v117 + 2 < (uint64_t)v13)
        {
          unint64_t v120 = *(_DWORD *)(i + 96 * v118 + 56);
          unint64_t v121 = *((_DWORD *)v119 + 38);
          if (v120 > v121
            || v120 == v121
            && ((v122 = *(_DWORD *)(i + 96 * v118 + 24), double v123 = *((_DWORD *)v119 + 30), v122 > v123)
             || v122 == v123 && *(double *)(i + 96 * v118 + 32) < *((double *)v119 + 16)))
          {
            v119 += 6;
            id v118 = 2 * v117 + 2;
          }
        }
        id v124 = *((_DWORD *)v119 + 14);
        id v125 = *(_DWORD *)(i + 96 * v117 + 56);
        if (v124 <= v125)
        {
          unint64_t v126 = i + 96 * v117;
          if (v124 == v125)
          {
            uint64_t v127 = *((_DWORD *)v119 + 6);
            id v128 = *(_DWORD *)(i + 96 * v117 + 24);
            if (v127 <= v128)
            {
              if (v127 != v128) {
                goto LABEL_184;
              }
              id v128 = *((_DWORD *)v119 + 6);
              if (*((double *)v119 + 4) >= *(double *)(i + 96 * v117 + 32)) {
                goto LABEL_184;
              }
            }
          }
          else
          {
            id v128 = *(_DWORD *)(v126 + 24);
LABEL_184:
            uint64_t v209 = *(void *)(v126 + 16);
            unint64_t v205 = *(_OWORD *)v126;
            uint64_t v129 = *(_DWORD *)(v126 + 28);
            double v130 = *(double *)(v126 + 32);
            char v217 = *(_OWORD *)(v126 + 40);
            *(_OWORD *)uint64_t v228 = *(_OWORD *)(v126 + 60);
            *(_OWORD *)&v228[16] = *(_OWORD *)(v126 + 76);
            id v132 = v119[3];
            uint64_t v131 = v119[4];
            uint64_t v133 = v119[2];
            *(_OWORD *)(v126 + 73) = *(_OWORD *)((char *)v119 + 73);
            *(_OWORD *)(v126 + 48) = v132;
            *(_OWORD *)(v126 + 64) = v131;
            *(_OWORD *)(v126 + 32) = v133;
            uint64_t v134 = v119[1];
            *(_OWORD *)unint64_t v126 = *v119;
            *(_OWORD *)(v126 + 16) = v134;
            while (1)
            {
              if (v115 < v118) {
                goto LABEL_200;
              }
              id v135 = v119;
              uint64_t v136 = 2 * v118;
              id v118 = (2 * v118) | 1;
              id v119 = (_OWORD *)(i + 96 * v118);
              uint64_t v137 = v136 + 2;
              if (v137 < (uint64_t)v13)
              {
                uint64_t v138 = *(_DWORD *)(i + 96 * v118 + 56);
                unint64_t v139 = *((_DWORD *)v119 + 38);
                if (v138 > v139
                  || v138 == v139
                  && ((id v140 = *(_DWORD *)(i + 96 * v118 + 24), v141 = *((_DWORD *)v119 + 30), v140 > v141)
                   || v140 == v141 && *(double *)(i + 96 * v118 + 32) < *((double *)v119 + 16)))
                {
                  v119 += 6;
                  id v118 = v137;
                }
              }
              unint64_t v142 = *((_DWORD *)v119 + 14);
              if (v142 > v125) {
                break;
              }
              if (v142 == v125)
              {
                id v143 = *((_DWORD *)v119 + 6);
                if (v143 > v128 || v143 == v128 && *((double *)v119 + 4) < v130) {
                  break;
                }
              }
              std::string::size_type v144 = v119[1];
              *id v135 = *v119;
              v135[1] = v144;
              uint64_t v145 = v119[2];
              std::string::size_type v146 = v119[3];
              __int16 v147 = v119[4];
              *(_OWORD *)((char *)v135 + 73) = *(_OWORD *)((char *)v119 + 73);
              v135[3] = v146;
              v135[4] = v147;
              v135[2] = v145;
            }
            id v119 = v135;
LABEL_200:
            *id v119 = v205;
            *((void *)v119 + 2) = v209;
            *((_DWORD *)v119 + 6) = v128;
            *((_DWORD *)v119 + 7) = v129;
            *((double *)v119 + 4) = v130;
            *(_OWORD *)((char *)v119 + 40) = v217;
            *((_DWORD *)v119 + 14) = v125;
            *(_OWORD *)((char *)v119 + 60) = *(_OWORD *)v228;
            *(_OWORD *)((char *)v119 + 73) = *(_OWORD *)&v228[13];
          }
        }
      }
      double v116 = v117 - 1;
      if (v117) {
        continue;
      }
      break;
    }
    id v148 = v12 / 0x60uLL;
    while (2)
    {
      id v149 = 0;
      __int16 v229 = *(_OWORD *)i;
      __int16 v235 = *(_OWORD *)(i + 16);
      *(_OWORD *)double v250 = *(_OWORD *)(i + 64);
      *(_OWORD *)&v250[16] = *(_OWORD *)(i + 80);
      uint64_t v240 = *(_OWORD *)(i + 32);
      __int16 v245 = *(_OWORD *)(i + 48);
      id v150 = i;
      do
      {
        id v151 = (_OWORD *)v150;
        double v152 = v149 + 1;
        v150 += 96 * (v149 + 1);
        id v153 = 2 * v149;
        id v149 = (2 * v149) | 1;
        unint64_t v154 = v153 + 2;
        if (v154 < v148)
        {
          int v155 = DWORD2(v151[6 * v152 + 3]);
          id v156 = *(_DWORD *)(v150 + 152);
          if (v155 > v156
            || v155 == v156
            && ((uint64_t v157 = DWORD2(v151[6 * v152 + 1]), v158 = *(_DWORD *)(v150 + 120), v157 > v158)
             || v157 == v158 && *(double *)&v151[6 * v152 + 2] < *(double *)(v150 + 128)))
          {
            v150 += 96;
            id v149 = v154;
          }
        }
        id v159 = *(_OWORD *)(v150 + 16);
        *id v151 = *(_OWORD *)v150;
        v151[1] = v159;
        id v160 = *(_OWORD *)(v150 + 32);
        id v161 = *(_OWORD *)(v150 + 48);
        id v162 = *(_OWORD *)(v150 + 64);
        *(_OWORD *)((char *)v151 + 73) = *(_OWORD *)(v150 + 73);
        v151[3] = v161;
        v151[4] = v162;
        v151[2] = v160;
      }
      while (v149 <= (uint64_t)((unint64_t)(v148 - 2) >> 1));
      a2 -= 6;
      if ((_OWORD *)v150 == a2)
      {
        *(_OWORD *)id v150 = v229;
        *(_OWORD *)(v150 + 16) = v235;
        *(_OWORD *)(v150 + 73) = *(_OWORD *)&v250[9];
        *(_OWORD *)(v150 + 48) = v245;
        *(_OWORD *)(v150 + 64) = *(_OWORD *)v250;
        *(_OWORD *)(v150 + 32) = v240;
      }
      else
      {
        __int16 v163 = a2[1];
        *(_OWORD *)id v150 = *a2;
        *(_OWORD *)(v150 + 16) = v163;
        id v164 = a2[2];
        __int16 v165 = a2[3];
        double v166 = a2[4];
        *(_OWORD *)(v150 + 73) = *(_OWORD *)((char *)a2 + 73);
        *(_OWORD *)(v150 + 48) = v165;
        *(_OWORD *)(v150 + 64) = v166;
        *(_OWORD *)(v150 + 32) = v164;
        *(_OWORD *)((char *)a2 + 73) = *(_OWORD *)&v250[9];
        a2[3] = v245;
        a2[4] = *(_OWORD *)v250;
        a2[2] = v240;
        *a2 = v229;
        a2[1] = v235;
        id v167 = v150 - i + 96;
        if (v167 >= 97)
        {
          id v168 = v167 / 0x60uLL - 2;
          __int16 v169 = v168 >> 1;
          double v170 = i + 96 * (v168 >> 1);
          __int16 v171 = *(_DWORD *)(v170 + 56);
          int v172 = *(_DWORD *)(v150 + 56);
          if (v171 > v172)
          {
            __int16 v173 = *(_DWORD *)(v150 + 24);
            goto LABEL_216;
          }
          if (v171 == v172)
          {
            float v189 = *(_DWORD *)(i + 96 * v169 + 24);
            __int16 v173 = *(_DWORD *)(v150 + 24);
            if (v189 > v173
              || v189 == v173
              && (__int16 v173 = *(_DWORD *)(i + 96 * v169 + 24), *(double *)(i + 96 * v169 + 32) < *(double *)(v150 + 32)))
            {
LABEL_216:
              char v222 = *(void *)(v150 + 16);
              char v218 = *(_OWORD *)v150;
              uint64_t v174 = *(_DWORD *)(v150 + 28);
              uint64_t v175 = *(double *)(v150 + 32);
              double v213 = *(_OWORD *)(v150 + 40);
              *(_OWORD *)__int16 v206 = *(_OWORD *)(v150 + 60);
              *(_OWORD *)&v206[16] = *(_OWORD *)(v150 + 76);
              int v177 = *(_OWORD *)(v170 + 48);
              double v176 = *(_OWORD *)(v170 + 64);
              long long v178 = *(_OWORD *)(v170 + 32);
              *(_OWORD *)(v150 + 73) = *(_OWORD *)(v170 + 73);
              *(_OWORD *)(v150 + 48) = v177;
              *(_OWORD *)(v150 + 64) = v176;
              *(_OWORD *)(v150 + 32) = v178;
              long long v179 = *(_OWORD *)(v170 + 16);
              *(_OWORD *)id v150 = *(_OWORD *)v170;
              *(_OWORD *)(v150 + 16) = v179;
              if (v168 >= 2)
              {
                while (1)
                {
                  long long v181 = v169 - 1;
                  __int16 v169 = (v169 - 1) >> 1;
                  long long v180 = i + 96 * v169;
                  long long v182 = *(_DWORD *)(v180 + 56);
                  if (v182 <= v172)
                  {
                    if (v182 != v172) {
                      break;
                    }
                    unint64_t v183 = *(_DWORD *)(i + 96 * v169 + 24);
                    if (v183 <= v173 && (v183 != v173 || *(double *)(i + 96 * v169 + 32) >= v175)) {
                      break;
                    }
                  }
                  long long v184 = *(_OWORD *)(v180 + 16);
                  *(_OWORD *)double v170 = *(_OWORD *)v180;
                  *(_OWORD *)(v170 + 16) = v184;
                  long long v185 = *(_OWORD *)(v180 + 32);
                  long long v186 = *(_OWORD *)(v180 + 48);
                  long long v187 = *(_OWORD *)(v180 + 64);
                  *(_OWORD *)(v170 + 73) = *(_OWORD *)(v180 + 73);
                  *(_OWORD *)(v170 + 48) = v186;
                  *(_OWORD *)(v170 + 64) = v187;
                  *(_OWORD *)(v170 + 32) = v185;
                  double v170 = i + 96 * v169;
                  if (v181 <= 1) {
                    goto LABEL_224;
                  }
                }
              }
              long long v180 = v170;
LABEL_224:
              *(_OWORD *)long long v180 = v218;
              *(void *)(v180 + 16) = v222;
              *(_DWORD *)(v180 + 24) = v173;
              *(_DWORD *)(v180 + 28) = v174;
              *(double *)(v180 + 32) = v175;
              *(_OWORD *)(v180 + 40) = v213;
              *(_DWORD *)(v180 + 56) = v172;
              *(_OWORD *)(v180 + 60) = *(_OWORD *)v206;
              *(_OWORD *)(v180 + 73) = *(_OWORD *)&v206[13];
            }
          }
        }
      }
      if (v148-- <= 2) {
        return;
      }
      continue;
    }
  }
}

  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v23 = *(a2 - 2);
          uint64_t v24 = *v11;
          if (v23 < *v11 || v24 >= v23 && *(a2 - 1) < v11[1])
          {
            *unint64_t v11 = v23;
            *(a2 - 2) = v24;
            unint64_t v25 = *((void *)v11 + 1);
            v11[1] = *(a2 - 1);
            *((void *)a2 - 1) = v25;
          }
          break;
        case 3uLL:
          sub_10064345C(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          sub_100643A5C(v11, (uint64_t)(v11 + 2), (uint64_t)(v11 + 4), (uint64_t)(a2 - 2));
          break;
        case 5uLL:
          sub_100643B60(v11, (uint64_t)(v11 + 2), (uint64_t)(v11 + 4), (uint64_t)(v11 + 6), (uint64_t)(a2 - 2));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        sub_100967620((uint64_t)v11, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    id v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      sub_10064345C(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      sub_10064345C(v11 + 2, v17 - 2, a2 - 4);
      sub_10064345C(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      sub_10064345C(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(_OWORD *)v11;
      *(_OWORD *)unint64_t v11 = *(_OWORD *)v17;
      *(_OWORD *)id v17 = v18;
      if (a5) {
        goto LABEL_15;
      }
    }
    else
    {
      sub_10064345C(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_15;
      }
    }
    long long v19 = *(v11 - 2);
    if (v19 >= *v11 && (*v11 < v19 || *(v11 - 1) >= v11[1]))
    {
      unint64_t v11 = sub_1006435B0(v11, a2);
      goto LABEL_20;
    }
LABEL_15:
    float v20 = (double *)sub_1006436F4(v11, a2);
    if ((v21 & 1) == 0) {
      goto LABEL_18;
    }
    double v22 = sub_1009673FC((uint64_t)v11, v20);
    unint64_t v11 = v20 + 2;
    if (sub_1009673FC((uint64_t)(v20 + 2), a2))
    {
      a4 = -v13;
      a2 = v20;
      if (v22) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_18:
      sub_100967004(a1, v20, a3, -v13, a5 & 1);
      unint64_t v11 = v20 + 2;
LABEL_20:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1006432E8(v11, a2);
  }
  else
  {
    sub_1006433C0(v11, a2);
  }
}

  unint64_t v11 = a2 - 25;
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    unint64_t v15 = (uint64_t)a2 - v12;
    unint64_t v16 = 0x8F5C28F5C28F5C29 * ((uint64_t)((uint64_t)a2 - v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v43 = *(a2 - 19);
          unint64_t v44 = *(void *)(v12 + 48);
          if (v43 == v44)
          {
            id v45 = *(a2 - 18);
            id v46 = *(void *)(v12 + 56);
            uint64_t v47 = v45 < v46;
            if (v45 == v46)
            {
              uint64_t v48 = *(a2 - 17);
              uint64_t v49 = *(void *)(v12 + 64);
              uint64_t v47 = v48 < v49;
              if (v48 == v49) {
                uint64_t v47 = *((_OWORD *)a2 - 8) < *(_OWORD *)(v12 + 72);
              }
            }
            if (!v47
              && (*(a2 - 16) != *(void *)(v12 + 72)
               || *(a2 - 17) != *(void *)(v12 + 64)
               || v45 != v46
               || *(a2 - 15) != *(void *)(v12 + 80)
               || !sub_100BC2CB4((uint64_t)(a2 - 25), v12)))
            {
              return result;
            }
          }
          else if (v43 >= v44)
          {
            return result;
          }
          double v60 = *(_OWORD *)v12;
          uint64_t v66 = *(_OWORD *)(v12 + 48);
          unint64_t v68 = *(_OWORD *)(v12 + 64);
          unint64_t v62 = *(_OWORD *)(v12 + 16);
          id v64 = *(_OWORD *)(v12 + 32);
          int v74 = *(_OWORD *)(v12 + 112);
          uint64_t v76 = *(_OWORD *)(v12 + 128);
          long long v70 = *(_OWORD *)(v12 + 80);
          long long v72 = *(_OWORD *)(v12 + 96);
          uint64_t v84 = *(void *)(v12 + 192);
          uint64_t v80 = *(_OWORD *)(v12 + 160);
          unint64_t v82 = *(_OWORD *)(v12 + 176);
          uint64_t v78 = *(_OWORD *)(v12 + 144);
          *(_OWORD *)uint64_t v12 = *v11;
          uint64_t v50 = *(_OWORD *)(a2 - 23);
          uint64_t v51 = *(_OWORD *)(a2 - 21);
          uint64_t v52 = *(_OWORD *)(a2 - 17);
          *(_OWORD *)(v12 + 48) = *(_OWORD *)(a2 - 19);
          *(_OWORD *)(v12 + 64) = v52;
          *(_OWORD *)(v12 + 16) = v50;
          *(_OWORD *)(v12 + 32) = v51;
          uint64_t v53 = *(_OWORD *)(a2 - 15);
          unint64_t v54 = *(_OWORD *)(a2 - 13);
          id v55 = *(_OWORD *)(a2 - 9);
          *(_OWORD *)(v12 + 112) = *(_OWORD *)(a2 - 11);
          *(_OWORD *)(v12 + 128) = v55;
          *(_OWORD *)(v12 + 80) = v53;
          *(_OWORD *)(v12 + 96) = v54;
          id v56 = *(_OWORD *)(a2 - 7);
          id v57 = *(_OWORD *)(a2 - 5);
          id v58 = *(_OWORD *)(a2 - 3);
          *(void *)(v12 + 192) = *(a2 - 1);
          *(_OWORD *)(v12 + 160) = v57;
          *(_OWORD *)(v12 + 176) = v58;
          *(_OWORD *)(v12 + 144) = v56;
          *(_OWORD *)(a2 - 5) = v80;
          *(_OWORD *)(a2 - 3) = v82;
          *(a2 - 1) = v84;
          *(_OWORD *)(a2 - 13) = v72;
          *(_OWORD *)(a2 - 11) = v74;
          *(_OWORD *)(a2 - 9) = v76;
          *(_OWORD *)(a2 - 7) = v78;
          *(_OWORD *)(a2 - 21) = v64;
          *(_OWORD *)(a2 - 19) = v66;
          *(_OWORD *)(a2 - 17) = v68;
          *(_OWORD *)(a2 - 15) = v70;
          uint64_t result = *(double *)&v62;
          *unint64_t v11 = v60;
          *(_OWORD *)(a2 - 23) = v62;
          return result;
        case 3uLL:
          sub_100BC1578(v12, v12 + 200, (uint64_t)(a2 - 25));
          return result;
        case 4uLL:
          *(void *)&uint64_t result = sub_100BC3080(v12, v12 + 200, v12 + 400, (uint64_t)(a2 - 25)).n128_u64[0];
          return result;
        case 5uLL:
          *(void *)&uint64_t result = sub_100BC34BC(v12, v12 + 200, v12 + 400, v12 + 600, (uint64_t)(a2 - 25)).n128_u64[0];
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v15 <= 4799) {
      break;
    }
    if (v14 == 1)
    {
      if ((void *)v12 != a2)
      {
        sub_100BC3A4C(v12, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return result;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = v12 + 200 * (v16 >> 1);
    if ((unint64_t)v15 >= 0x6401)
    {
      sub_100BC1578(v12, v12 + 200 * (v16 >> 1), (uint64_t)(a2 - 25));
      long long v19 = 200 * v17;
      float v20 = 200 * v17 + v12 - 200;
      sub_100BC1578(v12 + 200, v19 + v12 - 200, (uint64_t)(a2 - 50));
      float v21 = v12 + 400;
      double v22 = v12 + 200 + v19;
      sub_100BC1578(v21, v22, (uint64_t)(a2 - 75));
      sub_100BC1578(v20, v18, v22);
      id v59 = *(_OWORD *)a1;
      uint64_t v65 = *(_OWORD *)(a1 + 48);
      id v67 = *(_OWORD *)(a1 + 64);
      id v61 = *(_OWORD *)(a1 + 16);
      int v63 = *(_OWORD *)(a1 + 32);
      id v73 = *(_OWORD *)(a1 + 112);
      long long v75 = *(_OWORD *)(a1 + 128);
      long long v69 = *(_OWORD *)(a1 + 80);
      long long v71 = *(_OWORD *)(a1 + 96);
      __int16 v83 = *(void *)(a1 + 192);
      __int16 v79 = *(_OWORD *)(a1 + 160);
      __int16 v81 = *(_OWORD *)(a1 + 176);
      id v77 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)a1 = *(_OWORD *)v18;
      uint64_t v23 = *(_OWORD *)(v18 + 16);
      uint64_t v24 = *(_OWORD *)(v18 + 32);
      unint64_t v25 = *(_OWORD *)(v18 + 64);
      *(_OWORD *)(a1 + 48) = *(_OWORD *)(v18 + 48);
      *(_OWORD *)(a1 + 64) = v25;
      *(_OWORD *)(a1 + 16) = v23;
      *(_OWORD *)(a1 + 32) = v24;
      char v26 = *(_OWORD *)(v18 + 80);
      BOOL v27 = *(_OWORD *)(v18 + 96);
      uint64_t v28 = *(_OWORD *)(v18 + 128);
      *(_OWORD *)(a1 + 112) = *(_OWORD *)(v18 + 112);
      *(_OWORD *)(a1 + 128) = v28;
      *(_OWORD *)(a1 + 80) = v26;
      *(_OWORD *)(a1 + 96) = v27;
      uint64_t v29 = *(_OWORD *)(v18 + 144);
      uint64_t v30 = *(_OWORD *)(v18 + 160);
      double v31 = *(_OWORD *)(v18 + 176);
      *(void *)(a1 + 192) = *(void *)(v18 + 192);
      *(_OWORD *)(a1 + 160) = v30;
      *(_OWORD *)(a1 + 176) = v31;
      *(_OWORD *)(a1 + 144) = v29;
      *(_OWORD *)uint64_t v18 = v59;
      *(_OWORD *)(v18 + 48) = v65;
      *(_OWORD *)(v18 + 64) = v67;
      *(_OWORD *)(v18 + 16) = v61;
      *(_OWORD *)(v18 + 32) = v63;
      *(_OWORD *)(v18 + 112) = v73;
      *(_OWORD *)(v18 + 128) = v75;
      *(_OWORD *)(v18 + 80) = v69;
      *(_OWORD *)(v18 + 96) = v71;
      *(void *)(v18 + 192) = v83;
      *(_OWORD *)(v18 + 160) = v79;
      *(_OWORD *)(v18 + 176) = v81;
      *(_OWORD *)(v18 + 144) = v77;
      if (a5) {
        goto LABEL_24;
      }
    }
    else
    {
      sub_100BC1578(v12 + 200 * (v16 >> 1), v12, (uint64_t)(a2 - 25));
      if (a5) {
        goto LABEL_24;
      }
    }
    id v32 = *(void *)(a1 - 152);
    unsigned __int8 v33 = *(void *)(a1 + 48);
    if (v32 == v33)
    {
      uint64_t v34 = *(void *)(a1 - 144);
      uint64_t v35 = *(void *)(a1 + 56);
      id v36 = v34 < v35;
      if (v34 == v35)
      {
        unsigned __int8 v37 = *(void *)(a1 - 136);
        uint64_t v38 = *(void *)(a1 + 64);
        id v36 = v37 < v38;
        if (v37 == v38) {
          id v36 = *(_OWORD *)(a1 - 128) < *(_OWORD *)(a1 + 72);
        }
      }
      if (!v36
        && (*(void *)(a1 - 128) != *(void *)(a1 + 72)
         || *(void *)(a1 - 136) != *(void *)(a1 + 64)
         || v34 != v35
         || *(void *)(a1 - 120) != *(void *)(a1 + 80)
         || (sub_100BC2CB4(a1 - 200, a1) & 1) == 0))
      {
LABEL_28:
        uint64_t v12 = sub_100BC1C60((long long *)a1, (unint64_t)a2);
        goto LABEL_29;
      }
    }
    else if (v32 >= v33)
    {
      goto LABEL_28;
    }
LABEL_24:
    uint64_t v39 = sub_100BC2228((long long *)a1, a2);
    if ((v40 & 1) == 0) {
      goto LABEL_27;
    }
    id v41 = sub_100BC2778(a1, v39);
    uint64_t v12 = v39 + 200;
    if (sub_100BC2778(v39 + 200, (uint64_t)a2))
    {
      a4 = -v14;
      a2 = (void *)v39;
      if (v41) {
        return result;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v41)
    {
LABEL_27:
      sub_100BC0970(a1, v39, a3, -v14, a5 & 1);
      uint64_t v12 = v39 + 200;
LABEL_29:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_100BC0FE0(v12, (uint64_t)a2);
  }
  else
  {
    return sub_100BC12D8(v12, (uint64_t)a2);
  }
  return result;
}

  unint64_t v11 = a2 - 25;
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    unint64_t v15 = (uint64_t)a2 - v12;
    unint64_t v16 = 0x8F5C28F5C28F5C29 * ((uint64_t)((uint64_t)a2 - v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v43 = *(a2 - 9);
          unint64_t v44 = *(void *)(v12 + 128);
          if (v43 == v44)
          {
            id v45 = *(a2 - 8);
            id v46 = *(void *)(v12 + 136);
            uint64_t v47 = v45 < v46;
            if (v45 == v46)
            {
              uint64_t v48 = *(a2 - 7);
              uint64_t v49 = *(void *)(v12 + 144);
              uint64_t v47 = v48 < v49;
              if (v48 == v49) {
                uint64_t v47 = *((_OWORD *)a2 - 3) < *(_OWORD *)(v12 + 152);
              }
            }
            if (!v47
              && (*(a2 - 6) != *(void *)(v12 + 152)
               || *(a2 - 7) != *(void *)(v12 + 144)
               || v45 != v46
               || *(a2 - 5) != *(void *)(v12 + 160)
               || !sub_100BC6F4C((uint64_t)(a2 - 25), v12)))
            {
              return result;
            }
          }
          else if (v43 >= v44)
          {
            return result;
          }
          double v60 = *(_OWORD *)v12;
          uint64_t v66 = *(_OWORD *)(v12 + 48);
          unint64_t v68 = *(_OWORD *)(v12 + 64);
          unint64_t v62 = *(_OWORD *)(v12 + 16);
          id v64 = *(_OWORD *)(v12 + 32);
          int v74 = *(_OWORD *)(v12 + 112);
          uint64_t v76 = *(_OWORD *)(v12 + 128);
          long long v70 = *(_OWORD *)(v12 + 80);
          long long v72 = *(_OWORD *)(v12 + 96);
          uint64_t v84 = *(void *)(v12 + 192);
          uint64_t v80 = *(_OWORD *)(v12 + 160);
          unint64_t v82 = *(_OWORD *)(v12 + 176);
          uint64_t v78 = *(_OWORD *)(v12 + 144);
          *(_OWORD *)uint64_t v12 = *v11;
          uint64_t v50 = *(_OWORD *)(a2 - 23);
          uint64_t v51 = *(_OWORD *)(a2 - 21);
          uint64_t v52 = *(_OWORD *)(a2 - 17);
          *(_OWORD *)(v12 + 48) = *(_OWORD *)(a2 - 19);
          *(_OWORD *)(v12 + 64) = v52;
          *(_OWORD *)(v12 + 16) = v50;
          *(_OWORD *)(v12 + 32) = v51;
          uint64_t v53 = *(_OWORD *)(a2 - 15);
          unint64_t v54 = *(_OWORD *)(a2 - 13);
          id v55 = *(_OWORD *)(a2 - 9);
          *(_OWORD *)(v12 + 112) = *(_OWORD *)(a2 - 11);
          *(_OWORD *)(v12 + 128) = v55;
          *(_OWORD *)(v12 + 80) = v53;
          *(_OWORD *)(v12 + 96) = v54;
          id v56 = *(_OWORD *)(a2 - 7);
          id v57 = *(_OWORD *)(a2 - 5);
          id v58 = *(_OWORD *)(a2 - 3);
          *(void *)(v12 + 192) = *(a2 - 1);
          *(_OWORD *)(v12 + 160) = v57;
          *(_OWORD *)(v12 + 176) = v58;
          *(_OWORD *)(v12 + 144) = v56;
          *(_OWORD *)(a2 - 5) = v80;
          *(_OWORD *)(a2 - 3) = v82;
          *(a2 - 1) = v84;
          *(_OWORD *)(a2 - 13) = v72;
          *(_OWORD *)(a2 - 11) = v74;
          *(_OWORD *)(a2 - 9) = v76;
          *(_OWORD *)(a2 - 7) = v78;
          *(_OWORD *)(a2 - 21) = v64;
          *(_OWORD *)(a2 - 19) = v66;
          *(_OWORD *)(a2 - 17) = v68;
          *(_OWORD *)(a2 - 15) = v70;
          uint64_t result = *(double *)&v62;
          *unint64_t v11 = v60;
          *(_OWORD *)(a2 - 23) = v62;
          return result;
        case 3uLL:
          sub_100BC5810(v12, v12 + 200, (uint64_t)(a2 - 25));
          return result;
        case 4uLL:
          *(void *)&uint64_t result = sub_100BC7318(v12, v12 + 200, v12 + 400, (uint64_t)(a2 - 25)).n128_u64[0];
          return result;
        case 5uLL:
          *(void *)&uint64_t result = sub_100BC7754(v12, v12 + 200, v12 + 400, v12 + 600, (uint64_t)(a2 - 25)).n128_u64[0];
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v15 <= 4799) {
      break;
    }
    if (v14 == 1)
    {
      if ((void *)v12 != a2)
      {
        sub_100BC7CE4(v12, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return result;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = v12 + 200 * (v16 >> 1);
    if ((unint64_t)v15 >= 0x6401)
    {
      sub_100BC5810(v12, v12 + 200 * (v16 >> 1), (uint64_t)(a2 - 25));
      long long v19 = 200 * v17;
      float v20 = 200 * v17 + v12 - 200;
      sub_100BC5810(v12 + 200, v19 + v12 - 200, (uint64_t)(a2 - 50));
      float v21 = v12 + 400;
      double v22 = v12 + 200 + v19;
      sub_100BC5810(v21, v22, (uint64_t)(a2 - 75));
      sub_100BC5810(v20, v18, v22);
      id v59 = *(_OWORD *)a1;
      uint64_t v65 = *(_OWORD *)(a1 + 48);
      id v67 = *(_OWORD *)(a1 + 64);
      id v61 = *(_OWORD *)(a1 + 16);
      int v63 = *(_OWORD *)(a1 + 32);
      id v73 = *(_OWORD *)(a1 + 112);
      long long v75 = *(_OWORD *)(a1 + 128);
      long long v69 = *(_OWORD *)(a1 + 80);
      long long v71 = *(_OWORD *)(a1 + 96);
      __int16 v83 = *(void *)(a1 + 192);
      __int16 v79 = *(_OWORD *)(a1 + 160);
      __int16 v81 = *(_OWORD *)(a1 + 176);
      id v77 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)a1 = *(_OWORD *)v18;
      uint64_t v23 = *(_OWORD *)(v18 + 16);
      uint64_t v24 = *(_OWORD *)(v18 + 32);
      unint64_t v25 = *(_OWORD *)(v18 + 64);
      *(_OWORD *)(a1 + 48) = *(_OWORD *)(v18 + 48);
      *(_OWORD *)(a1 + 64) = v25;
      *(_OWORD *)(a1 + 16) = v23;
      *(_OWORD *)(a1 + 32) = v24;
      char v26 = *(_OWORD *)(v18 + 80);
      BOOL v27 = *(_OWORD *)(v18 + 96);
      uint64_t v28 = *(_OWORD *)(v18 + 128);
      *(_OWORD *)(a1 + 112) = *(_OWORD *)(v18 + 112);
      *(_OWORD *)(a1 + 128) = v28;
      *(_OWORD *)(a1 + 80) = v26;
      *(_OWORD *)(a1 + 96) = v27;
      uint64_t v29 = *(_OWORD *)(v18 + 144);
      uint64_t v30 = *(_OWORD *)(v18 + 160);
      double v31 = *(_OWORD *)(v18 + 176);
      *(void *)(a1 + 192) = *(void *)(v18 + 192);
      *(_OWORD *)(a1 + 160) = v30;
      *(_OWORD *)(a1 + 176) = v31;
      *(_OWORD *)(a1 + 144) = v29;
      *(_OWORD *)uint64_t v18 = v59;
      *(_OWORD *)(v18 + 48) = v65;
      *(_OWORD *)(v18 + 64) = v67;
      *(_OWORD *)(v18 + 16) = v61;
      *(_OWORD *)(v18 + 32) = v63;
      *(_OWORD *)(v18 + 112) = v73;
      *(_OWORD *)(v18 + 128) = v75;
      *(_OWORD *)(v18 + 80) = v69;
      *(_OWORD *)(v18 + 96) = v71;
      *(void *)(v18 + 192) = v83;
      *(_OWORD *)(v18 + 160) = v79;
      *(_OWORD *)(v18 + 176) = v81;
      *(_OWORD *)(v18 + 144) = v77;
      if (a5) {
        goto LABEL_24;
      }
    }
    else
    {
      sub_100BC5810(v12 + 200 * (v16 >> 1), v12, (uint64_t)(a2 - 25));
      if (a5) {
        goto LABEL_24;
      }
    }
    id v32 = *(void *)(a1 - 72);
    unsigned __int8 v33 = *(void *)(a1 + 128);
    if (v32 == v33)
    {
      uint64_t v34 = *(void *)(a1 - 64);
      uint64_t v35 = *(void *)(a1 + 136);
      id v36 = v34 < v35;
      if (v34 == v35)
      {
        unsigned __int8 v37 = *(void *)(a1 - 56);
        uint64_t v38 = *(void *)(a1 + 144);
        id v36 = v37 < v38;
        if (v37 == v38) {
          id v36 = *(_OWORD *)(a1 - 48) < *(_OWORD *)(a1 + 152);
        }
      }
      if (!v36
        && (*(void *)(a1 - 48) != *(void *)(a1 + 152)
         || *(void *)(a1 - 56) != *(void *)(a1 + 144)
         || v34 != v35
         || *(void *)(a1 - 40) != *(void *)(a1 + 160)
         || (sub_100BC6F4C(a1 - 200, a1) & 1) == 0))
      {
LABEL_28:
        uint64_t v12 = sub_100BC5EF8((long long *)a1, (unint64_t)a2);
        goto LABEL_29;
      }
    }
    else if (v32 >= v33)
    {
      goto LABEL_28;
    }
LABEL_24:
    uint64_t v39 = sub_100BC64C0((long long *)a1, a2);
    if ((v40 & 1) == 0) {
      goto LABEL_27;
    }
    id v41 = sub_100BC6A10(a1, v39);
    uint64_t v12 = v39 + 200;
    if (sub_100BC6A10(v39 + 200, (uint64_t)a2))
    {
      a4 = -v14;
      a2 = (void *)v39;
      if (v41) {
        return result;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v41)
    {
LABEL_27:
      sub_100BC4C20(a1, v39, a3, -v14, a5 & 1);
      uint64_t v12 = v39 + 200;
LABEL_29:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_100BC5290(v12, (uint64_t)a2);
  }
  else
  {
    return sub_100BC5588(v12, (uint64_t)a2);
  }
  return result;
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 5);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 11) < *(double *)(v10 + 8))
          {
            id v161 = *(_OWORD *)v10;
            __int16 v173 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)__int16 v208 = *(_OWORD *)(v10 + 64);
            *(_OWORD *)&v208[16] = *(_OWORD *)(v10 + 80);
            long long v184 = *(_OWORD *)(v10 + 32);
            long long v196 = *(_OWORD *)(v10 + 48);
            int v63 = *(a2 - 3);
            unint64_t v62 = *(a2 - 2);
            id v64 = *(a2 - 4);
            *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)a2 - 20);
            *(_OWORD *)(v10 + 48) = v63;
            *(_OWORD *)(v10 + 64) = v62;
            *(_OWORD *)(v10 + 32) = v64;
            uint64_t v65 = *(a2 - 5);
            *(_OWORD *)unint64_t v10 = *(a2 - 6);
            *(_OWORD *)(v10 + 16) = v65;
            *(a2 - 6) = v161;
            *(a2 - 5) = v173;
            *(_OWORD *)((char *)a2 - 20) = *(_OWORD *)&v208[12];
            *(a2 - 3) = v196;
            *(a2 - 2) = *(_OWORD *)v208;
            *(a2 - 4) = v184;
          }
          break;
        case 3uLL:
          sub_100C82F60(v10, v10 + 96, (uint64_t)(a2 - 6));
          break;
        case 4uLL:
          sub_100C8354C(v10, v10 + 96, v10 + 192, (uint64_t)(a2 - 6));
          break;
        case 5uLL:
          uint64_t v66 = (long long *)(v10 + 96);
          id v67 = (long long *)(v10 + 192);
          unint64_t v68 = (long long *)(v10 + 288);
          sub_100C8354C(v10, v10 + 96, v10 + 192, v10 + 288);
          if (*((double *)a2 - 11) < *(double *)(v10 + 296))
          {
            long long v185 = *(_OWORD *)(v10 + 320);
            long long v197 = *(_OWORD *)(v10 + 336);
            *(_OWORD *)uint64_t v209 = *(_OWORD *)(v10 + 352);
            *(_OWORD *)&v209[16] = *(_OWORD *)(v10 + 368);
            id v162 = *v68;
            uint64_t v174 = *(_OWORD *)(v10 + 304);
            long long v69 = *(a2 - 5);
            *unint64_t v68 = *(a2 - 6);
            *(_OWORD *)(v10 + 304) = v69;
            long long v71 = *(a2 - 3);
            long long v70 = *(a2 - 2);
            long long v72 = *(a2 - 4);
            *(_OWORD *)(v10 + 364) = *(_OWORD *)((char *)a2 - 20);
            *(_OWORD *)(v10 + 336) = v71;
            *(_OWORD *)(v10 + 352) = v70;
            *(_OWORD *)(v10 + 320) = v72;
            *(a2 - 6) = v162;
            *(a2 - 5) = v174;
            *(_OWORD *)((char *)a2 - 20) = *(_OWORD *)&v209[12];
            *(a2 - 3) = v197;
            *(a2 - 2) = *(_OWORD *)v209;
            *(a2 - 4) = v185;
            if (*(double *)(v10 + 296) < *(double *)(v10 + 200))
            {
              long long v186 = *(_OWORD *)(v10 + 224);
              long long v198 = *(_OWORD *)(v10 + 240);
              *(_OWORD *)int v210 = *(_OWORD *)(v10 + 256);
              *(_OWORD *)&v210[16] = *(_OWORD *)(v10 + 272);
              __int16 v163 = *v67;
              uint64_t v175 = *(_OWORD *)(v10 + 208);
              id v73 = *(_OWORD *)(v10 + 336);
              *(_OWORD *)(v10 + 224) = *(_OWORD *)(v10 + 320);
              *(_OWORD *)(v10 + 240) = v73;
              *(_OWORD *)(v10 + 256) = *(_OWORD *)(v10 + 352);
              *(_OWORD *)(v10 + 268) = *(_OWORD *)(v10 + 364);
              int v74 = *(_OWORD *)(v10 + 304);
              *id v67 = *v68;
              *(_OWORD *)(v10 + 208) = v74;
              *unint64_t v68 = v163;
              *(_OWORD *)(v10 + 304) = v175;
              *(_OWORD *)(v10 + 364) = *(_OWORD *)&v210[12];
              long long v75 = *(double *)(v10 + 200) < *(double *)(v10 + 104);
              *(_OWORD *)(v10 + 336) = v198;
              *(_OWORD *)(v10 + 352) = *(_OWORD *)v210;
              *(_OWORD *)(v10 + 320) = v186;
              if (v75)
              {
                long long v187 = *(_OWORD *)(v10 + 128);
                long long v199 = *(_OWORD *)(v10 + 144);
                *(_OWORD *)__int16 v211 = *(_OWORD *)(v10 + 160);
                *(_OWORD *)&v211[16] = *(_OWORD *)(v10 + 176);
                id v164 = *v66;
                double v176 = *(_OWORD *)(v10 + 112);
                uint64_t v76 = *(_OWORD *)(v10 + 240);
                *(_OWORD *)(v10 + 128) = *(_OWORD *)(v10 + 224);
                *(_OWORD *)(v10 + 144) = v76;
                *(_OWORD *)(v10 + 160) = *(_OWORD *)(v10 + 256);
                *(_OWORD *)(v10 + 172) = *(_OWORD *)(v10 + 268);
                id v77 = *(_OWORD *)(v10 + 208);
                *uint64_t v66 = *v67;
                *(_OWORD *)(v10 + 112) = v77;
                *id v67 = v164;
                *(_OWORD *)(v10 + 208) = v176;
                *(_OWORD *)(v10 + 268) = *(_OWORD *)&v211[12];
                long long v75 = *(double *)(v10 + 104) < *(double *)(v10 + 8);
                *(_OWORD *)(v10 + 240) = v199;
                *(_OWORD *)(v10 + 256) = *(_OWORD *)v211;
                *(_OWORD *)(v10 + 224) = v187;
                if (v75)
                {
                  __int16 v165 = *(_OWORD *)v10;
                  int v177 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)int v212 = *(_OWORD *)(v10 + 64);
                  *(_OWORD *)&v212[16] = *(_OWORD *)(v10 + 80);
                  std::string v188 = *(_OWORD *)(v10 + 32);
                  long long v200 = *(_OWORD *)(v10 + 48);
                  *(_OWORD *)(v10 + 76) = *(_OWORD *)(v10 + 172);
                  uint64_t v78 = *(_OWORD *)(v10 + 160);
                  __int16 v79 = *(_OWORD *)(v10 + 128);
                  *(_OWORD *)(v10 + 48) = *(_OWORD *)(v10 + 144);
                  *(_OWORD *)(v10 + 64) = v78;
                  uint64_t v80 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)unint64_t v10 = *v66;
                  *(_OWORD *)(v10 + 16) = v80;
                  *(_OWORD *)(v10 + 32) = v79;
                  *uint64_t v66 = v165;
                  *(_OWORD *)(v10 + 112) = v177;
                  *(_OWORD *)(v10 + 172) = *(_OWORD *)&v212[12];
                  *(_OWORD *)(v10 + 144) = v200;
                  *(_OWORD *)(v10 + 160) = *(_OWORD *)v212;
                  *(_OWORD *)(v10 + 128) = v188;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 2303) {
      break;
    }
    if (!a3)
    {
      if ((_OWORD *)v10 == a2) {
        return;
      }
      double v96 = (v12 - 2) >> 1;
      id v97 = v96;
      do
      {
        id v98 = v97;
        if (v96 >= v97)
        {
          int v99 = (2 * v97) | 1;
          int v100 = v10 + 96 * v99;
          if (2 * v98 + 2 < (uint64_t)v12 && *(double *)(v10 + 96 * v99 + 8) < *(double *)(v100 + 104))
          {
            v100 += 96;
            int v99 = 2 * v98 + 2;
          }
          uint64_t v101 = *(double *)(v10 + 96 * v98 + 8);
          if (*(double *)(v100 + 8) >= v101)
          {
            id v102 = v10 + 96 * v98;
            int64_t v103 = *(void *)v102;
            id v167 = *(_OWORD *)(v102 + 16);
            *(_OWORD *)double v202 = *(_OWORD *)(v102 + 64);
            *(_OWORD *)&v202[16] = *(_OWORD *)(v102 + 80);
            long long v178 = *(_OWORD *)(v102 + 32);
            long long v190 = *(_OWORD *)(v102 + 48);
            do
            {
              unint64_t v104 = (_OWORD *)v102;
              id v102 = v100;
              uint64_t v105 = *(_OWORD *)(v100 + 16);
              *unint64_t v104 = *(_OWORD *)v100;
              v104[1] = v105;
              unint64_t v106 = *(_OWORD *)(v100 + 32);
              uint64_t v107 = *(_OWORD *)(v100 + 48);
              id v108 = *(_OWORD *)(v100 + 64);
              *(_OWORD *)((char *)v104 + 76) = *(_OWORD *)(v100 + 76);
              v104[3] = v107;
              v104[4] = v108;
              v104[2] = v106;
              if (v96 < v99) {
                break;
              }
              uint64_t v109 = (2 * v99) | 1;
              int v100 = v10 + 96 * v109;
              uint64_t v110 = 2 * v99 + 2;
              if (v110 < (uint64_t)v12 && *(double *)(v10 + 96 * v109 + 8) < *(double *)(v100 + 104))
              {
                v100 += 96;
                uint64_t v109 = v110;
              }
              int v99 = v109;
            }
            while (*(double *)(v100 + 8) >= v101);
            *(void *)id v102 = v103;
            *(double *)(v102 + 8) = v101;
            *(_OWORD *)(v102 + 48) = v190;
            *(_OWORD *)(v102 + 64) = *(_OWORD *)v202;
            *(_OWORD *)(v102 + 76) = *(_OWORD *)&v202[12];
            *(_OWORD *)(v102 + 16) = v167;
            *(_OWORD *)(v102 + 32) = v178;
          }
        }
        id v97 = v98 - 1;
      }
      while (v98);
      long long v111 = v11 / 0x60uLL;
      while (2)
      {
        int v112 = 0;
        id v168 = *(_OWORD *)v10;
        long long v179 = *(_OWORD *)(v10 + 16);
        *(_OWORD *)double v213 = *(_OWORD *)(v10 + 64);
        *(_OWORD *)&v213[16] = *(_OWORD *)(v10 + 80);
        long long v191 = *(_OWORD *)(v10 + 32);
        __int16 v203 = *(_OWORD *)(v10 + 48);
        id v113 = v10;
        do
        {
          uint64_t v114 = (_OWORD *)v113;
          uint64_t v115 = v112 + 1;
          v113 += 96 * (v112 + 1);
          double v116 = 2 * v112;
          int v112 = (2 * v112) | 1;
          double v117 = v116 + 2;
          if (v117 < v111 && *((double *)&v114[6 * v115] + 1) < *(double *)(v113 + 104))
          {
            v113 += 96;
            int v112 = v117;
          }
          id v118 = *(_OWORD *)(v113 + 16);
          *uint64_t v114 = *(_OWORD *)v113;
          v114[1] = v118;
          id v119 = *(_OWORD *)(v113 + 32);
          unint64_t v120 = *(_OWORD *)(v113 + 48);
          unint64_t v121 = *(_OWORD *)(v113 + 64);
          *(_OWORD *)((char *)v114 + 76) = *(_OWORD *)(v113 + 76);
          v114[3] = v120;
          v114[4] = v121;
          v114[2] = v119;
        }
        while (v112 <= (uint64_t)((unint64_t)(v111 - 2) >> 1));
        a2 -= 6;
        if ((_OWORD *)v113 != a2)
        {
          double v122 = a2[1];
          *(_OWORD *)id v113 = *a2;
          *(_OWORD *)(v113 + 16) = v122;
          double v123 = a2[2];
          id v124 = a2[3];
          id v125 = a2[4];
          *(_OWORD *)(v113 + 76) = *(_OWORD *)((char *)a2 + 76);
          *(_OWORD *)(v113 + 48) = v124;
          *(_OWORD *)(v113 + 64) = v125;
          *(_OWORD *)(v113 + 32) = v123;
          *(_OWORD *)((char *)a2 + 76) = *(_OWORD *)&v213[12];
          a2[3] = v203;
          a2[4] = *(_OWORD *)v213;
          a2[2] = v191;
          *a2 = v168;
          a2[1] = v179;
          unint64_t v126 = v113 - v10 + 96;
          if (v126 >= 97)
          {
            uint64_t v127 = (v126 / 0x60uLL - 2) >> 1;
            id v128 = *(double *)(v113 + 8);
            if (*(double *)(v10 + 96 * v127 + 8) < v128)
            {
              uint64_t v129 = *(void *)v113;
              id v148 = *(_OWORD *)(v113 + 16);
              *(_OWORD *)uint64_t v157 = *(_OWORD *)(v113 + 64);
              *(_OWORD *)&v157[16] = *(_OWORD *)(v113 + 80);
              id v151 = *(_OWORD *)(v113 + 32);
              unint64_t v154 = *(_OWORD *)(v113 + 48);
              do
              {
                double v130 = (_OWORD *)v113;
                id v113 = v10 + 96 * v127;
                uint64_t v131 = *(_OWORD *)(v113 + 16);
                void *v130 = *(_OWORD *)v113;
                v130[1] = v131;
                id v132 = *(_OWORD *)(v113 + 32);
                uint64_t v133 = *(_OWORD *)(v113 + 48);
                uint64_t v134 = *(_OWORD *)(v113 + 64);
                *(_OWORD *)((char *)v130 + 76) = *(_OWORD *)(v113 + 76);
                v130[3] = v133;
                v130[4] = v134;
                v130[2] = v132;
                if (!v127) {
                  break;
                }
                uint64_t v127 = (v127 - 1) >> 1;
              }
              while (*(double *)(v10 + 96 * v127 + 8) < v128);
              *(void *)id v113 = v129;
              *(double *)(v113 + 8) = v128;
              *(_OWORD *)(v113 + 16) = v148;
              id v135 = v151;
              uint64_t v136 = v154;
              uint64_t v137 = *(_OWORD *)v157;
              uint64_t v138 = *(_OWORD *)&v157[12];
LABEL_117:
              *(_OWORD *)(v113 + 76) = v138;
              *(_OWORD *)(v113 + 48) = v136;
              *(_OWORD *)(v113 + 64) = v137;
              *(_OWORD *)(v113 + 32) = v135;
            }
          }
          if (v111-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)id v113 = v168;
      *(_OWORD *)(v113 + 16) = v179;
      id v135 = v191;
      uint64_t v136 = v203;
      uint64_t v137 = *(_OWORD *)v213;
      uint64_t v138 = *(_OWORD *)&v213[12];
      goto LABEL_117;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (_OWORD *)(v10 + 96 * (v12 >> 1));
    if ((unint64_t)v11 > 0x3000)
    {
      sub_100C82F60(a1, a1 + 96 * (v12 >> 1), (uint64_t)(a2 - 6));
      unint64_t v15 = 3 * v13;
      unint64_t v16 = a1 + 96 * v13 - 96;
      sub_100C82F60(a1 + 96, v16, (uint64_t)(a2 - 12));
      id v17 = a1 + 96 + 32 * v15;
      sub_100C82F60(a1 + 192, v17, (uint64_t)(a2 - 18));
      sub_100C82F60(v16, (uint64_t)v14, v17);
      unint64_t v158 = *(_OWORD *)a1;
      double v170 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)unint64_t v205 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v205[16] = *(_OWORD *)(a1 + 80);
      long long v181 = *(_OWORD *)(a1 + 32);
      long long v193 = *(_OWORD *)(a1 + 48);
      long long v19 = v14[3];
      uint64_t v18 = v14[4];
      float v20 = v14[2];
      *(_OWORD *)(a1 + 76) = *(_OWORD *)((char *)v14 + 76);
      *(_OWORD *)(a1 + 48) = v19;
      *(_OWORD *)(a1 + 64) = v18;
      *(_OWORD *)(a1 + 32) = v20;
      float v21 = v14[1];
      *(_OWORD *)a1 = *v14;
      *(_OWORD *)(a1 + 16) = v21;
      *uint64_t v14 = v158;
      v14[1] = v170;
      *(_OWORD *)((char *)v14 + 76) = *(_OWORD *)&v205[12];
      v14[3] = v193;
      v14[4] = *(_OWORD *)v205;
      int v14[2] = v181;
    }
    else
    {
      sub_100C82F60(a1 + 96 * (v12 >> 1), a1, (uint64_t)(a2 - 6));
    }
    --a3;
    if (a4)
    {
      double v22 = *(double *)(a1 + 8);
LABEL_12:
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)a1;
      *(_OWORD *)int v155 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v155[16] = *(_OWORD *)(a1 + 80);
      id v149 = *(_OWORD *)(a1 + 32);
      double v152 = *(_OWORD *)(a1 + 48);
      std::string::size_type v146 = *(_OWORD *)(a1 + 16);
      do
      {
        unint64_t v25 = *(double *)(a1 + v23 + 104);
        v23 += 96;
      }
      while (v25 < v22);
      char v26 = a1 + v23;
      BOOL v27 = (double *)a2;
      if (v23 == 96)
      {
        uint64_t v30 = (double *)a2;
        while (v26 < (unint64_t)v30)
        {
          uint64_t v28 = v30 - 12;
          double v31 = *(v30 - 11);
          v30 -= 12;
          if (v31 < v22) {
            goto LABEL_22;
          }
        }
        uint64_t v28 = v30;
      }
      else
      {
        do
        {
          uint64_t v28 = v27 - 12;
          uint64_t v29 = *(v27 - 11);
          v27 -= 12;
        }
        while (v29 >= v22);
      }
LABEL_22:
      unint64_t v10 = v26;
      if (v26 < (unint64_t)v28)
      {
        id v32 = v28;
        do
        {
          id v159 = *(_OWORD *)v10;
          __int16 v171 = *(_OWORD *)(v10 + 16);
          *(_OWORD *)__int16 v206 = *(_OWORD *)(v10 + 64);
          *(_OWORD *)&v206[16] = *(_OWORD *)(v10 + 80);
          long long v182 = *(_OWORD *)(v10 + 32);
          long long v194 = *(_OWORD *)(v10 + 48);
          uint64_t v34 = *((_OWORD *)v32 + 3);
          unsigned __int8 v33 = *((_OWORD *)v32 + 4);
          uint64_t v35 = *((_OWORD *)v32 + 2);
          *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)v32 + 76);
          *(_OWORD *)(v10 + 48) = v34;
          *(_OWORD *)(v10 + 64) = v33;
          *(_OWORD *)(v10 + 32) = v35;
          id v36 = *((_OWORD *)v32 + 1);
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v32;
          *(_OWORD *)(v10 + 16) = v36;
          *(_OWORD *)id v32 = v159;
          *((_OWORD *)v32 + 1) = v171;
          *(_OWORD *)((char *)v32 + 76) = *(_OWORD *)&v206[12];
          *((_OWORD *)v32 + 3) = v194;
          *((_OWORD *)v32 + 4) = *(_OWORD *)v206;
          *((_OWORD *)v32 + 2) = v182;
          do
          {
            unsigned __int8 v37 = *(double *)(v10 + 104);
            v10 += 96;
          }
          while (v37 < v22);
          do
          {
            uint64_t v38 = *(v32 - 11);
            v32 -= 12;
          }
          while (v38 >= v22);
        }
        while (v10 < (unint64_t)v32);
      }
      if (v10 - 96 != a1)
      {
        uint64_t v39 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 16) = v39;
        uint64_t v40 = *(_OWORD *)(v10 - 64);
        id v41 = *(_OWORD *)(v10 - 48);
        unsigned __int8 v42 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 76) = *(_OWORD *)(v10 - 20);
        *(_OWORD *)(a1 + 48) = v41;
        *(_OWORD *)(a1 + 64) = v42;
        *(_OWORD *)(a1 + 32) = v40;
      }
      *(void *)(v10 - 96) = v24;
      *(double *)(v10 - 88) = v22;
      *(_OWORD *)(v10 - 80) = v146;
      *(_OWORD *)(v10 - 20) = *(_OWORD *)&v155[12];
      *(_OWORD *)(v10 - 48) = v152;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v155;
      *(_OWORD *)(v10 - 64) = v149;
      if (v26 < (unint64_t)v28) {
        goto LABEL_33;
      }
      unint64_t v43 = sub_100C83150(a1, v10 - 96);
      if (sub_100C83150(v10, (uint64_t)a2))
      {
        a2 = (_OWORD *)(v10 - 96);
        if (v43) {
          return;
        }
        goto LABEL_1;
      }
      if (!v43)
      {
LABEL_33:
        sub_100C82344(a1, v10 - 96, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      double v22 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 88) < v22) {
        goto LABEL_12;
      }
      unint64_t v44 = *(void *)a1;
      *(_OWORD *)id v156 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v156[16] = *(_OWORD *)(a1 + 80);
      id v150 = *(_OWORD *)(a1 + 32);
      id v153 = *(_OWORD *)(a1 + 48);
      __int16 v147 = *(_OWORD *)(a1 + 16);
      if (v22 >= *((double *)a2 - 11))
      {
        uint64_t v47 = a1 + 96;
        do
        {
          unint64_t v10 = v47;
          if (v47 >= (unint64_t)a2) {
            break;
          }
          uint64_t v48 = *(double *)(v47 + 8);
          v47 += 96;
        }
        while (v22 >= v48);
      }
      else
      {
        id v45 = a1;
        do
        {
          unint64_t v10 = v45 + 96;
          id v46 = *(double *)(v45 + 104);
          v45 += 96;
        }
        while (v22 >= v46);
      }
      uint64_t v49 = (double *)a2;
      if (v10 < (unint64_t)a2)
      {
        uint64_t v50 = (double *)a2;
        do
        {
          uint64_t v49 = v50 - 12;
          uint64_t v51 = *(v50 - 11);
          v50 -= 12;
        }
        while (v22 < v51);
      }
      while (v10 < (unint64_t)v49)
      {
        id v160 = *(_OWORD *)v10;
        int v172 = *(_OWORD *)(v10 + 16);
        *(_OWORD *)double v207 = *(_OWORD *)(v10 + 64);
        *(_OWORD *)&v207[16] = *(_OWORD *)(v10 + 80);
        unint64_t v183 = *(_OWORD *)(v10 + 32);
        long long v195 = *(_OWORD *)(v10 + 48);
        uint64_t v53 = *((_OWORD *)v49 + 3);
        uint64_t v52 = *((_OWORD *)v49 + 4);
        unint64_t v54 = *((_OWORD *)v49 + 2);
        *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)v49 + 76);
        *(_OWORD *)(v10 + 48) = v53;
        *(_OWORD *)(v10 + 64) = v52;
        *(_OWORD *)(v10 + 32) = v54;
        id v55 = *((_OWORD *)v49 + 1);
        *(_OWORD *)unint64_t v10 = *(_OWORD *)v49;
        *(_OWORD *)(v10 + 16) = v55;
        *(_OWORD *)uint64_t v49 = v160;
        *((_OWORD *)v49 + 1) = v172;
        *(_OWORD *)((char *)v49 + 76) = *(_OWORD *)&v207[12];
        *((_OWORD *)v49 + 3) = v195;
        *((_OWORD *)v49 + 4) = *(_OWORD *)v207;
        *((_OWORD *)v49 + 2) = v183;
        do
        {
          id v56 = *(double *)(v10 + 104);
          v10 += 96;
        }
        while (v22 >= v56);
        do
        {
          id v57 = *(v49 - 11);
          v49 -= 12;
        }
        while (v22 < v57);
      }
      unint64_t v4 = v10 - 96 >= a1;
      char v5 = v10 - 96 == a1;
      if (v10 - 96 != a1)
      {
        id v58 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 16) = v58;
        id v59 = *(_OWORD *)(v10 - 64);
        double v60 = *(_OWORD *)(v10 - 48);
        id v61 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 76) = *(_OWORD *)(v10 - 20);
        *(_OWORD *)(a1 + 48) = v60;
        *(_OWORD *)(a1 + 64) = v61;
        *(_OWORD *)(a1 + 32) = v59;
      }
      a4 = 0;
      *(void *)(v10 - 96) = v44;
      *(double *)(v10 - 88) = v22;
      *(_OWORD *)(v10 - 80) = v147;
      *(_OWORD *)(v10 - 20) = *(_OWORD *)&v156[12];
      *(_OWORD *)(v10 - 48) = v153;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v156;
      *(_OWORD *)(v10 - 64) = v150;
    }
  }
  __int16 v81 = (_OWORD *)(v10 + 96);
  __int16 v83 = (_OWORD *)v10 == a2 || v81 == a2;
  if (a4)
  {
    if (!v83)
    {
      uint64_t v84 = 0;
      __int16 v85 = v10;
      do
      {
        double v86 = v81;
        uint64_t v87 = *(double *)(v85 + 104);
        if (v87 < *(double *)(v85 + 8))
        {
          double v88 = *(void *)v81;
          float v189 = *(_OWORD *)(v85 + 144);
          *(_OWORD *)double v201 = *(_OWORD *)(v85 + 160);
          *(_OWORD *)&v201[16] = *(_OWORD *)(v85 + 176);
          uint64_t v90 = *(_OWORD *)(v85 + 112);
          __int16 v89 = *(_OWORD *)(v85 + 128);
          __int16 v91 = v84;
          double v166 = v90;
          while (1)
          {
            unint64_t v92 = (_OWORD *)(v10 + v91);
            __int16 v93 = *(_OWORD *)(v10 + v91 + 48);
            v92[8] = *(_OWORD *)(v10 + v91 + 32);
            v92[9] = v93;
            v92[10] = *(_OWORD *)(v10 + v91 + 64);
            *(_OWORD *)((char *)v92 + 172) = *(_OWORD *)(v10 + v91 + 76);
            uint64_t v94 = *(_OWORD *)(v10 + v91 + 16);
            v92[6] = *(_OWORD *)(v10 + v91);
            v92[7] = v94;
            if (!v91) {
              break;
            }
            v91 -= 96;
            if (v87 >= *((double *)v92 - 11))
            {
              __int16 v95 = v10 + v91 + 96;
              goto LABEL_85;
            }
          }
          __int16 v95 = v10;
LABEL_85:
          *(void *)__int16 v95 = v88;
          *(double *)(v95 + 8) = v87;
          *(_OWORD *)(v95 + 48) = v189;
          *(_OWORD *)(v95 + 64) = *(_OWORD *)v201;
          *(_OWORD *)(v95 + 76) = *(_OWORD *)&v201[12];
          *(_OWORD *)(v95 + 16) = v166;
          *(_OWORD *)(v95 + 32) = v89;
        }
        __int16 v81 = v86 + 6;
        v84 += 96;
        __int16 v85 = (unint64_t)v86;
      }
      while (v86 + 6 != a2);
    }
  }
  else if (!v83)
  {
    do
    {
      id v140 = (unint64_t)v81;
      unint64_t v141 = *(double *)(a1 + 104);
      if (v141 < *(double *)(a1 + 8))
      {
        unint64_t v142 = *(void *)v81;
        unint64_t v192 = *(_OWORD *)(a1 + 144);
        *(_OWORD *)__int16 v204 = *(_OWORD *)(a1 + 160);
        *(_OWORD *)&v204[16] = *(_OWORD *)(a1 + 176);
        __int16 v169 = *(_OWORD *)(a1 + 112);
        long long v180 = *(_OWORD *)(a1 + 128);
        do
        {
          id v143 = *(v81 - 3);
          v81[2] = *(v81 - 4);
          v81[3] = v143;
          v81[4] = *(v81 - 2);
          *(_OWORD *)((char *)v81 + 76) = *(_OWORD *)((char *)v81 - 20);
          std::string::size_type v144 = *(v81 - 5);
          *__int16 v81 = *(v81 - 6);
          v81[1] = v144;
          uint64_t v145 = *((double *)v81 - 23);
          v81 -= 6;
        }
        while (v141 < v145);
        *(void *)__int16 v81 = v142;
        *((double *)v81 + 1) = v141;
        v81[1] = v169;
        *(_OWORD *)((char *)v81 + 76) = *(_OWORD *)&v204[12];
        v81[3] = v192;
        v81[4] = *(_OWORD *)v204;
        v81[2] = v180;
      }
      __int16 v81 = (_OWORD *)(v140 + 96);
      a1 = v140;
    }
    while ((_OWORD *)(v140 + 96) != a2);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = a2 - v10;
    uint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a2 - v10) >> 3);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*(double *)(a2 - 112) < *(double *)(v10 + 8))
          {
            uint64_t v225 = *(_OWORD *)(v10 + 32);
            __int16 v237 = *(_OWORD *)(v10 + 48);
            double v201 = *(_OWORD *)v10;
            double v213 = *(_OWORD *)(v10 + 16);
            uint64_t v284 = *(void *)(v10 + 112);
            float v260 = *(_OWORD *)(v10 + 80);
            double v272 = *(_OWORD *)(v10 + 96);
            int v248 = *(_OWORD *)(v10 + 64);
            long long v72 = *(_OWORD *)(a2 - 40);
            id v73 = *(_OWORD *)(a2 - 24);
            int v74 = *(_OWORD *)(a2 - 56);
            *(void *)(v10 + 112) = *(void *)(a2 - 8);
            *(_OWORD *)(v10 + 80) = v72;
            *(_OWORD *)(v10 + 96) = v73;
            *(_OWORD *)(v10 + 64) = v74;
            long long v75 = *(_OWORD *)(a2 - 120);
            uint64_t v76 = *(_OWORD *)(a2 - 104);
            id v77 = *(_OWORD *)(a2 - 72);
            *(_OWORD *)(v10 + 32) = *(_OWORD *)(a2 - 88);
            *(_OWORD *)(v10 + 48) = v77;
            *(_OWORD *)unint64_t v10 = v75;
            *(_OWORD *)(v10 + 16) = v76;
            *(_OWORD *)(a2 - 72) = v237;
            *(_OWORD *)(a2 - 88) = v225;
            *(_OWORD *)(a2 - 104) = v213;
            *(_OWORD *)(a2 - 120) = v201;
            *(void *)(a2 - 8) = v284;
            *(_OWORD *)(a2 - 24) = v272;
            *(_OWORD *)(a2 - 40) = v260;
            *(_OWORD *)(a2 - 56) = v248;
          }
          break;
        case 3uLL:
          sub_1011046A4((long long *)v10, (long long *)(v10 + 120), (double *)(a2 - 120));
          break;
        case 4uLL:
          sub_101104E0C(v10, v10 + 120, (long long *)(v10 + 240), (long long *)(a2 - 120));
          break;
        case 5uLL:
          uint64_t v78 = (long long *)(v10 + 120);
          __int16 v79 = (long long *)(v10 + 240);
          uint64_t v80 = (long long *)(v10 + 360);
          sub_101104E0C(v10, v10 + 120, (long long *)(v10 + 240), (long long *)(v10 + 360));
          if (*(double *)(a2 - 112) < *(double *)(v10 + 368))
          {
            __int16 v249 = *(_OWORD *)(v10 + 424);
            __int16 v261 = *(_OWORD *)(v10 + 440);
            uint64_t v273 = *(_OWORD *)(v10 + 456);
            __int16 v285 = *(void *)(v10 + 472);
            double v202 = *v80;
            __int16 v214 = *(_OWORD *)(v10 + 376);
            int v226 = *(_OWORD *)(v10 + 392);
            double v238 = *(_OWORD *)(v10 + 408);
            __int16 v81 = *(_OWORD *)(a2 - 120);
            unint64_t v82 = *(_OWORD *)(a2 - 104);
            __int16 v83 = *(_OWORD *)(a2 - 72);
            *(_OWORD *)(v10 + 392) = *(_OWORD *)(a2 - 88);
            *(_OWORD *)(v10 + 408) = v83;
            *uint64_t v80 = v81;
            *(_OWORD *)(v10 + 376) = v82;
            uint64_t v84 = *(void *)(a2 - 8);
            __int16 v85 = *(_OWORD *)(a2 - 24);
            double v86 = *(_OWORD *)(a2 - 40);
            *(_OWORD *)(v10 + 424) = *(_OWORD *)(a2 - 56);
            *(_OWORD *)(v10 + 440) = v86;
            *(_OWORD *)(v10 + 456) = v85;
            *(void *)(v10 + 472) = v84;
            *(_OWORD *)(a2 - 72) = v238;
            *(_OWORD *)(a2 - 88) = v226;
            *(_OWORD *)(a2 - 104) = v214;
            *(_OWORD *)(a2 - 120) = v202;
            *(void *)(a2 - 8) = v285;
            *(_OWORD *)(a2 - 24) = v273;
            *(_OWORD *)(a2 - 40) = v261;
            *(_OWORD *)(a2 - 56) = v249;
            if (*(double *)(v10 + 368) < *(double *)(v10 + 248))
            {
              double v250 = *(_OWORD *)(v10 + 304);
              uint64_t v262 = *(_OWORD *)(v10 + 320);
              uint64_t v274 = *(_OWORD *)(v10 + 336);
              int v286 = *(void *)(v10 + 352);
              __int16 v203 = *v79;
              uint64_t v215 = *(_OWORD *)(v10 + 256);
              char v227 = *(_OWORD *)(v10 + 272);
              __int16 v239 = *(_OWORD *)(v10 + 288);
              uint64_t v87 = *v80;
              double v88 = *(_OWORD *)(v10 + 376);
              __int16 v89 = *(_OWORD *)(v10 + 408);
              *(_OWORD *)(v10 + 272) = *(_OWORD *)(v10 + 392);
              *(_OWORD *)(v10 + 288) = v89;
              *__int16 v79 = v87;
              *(_OWORD *)(v10 + 256) = v88;
              uint64_t v90 = *(_OWORD *)(v10 + 424);
              __int16 v91 = *(_OWORD *)(v10 + 440);
              unint64_t v92 = *(_OWORD *)(v10 + 456);
              *(void *)(v10 + 352) = *(void *)(v10 + 472);
              *(_OWORD *)(v10 + 320) = v91;
              *(_OWORD *)(v10 + 336) = v92;
              *(_OWORD *)(v10 + 304) = v90;
              *(_OWORD *)(v10 + 392) = v227;
              *(_OWORD *)(v10 + 408) = v239;
              *uint64_t v80 = v203;
              *(_OWORD *)(v10 + 376) = v215;
              *(void *)(v10 + 472) = v286;
              *(_OWORD *)(v10 + 440) = v262;
              *(_OWORD *)(v10 + 456) = v274;
              *(void *)&unint64_t v92 = *(void *)(v10 + 248);
              *(void *)&__int16 v89 = *(void *)(v10 + 128);
              *(_OWORD *)(v10 + 424) = v250;
              if (*(double *)&v92 < *(double *)&v89)
              {
                __int16 v251 = *(_OWORD *)(v10 + 184);
                __int16 v263 = *(_OWORD *)(v10 + 200);
                uint64_t v275 = *(_OWORD *)(v10 + 216);
                __int16 v287 = *(void *)(v10 + 232);
                __int16 v204 = *v78;
                int v216 = *(_OWORD *)(v10 + 136);
                uint64_t v228 = *(_OWORD *)(v10 + 152);
                uint64_t v240 = *(_OWORD *)(v10 + 168);
                __int16 v93 = *v79;
                uint64_t v94 = *(_OWORD *)(v10 + 256);
                __int16 v95 = *(_OWORD *)(v10 + 288);
                *(_OWORD *)(v10 + 152) = *(_OWORD *)(v10 + 272);
                *(_OWORD *)(v10 + 168) = v95;
                *uint64_t v78 = v93;
                *(_OWORD *)(v10 + 136) = v94;
                double v96 = *(_OWORD *)(v10 + 304);
                id v97 = *(_OWORD *)(v10 + 320);
                id v98 = *(_OWORD *)(v10 + 336);
                *(void *)(v10 + 232) = *(void *)(v10 + 352);
                *(_OWORD *)(v10 + 200) = v97;
                *(_OWORD *)(v10 + 216) = v98;
                *(_OWORD *)(v10 + 184) = v96;
                *(_OWORD *)(v10 + 272) = v228;
                *(_OWORD *)(v10 + 288) = v240;
                *__int16 v79 = v204;
                *(_OWORD *)(v10 + 256) = v216;
                *(void *)(v10 + 352) = v287;
                *(_OWORD *)(v10 + 320) = v263;
                *(_OWORD *)(v10 + 336) = v275;
                *(void *)&id v98 = *(void *)(v10 + 128);
                *(void *)&__int16 v95 = *(void *)(v10 + 8);
                *(_OWORD *)(v10 + 304) = v251;
                if (*(double *)&v98 < *(double *)&v95)
                {
                  __int16 v229 = *(_OWORD *)(v10 + 32);
                  __int16 v241 = *(_OWORD *)(v10 + 48);
                  unint64_t v205 = *(_OWORD *)v10;
                  char v217 = *(_OWORD *)(v10 + 16);
                  v288 = *(void *)(v10 + 112);
                  uint64_t v264 = *(_OWORD *)(v10 + 80);
                  v276 = *(_OWORD *)(v10 + 96);
                  double v252 = *(_OWORD *)(v10 + 64);
                  int v99 = *(_OWORD *)(v10 + 200);
                  *(_OWORD *)(v10 + 64) = *(_OWORD *)(v10 + 184);
                  *(_OWORD *)(v10 + 80) = v99;
                  *(_OWORD *)(v10 + 96) = *(_OWORD *)(v10 + 216);
                  *(void *)(v10 + 112) = *(void *)(v10 + 232);
                  int v100 = *(_OWORD *)(v10 + 136);
                  *(_OWORD *)unint64_t v10 = *v78;
                  *(_OWORD *)(v10 + 16) = v100;
                  uint64_t v101 = *(_OWORD *)(v10 + 168);
                  *(_OWORD *)(v10 + 32) = *(_OWORD *)(v10 + 152);
                  *(_OWORD *)(v10 + 48) = v101;
                  *(_OWORD *)(v10 + 152) = v229;
                  *(_OWORD *)(v10 + 168) = v241;
                  *uint64_t v78 = v205;
                  *(_OWORD *)(v10 + 136) = v217;
                  *(void *)(v10 + 232) = v288;
                  *(_OWORD *)(v10 + 200) = v264;
                  *(_OWORD *)(v10 + 216) = v276;
                  *(_OWORD *)(v10 + 184) = v252;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 2879) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return;
      }
      id v118 = (v12 - 2) >> 1;
      id v119 = v118;
      do
      {
        unint64_t v120 = v119;
        if (v118 >= v119)
        {
          unint64_t v121 = (2 * v119) | 1;
          double v122 = v10 + 120 * v121;
          if (2 * v119 + 2 < (uint64_t)v12 && *(double *)(v10 + 120 * v121 + 8) < *(double *)(v122 + 128))
          {
            v122 += 120;
            unint64_t v121 = 2 * v119 + 2;
          }
          double v123 = *(double *)(v10 + 120 * v119 + 8);
          if (*(double *)(v122 + 8) >= v123)
          {
            id v124 = v10 + 120 * v119;
            id v125 = *(void *)v124;
            long long v219 = *(_OWORD *)(v124 + 32);
            v231 = *(_OWORD *)(v124 + 48);
            double v207 = *(_OWORD *)(v124 + 16);
            v278 = *(void *)(v124 + 112);
            double v254 = *(_OWORD *)(v124 + 80);
            double v266 = *(_OWORD *)(v124 + 96);
            uint64_t v242 = *(_OWORD *)(v124 + 64);
            do
            {
              unint64_t v126 = v124;
              id v124 = v122;
              uint64_t v127 = *(_OWORD *)v122;
              id v128 = *(_OWORD *)(v122 + 16);
              uint64_t v129 = *(_OWORD *)(v122 + 48);
              *(_OWORD *)(v126 + 32) = *(_OWORD *)(v122 + 32);
              *(_OWORD *)(v126 + 48) = v129;
              *(_OWORD *)unint64_t v126 = v127;
              *(_OWORD *)(v126 + 16) = v128;
              double v130 = *(_OWORD *)(v122 + 64);
              uint64_t v131 = *(_OWORD *)(v122 + 80);
              id v132 = *(_OWORD *)(v122 + 96);
              *(void *)(v126 + 112) = *(void *)(v122 + 112);
              *(_OWORD *)(v126 + 80) = v131;
              *(_OWORD *)(v126 + 96) = v132;
              *(_OWORD *)(v126 + 64) = v130;
              if (v118 < v121) {
                break;
              }
              uint64_t v133 = (2 * v121) | 1;
              double v122 = v10 + 120 * v133;
              uint64_t v134 = 2 * v121 + 2;
              if (v134 < (uint64_t)v12 && *(double *)(v10 + 120 * v133 + 8) < *(double *)(v122 + 128))
              {
                v122 += 120;
                uint64_t v133 = v134;
              }
              unint64_t v121 = v133;
            }
            while (*(double *)(v122 + 8) >= v123);
            *(void *)id v124 = v125;
            *(double *)(v124 + 8) = v123;
            *(_OWORD *)(v124 + 80) = v254;
            *(_OWORD *)(v124 + 96) = v266;
            *(void *)(v124 + 112) = v278;
            *(_OWORD *)(v124 + 16) = v207;
            *(_OWORD *)(v124 + 32) = v219;
            *(_OWORD *)(v124 + 48) = v231;
            *(_OWORD *)(v124 + 64) = v242;
          }
        }
        id v119 = v120 - 1;
      }
      while (v120);
      id v135 = v11 / 0x78uLL;
      while (2)
      {
        uint64_t v136 = 0;
        int v232 = *(_OWORD *)(v10 + 32);
        __int16 v243 = *(_OWORD *)(v10 + 48);
        __int16 v208 = *(_OWORD *)v10;
        double v220 = *(_OWORD *)(v10 + 16);
        __int16 v289 = *(void *)(v10 + 112);
        __int16 v267 = *(_OWORD *)(v10 + 80);
        char v279 = *(_OWORD *)(v10 + 96);
        __int16 v255 = *(_OWORD *)(v10 + 64);
        uint64_t v137 = v10;
        do
        {
          uint64_t v138 = v137;
          unint64_t v139 = v136 + 1;
          v137 += 120 * (v136 + 1);
          id v140 = 2 * v136;
          uint64_t v136 = (2 * v136) | 1;
          unint64_t v141 = v140 + 2;
          if (v141 < v135 && *(double *)(v138 + 120 * v139 + 8) < *(double *)(v137 + 128))
          {
            v137 += 120;
            uint64_t v136 = v141;
          }
          unint64_t v142 = *(_OWORD *)v137;
          id v143 = *(_OWORD *)(v137 + 16);
          std::string::size_type v144 = *(_OWORD *)(v137 + 48);
          *(_OWORD *)(v138 + 32) = *(_OWORD *)(v137 + 32);
          *(_OWORD *)(v138 + 48) = v144;
          *(_OWORD *)uint64_t v138 = v142;
          *(_OWORD *)(v138 + 16) = v143;
          uint64_t v145 = *(_OWORD *)(v137 + 64);
          std::string::size_type v146 = *(_OWORD *)(v137 + 80);
          __int16 v147 = *(_OWORD *)(v137 + 96);
          *(void *)(v138 + 112) = *(void *)(v137 + 112);
          *(_OWORD *)(v138 + 80) = v146;
          *(_OWORD *)(v138 + 96) = v147;
          *(_OWORD *)(v138 + 64) = v145;
        }
        while (v136 <= (uint64_t)((unint64_t)(v135 - 2) >> 1));
        a2 -= 120;
        if (v137 != a2)
        {
          id v148 = *(_OWORD *)a2;
          id v149 = *(_OWORD *)(a2 + 16);
          id v150 = *(_OWORD *)(a2 + 48);
          *(_OWORD *)(v137 + 32) = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(v137 + 48) = v150;
          *(_OWORD *)uint64_t v137 = v148;
          *(_OWORD *)(v137 + 16) = v149;
          id v151 = *(_OWORD *)(a2 + 64);
          double v152 = *(_OWORD *)(a2 + 80);
          id v153 = *(_OWORD *)(a2 + 96);
          *(void *)(v137 + 112) = *(void *)(a2 + 112);
          *(_OWORD *)(v137 + 80) = v152;
          *(_OWORD *)(v137 + 96) = v153;
          *(_OWORD *)(v137 + 64) = v151;
          *(void *)(a2 + 112) = v289;
          *(_OWORD *)(a2 + 80) = v267;
          *(_OWORD *)(a2 + 96) = v279;
          *(_OWORD *)(a2 + 64) = v255;
          *(_OWORD *)(a2 + 32) = v232;
          *(_OWORD *)(a2 + 48) = v243;
          *(_OWORD *)a2 = v208;
          *(_OWORD *)(a2 + 16) = v220;
          unint64_t v154 = v137 - v10 + 120;
          if (v154 >= 121)
          {
            int v155 = (v154 / 0x78uLL - 2) >> 1;
            id v156 = *(double *)(v137 + 8);
            if (*(double *)(v10 + 120 * v155 + 8) < v156)
            {
              uint64_t v157 = *(void *)v137;
              long long v182 = *(_OWORD *)(v137 + 32);
              long long v185 = *(_OWORD *)(v137 + 48);
              long long v179 = *(_OWORD *)(v137 + 16);
              long long v197 = *(void *)(v137 + 112);
              long long v191 = *(_OWORD *)(v137 + 80);
              long long v194 = *(_OWORD *)(v137 + 96);
              std::string v188 = *(_OWORD *)(v137 + 64);
              do
              {
                unint64_t v158 = v137;
                uint64_t v137 = v10 + 120 * v155;
                id v159 = *(_OWORD *)v137;
                id v160 = *(_OWORD *)(v137 + 16);
                id v161 = *(_OWORD *)(v137 + 48);
                *(_OWORD *)(v158 + 32) = *(_OWORD *)(v137 + 32);
                *(_OWORD *)(v158 + 48) = v161;
                *(_OWORD *)unint64_t v158 = v159;
                *(_OWORD *)(v158 + 16) = v160;
                id v162 = *(_OWORD *)(v137 + 64);
                __int16 v163 = *(_OWORD *)(v137 + 80);
                id v164 = *(_OWORD *)(v137 + 96);
                *(void *)(v158 + 112) = *(void *)(v137 + 112);
                *(_OWORD *)(v158 + 80) = v163;
                *(_OWORD *)(v158 + 96) = v164;
                *(_OWORD *)(v158 + 64) = v162;
                if (!v155) {
                  break;
                }
                int v155 = (v155 - 1) >> 1;
              }
              while (*(double *)(v10 + 120 * v155 + 8) < v156);
              *(void *)uint64_t v137 = v157;
              *(double *)(v137 + 8) = v156;
              *(_OWORD *)(v137 + 32) = v182;
              *(_OWORD *)(v137 + 48) = v185;
              *(_OWORD *)(v137 + 16) = v179;
              __int16 v165 = v188;
              double v166 = v191;
              id v167 = v194;
              id v168 = v197;
LABEL_115:
              *(void *)(v137 + 112) = v168;
              *(_OWORD *)(v137 + 80) = v166;
              *(_OWORD *)(v137 + 96) = v167;
              *(_OWORD *)(v137 + 64) = v165;
            }
          }
          if (v135-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)(v137 + 32) = v232;
      *(_OWORD *)(v137 + 48) = v243;
      *(_OWORD *)uint64_t v137 = v208;
      *(_OWORD *)(v137 + 16) = v220;
      __int16 v165 = v255;
      double v166 = v267;
      id v167 = v279;
      id v168 = v289;
      goto LABEL_115;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = v10 + 120 * (v12 >> 1);
    if ((unint64_t)v11 >= 0x3C01)
    {
      sub_1011046A4((long long *)a1, (long long *)(a1 + 120 * (v12 >> 1)), (double *)(a2 - 120));
      unint64_t v15 = 120 * v13;
      unint64_t v16 = (long long *)(120 * v13 + a1 - 120);
      sub_1011046A4((long long *)(a1 + 120), v16, (double *)(a2 - 240));
      id v17 = (long long *)(a1 + 120 + v15);
      sub_1011046A4((long long *)(a1 + 240), v17, (double *)(a2 - 360));
      sub_1011046A4(v16, (long long *)v14, (double *)v17);
      char v222 = *(_OWORD *)(a1 + 32);
      v234 = *(_OWORD *)(a1 + 48);
      long long v198 = *(_OWORD *)a1;
      int v210 = *(_OWORD *)(a1 + 16);
      id v281 = *(void *)(a1 + 112);
      __int16 v257 = *(_OWORD *)(a1 + 80);
      __int16 v269 = *(_OWORD *)(a1 + 96);
      __int16 v245 = *(_OWORD *)(a1 + 64);
      long long v19 = *(_OWORD *)(v14 + 80);
      uint64_t v18 = *(_OWORD *)(v14 + 96);
      float v20 = *(_OWORD *)(v14 + 64);
      *(void *)(a1 + 112) = *(void *)(v14 + 112);
      *(_OWORD *)(a1 + 80) = v19;
      *(_OWORD *)(a1 + 96) = v18;
      *(_OWORD *)(a1 + 64) = v20;
      float v21 = *(_OWORD *)v14;
      double v22 = *(_OWORD *)(v14 + 16);
      uint64_t v23 = *(_OWORD *)(v14 + 48);
      *(_OWORD *)(a1 + 32) = *(_OWORD *)(v14 + 32);
      *(_OWORD *)(a1 + 48) = v23;
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v22;
      *(_OWORD *)(v14 + 32) = v222;
      *(_OWORD *)(v14 + 48) = v234;
      *(_OWORD *)uint64_t v14 = v198;
      *(_OWORD *)(v14 + 16) = v210;
      *(void *)(v14 + 112) = v281;
      *(_OWORD *)(v14 + 80) = v257;
      *(_OWORD *)(v14 + 96) = v269;
      *(_OWORD *)(v14 + 64) = v245;
    }
    else
    {
      sub_1011046A4((long long *)(a1 + 120 * (v12 >> 1)), (long long *)a1, (double *)(a2 - 120));
    }
    --a3;
    if (a4)
    {
      uint64_t v24 = *(double *)(a1 + 8);
LABEL_12:
      unint64_t v25 = 0;
      char v26 = *(void *)a1;
      long long v195 = *(void *)(a1 + 112);
      unint64_t v183 = *(_OWORD *)(a1 + 48);
      long long v186 = *(_OWORD *)(a1 + 64);
      float v189 = *(_OWORD *)(a1 + 80);
      unint64_t v192 = *(_OWORD *)(a1 + 96);
      int v177 = *(_OWORD *)(a1 + 16);
      long long v180 = *(_OWORD *)(a1 + 32);
      do
      {
        BOOL v27 = *(double *)(a1 + v25 + 128);
        v25 += 120;
      }
      while (v27 < v24);
      uint64_t v28 = a1 + v25;
      uint64_t v29 = a2;
      if (v25 == 120)
      {
        id v32 = a2;
        while (v28 < v32)
        {
          uint64_t v30 = v32 - 120;
          unsigned __int8 v33 = *(double *)(v32 - 112);
          v32 -= 120;
          if (v33 < v24) {
            goto LABEL_22;
          }
        }
        uint64_t v30 = v32;
      }
      else
      {
        do
        {
          uint64_t v30 = v29 - 120;
          double v31 = *(double *)(v29 - 112);
          v29 -= 120;
        }
        while (v31 >= v24);
      }
LABEL_22:
      unint64_t v10 = v28;
      if (v28 < v30)
      {
        uint64_t v34 = v30;
        do
        {
          uint64_t v223 = *(_OWORD *)(v10 + 32);
          __int16 v235 = *(_OWORD *)(v10 + 48);
          long long v199 = *(_OWORD *)v10;
          __int16 v211 = *(_OWORD *)(v10 + 16);
          v282 = *(void *)(v10 + 112);
          double v258 = *(_OWORD *)(v10 + 80);
          double v270 = *(_OWORD *)(v10 + 96);
          double v246 = *(_OWORD *)(v10 + 64);
          id v36 = *(_OWORD *)(v34 + 80);
          uint64_t v35 = *(_OWORD *)(v34 + 96);
          unsigned __int8 v37 = *(_OWORD *)(v34 + 64);
          *(void *)(v10 + 112) = *(void *)(v34 + 112);
          *(_OWORD *)(v10 + 80) = v36;
          *(_OWORD *)(v10 + 96) = v35;
          *(_OWORD *)(v10 + 64) = v37;
          uint64_t v38 = *(_OWORD *)v34;
          uint64_t v39 = *(_OWORD *)(v34 + 16);
          uint64_t v40 = *(_OWORD *)(v34 + 48);
          *(_OWORD *)(v10 + 32) = *(_OWORD *)(v34 + 32);
          *(_OWORD *)(v10 + 48) = v40;
          *(_OWORD *)unint64_t v10 = v38;
          *(_OWORD *)(v10 + 16) = v39;
          *(_OWORD *)(v34 + 32) = v223;
          *(_OWORD *)(v34 + 48) = v235;
          *(_OWORD *)uint64_t v34 = v199;
          *(_OWORD *)(v34 + 16) = v211;
          *(void *)(v34 + 112) = v282;
          *(_OWORD *)(v34 + 80) = v258;
          *(_OWORD *)(v34 + 96) = v270;
          *(_OWORD *)(v34 + 64) = v246;
          do
          {
            id v41 = *(double *)(v10 + 128);
            v10 += 120;
          }
          while (v41 < v24);
          do
          {
            unsigned __int8 v42 = *(double *)(v34 - 112);
            v34 -= 120;
          }
          while (v42 >= v24);
        }
        while (v10 < v34);
      }
      if (v10 - 120 != a1)
      {
        unint64_t v43 = *(_OWORD *)(v10 - 120);
        unint64_t v44 = *(_OWORD *)(v10 - 104);
        id v45 = *(_OWORD *)(v10 - 72);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(v10 - 88);
        *(_OWORD *)(a1 + 48) = v45;
        *(_OWORD *)a1 = v43;
        *(_OWORD *)(a1 + 16) = v44;
        id v46 = *(_OWORD *)(v10 - 56);
        uint64_t v47 = *(_OWORD *)(v10 - 40);
        uint64_t v48 = *(_OWORD *)(v10 - 24);
        *(void *)(a1 + 112) = *(void *)(v10 - 8);
        *(_OWORD *)(a1 + 80) = v47;
        *(_OWORD *)(a1 + 96) = v48;
        *(_OWORD *)(a1 + 64) = v46;
      }
      *(void *)(v10 - 120) = v26;
      *(double *)(v10 - 112) = v24;
      *(_OWORD *)(v10 - 72) = v183;
      *(_OWORD *)(v10 - 88) = v180;
      *(_OWORD *)(v10 - 104) = v177;
      *(void *)(v10 - 8) = v195;
      *(_OWORD *)(v10 - 24) = v192;
      *(_OWORD *)(v10 - 40) = v189;
      *(_OWORD *)(v10 - 56) = v186;
      if (v28 < v30) {
        goto LABEL_33;
      }
      uint64_t v49 = sub_10110492C(a1, v10 - 120);
      if (sub_10110492C(v10, a2))
      {
        a2 = v10 - 120;
        if (v49) {
          return;
        }
        goto LABEL_1;
      }
      if (!v49)
      {
LABEL_33:
        sub_101103844(a1, v10 - 120, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v24 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 112) < v24) {
        goto LABEL_12;
      }
      uint64_t v50 = *(void *)a1;
      long long v196 = *(void *)(a1 + 112);
      long long v178 = *(_OWORD *)(a1 + 16);
      long long v181 = *(_OWORD *)(a1 + 32);
      long long v190 = *(_OWORD *)(a1 + 80);
      long long v193 = *(_OWORD *)(a1 + 96);
      long long v184 = *(_OWORD *)(a1 + 48);
      long long v187 = *(_OWORD *)(a1 + 64);
      if (v24 >= *(double *)(a2 - 112))
      {
        uint64_t v53 = a1 + 120;
        do
        {
          unint64_t v10 = v53;
          if (v53 >= a2) {
            break;
          }
          unint64_t v54 = *(double *)(v53 + 8);
          v53 += 120;
        }
        while (v24 >= v54);
      }
      else
      {
        uint64_t v51 = a1;
        do
        {
          unint64_t v10 = v51 + 120;
          uint64_t v52 = *(double *)(v51 + 128);
          v51 += 120;
        }
        while (v24 >= v52);
      }
      id v55 = a2;
      if (v10 < a2)
      {
        id v56 = a2;
        do
        {
          id v55 = v56 - 120;
          id v57 = *(double *)(v56 - 112);
          v56 -= 120;
        }
        while (v24 < v57);
      }
      while (v10 < v55)
      {
        char v224 = *(_OWORD *)(v10 + 32);
        v236 = *(_OWORD *)(v10 + 48);
        long long v200 = *(_OWORD *)v10;
        int v212 = *(_OWORD *)(v10 + 16);
        __int16 v283 = *(void *)(v10 + 112);
        __int16 v259 = *(_OWORD *)(v10 + 80);
        __int16 v271 = *(_OWORD *)(v10 + 96);
        __int16 v247 = *(_OWORD *)(v10 + 64);
        id v59 = *(_OWORD *)(v55 + 80);
        id v58 = *(_OWORD *)(v55 + 96);
        double v60 = *(_OWORD *)(v55 + 64);
        *(void *)(v10 + 112) = *(void *)(v55 + 112);
        *(_OWORD *)(v10 + 80) = v59;
        *(_OWORD *)(v10 + 96) = v58;
        *(_OWORD *)(v10 + 64) = v60;
        id v61 = *(_OWORD *)v55;
        unint64_t v62 = *(_OWORD *)(v55 + 16);
        int v63 = *(_OWORD *)(v55 + 48);
        *(_OWORD *)(v10 + 32) = *(_OWORD *)(v55 + 32);
        *(_OWORD *)(v10 + 48) = v63;
        *(_OWORD *)unint64_t v10 = v61;
        *(_OWORD *)(v10 + 16) = v62;
        *(_OWORD *)(v55 + 32) = v224;
        *(_OWORD *)(v55 + 48) = v236;
        *(_OWORD *)id v55 = v200;
        *(_OWORD *)(v55 + 16) = v212;
        *(void *)(v55 + 112) = v283;
        *(_OWORD *)(v55 + 80) = v259;
        *(_OWORD *)(v55 + 96) = v271;
        *(_OWORD *)(v55 + 64) = v247;
        do
        {
          id v64 = *(double *)(v10 + 128);
          v10 += 120;
        }
        while (v24 >= v64);
        do
        {
          uint64_t v65 = *(double *)(v55 - 112);
          v55 -= 120;
        }
        while (v24 < v65);
      }
      unint64_t v4 = v10 - 120 >= a1;
      char v5 = v10 - 120 == a1;
      if (v10 - 120 != a1)
      {
        uint64_t v66 = *(_OWORD *)(v10 - 120);
        id v67 = *(_OWORD *)(v10 - 104);
        unint64_t v68 = *(_OWORD *)(v10 - 72);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(v10 - 88);
        *(_OWORD *)(a1 + 48) = v68;
        *(_OWORD *)a1 = v66;
        *(_OWORD *)(a1 + 16) = v67;
        long long v69 = *(_OWORD *)(v10 - 56);
        long long v70 = *(_OWORD *)(v10 - 40);
        long long v71 = *(_OWORD *)(v10 - 24);
        *(void *)(a1 + 112) = *(void *)(v10 - 8);
        *(_OWORD *)(a1 + 80) = v70;
        *(_OWORD *)(a1 + 96) = v71;
        *(_OWORD *)(a1 + 64) = v69;
      }
      a4 = 0;
      *(void *)(v10 - 120) = v50;
      *(double *)(v10 - 112) = v24;
      *(_OWORD *)(v10 - 72) = v184;
      *(_OWORD *)(v10 - 88) = v181;
      *(_OWORD *)(v10 - 104) = v178;
      *(void *)(v10 - 8) = v196;
      *(_OWORD *)(v10 - 24) = v193;
      *(_OWORD *)(v10 - 40) = v190;
      *(_OWORD *)(v10 - 56) = v187;
    }
  }
  id v102 = v10 + 120;
  unint64_t v104 = v10 == a2 || v102 == a2;
  if (a4)
  {
    if (!v104)
    {
      uint64_t v105 = 0;
      unint64_t v106 = v10;
      do
      {
        uint64_t v107 = v102;
        id v108 = *(double *)(v106 + 128);
        if (v108 < *(double *)(v106 + 8))
        {
          uint64_t v109 = *(void *)v102;
          uint64_t v110 = *(_OWORD *)(v106 + 184);
          __int16 v253 = *(_OWORD *)(v106 + 200);
          __int16 v265 = *(_OWORD *)(v106 + 216);
          v277 = *(void *)(v106 + 232);
          __int16 v206 = *(_OWORD *)(v106 + 136);
          char v218 = *(_OWORD *)(v106 + 152);
          long long v111 = *(_OWORD *)(v106 + 168);
          int v112 = v105;
          int v230 = v111;
          while (1)
          {
            id v113 = v10 + v112;
            uint64_t v114 = *(_OWORD *)(v10 + v112 + 80);
            *(_OWORD *)(v113 + 184) = *(_OWORD *)(v10 + v112 + 64);
            *(_OWORD *)(v113 + 200) = v114;
            *(_OWORD *)(v113 + 216) = *(_OWORD *)(v10 + v112 + 96);
            uint64_t v115 = *(_OWORD *)(v10 + v112 + 16);
            *(_OWORD *)(v113 + 120) = *(_OWORD *)(v10 + v112);
            *(_OWORD *)(v113 + 136) = v115;
            double v116 = *(_OWORD *)(v10 + v112 + 48);
            *(_OWORD *)(v113 + 152) = *(_OWORD *)(v10 + v112 + 32);
            *(void *)(v113 + 232) = *(void *)(v10 + v112 + 112);
            *(_OWORD *)(v113 + 168) = v116;
            if (!v112) {
              break;
            }
            v112 -= 120;
            if (v108 >= *(double *)(v113 - 112))
            {
              double v117 = v10 + v112 + 120;
              goto LABEL_83;
            }
          }
          double v117 = v10;
LABEL_83:
          *(void *)double v117 = v109;
          *(double *)(v117 + 8) = v108;
          *(_OWORD *)(v117 + 80) = v253;
          *(_OWORD *)(v117 + 96) = v265;
          *(void *)(v117 + 112) = v277;
          *(_OWORD *)(v117 + 16) = v206;
          *(_OWORD *)(v117 + 32) = v218;
          *(_OWORD *)(v117 + 48) = v230;
          *(_OWORD *)(v117 + 64) = v110;
        }
        id v102 = v107 + 120;
        v105 += 120;
        unint64_t v106 = v107;
      }
      while (v107 + 120 != a2);
    }
  }
  else if (!v104)
  {
    do
    {
      double v170 = v102;
      __int16 v171 = *(double *)(a1 + 128);
      if (v171 < *(double *)(a1 + 8))
      {
        int v172 = *(void *)v102;
        v256 = *(_OWORD *)(a1 + 200);
        int v268 = *(_OWORD *)(a1 + 216);
        v280 = *(void *)(a1 + 232);
        uint64_t v209 = *(_OWORD *)(a1 + 136);
        uint64_t v221 = *(_OWORD *)(a1 + 152);
        v233 = *(_OWORD *)(a1 + 168);
        uint64_t v244 = *(_OWORD *)(a1 + 184);
        do
        {
          __int16 v173 = *(_OWORD *)(v102 - 40);
          *(_OWORD *)(v102 + 64) = *(_OWORD *)(v102 - 56);
          *(_OWORD *)(v102 + 80) = v173;
          *(_OWORD *)(v102 + 96) = *(_OWORD *)(v102 - 24);
          *(void *)(v102 + 112) = *(void *)(v102 - 8);
          uint64_t v174 = *(_OWORD *)(v102 - 104);
          *(_OWORD *)id v102 = *(_OWORD *)(v102 - 120);
          *(_OWORD *)(v102 + 16) = v174;
          uint64_t v175 = *(_OWORD *)(v102 - 72);
          *(_OWORD *)(v102 + 32) = *(_OWORD *)(v102 - 88);
          *(_OWORD *)(v102 + 48) = v175;
          double v176 = *(double *)(v102 - 232);
          v102 -= 120;
        }
        while (v171 < v176);
        *(void *)id v102 = v172;
        *(double *)(v102 + 8) = v171;
        *(_OWORD *)(v102 + 32) = v221;
        *(_OWORD *)(v102 + 48) = v233;
        *(_OWORD *)(v102 + 16) = v209;
        *(void *)(v102 + 112) = v280;
        *(_OWORD *)(v102 + 80) = v256;
        *(_OWORD *)(v102 + 96) = v268;
        *(_OWORD *)(v102 + 64) = v244;
      }
      id v102 = v170 + 120;
      a1 = v170;
    }
    while (v170 + 120 != a2);
  }
}

  unint64_t v11 = a2 - 24;
  uint64_t v12 = (const void **)a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v12;
    uint64_t v14 = v13;
    unint64_t v15 = a2 - (char *)v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((a2 - (char *)v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (sub_101214488(a3, (void *)a2 - 3, v12))
          {
            double v31 = v12[2];
            uint64_t v29 = *(_OWORD *)v12;
            BOOL v27 = *(_OWORD *)v11;
            _OWORD v12[2] = (const void *)*((void *)a2 - 1);
            *(_OWORD *)uint64_t v12 = v27;
            *(_OWORD *)unint64_t v11 = v29;
            *((void *)a2 - 1) = v31;
          }
          break;
        case 3uLL:
          sub_101214728(v12, v12 + 3, (void *)a2 - 3, a3);
          break;
        case 4uLL:
          sub_101214DEC((uint64_t)v12, v12 + 3, v12 + 6, (void *)a2 - 3, a3);
          break;
        case 5uLL:
          sub_101214ED8((uint64_t)v12, v12 + 3, v12 + 6, v12 + 9, (void *)a2 - 3, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 575) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (const void **)a2)
      {
        sub_101214FFC((uint64_t)v12, a2, a2, a3);
      }
      return;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = &v12[3 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0xC01)
    {
      sub_101214728(v12, &v12[3 * (v16 >> 1)], (void *)a2 - 3, a3);
      long long v19 = 3 * v17;
      float v20 = &v12[3 * v17 - 3];
      sub_101214728(v12 + 3, v20, (void *)a2 - 6, a3);
      float v21 = v12 + 6;
      double v22 = &v12[v19 + 3];
      sub_101214728(v21, v22, (void *)a2 - 9, a3);
      sub_101214728(v20, v18, v22, a3);
      uint64_t v30 = *(const void **)(a1 + 16);
      uint64_t v28 = *(_OWORD *)a1;
      uint64_t v23 = *(_OWORD *)v18;
      *(void *)(a1 + 16) = v18[2];
      *(_OWORD *)a1 = v23;
      v18[2] = v30;
      *(_OWORD *)uint64_t v18 = v28;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_101214728(&v12[3 * (v16 >> 1)], v12, (void *)a2 - 3, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!sub_101214488(a3, (void *)(a1 - 24), (const void **)a1))
    {
      uint64_t v12 = sub_101214874((const void **)a1, (unint64_t)a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v24 = (const void **)sub_101214A08((long long *)a1, a2, a3);
    if ((v25 & 1) == 0) {
      goto LABEL_16;
    }
    char v26 = sub_101214B98(a1, v24, a3);
    uint64_t v12 = v24 + 3;
    if (sub_101214B98((uint64_t)(v24 + 3), (const void **)a2, a3))
    {
      a4 = -v14;
      a2 = (char *)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v26)
    {
LABEL_16:
      sub_101214060(a1, v24, a3, -v14, a5 & 1);
      uint64_t v12 = v24 + 3;
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1012144F4((uint64_t)v12, a2, a3);
  }
  else
  {
    sub_10121461C(v12, a2, a3);
  }
}

  uint64_t v12 = (float *)a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v12;
    uint64_t v14 = v13;
    unint64_t v15 = (char *)a2 - (char *)v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v12) >> 3);
    if (!(!v7 & v6))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v28 = a2[-2].n128_f32[2];
          BOOL v27 = &a2[-2].n128_i8[8];
          if (v28 < *v12)
          {
            uint64_t v38 = *((void *)v12 + 2);
            uint64_t v35 = *(_OWORD *)v12;
            uint64_t v29 = *(_OWORD *)v27;
            *((void *)v12 + 2) = *((void *)v27 + 2);
            *(_OWORD *)uint64_t v12 = v29;
            *(_OWORD *)BOOL v27 = v35;
            *((void *)v27 + 2) = v38;
          }
          break;
        case 3uLL:
          sub_1013F77E0((long long *)v12, (long long *)(v12 + 6), (long long *)&a2[-2].n128_i8[8]);
          break;
        case 4uLL:
          sub_1013F7D74((uint64_t)v12, (uint64_t)(v12 + 6), (uint64_t)(v12 + 12), (uint64_t)&a2[-2].n128_i64[1]);
          break;
        case 5uLL:
          sub_1013F7E48((__n128 *)v12, (__n128 *)(v12 + 6), (__n128 *)v12 + 3, (__n128 *)(v12 + 18), (__n128 *)((char *)a2 - 24));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 575) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (float *)a2)
      {
        sub_1013F7F58((uint64_t)v12, a2, a2, a3, a6);
      }
      return;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = &v12[6 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0xC01)
    {
      sub_1013F77E0((long long *)v12, (long long *)&v12[6 * (v16 >> 1)], (long long *)&a2[-2].n128_i8[8]);
      long long v19 = 3 * v17;
      float v20 = (long long *)&v12[6 * v17 - 6];
      sub_1013F77E0((long long *)(v12 + 6), v20, (long long *)&a2[-3]);
      float v21 = (long long *)(v12 + 12);
      double v22 = (long long *)&v12[2 * v19 + 6];
      sub_1013F77E0(v21, v22, (long long *)&a2[-5].n128_i8[8]);
      sub_1013F77E0(v20, (long long *)v18, v22);
      unsigned __int8 v37 = *(void *)(a1 + 16);
      uint64_t v34 = *(_OWORD *)a1;
      uint64_t v23 = *(_OWORD *)v18;
      *(void *)(a1 + 16) = *((void *)v18 + 2);
      *(_OWORD *)a1 = v23;
      *((void *)v18 + 2) = v37;
      *(_OWORD *)uint64_t v18 = v34;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_1013F77E0((long long *)&v12[6 * (v16 >> 1)], (long long *)v12, (long long *)&a2[-2].n128_i8[8]);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(float *)(a1 - 24) >= *(float *)a1)
    {
      uint64_t v12 = sub_1013F78EC((float *)a1, (float *)a2);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v24 = sub_1013F7A24(a1, (unint64_t)a2);
    if ((v25 & 1) == 0) {
      goto LABEL_16;
    }
    char v26 = sub_1013F7B5C(a1, v24);
    uint64_t v12 = (float *)(v24 + 24);
    if (sub_1013F7B5C(v24 + 24, (uint64_t)a2))
    {
      a4 = -v14;
      a2 = (__n128 *)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v26)
    {
LABEL_16:
      sub_1013F71E4(a1, v24, a3, -v14, a5 & 1);
      uint64_t v12 = (float *)(v24 + 24);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1013F76F4((uint64_t)v12, (uint64_t)a2);
  }
  else if (v12 != (float *)a2)
  {
    uint64_t v30 = v12 + 6;
    while (v30 != (float *)a2)
    {
      double v31 = (uint64_t)v30;
      id v32 = *(float *)(a1 + 24);
      if (v32 < *(float *)a1)
      {
        id v36 = *(_OWORD *)(a1 + 28);
        uint64_t v39 = *(_DWORD *)(a1 + 44);
        do
        {
          *(_OWORD *)uint64_t v30 = *(_OWORD *)(v30 - 6);
          *((void *)v30 + 2) = *((void *)v30 - 1);
          unsigned __int8 v33 = *(v30 - 12);
          v30 -= 6;
        }
        while (v32 < v33);
        id *v30 = v32;
        *((_DWORD *)v30 + 5) = v39;
        *(_OWORD *)(v30 + 1) = v36;
      }
      uint64_t v30 = (float *)(v31 + 24);
      a1 = v31;
    }
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 5);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 11) < *(double *)(v10 + 8))
          {
            id v161 = *(_OWORD *)v10;
            __int16 v173 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)__int16 v208 = *(_OWORD *)(v10 + 64);
            *(_OWORD *)&v208[16] = *(_OWORD *)(v10 + 80);
            long long v184 = *(_OWORD *)(v10 + 32);
            long long v196 = *(_OWORD *)(v10 + 48);
            int v63 = *(a2 - 3);
            unint64_t v62 = *(a2 - 2);
            id v64 = *(a2 - 4);
            *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)a2 - 20);
            *(_OWORD *)(v10 + 48) = v63;
            *(_OWORD *)(v10 + 64) = v62;
            *(_OWORD *)(v10 + 32) = v64;
            uint64_t v65 = *(a2 - 5);
            *(_OWORD *)unint64_t v10 = *(a2 - 6);
            *(_OWORD *)(v10 + 16) = v65;
            *(a2 - 6) = v161;
            *(a2 - 5) = v173;
            *(_OWORD *)((char *)a2 - 20) = *(_OWORD *)&v208[12];
            *(a2 - 3) = v196;
            *(a2 - 2) = *(_OWORD *)v208;
            *(a2 - 4) = v184;
          }
          break;
        case 3uLL:
          sub_100C82F60(v10, v10 + 96, (uint64_t)(a2 - 6));
          break;
        case 4uLL:
          sub_100C8354C(v10, v10 + 96, v10 + 192, (uint64_t)(a2 - 6));
          break;
        case 5uLL:
          uint64_t v66 = (long long *)(v10 + 96);
          id v67 = (long long *)(v10 + 192);
          unint64_t v68 = (long long *)(v10 + 288);
          sub_100C8354C(v10, v10 + 96, v10 + 192, v10 + 288);
          if (*((double *)a2 - 11) < *(double *)(v10 + 296))
          {
            long long v185 = *(_OWORD *)(v10 + 320);
            long long v197 = *(_OWORD *)(v10 + 336);
            *(_OWORD *)uint64_t v209 = *(_OWORD *)(v10 + 352);
            *(_OWORD *)&v209[16] = *(_OWORD *)(v10 + 368);
            id v162 = *v68;
            uint64_t v174 = *(_OWORD *)(v10 + 304);
            long long v69 = *(a2 - 5);
            *unint64_t v68 = *(a2 - 6);
            *(_OWORD *)(v10 + 304) = v69;
            long long v71 = *(a2 - 3);
            long long v70 = *(a2 - 2);
            long long v72 = *(a2 - 4);
            *(_OWORD *)(v10 + 364) = *(_OWORD *)((char *)a2 - 20);
            *(_OWORD *)(v10 + 336) = v71;
            *(_OWORD *)(v10 + 352) = v70;
            *(_OWORD *)(v10 + 320) = v72;
            *(a2 - 6) = v162;
            *(a2 - 5) = v174;
            *(_OWORD *)((char *)a2 - 20) = *(_OWORD *)&v209[12];
            *(a2 - 3) = v197;
            *(a2 - 2) = *(_OWORD *)v209;
            *(a2 - 4) = v185;
            if (*(double *)(v10 + 296) < *(double *)(v10 + 200))
            {
              long long v186 = *(_OWORD *)(v10 + 224);
              long long v198 = *(_OWORD *)(v10 + 240);
              *(_OWORD *)int v210 = *(_OWORD *)(v10 + 256);
              *(_OWORD *)&v210[16] = *(_OWORD *)(v10 + 272);
              __int16 v163 = *v67;
              uint64_t v175 = *(_OWORD *)(v10 + 208);
              id v73 = *(_OWORD *)(v10 + 336);
              *(_OWORD *)(v10 + 224) = *(_OWORD *)(v10 + 320);
              *(_OWORD *)(v10 + 240) = v73;
              *(_OWORD *)(v10 + 256) = *(_OWORD *)(v10 + 352);
              *(_OWORD *)(v10 + 268) = *(_OWORD *)(v10 + 364);
              int v74 = *(_OWORD *)(v10 + 304);
              *id v67 = *v68;
              *(_OWORD *)(v10 + 208) = v74;
              *unint64_t v68 = v163;
              *(_OWORD *)(v10 + 304) = v175;
              *(_OWORD *)(v10 + 364) = *(_OWORD *)&v210[12];
              long long v75 = *(double *)(v10 + 200) < *(double *)(v10 + 104);
              *(_OWORD *)(v10 + 336) = v198;
              *(_OWORD *)(v10 + 352) = *(_OWORD *)v210;
              *(_OWORD *)(v10 + 320) = v186;
              if (v75)
              {
                long long v187 = *(_OWORD *)(v10 + 128);
                long long v199 = *(_OWORD *)(v10 + 144);
                *(_OWORD *)__int16 v211 = *(_OWORD *)(v10 + 160);
                *(_OWORD *)&v211[16] = *(_OWORD *)(v10 + 176);
                id v164 = *v66;
                double v176 = *(_OWORD *)(v10 + 112);
                uint64_t v76 = *(_OWORD *)(v10 + 240);
                *(_OWORD *)(v10 + 128) = *(_OWORD *)(v10 + 224);
                *(_OWORD *)(v10 + 144) = v76;
                *(_OWORD *)(v10 + 160) = *(_OWORD *)(v10 + 256);
                *(_OWORD *)(v10 + 172) = *(_OWORD *)(v10 + 268);
                id v77 = *(_OWORD *)(v10 + 208);
                *uint64_t v66 = *v67;
                *(_OWORD *)(v10 + 112) = v77;
                *id v67 = v164;
                *(_OWORD *)(v10 + 208) = v176;
                *(_OWORD *)(v10 + 268) = *(_OWORD *)&v211[12];
                long long v75 = *(double *)(v10 + 104) < *(double *)(v10 + 8);
                *(_OWORD *)(v10 + 240) = v199;
                *(_OWORD *)(v10 + 256) = *(_OWORD *)v211;
                *(_OWORD *)(v10 + 224) = v187;
                if (v75)
                {
                  __int16 v165 = *(_OWORD *)v10;
                  int v177 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)int v212 = *(_OWORD *)(v10 + 64);
                  *(_OWORD *)&v212[16] = *(_OWORD *)(v10 + 80);
                  std::string v188 = *(_OWORD *)(v10 + 32);
                  long long v200 = *(_OWORD *)(v10 + 48);
                  *(_OWORD *)(v10 + 76) = *(_OWORD *)(v10 + 172);
                  uint64_t v78 = *(_OWORD *)(v10 + 160);
                  __int16 v79 = *(_OWORD *)(v10 + 128);
                  *(_OWORD *)(v10 + 48) = *(_OWORD *)(v10 + 144);
                  *(_OWORD *)(v10 + 64) = v78;
                  uint64_t v80 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)unint64_t v10 = *v66;
                  *(_OWORD *)(v10 + 16) = v80;
                  *(_OWORD *)(v10 + 32) = v79;
                  *uint64_t v66 = v165;
                  *(_OWORD *)(v10 + 112) = v177;
                  *(_OWORD *)(v10 + 172) = *(_OWORD *)&v212[12];
                  *(_OWORD *)(v10 + 144) = v200;
                  *(_OWORD *)(v10 + 160) = *(_OWORD *)v212;
                  *(_OWORD *)(v10 + 128) = v188;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 2303) {
      break;
    }
    if (!a3)
    {
      if ((_OWORD *)v10 == a2) {
        return;
      }
      double v96 = (v12 - 2) >> 1;
      id v97 = v96;
      do
      {
        id v98 = v97;
        if (v96 >= v97)
        {
          int v99 = (2 * v97) | 1;
          int v100 = v10 + 96 * v99;
          if (2 * v98 + 2 < (uint64_t)v12 && *(double *)(v10 + 96 * v99 + 8) < *(double *)(v100 + 104))
          {
            v100 += 96;
            int v99 = 2 * v98 + 2;
          }
          uint64_t v101 = *(double *)(v10 + 96 * v98 + 8);
          if (*(double *)(v100 + 8) >= v101)
          {
            id v102 = v10 + 96 * v98;
            int64_t v103 = *(void *)v102;
            id v167 = *(_OWORD *)(v102 + 16);
            *(_OWORD *)double v202 = *(_OWORD *)(v102 + 64);
            *(_OWORD *)&v202[16] = *(_OWORD *)(v102 + 80);
            long long v178 = *(_OWORD *)(v102 + 32);
            long long v190 = *(_OWORD *)(v102 + 48);
            do
            {
              unint64_t v104 = (_OWORD *)v102;
              id v102 = v100;
              uint64_t v105 = *(_OWORD *)(v100 + 16);
              *unint64_t v104 = *(_OWORD *)v100;
              v104[1] = v105;
              unint64_t v106 = *(_OWORD *)(v100 + 32);
              uint64_t v107 = *(_OWORD *)(v100 + 48);
              id v108 = *(_OWORD *)(v100 + 64);
              *(_OWORD *)((char *)v104 + 76) = *(_OWORD *)(v100 + 76);
              v104[3] = v107;
              v104[4] = v108;
              v104[2] = v106;
              if (v96 < v99) {
                break;
              }
              uint64_t v109 = (2 * v99) | 1;
              int v100 = v10 + 96 * v109;
              uint64_t v110 = 2 * v99 + 2;
              if (v110 < (uint64_t)v12 && *(double *)(v10 + 96 * v109 + 8) < *(double *)(v100 + 104))
              {
                v100 += 96;
                uint64_t v109 = v110;
              }
              int v99 = v109;
            }
            while (*(double *)(v100 + 8) >= v101);
            *(void *)id v102 = v103;
            *(double *)(v102 + 8) = v101;
            *(_OWORD *)(v102 + 48) = v190;
            *(_OWORD *)(v102 + 64) = *(_OWORD *)v202;
            *(_OWORD *)(v102 + 76) = *(_OWORD *)&v202[12];
            *(_OWORD *)(v102 + 16) = v167;
            *(_OWORD *)(v102 + 32) = v178;
          }
        }
        id v97 = v98 - 1;
      }
      while (v98);
      long long v111 = v11 / 0x60uLL;
      while (2)
      {
        int v112 = 0;
        id v168 = *(_OWORD *)v10;
        long long v179 = *(_OWORD *)(v10 + 16);
        *(_OWORD *)double v213 = *(_OWORD *)(v10 + 64);
        *(_OWORD *)&v213[16] = *(_OWORD *)(v10 + 80);
        long long v191 = *(_OWORD *)(v10 + 32);
        __int16 v203 = *(_OWORD *)(v10 + 48);
        id v113 = v10;
        do
        {
          uint64_t v114 = (_OWORD *)v113;
          uint64_t v115 = v112 + 1;
          v113 += 96 * (v112 + 1);
          double v116 = 2 * v112;
          int v112 = (2 * v112) | 1;
          double v117 = v116 + 2;
          if (v117 < v111 && *((double *)&v114[6 * v115] + 1) < *(double *)(v113 + 104))
          {
            v113 += 96;
            int v112 = v117;
          }
          id v118 = *(_OWORD *)(v113 + 16);
          *uint64_t v114 = *(_OWORD *)v113;
          v114[1] = v118;
          id v119 = *(_OWORD *)(v113 + 32);
          unint64_t v120 = *(_OWORD *)(v113 + 48);
          unint64_t v121 = *(_OWORD *)(v113 + 64);
          *(_OWORD *)((char *)v114 + 76) = *(_OWORD *)(v113 + 76);
          v114[3] = v120;
          v114[4] = v121;
          v114[2] = v119;
        }
        while (v112 <= (uint64_t)((unint64_t)(v111 - 2) >> 1));
        a2 -= 6;
        if ((_OWORD *)v113 != a2)
        {
          double v122 = a2[1];
          *(_OWORD *)id v113 = *a2;
          *(_OWORD *)(v113 + 16) = v122;
          double v123 = a2[2];
          id v124 = a2[3];
          id v125 = a2[4];
          *(_OWORD *)(v113 + 76) = *(_OWORD *)((char *)a2 + 76);
          *(_OWORD *)(v113 + 48) = v124;
          *(_OWORD *)(v113 + 64) = v125;
          *(_OWORD *)(v113 + 32) = v123;
          *(_OWORD *)((char *)a2 + 76) = *(_OWORD *)&v213[12];
          a2[3] = v203;
          a2[4] = *(_OWORD *)v213;
          a2[2] = v191;
          *a2 = v168;
          a2[1] = v179;
          unint64_t v126 = v113 - v10 + 96;
          if (v126 >= 97)
          {
            uint64_t v127 = (v126 / 0x60uLL - 2) >> 1;
            id v128 = *(double *)(v113 + 8);
            if (*(double *)(v10 + 96 * v127 + 8) < v128)
            {
              uint64_t v129 = *(void *)v113;
              id v148 = *(_OWORD *)(v113 + 16);
              *(_OWORD *)uint64_t v157 = *(_OWORD *)(v113 + 64);
              *(_OWORD *)&v157[16] = *(_OWORD *)(v113 + 80);
              id v151 = *(_OWORD *)(v113 + 32);
              unint64_t v154 = *(_OWORD *)(v113 + 48);
              do
              {
                double v130 = (_OWORD *)v113;
                id v113 = v10 + 96 * v127;
                uint64_t v131 = *(_OWORD *)(v113 + 16);
                void *v130 = *(_OWORD *)v113;
                v130[1] = v131;
                id v132 = *(_OWORD *)(v113 + 32);
                uint64_t v133 = *(_OWORD *)(v113 + 48);
                uint64_t v134 = *(_OWORD *)(v113 + 64);
                *(_OWORD *)((char *)v130 + 76) = *(_OWORD *)(v113 + 76);
                v130[3] = v133;
                v130[4] = v134;
                v130[2] = v132;
                if (!v127) {
                  break;
                }
                uint64_t v127 = (v127 - 1) >> 1;
              }
              while (*(double *)(v10 + 96 * v127 + 8) < v128);
              *(void *)id v113 = v129;
              *(double *)(v113 + 8) = v128;
              *(_OWORD *)(v113 + 16) = v148;
              id v135 = v151;
              uint64_t v136 = v154;
              uint64_t v137 = *(_OWORD *)v157;
              uint64_t v138 = *(_OWORD *)&v157[12];
LABEL_117:
              *(_OWORD *)(v113 + 76) = v138;
              *(_OWORD *)(v113 + 48) = v136;
              *(_OWORD *)(v113 + 64) = v137;
              *(_OWORD *)(v113 + 32) = v135;
            }
          }
          if (v111-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)id v113 = v168;
      *(_OWORD *)(v113 + 16) = v179;
      id v135 = v191;
      uint64_t v136 = v203;
      uint64_t v137 = *(_OWORD *)v213;
      uint64_t v138 = *(_OWORD *)&v213[12];
      goto LABEL_117;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (_OWORD *)(v10 + 96 * (v12 >> 1));
    if ((unint64_t)v11 > 0x3000)
    {
      sub_100C82F60(a1, a1 + 96 * (v12 >> 1), (uint64_t)(a2 - 6));
      unint64_t v15 = 3 * v13;
      unint64_t v16 = a1 + 96 * v13 - 96;
      sub_100C82F60(a1 + 96, v16, (uint64_t)(a2 - 12));
      id v17 = a1 + 96 + 32 * v15;
      sub_100C82F60(a1 + 192, v17, (uint64_t)(a2 - 18));
      sub_100C82F60(v16, (uint64_t)v14, v17);
      unint64_t v158 = *(_OWORD *)a1;
      double v170 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)unint64_t v205 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v205[16] = *(_OWORD *)(a1 + 80);
      long long v181 = *(_OWORD *)(a1 + 32);
      long long v193 = *(_OWORD *)(a1 + 48);
      long long v19 = v14[3];
      uint64_t v18 = v14[4];
      float v20 = v14[2];
      *(_OWORD *)(a1 + 76) = *(_OWORD *)((char *)v14 + 76);
      *(_OWORD *)(a1 + 48) = v19;
      *(_OWORD *)(a1 + 64) = v18;
      *(_OWORD *)(a1 + 32) = v20;
      float v21 = v14[1];
      *(_OWORD *)a1 = *v14;
      *(_OWORD *)(a1 + 16) = v21;
      *uint64_t v14 = v158;
      v14[1] = v170;
      *(_OWORD *)((char *)v14 + 76) = *(_OWORD *)&v205[12];
      v14[3] = v193;
      v14[4] = *(_OWORD *)v205;
      int v14[2] = v181;
    }
    else
    {
      sub_100C82F60(a1 + 96 * (v12 >> 1), a1, (uint64_t)(a2 - 6));
    }
    --a3;
    if (a4)
    {
      double v22 = *(double *)(a1 + 8);
LABEL_12:
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)a1;
      *(_OWORD *)int v155 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v155[16] = *(_OWORD *)(a1 + 80);
      id v149 = *(_OWORD *)(a1 + 32);
      double v152 = *(_OWORD *)(a1 + 48);
      std::string::size_type v146 = *(_OWORD *)(a1 + 16);
      do
      {
        unint64_t v25 = *(double *)(a1 + v23 + 104);
        v23 += 96;
      }
      while (v25 < v22);
      char v26 = a1 + v23;
      BOOL v27 = (double *)a2;
      if (v23 == 96)
      {
        uint64_t v30 = (double *)a2;
        while (v26 < (unint64_t)v30)
        {
          uint64_t v28 = v30 - 12;
          double v31 = *(v30 - 11);
          v30 -= 12;
          if (v31 < v22) {
            goto LABEL_22;
          }
        }
        uint64_t v28 = v30;
      }
      else
      {
        do
        {
          uint64_t v28 = v27 - 12;
          uint64_t v29 = *(v27 - 11);
          v27 -= 12;
        }
        while (v29 >= v22);
      }
LABEL_22:
      unint64_t v10 = v26;
      if (v26 < (unint64_t)v28)
      {
        id v32 = v28;
        do
        {
          id v159 = *(_OWORD *)v10;
          __int16 v171 = *(_OWORD *)(v10 + 16);
          *(_OWORD *)__int16 v206 = *(_OWORD *)(v10 + 64);
          *(_OWORD *)&v206[16] = *(_OWORD *)(v10 + 80);
          long long v182 = *(_OWORD *)(v10 + 32);
          long long v194 = *(_OWORD *)(v10 + 48);
          uint64_t v34 = *((_OWORD *)v32 + 3);
          unsigned __int8 v33 = *((_OWORD *)v32 + 4);
          uint64_t v35 = *((_OWORD *)v32 + 2);
          *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)v32 + 76);
          *(_OWORD *)(v10 + 48) = v34;
          *(_OWORD *)(v10 + 64) = v33;
          *(_OWORD *)(v10 + 32) = v35;
          id v36 = *((_OWORD *)v32 + 1);
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v32;
          *(_OWORD *)(v10 + 16) = v36;
          *(_OWORD *)id v32 = v159;
          *((_OWORD *)v32 + 1) = v171;
          *(_OWORD *)((char *)v32 + 76) = *(_OWORD *)&v206[12];
          *((_OWORD *)v32 + 3) = v194;
          *((_OWORD *)v32 + 4) = *(_OWORD *)v206;
          *((_OWORD *)v32 + 2) = v182;
          do
          {
            unsigned __int8 v37 = *(double *)(v10 + 104);
            v10 += 96;
          }
          while (v37 < v22);
          do
          {
            uint64_t v38 = *(v32 - 11);
            v32 -= 12;
          }
          while (v38 >= v22);
        }
        while (v10 < (unint64_t)v32);
      }
      if (v10 - 96 != a1)
      {
        uint64_t v39 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 16) = v39;
        uint64_t v40 = *(_OWORD *)(v10 - 64);
        id v41 = *(_OWORD *)(v10 - 48);
        unsigned __int8 v42 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 76) = *(_OWORD *)(v10 - 20);
        *(_OWORD *)(a1 + 48) = v41;
        *(_OWORD *)(a1 + 64) = v42;
        *(_OWORD *)(a1 + 32) = v40;
      }
      *(void *)(v10 - 96) = v24;
      *(double *)(v10 - 88) = v22;
      *(_OWORD *)(v10 - 80) = v146;
      *(_OWORD *)(v10 - 20) = *(_OWORD *)&v155[12];
      *(_OWORD *)(v10 - 48) = v152;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v155;
      *(_OWORD *)(v10 - 64) = v149;
      if (v26 < (unint64_t)v28) {
        goto LABEL_33;
      }
      unint64_t v43 = sub_101573EEC(a1, v10 - 96);
      if (sub_101573EEC(v10, (uint64_t)a2))
      {
        a2 = (_OWORD *)(v10 - 96);
        if (v43) {
          return;
        }
        goto LABEL_1;
      }
      if (!v43)
      {
LABEL_33:
        sub_1015732D0(a1, v10 - 96, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      double v22 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 88) < v22) {
        goto LABEL_12;
      }
      unint64_t v44 = *(void *)a1;
      *(_OWORD *)id v156 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v156[16] = *(_OWORD *)(a1 + 80);
      id v150 = *(_OWORD *)(a1 + 32);
      id v153 = *(_OWORD *)(a1 + 48);
      __int16 v147 = *(_OWORD *)(a1 + 16);
      if (v22 >= *((double *)a2 - 11))
      {
        uint64_t v47 = a1 + 96;
        do
        {
          unint64_t v10 = v47;
          if (v47 >= (unint64_t)a2) {
            break;
          }
          uint64_t v48 = *(double *)(v47 + 8);
          v47 += 96;
        }
        while (v22 >= v48);
      }
      else
      {
        id v45 = a1;
        do
        {
          unint64_t v10 = v45 + 96;
          id v46 = *(double *)(v45 + 104);
          v45 += 96;
        }
        while (v22 >= v46);
      }
      uint64_t v49 = (double *)a2;
      if (v10 < (unint64_t)a2)
      {
        uint64_t v50 = (double *)a2;
        do
        {
          uint64_t v49 = v50 - 12;
          uint64_t v51 = *(v50 - 11);
          v50 -= 12;
        }
        while (v22 < v51);
      }
      while (v10 < (unint64_t)v49)
      {
        id v160 = *(_OWORD *)v10;
        int v172 = *(_OWORD *)(v10 + 16);
        *(_OWORD *)double v207 = *(_OWORD *)(v10 + 64);
        *(_OWORD *)&v207[16] = *(_OWORD *)(v10 + 80);
        unint64_t v183 = *(_OWORD *)(v10 + 32);
        long long v195 = *(_OWORD *)(v10 + 48);
        uint64_t v53 = *((_OWORD *)v49 + 3);
        uint64_t v52 = *((_OWORD *)v49 + 4);
        unint64_t v54 = *((_OWORD *)v49 + 2);
        *(_OWORD *)(v10 + 76) = *(_OWORD *)((char *)v49 + 76);
        *(_OWORD *)(v10 + 48) = v53;
        *(_OWORD *)(v10 + 64) = v52;
        *(_OWORD *)(v10 + 32) = v54;
        id v55 = *((_OWORD *)v49 + 1);
        *(_OWORD *)unint64_t v10 = *(_OWORD *)v49;
        *(_OWORD *)(v10 + 16) = v55;
        *(_OWORD *)uint64_t v49 = v160;
        *((_OWORD *)v49 + 1) = v172;
        *(_OWORD *)((char *)v49 + 76) = *(_OWORD *)&v207[12];
        *((_OWORD *)v49 + 3) = v195;
        *((_OWORD *)v49 + 4) = *(_OWORD *)v207;
        *((_OWORD *)v49 + 2) = v183;
        do
        {
          id v56 = *(double *)(v10 + 104);
          v10 += 96;
        }
        while (v22 >= v56);
        do
        {
          id v57 = *(v49 - 11);
          v49 -= 12;
        }
        while (v22 < v57);
      }
      unint64_t v4 = v10 - 96 >= a1;
      char v5 = v10 - 96 == a1;
      if (v10 - 96 != a1)
      {
        id v58 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 16) = v58;
        id v59 = *(_OWORD *)(v10 - 64);
        double v60 = *(_OWORD *)(v10 - 48);
        id v61 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 76) = *(_OWORD *)(v10 - 20);
        *(_OWORD *)(a1 + 48) = v60;
        *(_OWORD *)(a1 + 64) = v61;
        *(_OWORD *)(a1 + 32) = v59;
      }
      a4 = 0;
      *(void *)(v10 - 96) = v44;
      *(double *)(v10 - 88) = v22;
      *(_OWORD *)(v10 - 80) = v147;
      *(_OWORD *)(v10 - 20) = *(_OWORD *)&v156[12];
      *(_OWORD *)(v10 - 48) = v153;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v156;
      *(_OWORD *)(v10 - 64) = v150;
    }
  }
  __int16 v81 = (_OWORD *)(v10 + 96);
  __int16 v83 = (_OWORD *)v10 == a2 || v81 == a2;
  if (a4)
  {
    if (!v83)
    {
      uint64_t v84 = 0;
      __int16 v85 = v10;
      do
      {
        double v86 = v81;
        uint64_t v87 = *(double *)(v85 + 104);
        if (v87 < *(double *)(v85 + 8))
        {
          double v88 = *(void *)v81;
          float v189 = *(_OWORD *)(v85 + 144);
          *(_OWORD *)double v201 = *(_OWORD *)(v85 + 160);
          *(_OWORD *)&v201[16] = *(_OWORD *)(v85 + 176);
          uint64_t v90 = *(_OWORD *)(v85 + 112);
          __int16 v89 = *(_OWORD *)(v85 + 128);
          __int16 v91 = v84;
          double v166 = v90;
          while (1)
          {
            unint64_t v92 = (_OWORD *)(v10 + v91);
            __int16 v93 = *(_OWORD *)(v10 + v91 + 48);
            v92[8] = *(_OWORD *)(v10 + v91 + 32);
            v92[9] = v93;
            v92[10] = *(_OWORD *)(v10 + v91 + 64);
            *(_OWORD *)((char *)v92 + 172) = *(_OWORD *)(v10 + v91 + 76);
            uint64_t v94 = *(_OWORD *)(v10 + v91 + 16);
            v92[6] = *(_OWORD *)(v10 + v91);
            v92[7] = v94;
            if (!v91) {
              break;
            }
            v91 -= 96;
            if (v87 >= *((double *)v92 - 11))
            {
              __int16 v95 = v10 + v91 + 96;
              goto LABEL_85;
            }
          }
          __int16 v95 = v10;
LABEL_85:
          *(void *)__int16 v95 = v88;
          *(double *)(v95 + 8) = v87;
          *(_OWORD *)(v95 + 48) = v189;
          *(_OWORD *)(v95 + 64) = *(_OWORD *)v201;
          *(_OWORD *)(v95 + 76) = *(_OWORD *)&v201[12];
          *(_OWORD *)(v95 + 16) = v166;
          *(_OWORD *)(v95 + 32) = v89;
        }
        __int16 v81 = v86 + 6;
        v84 += 96;
        __int16 v85 = (unint64_t)v86;
      }
      while (v86 + 6 != a2);
    }
  }
  else if (!v83)
  {
    do
    {
      id v140 = (unint64_t)v81;
      unint64_t v141 = *(double *)(a1 + 104);
      if (v141 < *(double *)(a1 + 8))
      {
        unint64_t v142 = *(void *)v81;
        unint64_t v192 = *(_OWORD *)(a1 + 144);
        *(_OWORD *)__int16 v204 = *(_OWORD *)(a1 + 160);
        *(_OWORD *)&v204[16] = *(_OWORD *)(a1 + 176);
        __int16 v169 = *(_OWORD *)(a1 + 112);
        long long v180 = *(_OWORD *)(a1 + 128);
        do
        {
          id v143 = *(v81 - 3);
          v81[2] = *(v81 - 4);
          v81[3] = v143;
          v81[4] = *(v81 - 2);
          *(_OWORD *)((char *)v81 + 76) = *(_OWORD *)((char *)v81 - 20);
          std::string::size_type v144 = *(v81 - 5);
          *__int16 v81 = *(v81 - 6);
          v81[1] = v144;
          uint64_t v145 = *((double *)v81 - 23);
          v81 -= 6;
        }
        while (v141 < v145);
        *(void *)__int16 v81 = v142;
        *((double *)v81 + 1) = v141;
        v81[1] = v169;
        *(_OWORD *)((char *)v81 + 76) = *(_OWORD *)&v204[12];
        v81[3] = v192;
        v81[4] = *(_OWORD *)v204;
        v81[2] = v180;
      }
      __int16 v81 = (_OWORD *)(v140 + 96);
      a1 = v140;
    }
    while ((_OWORD *)(v140 + 96) != a2);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v10) >> 5);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 27) < *(double *)(v10 + 8))
          {
            double v272 = *(_OWORD *)v10;
            uint64_t v284 = *(_OWORD *)(v10 + 16);
            v319 = *(_OWORD *)(v10 + 64);
            v331 = *(_OWORD *)(v10 + 80);
            v295 = *(_OWORD *)(v10 + 32);
            v307 = *(_OWORD *)(v10 + 48);
            v367 = *(_OWORD *)(v10 + 128);
            v379 = *(_OWORD *)(v10 + 144);
            v343 = *(_OWORD *)(v10 + 96);
            v355 = *(_OWORD *)(v10 + 112);
            *(_OWORD *)v415 = *(_OWORD *)(v10 + 192);
            *(_OWORD *)&v415[16] = *(_OWORD *)(v10 + 208);
            v391 = *(_OWORD *)(v10 + 160);
            v403 = *(_OWORD *)(v10 + 176);
            unint64_t v92 = *(a2 - 13);
            *(_OWORD *)unint64_t v10 = *(a2 - 14);
            *(_OWORD *)(v10 + 16) = v92;
            __int16 v93 = *(a2 - 12);
            uint64_t v94 = *(a2 - 11);
            __int16 v95 = *(a2 - 9);
            *(_OWORD *)(v10 + 64) = *(a2 - 10);
            *(_OWORD *)(v10 + 80) = v95;
            *(_OWORD *)(v10 + 32) = v93;
            *(_OWORD *)(v10 + 48) = v94;
            double v96 = *(a2 - 8);
            id v97 = *(a2 - 7);
            id v98 = *(a2 - 5);
            *(_OWORD *)(v10 + 128) = *(a2 - 6);
            *(_OWORD *)(v10 + 144) = v98;
            *(_OWORD *)(v10 + 96) = v96;
            *(_OWORD *)(v10 + 112) = v97;
            int v99 = *(a2 - 4);
            int v100 = *(a2 - 3);
            uint64_t v101 = *(a2 - 2);
            *(_OWORD *)(v10 + 205) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 176) = v100;
            *(_OWORD *)(v10 + 192) = v101;
            *(_OWORD *)(v10 + 160) = v99;
            *(a2 - 14) = v272;
            *(a2 - 13) = v284;
            *(a2 - 10) = v319;
            *(a2 - 9) = v331;
            *(a2 - 12) = v295;
            *(a2 - 11) = v307;
            *(a2 - 6) = v367;
            *(a2 - 5) = v379;
            *(a2 - 8) = v343;
            *(a2 - 7) = v355;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v415[13];
            *(a2 - 3) = v403;
            *(a2 - 2) = *(_OWORD *)v415;
            *(a2 - 4) = v391;
          }
          break;
        case 3uLL:
          sub_1015A0F44((long long *)v10, (long long *)(v10 + 224), a2 - 14);
          break;
        case 4uLL:
          sub_1015A1948(v10, v10 + 224, v10 + 448, (uint64_t)(a2 - 14));
          break;
        case 5uLL:
          id v102 = (long long *)(v10 + 224);
          int64_t v103 = (long long *)(v10 + 448);
          unint64_t v104 = (long long *)(v10 + 672);
          sub_1015A1948(v10, v10 + 224, v10 + 448, v10 + 672);
          if (*((double *)a2 - 27) < *(double *)(v10 + 680))
          {
            v320 = *(_OWORD *)(v10 + 736);
            v332 = *(_OWORD *)(v10 + 752);
            v296 = *(_OWORD *)(v10 + 704);
            v308 = *(_OWORD *)(v10 + 720);
            v368 = *(_OWORD *)(v10 + 800);
            v380 = *(_OWORD *)(v10 + 816);
            v344 = *(_OWORD *)(v10 + 768);
            v356 = *(_OWORD *)(v10 + 784);
            *(_OWORD *)v416 = *(_OWORD *)(v10 + 864);
            *(_OWORD *)&v416[16] = *(_OWORD *)(v10 + 880);
            v392 = *(_OWORD *)(v10 + 832);
            v404 = *(_OWORD *)(v10 + 848);
            uint64_t v273 = *v104;
            __int16 v285 = *(_OWORD *)(v10 + 688);
            uint64_t v105 = *(a2 - 13);
            *unint64_t v104 = *(a2 - 14);
            *(_OWORD *)(v10 + 688) = v105;
            unint64_t v106 = *(a2 - 12);
            uint64_t v107 = *(a2 - 11);
            id v108 = *(a2 - 9);
            *(_OWORD *)(v10 + 736) = *(a2 - 10);
            *(_OWORD *)(v10 + 752) = v108;
            *(_OWORD *)(v10 + 704) = v106;
            *(_OWORD *)(v10 + 720) = v107;
            uint64_t v109 = *(a2 - 8);
            uint64_t v110 = *(a2 - 7);
            long long v111 = *(a2 - 5);
            *(_OWORD *)(v10 + 800) = *(a2 - 6);
            *(_OWORD *)(v10 + 816) = v111;
            *(_OWORD *)(v10 + 768) = v109;
            *(_OWORD *)(v10 + 784) = v110;
            int v112 = *(a2 - 4);
            id v113 = *(a2 - 3);
            uint64_t v114 = *(a2 - 2);
            *(_OWORD *)(v10 + 877) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 848) = v113;
            *(_OWORD *)(v10 + 864) = v114;
            *(_OWORD *)(v10 + 832) = v112;
            *(a2 - 14) = v273;
            *(a2 - 13) = v285;
            *(a2 - 10) = v320;
            *(a2 - 9) = v332;
            *(a2 - 12) = v296;
            *(a2 - 11) = v308;
            *(a2 - 6) = v368;
            *(a2 - 5) = v380;
            *(a2 - 8) = v344;
            *(a2 - 7) = v356;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v416[13];
            *(a2 - 3) = v404;
            *(a2 - 2) = *(_OWORD *)v416;
            *(a2 - 4) = v392;
            if (*(double *)(v10 + 680) < *(double *)(v10 + 456))
            {
              v393 = *(_OWORD *)(v10 + 608);
              v405 = *(_OWORD *)(v10 + 624);
              *(_OWORD *)v417 = *(_OWORD *)(v10 + 640);
              *(_OWORD *)&v417[16] = *(_OWORD *)(v10 + 656);
              v345 = *(_OWORD *)(v10 + 544);
              v357 = *(_OWORD *)(v10 + 560);
              v369 = *(_OWORD *)(v10 + 576);
              v381 = *(_OWORD *)(v10 + 592);
              uint64_t v297 = *(_OWORD *)(v10 + 480);
              v309 = *(_OWORD *)(v10 + 496);
              v321 = *(_OWORD *)(v10 + 512);
              v333 = *(_OWORD *)(v10 + 528);
              uint64_t v274 = *v103;
              int v286 = *(_OWORD *)(v10 + 464);
              uint64_t v115 = *(_OWORD *)(v10 + 848);
              *(_OWORD *)(v10 + 608) = *(_OWORD *)(v10 + 832);
              *(_OWORD *)(v10 + 624) = v115;
              *(_OWORD *)(v10 + 640) = *(_OWORD *)(v10 + 864);
              *(_OWORD *)(v10 + 653) = *(_OWORD *)(v10 + 877);
              double v116 = *(_OWORD *)(v10 + 784);
              *(_OWORD *)(v10 + 544) = *(_OWORD *)(v10 + 768);
              *(_OWORD *)(v10 + 560) = v116;
              double v117 = *(_OWORD *)(v10 + 816);
              *(_OWORD *)(v10 + 576) = *(_OWORD *)(v10 + 800);
              *(_OWORD *)(v10 + 592) = v117;
              id v118 = *(_OWORD *)(v10 + 720);
              *(_OWORD *)(v10 + 480) = *(_OWORD *)(v10 + 704);
              *(_OWORD *)(v10 + 496) = v118;
              id v119 = *(_OWORD *)(v10 + 752);
              *(_OWORD *)(v10 + 512) = *(_OWORD *)(v10 + 736);
              *(_OWORD *)(v10 + 528) = v119;
              unint64_t v120 = *(_OWORD *)(v10 + 688);
              NSObject *v103 = *v104;
              *(_OWORD *)(v10 + 464) = v120;
              *(_OWORD *)(v10 + 832) = v393;
              *(_OWORD *)(v10 + 848) = v405;
              *(_OWORD *)(v10 + 864) = *(_OWORD *)v417;
              *(_OWORD *)(v10 + 877) = *(_OWORD *)&v417[13];
              *(_OWORD *)(v10 + 768) = v345;
              *(_OWORD *)(v10 + 784) = v357;
              *(_OWORD *)(v10 + 800) = v369;
              *(_OWORD *)(v10 + 816) = v381;
              *(_OWORD *)(v10 + 704) = v297;
              *(_OWORD *)(v10 + 720) = v309;
              *(_OWORD *)(v10 + 736) = v321;
              *(_OWORD *)(v10 + 752) = v333;
              unint64_t v121 = *(double *)(v10 + 456) < *(double *)(v10 + 232);
              *unint64_t v104 = v274;
              *(_OWORD *)(v10 + 688) = v286;
              if (v121)
              {
                v394 = *(_OWORD *)(v10 + 384);
                v406 = *(_OWORD *)(v10 + 400);
                *(_OWORD *)v418 = *(_OWORD *)(v10 + 416);
                *(_OWORD *)&v418[16] = *(_OWORD *)(v10 + 432);
                v346 = *(_OWORD *)(v10 + 320);
                v358 = *(_OWORD *)(v10 + 336);
                v370 = *(_OWORD *)(v10 + 352);
                v382 = *(_OWORD *)(v10 + 368);
                uint64_t v298 = *(_OWORD *)(v10 + 256);
                v310 = *(_OWORD *)(v10 + 272);
                v322 = *(_OWORD *)(v10 + 288);
                v334 = *(_OWORD *)(v10 + 304);
                uint64_t v275 = *v102;
                __int16 v287 = *(_OWORD *)(v10 + 240);
                double v122 = *(_OWORD *)(v10 + 624);
                *(_OWORD *)(v10 + 384) = *(_OWORD *)(v10 + 608);
                *(_OWORD *)(v10 + 400) = v122;
                *(_OWORD *)(v10 + 416) = *(_OWORD *)(v10 + 640);
                *(_OWORD *)(v10 + 429) = *(_OWORD *)(v10 + 653);
                double v123 = *(_OWORD *)(v10 + 560);
                *(_OWORD *)(v10 + 320) = *(_OWORD *)(v10 + 544);
                *(_OWORD *)(v10 + 336) = v123;
                id v124 = *(_OWORD *)(v10 + 592);
                *(_OWORD *)(v10 + 352) = *(_OWORD *)(v10 + 576);
                *(_OWORD *)(v10 + 368) = v124;
                id v125 = *(_OWORD *)(v10 + 496);
                *(_OWORD *)(v10 + 256) = *(_OWORD *)(v10 + 480);
                *(_OWORD *)(v10 + 272) = v125;
                unint64_t v126 = *(_OWORD *)(v10 + 528);
                *(_OWORD *)(v10 + 288) = *(_OWORD *)(v10 + 512);
                *(_OWORD *)(v10 + 304) = v126;
                uint64_t v127 = *(_OWORD *)(v10 + 464);
                char *v102 = *v103;
                *(_OWORD *)(v10 + 240) = v127;
                *(_OWORD *)(v10 + 608) = v394;
                *(_OWORD *)(v10 + 624) = v406;
                *(_OWORD *)(v10 + 640) = *(_OWORD *)v418;
                *(_OWORD *)(v10 + 653) = *(_OWORD *)&v418[13];
                *(_OWORD *)(v10 + 544) = v346;
                *(_OWORD *)(v10 + 560) = v358;
                *(_OWORD *)(v10 + 576) = v370;
                *(_OWORD *)(v10 + 592) = v382;
                *(_OWORD *)(v10 + 480) = v298;
                *(_OWORD *)(v10 + 496) = v310;
                *(_OWORD *)(v10 + 512) = v322;
                *(_OWORD *)(v10 + 528) = v334;
                unint64_t v121 = *(double *)(v10 + 232) < *(double *)(v10 + 8);
                NSObject *v103 = v275;
                *(_OWORD *)(v10 + 464) = v287;
                if (v121)
                {
                  v276 = *(_OWORD *)v10;
                  v288 = *(_OWORD *)(v10 + 16);
                  v323 = *(_OWORD *)(v10 + 64);
                  v335 = *(_OWORD *)(v10 + 80);
                  v299 = *(_OWORD *)(v10 + 32);
                  v311 = *(_OWORD *)(v10 + 48);
                  v371 = *(_OWORD *)(v10 + 128);
                  v383 = *(_OWORD *)(v10 + 144);
                  v347 = *(_OWORD *)(v10 + 96);
                  v359 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)v419 = *(_OWORD *)(v10 + 192);
                  *(_OWORD *)&v419[16] = *(_OWORD *)(v10 + 208);
                  v395 = *(_OWORD *)(v10 + 160);
                  v407 = *(_OWORD *)(v10 + 176);
                  id v128 = *(_OWORD *)(v10 + 304);
                  *(_OWORD *)(v10 + 64) = *(_OWORD *)(v10 + 288);
                  *(_OWORD *)(v10 + 80) = v128;
                  uint64_t v129 = *(_OWORD *)(v10 + 272);
                  *(_OWORD *)(v10 + 32) = *(_OWORD *)(v10 + 256);
                  *(_OWORD *)(v10 + 48) = v129;
                  double v130 = *(_OWORD *)(v10 + 368);
                  *(_OWORD *)(v10 + 128) = *(_OWORD *)(v10 + 352);
                  *(_OWORD *)(v10 + 144) = v130;
                  uint64_t v131 = *(_OWORD *)(v10 + 336);
                  *(_OWORD *)(v10 + 96) = *(_OWORD *)(v10 + 320);
                  *(_OWORD *)(v10 + 112) = v131;
                  *(_OWORD *)(v10 + 205) = *(_OWORD *)(v10 + 429);
                  id v132 = *(_OWORD *)(v10 + 416);
                  uint64_t v133 = *(_OWORD *)(v10 + 384);
                  *(_OWORD *)(v10 + 176) = *(_OWORD *)(v10 + 400);
                  *(_OWORD *)(v10 + 192) = v132;
                  *(_OWORD *)(v10 + 160) = v133;
                  uint64_t v134 = *(_OWORD *)(v10 + 240);
                  *(_OWORD *)unint64_t v10 = *v102;
                  *(_OWORD *)(v10 + 16) = v134;
                  *(_OWORD *)(v10 + 384) = v395;
                  *(_OWORD *)(v10 + 400) = v407;
                  *(_OWORD *)(v10 + 416) = *(_OWORD *)v419;
                  *(_OWORD *)(v10 + 429) = *(_OWORD *)&v419[13];
                  *(_OWORD *)(v10 + 320) = v347;
                  *(_OWORD *)(v10 + 336) = v359;
                  *(_OWORD *)(v10 + 352) = v371;
                  *(_OWORD *)(v10 + 368) = v383;
                  *(_OWORD *)(v10 + 256) = v299;
                  *(_OWORD *)(v10 + 272) = v311;
                  *(_OWORD *)(v10 + 288) = v323;
                  *(_OWORD *)(v10 + 304) = v335;
                  char *v102 = v276;
                  *(_OWORD *)(v10 + 240) = v288;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5375) {
      break;
    }
    if (!a3)
    {
      if ((long long *)v10 == a2) {
        return;
      }
      unint64_t v154 = (v12 - 2) >> 1;
      int v155 = v154;
      do
      {
        id v156 = v155;
        if (v154 >= v155)
        {
          uint64_t v157 = (2 * v155) | 1;
          unint64_t v158 = v10 + 224 * v157;
          if (2 * v155 + 2 < (uint64_t)v12 && *(double *)(v10 + 224 * v157 + 8) < *(double *)(v158 + 232))
          {
            v158 += 224;
            uint64_t v157 = 2 * v155 + 2;
          }
          id v159 = *(double *)(v10 + 224 * v155 + 8);
          if (*(double *)(v158 + 8) >= v159)
          {
            id v160 = v10 + 224 * v155;
            id v161 = *(void *)v160;
            v278 = *(_OWORD *)(v160 + 16);
            v313 = *(_OWORD *)(v160 + 64);
            v325 = *(_OWORD *)(v160 + 80);
            __int16 v289 = *(_OWORD *)(v160 + 32);
            v301 = *(_OWORD *)(v160 + 48);
            v361 = *(_OWORD *)(v160 + 128);
            v373 = *(_OWORD *)(v160 + 144);
            v337 = *(_OWORD *)(v160 + 96);
            v349 = *(_OWORD *)(v160 + 112);
            *(_OWORD *)v409 = *(_OWORD *)(v160 + 192);
            *(_OWORD *)&v409[16] = *(_OWORD *)(v160 + 208);
            v385 = *(_OWORD *)(v160 + 160);
            v397 = *(_OWORD *)(v160 + 176);
            do
            {
              id v162 = (_OWORD *)v160;
              id v160 = v158;
              __int16 v163 = *(_OWORD *)(v158 + 16);
              *id v162 = *(_OWORD *)v158;
              v162[1] = v163;
              id v164 = *(_OWORD *)(v158 + 32);
              __int16 v165 = *(_OWORD *)(v158 + 48);
              double v166 = *(_OWORD *)(v158 + 80);
              v162[4] = *(_OWORD *)(v158 + 64);
              v162[5] = v166;
              v162[2] = v164;
              v162[3] = v165;
              id v167 = *(_OWORD *)(v158 + 96);
              id v168 = *(_OWORD *)(v158 + 112);
              __int16 v169 = *(_OWORD *)(v158 + 144);
              v162[8] = *(_OWORD *)(v158 + 128);
              v162[9] = v169;
              v162[6] = v167;
              v162[7] = v168;
              double v170 = *(_OWORD *)(v158 + 160);
              __int16 v171 = *(_OWORD *)(v158 + 176);
              int v172 = *(_OWORD *)(v158 + 192);
              *(_OWORD *)((char *)v162 + 205) = *(_OWORD *)(v158 + 205);
              v162[11] = v171;
              v162[12] = v172;
              v162[10] = v170;
              if (v154 < v157) {
                break;
              }
              __int16 v173 = (2 * v157) | 1;
              unint64_t v158 = v10 + 224 * v173;
              uint64_t v174 = 2 * v157 + 2;
              if (v174 < (uint64_t)v12 && *(double *)(v10 + 224 * v173 + 8) < *(double *)(v158 + 232))
              {
                v158 += 224;
                __int16 v173 = v174;
              }
              uint64_t v157 = v173;
            }
            while (*(double *)(v158 + 8) >= v159);
            *(void *)id v160 = v161;
            *(double *)(v160 + 8) = v159;
            *(_OWORD *)(v160 + 176) = v397;
            *(_OWORD *)(v160 + 192) = *(_OWORD *)v409;
            *(_OWORD *)(v160 + 205) = *(_OWORD *)&v409[13];
            *(_OWORD *)(v160 + 112) = v349;
            *(_OWORD *)(v160 + 128) = v361;
            *(_OWORD *)(v160 + 144) = v373;
            *(_OWORD *)(v160 + 160) = v385;
            *(_OWORD *)(v160 + 48) = v301;
            *(_OWORD *)(v160 + 64) = v313;
            *(_OWORD *)(v160 + 80) = v325;
            *(_OWORD *)(v160 + 96) = v337;
            *(_OWORD *)(v160 + 16) = v278;
            *(_OWORD *)(v160 + 32) = v289;
          }
        }
        int v155 = v156 - 1;
      }
      while (v156);
      uint64_t v175 = (((unint64_t)v11 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      while (2)
      {
        double v176 = 0;
        char v279 = *(_OWORD *)v10;
        int v290 = *(_OWORD *)(v10 + 16);
        v326 = *(_OWORD *)(v10 + 64);
        v338 = *(_OWORD *)(v10 + 80);
        id v302 = *(_OWORD *)(v10 + 32);
        v314 = *(_OWORD *)(v10 + 48);
        v374 = *(_OWORD *)(v10 + 128);
        v386 = *(_OWORD *)(v10 + 144);
        v350 = *(_OWORD *)(v10 + 96);
        v362 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v420 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v420[16] = *(_OWORD *)(v10 + 208);
        v398 = *(_OWORD *)(v10 + 160);
        v410 = *(_OWORD *)(v10 + 176);
        int v177 = v10;
        do
        {
          long long v178 = (_OWORD *)v177;
          long long v179 = v176 + 1;
          v177 += 224 * (v176 + 1);
          long long v180 = 2 * v176;
          double v176 = (2 * v176) | 1;
          long long v181 = v180 + 2;
          if (v181 < v175 && *((double *)&v178[14 * v179] + 1) < *(double *)(v177 + 232))
          {
            v177 += 224;
            double v176 = v181;
          }
          long long v182 = *(_OWORD *)(v177 + 16);
          void *v178 = *(_OWORD *)v177;
          v178[1] = v182;
          unint64_t v183 = *(_OWORD *)(v177 + 32);
          long long v184 = *(_OWORD *)(v177 + 48);
          long long v185 = *(_OWORD *)(v177 + 80);
          v178[4] = *(_OWORD *)(v177 + 64);
          v178[5] = v185;
          v178[2] = v183;
          v178[3] = v184;
          long long v186 = *(_OWORD *)(v177 + 96);
          long long v187 = *(_OWORD *)(v177 + 112);
          std::string v188 = *(_OWORD *)(v177 + 144);
          v178[8] = *(_OWORD *)(v177 + 128);
          v178[9] = v188;
          v178[6] = v186;
          v178[7] = v187;
          float v189 = *(_OWORD *)(v177 + 160);
          long long v190 = *(_OWORD *)(v177 + 176);
          long long v191 = *(_OWORD *)(v177 + 192);
          *(_OWORD *)((char *)v178 + 205) = *(_OWORD *)(v177 + 205);
          v178[11] = v190;
          v178[12] = v191;
          v178[10] = v189;
        }
        while (v176 <= (uint64_t)((unint64_t)(v175 - 2) >> 1));
        a2 -= 14;
        if ((long long *)v177 != a2)
        {
          unint64_t v192 = a2[1];
          *(_OWORD *)int v177 = *a2;
          *(_OWORD *)(v177 + 16) = v192;
          long long v193 = a2[2];
          long long v194 = a2[3];
          long long v195 = a2[5];
          *(_OWORD *)(v177 + 64) = a2[4];
          *(_OWORD *)(v177 + 80) = v195;
          *(_OWORD *)(v177 + 32) = v193;
          *(_OWORD *)(v177 + 48) = v194;
          long long v196 = a2[6];
          long long v197 = a2[7];
          long long v198 = a2[9];
          *(_OWORD *)(v177 + 128) = a2[8];
          *(_OWORD *)(v177 + 144) = v198;
          *(_OWORD *)(v177 + 96) = v196;
          *(_OWORD *)(v177 + 112) = v197;
          long long v199 = a2[10];
          long long v200 = a2[11];
          double v201 = a2[12];
          *(_OWORD *)(v177 + 205) = *(long long *)((char *)a2 + 205);
          *(_OWORD *)(v177 + 176) = v200;
          *(_OWORD *)(v177 + 192) = v201;
          *(_OWORD *)(v177 + 160) = v199;
          *a2 = v279;
          a2[1] = v290;
          a2[4] = v326;
          a2[5] = v338;
          a2[2] = v302;
          a2[3] = v314;
          a2[8] = v374;
          a2[9] = v386;
          a2[6] = v350;
          a2[7] = v362;
          *(long long *)((char *)a2 + 205) = *(_OWORD *)&v420[13];
          a2[11] = v410;
          a2[12] = *(_OWORD *)v420;
          a2[10] = v398;
          double v202 = v177 - v10 + 224;
          if (v202 >= 225)
          {
            __int16 v203 = (unint64_t)(((((unint64_t)v202 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64)
                                    - 2) >> 1;
            __int16 v204 = *(double *)(v177 + 8);
            if (*(double *)(v10 + 224 * v203 + 8) < v204)
            {
              unint64_t v205 = *(void *)v177;
              __int16 v235 = *(_OWORD *)(v177 + 16);
              uint64_t v244 = *(_OWORD *)(v177 + 64);
              __int16 v247 = *(_OWORD *)(v177 + 80);
              double v238 = *(_OWORD *)(v177 + 32);
              __int16 v241 = *(_OWORD *)(v177 + 48);
              v256 = *(_OWORD *)(v177 + 128);
              __int16 v259 = *(_OWORD *)(v177 + 144);
              double v250 = *(_OWORD *)(v177 + 96);
              __int16 v253 = *(_OWORD *)(v177 + 112);
              *(_OWORD *)int v268 = *(_OWORD *)(v177 + 192);
              *(_OWORD *)&v268[16] = *(_OWORD *)(v177 + 208);
              uint64_t v262 = *(_OWORD *)(v177 + 160);
              __int16 v265 = *(_OWORD *)(v177 + 176);
              do
              {
                __int16 v206 = (_OWORD *)v177;
                int v177 = v10 + 224 * v203;
                double v207 = *(_OWORD *)(v177 + 16);
                *__int16 v206 = *(_OWORD *)v177;
                v206[1] = v207;
                __int16 v208 = *(_OWORD *)(v177 + 32);
                uint64_t v209 = *(_OWORD *)(v177 + 48);
                int v210 = *(_OWORD *)(v177 + 80);
                v206[4] = *(_OWORD *)(v177 + 64);
                v206[5] = v210;
                void v206[2] = v208;
                v206[3] = v209;
                __int16 v211 = *(_OWORD *)(v177 + 96);
                int v212 = *(_OWORD *)(v177 + 112);
                double v213 = *(_OWORD *)(v177 + 144);
                v206[8] = *(_OWORD *)(v177 + 128);
                v206[9] = v213;
                v206[6] = v211;
                v206[7] = v212;
                __int16 v214 = *(_OWORD *)(v177 + 160);
                uint64_t v215 = *(_OWORD *)(v177 + 176);
                int v216 = *(_OWORD *)(v177 + 192);
                *(_OWORD *)((char *)v206 + 205) = *(_OWORD *)(v177 + 205);
                v206[11] = v215;
                v206[12] = v216;
                v206[10] = v214;
                if (!v203) {
                  break;
                }
                __int16 v203 = (v203 - 1) >> 1;
              }
              while (*(double *)(v10 + 224 * v203 + 8) < v204);
              *(void *)int v177 = v205;
              *(double *)(v177 + 8) = v204;
              *(_OWORD *)(v177 + 16) = v235;
              *(_OWORD *)(v177 + 64) = v244;
              *(_OWORD *)(v177 + 80) = v247;
              *(_OWORD *)(v177 + 32) = v238;
              *(_OWORD *)(v177 + 48) = v241;
              *(_OWORD *)(v177 + 128) = v256;
              *(_OWORD *)(v177 + 144) = v259;
              *(_OWORD *)(v177 + 96) = v250;
              *(_OWORD *)(v177 + 112) = v253;
              char v217 = v262;
              char v218 = v265;
              long long v219 = *(_OWORD *)v268;
              double v220 = *(_OWORD *)&v268[13];
LABEL_117:
              *(_OWORD *)(v177 + 205) = v220;
              *(_OWORD *)(v177 + 176) = v218;
              *(_OWORD *)(v177 + 192) = v219;
              *(_OWORD *)(v177 + 160) = v217;
            }
          }
          if (v175-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)int v177 = v279;
      *(_OWORD *)(v177 + 16) = v290;
      *(_OWORD *)(v177 + 64) = v326;
      *(_OWORD *)(v177 + 80) = v338;
      *(_OWORD *)(v177 + 32) = v302;
      *(_OWORD *)(v177 + 48) = v314;
      *(_OWORD *)(v177 + 128) = v374;
      *(_OWORD *)(v177 + 144) = v386;
      *(_OWORD *)(v177 + 96) = v350;
      *(_OWORD *)(v177 + 112) = v362;
      char v217 = v398;
      char v218 = v410;
      long long v219 = *(_OWORD *)v420;
      double v220 = *(_OWORD *)&v420[13];
      goto LABEL_117;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (long long *)(v10 + 224 * (v12 >> 1));
    if ((unint64_t)v11 > 0x7000)
    {
      sub_1015A0F44((long long *)a1, (long long *)(a1 + 224 * (v12 >> 1)), a2 - 14);
      unint64_t v15 = 224 * v13;
      unint64_t v16 = (long long *)(224 * v13 + a1 - 224);
      sub_1015A0F44((long long *)(a1 + 224), v16, a2 - 28);
      id v17 = (long long *)(a1 + 224 + v15);
      sub_1015A0F44((long long *)(a1 + 448), v17, a2 - 42);
      sub_1015A0F44(v16, v14, v17);
      __int16 v269 = *(_OWORD *)a1;
      id v281 = *(_OWORD *)(a1 + 16);
      v316 = *(_OWORD *)(a1 + 64);
      v328 = *(_OWORD *)(a1 + 80);
      int v292 = *(_OWORD *)(a1 + 32);
      v304 = *(_OWORD *)(a1 + 48);
      v364 = *(_OWORD *)(a1 + 128);
      v376 = *(_OWORD *)(a1 + 144);
      v340 = *(_OWORD *)(a1 + 96);
      v352 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)v412 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v412[16] = *(_OWORD *)(a1 + 208);
      v388 = *(_OWORD *)(a1 + 160);
      v400 = *(_OWORD *)(a1 + 176);
      uint64_t v18 = v14[1];
      *(_OWORD *)a1 = *v14;
      *(_OWORD *)(a1 + 16) = v18;
      long long v19 = v14[2];
      float v20 = v14[3];
      float v21 = v14[5];
      *(_OWORD *)(a1 + 64) = v14[4];
      *(_OWORD *)(a1 + 80) = v21;
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)(a1 + 48) = v20;
      double v22 = v14[6];
      uint64_t v23 = v14[7];
      uint64_t v24 = v14[9];
      *(_OWORD *)(a1 + 128) = v14[8];
      *(_OWORD *)(a1 + 144) = v24;
      *(_OWORD *)(a1 + 96) = v22;
      *(_OWORD *)(a1 + 112) = v23;
      unint64_t v25 = v14[10];
      char v26 = v14[11];
      BOOL v27 = v14[12];
      *(_OWORD *)(a1 + 205) = *(long long *)((char *)v14 + 205);
      *(_OWORD *)(a1 + 176) = v26;
      *(_OWORD *)(a1 + 192) = v27;
      *(_OWORD *)(a1 + 160) = v25;
      *uint64_t v14 = v269;
      v14[1] = v281;
      v14[4] = v316;
      v14[5] = v328;
      int v14[2] = v292;
      v14[3] = v304;
      char v14[8] = v364;
      v14[9] = v376;
      void v14[6] = v340;
      v14[7] = v352;
      *(long long *)((char *)v14 + 205) = *(_OWORD *)&v412[13];
      v14[11] = v400;
      unsigned char v14[12] = *(_OWORD *)v412;
      v14[10] = v388;
    }
    else
    {
      sub_1015A0F44((long long *)(a1 + 224 * (v12 >> 1)), (long long *)a1, a2 - 14);
    }
    --a3;
    if (a4)
    {
      uint64_t v28 = *(double *)(a1 + 8);
LABEL_12:
      uint64_t v29 = 0;
      uint64_t v30 = *(void *)a1;
      uint64_t v242 = *(_OWORD *)(a1 + 64);
      __int16 v245 = *(_OWORD *)(a1 + 80);
      double v254 = *(_OWORD *)(a1 + 128);
      __int16 v257 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)double v266 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v266[16] = *(_OWORD *)(a1 + 208);
      float v260 = *(_OWORD *)(a1 + 160);
      __int16 v263 = *(_OWORD *)(a1 + 176);
      int v248 = *(_OWORD *)(a1 + 96);
      __int16 v251 = *(_OWORD *)(a1 + 112);
      v236 = *(_OWORD *)(a1 + 32);
      __int16 v239 = *(_OWORD *)(a1 + 48);
      v233 = *(_OWORD *)(a1 + 16);
      do
      {
        double v31 = *(double *)(a1 + v29 + 232);
        v29 += 224;
      }
      while (v31 < v28);
      id v32 = a1 + v29;
      unsigned __int8 v33 = a2;
      if (v29 == 224)
      {
        id v36 = a2;
        while (v32 < (unint64_t)v36)
        {
          uint64_t v34 = v36 - 14;
          unsigned __int8 v37 = *((double *)v36 - 27);
          v36 -= 14;
          if (v37 < v28) {
            goto LABEL_22;
          }
        }
        uint64_t v34 = v36;
      }
      else
      {
        do
        {
          uint64_t v34 = v33 - 14;
          uint64_t v35 = *((double *)v33 - 27);
          v33 -= 14;
        }
        while (v35 >= v28);
      }
LABEL_22:
      unint64_t v10 = v32;
      if (v32 < (unint64_t)v34)
      {
        uint64_t v38 = v34;
        do
        {
          double v270 = *(_OWORD *)v10;
          v282 = *(_OWORD *)(v10 + 16);
          v317 = *(_OWORD *)(v10 + 64);
          v329 = *(_OWORD *)(v10 + 80);
          __int16 v293 = *(_OWORD *)(v10 + 32);
          v305 = *(_OWORD *)(v10 + 48);
          v365 = *(_OWORD *)(v10 + 128);
          v377 = *(_OWORD *)(v10 + 144);
          v341 = *(_OWORD *)(v10 + 96);
          v353 = *(_OWORD *)(v10 + 112);
          *(_OWORD *)v413 = *(_OWORD *)(v10 + 192);
          *(_OWORD *)&v413[16] = *(_OWORD *)(v10 + 208);
          v389 = *(_OWORD *)(v10 + 160);
          v401 = *(_OWORD *)(v10 + 176);
          uint64_t v39 = v38[1];
          *(_OWORD *)unint64_t v10 = *v38;
          *(_OWORD *)(v10 + 16) = v39;
          uint64_t v40 = v38[2];
          id v41 = v38[3];
          unsigned __int8 v42 = v38[5];
          *(_OWORD *)(v10 + 64) = v38[4];
          *(_OWORD *)(v10 + 80) = v42;
          *(_OWORD *)(v10 + 32) = v40;
          *(_OWORD *)(v10 + 48) = v41;
          unint64_t v43 = v38[6];
          unint64_t v44 = v38[7];
          id v45 = v38[9];
          *(_OWORD *)(v10 + 128) = v38[8];
          *(_OWORD *)(v10 + 144) = v45;
          *(_OWORD *)(v10 + 96) = v43;
          *(_OWORD *)(v10 + 112) = v44;
          id v46 = v38[10];
          uint64_t v47 = v38[11];
          uint64_t v48 = v38[12];
          *(_OWORD *)(v10 + 205) = *(long long *)((char *)v38 + 205);
          *(_OWORD *)(v10 + 176) = v47;
          *(_OWORD *)(v10 + 192) = v48;
          *(_OWORD *)(v10 + 160) = v46;
          *uint64_t v38 = v270;
          v38[1] = v282;
          v38[4] = v317;
          v38[5] = v329;
          v38[2] = v293;
          v38[3] = v305;
          v38[8] = v365;
          v38[9] = v377;
          v38[6] = v341;
          v38[7] = v353;
          *(long long *)((char *)v38 + 205) = *(_OWORD *)&v413[13];
          v38[11] = v401;
          v38[12] = *(_OWORD *)v413;
          v38[10] = v389;
          do
          {
            uint64_t v49 = *(double *)(v10 + 232);
            v10 += 224;
          }
          while (v49 < v28);
          do
          {
            uint64_t v50 = *((double *)v38 - 27);
            v38 -= 14;
          }
          while (v50 >= v28);
        }
        while (v10 < (unint64_t)v38);
      }
      if (v10 - 224 != a1)
      {
        uint64_t v51 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v51;
        uint64_t v52 = *(_OWORD *)(v10 - 192);
        uint64_t v53 = *(_OWORD *)(v10 - 176);
        unint64_t v54 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v54;
        *(_OWORD *)(a1 + 32) = v52;
        *(_OWORD *)(a1 + 48) = v53;
        id v55 = *(_OWORD *)(v10 - 128);
        id v56 = *(_OWORD *)(v10 - 112);
        id v57 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v57;
        *(_OWORD *)(a1 + 96) = v55;
        *(_OWORD *)(a1 + 112) = v56;
        id v58 = *(_OWORD *)(v10 - 64);
        id v59 = *(_OWORD *)(v10 - 48);
        double v60 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v59;
        *(_OWORD *)(a1 + 192) = v60;
        *(_OWORD *)(a1 + 160) = v58;
      }
      *(void *)(v10 - 224) = v30;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v233;
      *(_OWORD *)(v10 - 160) = v242;
      *(_OWORD *)(v10 - 144) = v245;
      *(_OWORD *)(v10 - 192) = v236;
      *(_OWORD *)(v10 - 176) = v239;
      *(_OWORD *)(v10 - 96) = v254;
      *(_OWORD *)(v10 - 80) = v257;
      *(_OWORD *)(v10 - 128) = v248;
      *(_OWORD *)(v10 - 112) = v251;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v266[13];
      *(_OWORD *)(v10 - 48) = v263;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v266;
      *(_OWORD *)(v10 - 64) = v260;
      if (v32 < (unint64_t)v34) {
        goto LABEL_33;
      }
      id v61 = sub_1015A12F8(a1, v10 - 224);
      if (sub_1015A12F8(v10, (uint64_t)a2))
      {
        a2 = (long long *)(v10 - 224);
        if (v61) {
          return;
        }
        goto LABEL_1;
      }
      if (!v61)
      {
LABEL_33:
        sub_10159FD28(a1, v10 - 224, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v28 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 216) < v28) {
        goto LABEL_12;
      }
      unint64_t v62 = *(void *)a1;
      __int16 v243 = *(_OWORD *)(a1 + 64);
      double v246 = *(_OWORD *)(a1 + 80);
      __int16 v237 = *(_OWORD *)(a1 + 32);
      uint64_t v240 = *(_OWORD *)(a1 + 48);
      __int16 v255 = *(_OWORD *)(a1 + 128);
      double v258 = *(_OWORD *)(a1 + 144);
      __int16 v249 = *(_OWORD *)(a1 + 96);
      double v252 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)__int16 v267 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v267[16] = *(_OWORD *)(a1 + 208);
      __int16 v261 = *(_OWORD *)(a1 + 160);
      uint64_t v264 = *(_OWORD *)(a1 + 176);
      v234 = *(_OWORD *)(a1 + 16);
      if (v28 >= *((double *)a2 - 27))
      {
        uint64_t v65 = a1 + 224;
        do
        {
          unint64_t v10 = v65;
          if (v65 >= (unint64_t)a2) {
            break;
          }
          uint64_t v66 = *(double *)(v65 + 8);
          v65 += 224;
        }
        while (v28 >= v66);
      }
      else
      {
        int v63 = a1;
        do
        {
          unint64_t v10 = v63 + 224;
          id v64 = *(double *)(v63 + 232);
          v63 += 224;
        }
        while (v28 >= v64);
      }
      id v67 = a2;
      if (v10 < (unint64_t)a2)
      {
        unint64_t v68 = a2;
        do
        {
          id v67 = v68 - 14;
          long long v69 = *((double *)v68 - 27);
          v68 -= 14;
        }
        while (v28 < v69);
      }
      while (v10 < (unint64_t)v67)
      {
        __int16 v271 = *(_OWORD *)v10;
        __int16 v283 = *(_OWORD *)(v10 + 16);
        v318 = *(_OWORD *)(v10 + 64);
        v330 = *(_OWORD *)(v10 + 80);
        double v294 = *(_OWORD *)(v10 + 32);
        v306 = *(_OWORD *)(v10 + 48);
        v366 = *(_OWORD *)(v10 + 128);
        v378 = *(_OWORD *)(v10 + 144);
        v342 = *(_OWORD *)(v10 + 96);
        v354 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v414 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v414[16] = *(_OWORD *)(v10 + 208);
        v390 = *(_OWORD *)(v10 + 160);
        v402 = *(_OWORD *)(v10 + 176);
        long long v70 = v67[1];
        *(_OWORD *)unint64_t v10 = *v67;
        *(_OWORD *)(v10 + 16) = v70;
        long long v71 = v67[2];
        long long v72 = v67[3];
        id v73 = v67[5];
        *(_OWORD *)(v10 + 64) = v67[4];
        *(_OWORD *)(v10 + 80) = v73;
        *(_OWORD *)(v10 + 32) = v71;
        *(_OWORD *)(v10 + 48) = v72;
        int v74 = v67[6];
        long long v75 = v67[7];
        uint64_t v76 = v67[9];
        *(_OWORD *)(v10 + 128) = v67[8];
        *(_OWORD *)(v10 + 144) = v76;
        *(_OWORD *)(v10 + 96) = v74;
        *(_OWORD *)(v10 + 112) = v75;
        id v77 = v67[10];
        uint64_t v78 = v67[11];
        __int16 v79 = v67[12];
        *(_OWORD *)(v10 + 205) = *(long long *)((char *)v67 + 205);
        *(_OWORD *)(v10 + 176) = v78;
        *(_OWORD *)(v10 + 192) = v79;
        *(_OWORD *)(v10 + 160) = v77;
        *id v67 = v271;
        v67[1] = v283;
        v67[4] = v318;
        v67[5] = v330;
        v67[2] = v294;
        v67[3] = v306;
        v67[8] = v366;
        v67[9] = v378;
        v67[6] = v342;
        v67[7] = v354;
        *(long long *)((char *)v67 + 205) = *(_OWORD *)&v414[13];
        v67[11] = v402;
        v67[12] = *(_OWORD *)v414;
        v67[10] = v390;
        do
        {
          uint64_t v80 = *(double *)(v10 + 232);
          v10 += 224;
        }
        while (v28 >= v80);
        do
        {
          __int16 v81 = *((double *)v67 - 27);
          v67 -= 14;
        }
        while (v28 < v81);
      }
      unint64_t v4 = v10 - 224 >= a1;
      char v5 = v10 - 224 == a1;
      if (v10 - 224 != a1)
      {
        unint64_t v82 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v82;
        __int16 v83 = *(_OWORD *)(v10 - 192);
        uint64_t v84 = *(_OWORD *)(v10 - 176);
        __int16 v85 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v85;
        *(_OWORD *)(a1 + 32) = v83;
        *(_OWORD *)(a1 + 48) = v84;
        double v86 = *(_OWORD *)(v10 - 128);
        uint64_t v87 = *(_OWORD *)(v10 - 112);
        double v88 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v88;
        *(_OWORD *)(a1 + 96) = v86;
        *(_OWORD *)(a1 + 112) = v87;
        __int16 v89 = *(_OWORD *)(v10 - 64);
        uint64_t v90 = *(_OWORD *)(v10 - 48);
        __int16 v91 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v90;
        *(_OWORD *)(a1 + 192) = v91;
        *(_OWORD *)(a1 + 160) = v89;
      }
      a4 = 0;
      *(void *)(v10 - 224) = v62;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v234;
      *(_OWORD *)(v10 - 160) = v243;
      *(_OWORD *)(v10 - 144) = v246;
      *(_OWORD *)(v10 - 192) = v237;
      *(_OWORD *)(v10 - 176) = v240;
      *(_OWORD *)(v10 - 96) = v255;
      *(_OWORD *)(v10 - 80) = v258;
      *(_OWORD *)(v10 - 128) = v249;
      *(_OWORD *)(v10 - 112) = v252;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v267[13];
      *(_OWORD *)(v10 - 48) = v264;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v267;
      *(_OWORD *)(v10 - 64) = v261;
    }
  }
  id v135 = (long long *)(v10 + 224);
  uint64_t v137 = (long long *)v10 == a2 || v135 == a2;
  if (a4)
  {
    if (!v137)
    {
      uint64_t v138 = 0;
      unint64_t v139 = v10;
      do
      {
        id v140 = v135;
        unint64_t v141 = *(double *)(v139 + 232);
        if (v141 < *(double *)(v139 + 8))
        {
          unint64_t v142 = *(void *)v135;
          v396 = *(_OWORD *)(v139 + 400);
          *(_OWORD *)v408 = *(_OWORD *)(v139 + 416);
          *(_OWORD *)&v408[16] = *(_OWORD *)(v139 + 432);
          v348 = *(_OWORD *)(v139 + 336);
          v360 = *(_OWORD *)(v139 + 352);
          v372 = *(_OWORD *)(v139 + 368);
          v384 = *(_OWORD *)(v139 + 384);
          char v300 = *(_OWORD *)(v139 + 272);
          v312 = *(_OWORD *)(v139 + 288);
          v324 = *(_OWORD *)(v139 + 304);
          v336 = *(_OWORD *)(v139 + 320);
          std::string::size_type v144 = *(_OWORD *)(v139 + 240);
          id v143 = *(_OWORD *)(v139 + 256);
          uint64_t v145 = v138;
          v277 = v144;
          while (1)
          {
            std::string::size_type v146 = (double *)(v10 + v145);
            __int16 v147 = *(_OWORD *)(v10 + v145 + 176);
            *((_OWORD *)v146 + 24) = *(_OWORD *)(v10 + v145 + 160);
            *((_OWORD *)v146 + 25) = v147;
            *((_OWORD *)v146 + 26) = *(_OWORD *)(v10 + v145 + 192);
            *(_OWORD *)(v10 + v145 + 429) = *(_OWORD *)(v10 + v145 + 205);
            id v148 = *(_OWORD *)(v10 + v145 + 112);
            *((_OWORD *)v146 + 20) = *(_OWORD *)(v10 + v145 + 96);
            *((_OWORD *)v146 + 21) = v148;
            id v149 = *(_OWORD *)(v10 + v145 + 144);
            *((_OWORD *)v146 + 22) = *(_OWORD *)(v10 + v145 + 128);
            *((_OWORD *)v146 + 23) = v149;
            id v150 = *(_OWORD *)(v10 + v145 + 48);
            *((_OWORD *)v146 + 16) = *(_OWORD *)(v10 + v145 + 32);
            *((_OWORD *)v146 + 17) = v150;
            id v151 = *(_OWORD *)(v10 + v145 + 80);
            *((_OWORD *)v146 + 18) = *(_OWORD *)(v10 + v145 + 64);
            *((_OWORD *)v146 + 19) = v151;
            double v152 = *(_OWORD *)(v10 + v145 + 16);
            *((_OWORD *)v146 + 14) = *(_OWORD *)(v10 + v145);
            *((_OWORD *)v146 + 15) = v152;
            if (!v145) {
              break;
            }
            v145 -= 224;
            if (v141 >= *(v146 - 27))
            {
              id v153 = v10 + v145 + 224;
              goto LABEL_85;
            }
          }
          id v153 = v10;
LABEL_85:
          *(void *)id v153 = v142;
          *(double *)(v153 + 8) = v141;
          *(_OWORD *)(v153 + 176) = v396;
          *(_OWORD *)(v153 + 192) = *(_OWORD *)v408;
          *(_OWORD *)(v153 + 205) = *(_OWORD *)&v408[13];
          *(_OWORD *)(v153 + 112) = v348;
          *(_OWORD *)(v153 + 128) = v360;
          *(_OWORD *)(v153 + 144) = v372;
          *(_OWORD *)(v153 + 160) = v384;
          *(_OWORD *)(v153 + 48) = v300;
          *(_OWORD *)(v153 + 64) = v312;
          *(_OWORD *)(v153 + 80) = v324;
          *(_OWORD *)(v153 + 96) = v336;
          *(_OWORD *)(v153 + 16) = v277;
          *(_OWORD *)(v153 + 32) = v143;
        }
        id v135 = v140 + 14;
        v138 += 224;
        unint64_t v139 = (unint64_t)v140;
      }
      while (v140 + 14 != a2);
    }
  }
  else if (!v137)
  {
    do
    {
      char v222 = v135;
      uint64_t v223 = *(double *)(a1 + 232);
      if (v223 < *(double *)(a1 + 8))
      {
        char v224 = *(void *)v135;
        v399 = *(_OWORD *)(a1 + 400);
        *(_OWORD *)v411 = *(_OWORD *)(a1 + 416);
        *(_OWORD *)&v411[16] = *(_OWORD *)(a1 + 432);
        v351 = *(_OWORD *)(a1 + 336);
        v363 = *(_OWORD *)(a1 + 352);
        v375 = *(_OWORD *)(a1 + 368);
        v387 = *(_OWORD *)(a1 + 384);
        v303 = *(_OWORD *)(a1 + 272);
        v315 = *(_OWORD *)(a1 + 288);
        v327 = *(_OWORD *)(a1 + 304);
        v339 = *(_OWORD *)(a1 + 320);
        v280 = *(_OWORD *)(a1 + 240);
        __int16 v291 = *(_OWORD *)(a1 + 256);
        do
        {
          uint64_t v225 = a1 + 224;
          int v226 = *(_OWORD *)(a1 + 176);
          *(_OWORD *)(a1 + 384) = *(_OWORD *)(a1 + 160);
          *(_OWORD *)(a1 + 400) = v226;
          *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 192);
          char v227 = *(_OWORD *)(a1 + 112);
          *(_OWORD *)(a1 + 320) = *(_OWORD *)(a1 + 96);
          *(_OWORD *)(a1 + 336) = v227;
          uint64_t v228 = *(_OWORD *)(a1 + 144);
          *(_OWORD *)(a1 + 352) = *(_OWORD *)(a1 + 128);
          *(_OWORD *)(a1 + 368) = v228;
          __int16 v229 = *(_OWORD *)(a1 + 48);
          *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 32);
          *(_OWORD *)(a1 + 272) = v229;
          int v230 = *(_OWORD *)(a1 + 80);
          *(_OWORD *)(a1 + 288) = *(_OWORD *)(a1 + 64);
          *(_OWORD *)(a1 + 304) = v230;
          v231 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)(a1 + 224) = *(_OWORD *)a1;
          *(_OWORD *)(a1 + 240) = v231;
          unint64_t v121 = v223 < *(double *)(a1 - 216);
          int v232 = *(_OWORD *)(a1 + 205);
          a1 -= 224;
          *(_OWORD *)(v225 + 205) = v232;
        }
        while (v121);
        *(void *)(a1 + 224) = v224;
        *(double *)(a1 + 232) = v223;
        *(_OWORD *)(a1 + 240) = v280;
        *(_OWORD *)(a1 + 288) = v315;
        *(_OWORD *)(a1 + 304) = v327;
        *(_OWORD *)(a1 + 256) = v291;
        *(_OWORD *)(a1 + 272) = v303;
        *(_OWORD *)(a1 + 352) = v363;
        *(_OWORD *)(a1 + 368) = v375;
        *(_OWORD *)(a1 + 320) = v339;
        *(_OWORD *)(a1 + 336) = v351;
        *(_OWORD *)(a1 + 429) = *(_OWORD *)&v411[13];
        *(_OWORD *)(a1 + 400) = v399;
        *(_OWORD *)(a1 + 416) = *(_OWORD *)v411;
        *(_OWORD *)(a1 + 384) = v387;
      }
      id v135 = v222 + 14;
      a1 = (unint64_t)v222;
    }
    while (v222 + 14 != a2);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v10) >> 5);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 27) < *(double *)(v10 + 8))
          {
            double v272 = *(_OWORD *)v10;
            uint64_t v284 = *(_OWORD *)(v10 + 16);
            v319 = *(_OWORD *)(v10 + 64);
            v331 = *(_OWORD *)(v10 + 80);
            v295 = *(_OWORD *)(v10 + 32);
            v307 = *(_OWORD *)(v10 + 48);
            v367 = *(_OWORD *)(v10 + 128);
            v379 = *(_OWORD *)(v10 + 144);
            v343 = *(_OWORD *)(v10 + 96);
            v355 = *(_OWORD *)(v10 + 112);
            *(_OWORD *)v415 = *(_OWORD *)(v10 + 192);
            *(_OWORD *)&v415[16] = *(_OWORD *)(v10 + 208);
            v391 = *(_OWORD *)(v10 + 160);
            v403 = *(_OWORD *)(v10 + 176);
            unint64_t v92 = *(a2 - 13);
            *(_OWORD *)unint64_t v10 = *(a2 - 14);
            *(_OWORD *)(v10 + 16) = v92;
            __int16 v93 = *(a2 - 12);
            uint64_t v94 = *(a2 - 11);
            __int16 v95 = *(a2 - 9);
            *(_OWORD *)(v10 + 64) = *(a2 - 10);
            *(_OWORD *)(v10 + 80) = v95;
            *(_OWORD *)(v10 + 32) = v93;
            *(_OWORD *)(v10 + 48) = v94;
            double v96 = *(a2 - 8);
            id v97 = *(a2 - 7);
            id v98 = *(a2 - 5);
            *(_OWORD *)(v10 + 128) = *(a2 - 6);
            *(_OWORD *)(v10 + 144) = v98;
            *(_OWORD *)(v10 + 96) = v96;
            *(_OWORD *)(v10 + 112) = v97;
            int v99 = *(a2 - 4);
            int v100 = *(a2 - 3);
            uint64_t v101 = *(a2 - 2);
            *(_OWORD *)(v10 + 205) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 176) = v100;
            *(_OWORD *)(v10 + 192) = v101;
            *(_OWORD *)(v10 + 160) = v99;
            *(a2 - 14) = v272;
            *(a2 - 13) = v284;
            *(a2 - 10) = v319;
            *(a2 - 9) = v331;
            *(a2 - 12) = v295;
            *(a2 - 11) = v307;
            *(a2 - 6) = v367;
            *(a2 - 5) = v379;
            *(a2 - 8) = v343;
            *(a2 - 7) = v355;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v415[13];
            *(a2 - 3) = v403;
            *(a2 - 2) = *(_OWORD *)v415;
            *(a2 - 4) = v391;
          }
          break;
        case 3uLL:
          sub_1015A0F44((long long *)v10, (long long *)(v10 + 224), a2 - 14);
          break;
        case 4uLL:
          sub_1015A1948(v10, v10 + 224, v10 + 448, (uint64_t)(a2 - 14));
          break;
        case 5uLL:
          id v102 = (long long *)(v10 + 224);
          int64_t v103 = (long long *)(v10 + 448);
          unint64_t v104 = (long long *)(v10 + 672);
          sub_1015A1948(v10, v10 + 224, v10 + 448, v10 + 672);
          if (*((double *)a2 - 27) < *(double *)(v10 + 680))
          {
            v320 = *(_OWORD *)(v10 + 736);
            v332 = *(_OWORD *)(v10 + 752);
            v296 = *(_OWORD *)(v10 + 704);
            v308 = *(_OWORD *)(v10 + 720);
            v368 = *(_OWORD *)(v10 + 800);
            v380 = *(_OWORD *)(v10 + 816);
            v344 = *(_OWORD *)(v10 + 768);
            v356 = *(_OWORD *)(v10 + 784);
            *(_OWORD *)v416 = *(_OWORD *)(v10 + 864);
            *(_OWORD *)&v416[16] = *(_OWORD *)(v10 + 880);
            v392 = *(_OWORD *)(v10 + 832);
            v404 = *(_OWORD *)(v10 + 848);
            uint64_t v273 = *v104;
            __int16 v285 = *(_OWORD *)(v10 + 688);
            uint64_t v105 = *(a2 - 13);
            *unint64_t v104 = *(a2 - 14);
            *(_OWORD *)(v10 + 688) = v105;
            unint64_t v106 = *(a2 - 12);
            uint64_t v107 = *(a2 - 11);
            id v108 = *(a2 - 9);
            *(_OWORD *)(v10 + 736) = *(a2 - 10);
            *(_OWORD *)(v10 + 752) = v108;
            *(_OWORD *)(v10 + 704) = v106;
            *(_OWORD *)(v10 + 720) = v107;
            uint64_t v109 = *(a2 - 8);
            uint64_t v110 = *(a2 - 7);
            long long v111 = *(a2 - 5);
            *(_OWORD *)(v10 + 800) = *(a2 - 6);
            *(_OWORD *)(v10 + 816) = v111;
            *(_OWORD *)(v10 + 768) = v109;
            *(_OWORD *)(v10 + 784) = v110;
            int v112 = *(a2 - 4);
            id v113 = *(a2 - 3);
            uint64_t v114 = *(a2 - 2);
            *(_OWORD *)(v10 + 877) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 848) = v113;
            *(_OWORD *)(v10 + 864) = v114;
            *(_OWORD *)(v10 + 832) = v112;
            *(a2 - 14) = v273;
            *(a2 - 13) = v285;
            *(a2 - 10) = v320;
            *(a2 - 9) = v332;
            *(a2 - 12) = v296;
            *(a2 - 11) = v308;
            *(a2 - 6) = v368;
            *(a2 - 5) = v380;
            *(a2 - 8) = v344;
            *(a2 - 7) = v356;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v416[13];
            *(a2 - 3) = v404;
            *(a2 - 2) = *(_OWORD *)v416;
            *(a2 - 4) = v392;
            if (*(double *)(v10 + 680) < *(double *)(v10 + 456))
            {
              v393 = *(_OWORD *)(v10 + 608);
              v405 = *(_OWORD *)(v10 + 624);
              *(_OWORD *)v417 = *(_OWORD *)(v10 + 640);
              *(_OWORD *)&v417[16] = *(_OWORD *)(v10 + 656);
              v345 = *(_OWORD *)(v10 + 544);
              v357 = *(_OWORD *)(v10 + 560);
              v369 = *(_OWORD *)(v10 + 576);
              v381 = *(_OWORD *)(v10 + 592);
              uint64_t v297 = *(_OWORD *)(v10 + 480);
              v309 = *(_OWORD *)(v10 + 496);
              v321 = *(_OWORD *)(v10 + 512);
              v333 = *(_OWORD *)(v10 + 528);
              uint64_t v274 = *v103;
              int v286 = *(_OWORD *)(v10 + 464);
              uint64_t v115 = *(_OWORD *)(v10 + 848);
              *(_OWORD *)(v10 + 608) = *(_OWORD *)(v10 + 832);
              *(_OWORD *)(v10 + 624) = v115;
              *(_OWORD *)(v10 + 640) = *(_OWORD *)(v10 + 864);
              *(_OWORD *)(v10 + 653) = *(_OWORD *)(v10 + 877);
              double v116 = *(_OWORD *)(v10 + 784);
              *(_OWORD *)(v10 + 544) = *(_OWORD *)(v10 + 768);
              *(_OWORD *)(v10 + 560) = v116;
              double v117 = *(_OWORD *)(v10 + 816);
              *(_OWORD *)(v10 + 576) = *(_OWORD *)(v10 + 800);
              *(_OWORD *)(v10 + 592) = v117;
              id v118 = *(_OWORD *)(v10 + 720);
              *(_OWORD *)(v10 + 480) = *(_OWORD *)(v10 + 704);
              *(_OWORD *)(v10 + 496) = v118;
              id v119 = *(_OWORD *)(v10 + 752);
              *(_OWORD *)(v10 + 512) = *(_OWORD *)(v10 + 736);
              *(_OWORD *)(v10 + 528) = v119;
              unint64_t v120 = *(_OWORD *)(v10 + 688);
              NSObject *v103 = *v104;
              *(_OWORD *)(v10 + 464) = v120;
              *(_OWORD *)(v10 + 832) = v393;
              *(_OWORD *)(v10 + 848) = v405;
              *(_OWORD *)(v10 + 864) = *(_OWORD *)v417;
              *(_OWORD *)(v10 + 877) = *(_OWORD *)&v417[13];
              *(_OWORD *)(v10 + 768) = v345;
              *(_OWORD *)(v10 + 784) = v357;
              *(_OWORD *)(v10 + 800) = v369;
              *(_OWORD *)(v10 + 816) = v381;
              *(_OWORD *)(v10 + 704) = v297;
              *(_OWORD *)(v10 + 720) = v309;
              *(_OWORD *)(v10 + 736) = v321;
              *(_OWORD *)(v10 + 752) = v333;
              unint64_t v121 = *(double *)(v10 + 456) < *(double *)(v10 + 232);
              *unint64_t v104 = v274;
              *(_OWORD *)(v10 + 688) = v286;
              if (v121)
              {
                v394 = *(_OWORD *)(v10 + 384);
                v406 = *(_OWORD *)(v10 + 400);
                *(_OWORD *)v418 = *(_OWORD *)(v10 + 416);
                *(_OWORD *)&v418[16] = *(_OWORD *)(v10 + 432);
                v346 = *(_OWORD *)(v10 + 320);
                v358 = *(_OWORD *)(v10 + 336);
                v370 = *(_OWORD *)(v10 + 352);
                v382 = *(_OWORD *)(v10 + 368);
                uint64_t v298 = *(_OWORD *)(v10 + 256);
                v310 = *(_OWORD *)(v10 + 272);
                v322 = *(_OWORD *)(v10 + 288);
                v334 = *(_OWORD *)(v10 + 304);
                uint64_t v275 = *v102;
                __int16 v287 = *(_OWORD *)(v10 + 240);
                double v122 = *(_OWORD *)(v10 + 624);
                *(_OWORD *)(v10 + 384) = *(_OWORD *)(v10 + 608);
                *(_OWORD *)(v10 + 400) = v122;
                *(_OWORD *)(v10 + 416) = *(_OWORD *)(v10 + 640);
                *(_OWORD *)(v10 + 429) = *(_OWORD *)(v10 + 653);
                double v123 = *(_OWORD *)(v10 + 560);
                *(_OWORD *)(v10 + 320) = *(_OWORD *)(v10 + 544);
                *(_OWORD *)(v10 + 336) = v123;
                id v124 = *(_OWORD *)(v10 + 592);
                *(_OWORD *)(v10 + 352) = *(_OWORD *)(v10 + 576);
                *(_OWORD *)(v10 + 368) = v124;
                id v125 = *(_OWORD *)(v10 + 496);
                *(_OWORD *)(v10 + 256) = *(_OWORD *)(v10 + 480);
                *(_OWORD *)(v10 + 272) = v125;
                unint64_t v126 = *(_OWORD *)(v10 + 528);
                *(_OWORD *)(v10 + 288) = *(_OWORD *)(v10 + 512);
                *(_OWORD *)(v10 + 304) = v126;
                uint64_t v127 = *(_OWORD *)(v10 + 464);
                char *v102 = *v103;
                *(_OWORD *)(v10 + 240) = v127;
                *(_OWORD *)(v10 + 608) = v394;
                *(_OWORD *)(v10 + 624) = v406;
                *(_OWORD *)(v10 + 640) = *(_OWORD *)v418;
                *(_OWORD *)(v10 + 653) = *(_OWORD *)&v418[13];
                *(_OWORD *)(v10 + 544) = v346;
                *(_OWORD *)(v10 + 560) = v358;
                *(_OWORD *)(v10 + 576) = v370;
                *(_OWORD *)(v10 + 592) = v382;
                *(_OWORD *)(v10 + 480) = v298;
                *(_OWORD *)(v10 + 496) = v310;
                *(_OWORD *)(v10 + 512) = v322;
                *(_OWORD *)(v10 + 528) = v334;
                unint64_t v121 = *(double *)(v10 + 232) < *(double *)(v10 + 8);
                NSObject *v103 = v275;
                *(_OWORD *)(v10 + 464) = v287;
                if (v121)
                {
                  v276 = *(_OWORD *)v10;
                  v288 = *(_OWORD *)(v10 + 16);
                  v323 = *(_OWORD *)(v10 + 64);
                  v335 = *(_OWORD *)(v10 + 80);
                  v299 = *(_OWORD *)(v10 + 32);
                  v311 = *(_OWORD *)(v10 + 48);
                  v371 = *(_OWORD *)(v10 + 128);
                  v383 = *(_OWORD *)(v10 + 144);
                  v347 = *(_OWORD *)(v10 + 96);
                  v359 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)v419 = *(_OWORD *)(v10 + 192);
                  *(_OWORD *)&v419[16] = *(_OWORD *)(v10 + 208);
                  v395 = *(_OWORD *)(v10 + 160);
                  v407 = *(_OWORD *)(v10 + 176);
                  id v128 = *(_OWORD *)(v10 + 304);
                  *(_OWORD *)(v10 + 64) = *(_OWORD *)(v10 + 288);
                  *(_OWORD *)(v10 + 80) = v128;
                  uint64_t v129 = *(_OWORD *)(v10 + 272);
                  *(_OWORD *)(v10 + 32) = *(_OWORD *)(v10 + 256);
                  *(_OWORD *)(v10 + 48) = v129;
                  double v130 = *(_OWORD *)(v10 + 368);
                  *(_OWORD *)(v10 + 128) = *(_OWORD *)(v10 + 352);
                  *(_OWORD *)(v10 + 144) = v130;
                  uint64_t v131 = *(_OWORD *)(v10 + 336);
                  *(_OWORD *)(v10 + 96) = *(_OWORD *)(v10 + 320);
                  *(_OWORD *)(v10 + 112) = v131;
                  *(_OWORD *)(v10 + 205) = *(_OWORD *)(v10 + 429);
                  id v132 = *(_OWORD *)(v10 + 416);
                  uint64_t v133 = *(_OWORD *)(v10 + 384);
                  *(_OWORD *)(v10 + 176) = *(_OWORD *)(v10 + 400);
                  *(_OWORD *)(v10 + 192) = v132;
                  *(_OWORD *)(v10 + 160) = v133;
                  uint64_t v134 = *(_OWORD *)(v10 + 240);
                  *(_OWORD *)unint64_t v10 = *v102;
                  *(_OWORD *)(v10 + 16) = v134;
                  *(_OWORD *)(v10 + 384) = v395;
                  *(_OWORD *)(v10 + 400) = v407;
                  *(_OWORD *)(v10 + 416) = *(_OWORD *)v419;
                  *(_OWORD *)(v10 + 429) = *(_OWORD *)&v419[13];
                  *(_OWORD *)(v10 + 320) = v347;
                  *(_OWORD *)(v10 + 336) = v359;
                  *(_OWORD *)(v10 + 352) = v371;
                  *(_OWORD *)(v10 + 368) = v383;
                  *(_OWORD *)(v10 + 256) = v299;
                  *(_OWORD *)(v10 + 272) = v311;
                  *(_OWORD *)(v10 + 288) = v323;
                  *(_OWORD *)(v10 + 304) = v335;
                  char *v102 = v276;
                  *(_OWORD *)(v10 + 240) = v288;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5375) {
      break;
    }
    if (!a3)
    {
      if ((long long *)v10 == a2) {
        return;
      }
      unint64_t v154 = (v12 - 2) >> 1;
      int v155 = v154;
      do
      {
        id v156 = v155;
        if (v154 >= v155)
        {
          uint64_t v157 = (2 * v155) | 1;
          unint64_t v158 = v10 + 224 * v157;
          if (2 * v155 + 2 < (uint64_t)v12 && *(double *)(v10 + 224 * v157 + 8) < *(double *)(v158 + 232))
          {
            v158 += 224;
            uint64_t v157 = 2 * v155 + 2;
          }
          id v159 = *(double *)(v10 + 224 * v155 + 8);
          if (*(double *)(v158 + 8) >= v159)
          {
            id v160 = v10 + 224 * v155;
            id v161 = *(void *)v160;
            v278 = *(_OWORD *)(v160 + 16);
            v313 = *(_OWORD *)(v160 + 64);
            v325 = *(_OWORD *)(v160 + 80);
            __int16 v289 = *(_OWORD *)(v160 + 32);
            v301 = *(_OWORD *)(v160 + 48);
            v361 = *(_OWORD *)(v160 + 128);
            v373 = *(_OWORD *)(v160 + 144);
            v337 = *(_OWORD *)(v160 + 96);
            v349 = *(_OWORD *)(v160 + 112);
            *(_OWORD *)v409 = *(_OWORD *)(v160 + 192);
            *(_OWORD *)&v409[16] = *(_OWORD *)(v160 + 208);
            v385 = *(_OWORD *)(v160 + 160);
            v397 = *(_OWORD *)(v160 + 176);
            do
            {
              id v162 = (_OWORD *)v160;
              id v160 = v158;
              __int16 v163 = *(_OWORD *)(v158 + 16);
              *id v162 = *(_OWORD *)v158;
              v162[1] = v163;
              id v164 = *(_OWORD *)(v158 + 32);
              __int16 v165 = *(_OWORD *)(v158 + 48);
              double v166 = *(_OWORD *)(v158 + 80);
              v162[4] = *(_OWORD *)(v158 + 64);
              v162[5] = v166;
              v162[2] = v164;
              v162[3] = v165;
              id v167 = *(_OWORD *)(v158 + 96);
              id v168 = *(_OWORD *)(v158 + 112);
              __int16 v169 = *(_OWORD *)(v158 + 144);
              v162[8] = *(_OWORD *)(v158 + 128);
              v162[9] = v169;
              v162[6] = v167;
              v162[7] = v168;
              double v170 = *(_OWORD *)(v158 + 160);
              __int16 v171 = *(_OWORD *)(v158 + 176);
              int v172 = *(_OWORD *)(v158 + 192);
              *(_OWORD *)((char *)v162 + 205) = *(_OWORD *)(v158 + 205);
              v162[11] = v171;
              v162[12] = v172;
              v162[10] = v170;
              if (v154 < v157) {
                break;
              }
              __int16 v173 = (2 * v157) | 1;
              unint64_t v158 = v10 + 224 * v173;
              uint64_t v174 = 2 * v157 + 2;
              if (v174 < (uint64_t)v12 && *(double *)(v10 + 224 * v173 + 8) < *(double *)(v158 + 232))
              {
                v158 += 224;
                __int16 v173 = v174;
              }
              uint64_t v157 = v173;
            }
            while (*(double *)(v158 + 8) >= v159);
            *(void *)id v160 = v161;
            *(double *)(v160 + 8) = v159;
            *(_OWORD *)(v160 + 176) = v397;
            *(_OWORD *)(v160 + 192) = *(_OWORD *)v409;
            *(_OWORD *)(v160 + 205) = *(_OWORD *)&v409[13];
            *(_OWORD *)(v160 + 112) = v349;
            *(_OWORD *)(v160 + 128) = v361;
            *(_OWORD *)(v160 + 144) = v373;
            *(_OWORD *)(v160 + 160) = v385;
            *(_OWORD *)(v160 + 48) = v301;
            *(_OWORD *)(v160 + 64) = v313;
            *(_OWORD *)(v160 + 80) = v325;
            *(_OWORD *)(v160 + 96) = v337;
            *(_OWORD *)(v160 + 16) = v278;
            *(_OWORD *)(v160 + 32) = v289;
          }
        }
        int v155 = v156 - 1;
      }
      while (v156);
      uint64_t v175 = (((unint64_t)v11 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      while (2)
      {
        double v176 = 0;
        char v279 = *(_OWORD *)v10;
        int v290 = *(_OWORD *)(v10 + 16);
        v326 = *(_OWORD *)(v10 + 64);
        v338 = *(_OWORD *)(v10 + 80);
        id v302 = *(_OWORD *)(v10 + 32);
        v314 = *(_OWORD *)(v10 + 48);
        v374 = *(_OWORD *)(v10 + 128);
        v386 = *(_OWORD *)(v10 + 144);
        v350 = *(_OWORD *)(v10 + 96);
        v362 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v420 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v420[16] = *(_OWORD *)(v10 + 208);
        v398 = *(_OWORD *)(v10 + 160);
        v410 = *(_OWORD *)(v10 + 176);
        int v177 = v10;
        do
        {
          long long v178 = (_OWORD *)v177;
          long long v179 = v176 + 1;
          v177 += 224 * (v176 + 1);
          long long v180 = 2 * v176;
          double v176 = (2 * v176) | 1;
          long long v181 = v180 + 2;
          if (v181 < v175 && *((double *)&v178[14 * v179] + 1) < *(double *)(v177 + 232))
          {
            v177 += 224;
            double v176 = v181;
          }
          long long v182 = *(_OWORD *)(v177 + 16);
          void *v178 = *(_OWORD *)v177;
          v178[1] = v182;
          unint64_t v183 = *(_OWORD *)(v177 + 32);
          long long v184 = *(_OWORD *)(v177 + 48);
          long long v185 = *(_OWORD *)(v177 + 80);
          v178[4] = *(_OWORD *)(v177 + 64);
          v178[5] = v185;
          v178[2] = v183;
          v178[3] = v184;
          long long v186 = *(_OWORD *)(v177 + 96);
          long long v187 = *(_OWORD *)(v177 + 112);
          std::string v188 = *(_OWORD *)(v177 + 144);
          v178[8] = *(_OWORD *)(v177 + 128);
          v178[9] = v188;
          v178[6] = v186;
          v178[7] = v187;
          float v189 = *(_OWORD *)(v177 + 160);
          long long v190 = *(_OWORD *)(v177 + 176);
          long long v191 = *(_OWORD *)(v177 + 192);
          *(_OWORD *)((char *)v178 + 205) = *(_OWORD *)(v177 + 205);
          v178[11] = v190;
          v178[12] = v191;
          v178[10] = v189;
        }
        while (v176 <= (uint64_t)((unint64_t)(v175 - 2) >> 1));
        a2 -= 14;
        if ((long long *)v177 != a2)
        {
          unint64_t v192 = a2[1];
          *(_OWORD *)int v177 = *a2;
          *(_OWORD *)(v177 + 16) = v192;
          long long v193 = a2[2];
          long long v194 = a2[3];
          long long v195 = a2[5];
          *(_OWORD *)(v177 + 64) = a2[4];
          *(_OWORD *)(v177 + 80) = v195;
          *(_OWORD *)(v177 + 32) = v193;
          *(_OWORD *)(v177 + 48) = v194;
          long long v196 = a2[6];
          long long v197 = a2[7];
          long long v198 = a2[9];
          *(_OWORD *)(v177 + 128) = a2[8];
          *(_OWORD *)(v177 + 144) = v198;
          *(_OWORD *)(v177 + 96) = v196;
          *(_OWORD *)(v177 + 112) = v197;
          long long v199 = a2[10];
          long long v200 = a2[11];
          double v201 = a2[12];
          *(_OWORD *)(v177 + 205) = *(long long *)((char *)a2 + 205);
          *(_OWORD *)(v177 + 176) = v200;
          *(_OWORD *)(v177 + 192) = v201;
          *(_OWORD *)(v177 + 160) = v199;
          *a2 = v279;
          a2[1] = v290;
          a2[4] = v326;
          a2[5] = v338;
          a2[2] = v302;
          a2[3] = v314;
          a2[8] = v374;
          a2[9] = v386;
          a2[6] = v350;
          a2[7] = v362;
          *(long long *)((char *)a2 + 205) = *(_OWORD *)&v420[13];
          a2[11] = v410;
          a2[12] = *(_OWORD *)v420;
          a2[10] = v398;
          double v202 = v177 - v10 + 224;
          if (v202 >= 225)
          {
            __int16 v203 = (unint64_t)(((((unint64_t)v202 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64)
                                    - 2) >> 1;
            __int16 v204 = *(double *)(v177 + 8);
            if (*(double *)(v10 + 224 * v203 + 8) < v204)
            {
              unint64_t v205 = *(void *)v177;
              __int16 v235 = *(_OWORD *)(v177 + 16);
              uint64_t v244 = *(_OWORD *)(v177 + 64);
              __int16 v247 = *(_OWORD *)(v177 + 80);
              double v238 = *(_OWORD *)(v177 + 32);
              __int16 v241 = *(_OWORD *)(v177 + 48);
              v256 = *(_OWORD *)(v177 + 128);
              __int16 v259 = *(_OWORD *)(v177 + 144);
              double v250 = *(_OWORD *)(v177 + 96);
              __int16 v253 = *(_OWORD *)(v177 + 112);
              *(_OWORD *)int v268 = *(_OWORD *)(v177 + 192);
              *(_OWORD *)&v268[16] = *(_OWORD *)(v177 + 208);
              uint64_t v262 = *(_OWORD *)(v177 + 160);
              __int16 v265 = *(_OWORD *)(v177 + 176);
              do
              {
                __int16 v206 = (_OWORD *)v177;
                int v177 = v10 + 224 * v203;
                double v207 = *(_OWORD *)(v177 + 16);
                *__int16 v206 = *(_OWORD *)v177;
                v206[1] = v207;
                __int16 v208 = *(_OWORD *)(v177 + 32);
                uint64_t v209 = *(_OWORD *)(v177 + 48);
                int v210 = *(_OWORD *)(v177 + 80);
                v206[4] = *(_OWORD *)(v177 + 64);
                v206[5] = v210;
                void v206[2] = v208;
                v206[3] = v209;
                __int16 v211 = *(_OWORD *)(v177 + 96);
                int v212 = *(_OWORD *)(v177 + 112);
                double v213 = *(_OWORD *)(v177 + 144);
                v206[8] = *(_OWORD *)(v177 + 128);
                v206[9] = v213;
                v206[6] = v211;
                v206[7] = v212;
                __int16 v214 = *(_OWORD *)(v177 + 160);
                uint64_t v215 = *(_OWORD *)(v177 + 176);
                int v216 = *(_OWORD *)(v177 + 192);
                *(_OWORD *)((char *)v206 + 205) = *(_OWORD *)(v177 + 205);
                v206[11] = v215;
                v206[12] = v216;
                v206[10] = v214;
                if (!v203) {
                  break;
                }
                __int16 v203 = (v203 - 1) >> 1;
              }
              while (*(double *)(v10 + 224 * v203 + 8) < v204);
              *(void *)int v177 = v205;
              *(double *)(v177 + 8) = v204;
              *(_OWORD *)(v177 + 16) = v235;
              *(_OWORD *)(v177 + 64) = v244;
              *(_OWORD *)(v177 + 80) = v247;
              *(_OWORD *)(v177 + 32) = v238;
              *(_OWORD *)(v177 + 48) = v241;
              *(_OWORD *)(v177 + 128) = v256;
              *(_OWORD *)(v177 + 144) = v259;
              *(_OWORD *)(v177 + 96) = v250;
              *(_OWORD *)(v177 + 112) = v253;
              char v217 = v262;
              char v218 = v265;
              long long v219 = *(_OWORD *)v268;
              double v220 = *(_OWORD *)&v268[13];
LABEL_117:
              *(_OWORD *)(v177 + 205) = v220;
              *(_OWORD *)(v177 + 176) = v218;
              *(_OWORD *)(v177 + 192) = v219;
              *(_OWORD *)(v177 + 160) = v217;
            }
          }
          if (v175-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)int v177 = v279;
      *(_OWORD *)(v177 + 16) = v290;
      *(_OWORD *)(v177 + 64) = v326;
      *(_OWORD *)(v177 + 80) = v338;
      *(_OWORD *)(v177 + 32) = v302;
      *(_OWORD *)(v177 + 48) = v314;
      *(_OWORD *)(v177 + 128) = v374;
      *(_OWORD *)(v177 + 144) = v386;
      *(_OWORD *)(v177 + 96) = v350;
      *(_OWORD *)(v177 + 112) = v362;
      char v217 = v398;
      char v218 = v410;
      long long v219 = *(_OWORD *)v420;
      double v220 = *(_OWORD *)&v420[13];
      goto LABEL_117;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (long long *)(v10 + 224 * (v12 >> 1));
    if ((unint64_t)v11 > 0x7000)
    {
      sub_1015A0F44((long long *)a1, (long long *)(a1 + 224 * (v12 >> 1)), a2 - 14);
      unint64_t v15 = 224 * v13;
      unint64_t v16 = (long long *)(224 * v13 + a1 - 224);
      sub_1015A0F44((long long *)(a1 + 224), v16, a2 - 28);
      id v17 = (long long *)(a1 + 224 + v15);
      sub_1015A0F44((long long *)(a1 + 448), v17, a2 - 42);
      sub_1015A0F44(v16, v14, v17);
      __int16 v269 = *(_OWORD *)a1;
      id v281 = *(_OWORD *)(a1 + 16);
      v316 = *(_OWORD *)(a1 + 64);
      v328 = *(_OWORD *)(a1 + 80);
      int v292 = *(_OWORD *)(a1 + 32);
      v304 = *(_OWORD *)(a1 + 48);
      v364 = *(_OWORD *)(a1 + 128);
      v376 = *(_OWORD *)(a1 + 144);
      v340 = *(_OWORD *)(a1 + 96);
      v352 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)v412 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v412[16] = *(_OWORD *)(a1 + 208);
      v388 = *(_OWORD *)(a1 + 160);
      v400 = *(_OWORD *)(a1 + 176);
      uint64_t v18 = v14[1];
      *(_OWORD *)a1 = *v14;
      *(_OWORD *)(a1 + 16) = v18;
      long long v19 = v14[2];
      float v20 = v14[3];
      float v21 = v14[5];
      *(_OWORD *)(a1 + 64) = v14[4];
      *(_OWORD *)(a1 + 80) = v21;
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)(a1 + 48) = v20;
      double v22 = v14[6];
      uint64_t v23 = v14[7];
      uint64_t v24 = v14[9];
      *(_OWORD *)(a1 + 128) = v14[8];
      *(_OWORD *)(a1 + 144) = v24;
      *(_OWORD *)(a1 + 96) = v22;
      *(_OWORD *)(a1 + 112) = v23;
      unint64_t v25 = v14[10];
      char v26 = v14[11];
      BOOL v27 = v14[12];
      *(_OWORD *)(a1 + 205) = *(long long *)((char *)v14 + 205);
      *(_OWORD *)(a1 + 176) = v26;
      *(_OWORD *)(a1 + 192) = v27;
      *(_OWORD *)(a1 + 160) = v25;
      *uint64_t v14 = v269;
      v14[1] = v281;
      v14[4] = v316;
      v14[5] = v328;
      int v14[2] = v292;
      v14[3] = v304;
      char v14[8] = v364;
      v14[9] = v376;
      void v14[6] = v340;
      v14[7] = v352;
      *(long long *)((char *)v14 + 205) = *(_OWORD *)&v412[13];
      v14[11] = v400;
      unsigned char v14[12] = *(_OWORD *)v412;
      v14[10] = v388;
    }
    else
    {
      sub_1015A0F44((long long *)(a1 + 224 * (v12 >> 1)), (long long *)a1, a2 - 14);
    }
    --a3;
    if (a4)
    {
      uint64_t v28 = *(double *)(a1 + 8);
LABEL_12:
      uint64_t v29 = 0;
      uint64_t v30 = *(void *)a1;
      uint64_t v242 = *(_OWORD *)(a1 + 64);
      __int16 v245 = *(_OWORD *)(a1 + 80);
      double v254 = *(_OWORD *)(a1 + 128);
      __int16 v257 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)double v266 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v266[16] = *(_OWORD *)(a1 + 208);
      float v260 = *(_OWORD *)(a1 + 160);
      __int16 v263 = *(_OWORD *)(a1 + 176);
      int v248 = *(_OWORD *)(a1 + 96);
      __int16 v251 = *(_OWORD *)(a1 + 112);
      v236 = *(_OWORD *)(a1 + 32);
      __int16 v239 = *(_OWORD *)(a1 + 48);
      v233 = *(_OWORD *)(a1 + 16);
      do
      {
        double v31 = *(double *)(a1 + v29 + 232);
        v29 += 224;
      }
      while (v31 < v28);
      id v32 = a1 + v29;
      unsigned __int8 v33 = a2;
      if (v29 == 224)
      {
        id v36 = a2;
        while (v32 < (unint64_t)v36)
        {
          uint64_t v34 = v36 - 14;
          unsigned __int8 v37 = *((double *)v36 - 27);
          v36 -= 14;
          if (v37 < v28) {
            goto LABEL_22;
          }
        }
        uint64_t v34 = v36;
      }
      else
      {
        do
        {
          uint64_t v34 = v33 - 14;
          uint64_t v35 = *((double *)v33 - 27);
          v33 -= 14;
        }
        while (v35 >= v28);
      }
LABEL_22:
      unint64_t v10 = v32;
      if (v32 < (unint64_t)v34)
      {
        uint64_t v38 = v34;
        do
        {
          double v270 = *(_OWORD *)v10;
          v282 = *(_OWORD *)(v10 + 16);
          v317 = *(_OWORD *)(v10 + 64);
          v329 = *(_OWORD *)(v10 + 80);
          __int16 v293 = *(_OWORD *)(v10 + 32);
          v305 = *(_OWORD *)(v10 + 48);
          v365 = *(_OWORD *)(v10 + 128);
          v377 = *(_OWORD *)(v10 + 144);
          v341 = *(_OWORD *)(v10 + 96);
          v353 = *(_OWORD *)(v10 + 112);
          *(_OWORD *)v413 = *(_OWORD *)(v10 + 192);
          *(_OWORD *)&v413[16] = *(_OWORD *)(v10 + 208);
          v389 = *(_OWORD *)(v10 + 160);
          v401 = *(_OWORD *)(v10 + 176);
          uint64_t v39 = v38[1];
          *(_OWORD *)unint64_t v10 = *v38;
          *(_OWORD *)(v10 + 16) = v39;
          uint64_t v40 = v38[2];
          id v41 = v38[3];
          unsigned __int8 v42 = v38[5];
          *(_OWORD *)(v10 + 64) = v38[4];
          *(_OWORD *)(v10 + 80) = v42;
          *(_OWORD *)(v10 + 32) = v40;
          *(_OWORD *)(v10 + 48) = v41;
          unint64_t v43 = v38[6];
          unint64_t v44 = v38[7];
          id v45 = v38[9];
          *(_OWORD *)(v10 + 128) = v38[8];
          *(_OWORD *)(v10 + 144) = v45;
          *(_OWORD *)(v10 + 96) = v43;
          *(_OWORD *)(v10 + 112) = v44;
          id v46 = v38[10];
          uint64_t v47 = v38[11];
          uint64_t v48 = v38[12];
          *(_OWORD *)(v10 + 205) = *(long long *)((char *)v38 + 205);
          *(_OWORD *)(v10 + 176) = v47;
          *(_OWORD *)(v10 + 192) = v48;
          *(_OWORD *)(v10 + 160) = v46;
          *uint64_t v38 = v270;
          v38[1] = v282;
          v38[4] = v317;
          v38[5] = v329;
          v38[2] = v293;
          v38[3] = v305;
          v38[8] = v365;
          v38[9] = v377;
          v38[6] = v341;
          v38[7] = v353;
          *(long long *)((char *)v38 + 205) = *(_OWORD *)&v413[13];
          v38[11] = v401;
          v38[12] = *(_OWORD *)v413;
          v38[10] = v389;
          do
          {
            uint64_t v49 = *(double *)(v10 + 232);
            v10 += 224;
          }
          while (v49 < v28);
          do
          {
            uint64_t v50 = *((double *)v38 - 27);
            v38 -= 14;
          }
          while (v50 >= v28);
        }
        while (v10 < (unint64_t)v38);
      }
      if (v10 - 224 != a1)
      {
        uint64_t v51 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v51;
        uint64_t v52 = *(_OWORD *)(v10 - 192);
        uint64_t v53 = *(_OWORD *)(v10 - 176);
        unint64_t v54 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v54;
        *(_OWORD *)(a1 + 32) = v52;
        *(_OWORD *)(a1 + 48) = v53;
        id v55 = *(_OWORD *)(v10 - 128);
        id v56 = *(_OWORD *)(v10 - 112);
        id v57 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v57;
        *(_OWORD *)(a1 + 96) = v55;
        *(_OWORD *)(a1 + 112) = v56;
        id v58 = *(_OWORD *)(v10 - 64);
        id v59 = *(_OWORD *)(v10 - 48);
        double v60 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v59;
        *(_OWORD *)(a1 + 192) = v60;
        *(_OWORD *)(a1 + 160) = v58;
      }
      *(void *)(v10 - 224) = v30;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v233;
      *(_OWORD *)(v10 - 160) = v242;
      *(_OWORD *)(v10 - 144) = v245;
      *(_OWORD *)(v10 - 192) = v236;
      *(_OWORD *)(v10 - 176) = v239;
      *(_OWORD *)(v10 - 96) = v254;
      *(_OWORD *)(v10 - 80) = v257;
      *(_OWORD *)(v10 - 128) = v248;
      *(_OWORD *)(v10 - 112) = v251;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v266[13];
      *(_OWORD *)(v10 - 48) = v263;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v266;
      *(_OWORD *)(v10 - 64) = v260;
      if (v32 < (unint64_t)v34) {
        goto LABEL_33;
      }
      id v61 = sub_1015A2E08(a1, v10 - 224);
      if (sub_1015A2E08(v10, (uint64_t)a2))
      {
        a2 = (long long *)(v10 - 224);
        if (v61) {
          return;
        }
        goto LABEL_1;
      }
      if (!v61)
      {
LABEL_33:
        sub_1015A1BEC(a1, v10 - 224, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v28 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 216) < v28) {
        goto LABEL_12;
      }
      unint64_t v62 = *(void *)a1;
      __int16 v243 = *(_OWORD *)(a1 + 64);
      double v246 = *(_OWORD *)(a1 + 80);
      __int16 v237 = *(_OWORD *)(a1 + 32);
      uint64_t v240 = *(_OWORD *)(a1 + 48);
      __int16 v255 = *(_OWORD *)(a1 + 128);
      double v258 = *(_OWORD *)(a1 + 144);
      __int16 v249 = *(_OWORD *)(a1 + 96);
      double v252 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)__int16 v267 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v267[16] = *(_OWORD *)(a1 + 208);
      __int16 v261 = *(_OWORD *)(a1 + 160);
      uint64_t v264 = *(_OWORD *)(a1 + 176);
      v234 = *(_OWORD *)(a1 + 16);
      if (v28 >= *((double *)a2 - 27))
      {
        uint64_t v65 = a1 + 224;
        do
        {
          unint64_t v10 = v65;
          if (v65 >= (unint64_t)a2) {
            break;
          }
          uint64_t v66 = *(double *)(v65 + 8);
          v65 += 224;
        }
        while (v28 >= v66);
      }
      else
      {
        int v63 = a1;
        do
        {
          unint64_t v10 = v63 + 224;
          id v64 = *(double *)(v63 + 232);
          v63 += 224;
        }
        while (v28 >= v64);
      }
      id v67 = a2;
      if (v10 < (unint64_t)a2)
      {
        unint64_t v68 = a2;
        do
        {
          id v67 = v68 - 14;
          long long v69 = *((double *)v68 - 27);
          v68 -= 14;
        }
        while (v28 < v69);
      }
      while (v10 < (unint64_t)v67)
      {
        __int16 v271 = *(_OWORD *)v10;
        __int16 v283 = *(_OWORD *)(v10 + 16);
        v318 = *(_OWORD *)(v10 + 64);
        v330 = *(_OWORD *)(v10 + 80);
        double v294 = *(_OWORD *)(v10 + 32);
        v306 = *(_OWORD *)(v10 + 48);
        v366 = *(_OWORD *)(v10 + 128);
        v378 = *(_OWORD *)(v10 + 144);
        v342 = *(_OWORD *)(v10 + 96);
        v354 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v414 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v414[16] = *(_OWORD *)(v10 + 208);
        v390 = *(_OWORD *)(v10 + 160);
        v402 = *(_OWORD *)(v10 + 176);
        long long v70 = v67[1];
        *(_OWORD *)unint64_t v10 = *v67;
        *(_OWORD *)(v10 + 16) = v70;
        long long v71 = v67[2];
        long long v72 = v67[3];
        id v73 = v67[5];
        *(_OWORD *)(v10 + 64) = v67[4];
        *(_OWORD *)(v10 + 80) = v73;
        *(_OWORD *)(v10 + 32) = v71;
        *(_OWORD *)(v10 + 48) = v72;
        int v74 = v67[6];
        long long v75 = v67[7];
        uint64_t v76 = v67[9];
        *(_OWORD *)(v10 + 128) = v67[8];
        *(_OWORD *)(v10 + 144) = v76;
        *(_OWORD *)(v10 + 96) = v74;
        *(_OWORD *)(v10 + 112) = v75;
        id v77 = v67[10];
        uint64_t v78 = v67[11];
        __int16 v79 = v67[12];
        *(_OWORD *)(v10 + 205) = *(long long *)((char *)v67 + 205);
        *(_OWORD *)(v10 + 176) = v78;
        *(_OWORD *)(v10 + 192) = v79;
        *(_OWORD *)(v10 + 160) = v77;
        *id v67 = v271;
        v67[1] = v283;
        v67[4] = v318;
        v67[5] = v330;
        v67[2] = v294;
        v67[3] = v306;
        v67[8] = v366;
        v67[9] = v378;
        v67[6] = v342;
        v67[7] = v354;
        *(long long *)((char *)v67 + 205) = *(_OWORD *)&v414[13];
        v67[11] = v402;
        v67[12] = *(_OWORD *)v414;
        v67[10] = v390;
        do
        {
          uint64_t v80 = *(double *)(v10 + 232);
          v10 += 224;
        }
        while (v28 >= v80);
        do
        {
          __int16 v81 = *((double *)v67 - 27);
          v67 -= 14;
        }
        while (v28 < v81);
      }
      unint64_t v4 = v10 - 224 >= a1;
      char v5 = v10 - 224 == a1;
      if (v10 - 224 != a1)
      {
        unint64_t v82 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v82;
        __int16 v83 = *(_OWORD *)(v10 - 192);
        uint64_t v84 = *(_OWORD *)(v10 - 176);
        __int16 v85 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v85;
        *(_OWORD *)(a1 + 32) = v83;
        *(_OWORD *)(a1 + 48) = v84;
        double v86 = *(_OWORD *)(v10 - 128);
        uint64_t v87 = *(_OWORD *)(v10 - 112);
        double v88 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v88;
        *(_OWORD *)(a1 + 96) = v86;
        *(_OWORD *)(a1 + 112) = v87;
        __int16 v89 = *(_OWORD *)(v10 - 64);
        uint64_t v90 = *(_OWORD *)(v10 - 48);
        __int16 v91 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v90;
        *(_OWORD *)(a1 + 192) = v91;
        *(_OWORD *)(a1 + 160) = v89;
      }
      a4 = 0;
      *(void *)(v10 - 224) = v62;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v234;
      *(_OWORD *)(v10 - 160) = v243;
      *(_OWORD *)(v10 - 144) = v246;
      *(_OWORD *)(v10 - 192) = v237;
      *(_OWORD *)(v10 - 176) = v240;
      *(_OWORD *)(v10 - 96) = v255;
      *(_OWORD *)(v10 - 80) = v258;
      *(_OWORD *)(v10 - 128) = v249;
      *(_OWORD *)(v10 - 112) = v252;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v267[13];
      *(_OWORD *)(v10 - 48) = v264;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v267;
      *(_OWORD *)(v10 - 64) = v261;
    }
  }
  id v135 = (long long *)(v10 + 224);
  uint64_t v137 = (long long *)v10 == a2 || v135 == a2;
  if (a4)
  {
    if (!v137)
    {
      uint64_t v138 = 0;
      unint64_t v139 = v10;
      do
      {
        id v140 = v135;
        unint64_t v141 = *(double *)(v139 + 232);
        if (v141 < *(double *)(v139 + 8))
        {
          unint64_t v142 = *(void *)v135;
          v396 = *(_OWORD *)(v139 + 400);
          *(_OWORD *)v408 = *(_OWORD *)(v139 + 416);
          *(_OWORD *)&v408[16] = *(_OWORD *)(v139 + 432);
          v348 = *(_OWORD *)(v139 + 336);
          v360 = *(_OWORD *)(v139 + 352);
          v372 = *(_OWORD *)(v139 + 368);
          v384 = *(_OWORD *)(v139 + 384);
          char v300 = *(_OWORD *)(v139 + 272);
          v312 = *(_OWORD *)(v139 + 288);
          v324 = *(_OWORD *)(v139 + 304);
          v336 = *(_OWORD *)(v139 + 320);
          std::string::size_type v144 = *(_OWORD *)(v139 + 240);
          id v143 = *(_OWORD *)(v139 + 256);
          uint64_t v145 = v138;
          v277 = v144;
          while (1)
          {
            std::string::size_type v146 = (double *)(v10 + v145);
            __int16 v147 = *(_OWORD *)(v10 + v145 + 176);
            *((_OWORD *)v146 + 24) = *(_OWORD *)(v10 + v145 + 160);
            *((_OWORD *)v146 + 25) = v147;
            *((_OWORD *)v146 + 26) = *(_OWORD *)(v10 + v145 + 192);
            *(_OWORD *)(v10 + v145 + 429) = *(_OWORD *)(v10 + v145 + 205);
            id v148 = *(_OWORD *)(v10 + v145 + 112);
            *((_OWORD *)v146 + 20) = *(_OWORD *)(v10 + v145 + 96);
            *((_OWORD *)v146 + 21) = v148;
            id v149 = *(_OWORD *)(v10 + v145 + 144);
            *((_OWORD *)v146 + 22) = *(_OWORD *)(v10 + v145 + 128);
            *((_OWORD *)v146 + 23) = v149;
            id v150 = *(_OWORD *)(v10 + v145 + 48);
            *((_OWORD *)v146 + 16) = *(_OWORD *)(v10 + v145 + 32);
            *((_OWORD *)v146 + 17) = v150;
            id v151 = *(_OWORD *)(v10 + v145 + 80);
            *((_OWORD *)v146 + 18) = *(_OWORD *)(v10 + v145 + 64);
            *((_OWORD *)v146 + 19) = v151;
            double v152 = *(_OWORD *)(v10 + v145 + 16);
            *((_OWORD *)v146 + 14) = *(_OWORD *)(v10 + v145);
            *((_OWORD *)v146 + 15) = v152;
            if (!v145) {
              break;
            }
            v145 -= 224;
            if (v141 >= *(v146 - 27))
            {
              id v153 = v10 + v145 + 224;
              goto LABEL_85;
            }
          }
          id v153 = v10;
LABEL_85:
          *(void *)id v153 = v142;
          *(double *)(v153 + 8) = v141;
          *(_OWORD *)(v153 + 176) = v396;
          *(_OWORD *)(v153 + 192) = *(_OWORD *)v408;
          *(_OWORD *)(v153 + 205) = *(_OWORD *)&v408[13];
          *(_OWORD *)(v153 + 112) = v348;
          *(_OWORD *)(v153 + 128) = v360;
          *(_OWORD *)(v153 + 144) = v372;
          *(_OWORD *)(v153 + 160) = v384;
          *(_OWORD *)(v153 + 48) = v300;
          *(_OWORD *)(v153 + 64) = v312;
          *(_OWORD *)(v153 + 80) = v324;
          *(_OWORD *)(v153 + 96) = v336;
          *(_OWORD *)(v153 + 16) = v277;
          *(_OWORD *)(v153 + 32) = v143;
        }
        id v135 = v140 + 14;
        v138 += 224;
        unint64_t v139 = (unint64_t)v140;
      }
      while (v140 + 14 != a2);
    }
  }
  else if (!v137)
  {
    do
    {
      char v222 = v135;
      uint64_t v223 = *(double *)(a1 + 232);
      if (v223 < *(double *)(a1 + 8))
      {
        char v224 = *(void *)v135;
        v399 = *(_OWORD *)(a1 + 400);
        *(_OWORD *)v411 = *(_OWORD *)(a1 + 416);
        *(_OWORD *)&v411[16] = *(_OWORD *)(a1 + 432);
        v351 = *(_OWORD *)(a1 + 336);
        v363 = *(_OWORD *)(a1 + 352);
        v375 = *(_OWORD *)(a1 + 368);
        v387 = *(_OWORD *)(a1 + 384);
        v303 = *(_OWORD *)(a1 + 272);
        v315 = *(_OWORD *)(a1 + 288);
        v327 = *(_OWORD *)(a1 + 304);
        v339 = *(_OWORD *)(a1 + 320);
        v280 = *(_OWORD *)(a1 + 240);
        __int16 v291 = *(_OWORD *)(a1 + 256);
        do
        {
          uint64_t v225 = a1 + 224;
          int v226 = *(_OWORD *)(a1 + 176);
          *(_OWORD *)(a1 + 384) = *(_OWORD *)(a1 + 160);
          *(_OWORD *)(a1 + 400) = v226;
          *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 192);
          char v227 = *(_OWORD *)(a1 + 112);
          *(_OWORD *)(a1 + 320) = *(_OWORD *)(a1 + 96);
          *(_OWORD *)(a1 + 336) = v227;
          uint64_t v228 = *(_OWORD *)(a1 + 144);
          *(_OWORD *)(a1 + 352) = *(_OWORD *)(a1 + 128);
          *(_OWORD *)(a1 + 368) = v228;
          __int16 v229 = *(_OWORD *)(a1 + 48);
          *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 32);
          *(_OWORD *)(a1 + 272) = v229;
          int v230 = *(_OWORD *)(a1 + 80);
          *(_OWORD *)(a1 + 288) = *(_OWORD *)(a1 + 64);
          *(_OWORD *)(a1 + 304) = v230;
          v231 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)(a1 + 224) = *(_OWORD *)a1;
          *(_OWORD *)(a1 + 240) = v231;
          unint64_t v121 = v223 < *(double *)(a1 - 216);
          int v232 = *(_OWORD *)(a1 + 205);
          a1 -= 224;
          *(_OWORD *)(v225 + 205) = v232;
        }
        while (v121);
        *(void *)(a1 + 224) = v224;
        *(double *)(a1 + 232) = v223;
        *(_OWORD *)(a1 + 240) = v280;
        *(_OWORD *)(a1 + 288) = v315;
        *(_OWORD *)(a1 + 304) = v327;
        *(_OWORD *)(a1 + 256) = v291;
        *(_OWORD *)(a1 + 272) = v303;
        *(_OWORD *)(a1 + 352) = v363;
        *(_OWORD *)(a1 + 368) = v375;
        *(_OWORD *)(a1 + 320) = v339;
        *(_OWORD *)(a1 + 336) = v351;
        *(_OWORD *)(a1 + 429) = *(_OWORD *)&v411[13];
        *(_OWORD *)(a1 + 400) = v399;
        *(_OWORD *)(a1 + 416) = *(_OWORD *)v411;
        *(_OWORD *)(a1 + 384) = v387;
      }
      id v135 = v222 + 14;
      a1 = (unint64_t)v222;
    }
    while (v222 + 14 != a2);
  }
}

  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    unint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v10) >> 5);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*((double *)a2 - 27) < *(double *)(v10 + 8))
          {
            double v272 = *(_OWORD *)v10;
            uint64_t v284 = *(_OWORD *)(v10 + 16);
            v319 = *(_OWORD *)(v10 + 64);
            v331 = *(_OWORD *)(v10 + 80);
            v295 = *(_OWORD *)(v10 + 32);
            v307 = *(_OWORD *)(v10 + 48);
            v367 = *(_OWORD *)(v10 + 128);
            v379 = *(_OWORD *)(v10 + 144);
            v343 = *(_OWORD *)(v10 + 96);
            v355 = *(_OWORD *)(v10 + 112);
            *(_OWORD *)v415 = *(_OWORD *)(v10 + 192);
            *(_OWORD *)&v415[16] = *(_OWORD *)(v10 + 208);
            v391 = *(_OWORD *)(v10 + 160);
            v403 = *(_OWORD *)(v10 + 176);
            unint64_t v92 = *(a2 - 13);
            *(_OWORD *)unint64_t v10 = *(a2 - 14);
            *(_OWORD *)(v10 + 16) = v92;
            __int16 v93 = *(a2 - 12);
            uint64_t v94 = *(a2 - 11);
            __int16 v95 = *(a2 - 9);
            *(_OWORD *)(v10 + 64) = *(a2 - 10);
            *(_OWORD *)(v10 + 80) = v95;
            *(_OWORD *)(v10 + 32) = v93;
            *(_OWORD *)(v10 + 48) = v94;
            double v96 = *(a2 - 8);
            id v97 = *(a2 - 7);
            id v98 = *(a2 - 5);
            *(_OWORD *)(v10 + 128) = *(a2 - 6);
            *(_OWORD *)(v10 + 144) = v98;
            *(_OWORD *)(v10 + 96) = v96;
            *(_OWORD *)(v10 + 112) = v97;
            int v99 = *(a2 - 4);
            int v100 = *(a2 - 3);
            uint64_t v101 = *(a2 - 2);
            *(_OWORD *)(v10 + 205) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 176) = v100;
            *(_OWORD *)(v10 + 192) = v101;
            *(_OWORD *)(v10 + 160) = v99;
            *(a2 - 14) = v272;
            *(a2 - 13) = v284;
            *(a2 - 10) = v319;
            *(a2 - 9) = v331;
            *(a2 - 12) = v295;
            *(a2 - 11) = v307;
            *(a2 - 6) = v367;
            *(a2 - 5) = v379;
            *(a2 - 8) = v343;
            *(a2 - 7) = v355;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v415[13];
            *(a2 - 3) = v403;
            *(a2 - 2) = *(_OWORD *)v415;
            *(a2 - 4) = v391;
          }
          break;
        case 3uLL:
          sub_1015A0F44((long long *)v10, (long long *)(v10 + 224), a2 - 14);
          break;
        case 4uLL:
          sub_1015A1948(v10, v10 + 224, v10 + 448, (uint64_t)(a2 - 14));
          break;
        case 5uLL:
          id v102 = (long long *)(v10 + 224);
          int64_t v103 = (long long *)(v10 + 448);
          unint64_t v104 = (long long *)(v10 + 672);
          sub_1015A1948(v10, v10 + 224, v10 + 448, v10 + 672);
          if (*((double *)a2 - 27) < *(double *)(v10 + 680))
          {
            v320 = *(_OWORD *)(v10 + 736);
            v332 = *(_OWORD *)(v10 + 752);
            v296 = *(_OWORD *)(v10 + 704);
            v308 = *(_OWORD *)(v10 + 720);
            v368 = *(_OWORD *)(v10 + 800);
            v380 = *(_OWORD *)(v10 + 816);
            v344 = *(_OWORD *)(v10 + 768);
            v356 = *(_OWORD *)(v10 + 784);
            *(_OWORD *)v416 = *(_OWORD *)(v10 + 864);
            *(_OWORD *)&v416[16] = *(_OWORD *)(v10 + 880);
            v392 = *(_OWORD *)(v10 + 832);
            v404 = *(_OWORD *)(v10 + 848);
            uint64_t v273 = *v104;
            __int16 v285 = *(_OWORD *)(v10 + 688);
            uint64_t v105 = *(a2 - 13);
            *unint64_t v104 = *(a2 - 14);
            *(_OWORD *)(v10 + 688) = v105;
            unint64_t v106 = *(a2 - 12);
            uint64_t v107 = *(a2 - 11);
            id v108 = *(a2 - 9);
            *(_OWORD *)(v10 + 736) = *(a2 - 10);
            *(_OWORD *)(v10 + 752) = v108;
            *(_OWORD *)(v10 + 704) = v106;
            *(_OWORD *)(v10 + 720) = v107;
            uint64_t v109 = *(a2 - 8);
            uint64_t v110 = *(a2 - 7);
            long long v111 = *(a2 - 5);
            *(_OWORD *)(v10 + 800) = *(a2 - 6);
            *(_OWORD *)(v10 + 816) = v111;
            *(_OWORD *)(v10 + 768) = v109;
            *(_OWORD *)(v10 + 784) = v110;
            int v112 = *(a2 - 4);
            id v113 = *(a2 - 3);
            uint64_t v114 = *(a2 - 2);
            *(_OWORD *)(v10 + 877) = *(long long *)((char *)a2 - 19);
            *(_OWORD *)(v10 + 848) = v113;
            *(_OWORD *)(v10 + 864) = v114;
            *(_OWORD *)(v10 + 832) = v112;
            *(a2 - 14) = v273;
            *(a2 - 13) = v285;
            *(a2 - 10) = v320;
            *(a2 - 9) = v332;
            *(a2 - 12) = v296;
            *(a2 - 11) = v308;
            *(a2 - 6) = v368;
            *(a2 - 5) = v380;
            *(a2 - 8) = v344;
            *(a2 - 7) = v356;
            *(long long *)((char *)a2 - 19) = *(_OWORD *)&v416[13];
            *(a2 - 3) = v404;
            *(a2 - 2) = *(_OWORD *)v416;
            *(a2 - 4) = v392;
            if (*(double *)(v10 + 680) < *(double *)(v10 + 456))
            {
              v393 = *(_OWORD *)(v10 + 608);
              v405 = *(_OWORD *)(v10 + 624);
              *(_OWORD *)v417 = *(_OWORD *)(v10 + 640);
              *(_OWORD *)&v417[16] = *(_OWORD *)(v10 + 656);
              v345 = *(_OWORD *)(v10 + 544);
              v357 = *(_OWORD *)(v10 + 560);
              v369 = *(_OWORD *)(v10 + 576);
              v381 = *(_OWORD *)(v10 + 592);
              uint64_t v297 = *(_OWORD *)(v10 + 480);
              v309 = *(_OWORD *)(v10 + 496);
              v321 = *(_OWORD *)(v10 + 512);
              v333 = *(_OWORD *)(v10 + 528);
              uint64_t v274 = *v103;
              int v286 = *(_OWORD *)(v10 + 464);
              uint64_t v115 = *(_OWORD *)(v10 + 848);
              *(_OWORD *)(v10 + 608) = *(_OWORD *)(v10 + 832);
              *(_OWORD *)(v10 + 624) = v115;
              *(_OWORD *)(v10 + 640) = *(_OWORD *)(v10 + 864);
              *(_OWORD *)(v10 + 653) = *(_OWORD *)(v10 + 877);
              double v116 = *(_OWORD *)(v10 + 784);
              *(_OWORD *)(v10 + 544) = *(_OWORD *)(v10 + 768);
              *(_OWORD *)(v10 + 560) = v116;
              double v117 = *(_OWORD *)(v10 + 816);
              *(_OWORD *)(v10 + 576) = *(_OWORD *)(v10 + 800);
              *(_OWORD *)(v10 + 592) = v117;
              id v118 = *(_OWORD *)(v10 + 720);
              *(_OWORD *)(v10 + 480) = *(_OWORD *)(v10 + 704);
              *(_OWORD *)(v10 + 496) = v118;
              id v119 = *(_OWORD *)(v10 + 752);
              *(_OWORD *)(v10 + 512) = *(_OWORD *)(v10 + 736);
              *(_OWORD *)(v10 + 528) = v119;
              unint64_t v120 = *(_OWORD *)(v10 + 688);
              NSObject *v103 = *v104;
              *(_OWORD *)(v10 + 464) = v120;
              *(_OWORD *)(v10 + 832) = v393;
              *(_OWORD *)(v10 + 848) = v405;
              *(_OWORD *)(v10 + 864) = *(_OWORD *)v417;
              *(_OWORD *)(v10 + 877) = *(_OWORD *)&v417[13];
              *(_OWORD *)(v10 + 768) = v345;
              *(_OWORD *)(v10 + 784) = v357;
              *(_OWORD *)(v10 + 800) = v369;
              *(_OWORD *)(v10 + 816) = v381;
              *(_OWORD *)(v10 + 704) = v297;
              *(_OWORD *)(v10 + 720) = v309;
              *(_OWORD *)(v10 + 736) = v321;
              *(_OWORD *)(v10 + 752) = v333;
              unint64_t v121 = *(double *)(v10 + 456) < *(double *)(v10 + 232);
              *unint64_t v104 = v274;
              *(_OWORD *)(v10 + 688) = v286;
              if (v121)
              {
                v394 = *(_OWORD *)(v10 + 384);
                v406 = *(_OWORD *)(v10 + 400);
                *(_OWORD *)v418 = *(_OWORD *)(v10 + 416);
                *(_OWORD *)&v418[16] = *(_OWORD *)(v10 + 432);
                v346 = *(_OWORD *)(v10 + 320);
                v358 = *(_OWORD *)(v10 + 336);
                v370 = *(_OWORD *)(v10 + 352);
                v382 = *(_OWORD *)(v10 + 368);
                uint64_t v298 = *(_OWORD *)(v10 + 256);
                v310 = *(_OWORD *)(v10 + 272);
                v322 = *(_OWORD *)(v10 + 288);
                v334 = *(_OWORD *)(v10 + 304);
                uint64_t v275 = *v102;
                __int16 v287 = *(_OWORD *)(v10 + 240);
                double v122 = *(_OWORD *)(v10 + 624);
                *(_OWORD *)(v10 + 384) = *(_OWORD *)(v10 + 608);
                *(_OWORD *)(v10 + 400) = v122;
                *(_OWORD *)(v10 + 416) = *(_OWORD *)(v10 + 640);
                *(_OWORD *)(v10 + 429) = *(_OWORD *)(v10 + 653);
                double v123 = *(_OWORD *)(v10 + 560);
                *(_OWORD *)(v10 + 320) = *(_OWORD *)(v10 + 544);
                *(_OWORD *)(v10 + 336) = v123;
                id v124 = *(_OWORD *)(v10 + 592);
                *(_OWORD *)(v10 + 352) = *(_OWORD *)(v10 + 576);
                *(_OWORD *)(v10 + 368) = v124;
                id v125 = *(_OWORD *)(v10 + 496);
                *(_OWORD *)(v10 + 256) = *(_OWORD *)(v10 + 480);
                *(_OWORD *)(v10 + 272) = v125;
                unint64_t v126 = *(_OWORD *)(v10 + 528);
                *(_OWORD *)(v10 + 288) = *(_OWORD *)(v10 + 512);
                *(_OWORD *)(v10 + 304) = v126;
                uint64_t v127 = *(_OWORD *)(v10 + 464);
                char *v102 = *v103;
                *(_OWORD *)(v10 + 240) = v127;
                *(_OWORD *)(v10 + 608) = v394;
                *(_OWORD *)(v10 + 624) = v406;
                *(_OWORD *)(v10 + 640) = *(_OWORD *)v418;
                *(_OWORD *)(v10 + 653) = *(_OWORD *)&v418[13];
                *(_OWORD *)(v10 + 544) = v346;
                *(_OWORD *)(v10 + 560) = v358;
                *(_OWORD *)(v10 + 576) = v370;
                *(_OWORD *)(v10 + 592) = v382;
                *(_OWORD *)(v10 + 480) = v298;
                *(_OWORD *)(v10 + 496) = v310;
                *(_OWORD *)(v10 + 512) = v322;
                *(_OWORD *)(v10 + 528) = v334;
                unint64_t v121 = *(double *)(v10 + 232) < *(double *)(v10 + 8);
                NSObject *v103 = v275;
                *(_OWORD *)(v10 + 464) = v287;
                if (v121)
                {
                  v276 = *(_OWORD *)v10;
                  v288 = *(_OWORD *)(v10 + 16);
                  v323 = *(_OWORD *)(v10 + 64);
                  v335 = *(_OWORD *)(v10 + 80);
                  v299 = *(_OWORD *)(v10 + 32);
                  v311 = *(_OWORD *)(v10 + 48);
                  v371 = *(_OWORD *)(v10 + 128);
                  v383 = *(_OWORD *)(v10 + 144);
                  v347 = *(_OWORD *)(v10 + 96);
                  v359 = *(_OWORD *)(v10 + 112);
                  *(_OWORD *)v419 = *(_OWORD *)(v10 + 192);
                  *(_OWORD *)&v419[16] = *(_OWORD *)(v10 + 208);
                  v395 = *(_OWORD *)(v10 + 160);
                  v407 = *(_OWORD *)(v10 + 176);
                  id v128 = *(_OWORD *)(v10 + 304);
                  *(_OWORD *)(v10 + 64) = *(_OWORD *)(v10 + 288);
                  *(_OWORD *)(v10 + 80) = v128;
                  uint64_t v129 = *(_OWORD *)(v10 + 272);
                  *(_OWORD *)(v10 + 32) = *(_OWORD *)(v10 + 256);
                  *(_OWORD *)(v10 + 48) = v129;
                  double v130 = *(_OWORD *)(v10 + 368);
                  *(_OWORD *)(v10 + 128) = *(_OWORD *)(v10 + 352);
                  *(_OWORD *)(v10 + 144) = v130;
                  uint64_t v131 = *(_OWORD *)(v10 + 336);
                  *(_OWORD *)(v10 + 96) = *(_OWORD *)(v10 + 320);
                  *(_OWORD *)(v10 + 112) = v131;
                  *(_OWORD *)(v10 + 205) = *(_OWORD *)(v10 + 429);
                  id v132 = *(_OWORD *)(v10 + 416);
                  uint64_t v133 = *(_OWORD *)(v10 + 384);
                  *(_OWORD *)(v10 + 176) = *(_OWORD *)(v10 + 400);
                  *(_OWORD *)(v10 + 192) = v132;
                  *(_OWORD *)(v10 + 160) = v133;
                  uint64_t v134 = *(_OWORD *)(v10 + 240);
                  *(_OWORD *)unint64_t v10 = *v102;
                  *(_OWORD *)(v10 + 16) = v134;
                  *(_OWORD *)(v10 + 384) = v395;
                  *(_OWORD *)(v10 + 400) = v407;
                  *(_OWORD *)(v10 + 416) = *(_OWORD *)v419;
                  *(_OWORD *)(v10 + 429) = *(_OWORD *)&v419[13];
                  *(_OWORD *)(v10 + 320) = v347;
                  *(_OWORD *)(v10 + 336) = v359;
                  *(_OWORD *)(v10 + 352) = v371;
                  *(_OWORD *)(v10 + 368) = v383;
                  *(_OWORD *)(v10 + 256) = v299;
                  *(_OWORD *)(v10 + 272) = v311;
                  *(_OWORD *)(v10 + 288) = v323;
                  *(_OWORD *)(v10 + 304) = v335;
                  char *v102 = v276;
                  *(_OWORD *)(v10 + 240) = v288;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5375) {
      break;
    }
    if (!a3)
    {
      if ((long long *)v10 == a2) {
        return;
      }
      unint64_t v154 = (v12 - 2) >> 1;
      int v155 = v154;
      do
      {
        id v156 = v155;
        if (v154 >= v155)
        {
          uint64_t v157 = (2 * v155) | 1;
          unint64_t v158 = v10 + 224 * v157;
          if (2 * v155 + 2 < (uint64_t)v12 && *(double *)(v10 + 224 * v157 + 8) < *(double *)(v158 + 232))
          {
            v158 += 224;
            uint64_t v157 = 2 * v155 + 2;
          }
          id v159 = *(double *)(v10 + 224 * v155 + 8);
          if (*(double *)(v158 + 8) >= v159)
          {
            id v160 = v10 + 224 * v155;
            id v161 = *(void *)v160;
            v278 = *(_OWORD *)(v160 + 16);
            v313 = *(_OWORD *)(v160 + 64);
            v325 = *(_OWORD *)(v160 + 80);
            __int16 v289 = *(_OWORD *)(v160 + 32);
            v301 = *(_OWORD *)(v160 + 48);
            v361 = *(_OWORD *)(v160 + 128);
            v373 = *(_OWORD *)(v160 + 144);
            v337 = *(_OWORD *)(v160 + 96);
            v349 = *(_OWORD *)(v160 + 112);
            *(_OWORD *)v409 = *(_OWORD *)(v160 + 192);
            *(_OWORD *)&v409[16] = *(_OWORD *)(v160 + 208);
            v385 = *(_OWORD *)(v160 + 160);
            v397 = *(_OWORD *)(v160 + 176);
            do
            {
              id v162 = (_OWORD *)v160;
              id v160 = v158;
              __int16 v163 = *(_OWORD *)(v158 + 16);
              *id v162 = *(_OWORD *)v158;
              v162[1] = v163;
              id v164 = *(_OWORD *)(v158 + 32);
              __int16 v165 = *(_OWORD *)(v158 + 48);
              double v166 = *(_OWORD *)(v158 + 80);
              v162[4] = *(_OWORD *)(v158 + 64);
              v162[5] = v166;
              v162[2] = v164;
              v162[3] = v165;
              id v167 = *(_OWORD *)(v158 + 96);
              id v168 = *(_OWORD *)(v158 + 112);
              __int16 v169 = *(_OWORD *)(v158 + 144);
              v162[8] = *(_OWORD *)(v158 + 128);
              v162[9] = v169;
              v162[6] = v167;
              v162[7] = v168;
              double v170 = *(_OWORD *)(v158 + 160);
              __int16 v171 = *(_OWORD *)(v158 + 176);
              int v172 = *(_OWORD *)(v158 + 192);
              *(_OWORD *)((char *)v162 + 205) = *(_OWORD *)(v158 + 205);
              v162[11] = v171;
              v162[12] = v172;
              v162[10] = v170;
              if (v154 < v157) {
                break;
              }
              __int16 v173 = (2 * v157) | 1;
              unint64_t v158 = v10 + 224 * v173;
              uint64_t v174 = 2 * v157 + 2;
              if (v174 < (uint64_t)v12 && *(double *)(v10 + 224 * v173 + 8) < *(double *)(v158 + 232))
              {
                v158 += 224;
                __int16 v173 = v174;
              }
              uint64_t v157 = v173;
            }
            while (*(double *)(v158 + 8) >= v159);
            *(void *)id v160 = v161;
            *(double *)(v160 + 8) = v159;
            *(_OWORD *)(v160 + 176) = v397;
            *(_OWORD *)(v160 + 192) = *(_OWORD *)v409;
            *(_OWORD *)(v160 + 205) = *(_OWORD *)&v409[13];
            *(_OWORD *)(v160 + 112) = v349;
            *(_OWORD *)(v160 + 128) = v361;
            *(_OWORD *)(v160 + 144) = v373;
            *(_OWORD *)(v160 + 160) = v385;
            *(_OWORD *)(v160 + 48) = v301;
            *(_OWORD *)(v160 + 64) = v313;
            *(_OWORD *)(v160 + 80) = v325;
            *(_OWORD *)(v160 + 96) = v337;
            *(_OWORD *)(v160 + 16) = v278;
            *(_OWORD *)(v160 + 32) = v289;
          }
        }
        int v155 = v156 - 1;
      }
      while (v156);
      uint64_t v175 = (((unint64_t)v11 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      while (2)
      {
        double v176 = 0;
        char v279 = *(_OWORD *)v10;
        int v290 = *(_OWORD *)(v10 + 16);
        v326 = *(_OWORD *)(v10 + 64);
        v338 = *(_OWORD *)(v10 + 80);
        id v302 = *(_OWORD *)(v10 + 32);
        v314 = *(_OWORD *)(v10 + 48);
        v374 = *(_OWORD *)(v10 + 128);
        v386 = *(_OWORD *)(v10 + 144);
        v350 = *(_OWORD *)(v10 + 96);
        v362 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v420 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v420[16] = *(_OWORD *)(v10 + 208);
        v398 = *(_OWORD *)(v10 + 160);
        v410 = *(_OWORD *)(v10 + 176);
        int v177 = v10;
        do
        {
          long long v178 = (_OWORD *)v177;
          long long v179 = v176 + 1;
          v177 += 224 * (v176 + 1);
          long long v180 = 2 * v176;
          double v176 = (2 * v176) | 1;
          long long v181 = v180 + 2;
          if (v181 < v175 && *((double *)&v178[14 * v179] + 1) < *(double *)(v177 + 232))
          {
            v177 += 224;
            double v176 = v181;
          }
          long long v182 = *(_OWORD *)(v177 + 16);
          void *v178 = *(_OWORD *)v177;
          v178[1] = v182;
          unint64_t v183 = *(_OWORD *)(v177 + 32);
          long long v184 = *(_OWORD *)(v177 + 48);
          long long v185 = *(_OWORD *)(v177 + 80);
          v178[4] = *(_OWORD *)(v177 + 64);
          v178[5] = v185;
          v178[2] = v183;
          v178[3] = v184;
          long long v186 = *(_OWORD *)(v177 + 96);
          long long v187 = *(_OWORD *)(v177 + 112);
          std::string v188 = *(_OWORD *)(v177 + 144);
          v178[8] = *(_OWORD *)(v177 + 128);
          v178[9] = v188;
          v178[6] = v186;
          v178[7] = v187;
          float v189 = *(_OWORD *)(v177 + 160);
          long long v190 = *(_OWORD *)(v177 + 176);
          long long v191 = *(_OWORD *)(v177 + 192);
          *(_OWORD *)((char *)v178 + 205) = *(_OWORD *)(v177 + 205);
          v178[11] = v190;
          v178[12] = v191;
          v178[10] = v189;
        }
        while (v176 <= (uint64_t)((unint64_t)(v175 - 2) >> 1));
        a2 -= 14;
        if ((long long *)v177 != a2)
        {
          unint64_t v192 = a2[1];
          *(_OWORD *)int v177 = *a2;
          *(_OWORD *)(v177 + 16) = v192;
          long long v193 = a2[2];
          long long v194 = a2[3];
          long long v195 = a2[5];
          *(_OWORD *)(v177 + 64) = a2[4];
          *(_OWORD *)(v177 + 80) = v195;
          *(_OWORD *)(v177 + 32) = v193;
          *(_OWORD *)(v177 + 48) = v194;
          long long v196 = a2[6];
          long long v197 = a2[7];
          long long v198 = a2[9];
          *(_OWORD *)(v177 + 128) = a2[8];
          *(_OWORD *)(v177 + 144) = v198;
          *(_OWORD *)(v177 + 96) = v196;
          *(_OWORD *)(v177 + 112) = v197;
          long long v199 = a2[10];
          long long v200 = a2[11];
          double v201 = a2[12];
          *(_OWORD *)(v177 + 205) = *(long long *)((char *)a2 + 205);
          *(_OWORD *)(v177 + 176) = v200;
          *(_OWORD *)(v177 + 192) = v201;
          *(_OWORD *)(v177 + 160) = v199;
          *a2 = v279;
          a2[1] = v290;
          a2[4] = v326;
          a2[5] = v338;
          a2[2] = v302;
          a2[3] = v314;
          a2[8] = v374;
          a2[9] = v386;
          a2[6] = v350;
          a2[7] = v362;
          *(long long *)((char *)a2 + 205) = *(_OWORD *)&v420[13];
          a2[11] = v410;
          a2[12] = *(_OWORD *)v420;
          a2[10] = v398;
          double v202 = v177 - v10 + 224;
          if (v202 >= 225)
          {
            __int16 v203 = (unint64_t)(((((unint64_t)v202 >> 5) * (unsigned __int128)0x2492492492492493uLL) >> 64)
                                    - 2) >> 1;
            __int16 v204 = *(double *)(v177 + 8);
            if (*(double *)(v10 + 224 * v203 + 8) < v204)
            {
              unint64_t v205 = *(void *)v177;
              __int16 v235 = *(_OWORD *)(v177 + 16);
              uint64_t v244 = *(_OWORD *)(v177 + 64);
              __int16 v247 = *(_OWORD *)(v177 + 80);
              double v238 = *(_OWORD *)(v177 + 32);
              __int16 v241 = *(_OWORD *)(v177 + 48);
              v256 = *(_OWORD *)(v177 + 128);
              __int16 v259 = *(_OWORD *)(v177 + 144);
              double v250 = *(_OWORD *)(v177 + 96);
              __int16 v253 = *(_OWORD *)(v177 + 112);
              *(_OWORD *)int v268 = *(_OWORD *)(v177 + 192);
              *(_OWORD *)&v268[16] = *(_OWORD *)(v177 + 208);
              uint64_t v262 = *(_OWORD *)(v177 + 160);
              __int16 v265 = *(_OWORD *)(v177 + 176);
              do
              {
                __int16 v206 = (_OWORD *)v177;
                int v177 = v10 + 224 * v203;
                double v207 = *(_OWORD *)(v177 + 16);
                *__int16 v206 = *(_OWORD *)v177;
                v206[1] = v207;
                __int16 v208 = *(_OWORD *)(v177 + 32);
                uint64_t v209 = *(_OWORD *)(v177 + 48);
                int v210 = *(_OWORD *)(v177 + 80);
                v206[4] = *(_OWORD *)(v177 + 64);
                v206[5] = v210;
                void v206[2] = v208;
                v206[3] = v209;
                __int16 v211 = *(_OWORD *)(v177 + 96);
                int v212 = *(_OWORD *)(v177 + 112);
                double v213 = *(_OWORD *)(v177 + 144);
                v206[8] = *(_OWORD *)(v177 + 128);
                v206[9] = v213;
                v206[6] = v211;
                v206[7] = v212;
                __int16 v214 = *(_OWORD *)(v177 + 160);
                uint64_t v215 = *(_OWORD *)(v177 + 176);
                int v216 = *(_OWORD *)(v177 + 192);
                *(_OWORD *)((char *)v206 + 205) = *(_OWORD *)(v177 + 205);
                v206[11] = v215;
                v206[12] = v216;
                v206[10] = v214;
                if (!v203) {
                  break;
                }
                __int16 v203 = (v203 - 1) >> 1;
              }
              while (*(double *)(v10 + 224 * v203 + 8) < v204);
              *(void *)int v177 = v205;
              *(double *)(v177 + 8) = v204;
              *(_OWORD *)(v177 + 16) = v235;
              *(_OWORD *)(v177 + 64) = v244;
              *(_OWORD *)(v177 + 80) = v247;
              *(_OWORD *)(v177 + 32) = v238;
              *(_OWORD *)(v177 + 48) = v241;
              *(_OWORD *)(v177 + 128) = v256;
              *(_OWORD *)(v177 + 144) = v259;
              *(_OWORD *)(v177 + 96) = v250;
              *(_OWORD *)(v177 + 112) = v253;
              char v217 = v262;
              char v218 = v265;
              long long v219 = *(_OWORD *)v268;
              double v220 = *(_OWORD *)&v268[13];
LABEL_117:
              *(_OWORD *)(v177 + 205) = v220;
              *(_OWORD *)(v177 + 176) = v218;
              *(_OWORD *)(v177 + 192) = v219;
              *(_OWORD *)(v177 + 160) = v217;
            }
          }
          if (v175-- <= 2) {
            return;
          }
          continue;
        }
        break;
      }
      *(_OWORD *)int v177 = v279;
      *(_OWORD *)(v177 + 16) = v290;
      *(_OWORD *)(v177 + 64) = v326;
      *(_OWORD *)(v177 + 80) = v338;
      *(_OWORD *)(v177 + 32) = v302;
      *(_OWORD *)(v177 + 48) = v314;
      *(_OWORD *)(v177 + 128) = v374;
      *(_OWORD *)(v177 + 144) = v386;
      *(_OWORD *)(v177 + 96) = v350;
      *(_OWORD *)(v177 + 112) = v362;
      char v217 = v398;
      char v218 = v410;
      long long v219 = *(_OWORD *)v420;
      double v220 = *(_OWORD *)&v420[13];
      goto LABEL_117;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = (long long *)(v10 + 224 * (v12 >> 1));
    if ((unint64_t)v11 > 0x7000)
    {
      sub_1015A0F44((long long *)a1, (long long *)(a1 + 224 * (v12 >> 1)), a2 - 14);
      unint64_t v15 = 224 * v13;
      unint64_t v16 = (long long *)(224 * v13 + a1 - 224);
      sub_1015A0F44((long long *)(a1 + 224), v16, a2 - 28);
      id v17 = (long long *)(a1 + 224 + v15);
      sub_1015A0F44((long long *)(a1 + 448), v17, a2 - 42);
      sub_1015A0F44(v16, v14, v17);
      __int16 v269 = *(_OWORD *)a1;
      id v281 = *(_OWORD *)(a1 + 16);
      v316 = *(_OWORD *)(a1 + 64);
      v328 = *(_OWORD *)(a1 + 80);
      int v292 = *(_OWORD *)(a1 + 32);
      v304 = *(_OWORD *)(a1 + 48);
      v364 = *(_OWORD *)(a1 + 128);
      v376 = *(_OWORD *)(a1 + 144);
      v340 = *(_OWORD *)(a1 + 96);
      v352 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)v412 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v412[16] = *(_OWORD *)(a1 + 208);
      v388 = *(_OWORD *)(a1 + 160);
      v400 = *(_OWORD *)(a1 + 176);
      uint64_t v18 = v14[1];
      *(_OWORD *)a1 = *v14;
      *(_OWORD *)(a1 + 16) = v18;
      long long v19 = v14[2];
      float v20 = v14[3];
      float v21 = v14[5];
      *(_OWORD *)(a1 + 64) = v14[4];
      *(_OWORD *)(a1 + 80) = v21;
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)(a1 + 48) = v20;
      double v22 = v14[6];
      uint64_t v23 = v14[7];
      uint64_t v24 = v14[9];
      *(_OWORD *)(a1 + 128) = v14[8];
      *(_OWORD *)(a1 + 144) = v24;
      *(_OWORD *)(a1 + 96) = v22;
      *(_OWORD *)(a1 + 112) = v23;
      unint64_t v25 = v14[10];
      char v26 = v14[11];
      BOOL v27 = v14[12];
      *(_OWORD *)(a1 + 205) = *(long long *)((char *)v14 + 205);
      *(_OWORD *)(a1 + 176) = v26;
      *(_OWORD *)(a1 + 192) = v27;
      *(_OWORD *)(a1 + 160) = v25;
      *uint64_t v14 = v269;
      v14[1] = v281;
      v14[4] = v316;
      v14[5] = v328;
      int v14[2] = v292;
      v14[3] = v304;
      char v14[8] = v364;
      v14[9] = v376;
      void v14[6] = v340;
      v14[7] = v352;
      *(long long *)((char *)v14 + 205) = *(_OWORD *)&v412[13];
      v14[11] = v400;
      unsigned char v14[12] = *(_OWORD *)v412;
      v14[10] = v388;
    }
    else
    {
      sub_1015A0F44((long long *)(a1 + 224 * (v12 >> 1)), (long long *)a1, a2 - 14);
    }
    --a3;
    if (a4)
    {
      uint64_t v28 = *(double *)(a1 + 8);
LABEL_12:
      uint64_t v29 = 0;
      uint64_t v30 = *(void *)a1;
      uint64_t v242 = *(_OWORD *)(a1 + 64);
      __int16 v245 = *(_OWORD *)(a1 + 80);
      double v254 = *(_OWORD *)(a1 + 128);
      __int16 v257 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)double v266 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v266[16] = *(_OWORD *)(a1 + 208);
      float v260 = *(_OWORD *)(a1 + 160);
      __int16 v263 = *(_OWORD *)(a1 + 176);
      int v248 = *(_OWORD *)(a1 + 96);
      __int16 v251 = *(_OWORD *)(a1 + 112);
      v236 = *(_OWORD *)(a1 + 32);
      __int16 v239 = *(_OWORD *)(a1 + 48);
      v233 = *(_OWORD *)(a1 + 16);
      do
      {
        double v31 = *(double *)(a1 + v29 + 232);
        v29 += 224;
      }
      while (v31 < v28);
      id v32 = a1 + v29;
      unsigned __int8 v33 = a2;
      if (v29 == 224)
      {
        id v36 = a2;
        while (v32 < (unint64_t)v36)
        {
          uint64_t v34 = v36 - 14;
          unsigned __int8 v37 = *((double *)v36 - 27);
          v36 -= 14;
          if (v37 < v28) {
            goto LABEL_22;
          }
        }
        uint64_t v34 = v36;
      }
      else
      {
        do
        {
          uint64_t v34 = v33 - 14;
          uint64_t v35 = *((double *)v33 - 27);
          v33 -= 14;
        }
        while (v35 >= v28);
      }
LABEL_22:
      unint64_t v10 = v32;
      if (v32 < (unint64_t)v34)
      {
        uint64_t v38 = v34;
        do
        {
          double v270 = *(_OWORD *)v10;
          v282 = *(_OWORD *)(v10 + 16);
          v317 = *(_OWORD *)(v10 + 64);
          v329 = *(_OWORD *)(v10 + 80);
          __int16 v293 = *(_OWORD *)(v10 + 32);
          v305 = *(_OWORD *)(v10 + 48);
          v365 = *(_OWORD *)(v10 + 128);
          v377 = *(_OWORD *)(v10 + 144);
          v341 = *(_OWORD *)(v10 + 96);
          v353 = *(_OWORD *)(v10 + 112);
          *(_OWORD *)v413 = *(_OWORD *)(v10 + 192);
          *(_OWORD *)&v413[16] = *(_OWORD *)(v10 + 208);
          v389 = *(_OWORD *)(v10 + 160);
          v401 = *(_OWORD *)(v10 + 176);
          uint64_t v39 = v38[1];
          *(_OWORD *)unint64_t v10 = *v38;
          *(_OWORD *)(v10 + 16) = v39;
          uint64_t v40 = v38[2];
          id v41 = v38[3];
          unsigned __int8 v42 = v38[5];
          *(_OWORD *)(v10 + 64) = v38[4];
          *(_OWORD *)(v10 + 80) = v42;
          *(_OWORD *)(v10 + 32) = v40;
          *(_OWORD *)(v10 + 48) = v41;
          unint64_t v43 = v38[6];
          unint64_t v44 = v38[7];
          id v45 = v38[9];
          *(_OWORD *)(v10 + 128) = v38[8];
          *(_OWORD *)(v10 + 144) = v45;
          *(_OWORD *)(v10 + 96) = v43;
          *(_OWORD *)(v10 + 112) = v44;
          id v46 = v38[10];
          uint64_t v47 = v38[11];
          uint64_t v48 = v38[12];
          *(_OWORD *)(v10 + 205) = *(long long *)((char *)v38 + 205);
          *(_OWORD *)(v10 + 176) = v47;
          *(_OWORD *)(v10 + 192) = v48;
          *(_OWORD *)(v10 + 160) = v46;
          *uint64_t v38 = v270;
          v38[1] = v282;
          v38[4] = v317;
          v38[5] = v329;
          v38[2] = v293;
          v38[3] = v305;
          v38[8] = v365;
          v38[9] = v377;
          v38[6] = v341;
          v38[7] = v353;
          *(long long *)((char *)v38 + 205) = *(_OWORD *)&v413[13];
          v38[11] = v401;
          v38[12] = *(_OWORD *)v413;
          v38[10] = v389;
          do
          {
            uint64_t v49 = *(double *)(v10 + 232);
            v10 += 224;
          }
          while (v49 < v28);
          do
          {
            uint64_t v50 = *((double *)v38 - 27);
            v38 -= 14;
          }
          while (v50 >= v28);
        }
        while (v10 < (unint64_t)v38);
      }
      if (v10 - 224 != a1)
      {
        uint64_t v51 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v51;
        uint64_t v52 = *(_OWORD *)(v10 - 192);
        uint64_t v53 = *(_OWORD *)(v10 - 176);
        unint64_t v54 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v54;
        *(_OWORD *)(a1 + 32) = v52;
        *(_OWORD *)(a1 + 48) = v53;
        id v55 = *(_OWORD *)(v10 - 128);
        id v56 = *(_OWORD *)(v10 - 112);
        id v57 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v57;
        *(_OWORD *)(a1 + 96) = v55;
        *(_OWORD *)(a1 + 112) = v56;
        id v58 = *(_OWORD *)(v10 - 64);
        id v59 = *(_OWORD *)(v10 - 48);
        double v60 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v59;
        *(_OWORD *)(a1 + 192) = v60;
        *(_OWORD *)(a1 + 160) = v58;
      }
      *(void *)(v10 - 224) = v30;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v233;
      *(_OWORD *)(v10 - 160) = v242;
      *(_OWORD *)(v10 - 144) = v245;
      *(_OWORD *)(v10 - 192) = v236;
      *(_OWORD *)(v10 - 176) = v239;
      *(_OWORD *)(v10 - 96) = v254;
      *(_OWORD *)(v10 - 80) = v257;
      *(_OWORD *)(v10 - 128) = v248;
      *(_OWORD *)(v10 - 112) = v251;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v266[13];
      *(_OWORD *)(v10 - 48) = v263;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v266;
      *(_OWORD *)(v10 - 64) = v260;
      if (v32 < (unint64_t)v34) {
        goto LABEL_33;
      }
      id v61 = sub_1015A52CC(a1, v10 - 224);
      if (sub_1015A52CC(v10, (uint64_t)a2))
      {
        a2 = (long long *)(v10 - 224);
        if (v61) {
          return;
        }
        goto LABEL_1;
      }
      if (!v61)
      {
LABEL_33:
        sub_1015A40B0(a1, v10 - 224, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v28 = *(double *)(a1 + 8);
      if (*(double *)(a1 - 216) < v28) {
        goto LABEL_12;
      }
      unint64_t v62 = *(void *)a1;
      __int16 v243 = *(_OWORD *)(a1 + 64);
      double v246 = *(_OWORD *)(a1 + 80);
      __int16 v237 = *(_OWORD *)(a1 + 32);
      uint64_t v240 = *(_OWORD *)(a1 + 48);
      __int16 v255 = *(_OWORD *)(a1 + 128);
      double v258 = *(_OWORD *)(a1 + 144);
      __int16 v249 = *(_OWORD *)(a1 + 96);
      double v252 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)__int16 v267 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)&v267[16] = *(_OWORD *)(a1 + 208);
      __int16 v261 = *(_OWORD *)(a1 + 160);
      uint64_t v264 = *(_OWORD *)(a1 + 176);
      v234 = *(_OWORD *)(a1 + 16);
      if (v28 >= *((double *)a2 - 27))
      {
        uint64_t v65 = a1 + 224;
        do
        {
          unint64_t v10 = v65;
          if (v65 >= (unint64_t)a2) {
            break;
          }
          uint64_t v66 = *(double *)(v65 + 8);
          v65 += 224;
        }
        while (v28 >= v66);
      }
      else
      {
        int v63 = a1;
        do
        {
          unint64_t v10 = v63 + 224;
          id v64 = *(double *)(v63 + 232);
          v63 += 224;
        }
        while (v28 >= v64);
      }
      id v67 = a2;
      if (v10 < (unint64_t)a2)
      {
        unint64_t v68 = a2;
        do
        {
          id v67 = v68 - 14;
          long long v69 = *((double *)v68 - 27);
          v68 -= 14;
        }
        while (v28 < v69);
      }
      while (v10 < (unint64_t)v67)
      {
        __int16 v271 = *(_OWORD *)v10;
        __int16 v283 = *(_OWORD *)(v10 + 16);
        v318 = *(_OWORD *)(v10 + 64);
        v330 = *(_OWORD *)(v10 + 80);
        double v294 = *(_OWORD *)(v10 + 32);
        v306 = *(_OWORD *)(v10 + 48);
        v366 = *(_OWORD *)(v10 + 128);
        v378 = *(_OWORD *)(v10 + 144);
        v342 = *(_OWORD *)(v10 + 96);
        v354 = *(_OWORD *)(v10 + 112);
        *(_OWORD *)v414 = *(_OWORD *)(v10 + 192);
        *(_OWORD *)&v414[16] = *(_OWORD *)(v10 + 208);
        v390 = *(_OWORD *)(v10 + 160);
        v402 = *(_OWORD *)(v10 + 176);
        long long v70 = v67[1];
        *(_OWORD *)unint64_t v10 = *v67;
        *(_OWORD *)(v10 + 16) = v70;
        long long v71 = v67[2];
        long long v72 = v67[3];
        id v73 = v67[5];
        *(_OWORD *)(v10 + 64) = v67[4];
        *(_OWORD *)(v10 + 80) = v73;
        *(_OWORD *)(v10 + 32) = v71;
        *(_OWORD *)(v10 + 48) = v72;
        int v74 = v67[6];
        long long v75 = v67[7];
        uint64_t v76 = v67[9];
        *(_OWORD *)(v10 + 128) = v67[8];
        *(_OWORD *)(v10 + 144) = v76;
        *(_OWORD *)(v10 + 96) = v74;
        *(_OWORD *)(v10 + 112) = v75;
        id v77 = v67[10];
        uint64_t v78 = v67[11];
        __int16 v79 = v67[12];
        *(_OWORD *)(v10 + 205) = *(long long *)((char *)v67 + 205);
        *(_OWORD *)(v10 + 176) = v78;
        *(_OWORD *)(v10 + 192) = v79;
        *(_OWORD *)(v10 + 160) = v77;
        *id v67 = v271;
        v67[1] = v283;
        v67[4] = v318;
        v67[5] = v330;
        v67[2] = v294;
        v67[3] = v306;
        v67[8] = v366;
        v67[9] = v378;
        v67[6] = v342;
        v67[7] = v354;
        *(long long *)((char *)v67 + 205) = *(_OWORD *)&v414[13];
        v67[11] = v402;
        v67[12] = *(_OWORD *)v414;
        v67[10] = v390;
        do
        {
          uint64_t v80 = *(double *)(v10 + 232);
          v10 += 224;
        }
        while (v28 >= v80);
        do
        {
          __int16 v81 = *((double *)v67 - 27);
          v67 -= 14;
        }
        while (v28 < v81);
      }
      unint64_t v4 = v10 - 224 >= a1;
      char v5 = v10 - 224 == a1;
      if (v10 - 224 != a1)
      {
        unint64_t v82 = *(_OWORD *)(v10 - 208);
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 224);
        *(_OWORD *)(a1 + 16) = v82;
        __int16 v83 = *(_OWORD *)(v10 - 192);
        uint64_t v84 = *(_OWORD *)(v10 - 176);
        __int16 v85 = *(_OWORD *)(v10 - 144);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v10 - 160);
        *(_OWORD *)(a1 + 80) = v85;
        *(_OWORD *)(a1 + 32) = v83;
        *(_OWORD *)(a1 + 48) = v84;
        double v86 = *(_OWORD *)(v10 - 128);
        uint64_t v87 = *(_OWORD *)(v10 - 112);
        double v88 = *(_OWORD *)(v10 - 80);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(v10 - 96);
        *(_OWORD *)(a1 + 144) = v88;
        *(_OWORD *)(a1 + 96) = v86;
        *(_OWORD *)(a1 + 112) = v87;
        __int16 v89 = *(_OWORD *)(v10 - 64);
        uint64_t v90 = *(_OWORD *)(v10 - 48);
        __int16 v91 = *(_OWORD *)(v10 - 32);
        *(_OWORD *)(a1 + 205) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(a1 + 176) = v90;
        *(_OWORD *)(a1 + 192) = v91;
        *(_OWORD *)(a1 + 160) = v89;
      }
      a4 = 0;
      *(void *)(v10 - 224) = v62;
      *(double *)(v10 - 216) = v28;
      *(_OWORD *)(v10 - 208) = v234;
      *(_OWORD *)(v10 - 160) = v243;
      *(_OWORD *)(v10 - 144) = v246;
      *(_OWORD *)(v10 - 192) = v237;
      *(_OWORD *)(v10 - 176) = v240;
      *(_OWORD *)(v10 - 96) = v255;
      *(_OWORD *)(v10 - 80) = v258;
      *(_OWORD *)(v10 - 128) = v249;
      *(_OWORD *)(v10 - 112) = v252;
      *(_OWORD *)(v10 - 19) = *(_OWORD *)&v267[13];
      *(_OWORD *)(v10 - 48) = v264;
      *(_OWORD *)(v10 - 32) = *(_OWORD *)v267;
      *(_OWORD *)(v10 - 64) = v261;
    }
  }
  id v135 = (long long *)(v10 + 224);
  uint64_t v137 = (long long *)v10 == a2 || v135 == a2;
  if (a4)
  {
    if (!v137)
    {
      uint64_t v138 = 0;
      unint64_t v139 = v10;
      do
      {
        id v140 = v135;
        unint64_t v141 = *(double *)(v139 + 232);
        if (v141 < *(double *)(v139 + 8))
        {
          unint64_t v142 = *(void *)v135;
          v396 = *(_OWORD *)(v139 + 400);
          *(_OWORD *)v408 = *(_OWORD *)(v139 + 416);
          *(_OWORD *)&v408[16] = *(_OWORD *)(v139 + 432);
          v348 = *(_OWORD *)(v139 + 336);
          v360 = *(_OWORD *)(v139 + 352);
          v372 = *(_OWORD *)(v139 + 368);
          v384 = *(_OWORD *)(v139 + 384);
          char v300 = *(_OWORD *)(v139 + 272);
          v312 = *(_OWORD *)(v139 + 288);
          v324 = *(_OWORD *)(v139 + 304);
          v336 = *(_OWORD *)(v139 + 320);
          std::string::size_type v144 = *(_OWORD *)(v139 + 240);
          id v143 = *(_OWORD *)(v139 + 256);
          uint64_t v145 = v138;
          v277 = v144;
          while (1)
          {
            std::string::size_type v146 = (double *)(v10 + v145);
            __int16 v147 = *(_OWORD *)(v10 + v145 + 176);
            *((_OWORD *)v146 + 24) = *(_OWORD *)(v10 + v145 + 160);
            *((_OWORD *)v146 + 25) = v147;
            *((_OWORD *)v146 + 26) = *(_OWORD *)(v10 + v145 + 192);
            *(_OWORD *)(v10 + v145 + 429) = *(_OWORD *)(v10 + v145 + 205);
            id v148 = *(_OWORD *)(v10 + v145 + 112);
            *((_OWORD *)v146 + 20) = *(_OWORD *)(v10 + v145 + 96);
            *((_OWORD *)v146 + 21) = v148;
            id v149 = *(_OWORD *)(v10 + v145 + 144);
            *((_OWORD *)v146 + 22) = *(_OWORD *)(v10 + v145 + 128);
            *((_OWORD *)v146 + 23) = v149;
            id v150 = *(_OWORD *)(v10 + v145 + 48);
            *((_OWORD *)v146 + 16) = *(_OWORD *)(v10 + v145 + 32);
            *((_OWORD *)v146 + 17) = v150;
            id v151 = *(_OWORD *)(v10 + v145 + 80);
            *((_OWORD *)v146 + 18) = *(_OWORD *)(v10 + v145 + 64);
            *((_OWORD *)v146 + 19) = v151;
            double v152 = *(_OWORD *)(v10 + v145 + 16);
            *((_OWORD *)v146 + 14) = *(_OWORD *)(v10 + v145);
            *((_OWORD *)v146 + 15) = v152;
            if (!v145) {
              break;
            }
            v145 -= 224;
            if (v141 >= *(v146 - 27))
            {
              id v153 = v10 + v145 + 224;
              goto LABEL_85;
            }
          }
          id v153 = v10;
LABEL_85:
          *(void *)id v153 = v142;
          *(double *)(v153 + 8) = v141;
          *(_OWORD *)(v153 + 176) = v396;
          *(_OWORD *)(v153 + 192) = *(_OWORD *)v408;
          *(_OWORD *)(v153 + 205) = *(_OWORD *)&v408[13];
          *(_OWORD *)(v153 + 112) = v348;
          *(_OWORD *)(v153 + 128) = v360;
          *(_OWORD *)(v153 + 144) = v372;
          *(_OWORD *)(v153 + 160) = v384;
          *(_OWORD *)(v153 + 48) = v300;
          *(_OWORD *)(v153 + 64) = v312;
          *(_OWORD *)(v153 + 80) = v324;
          *(_OWORD *)(v153 + 96) = v336;
          *(_OWORD *)(v153 + 16) = v277;
          *(_OWORD *)(v153 + 32) = v143;
        }
        id v135 = v140 + 14;
        v138 += 224;
        unint64_t v139 = (unint64_t)v140;
      }
      while (v140 + 14 != a2);
    }
  }
  else if (!v137)
  {
    do
    {
      char v222 = v135;
      uint64_t v223 = *(double *)(a1 + 232);
      if (v223 < *(double *)(a1 + 8))
      {
        char v224 = *(void *)v135;
        v399 = *(_OWORD *)(a1 + 400);
        *(_OWORD *)v411 = *(_OWORD *)(a1 + 416);
        *(_OWORD *)&v411[16] = *(_OWORD *)(a1 + 432);
        v351 = *(_OWORD *)(a1 + 336);
        v363 = *(_OWORD *)(a1 + 352);
        v375 = *(_OWORD *)(a1 + 368);
        v387 = *(_OWORD *)(a1 + 384);
        v303 = *(_OWORD *)(a1 + 272);
        v315 = *(_OWORD *)(a1 + 288);
        v327 = *(_OWORD *)(a1 + 304);
        v339 = *(_OWORD *)(a1 + 320);
        v280 = *(_OWORD *)(a1 + 240);
        __int16 v291 = *(_OWORD *)(a1 + 256);
        do
        {
          uint64_t v225 = a1 + 224;
          int v226 = *(_OWORD *)(a1 + 176);
          *(_OWORD *)(a1 + 384) = *(_OWORD *)(a1 + 160);
          *(_OWORD *)(a1 + 400) = v226;
          *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 192);
          char v227 = *(_OWORD *)(a1 + 112);
          *(_OWORD *)(a1 + 320) = *(_OWORD *)(a1 + 96);
          *(_OWORD *)(a1 + 336) = v227;
          uint64_t v228 = *(_OWORD *)(a1 + 144);
          *(_OWORD *)(a1 + 352) = *(_OWORD *)(a1 + 128);
          *(_OWORD *)(a1 + 368) = v228;
          __int16 v229 = *(_OWORD *)(a1 + 48);
          *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 32);
          *(_OWORD *)(a1 + 272) = v229;
          int v230 = *(_OWORD *)(a1 + 80);
          *(_OWORD *)(a1 + 288) = *(_OWORD *)(a1 + 64);
          *(_OWORD *)(a1 + 304) = v230;
          v231 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)(a1 + 224) = *(_OWORD *)a1;
          *(_OWORD *)(a1 + 240) = v231;
          unint64_t v121 = v223 < *(double *)(a1 - 216);
          int v232 = *(_OWORD *)(a1 + 205);
          a1 -= 224;
          *(_OWORD *)(v225 + 205) = v232;
        }
        while (v121);
        *(void *)(a1 + 224) = v224;
        *(double *)(a1 + 232) = v223;
        *(_OWORD *)(a1 + 240) = v280;
        *(_OWORD *)(a1 + 288) = v315;
        *(_OWORD *)(a1 + 304) = v327;
        *(_OWORD *)(a1 + 256) = v291;
        *(_OWORD *)(a1 + 272) = v303;
        *(_OWORD *)(a1 + 352) = v363;
        *(_OWORD *)(a1 + 368) = v375;
        *(_OWORD *)(a1 + 320) = v339;
        *(_OWORD *)(a1 + 336) = v351;
        *(_OWORD *)(a1 + 429) = *(_OWORD *)&v411[13];
        *(_OWORD *)(a1 + 400) = v399;
        *(_OWORD *)(a1 + 416) = *(_OWORD *)v411;
        *(_OWORD *)(a1 + 384) = v387;
      }
      id v135 = v222 + 14;
      a1 = (unint64_t)v222;
    }
    while (v222 + 14 != a2);
  }
}

  unint64_t v11 = a2 - 24;
  unint64_t v121 = (void **)(a2 - 48);
  id v124 = a2;
  id v118 = (void **)(a2 - 72);
  uint64_t v12 = a1;
  while (1)
  {
    a1 = v12;
    uint64_t v13 = v124 - v12;
    uint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v124 - v12) >> 3);
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          sub_1016FFF0C(*a3, (void **)v11, v131);
          sub_1016FFF0C(*a3, (void **)a1, __p);
          uint64_t v53 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
          if (v53)
          {
            unint64_t v54 = *(_OWORD *)a1;
            id v132 = *(void **)(a1 + 16);
            *(_OWORD *)uint64_t v131 = v54;
            id v55 = *(_OWORD *)v11;
            *(void *)(a1 + 16) = *(void *)(v11 + 16);
            *(_OWORD *)a1 = v55;
            id v56 = *(_OWORD *)v131;
            *(void *)(v11 + 16) = v132;
            *(_OWORD *)unint64_t v11 = v56;
          }
          break;
        case 3uLL:
          sub_1016FF8C4((void **)a1, (void **)(a1 + 24), (void **)v11, a3);
          break;
        case 4uLL:
          sub_101701220(a1, (void **)(a1 + 24), (void **)(a1 + 48), (void **)v11, a3);
          break;
        case 5uLL:
          sub_1016FF648(a1, (void **)(a1 + 24), (void **)(a1 + 48), (void **)(a1 + 72), (void **)v11, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v13 <= 575)
    {
      if (a5)
      {
        if (a1 == v124) {
          return;
        }
        id v57 = (void **)(a1 + 24);
        if (a1 + 24 == v124) {
          return;
        }
        id v58 = 0;
        id v59 = (void **)a1;
        while (2)
        {
          double v60 = v57;
          sub_1016FFF0C(*a3, v57, v131);
          sub_1016FFF0C(*a3, v59, __p);
          id v61 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0)
          {
            operator delete(v131[0]);
            if (!v61) {
              goto LABEL_147;
            }
          }
          else if (!v61)
          {
            goto LABEL_147;
          }
          unint64_t v62 = *(_OWORD *)v60;
          id v128 = v60[2];
          uint64_t v127 = v62;
          v60[1] = 0;
          v60[2] = 0;
          *double v60 = 0;
          int v63 = v58;
          do
          {
            id v64 = a1 + v63;
            uint64_t v65 = (void **)(a1 + v63 + 24);
            if (*(char *)(a1 + v63 + 47) < 0) {
              operator delete(*v65);
            }
            *(_OWORD *)uint64_t v65 = *(_OWORD *)v64;
            *(void *)(a1 + v63 + 40) = *(void *)(v64 + 16);
            *(unsigned char *)(v64 + 23) = 0;
            *(unsigned char *)id v64 = 0;
            if (!v63)
            {
              id v67 = a1;
              goto LABEL_146;
            }
            sub_1016FFF0C(*a3, (void **)&v127, v131);
            sub_1016FFF0C(*a3, (void **)(a1 + v63 - 24), __p);
            uint64_t v66 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v132) < 0) {
              operator delete(v131[0]);
            }
            v63 -= 24;
          }
          while (v66);
          id v67 = a1 + v63 + 24;
          if (*(char *)(a1 + v63 + 47) < 0) {
            operator delete(*(void **)v67);
          }
LABEL_146:
          unint64_t v68 = v127;
          *(void *)(v67 + 16) = v128;
          *(_OWORD *)id v67 = v68;
LABEL_147:
          id v57 = v60 + 3;
          v58 += 24;
          id v59 = v60;
          if (v60 + 3 == (void **)v124) {
            return;
          }
          continue;
        }
      }
      if (a1 == v124) {
        return;
      }
      uint64_t v107 = (void **)(a1 + 24);
      if (a1 + 24 == v124) {
        return;
      }
      id v108 = a1 - 24;
      while (2)
      {
        uint64_t v109 = v107;
        sub_1016FFF0C(*a3, v107, v131);
        sub_1016FFF0C(*a3, (void **)a1, __p);
        uint64_t v110 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
        if (v130 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v132) < 0)
        {
          operator delete(v131[0]);
          if (!v110) {
            goto LABEL_242;
          }
        }
        else if (!v110)
        {
          goto LABEL_242;
        }
        long long v111 = *(_OWORD *)v109;
        id v128 = v109[2];
        uint64_t v127 = v111;
        v109[1] = 0;
        v109[2] = 0;
        *uint64_t v109 = 0;
        int v112 = v108;
        do
        {
          id v113 = (void **)(v112 + 48);
          if (*(char *)(v112 + 71) < 0) {
            operator delete(*v113);
          }
          *(_OWORD *)id v113 = *(_OWORD *)(v112 + 24);
          *(void *)(v112 + 64) = *(void *)(v112 + 40);
          *(unsigned char *)(v112 + 47) = 0;
          *(unsigned char *)(v112 + 24) = 0;
          sub_1016FFF0C(*a3, (void **)&v127, v131);
          sub_1016FFF0C(*a3, (void **)v112, __p);
          uint64_t v114 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
          v112 -= 24;
        }
        while (v114);
        uint64_t v115 = *(char *)(v112 + 71);
        double v116 = v112 + 48;
        if (v115 < 0) {
          operator delete(*(void **)v116);
        }
        double v117 = v127;
        *(void *)(v116 + 16) = v128;
        *(_OWORD *)double v116 = v117;
LABEL_242:
        uint64_t v107 = v109 + 3;
        v108 += 24;
        a1 = (unint64_t)v109;
        if (v109 + 3 == (void **)v124) {
          return;
        }
        continue;
      }
    }
    if (!a4) {
      break;
    }
    unint64_t v15 = v14 >> 1;
    unint64_t v16 = a1 + 24 * (v14 >> 1);
    if ((unint64_t)v13 >= 0xC01)
    {
      sub_1016FF8C4((void **)a1, (void **)(a1 + 24 * (v14 >> 1)), (void **)v11, a3);
      sub_1016FF8C4((void **)(a1 + 24), (void **)(a1 + 24 * v15 - 24), v121, a3);
      sub_1016FF8C4((void **)(a1 + 48), (void **)(a1 + 24 * v15 + 24), v118, a3);
      sub_1016FF8C4((void **)(a1 + 24 * v15 - 24), (void **)v16, (void **)(a1 + 24 * v15 + 24), a3);
      id v17 = *(_OWORD *)a1;
      id v132 = *(void **)(a1 + 16);
      *(_OWORD *)uint64_t v131 = v17;
      uint64_t v18 = *(_OWORD *)v16;
      *(void *)(a1 + 16) = *(void *)(v16 + 16);
      *(_OWORD *)a1 = v18;
      long long v19 = *(_OWORD *)v131;
      *(void *)(v16 + 16) = v132;
      *(_OWORD *)unint64_t v16 = v19;
    }
    else
    {
      sub_1016FF8C4((void **)(a1 + 24 * (v14 >> 1)), (void **)a1, (void **)v11, a3);
    }
    --a4;
    if (a5) {
      goto LABEL_15;
    }
    sub_1016FFF0C(*a3, (void **)(a1 - 24), v131);
    sub_1016FFF0C(*a3, (void **)a1, __p);
    float v20 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
    if (v130 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v132) < 0) {
      operator delete(v131[0]);
    }
    if (v20)
    {
LABEL_15:
      float v21 = 0;
      double v22 = *(_OWORD *)a1;
      id v128 = *(void **)(a1 + 16);
      uint64_t v127 = v22;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)a1 = 0;
      do
      {
        sub_1016FFF0C(*a3, (void **)(a1 + v21 + 24), v131);
        sub_1016FFF0C(*a3, (void **)&v127, __p);
        uint64_t v23 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
        if (v130 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v132) < 0) {
          operator delete(v131[0]);
        }
        v21 += 24;
      }
      while (v23);
      uint64_t v24 = a1 + v21;
      unint64_t v25 = (void **)v124;
      if (v21 == 24)
      {
        unint64_t v25 = (void **)v124;
        while (v24 < (unint64_t)v25)
        {
          v25 -= 3;
          sub_1016FFF0C(*a3, v25, v131);
          sub_1016FFF0C(*a3, (void **)&v127, __p);
          BOOL v27 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0)
          {
            operator delete(v131[0]);
            if (v27) {
              break;
            }
          }
          else if (v27)
          {
            break;
          }
        }
      }
      else
      {
        do
        {
          while (1)
          {
            v25 -= 3;
            sub_1016FFF0C(*a3, v25, v131);
            sub_1016FFF0C(*a3, (void **)&v127, __p);
            char v26 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v132) < 0) {
              break;
            }
            if (v26) {
              goto LABEL_37;
            }
          }
          operator delete(v131[0]);
        }
        while (!v26);
      }
LABEL_37:
      uint64_t v12 = a1 + v21;
      if (v24 < (unint64_t)v25)
      {
        uint64_t v28 = v25;
        do
        {
          uint64_t v29 = *(_OWORD *)v12;
          id v132 = *(void **)(v12 + 16);
          *(_OWORD *)uint64_t v131 = v29;
          uint64_t v30 = *(_OWORD *)v28;
          *(void *)(v12 + 16) = v28[2];
          *(_OWORD *)uint64_t v12 = v30;
          double v31 = *(_OWORD *)v131;
          v28[2] = v132;
          *(_OWORD *)uint64_t v28 = v31;
          do
          {
            while (1)
            {
              v12 += 24;
              sub_1016FFF0C(*a3, (void **)v12, v131);
              sub_1016FFF0C(*a3, (void **)&v127, __p);
              id v32 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
              if (v130 < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v132) < 0) {
                break;
              }
              if (!v32) {
                goto LABEL_48;
              }
            }
            operator delete(v131[0]);
          }
          while (v32);
          do
          {
            while (1)
            {
LABEL_48:
              v28 -= 3;
              sub_1016FFF0C(*a3, v28, v131);
              sub_1016FFF0C(*a3, (void **)&v127, __p);
              unsigned __int8 v33 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
              if (v130 < 0) {
                operator delete(__p[0]);
              }
              if ((SHIBYTE(v132) & 0x80000000) == 0) {
                break;
              }
              operator delete(v131[0]);
              if (v33) {
                goto LABEL_52;
              }
            }
          }
          while (!v33);
LABEL_52:
          ;
        }
        while (v12 < (unint64_t)v28);
      }
      uint64_t v34 = (long long *)(v12 - 24);
      if (v12 - 24 == a1)
      {
        if (*(char *)(v12 - 1) < 0) {
          operator delete(*(void **)a1);
        }
      }
      else
      {
        if (*(char *)(a1 + 23) < 0) {
          operator delete(*(void **)a1);
        }
        uint64_t v35 = *v34;
        *(void *)(a1 + 16) = *(void *)(v12 - 8);
        *(_OWORD *)a1 = v35;
        *(unsigned char *)(v12 - 1) = 0;
        *(unsigned char *)(v12 - 24) = 0;
      }
      id v36 = v127;
      *(void *)(v12 - 8) = v128;
      *uint64_t v34 = v36;
      if (v24 < (unint64_t)v25) {
        goto LABEL_62;
      }
      unsigned __int8 v37 = sub_1016FFB98(a1, v12 - 24, a3);
      if (sub_1016FFB98(v12, v124, a3))
      {
        a2 = v12 - 24;
        if (v37) {
          return;
        }
        goto LABEL_1;
      }
      if (!v37)
      {
LABEL_62:
        sub_1016FE384(a1, v12 - 24, a3, a4, a5 & 1);
        a5 = 0;
      }
    }
    else
    {
      uint64_t v38 = *(_OWORD *)a1;
      id v128 = *(void **)(a1 + 16);
      uint64_t v127 = v38;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)a1 = 0;
      sub_1016FFF0C(*a3, (void **)&v127, v131);
      sub_1016FFF0C(*a3, (void **)v11, __p);
      uint64_t v39 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
      if (v130 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v132) < 0) {
        operator delete(v131[0]);
      }
      if (v39)
      {
        uint64_t v12 = a1;
        do
        {
          sub_1016FFF0C(*a3, (void **)&v127, v131);
          v12 += 24;
          sub_1016FFF0C(*a3, (void **)v12, __p);
          uint64_t v40 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
        }
        while (!v40);
      }
      else
      {
        id v41 = a1 + 24;
        do
        {
          uint64_t v12 = v41;
          if (v41 >= v124) {
            break;
          }
          sub_1016FFF0C(*a3, (void **)&v127, v131);
          sub_1016FFF0C(*a3, (void **)v12, __p);
          unsigned __int8 v42 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
          id v41 = v12 + 24;
        }
        while (!v42);
      }
      unint64_t v43 = v124;
      if (v12 < v124)
      {
        unint64_t v43 = v124;
        do
        {
          while (1)
          {
            sub_1016FFF0C(*a3, (void **)&v127, v131);
            v43 -= 24;
            sub_1016FFF0C(*a3, (void **)v43, __p);
            unint64_t v44 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v132) < 0) {
              break;
            }
            if (!v44) {
              goto LABEL_104;
            }
          }
          operator delete(v131[0]);
        }
        while (v44);
      }
LABEL_104:
      while (v12 < v43)
      {
        id v45 = *(_OWORD *)v12;
        id v132 = *(void **)(v12 + 16);
        *(_OWORD *)uint64_t v131 = v45;
        id v46 = *(_OWORD *)v43;
        *(void *)(v12 + 16) = *(void *)(v43 + 16);
        *(_OWORD *)uint64_t v12 = v46;
        uint64_t v47 = *(_OWORD *)v131;
        *(void *)(v43 + 16) = v132;
        *(_OWORD *)unint64_t v43 = v47;
        do
        {
          while (1)
          {
            sub_1016FFF0C(*a3, (void **)&v127, v131);
            v12 += 24;
            sub_1016FFF0C(*a3, (void **)v12, __p);
            uint64_t v48 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v132) < 0) {
              break;
            }
            if (v48) {
              goto LABEL_100;
            }
          }
          operator delete(v131[0]);
        }
        while (!v48);
        do
        {
          while (1)
          {
LABEL_100:
            sub_1016FFF0C(*a3, (void **)&v127, v131);
            v43 -= 24;
            sub_1016FFF0C(*a3, (void **)v43, __p);
            uint64_t v49 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if ((SHIBYTE(v132) & 0x80000000) == 0) {
              break;
            }
            operator delete(v131[0]);
            if (!v49) {
              goto LABEL_104;
            }
          }
        }
        while (v49);
      }
      uint64_t v50 = (long long *)(v12 - 24);
      char v5 = v12 - 24 >= a1;
      char v6 = v12 - 24 == a1;
      if (v12 - 24 == a1)
      {
        if (*(char *)(v12 - 1) < 0) {
          operator delete(*(void **)a1);
        }
      }
      else
      {
        if (*(char *)(a1 + 23) < 0) {
          operator delete(*(void **)a1);
        }
        uint64_t v51 = *v50;
        *(void *)(a1 + 16) = *(void *)(v12 - 8);
        *(_OWORD *)a1 = v51;
        *(unsigned char *)(v12 - 1) = 0;
        *(unsigned char *)(v12 - 24) = 0;
      }
      a5 = 0;
      uint64_t v52 = v127;
      *(void *)(v12 - 8) = v128;
      *uint64_t v50 = v52;
    }
  }
  long long v69 = (_OWORD *)v124;
  if (a1 != v124)
  {
    long long v70 = (v14 - 2) >> 1;
    double v122 = v70;
    do
    {
      long long v71 = v70;
      if (v122 >= v70)
      {
        long long v72 = (2 * v70) | 1;
        id v73 = a1 + 24 * v72;
        int v74 = 2 * v70 + 2;
        long long v75 = v70;
        if (v74 < (uint64_t)v14)
        {
          sub_1016FFF0C(*a3, (void **)(a1 + 24 * v72), v131);
          sub_1016FFF0C(*a3, (void **)(v73 + 24), __p);
          uint64_t v76 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
          if (v76)
          {
            v73 += 24;
            long long v72 = v74;
          }
        }
        sub_1016FFF0C(*a3, (void **)v73, v131);
        id v119 = v75;
        id v77 = a1 + 24 * v75;
        sub_1016FFF0C(*a3, (void **)v77, __p);
        uint64_t v78 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
        long long v69 = (_OWORD *)v124;
        if (v130 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v132) < 0) {
          operator delete(v131[0]);
        }
        long long v71 = v75;
        if (!v78)
        {
          __int16 v79 = *(_OWORD *)v77;
          id v128 = *(void **)(v77 + 16);
          uint64_t v127 = v79;
          *(void *)(v77 + 8) = 0;
          *(void *)(v77 + 16) = 0;
          *(void *)id v77 = 0;
          do
          {
            uint64_t v80 = v73;
            if (*(char *)(v77 + 23) < 0) {
              operator delete(*(void **)v77);
            }
            __int16 v81 = *(_OWORD *)v73;
            *(void *)(v77 + 16) = *(void *)(v73 + 16);
            *(_OWORD *)id v77 = v81;
            *(unsigned char *)(v73 + 23) = 0;
            *(unsigned char *)id v73 = 0;
            if (v122 < v72) {
              goto LABEL_184;
            }
            unint64_t v82 = (2 * v72) | 1;
            id v73 = a1 + 24 * v82;
            long long v72 = 2 * v72 + 2;
            if (v72 < (uint64_t)v14)
            {
              sub_1016FFF0C(*a3, (void **)(a1 + 24 * v82), v131);
              sub_1016FFF0C(*a3, (void **)(v73 + 24), __p);
              __int16 v83 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
              if (v130 < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v132) < 0) {
                operator delete(v131[0]);
              }
              if (v83) {
                v73 += 24;
              }
              else {
                long long v72 = v82;
              }
            }
            else
            {
              long long v72 = v82;
            }
            sub_1016FFF0C(*a3, (void **)v73, v131);
            sub_1016FFF0C(*a3, (void **)&v127, __p);
            uint64_t v84 = sub_100130070((uint64_t)v133, (const void **)v131, (const void **)__p);
            if (v130 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v132) < 0) {
              operator delete(v131[0]);
            }
            id v77 = v80;
          }
          while (!v84);
          if (*(char *)(v80 + 23) < 0) {
            operator delete(*(void **)v80);
          }
LABEL_184:
          __int16 v85 = v127;
          *(void *)(v80 + 16) = v128;
          *(_OWORD *)uint64_t v80 = v85;
          long long v69 = (_OWORD *)v124;
          long long v71 = v119;
        }
      }
      long long v70 = v71 - 1;
    }
    while (v71);
    double v86 = v13 / 0x18uLL;
    while (2)
    {
      uint64_t v87 = 0;
      unint64_t v120 = v69;
      double v123 = *(void **)a1;
      *(void *)uint64_t v133 = *(void *)(a1 + 8);
      *(void *)&v133[7] = *(void *)(a1 + 15);
      id v125 = *(unsigned char *)(a1 + 23);
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)a1 = 0;
      double v88 = a1;
      do
      {
        __int16 v89 = v88 + 24 * v87 + 24;
        uint64_t v90 = 2 * v87;
        uint64_t v87 = (2 * v87) | 1;
        __int16 v91 = v90 + 2;
        if (v90 + 2 < v86)
        {
          sub_1016FFF0C(*a3, (void **)v89, v131);
          sub_1016FFF0C(*a3, (void **)(v89 + 24), __p);
          unint64_t v92 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v132) < 0) {
            operator delete(v131[0]);
          }
          if (v92)
          {
            v89 += 24;
            uint64_t v87 = v91;
          }
        }
        if (*(char *)(v88 + 23) < 0) {
          operator delete(*(void **)v88);
        }
        __int16 v93 = *(_OWORD *)v89;
        *(void *)(v88 + 16) = *(void *)(v89 + 16);
        *(_OWORD *)double v88 = v93;
        *(unsigned char *)(v89 + 23) = 0;
        *(unsigned char *)__int16 v89 = 0;
        double v88 = v89;
      }
      while (v87 <= (uint64_t)((unint64_t)(v86 - 2) >> 1));
      long long v69 = (_OWORD *)((char *)v120 - 24);
      if ((_OWORD *)v89 == (_OWORD *)((char *)v120 - 24))
      {
        *(void *)__int16 v89 = v123;
        int v100 = *(void *)&v133[7];
        *(void *)(v89 + 8) = *(void *)v133;
        *(void *)(v89 + 15) = v100;
        *(unsigned char *)(v89 + 23) = v125;
        goto LABEL_219;
      }
      uint64_t v94 = *v69;
      *(void *)(v89 + 16) = *((void *)v120 - 1);
      *(_OWORD *)__int16 v89 = v94;
      *((void *)v120 - 3) = v123;
      __int16 v95 = *(void *)v133;
      *(void *)((char *)v120 - 9) = *(void *)&v133[7];
      *((void *)v120 - 2) = v95;
      *((unsigned char *)v120 - 1) = v125;
      double v96 = v89 - a1 + 24;
      if (v96 < 25) {
        goto LABEL_219;
      }
      id v97 = (v96 / 0x18uLL - 2) >> 1;
      id v98 = a1 + 24 * v97;
      sub_1016FFF0C(*a3, (void **)v98, v131);
      sub_1016FFF0C(*a3, (void **)v89, __p);
      int v99 = sub_100130070((uint64_t)&v127, (const void **)v131, (const void **)__p);
      if (v130 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v132) < 0)
      {
        operator delete(v131[0]);
        if (!v99) {
          goto LABEL_219;
        }
      }
      else if (!v99)
      {
        goto LABEL_219;
      }
      uint64_t v101 = *(_OWORD *)v89;
      id v128 = *(void **)(v89 + 16);
      uint64_t v127 = v101;
      *(void *)(v89 + 8) = 0;
      *(void *)(v89 + 16) = 0;
      *(void *)__int16 v89 = 0;
      while (1)
      {
        id v102 = v98;
        if (*(char *)(v89 + 23) < 0) {
          operator delete(*(void **)v89);
        }
        int64_t v103 = *(_OWORD *)v98;
        *(void *)(v89 + 16) = *(void *)(v98 + 16);
        *(_OWORD *)__int16 v89 = v103;
        *(unsigned char *)(v98 + 23) = 0;
        *(unsigned char *)id v98 = 0;
        if (!v97) {
          break;
        }
        id v97 = (v97 - 1) >> 1;
        id v98 = a1 + 24 * v97;
        sub_1016FFF0C(*a3, (void **)v98, v131);
        sub_1016FFF0C(*a3, (void **)&v127, __p);
        unint64_t v104 = sub_100130070((uint64_t)&v126, (const void **)v131, (const void **)__p);
        if (v130 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v132) < 0) {
          operator delete(v131[0]);
        }
        __int16 v89 = v102;
        if (!v104)
        {
          if (*(char *)(v102 + 23) < 0) {
            operator delete(*(void **)v102);
          }
          break;
        }
      }
      uint64_t v105 = v127;
      *(void *)(v102 + 16) = v128;
      *(_OWORD *)id v102 = v105;
      long long v69 = (_OWORD *)((char *)v120 - 24);
LABEL_219:
      if (v86-- <= 2) {
        return;
      }
      continue;
    }
  }
}

  unint64_t v11 = (long long *)((char *)a2 - 24);
  uint64_t v12 = (const void **)a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v12;
    uint64_t v14 = v13;
    unint64_t v15 = (char *)a2 - (char *)v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (sub_100130070(a3, (const void **)a2 - 3, v12))
          {
            double v31 = v12[2];
            uint64_t v29 = *(_OWORD *)v12;
            BOOL v27 = *v11;
            _OWORD v12[2] = (const void *)*((void *)a2 - 1);
            *(_OWORD *)uint64_t v12 = v27;
            *unint64_t v11 = v29;
            *((void *)a2 - 1) = v31;
          }
          break;
        case 3uLL:
          sub_101764310(v12, v12 + 3, (const void **)a2 - 3, a3);
          break;
        case 4uLL:
          sub_1017649D4((uint64_t)v12, v12 + 3, v12 + 6, (long long *)((char *)a2 - 24), a3);
          break;
        case 5uLL:
          sub_101764AC0((uint64_t)v12, v12 + 3, v12 + 6, (long long *)(v12 + 9), (long long *)((char *)a2 - 24), a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 575) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (const void **)a2)
      {
        sub_101764BE4((uint64_t)v12, a2, a2, a3);
      }
      return;
    }
    id v17 = v16 >> 1;
    uint64_t v18 = &v12[3 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0xC01)
    {
      sub_101764310(v12, &v12[3 * (v16 >> 1)], (const void **)a2 - 3, a3);
      long long v19 = 3 * v17;
      float v20 = &v12[3 * v17 - 3];
      sub_101764310(v12 + 3, v20, (const void **)a2 - 6, a3);
      float v21 = v12 + 6;
      double v22 = &v12[v19 + 3];
      sub_101764310(v21, v22, (const void **)a2 - 9, a3);
      sub_101764310(v20, v18, v22, a3);
      uint64_t v30 = *(const void **)(a1 + 16);
      uint64_t v28 = *(_OWORD *)a1;
      uint64_t v23 = *(_OWORD *)v18;
      *(void *)(a1 + 16) = v18[2];
      *(_OWORD *)a1 = v23;
      v18[2] = v30;
      *(_OWORD *)uint64_t v18 = v28;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_101764310(&v12[3 * (v16 >> 1)], v12, (const void **)a2 - 3, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!sub_100130070(a3, (const void **)(a1 - 24), (const void **)a1))
    {
      uint64_t v12 = sub_10176445C((const void **)a1, (unint64_t)a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v24 = sub_1017645F0((long long *)a1, (const void **)a2, a3);
    if ((v25 & 1) == 0) {
      goto LABEL_16;
    }
    char v26 = sub_101764780(a1, v24, a3);
    uint64_t v12 = (const void **)(v24 + 24);
    if (sub_101764780(v24 + 24, (uint64_t)a2, a3))
    {
      a4 = -v14;
      a2 = (long long *)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v26)
    {
LABEL_16:
      sub_101763CB4(a1, v24, a3, -v14, a5 & 1);
      uint64_t v12 = (const void **)(v24 + 24);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_1017640DC((uint64_t)v12, (const void **)a2, a3);
  }
  else
  {
    sub_101764204(v12, (const void **)a2, a3);
  }
}