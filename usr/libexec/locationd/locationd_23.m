void sub_100FA9DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_10055C7F8((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_100FA9E30(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    [*(id *)(a1 + 32) setRscp:[objc_msgSend(objc_msgSend(a2, "rscp"), "intValue")];
    [*(id *)(a1 + 32) setEcn0:[objc_msgSend(objc_msgSend(a2, "ecn0"), "intValue")];
  }
  [*(id *)(v3 + 384) writeSecondaryObject:*(void *)(a1 + 32) collectedAt:[*(id *)(a1 + 32) location] toField:2];
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102307DD0);
  }
  v5 = qword_102419568;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    v7[0] = 68289795;
    v7[1] = 0;
    __int16 v8 = 2082;
    v9 = "";
    __int16 v10 = 2050;
    uint64_t v11 = 1;
    __int16 v12 = 2081;
    v13 = "GSM";
    __int16 v14 = 2113;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvest-Collect\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"type\":%{private, location:escape_only}s, \"harvest\":%{private, location:escape_only}@}", (uint8_t *)v7, 0x30u);
  }
}

void sub_100FA9FB8(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    [*(id *)(a1 + 32) setRscp:[objc_msgSend(objc_msgSend(a2, "rsrp"), "intValue")];
    [*(id *)(a1 + 32) setEcn0:[objc_msgSend(objc_msgSend(a2, "snr"), "intValue")];
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v5 = *(void *)(v3 + 352);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100FAA25C;
    v9[3] = &unk_102307D70;
    v9[4] = *(void *)(a1 + 32);
    v9[5] = v3;
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 152))(v5, v9);
  }
  else
  {
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_102307DD0);
    }
    uint64_t v6 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      v13 = "";
      __int16 v14 = 2050;
      uint64_t v15 = 1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"DiagnosticsSubmission is not allowed\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}", buf, 0x1Cu);
    }
    [*(id *)(v3 + 384) writeSecondaryObject:*(void *)(a1 + 32) collectedAt:[*(id *)(a1 + 32) location] toField:5];
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_102307DD0);
    }
    v7 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      v13 = "";
      __int16 v14 = 2050;
      uint64_t v15 = 1;
      __int16 v16 = 2081;
      v17 = "LTE";
      __int16 v18 = 2113;
      uint64_t v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvest-Collect\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"type\":%{private, location:escape_only}s, \"harvest\":%{private, location:escape_only}@}", buf, 0x30u);
    }
  }
}

void sub_100FAA25C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102307DD0);
  }
  int v11 = qword_102419568;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
  {
    int v14 = 68290050;
    int v15 = 0;
    __int16 v16 = 2082;
    v17 = "";
    __int16 v18 = 1026;
    *(_DWORD *)uint64_t v19 = a2;
    *(_WORD *)&v19[4] = 1026;
    *(_DWORD *)&v19[6] = a3;
    LOWORD(v20) = 1026;
    *(_DWORD *)((char *)&v20 + 2) = a4;
    HIWORD(v20) = 1026;
    v21[0] = a5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#irat streamingInfo\", \"isValidMetrics\":%{public}hhd, \"downlinkBandwidth\":%{public}d, \"isStalled\":%{public}hhd, \"latency\":%{public}d}", (uint8_t *)&v14, 0x2Au);
  }
  if (a2)
  {
    [*(id *)(a1 + 32) setDownlinkBandwidth:a3];
    [*(id *)(a1 + 32) setIsStalled:a4];
    [*(id *)(a1 + 32) setLatency:a5];
  }
  [*(id *)(v10 + 384) writeSecondaryObject:*(void *)(a1 + 32) collectedAt:objc_msgSend(*(id *)(a1 + 32), "location") toField:5];
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102307DD0);
  }
  __int16 v12 = qword_102419568;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v13 = *(void *)(a1 + 32);
    int v14 = 68289795;
    int v15 = 0;
    __int16 v16 = 2082;
    v17 = "";
    __int16 v18 = 2050;
    *(void *)uint64_t v19 = 1;
    *(_WORD *)&v19[8] = 2081;
    v20 = "LTE";
    LOWORD(v21[0]) = 2113;
    *(void *)((char *)v21 + 2) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvest-Collect\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"type\":%{private, location:escape_only}s, \"harvest\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x30u);
  }
}

void sub_100FAA490(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    [*(id *)(a1 + 32) setRscp:[objc_msgSend(objc_msgSend(a2, "rsrp"), "intValue")];
    [*(id *)(a1 + 32) setEcn0:[objc_msgSend(objc_msgSend(a2, "snr"), "intValue")];
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v5 = *(void *)(v3 + 352);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100FAA734;
    v9[3] = &unk_102307D70;
    v9[4] = *(void *)(a1 + 32);
    v9[5] = v3;
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 152))(v5, v9);
  }
  else
  {
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_102307DD0);
    }
    uint64_t v6 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2050;
      uint64_t v15 = 1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"DiagnosticsSubmission is not allowed\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}", buf, 0x1Cu);
    }
    [*(id *)(v3 + 384) writeSecondaryObject:*(void *)(a1 + 32) collectedAt:[*(id *)(a1 + 32) location] toField:8];
    if (qword_102419560 != -1) {
      dispatch_once(&qword_102419560, &stru_102307DD0);
    }
    v7 = qword_102419568;
    if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2050;
      uint64_t v15 = 1;
      __int16 v16 = 2081;
      v17 = "NR5G";
      __int16 v18 = 2113;
      uint64_t v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvest-Collect\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"type\":%{private, location:escape_only}s, \"harvest\":%{private, location:escape_only}@}", buf, 0x30u);
    }
  }
}

void sub_100FAA734(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102307DD0);
  }
  int v11 = qword_102419568;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
  {
    int v14 = 68290050;
    int v15 = 0;
    __int16 v16 = 2082;
    v17 = "";
    __int16 v18 = 1026;
    *(_DWORD *)uint64_t v19 = a2;
    *(_WORD *)&v19[4] = 1026;
    *(_DWORD *)&v19[6] = a3;
    LOWORD(v20) = 1026;
    *(_DWORD *)((char *)&v20 + 2) = a4;
    HIWORD(v20) = 1026;
    v21[0] = a5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#irat streamingInfo\", \"isValidMetrics\":%{public}hhd, \"downlinkBandwidth\":%{public}d, \"isStalled\":%{public}hhd, \"latency\":%{public}d}", (uint8_t *)&v14, 0x2Au);
  }
  if (a2)
  {
    [*(id *)(a1 + 32) setDownlinkBandwidth:a3];
    [*(id *)(a1 + 32) setIsStalled:a4];
    [*(id *)(a1 + 32) setLatency:a5];
  }
  [*(id *)(v10 + 384) writeSecondaryObject:*(void *)(a1 + 32) collectedAt:objc_msgSend(*(id *)(a1 + 32), "location") toField:8];
  if (qword_102419560 != -1) {
    dispatch_once(&qword_102419560, &stru_102307DD0);
  }
  __int16 v12 = qword_102419568;
  if (os_log_type_enabled((os_log_t)qword_102419568, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v13 = *(void *)(a1 + 32);
    int v14 = 68289795;
    int v15 = 0;
    __int16 v16 = 2082;
    v17 = "";
    __int16 v18 = 2050;
    *(void *)uint64_t v19 = 1;
    *(_WORD *)&v19[8] = 2081;
    v20 = "NR5G";
    LOWORD(v21[0]) = 2113;
    *(void *)((char *)v21 + 2) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Harvest-Collect\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"type\":%{private, location:escape_only}s, \"harvest\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x30u);
  }
}

uint64_t sub_100FAA968(void *a1)
{
  *a1 = off_102307C78;
  v2 = (std::__shared_weak_count *)a1[47];
  if (v2) {
    sub_1000DB0A0(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[45];
  if (v3) {
    sub_1000DB0A0(v3);
  }

  return sub_1003C0998((uint64_t)a1);
}

void sub_100FAA9D0(void *a1)
{
  *a1 = off_102307C78;
  v2 = (std::__shared_weak_count *)a1[47];
  if (v2) {
    sub_1000DB0A0(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[45];
  if (v3) {
    sub_1000DB0A0(v3);
  }
  sub_1003C0998((uint64_t)a1);

  operator delete();
}

void sub_100FAAA4C(id a1)
{
  qword_102419568 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

uint64_t sub_100FAAA7C()
{
  return sub_1012B748C((uint64_t)&xmmword_102482768, 1, 2, 2, 1, 60.0, 43200.0, 43200.0);
}

uint64_t sub_100FAB814(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    v4 = &OBJC_IVAR___CLHidManager__delegate;
    uint64_t v5 = &OBJC_IVAR___CLHidManager__delegate;
    uint64_t v6 = &OBJC_IVAR___CLHidManager__delegate;
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v10 == -1 || v10 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v11 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v10);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v10 + 1;
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          goto LABEL_12;
        }
        v7 += 7;
        BOOL v12 = v8++ >= 9;
        if (v12)
        {
          unint64_t v9 = 0;
          int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
      int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v9 = 0;
      }
LABEL_14:
      int v14 = v9 & 7;
      if (v13 || v14 == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      switch((v9 >> 3))
      {
        case 0x15u:
          char v16 = 0;
          unsigned int v17 = 0;
          uint64_t v18 = 0;
          *(unsigned char *)(a1 + v6[786]) |= 4u;
          while (2)
          {
            unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v19 == -1 || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }
            else
            {
              char v20 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
              v18 |= (unint64_t)(v20 & 0x7F) << v16;
              if (v20 < 0)
              {
                v16 += 7;
                BOOL v12 = v17++ >= 9;
                if (v12)
                {
                  LODWORD(v18) = 0;
                  goto LABEL_97;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v18) = 0;
          }
LABEL_97:
          uint64_t v61 = 64;
          goto LABEL_135;
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
LABEL_34:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
          goto LABEL_136;
        case 0x1Fu:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v18 = 0;
          *(unsigned char *)(a1 + v6[786]) |= 0x10u;
          while (2)
          {
            unint64_t v28 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v28 == -1 || v28 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }
            else
            {
              char v29 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v28);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28 + 1;
              v18 |= (unint64_t)(v29 & 0x7F) << v26;
              if (v29 < 0)
              {
                v26 += 7;
                BOOL v12 = v27++ >= 9;
                if (v12)
                {
                  LODWORD(v18) = 0;
                  goto LABEL_101;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v18) = 0;
          }
LABEL_101:
          uint64_t v61 = 72;
          goto LABEL_135;
        case 0x20u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v18 = 0;
          *(unsigned char *)(a1 + v6[786]) |= 2u;
          while (2)
          {
            unint64_t v32 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v32 == -1 || v32 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }
            else
            {
              char v33 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v32);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v32 + 1;
              v18 |= (unint64_t)(v33 & 0x7F) << v30;
              if (v33 < 0)
              {
                v30 += 7;
                BOOL v12 = v31++ >= 9;
                if (v12)
                {
                  LODWORD(v18) = 0;
                  goto LABEL_105;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v18) = 0;
          }
LABEL_105:
          uint64_t v61 = 60;
          goto LABEL_135;
        case 0x21u:
          if (v14 == 2)
          {
            uint64_t result = PBReaderPlaceMark();
            if (!result) {
              return result;
            }
            while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length)
                 && !*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error))
            {
              char v35 = 0;
              unsigned int v36 = 0;
              uint64_t v37 = 0;
              while (1)
              {
                unint64_t v38 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v38 == -1 || v38 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                  break;
                }
                char v39 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v38);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v38 + 1;
                v37 |= (unint64_t)(v39 & 0x7F) << v35;
                if (v39 < 0)
                {
                  v35 += 7;
                  BOOL v12 = v36++ >= 9;
                  if (!v12) {
                    continue;
                  }
                }
                goto LABEL_62;
              }
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_62:
              PBRepeatedInt32Add();
            }
            PBReaderRecallMark();
          }
          else
          {
            char v62 = 0;
            unsigned int v63 = 0;
            uint64_t v64 = 0;
            while (1)
            {
              unint64_t v65 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v65 == -1 || v65 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v66 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v65);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v65 + 1;
              v64 |= (unint64_t)(v66 & 0x7F) << v62;
              if (v66 < 0)
              {
                v62 += 7;
                BOOL v12 = v63++ >= 9;
                if (!v12) {
                  continue;
                }
              }
              goto LABEL_139;
            }
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_139:
            PBRepeatedInt32Add();
          }
          goto LABEL_136;
        case 0x22u:
          char v40 = 0;
          unsigned int v41 = 0;
          uint64_t v18 = 0;
          *(unsigned char *)(a1 + v6[786]) |= 8u;
          while (2)
          {
            unint64_t v42 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v42 == -1 || v42 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }
            else
            {
              char v43 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v42);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v42 + 1;
              v18 |= (unint64_t)(v43 & 0x7F) << v40;
              if (v43 < 0)
              {
                v40 += 7;
                BOOL v12 = v41++ >= 9;
                if (v12)
                {
                  LODWORD(v18) = 0;
                  goto LABEL_109;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v18) = 0;
          }
LABEL_109:
          uint64_t v61 = 68;
          goto LABEL_135;
        case 0x23u:
          v44 = v6;
          v45 = v5;
          v46 = v4;
          v47 = objc_alloc_init(ALSMeta);

          *(void *)(a1 + 48) = v47;
          if (!PBReaderPlaceMark() || !sub_101245554((uint64_t)v47, a2)) {
            return 0;
          }
          PBReaderRecallMark();
          v4 = v46;
          uint64_t v5 = v45;
          uint64_t v6 = v44;
LABEL_136:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          break;
        default:
          switch((v9 >> 3))
          {
            case 1u:
              char v21 = 0;
              unsigned int v22 = 0;
              uint64_t v23 = 0;
              while (2)
              {
                unint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v24 == -1 || v24 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }
                else
                {
                  char v25 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 1;
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if (v25 < 0)
                  {
                    v21 += 7;
                    BOOL v12 = v22++ >= 9;
                    if (v12)
                    {
                      uint64_t v23 = 0;
                      goto LABEL_121;
                    }
                    continue;
                  }
                }
                break;
              }
              if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v23 = 0;
              }
LABEL_121:
              uint64_t v67 = v4[794];
              goto LABEL_126;
            case 2u:
              char v48 = 0;
              unsigned int v49 = 0;
              uint64_t v23 = 0;
              while (2)
              {
                unint64_t v50 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v50 == -1 || v50 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }
                else
                {
                  char v51 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v50);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v50 + 1;
                  v23 |= (unint64_t)(v51 & 0x7F) << v48;
                  if (v51 < 0)
                  {
                    v48 += 7;
                    BOOL v12 = v49++ >= 9;
                    if (v12)
                    {
                      uint64_t v23 = 0;
                      goto LABEL_125;
                    }
                    continue;
                  }
                }
                break;
              }
              if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v23 = 0;
              }
LABEL_125:
              uint64_t v67 = v5[795];
LABEL_126:
              *(void *)(a1 + v67) = v23;
              goto LABEL_136;
            case 3u:
              char v52 = 0;
              unsigned int v53 = 0;
              uint64_t v54 = 0;
              *(unsigned char *)(a1 + v6[786]) |= 0x20u;
              while (2)
              {
                unint64_t v55 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v55 == -1 || v55 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }
                else
                {
                  char v56 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v55);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v55 + 1;
                  v54 |= (unint64_t)(v56 & 0x7F) << v52;
                  if (v56 < 0)
                  {
                    v52 += 7;
                    BOOL v12 = v53++ >= 9;
                    if (v12)
                    {
                      uint64_t v54 = 0;
                      goto LABEL_130;
                    }
                    continue;
                  }
                }
                break;
              }
              if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v54 = 0;
              }
LABEL_130:
              *(unsigned char *)(a1 + 76) = v54 != 0;
              goto LABEL_136;
            case 4u:
              char v57 = 0;
              unsigned int v58 = 0;
              uint64_t v18 = 0;
              *(unsigned char *)(a1 + v6[786]) |= 1u;
              break;
            default:
              goto LABEL_34;
          }
          while (2)
          {
            unint64_t v59 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v59 == -1 || v59 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }
            else
            {
              char v60 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v59);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v59 + 1;
              v18 |= (unint64_t)(v60 & 0x7F) << v57;
              if (v60 < 0)
              {
                v57 += 7;
                BOOL v12 = v58++ >= 9;
                if (v12)
                {
                  LODWORD(v18) = 0;
                  goto LABEL_134;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v18) = 0;
          }
LABEL_134:
          uint64_t v61 = 56;
LABEL_135:
          *(_DWORD *)(a1 + v61) = v18;
          goto LABEL_136;
      }
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_100FAD2D4()
{
  sub_100134750(qword_1024827A8, "VO2MaxPowerBudgetEstimatorLastExtendedBudgetAllotmentReason");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1024827A8, (void *)&_mh_execute_header);
}

void sub_100FAD3E4(id a1)
{
  qword_102482808 = (uint64_t)[objc_alloc((Class)CLDispatchSilo) initWithIdentifier:@"CLMicroLocationNotifierSilo"];
}

uint64_t sub_100FAD4A4(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100FB5408;
  block[3] = &unk_10229FED8;
  block[4] = a1;
  if (qword_102482818 != -1) {
    dispatch_once(&qword_102482818, block);
  }
  return qword_10248AFD0;
}

void sub_100FAD704(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = sub_100103240();
  if (sub_100740C6C(v6))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    char v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      id v17 = [[objc_msgSend(a3, "UUIDString") UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Notifier adding a client for Milo connection event updates\", \"connectionToken\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
    if ([*(id *)(a1 + 3544) objectForKey:a3])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68289026;
        int v13 = 0;
        __int16 v14 = 2082;
        int v15 = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Adding a client for MiLo connection event updates failed, a client with same connection token exists\"}", buf, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
      }
      unint64_t v9 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        *(_DWORD *)buf = 68289026;
        int v13 = 0;
        __int16 v14 = 2082;
        int v15 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Adding a client for MiLo connection event updates failed, a client with same connection token exists", "{\"msg%{public}.0s\":\"Adding a client for MiLo connection event updates failed, a client with same connection token exists\"}", buf, 0x12u);
      }
    }
    else
    {
      [*(id *)(a1 + 3544) setObject:a2 forKeyedSubscript:a3];
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    unint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "registerForMiloServiceEventUpdates, MicroLocations not supported on this platform", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      char v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::registerForMiloServiceEventUpdates(id<CLMicroLocationNotifierClientProtocol>, NSUUID *)", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
}

void sub_100FADAB0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = sub_100103240();
  if (sub_100740C6C(v5))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289282;
      int v10 = 0;
      __int16 v11 = 2082;
      BOOL v12 = "";
      __int16 v13 = 2082;
      id v14 = [[objc_msgSend(a3, "UUIDString") UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Notifier removed a client for Milo connection event updates\", \"connectionToken\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
    [*(id *)(a1 + 3544) removeObjectForKey:a3];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    char v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "unregisterForMiloServiceEventUpdates, MicroLocations not supported on this platform", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      unsigned int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::unregisterForMiloServiceEventUpdates(id<CLMicroLocationNotifierClientProtocol>, NSUUID *)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
}

void sub_100FADD24(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100103240();
  if (sub_100740C6C(v4))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289026;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Added a client for Milo prediction event updates\"}", buf, 0x12u);
    }
    [*(id *)(a1 + 3552) addObject:a2];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "registerForMiloPredictionEventUpdates, MicroLocations not supported on this platform", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      char v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::registerForMiloPredictionEventUpdates(id<CLMicroLocationNotifierClientProtocol>)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

void sub_100FADF84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100103240();
  if (sub_100740C6C(v4))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289026;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"removed a client for Milo prediction event updates\"}", buf, 0x12u);
    }
    [*(id *)(a1 + 3552) removeObject:a2];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "unregisterForMiloPredictionEventUpdates, MicroLocations not supported on this platform", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      char v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::unregisterForMiloPredictionEventUpdates(id<CLMicroLocationNotifierClientProtocol>)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

void sub_100FAE25C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAE290(uint64_t a1, const std::string *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  __p = 0;
  uint64_t v54 = 0;
  unint64_t v55 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  id v8 = [a4 countByEnumeratingWithState:&v49 objects:v78 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v50;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(void *)v50 != v9) {
          objc_enumerationMutation(a4);
        }
        id v11 = [*(id *)(*((void *)&v49 + 1) + 8 * i) locationType];
        id v12 = v11;
        __int16 v13 = v54;
        if ((unint64_t)v54 >= v55)
        {
          int v15 = __p;
          uint64_t v16 = ((char *)v54 - (unsigned char *)__p) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            sub_1001D7FD4();
          }
          uint64_t v18 = v55 - (void)__p;
          if ((uint64_t)(v55 - (void)__p) >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            char v20 = (char *)sub_1000DA54C((uint64_t)&v55, v19);
            int v15 = __p;
            __int16 v13 = v54;
          }
          else
          {
            char v20 = 0;
          }
          char v21 = &v20[8 * v16];
          *(void *)char v21 = v12;
          id v14 = v21 + 8;
          while (v13 != v15)
          {
            uint64_t v22 = *--v13;
            *((void *)v21 - 1) = v22;
            v21 -= 8;
          }
          __p = v21;
          uint64_t v54 = v14;
          unint64_t v55 = (unint64_t)&v20[8 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *uint64_t v54 = v11;
          id v14 = v13 + 1;
        }
        uint64_t v54 = v14;
      }
      id v8 = [a4 countByEnumeratingWithState:&v49 objects:v78 count:16];
    }
    while (v8);
  }
  sub_10023DC48((uint64_t)&v44);
  LODWORD(v48) = v48 | 2;
  if (v45 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v45, a2);
  LODWORD(v48) = v48 | 4;
  uint64_t v46 = a3;
  *(_DWORD *)buf = 0;
  sub_1001EE1F4((int *)buf);
  *(void *)&v75[0] = sub_1001EC8C4((ssize_t)buf);
  *((void *)&v75[0] + 1) = v23;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100FBCC78(v75, (uint64_t)&v44, (uint64_t)v57, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), v57);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v57[2]);
  sub_1001EF3E8((unsigned int *)buf);
  unint64_t v42 = 0;
  uint64_t v43 = 0;
  unsigned int v41 = 0;
  sub_1001DD364(&v41, __p, (uint64_t)v54, ((char *)v54 - (unsigned char *)__p) >> 3);
  sub_10031370C(a1 + 584, (uint64_t)a2, a3, (uint64_t)&v41, a6, (uint64_t)v75);
  unint64_t v32 = v41;
  if (v41)
  {
    unint64_t v42 = v41;
    operator delete(v41);
  }
  memset((char *)&v57[1] + 8, 0, 48);
  char v59 = 0;
  char v60 = 0;
  char v61 = 0;
  memset(&v57[6], 0, 48);
  char v58 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  uint64_t v62 = -1;
  uint64_t v70 = -1;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  if (v77 == -1)
  {
    if (!v76)
    {
      sub_101A993F8((uint64_t)v32, v25, v26, v27, v28, v29, v30, v31, v33, v34, v35, v36, a5, a6, (uint64_t)a2, a3, (uint64_t)v41, (uint64_t)v42, v43,
        v44,
        (uint64_t)v45,
        v46,
        v47,
        v48);
      abort_report_np();
      __break(1u);
    }
    *((void *)&v57[0] + 1) = 1;
    long long v71 = v75[0];
  }
  else
  {
    *((void *)&v57[0] + 1) = 2;
    uint64_t v70 = v77;
  }
  sub_100FBC288();
}

void sub_100FAE738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  if (__p)
  {
    a35 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FAE878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FAE8AC(uint64_t a1, std::string *a2, void *a3, uint64_t a4, unsigned __int8 *a5)
{
  id v8 = sub_1002E5990(a3, (uint64_t)&v54);
  if (v55)
  {
    sub_10023DC84((uint64_t)&v23);
    LODWORD(v27) = v27 | 2;
    if (v24 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v24, a2);
    if (!v55) {
      sub_10020D700();
    }
    memset(&__str, 0, sizeof(__str));
    if ((sub_1001E86C0((uint64_t)&v54, &__str) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v31);
      *(void *)&long long v31 = &off_10229E8C8;
      sub_1001E91E8((uint64_t)&v31);
    }
    LODWORD(v27) = v27 | 4;
    if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v25, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    LODWORD(buf) = 0;
    sub_1001EE1F4((int *)&buf);
    __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&buf);
    __str.__r_.__value_.__l.__size_ = v9;
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_100FBCD04(&__str, (uint64_t)&v23, (uint64_t)&v31, Current_5);
    sub_100219EBC((uint64_t *)(a1 + 552), &v31);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v33[1]);
    sub_1001EF3E8((unsigned int *)&buf);
    if (!v55) {
      sub_10020D700();
    }
    sub_1003137B8(a1 + 584, (unsigned __int8 *)a2, v54, *((uint64_t *)&v54 + 1), a5, (__n128 *)&__str);
    memset(v33, 0, 48);
    char v35 = 0;
    char v36 = 0;
    char v37 = 0;
    memset(&v33[9], 0, 48);
    char v34 = 0;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long __p = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    uint64_t v38 = -1;
    uint64_t v46 = -1;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    if (v53 != -1)
    {
      *((void *)&v31 + 1) = 4;
      if (!v55) {
        sub_10020D700();
      }
      long long v47 = v54;
      uint64_t v46 = v53;
LABEL_16:
      sub_100FBC288();
    }
    if (v52)
    {
      *((void *)&v31 + 1) = 3;
      long long v47 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
      goto LABEL_16;
    }
    sub_101A996BC(v11, v12, v13, v14, v15, v16, v17, v18, v20, v21, v22, v23, (uint64_t)v24, (uint64_t)v25, v26, v27, buf, v29, v30[0],
      v30[1],
      v31,
      *((uint64_t *)&v31 + 1),
      (uint64_t)v32,
      v33[0]);
    uint64_t result = abort_report_np();
  }
  else
  {
    uint64_t result = sub_101A99550(v8);
  }
  __break(1u);
  return result;
}

void sub_100FAECA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,std::bad_cast a21)
{
}

void sub_100FAEDC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAEDFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_100313958(a1 + 584, a2, a4, &v6);
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  char v16 = 0;
  char v17 = 0;
  char v18 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  char v15 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long __p = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v19 = -1;
  uint64_t v27 = -1;
  memset(v28, 0, 48);
  uint64_t v8 = 5;
  uint64_t v4 = (long long *)v6;
  uint64_t v5 = v7;
  if (v6 != v7)
  {
    do
    {
      memset(v31, 0, sizeof(v31));
      long long buf = *v4;
      uint64_t v30 = *((void *)v4 + 2);
      sub_100FC426C(v28, &buf);
      sub_10041F48C(v31);
      v4 += 2;
    }
    while (v4 != v5);
  }
  sub_100FBC288();
}

void sub_100FAF044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FAF124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAF158(uint64_t a1, std::string *a2, void *a3, void *a4, const void **a5)
{
  sub_1002E5990(a3, (uint64_t)&v34);
  id v9 = sub_1002E5990(a4, (uint64_t)v32);
  if (!v35)
  {
    sub_101A99814(v9);
LABEL_25:
    __break(1u);
    return;
  }
  if (!v33)
  {
    sub_101A99980(v9);
    goto LABEL_25;
  }
  sub_10023DCC0((uint64_t)v14);
  v17 |= 2u;
  if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v15, a2);
  if (!v35) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)&v34, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast(v18);
    v18[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
    sub_1001E91E8((uint64_t)v18);
  }
  v17 |= 4u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v16, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  int v13 = 0;
  sub_1001EE1F4(&v13);
  __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v13);
  __str.__r_.__value_.__l.__size_ = v10;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100FBCD90(&__str, (uint64_t)v14, (uint64_t)v18, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), (long long *)v18);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)((char *)v19 + 8));
  sub_1001EF3E8((unsigned int *)&v13);
  if (!v35 || !v33) {
    sub_10020D700();
  }
  uint64_t v12 = sub_100313960(a1 + 584, (size_t *)a2, v34, *((uint64_t *)&v34 + 1), v32[0], v32[1], a5);
  memset(v19, 0, 48);
  char v22 = 0;
  char v23 = 0;
  char v24 = 0;
  memset(v20, 0, sizeof(v20));
  char v21 = 0;
  uint64_t v25 = -1;
  long long v26 = 0u;
  memset(v27, 0, sizeof(v27));
  uint64_t v28 = -1;
  memset(v30, 0, 48);
  if (v12 != -1)
  {
    v18[1].__vftable = (std::bad_cast_vtbl *)8;
    uint64_t v28 = v12;
    if (v35)
    {
      long long v29 = v34;
      sub_100FBC288();
    }
    sub_10020D700();
  }
  sub_100FC10FC(v30);
  sub_1000D80C4(&v27[1]);
  if ((void)v26)
  {
    *((void *)&v26 + 1) = v26;
    operator delete((void *)v26);
  }
  sub_10041F48C(v20);
  sub_10041F48C(v19);
  sub_10025897C((wireless_diagnostics::google::protobuf::MessageLite *)v14);
}

void sub_100FAF48C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::bad_cast a18)
{
}

void sub_100FAF5B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAF5E8(uint64_t a1, std::string *a2, void *a3, void *a4, unsigned __int8 *a5)
{
  id v9 = sub_1002E5990(a3, (uint64_t)&v40);
  if (!v41)
  {
    sub_101A99AEC(v9);
LABEL_23:
    __break(1u);
    return;
  }
  id v10 = sub_1002E5990(a4, (uint64_t)v38);
  if (!v39)
  {
    sub_101A99C58(v10);
    goto LABEL_23;
  }
  sub_10023DCFC((uint64_t)v15);
  v18 |= 2u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v16, a2);
  if (!v41) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)&v40, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast(v19);
    v19[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
    sub_1001E91E8((uint64_t)v19);
  }
  v18 |= 4u;
  if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v17, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  int v14 = 0;
  sub_1001EE1F4(&v14);
  __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v14);
  __str.__r_.__value_.__l.__size_ = v11;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100FBCE1C(&__str, (uint64_t)v15, (uint64_t)v19, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), (long long *)v19);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v19[4]);
  sub_1001EF3E8((unsigned int *)&v14);
  if (!v41 || !v39) {
    sub_10020D700();
  }
  uint64_t v13 = sub_100313968(a1 + 584, (unsigned __int8 *)a2, v40, *((uint64_t *)&v40 + 1), v38[0], v38[1], a5);
  sub_10021A0B0((uint64_t *)(a1 + 552));
  if (v13 != -1)
  {
    memset(&v19[3], 0, 48);
    char v21 = 0;
    char v22 = 0;
    char v23 = 0;
    memset(&v19[12], 0, 48);
    char v20 = 0;
    uint64_t v24 = -1;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    v19[1].__vftable = (std::bad_cast_vtbl *)9;
    uint64_t v32 = v13;
    if (v41)
    {
      long long v33 = v40;
      sub_100FBC288();
    }
    sub_10020D700();
  }
  sub_100259204((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_100FAF92C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::bad_cast a18)
{
}

void sub_100FAFA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAFA4C(uint64_t a1, const std::string *a2, void *a3, void *a4)
{
  id v7 = sub_1002E5990(a3, (uint64_t)v41);
  if (!v42)
  {
    sub_101A99DC4(v7);
LABEL_31:
    __break(1u);
    return;
  }
  id v8 = sub_1002E5990(a4, (uint64_t)&v39);
  if (!v40)
  {
    sub_101A99F30(v8);
    goto LABEL_31;
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  double v17 = Current_5;
  sub_10023DDEC((uint64_t)v12);
  v16 |= 2u;
  if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v13, a2);
  if (!v42) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)v41, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&v18);
    *(void *)&long long v18 = &off_10229E8C8;
    sub_1001E91E8((uint64_t)&v18);
  }
  v16 |= 4u;
  if (v14 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v14, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (!v40) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)&v39, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&v18);
    *(void *)&long long v18 = &off_10229E8C8;
    sub_1001E91E8((uint64_t)&v18);
  }
  v16 |= 8u;
  if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v15, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  int v11 = 0;
  sub_1001EE1F4(&v11);
  __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v11);
  __str.__r_.__value_.__l.__size_ = v10;
  sub_100FBCEA8(&__str, (uint64_t)v12, (uint64_t)&v18, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), &v18);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v20[1]);
  sub_1001EF3E8((unsigned int *)&v11);
  if (!v42 || !v40) {
    sub_10020D700();
  }
  if ((sub_100313974(a1 + 584, v41[0], v41[1], &v39, (uint64_t)&v17, 1) & 1) == 0)
  {
    memset(v20, 0, 48);
    char v22 = 0;
    char v23 = 0;
    char v24 = 0;
    memset(&v20[9], 0, 48);
    char v21 = 0;
    uint64_t v25 = -1;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v33 = -1;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *((void *)&v18 + 1) = 10;
    if (v40)
    {
      long long v37 = v39;
      uint64_t v33 = 29;
      sub_100FBC288();
    }
    sub_10020D700();
  }
  sub_10025B9F0((wireless_diagnostics::google::protobuf::MessageLite *)v12);
}

void sub_100FAFE5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::bad_cast a20)
{
}

void sub_100FAFF80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAFF9C(uint64_t a1, const std::string *a2, void *a3, void *a4, void *a5)
{
  id v9 = sub_1002E5990(a3, (uint64_t)v31);
  if (!v32)
  {
    sub_101A9A09C(v9);
LABEL_39:
    __break(1u);
    return;
  }
  id v10 = sub_1002E5990(a4, (uint64_t)v29);
  if (!v30)
  {
    sub_101A9A208(v10);
    goto LABEL_39;
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  double v20 = Current_5;
  LOBYTE(v27) = 0;
  char v28 = 0;
  if (a5)
  {
    sub_1002E5990(a5, (uint64_t)v23);
    long long v27 = *(_OWORD *)&v23[0].__vftable;
    char v28 = (char)v24;
  }
  sub_10023DDAC((uint64_t)v14);
  v19 |= 2u;
  if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v15, a2);
  if (!v32) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)v31, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast(v23);
    v23[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
    sub_1001E91E8((uint64_t)v23);
  }
  v19 |= 4u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v16, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (!v30) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)v29, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast(v23);
    v23[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
    sub_1001E91E8((uint64_t)v23);
  }
  v19 |= 8u;
  if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v17, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v28)
  {
    memset(&__str, 0, sizeof(__str));
    if ((sub_1001E86C0((uint64_t)&v27, &__str) & 1) == 0)
    {
      std::bad_cast::bad_cast(v23);
      v23[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
      sub_1001E91E8((uint64_t)v23);
    }
    v19 |= 0x10u;
    if (v18 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v18, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  int v13 = 0;
  sub_1001EE1F4(&v13);
  __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v13);
  __str.__r_.__value_.__l.__size_ = v12;
  sub_100FBCF34(&__str, (uint64_t)v14, (uint64_t)v23, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), (long long *)v23);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v25);
  sub_1001EF3E8((unsigned int *)&v13);
  if (!v32 || !v30) {
LABEL_33:
  }
    sub_10020D700();
  long long v21 = v27;
  char v22 = v28;
  if ((sub_10031397C(a1 + 584, v31[0], v31[1], v29[0], v29[1], &v21, (uint64_t)&v20) & 1) == 0)
  {
    if (v30) {
      sub_100FBC4A8();
    }
    goto LABEL_33;
  }
  sub_10025AE84((wireless_diagnostics::google::protobuf::MessageLite *)v14);
}

void sub_100FB03D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::bad_cast a25)
{
  std::bad_cast::~bad_cast(&a25);
  if (*(char *)(v26 - 145) < 0) {
    operator delete(*v25);
  }
  sub_10025AE84((wireless_diagnostics::google::protobuf::MessageLite *)&a13);
  _Unwind_Resume(a1);
}

void sub_100FB04F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FB0510(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = sub_1002E5990(a3, (uint64_t)v21);
  if (!v22)
  {
    id v11 = (id)sub_101A9A374(v10);
    goto LABEL_12;
  }
  id v11 = sub_1002E5990(a4, (uint64_t)v19);
  if (!v20)
  {
LABEL_12:
    id v12 = (id)sub_101A9A4D8(v11);
    goto LABEL_13;
  }
  id v12 = sub_1002E5990(a5, (uint64_t)v17);
  if (!v18)
  {
LABEL_13:
    id v13 = (id)sub_101A9A63C(v12);
    goto LABEL_14;
  }
  id v13 = sub_1002E5990(a6, (uint64_t)v15);
  if (!v18)
  {
LABEL_14:
    sub_101A9A7A0(v13);
    goto LABEL_15;
  }
  if (!v22 || !v16) {
LABEL_15:
  }
    sub_10020D700();
  BOOL result = sub_1003145EC(a1 + 584, v21[0], v21[1], v15[0], v15[1], v17[0], v17[1]);
  if (!result)
  {
    if (v20) {
      sub_100FBC4A8();
    }
    goto LABEL_15;
  }
  return result;
}

void sub_100FB06C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB06DC(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7)
{
  id v12 = sub_1002E5990(a3, (uint64_t)v18);
  if (v19)
  {
    id v13 = sub_1002E5990(a4, (uint64_t)v16);
    if (v17)
    {
      id v14 = sub_1002E5990(a5, (uint64_t)v15);
      if (v15[16])
      {
        if (v19 && v17)
        {
          if (sub_1003145F4(a1 + 584, v18[0], v18[1], (uint64_t)v16, (uint64_t)v15, a6, a7))
          {
            if (v17) {
LABEL_10:
            }
              sub_100FBC4A8();
          }
          else if (v17)
          {
            goto LABEL_10;
          }
        }
LABEL_14:
        sub_10020D700();
      }
LABEL_13:
      sub_101A9ABCC(v14);
      goto LABEL_14;
    }
  }
  else
  {
    id v13 = (id)sub_101A9A904(v12);
  }
  id v14 = (id)sub_101A9AA68(v13);
  goto LABEL_13;
}

void sub_100FB0884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB08A0(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4, uint64_t a5)
{
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  char v37 = 0;
  char v38 = 0;
  char v39 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  char v36 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long __p = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v40 = -1;
  uint64_t v48 = -1;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t v29 = 10;
  id v9 = sub_1002E5990(a4, (uint64_t)&v27[7]);
  if (v27[23])
  {
    uint64_t v48 = 15;
    long long v52 = *(_OWORD *)&v27[7];
    if (qword_102419450 == -1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_101A9AD30((uint64_t)v9, v10, v11, v12, v13, v14, v15, v16, v19, v20, v21, v22, buf, *(uint64_t *)v24, *(uint64_t *)&v24[8], *(uint64_t *)&v24[16], *(uint64_t *)&v24[24], v25, v26,
      *((uint64_t *)&v26 + 1),
      *(uint64_t *)v27,
      *(uint64_t *)&v27[8],
      *(uint64_t *)&v27[16],
      v28);
    abort_report_np();
    __break(1u);
  }
  dispatch_once(&qword_102419450, &stru_102308378);
LABEL_3:
  char v17 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      char v18 = a2;
    }
    else {
      char v18 = (uint64_t *)*a2;
    }
    uint64_t buf = 68290050;
    *(_WORD *)char v24 = 2082;
    *(void *)&v24[2] = "";
    *(_WORD *)&v24[10] = 2082;
    *(void *)&v24[12] = v18;
    *(_WORD *)&v24[20] = 2114;
    *(void *)&v24[22] = a3;
    *(_WORD *)&v24[30] = 2114;
    uint64_t v25 = (uint64_t)a4;
    LOWORD(v26) = 2114;
    *(void *)((char *)&v26 + 2) = a5;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"fake processing requestRemoveLabelsForClient\", \"clientId\":%{public, location:escape_only}s, \"serviceIdentifier\":%{public, location:escape_only}@, \"requestIdentifier\":%{public, location:escape_only}@, \"labels\":%{public, location:escape_only}@}", (uint8_t *)&buf, 0x3Au);
  }
  sub_100FBC288();
}

void sub_100FB0AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  sub_100FBC3C0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100FB0B74(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = sub_1002E5990(a2, (uint64_t)&v13);
  if (v14)
  {
    id v8 = sub_1002E5990(a3, (uint64_t)v11);
    if (v12)
    {
      if (v14)
      {
        sub_100134750(__p, (char *)[a4 UTF8String]);
        sub_1003147EC(a1 + 584, &v13, (uint64_t)__p);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
        if (v12) {
          sub_100FBC4A8();
        }
        sub_10020D700();
      }
      sub_10020D700();
    }
    sub_101A9AFF4(v8);
  }
  else
  {
    sub_101A9AE88(v7);
  }
  __break(1u);
}

void sub_100FB0C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB0D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB0D4C(uint64_t a1, const std::string *a2, void *a3, void *a4, void *a5)
{
  id v9 = sub_1002E5990(a3, (uint64_t)v24);
  if (v25)
  {
    id v10 = sub_1002E5990(a4, (uint64_t)v22);
    if (v23)
    {
      if (a5) {
        LODWORD(a5) = [a5 isLowLatency];
      }
      sub_10023DD38((uint64_t)v14);
      v18 |= 2u;
      if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v15, a2);
      if (v25)
      {
        memset(&__str, 0, sizeof(__str));
        if (sub_1001E86C0((uint64_t)v24, &__str))
        {
          v18 |= 4u;
          if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v17, &__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          v18 |= 8u;
          char v16 = (char)a5;
          int v13 = 0;
          sub_1001EE1F4(&v13);
          __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v13);
          __str.__r_.__value_.__l.__size_ = v11;
          double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
          sub_100FBCFC0(&__str, (uint64_t)v14, (uint64_t)v19, Current_5);
          sub_100219EBC((uint64_t *)(a1 + 552), (long long *)v19);
          sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v20);
          sub_1001EF3E8((unsigned int *)&v13);
          if (v25)
          {
            sub_10031479C(a1 + 584, v24, (int)a5);
            if (v23) {
              sub_100FBC4A8();
            }
            sub_10020D700();
          }
          sub_10020D700();
        }
        std::bad_cast::bad_cast(v19);
        v19[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
        sub_1001E91E8((uint64_t)v19);
      }
      sub_10020D700();
    }
    sub_101A9B2CC(v10);
  }
  else
  {
    sub_101A9B160(v9);
  }
  __break(1u);
}

void sub_100FB0FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, unsigned int a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::bad_cast a18)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v18 + 32));
  sub_1001EF3E8(&a11);
  sub_100259AB4((wireless_diagnostics::google::protobuf::MessageLite *)&a12);
  _Unwind_Resume(a1);
}

void sub_100FB10C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB10E4(uint64_t a1, const std::string *a2, void *a3, void *a4)
{
  id v7 = sub_1002E5990(a3, (uint64_t)v60);
  if (v61)
  {
    long long v39 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    char v44 = 0;
    char v45 = 0;
    char v46 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    char v43 = 0;
    uint64_t v47 = -1;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    uint64_t v55 = -1;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    uint64_t v36 = 10;
    id v8 = sub_1002E5990(a4, (uint64_t)&v34);
    if (v35)
    {
      if (v61)
      {
        uint64_t v16 = sub_1003147A4(a1 + 584, v60) ? -1 : 17;
        uint64_t v55 = v16;
        if (v35)
        {
          long long v59 = v34;
          sub_10023DD70((uint64_t)&v24);
          LODWORD(v28) = v28 | 2;
          if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v25, a2);
          if (v61)
          {
            memset(&__str, 0, sizeof(__str));
            if (sub_1001E86C0((uint64_t)v60, &__str))
            {
              LODWORD(v28) = v28 | 4;
              if (v26 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
                operator new();
              }
              std::string::operator=(v26, &__str);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              HIDWORD(v23) = 0;
              sub_1001EE1F4((int *)&v23 + 1);
              __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v23 + 4);
              __str.__r_.__value_.__l.__size_ = v17;
              double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
              sub_100FBD04C(&__str, (uint64_t)&v24, (uint64_t)&v29, Current_5);
              sub_100219EBC((uint64_t *)(a1 + 552), &v29);
              sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v32);
              sub_1001EF3E8((unsigned int *)&v23 + 1);
              if (v35) {
                sub_100FBC4A8();
              }
              sub_10020D700();
            }
            std::bad_cast::bad_cast((std::bad_cast *)&v29);
            *(void *)&long long v29 = &off_10229E8C8;
            sub_1001E91E8((uint64_t)&v29);
          }
          sub_10020D700();
        }
      }
      sub_10020D700();
    }
    sub_101A9B5A4((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15, v19, v20, v21, v22, v23, v24, (uint64_t)v25, (uint64_t)v26, v27, v28, v29,
      *((uint64_t *)&v29 + 1),
      (uint64_t)v30,
      v31,
      v32[0],
      v32[1]);
    abort_report_np();
  }
  else
  {
    sub_101A9B438(v7);
  }
  __break(1u);
}

void sub_100FB1440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::bad_cast a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v68 + 32));
  sub_1001EF3E8(&a14);
  sub_10025A410((wireless_diagnostics::google::protobuf::MessageLite *)&a15);
  sub_100FBC3C0(&a68);
  _Unwind_Resume(a1);
}

void sub_100FB1604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB1628(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = sub_1002E5990(a3, (uint64_t)v12);
  if (!v13)
  {
    id v8 = (id)sub_101A9B6FC(v7);
    goto LABEL_6;
  }
  id v8 = sub_1002E5990(a4, (uint64_t)&v10);
  if (!v11)
  {
LABEL_6:
    sub_101A9B860(v8);
LABEL_7:
    sub_10020D700();
  }
  if (!v13) {
    goto LABEL_7;
  }
  return sub_100314744(a1 + 584, a2, v12[0], v12[1], &v10);
}

void sub_100FB1804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB1828(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = sub_1002E5990(a3, (uint64_t)v5);
  if (!v5[16]) {
    sub_101A9B9C4(v4);
  }
  sub_100311188(a1 + 584);
  sub_100FBCBB8(a1);
}

void sub_100FB19DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB1A00(uint64_t a1, uint64_t a2, void *a3)
{
  LOBYTE(v18[0]) = 0;
  char v20 = 0;
  long long v16 = xmmword_101D9A4E0;
  sub_1002E5990(a3, (uint64_t)&v14);
  if (v15) {
    long long v17 = v14;
  }
  sub_100134750(&__p, "");
  sub_100FB2C10(a1, 0, (char *)buf);
  sub_100FC0F60((uint64_t)v18, (long long *)buf);
  sub_100FC0D88((uint64_t)buf);
  if (v7 < 0) {
    operator delete(__p);
  }
  if (v20)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    id v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (v19 >= 0) {
        uint64_t v5 = v18;
      }
      else {
        uint64_t v5 = (void *)v18[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      char v11 = "";
      __int16 v12 = 2082;
      char v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MicroLocation DB Tables exported\", \"path\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
  }
  else
  {
    *((void *)&v16 + 1) = 0;
  }
  sub_100FBBE68();
}

void sub_100FB1BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB1C9C(uint64_t a1, void *a2, void *a3, void *a4)
{
  sub_1002E5990(a2, (uint64_t)v21);
  sub_1002E5990(a4, (uint64_t)v19);
  id v7 = sub_1002E5990(a3, (uint64_t)&v17);
  if (!v22)
  {
    sub_101A9BB28(v7);
    goto LABEL_23;
  }
  if (!v20)
  {
    sub_101A9BC94(v7);
    goto LABEL_23;
  }
  if (!v18)
  {
    sub_101A9BE00(v7);
LABEL_23:
    __break(1u);
  }
  sub_10023DF18((uint64_t)v11);
  if (!v22) {
    sub_10020D700();
  }
  memset(&__str, 0, sizeof(__str));
  if ((sub_1001E86C0((uint64_t)v21, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast(v14);
    v14[0].__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
    sub_1001E91E8((uint64_t)v14);
  }
  v13 |= 2u;
  if (v12 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v12, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  int v10 = 0;
  sub_1001EE1F4(&v10);
  __str.__r_.__value_.__r.__words[0] = sub_1001EC8C4((ssize_t)&v10);
  __str.__r_.__value_.__l.__size_ = v8;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100FBC41C(&__str, (uint64_t)v11, (uint64_t)v14, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), (long long *)v14);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
  sub_1001EF3E8((unsigned int *)&v10);
  if (!v22 || !v18 || !v20) {
LABEL_20:
  }
    sub_10020D700();
  if (sub_1003145FC(a1 + 584, v21[0], v21[1], &v17) != -1)
  {
    if (v18) {
      sub_100FBC4A8();
    }
    goto LABEL_20;
  }
  sub_10025EA0C((wireless_diagnostics::google::protobuf::MessageLite *)v11);
}

void sub_100FB1EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, unsigned int a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, std::bad_cast a16)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v16 + 32));
  sub_1001EF3E8(&a10);
  sub_10025EA0C((wireless_diagnostics::google::protobuf::MessageLite *)&a11);
  _Unwind_Resume(a1);
}

void sub_100FB1FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB1FE8(void *a1, const std::string *a2, void *a3, void (**a4)(void, void))
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  std::string::size_type v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v9 = a2;
    }
    else {
      int v9 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 68289795;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v35 = 2082;
    uint64_t v36 = "";
    __int16 v37 = 2082;
    long long v38 = "Client request";
    __int16 v39 = 2082;
    long long v40 = "Current microlocation";
    __int16 v41 = 2081;
    long long v42 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s}", buf, 0x30u);
  }
  if (sub_1002A3270((uint64_t)(a1 + 401), a3))
  {
    sub_100103240();
    if (!sub_100740E34())
    {
      if (!a4) {
        return 0;
      }
LABEL_17:
      id v18 = objc_alloc((Class)NSError);
      long long v33 = +[NSString stringWithFormat:@"requestCurrentMicroLocation failed internally, MiLo is not at right state", NSLocalizedDescriptionKey];
      char v19 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
      ((void (**)(void, id))a4)[2](a4, [v18 initWithDomain:kCLErrorDomainPrivate code:5 userInfo:v19]);
      return 0;
    }
    id v10 = [objc_alloc((Class)NSMutableDictionary) initWithDictionary:a3 copyItems:1];
    [v10 setObject:&off_102393848 forKeyedSubscript:@"shouldTriggerLocalizationScan"];
    *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
    uint64_t v11 = sub_1002A2480((uint64_t)(a1 + 401), v10, (double *)buf);
    id v12 = v10;
    if (!a4) {
      return v11;
    }
  }
  else
  {
    *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
    uint64_t v11 = sub_1002A2B08((uint64_t)(a1 + 401), a2, (double *)buf);
    if (!a4) {
      return v11;
    }
  }
  if (!v11) {
    goto LABEL_17;
  }
  int v13 = a4;
  long long v14 = v13;
  uint64_t v15 = (void *)a1[440];
  unint64_t v16 = a1[441];
  if ((unint64_t)v15 >= v16)
  {
    uint64_t v20 = a1[439];
    uint64_t v21 = ((uint64_t)v15 - v20) >> 3;
    if ((unint64_t)(v21 + 1) >> 61) {
      sub_1001D7FD4();
    }
    uint64_t v22 = v16 - v20;
    uint64_t v23 = v22 >> 2;
    if (v22 >> 2 <= (unint64_t)(v21 + 1)) {
      uint64_t v23 = v21 + 1;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v23;
    }
    if (v24) {
      char v25 = (char *)sub_1000DA54C((uint64_t)(a1 + 441), v24);
    }
    else {
      char v25 = 0;
    }
    long long v26 = &v25[8 * v21];
    uint64_t v27 = &v25[8 * v24];
    *(void *)long long v26 = v14;
    long long v17 = v26 + 8;
    uint64_t v28 = (char *)a1[440];
    long long v29 = (char *)a1[439];
    if (v28 != v29)
    {
      do
      {
        uint64_t v30 = *((void *)v28 - 1);
        v28 -= 8;
        *((void *)v26 - 1) = v30;
        v26 -= 8;
      }
      while (v28 != v29);
      uint64_t v28 = (char *)a1[439];
    }
    a1[439] = v26;
    a1[440] = v17;
    a1[441] = v27;
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *uint64_t v15 = v13;
    long long v17 = v15 + 1;
  }
  a1[440] = v17;
  return 1;
}

void sub_100FB2398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB23B4(void *a1, char *a2, void *a3, void (**a4)(void, void))
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  std::string::size_type v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      int v9 = a2;
    }
    else {
      int v9 = *(char **)a2;
    }
    *(_DWORD *)uint64_t buf = 68289795;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v36 = 2082;
    __int16 v37 = "";
    __int16 v38 = 2082;
    __int16 v39 = "Client request";
    __int16 v40 = 2082;
    __int16 v41 = "Recording scan request";
    __int16 v42 = 2081;
    char v43 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s}", buf, 0x30u);
  }
  if (!sub_1002A3270((uint64_t)(a1 + 401), a3))
  {
    *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
    uint64_t v11 = sub_1002A292C((uint64_t)(a1 + 401), (void **)a2, a3, (double *)buf);
LABEL_12:
    if (!a4) {
      return v11;
    }
    goto LABEL_19;
  }
  sub_100103240();
  if (sub_100740E34())
  {
    id v10 = [objc_alloc((Class)NSMutableDictionary) initWithDictionary:a3 copyItems:1];
    [v10 setObject:&off_102393848 forKeyedSubscript:@"shouldTriggerRecordingScan"];
    *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
    uint64_t v11 = sub_1002A2480((uint64_t)(a1 + 401), v10, (double *)buf);
    id v12 = v10;
    goto LABEL_12;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  int v13 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v36 = 2082;
    __int16 v37 = "";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"device doesn't support suggestions so suppressing request\"}", buf, 0x12u);
  }
  uint64_t v11 = 0;
  if (a4)
  {
LABEL_19:
    if (v11)
    {
      long long v14 = a4;
      uint64_t v15 = v14;
      unint64_t v16 = (void *)a1[437];
      unint64_t v17 = a1[438];
      if ((unint64_t)v16 >= v17)
      {
        uint64_t v21 = a1[436];
        uint64_t v22 = ((uint64_t)v16 - v21) >> 3;
        if ((unint64_t)(v22 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v23 = v17 - v21;
        uint64_t v24 = v23 >> 2;
        if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
          uint64_t v24 = v22 + 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          long long v26 = (char *)sub_1000DA54C((uint64_t)(a1 + 438), v25);
        }
        else {
          long long v26 = 0;
        }
        uint64_t v27 = &v26[8 * v22];
        uint64_t v28 = &v26[8 * v25];
        *(void *)uint64_t v27 = v15;
        id v18 = v27 + 8;
        long long v29 = (char *)a1[437];
        uint64_t v30 = (char *)a1[436];
        if (v29 != v30)
        {
          do
          {
            uint64_t v31 = *((void *)v29 - 1);
            v29 -= 8;
            *((void *)v27 - 1) = v31;
            v27 -= 8;
          }
          while (v29 != v30);
          long long v29 = (char *)a1[436];
        }
        a1[436] = v27;
        a1[437] = v18;
        a1[438] = v28;
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *unint64_t v16 = v14;
        id v18 = v16 + 1;
      }
      a1[437] = v18;
    }
    else
    {
      id v19 = objc_alloc((Class)NSError);
      long long v34 = +[NSString stringWithFormat:@"requestMicroLocationRecordingScan failed internally, MiLo is not at right state", NSLocalizedDescriptionKey];
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v34 forKeys:&v33 count:1];
      ((void (**)(void, id))a4)[2](a4, [v19 initWithDomain:kCLErrorDomainPrivate code:5 userInfo:v20]);
    }
  }
  return v11;
}

void sub_100FB28B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB2BD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

void sub_100FB2C10(uint64_t a1@<X0>, int a2@<W2>, char *a3@<X8>)
{
  if ((a2 & 1) == 0)
  {
    sub_100103240();
    if ((sub_10073E30C() & 1) == 0)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      id v18 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Export DB requests are served in internal builds only!\"}", buf, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
      }
      uint64_t v15 = qword_102419458;
      if (!os_signpost_enabled((os_log_t)qword_102419458)) {
        goto LABEL_40;
      }
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      unint64_t v16 = "Export DB requests are served in internal builds only!";
      unint64_t v17 = "{\"msg%{public}.0s\":\"Export DB requests are served in internal builds only!\"}";
LABEL_30:
      id v19 = v15;
      uint32_t v20 = 18;
LABEL_39:
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v16, v17, buf, v20);
LABEL_40:
      *a3 = 0;
      a3[72] = 0;
      return;
    }
  }
  sub_100206EC0(a1 + 248);
  if (!sub_1002083F4(a1 + 248))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    long long v14 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Error: Unable to export MicroLocation DB - local DB is not ready!\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
    }
    uint64_t v15 = qword_102419458;
    if (!os_signpost_enabled((os_log_t)qword_102419458)) {
      goto LABEL_40;
    }
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    unint64_t v16 = "Error: Unable to export MicroLocation DB - local DB is not ready!";
    unint64_t v17 = "{\"msg%{public}.0s\":\"Error: Unable to export MicroLocation DB - local DB is not ready!\"}";
    goto LABEL_30;
  }
  sub_10021A0B0((uint64_t *)(a1 + 552));
  uint64_t v6 = "ExportedMicroLocationDB.db";
  if (a2) {
    uint64_t v6 = "ExportedMiloDB.db";
  }
  __s = (char *)v6;
  id v7 = NSTemporaryDirectory();
  NSFileAttributeKey v56 = NSFilePosixPermissions;
  long long v57 = &off_102393860;
  uint64_t v49 = 0;
  if (![+[NSFileManager defaultManager](NSFileManager, "defaultManager") setAttributes:+[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1] ofItemAtPath:v7 error:&v49])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v21 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = [(NSString *)v7 UTF8String];
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v22;
      *(_WORD *)&buf[28] = 2113;
      *(void *)&buf[30] = v49;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
    }
    uint64_t v23 = qword_102419458;
    if (!os_signpost_enabled((os_log_t)qword_102419458)) {
      goto LABEL_40;
    }
    uint64_t v24 = [(NSString *)v7 UTF8String];
    *(_DWORD *)uint64_t buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v24;
    *(_WORD *)&buf[28] = 2113;
    *(void *)&buf[30] = v49;
    unint64_t v16 = "failed to set attributes for file";
    unint64_t v17 = "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \""
          "error\":%{private, location:escape_only}@}";
    id v19 = v23;
LABEL_38:
    uint32_t v20 = 38;
    goto LABEL_39;
  }
  if (a2) {
    std::string::size_type v8 = "microLocationDB";
  }
  else {
    std::string::size_type v8 = "microLocationDiagnosticDB";
  }
  int v9 = [(NSString *)v7 stringByAppendingPathComponent:+[NSString stringWithUTF8String:v8]];
  if ([+[NSFileManager defaultManager] fileExistsAtPath:v9 isDirectory:0])
  {
    v46[0] = 0;
    if (![+[NSFileManager defaultManager] removeItemAtPath:v9 error:v46])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      long long v29 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = [(NSString *)v9 UTF8String];
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = v30;
        *(_WORD *)&buf[28] = 2113;
        *(void **)&buf[30] = v46[0];
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to remove existing destination directory\", \"directory\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
      }
      uint64_t v31 = qword_102419458;
      if (!os_signpost_enabled((os_log_t)qword_102419458)) {
        goto LABEL_40;
      }
      uint64_t v32 = [(NSString *)v9 UTF8String];
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v32;
      *(_WORD *)&buf[28] = 2113;
      *(void **)&buf[30] = v46[0];
      unint64_t v16 = "failed to remove existing destination directory";
      unint64_t v17 = "{\"msg%{public}.0s\":\"failed to remove existing destination directory\", \"directory\":%{private, location:"
            "escape_only}s, \"error\":%{private, location:escape_only}@}";
      id v19 = v31;
      goto LABEL_38;
    }
  }
  uint64_t v48 = 0;
  NSFileAttributeKey v54 = NSFilePosixPermissions;
  uint64_t v55 = &off_102393878;
  id v10 = +[NSDictionary dictionaryWithObjects:&v55 forKeys:&v54 count:1];
  uint64_t v11 = [[CLOSTransaction alloc] initWithDescription:"com.apple.locationd.microlocation.export-db"];
  if (![+[NSFileManager defaultManager] createDirectoryAtPath:v9 withIntermediateDirectories:0 attributes:v10 error:&v48])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    unint64_t v25 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      long long v26 = [(NSString *)v9 UTF8String];
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v26;
      *(_WORD *)&buf[28] = 2113;
      *(void *)&buf[30] = v48;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to create destination directory\", \"directory\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
    }
    uint64_t v27 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v28 = [(NSString *)v9 UTF8String];
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2113;
      *(void *)&buf[30] = v48;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to create destination directory", "{\"msg%{public}.0s\":\"failed to create destination directory\", \"directory\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
    }

    goto LABEL_40;
  }
  sub_100134750(v46, (char *)[[(NSString *)v9 stringByAppendingPathComponent:+[NSString stringWithUTF8String:__s]] UTF8String]);
  sub_100FBC6B0(a1, (uint64_t)v46);
  uint64_t v45 = 0;
  if (!a2) {
    operator new();
  }
  sub_1002918E0(__p, a1 + 248);
  if (!sub_1002918E8((uint64_t *)__p)) {
    operator new();
  }
  char v12 = sub_100291DD8(__p, v46);
  uint64_t v13 = 0;
  if (v12)
  {
    uint64_t v33 = [(NSString *)v9 cStringUsingEncoding:4];
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    long long v34 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v33;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"trying to issue sandbox extension\", \"path\":%{private, location:escape_only}s}", buf, 0x1Cu);
    }
    __int16 v35 = (char *)sandbox_extension_issue_file();
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v44 = 0;
    if (v35)
    {
      sub_100134750(buf, v35);
      if (SHIBYTE(v44) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v44 = *(void *)&buf[16];
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v36 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        __int16 v37 = __p;
        if (v44 < 0) {
          __int16 v37 = (void **)__p[0];
        }
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = v33;
        *(_WORD *)&buf[28] = 2081;
        *(void *)&buf[30] = v37;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"issued a sandbox extension\", \"path\":%{private, location:escape_only}s, \"data\":%{private, location:escape_only}s}", buf, 0x26u);
      }
      free(v35);
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v38 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = v33;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to issue sandbox extension for file\", \"filename\":%{private, location:escape_only}s}", buf, 0x1Cu);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
      }
      __int16 v39 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        *(_DWORD *)uint64_t buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = v33;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to issue sandbox extension for file", "{\"msg%{public}.0s\":\"failed to issue sandbox extension for file\", \"filename\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
    }
    sub_100134750(buf, v33);
    sub_100134750(&buf[24], __s);
    if (SHIBYTE(v44) < 0)
    {
      sub_1000DC48C(&v52, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v52 = *(_OWORD *)__p;
      uint64_t v53 = v44;
    }

    sub_100FC1250(a3, (long long *)buf);
    if (SHIBYTE(v53) < 0) {
      operator delete((void *)v52);
    }
    if (v51 < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    __int16 v40 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to copy MiLo database tables!\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
    }
    __int16 v41 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to copy MiLo database tables!", "{\"msg%{public}.0s\":\"failed to copy MiLo database tables!\"}", buf, 0x12u);
    }
    uint64_t v45 = 0;
    sub_100FBC6B0(a1, (uint64_t)v46);

    *a3 = 0;
    a3[72] = 0;
    uint64_t v13 = v45;
  }
  uint64_t v45 = 0;
  if (v13)
  {
    sub_1001F9CAC(v13);
    operator delete();
  }
  if (v47 < 0) {
    operator delete(v46[0]);
  }
}

void sub_100FB3A84(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
}

void sub_100FB3F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_100FB3FC4(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  sub_1000C7F88(buf);
  v19[0] = 0;
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterAnchorValueStatisticsEnabled", 0x8000100u, kCFAllocatorNull);
  int v5 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v4, v19);
  CFRelease(v4);
  BOOL v6 = v19[0];
  if (*(void *)v17) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v17);
  }
  if (v6) {
    int v7 = 0;
  }
  else {
    int v7 = v5;
  }
  if (v7 == 1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    std::string::size_type v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)unint64_t v17 = 2082;
      *(void *)&uint64_t v17[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics feature is not enabled in setting, won't fetch data from DB\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
    }
    int v9 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)unint64_t v17 = 2082;
      *(void *)&uint64_t v17[2] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ClusterAnchorValueStatistics feature is not enabled in setting, won't fetch data from DB", "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics feature is not enabled in setting, won't fetch data from DB\"}", buf, 0x12u);
    }
    *a2 = 0;
    a2[40] = 0;
  }
  else
  {
    sub_100134750(buf, "home");
    sub_100201F10(a1 + 248, (uint64_t)buf, v19);
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
    if (v21)
    {
      uint64_t v10 = v20;
      if (!v20) {
        uint64_t v10 = *(void *)(qword_102489B20 + 32);
      }
      uint64_t v11 = *(void *)(v10 + 8);
      if (!v11) {
        uint64_t v11 = *(void *)(qword_102489B18 + 8);
      }
      sub_10033460C(v15, v11);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      char v12 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "recovered anchor value map", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        long long v14 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<CLMicroLocationAnchorValueStatisticsMap> CLMicroLocationNotifier::getMicroLocationAnchorStatisticsMap()", "%s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
      }
      sub_1002CF6B4((uint64_t)a2, (uint64_t)v15);
      a2[40] = 1;
      sub_100289AB8((uint64_t)v15);
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      uint64_t v13 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v17 = 2082;
        *(void *)&uint64_t v17[2] = "";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"couldn't get most recent cluster anchor value statistics. either database is inaccessible or no model anchor cluster value statistics has been learnt yet\"}", buf, 0x12u);
      }
      *a2 = 0;
      a2[40] = 0;
    }
    sub_100288C48((uint64_t)v19);
  }
}

void sub_100FB441C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_100289AB8((uint64_t)&a12);
  sub_100288C48(v22 - 176);
  _Unwind_Resume(a1);
}

void sub_100FB44E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB44FC(const void **a1, uint64_t *a2, const void *a3)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  BOOL v6 = qword_102419458;
  if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = a1 + 442;
    if (!a1[442]) {
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  if (*((char *)a2 + 23) >= 0) {
    int v7 = a2;
  }
  else {
    int v7 = (uint64_t *)*a2;
  }
  uint64_t buf = 68289795;
  __int16 v20 = 2082;
  char v21 = "";
  __int16 v22 = 2082;
  uint64_t v23 = "Client request";
  __int16 v24 = 2082;
  unint64_t v25 = "learning";
  __int16 v26 = 2081;
  uint64_t v27 = v7;
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x30u);
  uint64_t v8 = qword_102419450;
  int v9 = a1 + 442;
  if (a1[442])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
LABEL_11:
    uint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289026;
      __int16 v20 = 2082;
      char v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning callback, already exists, release it first\"}", (uint8_t *)&buf, 0x12u);
    }
    _Block_release(*v9);
    uint64_t v8 = qword_102419450;
  }
  if (v8 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
LABEL_16:
  uint64_t v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    uint64_t buf = 68289026;
    __int16 v20 = 2082;
    char v21 = "";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning callback, block copy it\"}", (uint8_t *)&buf, 0x12u);
  }
  _Block_copy(a3);
  a1[442] = a3;
  uint64_t v12 = (*((uint64_t (**)(const void **))*a1 + 50))(a1);
  if (v12)
  {
    sub_10027EB30(&buf, (uint64_t)(a1 + 14), (uint64_t)(a1 + 31));
    sub_100293D1C(v16, (uint64_t)(a1 + 15), (uint64_t)(a1 + 31));
    sub_100288974(&buf);
    sub_100293D20(v16);
    char v18 = (void **)&v17;
    sub_10022F0E4(&v18);
    v16[0] = (void **)((char *)&v21 + 6);
    sub_10022F0E4(v16);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v13 = qword_102419458;
    BOOL v14 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO);
    if (v14)
    {
      uint64_t buf = 68289026;
      __int16 v20 = 2082;
      char v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"client request learning but Microlocation is not enabled\"}", (uint8_t *)&buf, 0x12u);
    }
    sub_100FB981C(v14, v9, @"Microlocation is not enabled at this moment");
  }
  return v12;
}

void sub_100FB4884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  a9 = (void **)&a17;
  sub_10022F0E4(&a9);
  _Unwind_Resume(a1);
}

void sub_100FB49F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100FB4A18(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    uint64_t buf = 68290307;
    __int16 v14 = 2082;
    uint64_t v15 = "";
    __int16 v16 = 2082;
    uint64_t v17 = "Client request";
    __int16 v18 = 2082;
    id v19 = "truth label donation request";
    __int16 v20 = 2081;
    uint64_t v21 = v9;
    __int16 v22 = 2082;
    id v23 = [[objc_msgSend(a3, "UUIDString") UTF8String];
    __int16 v24 = 2082;
    id v25 = [[objc_msgSend(a4, "UUIDString") UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s, \"truthLabelUUID\":%{public, location:escape_only}s, \"triggerUUID\":%{public, location:escape_only}s}", (uint8_t *)&buf, 0x44u);
  }
  sub_1002E5990(a3, (uint64_t)&buf);
  sub_1002E5990(a4, (uint64_t)v11);
  uint64_t result = 0;
  if (BYTE6(v15))
  {
    if (v12) {
      return sub_1002A2CE4(a1 + 3208, (uint64_t *)a2, &buf, v11);
    }
  }
  return result;
}

void sub_100FB4CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100FB4D20(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v10 = [*(id *)(a1 + 3480) stringFromDate:a4];
  id v11 = [*(id *)(a1 + 3480) stringFromDate:a5];
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  char v12 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v14[0] = 68290306;
    v14[1] = 0;
    __int16 v15 = 2082;
    __int16 v16 = "";
    __int16 v17 = 2082;
    __int16 v18 = "Client request";
    __int16 v19 = 2082;
    __int16 v20 = "MicroLocation donate truth label for recording events between dates";
    __int16 v21 = 2082;
    id v22 = [[[a3 UUIDString] UTF8String];
    __int16 v23 = 2082;
    id v24 = [v10 UTF8String];
    __int16 v25 = 2082;
    id v26 = [v11 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"truthLabelUUID\":%{public, location:escape_only}s, \"startDate\":%{public, location:escape_only}s, \"endDate\":%{public, location:escape_only}s}", (uint8_t *)v14, 0x44u);
  }
  sub_1002E5990(a3, (uint64_t)v14);
  if (BYTE6(v16)) {
    return sub_1002A2F90(a1 + 3208, a2, (uint64_t)v14, a4, a5);
  }
  else {
    return 0;
  }
}

void sub_100FB4F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB500C(uint64_t a1, void *a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    uint64_t buf = (unsigned __int8 *)68289539;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2081;
    id v11 = [[objc_msgSend(a2, "bundleId") UTF8String];
    __int16 v12 = 2081;
    id v13 = [[objc_msgSend(a2, "launchReason") UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"onForegroundAppLaunched\", \"id\":%{private, location:escape_only}s, \"reason\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
  }
  sub_100FBAAF4(&buf);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100FBABD0;
  v5[3] = &unk_1023081D0;
  v5[4] = a2;
  v5[5] = a1;
  sub_1002E8E18([a2 bundleId], &buf, (uint64_t)v5);
  p_uint64_t buf = &buf;
  sub_1000A7B4C((void ***)&p_buf);
}

void sub_100FB5198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_100FB51C8(uint64_t a1, void *a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Received onNowPlaying Duet Callback", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    LOWORD(v7) = 0;
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onNowPlaying(CLDuetNowPlaying *)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  sub_100FBAAF4(buf);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100FBAD00;
  v6[3] = &unk_1023081D0;
  v6[4] = a2;
  v6[5] = a1;
  sub_1002E8E18([a2 bundleId], (unsigned __int8 **)buf, (uint64_t)v6);
  int v7 = buf;
  sub_1000A7B4C((void ***)&v7);
}

void sub_100FB53D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_100FB5408()
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  v0 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    sub_100FB557C(&__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 68289283;
    int v4 = 0;
    __int16 v5 = 2082;
    BOOL v6 = "";
    __int16 v7 = 2081;
    __int16 v8 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Microlocation: createInUniverse\", \"Microlocation Version\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  operator new();
}

void sub_100FB5550()
{
}

void sub_100FB557C(std::string *a1@<X8>)
{
  sub_1000C7F88(&v6);
  memset(&v5, 0, sizeof(v5));
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsVersion", 0x8000100u, kCFAllocatorNull);
  BOOL v3 = sub_1000A7CF8(v6, (uint64_t)v2, &v5);
  CFRelease(v2);
  if (v3)
  {
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
      sub_1000DC48C(&__p, v5.__r_.__value_.__l.__data_, v5.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v5;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_1000DC48C(a1, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      *a1 = __p;
    }
  }
  else
  {
    sub_100134750(a1, "2.0.9");
  }
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  if (v7) {
    sub_1000DB0A0(v7);
  }
}

void sub_100FB5698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a22) {
    sub_1000DB0A0(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB56DC(uint64_t a1, void *a2)
{
  sub_100134750(__p, "");
  sub_100FB6334(a1, a2, (uint64_t)__p);
}

void sub_100FB5764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FB578C(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Rapport, unregister rapport session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    BOOL v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::stopRapportSession()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  [*(id *)(a1 + 224) invalidate];

  *(void *)(a1 + 224) = 0;
}

void sub_100FB5934(uint64_t a1)
{
}

id sub_100FB593C(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Rapport, register rapport session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    __int16 v8 = 0;
    std::string v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::startRapportSession()", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  *(void *)(a1 + 224) = objc_alloc_init((Class)RPCompanionLinkClient);
  [*(id *)(a1 + 224) setDispatchQueue:[*(id *)(a1 + 40) queue]];
  [*(id *)(a1 + 224) setControlFlags:4];
  [*(id *)(a1 + 224) setTargetUserSession:1];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_100FB5BB4;
  v7[3] = &unk_102307E10;
  v7[4] = a1;
  [*(id *)(a1 + 224) setDeviceFoundHandler:v7];
  BOOL v3 = *(void **)(a1 + 224);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100FB61CC;
  v6[3] = &unk_1022A5348;
  v6[4] = a1;
  return [v3 activateWithCompletion:v6];
}

void sub_100FB5BB4(uint64_t a1, void *a2)
{
}

void sub_100FB5BBC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100134750(&v21, "");
    sub_100134750(__p, "");
    sub_100134750(v17, "");
    if ([a2 name])
    {
      sub_100134750(buf, [objc_msgSend(objc_msgSend(a2, "name"), "UTF8String") UTF8String]);
      if (SHIBYTE(v22) < 0) {
        operator delete((void *)v21);
      }
      long long v21 = *(_OWORD *)buf;
      uint64_t v22 = *(void *)&buf[16];
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      std::string v5 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        *(void *)uint64_t buf = 68289282;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "device name unavailable";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"note\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
    }
    if ([a2 idsDeviceIdentifier])
    {
      sub_100134750(buf, (char *)[objc_msgSend(objc_msgSend(a2, "idsDeviceIdentifier"), "UTF8String")]);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v20 = *(void *)&buf[16];
      if ([a2 model])
      {
        sub_100134750(buf, [[[a2 model] UTF8String];
        if (SHIBYTE(v18) < 0) {
          operator delete(v17[0]);
        }
        *(_OWORD *)__int16 v17 = *(_OWORD *)buf;
        uint64_t v18 = *(void *)&buf[16];
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        uint64_t v6 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          __int16 v7 = &v21;
          if (v22 < 0) {
            __int16 v7 = (long long *)v21;
          }
          __int16 v8 = __p;
          if (v20 < 0) {
            __int16 v8 = (void **)__p[0];
          }
          uint64_t v9 = v17;
          if (v18 < 0) {
            uint64_t v9 = (void **)v17[0];
          }
          *(void *)uint64_t buf = 68289795;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2081;
          *(void *)&buf[20] = v7;
          __int16 v24 = 2081;
          __int16 v25 = v8;
          __int16 v26 = 2081;
          uint64_t v27 = v9;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"name\":%{private, location:escape_only}s, \"idsDeviceIdentifier\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s}", buf, 0x30u);
        }
        if (SHIBYTE(v20) < 0)
        {
          sub_1000DC48C(__dst, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)__dst = *(_OWORD *)__p;
          uint64_t v16 = v20;
        }
        if (SHIBYTE(v18) < 0)
        {
          sub_1000DC48C(v13, v17[0], (unint64_t)v17[1]);
        }
        else
        {
          *(_OWORD *)id v13 = *(_OWORD *)v17;
          uint64_t v14 = v18;
        }
        if (SHIBYTE(v22) < 0)
        {
          sub_1000DC48C(v11, (void *)v21, *((unint64_t *)&v21 + 1));
        }
        else
        {
          *(_OWORD *)id v11 = v21;
          uint64_t v12 = v22;
        }
        sub_100310D4C(a1 + 584, (uint64_t)__dst, (uint64_t)v13, (long long *)v11);
        if (SHIBYTE(v12) < 0) {
          operator delete(v11[0]);
        }
        if (SHIBYTE(v14) < 0) {
          operator delete(v13[0]);
        }
        if (SHIBYTE(v16) < 0) {
          operator delete(__dst[0]);
        }
        goto LABEL_54;
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v10 = qword_102419458;
      if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_54;
      }
      *(void *)uint64_t buf = 68289282;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "Model type unavailable  - device not buffered to monitor";
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v10 = qword_102419458;
      if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_54;
      }
      *(void *)uint64_t buf = 68289282;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "IDS Identifier unavailable - device not buffered to monitor";
    }
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"error\":%{public, location:escape_only}s}", buf, 0x1Cu);
LABEL_54:
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete((void *)v21);
    }
    return;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  int v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(void *)uint64_t buf = 68289026;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound - rapport session device found is nil\"}", buf, 0x12u);
  }
}

void sub_100FB6124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (*(char *)(v42 - 121) < 0) {
    operator delete(*(void **)(v42 - 144));
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB61CC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    sub_10031A59C((uint64_t)+[NSString stringWithFormat:@"%@ %@", @"Rapport, rapport session activation error:", a2]);
    BOOL v3 = *(void (**)(uint64_t))(*(void *)v2 + 248);
    v3(v2);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      __int16 v8 = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Rapport, rapport session ready to listen for incoming devices\"}", buf, 0x12u);
    }
  }
}

id sub_100FB632C(uint64_t a1)
{
  return sub_100FB593C(a1 - 136);
}

void sub_100FB6334(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = sub_100FB6DE4(a1, "CLMicroLocationNotifier", a2);
  uint64_t v7 = v6 + 136;
  *(void *)uint64_t v6 = off_102307E40;
  *(void *)(v6 + 112) = off_102308010;
  *(void *)(v6 + 12sub_100FB8FC8(&a9, 0) = off_102308068;
  *(void *)(v6 + 128) = off_102308098;
  *(void *)(v6 + 136) = off_1023080C0;
  *(void *)(v6 + 144) = off_102308168;
  *(void *)(v6 + 16sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)(v6 + 176) = 0u;
  *(_OWORD *)(v6 + 192) = 0u;
  *(_OWORD *)(v6 + 208) = 0u;
  *(void *)(v6 + 232) = 0;
  *(void *)(v6 + 24sub_100FB8FC8(&a9, 0) = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1000DC48C(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  sub_1001F9ADC(a1 + 248, (long long *)__p, 2);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_100219EB0((void *)(a1 + 552), a1 + 248);
  [objc_msgSend(a2, "silo") queue];
  sub_100309AC8(a1 + 584, v7, a1 + 3208, a1 + 248);
}

void sub_100FB6BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1000F5BB0(v32 + 3576, *v36);
  __int16 v38 = (void **)(v32 + 3488);
  __int16 v39 = *(void **)(v32 + 3512);
  if (v39)
  {
    *(void *)(v32 + 352sub_100FB8FC8(&a9, 0) = v39;
    operator delete(v39);
  }
  __int16 v40 = *v38;
  if (*v38)
  {
    *(void *)(v32 + 3496) = v40;
    operator delete(v40);
  }
  sub_100FB8FC8((uint64_t *)(v32 + 3416), 0);
  *(void *)(v32 + 3208) = off_1022A3498;
  if (*(unsigned char *)(v32 + 3288)) {
    sub_100255458(v32 + 3216);
  }
  sub_100309E60(v35);
  sub_10021A410(v34);
  sub_1001F9CAC(v33);
  uint64_t v41 = *(void *)(v32 + 216);
  *(void *)(v32 + 216) = 0;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
  }
  uint64_t v42 = *(void *)(v32 + 208);
  *(void *)(v32 + 208) = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  uint64_t v43 = *(void *)(v32 + 200);
  *(void *)(v32 + 20sub_100FB8FC8(&a9, 0) = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  uint64_t v44 = *(void *)(v32 + 192);
  *(void *)(v32 + 192) = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  uint64_t v45 = *(void *)(v32 + 184);
  *(void *)(v32 + 184) = 0;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
  }
  sub_100FB77BC(v32);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB6DE4(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_102308708;
  sub_100134750((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = [a3 silo];
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 108) = 0;
  return a1;
}

void sub_100FB6E74(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB6E90(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7954((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FB6F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FB6F1C(void *a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "MicroLocations startClients", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::startClients()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  id v3 = [[CLMicroLocationLoiBridge alloc] initInUniverse:a1[4]];
  a1[399] = v3;
  sub_10030A038((uint64_t)(a1 + 73), v3);
  *(void *)uint64_t buf = off_1023087E8;
  uint64_t v6 = a1;
  uint64_t v7 = buf;
  sub_10030A010((uint64_t)(a1 + 73), (uint64_t)buf);
  sub_100FC1740(buf);
  *(void *)uint64_t buf = off_102308878;
  uint64_t v6 = a1;
  uint64_t v7 = buf;
  sub_10030A018((uint64_t)(a1 + 73), (uint64_t)buf);
  sub_100FC191C(buf);
  *(void *)uint64_t buf = off_102308908;
  uint64_t v6 = a1;
  uint64_t v7 = buf;
  sub_10030A020((uint64_t)(a1 + 73), (uint64_t)buf);
  sub_100FC1AF8(buf);
  *(void *)uint64_t buf = off_102308998;
  uint64_t v6 = a1;
  uint64_t v7 = buf;
  sub_10030A028((uint64_t)(a1 + 73), (uint64_t)buf);
  sub_100FC1CD4(buf);
  *(void *)uint64_t buf = off_102308A28;
  uint64_t v6 = a1;
  uint64_t v7 = buf;
  sub_10030A030((uint64_t)(a1 + 73), (uint64_t)buf);
  sub_100FC1EB0(buf);
  sub_10022D380(a1 + 400);
  a1[30] = [[CLMicroLocationIntersiloDelegate alloc] initWithMicroLocationNotifier:a1];
  sub_101389C2C();
}

void sub_100FB7704(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

uint64_t sub_100FB77BC(uint64_t a1)
{
  *(void *)a1 = off_102308708;
  [*(id *)(a1 + 48) invalidate];

  sub_1004459BC(a1 + 80, *(void **)(a1 + 88));
  sub_1007E53C4(a1 + 56, *(void **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100FB7840(uint64_t a1)
{
  *(void *)a1 = off_102307E40;
  *(void *)(a1 + 112) = off_102308010;
  *(void *)(a1 + 12sub_100FB8FC8(&a9, 0) = off_102308068;
  *(void *)(a1 + 128) = off_102308098;
  *(void *)(a1 + 136) = off_1023080C0;
  *(void *)(a1 + 144) = off_102308168;
  uint64_t v2 = *(void **)(a1 + 152);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 152) = 0;
  }
  id v3 = *(void **)(a1 + 168);
  if (v3)
  {
    [v3 invalidate];

    *(void *)(a1 + 168) = 0;
  }
  int v4 = *(void **)(a1 + 3568);
  if (v4)
  {
    [v4 invalidate];

    *(void *)(a1 + 3568) = 0;
  }
  std::string v5 = *(void **)(a1 + 3560);
  if (v5)
  {
    [v5 invalidate];

    *(void *)(a1 + 356sub_100FB8FC8(&a9, 0) = 0;
  }

  *(void *)(a1 + 348sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 3544) = 0;

  *(void *)(a1 + 3552) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  sub_1000F5BB0(a1 + 3576, *(void **)(a1 + 3584));
  uint64_t v6 = *(void **)(a1 + 3512);
  if (v6)
  {
    *(void *)(a1 + 352sub_100FB8FC8(&a9, 0) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(a1 + 3488);
  if (v7)
  {
    *(void *)(a1 + 3496) = v7;
    operator delete(v7);
  }
  sub_100FB8FC8((uint64_t *)(a1 + 3416), 0);
  *(void *)(a1 + 3208) = off_1022A3498;
  if (*(unsigned char *)(a1 + 3288)) {
    sub_100255458(a1 + 3216);
  }
  sub_100309E60(a1 + 584);
  sub_10021A410((uint64_t *)(a1 + 552));
  sub_1001F9CAC(a1 + 248);
  uint64_t v8 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 200);
  *(void *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }

  return sub_100FB77BC(a1);
}

uint64_t sub_100FB7B54(uint64_t a1)
{
  return sub_100FB7840(a1 - 112);
}

uint64_t sub_100FB7B5C(uint64_t a1)
{
  return sub_100FB7840(a1 - 120);
}

uint64_t sub_100FB7B64(uint64_t a1)
{
  return sub_100FB7840(a1 - 128);
}

uint64_t sub_100FB7B6C(uint64_t a1)
{
  return sub_100FB7840(a1 - 136);
}

uint64_t sub_100FB7B74(uint64_t a1)
{
  return sub_100FB7840(a1 - 144);
}

void sub_100FB7B7C(uint64_t a1)
{
  sub_100FB7840(a1);

  operator delete();
}

void sub_100FB7BB4(uint64_t a1)
{
  sub_100FB7840(a1 - 112);

  operator delete();
}

void sub_100FB7BF0(uint64_t a1)
{
  sub_100FB7840(a1 - 120);

  operator delete();
}

void sub_100FB7C2C(uint64_t a1)
{
  sub_100FB7840(a1 - 128);

  operator delete();
}

void sub_100FB7C68(uint64_t a1)
{
  sub_100FB7840(a1 - 136);

  operator delete();
}

void sub_100FB7CA4(uint64_t a1)
{
  sub_100FB7840(a1 - 144);

  operator delete();
}

void sub_100FB7CE0(id *a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "MicroLocation: shutdown", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    id v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::shutdown()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  sub_100FB7E7C(a1);
}

void sub_100FB7E7C(id *a1)
{
  sub_100FB8FC8((uint64_t *)a1 + 427, 0);
  uint64_t v2 = (id *)a1[26];
  if (v2)
  {
    [v2[2] unregister:v2[1] forNotification:0];
    [*((id *)a1[26] + 2) unregister:*((void *)a1[26] + 1) forNotification:9];
    id v3 = a1[26];
    a1[26] = 0;
    if (v3) {
      (*(void (**)(id))(*(void *)v3 + 8))(v3);
    }
  }
  int v4 = (id *)a1[24];
  if (v4)
  {
    [v4[2] unregister:v4[1] forNotification:0];
    [*((id *)a1[24] + 2) unregister:*((void *)a1[24] + 1) forNotification:4];
    [*((id *)a1[24] + 2) unregister:*((void *)a1[24] + 1) forNotification:2];
    id v5 = a1[24];
    a1[24] = 0;
    if (v5) {
      (*(void (**)(id))(*(void *)v5 + 8))(v5);
    }
  }
  uint64_t v6 = (id *)a1[23];
  if (v6)
  {
    [v6[2] unregister:v6[1] forNotification:15];
    [*((id *)a1[23] + 2) unregister:*((void *)a1[23] + 1) forNotification:14];
    id v7 = a1[23];
    a1[23] = 0;
    if (v7) {
      (*(void (**)(id))(*(void *)v7 + 8))(v7);
    }
  }
  (*((void (**)(id *))*a1 + 27))(a1);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  [a1[29] stopMonitoringForClient:a1[30]];

  a1[29] = 0;
  sub_10022D3BC(a1 + 400);

  a1[28] = 0;
  a1[30] = 0;
  [a1[434] invalidate];

  a1[434] = 0;
}

void sub_100FB8030(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    id v7 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMicroLocationNotifier::onDarwinNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v8 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDarwinNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v10 = 0;
  }
  sub_100FB9A18(a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FB81E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB8204(uint64_t a1, int *a2, _DWORD *a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMicroLocationNotifier::onDataProtectionManagerNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDataProtectionManagerNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_100FBB9C4(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FB83C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB83E0(uint64_t a1, int *a2, unsigned __int8 *a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMicroLocationNotifier::onDaemonStatusNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDaemonStatusNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_100FB9CA4(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FB859C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB85BC(uint64_t a1)
{
  return nullsub_41(*(void *)(a1 + 32) + 584, 7);
}

void sub_100FB85CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a2 + 32), "silo") assertOutside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    char v10 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMicroLocationNotifier::onNotificationCenterNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    char v11 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2082;
      long long v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNotificationCenterNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v15 = 0;
  }
  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100FC0DE4;
  v13[3] = &unk_1022ACFE0;
  v13[4] = a2;
  v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FB87E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB8808(uint64_t a1)
{
  sub_1000C7F88(buf);
  v11[0] = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnabled", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v2, v11);
  CFRelease(v2);
  BOOL v4 = v11[0];
  if (v13) {
    sub_1000DB0A0(v13);
  }
  if (v4) {
    int v5 = v3;
  }
  else {
    int v5 = 0;
  }
  if (v5 == 1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Registering for leeched location updates", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      *(_WORD *)char v11 = 0;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    uint64_t v7 = *(void *)(a1 + 216);
    if (!v7) {
      sub_100681630();
    }
    [*(id *)(v7 + 16) register:*(void *)(v7 + 8) forNotification:5 registrationInfo:0];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Disabled - not registering for leeched location updates", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      *(_WORD *)char v11 = 0;
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
}

void sub_100FB8BE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB8C04(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 32), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMicroLocationNotifier::onLocationNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onLocationNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_100FBA690(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FB8DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB8DE0(uint64_t a1)
{
}

void sub_100FB8DE8(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Deregistering from leeched location updates", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::deregisterForLeechedLocationUpdates()", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  uint64_t v3 = *(void *)(a1 + 216);
  if (v3)
  {
    [*(id *)(v3 + 16) unregister:*(void *)(v3 + 8) forNotification:5];
    uint64_t v4 = *(void *)(a1 + 216);
    *(void *)(a1 + 216) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
}

void sub_100FB8FC0(uint64_t a1)
{
}

uint64_t sub_100FB8FC8(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1011627F8(result);
    operator delete();
  }
  return result;
}

void sub_100FB9018(uint64_t *a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLMicroLocationNotifier: startSpectating", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    v9[0] = 0;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::startSpectating()", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  int v10 = 0;
  sub_1001EE1F4(&v10);
  *(void *)&long long v11 = sub_1001EC8C4((ssize_t)&v10);
  *((void *)&v11 + 1) = v3;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_10023DBE8((uint64_t)v9);
  sub_100FB93EC(&v11, (uint64_t)v9, (uint64_t)buf, Current_5);
  sub_100219EBC(a1 + 69, (long long *)buf);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v13);
  sub_100256E68((wireless_diagnostics::google::protobuf::MessageLite *)v9);
  sub_1001EF3E8((unsigned int *)&v10);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  int v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "CLMicroLocationNotifier: register Biome", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    v9[0] = 0;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::startSpectating()", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  sub_100307498(a1 + 428);
  [*(id *)(a1[23] + 16) register:*(void *)(a1[23] + 8) forNotification:7 registrationInfo:0];
  [*(id *)(a1[23] + 16) register:*(void *)(a1[23] + 8) forNotification:10 registrationInfo:0];
  sub_100103240();
  if (sub_10073E30C())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, a1, (CFNotificationCallback)sub_100FB85CC, @"com.apple.locationd.MicroLocationAction-record", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
}

void sub_100FB93AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, unsigned int a15)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v15 + 32));
  sub_100256E68((wireless_diagnostics::google::protobuf::MessageLite *)&a11);
  sub_1001EF3E8(&a15);
  _Unwind_Resume(a1);
}

void sub_100FB93EC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7314((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FB9464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FB9478(uint64_t a1)
{
}

id sub_100FB9480(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  CFStringRef v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLMicroLocationNotifier: stopSpectating", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    v8[0] = 0;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationNotifier::stopSpectating()", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  int v9 = 0;
  sub_1001EE1F4(&v9);
  *(void *)&long long v10 = sub_1001EC8C4((ssize_t)&v9);
  *((void *)&v10 + 1) = v3;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_10023DC18((uint64_t)v8);
  sub_100FB9768(&v10, (uint64_t)v8, (uint64_t)buf, Current_5);
  sub_100219EBC((uint64_t *)(a1 + 552), (long long *)buf);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v12);
  sub_100257308((wireless_diagnostics::google::protobuf::MessageLite *)v8);
  sub_1001EF3E8((unsigned int *)&v9);
  sub_10021A0B0((uint64_t *)(a1 + 552));
  [*(id *)(a1 + 232) stopMonitoringNowPlayingForClient:*(void *)(a1 + 240)];
  sub_100103240();
  if (sub_100740E34())
  {
    [*(id *)(a1 + 232) stopMonitoringHomeKitAccessoryForClient:*(void *)(a1 + 240)];
    [*(id *)(a1 + 232) stopMonitoringHomeKitSceneForClient:*(void *)(a1 + 240)];
  }
  sub_100307D6C((id *)(a1 + 3424));
  [*(id *)(*(void *)(a1 + 184) + 16) unregister:*(void *)(*(void *)(a1 + 184) + 8) forNotification:7];
  [*(id *)(*(void *)(a1 + 184) + 16) unregister:*(void *)(*(void *)(a1 + 184) + 8) forNotification:10];
  sub_100103240();
  if (sub_10073E30C())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(DarwinNotifyCenter, (const void *)a1, @"com.apple.locationd.MicroLocationAction-record", 0);
  }
  sub_1002A3260(a1 + 3208);
  id result = [*(id *)(a1 + 168) invalidate];
  *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
  return result;
}

void sub_100FB9728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, unsigned int a15)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v15 + 32));
  sub_100257308((wireless_diagnostics::google::protobuf::MessageLite *)&a11);
  sub_1001EF3E8(&a15);
  _Unwind_Resume(a1);
}

void sub_100FB9768(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E73B4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FB97E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100FB97F4(uint64_t a1)
{
  return sub_100FB9480(a1 - 136);
}

uint64_t sub_100FB97FC()
{
  return 1;
}

uint64_t sub_100FB9804()
{
  return 1;
}

void *sub_100FB980C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "NotificationMicroLocation");
}

void sub_100FB981C(uint64_t a1, const void **a2, uint64_t a3)
{
  if (*a2)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"learning callback, calling SPI response block for learning request\"}", buf, 0x12u);
    }
    if (a3)
    {
      id v6 = objc_alloc((Class)NSError);
      NSErrorUserInfoKey v8 = NSLocalizedDescriptionKey;
      uint64_t v9 = a3;
      [v6 initWithDomain:kCLErrorDomainPrivate code:5 userInfo:[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v9, &v8, 1)];
    }
    (*((void (**)(void))*a2 + 2))();
    _Block_release(*a2);
    *a2 = 0;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"No SPI responses cached for learning completion\"}", buf, 0x12u);
    }
  }
}

void sub_100FB9A18(uint64_t a1, uint64_t a2, int *a3)
{
  int v4 = *a3;
  if (*a3 == 12)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    id v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "LocationOfInterestDidClear";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", (uint8_t *)&v8, 0x26u);
    }
    sub_100311188(a1 + 584);
    sub_100FBCBB8(a1);
  }
  else if (v4 == 9)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "Sysdiagnose Notification";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", (uint8_t *)&v8, 0x26u);
    }
    sub_10030A1EC(a1 + 584);
  }
  else if (!v4)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "Daemon settings";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", (uint8_t *)&v8, 0x26u);
    }
    sub_10030A040(a1 + 584);
  }
}

void sub_100FB9CA4(uint64_t a1, uint64_t a2, int *a3, unsigned __int8 *a4)
{
  switch(*a3)
  {
    case 7:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      uint64_t v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v21 = 2082;
        __int16 v22 = "Battery";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
      }
      *(_OWORD *)uint64_t buf = *(_OWORD *)a4;
      *(void *)&buf[16] = *((void *)a4 + 2);
      CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
      sub_1002A20E8(a1 + 3208, (uint64_t *)buf, &Current_5);
      break;
    case 10:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v12 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *a4;
        *(_DWORD *)uint64_t buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v21 = 2082;
        __int16 v22 = "Display";
        __int16 v23 = 1025;
        int v24 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"is on\":%{private}hhd}", buf, 0x2Cu);
      }
      int v14 = *a4;
      *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
      sub_100311458(a1 + 584, v14, buf);
      int v15 = *a4;
      *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
      sub_1002A22B4(a1 + 3208, v15, (double *)buf);
      break;
    case 14:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v16 = qword_102419458;
      if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v17 = *a4;
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "Daemon status";
      __int16 v21 = 2082;
      __int16 v22 = "Restricted power mode";
      __int16 v23 = 1025;
      int v24 = v17;
      __int16 v18 = "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{p"
            "ublic, location:escape_only}s, \"is restricted\":%{private}hhd}";
      goto LABEL_29;
    case 15:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      __int16 v16 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = *a4;
        *(_DWORD *)uint64_t buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v21 = 2082;
        __int16 v22 = "Battery saver mode";
        __int16 v23 = 1025;
        int v24 = v19;
        __int16 v18 = "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%"
              "{public, location:escape_only}s, \"is enabled\":%{private}hhd}";
LABEL_29:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v18, buf, 0x2Cu);
      }
LABEL_30:
      sub_1002A3268(a1 + 3208, *a4);
      sub_100311744(a1 + 584, *a4);
      break;
    default:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *a3;
        *(_DWORD *)uint64_t buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#Warning Received unhandled daemon status notification %d", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        int v10 = *a3;
        LODWORD(Current_5) = 67109120;
        HIDWORD(Current_5) = v10;
        int v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v11);
        if (v11 != buf) {
          free(v11);
        }
      }
      break;
  }
}

void sub_100FBA200(uint64_t a1, int a2, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-localize", 0))
  {
    if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-record", 0))
    {
      if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-purge", 0))
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        int v5 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 136315138;
          *(void *)&uint8_t buf[4] = CFStringGetCStringPtr(theString1, 0x8000100u);
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Got a notification center notification that we weren't expecting: %s", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_102308378);
          }
          LODWORD(v10[0]) = 136315138;
          *(void *)((char *)v10 + 4) = CFStringGetCStringPtr(theString1, 0x8000100u);
          id v6 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onNotificationCenterNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)", "%s\n", v6);
          if (v6 != buf) {
            free(v6);
          }
        }
      }
      else
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        int v9 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          __int16 v12 = 2082;
          int v13 = "Notification center";
          __int16 v14 = 2082;
          int v15 = "Purge";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
        }
        sub_100311188(a1 + 584);
        sub_100FBCBB8(a1);
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v12 = 2082;
        int v13 = "Notification center";
        __int16 v14 = 2082;
        int v15 = "Force record";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
      }
      *(void *)uint64_t buf = j__CFAbsoluteTimeGetCurrent_5();
      sub_1002A2760(a1 + 3208, (double *)buf);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v12 = 2082;
      int v13 = "Notification center";
      __int16 v14 = 2082;
      int v15 = "Force localization";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
    }
    sub_100134750(buf, "NotificationCenter");
    v10[0] = j__CFAbsoluteTimeGetCurrent_5();
    sub_1002A2B08(a1 + 3208, (const std::string *)buf, v10);
    if (SBYTE3(v13) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_100FBA66C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBA690(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 5)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    id v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v20 = 2082;
      __int16 v21 = "Location";
      __int16 v22 = 2082;
      __int16 v23 = "Location leech";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
    }
    uint64_t v7 = a1 + 584;
    if (sub_100312108(v7))
    {
      double v8 = *(double *)(a4 + 20);
      sub_1000C7F88(buf);
      v18[0] = 0.0;
      CFStringRef v9 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLeechedLocationHorizontalAccuracyThreshold", 0x8000100u, kCFAllocatorNull);
      int v10 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v9, v18);
      CFRelease(v9);
      double v11 = v18[0];
      if (*(void *)&buf[8]) {
        sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
      }
      double v12 = 65.0;
      if (v10) {
        double v12 = v11;
      }
      if (v8 <= v12)
      {
        sub_100312064(v7, [objc_alloc((Class)CLLocation) initWithLatitude:*(double *)(a4 + 4) longitude:*(double *)(a4 + 12)]);
        return;
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      int v13 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a4 + 20);
        *(_DWORD *)uint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Ignoring leeched location since horizontal accuracy (%.1f m) exceeds threshold", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        uint64_t v15 = *(void *)(a4 + 20);
        LODWORD(v18[0]) = 134217984;
        *(void *)((char *)v18 + 4) = v15;
        __int16 v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v16);
LABEL_28:
        if (v16 != buf) {
          free(v16);
        }
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v17 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Received unhandled location notification", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      LOWORD(v18[0]) = 0;
      __int16 v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)", "%s\n", v16);
      goto LABEL_28;
    }
  }
}

void sub_100FBAAD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBAAF4(void *a1@<X8>)
{
  sub_1000C7F88(&v5);
  CFArrayRef v4 = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAppLaunchLocalizationAllowedList", 0x8000100u, kCFAllocatorNull);
  BOOL v3 = sub_1004D1D1C(v5, v2, (CFTypeRef *)&v4);
  CFRelease(v2);
  if (v3)
  {
    sub_100FC0DF4(v4, (uint64_t)a1);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  if (v6) {
    sub_1000DB0A0(v6);
  }
}

void sub_100FBABB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBABD0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(v4 + 32) silo];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  v6[2] = sub_100FBAC98;
  v6[3] = &unk_102308198;
  v6[4] = *(void *)(a1 + 32);
  void v6[5] = v4;
  sub_10024D304(v7, a2);
  [v5 async:v6];
  sub_10024D308((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_100FBAC84(_Unwind_Exception *a1)
{
  sub_10024D308(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBAC98(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40) + 3208;
  BOOL v3 = (unsigned char *)(a1 + 48);
  CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  return sub_1002A1F1C(v2, v1, v3, &Current_5);
}

uint64_t sub_100FBACEC(uint64_t a1, uint64_t a2)
{
  return sub_10024D304(a1 + 48, a2 + 48);
}

void sub_100FBACF8(uint64_t a1)
{
}

void sub_100FBAD00(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(v4 + 32) silo];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  v6[2] = sub_100FBADC8;
  v6[3] = &unk_102308198;
  v6[4] = *(void *)(a1 + 32);
  void v6[5] = v4;
  sub_10024D304(v7, a2);
  [v5 async:v6];
  sub_10024D308((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_100FBADB4(_Unwind_Exception *a1)
{
  sub_10024D308(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBADC8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40) + 3208;
  BOOL v3 = (unsigned char *)(a1 + 48);
  CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  return sub_1002A1A64(v2, v1, v3, &Current_5);
}

uint64_t sub_100FBAE1C()
{
  uint64_t v0 = sub_100103240();

  return sub_100740C6C(v0);
}

id sub_100FBAE44(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100FBAEB8;
  v3[3] = &unk_1022A3020;
  v3[4] = a1;
  return [v1 async:v3];
}

uint64_t sub_100FBAEB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v6 = 0;
  sub_1001EE1F4(&v6);
  *(void *)&long long v7 = sub_1001EC8C4((ssize_t)&v6);
  *((void *)&v7 + 1) = v2;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_10023DB58((uint64_t)v5);
  sub_100FBAFBC(&v7, (uint64_t)v5, (uint64_t)v8, Current_5);
  sub_100219EBC((uint64_t *)(v1 + 552), v8);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
  sub_100256088((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  return sub_1001EF3E8((unsigned int *)&v6);
}

void sub_100FBAF78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

void sub_100FBAFBC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7134((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBB034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100FBB048(uint64_t a1)
{
  uint64_t v1 = a1 - 112;
  uint64_t v2 = *(void **)(a1 - 72);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100FBAEB8;
  v4[3] = &unk_1022A3020;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t *sub_100FBB0BC(uint64_t *result, int a2, uint64_t a3)
{
  int v9 = a2;
  if (*(unsigned char *)(a3 + 280))
  {
    BOOL v3 = (uint64_t **)(result + 447);
    uint64_t v4 = result[448];
    if (!v4) {
      goto LABEL_12;
    }
    id v5 = result + 448;
    do
    {
      int v6 = *(_DWORD *)(v4 + 28);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        double v8 = (uint64_t *)v4;
      }
      else {
        double v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        id v5 = (uint64_t *)v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    if (v5 == result + 448 || *((_DWORD *)v5 + 7) > a2)
    {
LABEL_12:
      int v10 = (unsigned int *)&v9;
      *((_DWORD *)sub_100125FD0((uint64_t **)result + 447, &v9, (uint64_t)&unk_101D0B290, &v10) + 8) = 0;
    }
    int v10 = (unsigned int *)&v9;
    id result = sub_100125FD0(v3, &v9, (uint64_t)&unk_101D0B290, &v10);
    ++*((_DWORD *)result + 8);
  }
  return result;
}

uint64_t *sub_100FBB188(uint64_t a1, int a2, uint64_t a3)
{
  return sub_100FBB0BC((uint64_t *)(a1 - 112), a2, a3);
}

void *sub_100FBB190(void *result, int a2)
{
  int v11 = a2;
  uint64_t v2 = result[448];
  if (v2)
  {
    BOOL v3 = result;
    result += 447;
    uint64_t v4 = v3 + 448;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < a2;
      if (v5 >= a2) {
        BOOL v7 = (uint64_t *)v2;
      }
      else {
        BOOL v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = (void *)v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
    if (v4 != v3 + 448 && *((_DWORD *)v4 + 7) <= a2)
    {
      if (*((_DWORD *)v4 + 8))
      {
        double v12 = (unsigned int *)&v11;
        *((_DWORD *)sub_100125FD0((uint64_t **)result, &v11, (uint64_t)&unk_101D0B290, &v12) + 8) = 0;
        double v8 = (void *)v3[5];
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472;
        v9[2] = sub_100FBB288;
        v9[3] = &unk_1022B2410;
        v9[4] = v3;
        int v10 = v11;
        return [v8 async:v9];
      }
    }
  }
  return result;
}

void sub_100FBB288()
{
}

void *sub_100FBB29C(uint64_t a1, int a2)
{
  return sub_100FBB190((void *)(a1 - 112), a2);
}

id sub_100FBB2A4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100FBB318;
  v3[3] = &unk_1022A3020;
  v3[4] = a1;
  return [v1 async:v3];
}

void sub_100FBB318(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v6 = 0;
  sub_1001EE1F4(&v6);
  *(void *)&long long v7 = sub_1001EC8C4((ssize_t)&v6);
  *((void *)&v7 + 1) = v2;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_10023DB88((uint64_t)v5);
  sub_100FBB434(&v7, (uint64_t)v5, (uint64_t)v8, Current_5);
  sub_100219EBC((uint64_t *)(v1 + 552), v8);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
  sub_100256528((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  uint64_t v4 = sub_1001EF3E8((unsigned int *)&v6);
  sub_100FB981C(v4, (const void **)(v1 + 3536), 0);
  sub_1003118D4(v1 + 584);
}

void sub_100FBB3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v14 + 32));
  sub_100256528((wireless_diagnostics::google::protobuf::MessageLite *)&a10);
  sub_1001EF3E8(&a14);
  _Unwind_Resume(a1);
}

void sub_100FBB434(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E71D4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBB4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100FBB4C0(uint64_t a1)
{
  uint64_t v1 = a1 - 112;
  uint64_t v2 = *(void **)(a1 - 72);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100FBB318;
  v4[3] = &unk_1022A3020;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t sub_100FBB534@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  return sub_100312944(a1 + 584, a2, a3, a4, a5);
}

uint64_t sub_100FBB53C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  return sub_100312944(a1 + 472, a2, a3, a4, a5);
}

void sub_100FBB544(uint64_t a1, void *a2, id a3)
{
  if (*a2 == a2[1])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v15 = 0;
      __int16 v16 = 2082;
      int v17 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"No SPI responses cached for recording/localization completion\"}", buf, 0x12u);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v15 = 0;
      __int16 v16 = 2082;
      int v17 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"calling SPI responses after recording/localization completion\"}", buf, 0x12u);
    }
    if (a3)
    {
      id v6 = objc_alloc((Class)NSError);
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v13 = a3;
      long long v7 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      a3 = [v6 initWithDomain:kCLErrorDomainPrivate code:5 userInfo:v7];
    }
    double v8 = (void *)*a2;
    uint64_t v9 = (void *)a2[1];
    if ((void *)*a2 != v9)
    {
      do
      {
        int v10 = (void *)*v8;
        (*(void (**)(void, id))(*v8 + 16))(*v8, a3);

        ++v8;
      }
      while (v8 != v9);
      double v8 = (void *)*a2;
    }
    a2[1] = v8;
    sub_100FBB76C((uint64_t)a2);
  }
}

void sub_100FBB76C(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(char **)a1;
  int v5 = *(unsigned char **)(a1 + 8);
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 >= (v3 - (uint64_t)v4) >> 3) {
    return;
  }
  if (v5 == v4)
  {
    int v11 = 0;
    uint64_t v9 = 8 * v6;
    goto LABEL_8;
  }
  long long v7 = (char *)sub_1000DA54C(v2, v6);
  uint64_t v4 = *(char **)a1;
  double v8 = *(char **)(a1 + 8);
  uint64_t v9 = (uint64_t)&v7[8 * v6];
  int v11 = &v7[8 * v10];
  if (v8 == *(char **)a1)
  {
LABEL_8:
    uint64_t v12 = v9;
    goto LABEL_9;
  }
  uint64_t v12 = v9;
  do
  {
    uint64_t v13 = *((void *)v8 - 1);
    v8 -= 8;
    *(void *)(v12 - 8) = v13;
    v12 -= 8;
  }
  while (v8 != v4);
  uint64_t v4 = *(char **)a1;
LABEL_9:
  *(void *)a1 = v12;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v11;
  if (v4)
  {
    operator delete(v4);
  }
}

void sub_100FBB838(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_10021A0B0((uint64_t *)(a1 + 552));

  sub_100FBB544(v4, (void *)(a1 + 3488), a2);
}

void sub_100FBB87C(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_10021A0B0((uint64_t *)(a1 + 416));

  sub_100FBB544(v4, (void *)(a1 + 3352), a2);
}

id sub_100FBB8C0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100FBB934;
  v3[3] = &unk_1022A3020;
  v3[4] = a1;
  return [v1 async:v3];
}

uint64_t sub_100FBB934(uint64_t a1)
{
  return sub_100311A80(*(void *)(a1 + 32) + 584);
}

id sub_100FBB940(uint64_t a1)
{
  uint64_t v1 = a1 - 120;
  uint64_t v2 = *(void **)(a1 - 80);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100FBB934;
  v4[3] = &unk_1022A3020;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t sub_100FBB9B4(uint64_t a1)
{
  return sub_10021A0B0((uint64_t *)(a1 + 552));
}

uint64_t sub_100FBB9BC(uint64_t a1)
{
  return sub_10021A0B0((uint64_t *)(a1 + 432));
}

void sub_100FBB9C4(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  if (*a3)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    int v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *a3;
      *(_DWORD *)uint64_t buf = 67240192;
      int v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Got a data protection notification we weren't registered for: %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      long long v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationNotifier::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
  else if (*a4 == 1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      int v15 = "DataProtection";
      __int16 v16 = 2082;
      int v17 = "Data available";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}", buf, 0x26u);
    }
    sub_1002083F4(a1 + 248);
    sub_1003128F0(a1 + 584);
    sub_100FBBC88(a1, 1);
  }
}

void sub_100FBBC88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  sub_100FBC604();
}

void sub_100FBBE68()
{
}

void sub_100FBBF20()
{
}

void sub_100FBBF44(int a1, int a2, std::string *__str)
{
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, __str);
  sub_100FBC004();
}

void sub_100FBBFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBC004()
{
}

void sub_100FBC0DC()
{
}

void sub_100FBC100(int a1, int a2, std::string *a3)
{
}

void sub_100FBC108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v4 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a4];
  sub_100FBC288();
}

void sub_100FBC274(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100FBC3C0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100FBC288()
{
}

void sub_100FBC36C()
{
  sub_1000D80C4(v0 + 28);
  uint64_t v1 = (void *)v0[25];
  if (v1)
  {
    v0[26] = v1;
    operator delete(v1);
  }
  sub_10041F48C(v0 + 12);
  sub_10041F48C(v0 + 3);
  operator delete();
}

void *sub_100FBC3C0(void *a1)
{
  sub_100FC10FC(a1 + 42);
  sub_1000D80C4(a1 + 28);
  uint64_t v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }
  sub_10041F48C(a1 + 12);
  sub_10041F48C(a1 + 3);
  return a1;
}

void sub_100FBC414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_100FBC41C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7E54((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBC494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBC4A8()
{
}

void sub_100FBC5F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100FBC3C0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100FBC604()
{
}

void sub_100FBC6B0(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1000DC48C(&__dst, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(unsigned char *)(a2 + 23);
  }
  else
  {
    long long __dst = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
  }
  id v4 = v20;
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)v20, v5 + 4);
  if (v21 < 0) {
    id v4 = (void *)v20[0];
  }
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v6 = (const void *)a2;
    }
    else {
      int v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }
  strcpy((char *)v4 + v5, "-wal");
  long long v7 = v22;
  if (*(char *)(a2 + 23) >= 0) {
    size_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)v22, v8 + 4);
  if (v23 < 0) {
    long long v7 = (void *)v22[0];
  }
  if (v8)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = (const void *)a2;
    }
    else {
      uint64_t v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }
  strcpy((char *)v7 + v8, "-shm");
  __int16 v14 = 0;
  int v15 = 0;
  v16[0] = 0;
  v16[1] = &v14;
  char v17 = 0;
  __int16 v14 = (char *)operator new(0x48uLL);
  int v15 = v14;
  v16[0] = v14 + 72;
  uint64_t v10 = sub_1000DC3CC((uint64_t)v16, &__dst, &v24, v14);
  uint64_t v11 = 0;
  int v15 = v10;
  do
  {
    if (*(&v23 + v11 * 8) < 0) {
      operator delete((void *)v22[v11]);
    }
    v11 -= 3;
  }
  while (v11 != -9);
  __int16 v12 = (uint64_t *)v14;
  uint64_t v13 = (uint64_t *)v15;
  while (v12 != v13)
  {
    sub_100FBC988((uint64_t)v10, v12);
    v12 += 3;
  }
  *(void *)&long long __dst = &v14;
  sub_1000A7B4C((void ***)&__dst);
}

void sub_100FBC8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15)
{
}

uint64_t sub_100FBC938(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1001F9CAC(result);
    operator delete();
  }
  return result;
}

void sub_100FBC988(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = (uint64_t *)*a2;
  }
  id v4 = +[NSString stringWithUTF8String:v3];
  if ([+[NSFileManager defaultManager] fileExistsAtPath:v4 isDirectory:0])
  {
    uint64_t v9 = 0;
    if (![+[NSFileManager defaultManager] removeItemAtPath:v4 error:&v9])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      size_t v5 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v6 = *((char *)a2 + 23) >= 0 ? a2 : (uint64_t *)*a2;
        *(_DWORD *)uint64_t buf = 68289539;
        int v11 = 0;
        __int16 v12 = 2082;
        uint64_t v13 = "";
        __int16 v14 = 2081;
        int v15 = v6;
        __int16 v16 = 2113;
        uint64_t v17 = v9;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to remove file\", \"filepath\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
      }
      long long v7 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        if (*((char *)a2 + 23) >= 0) {
          size_t v8 = a2;
        }
        else {
          size_t v8 = (uint64_t *)*a2;
        }
        *(_DWORD *)uint64_t buf = 68289539;
        int v11 = 0;
        __int16 v12 = 2082;
        uint64_t v13 = "";
        __int16 v14 = 2081;
        int v15 = v8;
        __int16 v16 = 2113;
        uint64_t v17 = v9;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to remove file", "{\"msg%{public}.0s\":\"failed to remove file\", \"filepath\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
      }
    }
  }
}

uint64_t sub_100FBCBA8(uint64_t a1)
{
  return sub_100312100(a1 + 584);
}

uint64_t sub_100FBCBB0(uint64_t a1)
{
  return sub_100312100(a1 + 472);
}

void sub_100FBCBB8(uint64_t a1)
{
  uint64_t v2 = [[[(NSString *)NSTemporaryDirectory() stringByAppendingPathComponent:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "microLocationDB")] stringByAppendingPathComponent:+[NSString stringWithUTF8String:"ExportedMiloDB.db"]] UTF8String];
  sub_100134750(__p, v2);
  sub_100FBC6B0(a1, (uint64_t)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FBCC5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBCC78(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7454((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 24), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCCF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCD04(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E74F4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 24), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCD90(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7594((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 24), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCE1C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7634((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 24), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCEA8(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E78B4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 32), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCF34(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7814((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 40), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBCFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBCFC0(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E76D4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBD038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBD04C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7774((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 24), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100FBD0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBD0D8(uint64_t a1, uint64_t *a2)
{
  memset(v13, 0, 48);
  char v17 = 0;
  LOBYTE(v18) = 0;
  char v19 = 0;
  memset(v15, 0, sizeof(v15));
  LOBYTE(v16) = 0;
  memset(__p, 0, 112);
  uint64_t v20 = -1;
  __p[14] = (void *)-1;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v3 = *a2;
  char v4 = (void *)a2[1];
  uint64_t v11 = 7;
  uint64_t v12 = v3;
  size_t v5 = (void *)a2[2];
  while (v4 != v5)
    sub_100FC467C(v13, v4++);
  unint64_t v6 = 0;
  v13[3] = *((_OWORD *)a2 + 2);
  uint64_t v14 = a2[6];
  while (1)
  {
    if (((unint64_t)a2[7] >> v6))
    {
      v10.n128_u64[0] = v6;
      sub_100FBD368(v15, &v10);
    }
    if (++v6 == 32)
    {
      size_t v8 = (__n128 *)a2[13];
      for (i = (__n128 *)a2[14]; v8 != i; ++v8)
      {
        __n128 v10 = *v8;
        sub_100FBD3F0(&__p[3], &v10);
      }
      uint64_t v21 = a2[9];
      if (__p != (void **)(a2 + 10)) {
        sub_1002DD194((char *)__p, (char *)a2[10], a2[11], (a2[11] - a2[10]) >> 3);
      }
      if (*((unsigned char *)a2 + 152))
      {
        long long v16 = *(_OWORD *)(a2 + 17);
        if (!v17) {
          char v17 = 1;
        }
        uint64_t v18 = a2[16];
        char v19 = 1;
      }
      long long v9 = *((_OWORD *)a2 + 11);
      *(_OWORD *)&__p[9] = *((_OWORD *)a2 + 10);
      *(_OWORD *)&__p[11] = v9;
      __p[13] = (void *)a2[24];
      sub_100FBC288();
    }
  }
}

void sub_100FBD340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100FBC3C0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100FBD368(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100FC4A1C(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

__n128 sub_100FBD3F0(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FC4D34(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100FBD47C(uint64_t a1, uint64_t *a2)
{
}

void sub_100FBD484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v5 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a5];

  sub_100FBC4A8();
}

void sub_100FBD4F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void sub_100FBD4F8(uint64_t a1, uint64_t a2, long long *a3, int64x2_t *a4, uint64_t a5)
{
  id v8 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a5];

  sub_100FBD564(a1, a3, a4);
}

void sub_100FBD564(uint64_t a1, long long *a2, int64x2_t *a3)
{
  memset(v15, 0, sizeof(v15));
  id v5 = (int64x2_t *)a3[1].i64[1];
  uint64_t v6 = a3 + 2;
  if (v5 != &a3[2])
  {
    do
    {
      uint64_t v7 = (v5[1].i32[3] - 1);
      if (v7 >= 3) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v7 + 2;
      }
      uint64_t v16 = v8;
      sub_100FBE840(v15, &v16);
      long long v9 = (int64x2_t *)v5->i64[1];
      if (v9)
      {
        do
        {
          __n128 v10 = v9;
          long long v9 = (int64x2_t *)v9->i64[0];
        }
        while (v9);
      }
      else
      {
        do
        {
          __n128 v10 = (int64x2_t *)v5[1].i64[0];
          BOOL v11 = v10->i64[0] == (void)v5;
          id v5 = v10;
        }
        while (!v11);
      }
      id v5 = v10;
    }
    while (v10 != v6);
  }
  int32x2_t v18 = 0;
  int v19 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v16 = 13;
  long long v17 = *a2;
  memset(v14, 0, sizeof(v14));
  int32x2_t v12 = vmovn_s64(*a3);
  int v13 = a3[1].i64[0];
  sub_100FBE8C8(v14, v15);
  int32x2_t v18 = v12;
  int v19 = v13;
  sub_100FBE8C8(v20, v14);
  sub_100FBE95C();
}

void sub_100FBD708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10041F48C(v10);
  sub_10041F48C(v9);
  sub_10041F48C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100FBD738(uint64_t a1, uint64_t a2, long long *a3, int64x2_t *a4, uint64_t a5)
{
}

void sub_100FBD740(uint64_t a1, uint64_t a2, long long *a3, uint64_t *a4)
{
  long long v41 = 0u;
  long long v40 = 0u;
  int64x2_t v39 = 0u;
  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  uint64_t v42 = -1;
  memset(v44, 0, sizeof(v44));
  long long v45 = 0u;
  int v46 = 0;
  if (*((unsigned char *)a3 + 16)) {
    long long v43 = *a3;
  }
  uint64_t v6 = (unsigned int *)a4[18];
  uint64_t v7 = (unsigned int *)a4[19];
  while (v6 != v7)
  {
    *(void *)uint64_t buf = *v6;
    sub_100FC504C(&v44[1], buf);
    ++v6;
  }
  uint64_t v8 = *((int *)a4 + 34);
  if (v8 >= 4)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    __n128 v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"unknown protobuf confidence level, deprecated?\"}", buf, 0x12u);
    }
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = qword_101D9B0C0[v8];
  }
  v44[0] = v9;
  *((int32x2_t *)&v45 + 1) = vmovn_s64(*(int64x2_t *)(a4 + 3));
  int v46 = a4[5];
  uint64_t v11 = *(void *)(a2 + 16);
  if ((unint64_t)(v11 - 1) >= 3)
  {
    if (v11 == 4)
    {
      uint64_t v19 = *a4;
      uint64_t v18 = a4[1];
      if (*a4 != v18)
      {
        do
        {
          *(_OWORD *)uint64_t buf = *(_OWORD *)v19;
          *(void *)&buf[16] = *(void *)(v19 + 16);
          uint64_t v20 = *(int *)(v19 + 24);
          if (v20 >= 4)
          {
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_102308378);
            }
            __int16 v22 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)long long __dst = 68289026;
              *(_WORD *)&__dst[8] = 2082;
              *(void *)&__dst[10] = "";
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"unknown protobuf confidence level, deprecated?\"}", __dst, 0x12u);
            }
            uint64_t v21 = 0;
          }
          else
          {
            uint64_t v21 = qword_101D9B0C0[v20];
          }
          *(void *)&buf[24] = v21;
          sub_100FC53EC(v38, (uint64_t)buf);
          v19 += 32;
        }
        while (v19 != v18);
      }
      if (*((unsigned char *)a4 + 128))
      {
        uint64_t v27 = (uint64_t *)a4[13];
        uint64_t v28 = (void *)(v39.i64[1] + 8 * ((unint64_t)v41 / 0x66));
        if ((void)v40 == v39.i64[1])
        {
          uint64_t v29 = 0;
          if (!v27) {
            goto LABEL_61;
          }
        }
        else
        {
          uint64_t v29 = *v28 + 40 * ((unint64_t)v41 % 0x66);
          if (!v27) {
            goto LABEL_61;
          }
        }
        do
        {
          if (*((char *)v27 + 39) < 0)
          {
            sub_1000DC48C(__dst, (void *)v27[2], v27[3]);
          }
          else
          {
            *(_OWORD *)long long __dst = *((_OWORD *)v27 + 1);
            *(void *)&__dst[16] = v27[4];
          }
          uint64_t v30 = v27[5];
          uint64_t v31 = v27[6];
          if ((__dst[23] & 0x80000000) != 0)
          {
            sub_1000DC48C(buf, *(void **)__dst, *(unint64_t *)&__dst[8]);
            *(void *)&buf[24] = v31;
            *(void *)&long long v35 = v30;
            if ((__dst[23] & 0x80000000) != 0) {
              operator delete(*(void **)__dst);
            }
          }
          else
          {
            *(_OWORD *)uint64_t buf = *(_OWORD *)__dst;
            *(void *)&buf[16] = *(void *)&__dst[16];
            *(void *)&buf[24] = v31;
            *(void *)&long long v35 = v30;
          }
          uint64_t v32 = (void *)sub_100FC5794(&v39, v28, v29, (long long *)buf);
          uint64_t v28 = v32;
          uint64_t v29 = v33 + 40;
          if (v33 + 40 - *v32 == 4080)
          {
            uint64_t v28 = v32 + 1;
            uint64_t v29 = v32[1];
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v27 = (uint64_t *)*v27;
        }
        while (v27);
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_102308378);
      }
      long long v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(a2 + 16);
        *(_DWORD *)uint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "MiLo send prediction unknown service type: %lu", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_102308378);
        }
        uint64_t v25 = *(void *)(a2 + 16);
        *(_DWORD *)long long __dst = 134217984;
        *(void *)&__dst[4] = v25;
        __int16 v26 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLMicroLocationNotifier::onSendPredictionResultsToClient(const CLMiLoService::ServiceDescriptor &, const std::optional<boost::uuids::uuid> &, const CLMicroLocationResultToPublish &, const CLMiLoService::ConnectionUuid &)", "%s\n", v26);
        if (v26 != (char *)buf) {
          free(v26);
        }
      }
    }
  }
  else
  {
    uint64_t v36 = 0;
    long long v35 = 0u;
    memset(buf, 0, sizeof(buf));
    int32x2_t v12 = (void *)sub_100FBDE88((uint64_t)v37, buf);
    sub_1002CDF4C(buf);
    v12[6] = *(void *)(a2 + 16);
    uint64_t v13 = *a4;
    uint64_t v14 = a4[1];
    if (*a4 != v14)
    {
      do
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)v13;
        *(void *)&buf[16] = *(void *)(v13 + 16);
        uint64_t v15 = *(int *)(v13 + 24);
        if (v15 >= 4)
        {
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_102308378);
          }
          long long v17 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)long long __dst = 68289026;
            *(_WORD *)&__dst[8] = 2082;
            *(void *)&__dst[10] = "";
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"unknown protobuf confidence level, deprecated?\"}", __dst, 0x12u);
          }
          uint64_t v16 = 0;
        }
        else
        {
          uint64_t v16 = qword_101D9B0C0[v15];
        }
        *(void *)&buf[24] = v16;
        sub_100FC53EC(v12, (uint64_t)buf);
        v13 += 32;
      }
      while (v13 != v14);
    }
  }
LABEL_61:
  sub_100FBDFA8();
}

void sub_100FBDE1C(_Unwind_Exception *a1)
{
}

unint64_t sub_100FBDE88(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100FC67CC((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x49));
  uint64_t v7 = *v6 + 56 * (v4 % 0x49);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4088;
  }
  *(void *)(v7 - 56) = *a2;
  *(void *)(v7 - 48) = a2[1];
  *(void *)(v7 - 4sub_100FB8FC8(&a9, 0) = a2[2];
  *(void *)(v7 - 32) = a2[3];
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *(void *)(v7 - 24) = a2[4];
  *(void *)(v7 - 16) = a2[5];
  a2[4] = 0;
  a2[5] = 0;
  *(void *)(v7 - 8) = a2[6];
  int64x2_t v8 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_101D1F270);
  *(int64x2_t *)(a1 + 32) = v8;
  uint64_t v9 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) == v9) {
    return 0;
  }
  else {
    return *(void *)(v9 + 8 * (v8.i64[0] / 0x49uLL)) + 56 * (v8.i64[0] % 0x49uLL);
  }
}

void sub_100FBDFA8()
{
}

void sub_100FBE0A4()
{
  sub_100FC1340(v2);
  sub_1002CDF4C(v1);
  sub_100FC14A0(v0);
  operator delete();
}

uint64_t sub_100FBE0F8(void *a1)
{
  sub_10041F48C(a1 + 22);
  sub_100FC1340(a1 + 12);
  sub_1002CDF4C(a1 + 6);

  return sub_100FC14A0(a1);
}

void sub_100FBE144(uint64_t a1, uint64_t a2, long long *a3, uint64_t *a4)
{
}

void sub_100FBE14C(uint64_t a1)
{
  uint64_t v2 = a1 + 248;
  sub_10027EB30(v5, a1 + 112, a1 + 248);
  sub_100293D1C(v3, a1 + 120, v2);
  sub_100288974(v5);
  sub_100293D20(v3);
  uint64_t v7 = (void **)&v4;
  sub_10022F0E4(&v7);
  v3[0] = (void **)&v6;
  sub_10022F0E4(v3);
}

void sub_100FBE1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  a10 = (void **)&a17;
  sub_10022F0E4(&a10);
  _Unwind_Resume(a1);
}

void sub_100FBE20C(uint64_t a1)
{
}

id sub_100FBE214(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) silo];
  if (*(double *)(a1 + 160) != 1.79769313e308)
  {
    [*(id *)(a1 + 152) invalidate];
    *(void *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0x7FEFFFFFFFFFFFFFLL;
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  *(double *)(a1 + 16sub_100FB8FC8(&a9, 0) = (Current_5 * 1000.0 + (double)a2) / 1000.0;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 160);
    *(_DWORD *)uint64_t buf = 68289794;
    int v10 = 0;
    __int16 v11 = 2082;
    int32x2_t v12 = "";
    __int16 v13 = 2050;
    double v14 = Current_5;
    __int16 v15 = 2050;
    uint64_t v16 = a2;
    __int16 v17 = 2050;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Starting periodic Trigger Event Timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}", buf, 0x30u);
  }
  [*(id *)(a1 + 152) setNextFireTime:*(double *)(a1 + 160)];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  long long v8[2] = sub_100FBE3D0;
  v8[3] = &unk_1022A3020;
  v8[4] = a1;
  return [*(id *)(a1 + 152) setHandler:v8];
}

void sub_100FBE3D0(uint64_t a1)
{
}

void sub_100FBE3D8(uint64_t a1)
{
  [*(id *)(a1 + 32) silo];
  CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 2050;
    CFAbsoluteTime v8 = Current_5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, periodic Trigger Event Timer stopped\", \"now\":\"%{public}.3f\"}", (uint8_t *)v4, 0x1Cu);
  }
  [*(id *)(a1 + 152) invalidate];
  *(void *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0x7FEFFFFFFFFFFFFFLL;
  sub_10030E188((unsigned __int8 *)(a1 + 584));
}

id sub_100FBE4F0(uint64_t a1, uint64_t a2)
{
  return sub_100FBE214(a1 - 136, a2);
}

BOOL sub_100FBE4F8(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) silo];
  double v4 = *(double *)(a1 + 176);
  if (v4 == 1.79769313e308)
  {
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    *(double *)(a1 + 176) = (Current_5 * 1000.0 + (double)a2) / 1000.0;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_102308378);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 176);
      *(_DWORD *)uint64_t buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2050;
      double v15 = Current_5;
      __int16 v16 = 2050;
      uint64_t v17 = a2;
      __int16 v18 = 2050;
      uint64_t v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Starting Rescheduled Localization Timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}", buf, 0x30u);
    }
    [*(id *)(a1 + 168) setNextFireTime:*(double *)(a1 + 176)];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100FBE6B8;
    v9[3] = &unk_1022A3020;
    v9[4] = a1;
    [*(id *)(a1 + 168) setHandler:v9];
  }
  return v4 == 1.79769313e308;
}

void sub_100FBE6B8(uint64_t a1)
{
}

void sub_100FBE6C0(uint64_t a1)
{
  [*(id *)(a1 + 32) silo];
  CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 2050;
    CFAbsoluteTime v8 = Current_5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Rescheduled Localization Timer stopped\", \"now\":\"%{public}.3f\"}", (uint8_t *)v4, 0x1Cu);
  }
  [*(id *)(a1 + 168) invalidate];
  *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
  sub_10030E39C(a1 + 584);
}

BOOL sub_100FBE7D8(uint64_t a1, uint64_t a2)
{
  return sub_100FBE4F8(a1 - 136, a2);
}

void sub_100FBE7E0(uint64_t a1, long long *a2)
{
}

void sub_100FBE7E8(uint64_t a1, long long *a2)
{
}

uint64_t sub_100FBE7F0(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_100FBE7F8(uint64_t a1)
{
  return *(void *)(a1 - 72);
}

uint64_t sub_100FBE800(uint64_t a1)
{
  return 1;
}

uint64_t sub_100FBE820(uint64_t a1)
{
  return 1;
}

void sub_100FBE840(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100FC8BF4(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void *sub_100FBE8C8(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a2[4];
    uint64_t v5 = a2[1];
    uint64_t v6 = a2[2];
    uint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
    if (v6 == v5)
    {
      unint64_t v8 = 0;
      int v11 = 0;
      int v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
    }
    else
    {
      unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
      unint64_t v9 = a2[5] + v4;
      int v10 = (char *)(v5 + 8 * (v9 >> 9));
      int v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
    }
    sub_100FC8F0C(a1, v7, v8, v10, v11);
  }
  return a1;
}

void sub_100FBE95C()
{
}

void sub_100FBEA28()
{
}

void sub_100FBEA4C()
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v0 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v1[0] = 68289026;
    v1[1] = 0;
    __int16 v2 = 2082;
    uint64_t v3 = "";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNowPlayingEvent\"}", (uint8_t *)v1, 0x12u);
  }
}

void sub_100FBEB28()
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v0 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v1[0] = 68289026;
    v1[1] = 0;
    __int16 v2 = 2082;
    uint64_t v3 = "";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onAppLaunchEvent\"}", (uint8_t *)v1, 0x12u);
  }
}

void sub_100FBEC04(uint64_t a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_102308378);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 1026;
    int v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNowPlayingQueryResult\", \"Number of events\":%{public}d}", (uint8_t *)v4, 0x18u);
  }
}

void sub_100FBECF0()
{
}

void sub_100FBEDAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t sub_100FBEDE8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_102308AB8;
  *(void *)(a1 + 8) = [[CLNotifierClientAdapter alloc] initWithClient:a1];
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  if (*((char *)a3 + 23) >= 0) {
    __int16 v12 = a3;
  }
  else {
    __int16 v12 = (uint64_t *)*a3;
  }
  id v13 = [objc_msgSend(a4, "vendor") proxyForService:[NSString stringWithUTF8String:v12]];
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  [*(id *)(a1 + 16) registerDelegate:*(void *)(a1 + 8) inSilo:objc_msgSend(a4, "silo")];
  return a1;
}

void sub_100FBEECC(uint64_t a1, uint64_t a2)
{
  v14[0] = a2;
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        unint64_t v9 = (uint64_t *)v4;
      }
      else {
        unint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)uint64_t buf = *(_DWORD *)(*(void *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112))(a1, a2, buf);
      }
      sub_10006DA64(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_102308358);
      }
      int v10 = qword_102419588;
      if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          int v11 = (void *)*v11;
        }
        *(_DWORD *)uint64_t buf = 136446466;
        uint64_t v19 = v11;
        __int16 v20 = 1026;
        int v21 = a2;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419580 != -1) {
          dispatch_once(&qword_102419580, &stru_102308358);
        }
        __int16 v12 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          __int16 v12 = (void *)*v12;
        }
        v14[1] = 136446466;
        double v15 = v12;
        __int16 v16 = 1026;
        int v17 = a2;
        id v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::removeClient(int) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
    }
  }
}

uint64_t sub_100FBF15C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_100FC9B64(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96))(a1, a2, &v10, v7);
  }
  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88))(a1, a2, &v9);
  }
}

uint64_t sub_100FBF210(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 104))(a1, a2, &v4);
}

uint64_t sub_100FBF258(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 112))(a1, a2, &v4);
}

uint64_t sub_100FBF2A0(uint64_t a1, int a2)
{
  int v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 120))(a1, &v3);
}

uint64_t sub_100FBF2E8(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024758F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = a1;
    int v3 = __cxa_guard_acquire(&qword_1024758F0);
    a1 = v4;
    if (v3)
    {
      qword_1024758D8 = 0;
      unk_1024758E0 = 0;
      qword_1024758E8 = 0;
      __cxa_atexit((void (*)(void *))sub_10058C198, &qword_1024758D8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1024758F0);
      a1 = v4;
    }
  }
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 96);

  return v1();
}

BOOL sub_100FBF3C4(uint64_t a1, int a2, int *a3, const std::string *a4)
{
  int v40 = a2;
  if (*(unsigned char *)(a1 + 108)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v39 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          long long v23 = (uint64_t *)v17;
        }
        else {
          long long v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }
      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          uint64_t v28 = (uint64_t *)v24;
        }
        else {
          uint64_t v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }
      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)long long v41 = v25;
        uint64_t v34 = *(void *)(v25 + 56);
        *(void *)uint64_t buf = &v40;
        long long v35 = sub_1000EAEE4((uint64_t **)(v25 + 40), &v40, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        std::string::operator=((std::string *)(v35 + 5), a4);
        *(void *)uint64_t buf = 0;
        *(_OWORD *)&buf[16] = 0u;
        *(void *)&uint8_t buf[8] = &buf[16];
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, unsigned char *))(*(void *)a1 + 128))(a1, a3, buf))
        {
          sub_100FC9DDC();
        }
        sub_1002A50D0((uint64_t)&buf[8], *(void **)&buf[16]);
        if (v34) {
          goto LABEL_46;
        }
      }
      else
      {
LABEL_42:
        *(void *)long long v41 = a1 + 64;
        char v29 = byte_1024758F8;
        int v38 = v16;
        *(void *)uint64_t buf = &v38;
        *((unsigned char *)sub_10078BC58((uint64_t **)(a1 + 56), &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 8sub_100FB8FC8(&a9, 0) = v29;
        int v38 = *a3;
        *(void *)uint64_t buf = &v38;
        uint64_t v30 = sub_10078BC58((uint64_t **)(a1 + 56), &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        uint64_t v31 = (std::__shared_weak_count *)v30[9];
        void v30[8] = 0;
        v30[9] = 0;
        if (v31) {
          sub_1000DB0A0(v31);
        }
        int v38 = *a3;
        *(void *)uint64_t buf = &v38;
        uint64_t v32 = sub_10078BC58((uint64_t **)(a1 + 56), &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *(void *)uint64_t buf = &v40;
        uint64_t v33 = sub_1000EAEE4(v32 + 5, &v40, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        std::string::operator=((std::string *)(v33 + 5), a4);
      }
      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168))(a1, a3);
LABEL_46:
      if (v20 == v18)
      {
        *(_DWORD *)uint64_t buf = *a3;
        sub_1000EDED4((uint64_t **)(v39 + 40), (int *)buf, buf);
      }
      return 1;
    }
  }
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  id v14 = qword_102419588;
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
  {
    double v15 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      double v15 = (void *)*v15;
    }
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }
  BOOL result = sub_10013D1A0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v36 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v36 = (void *)*v36;
    }
    *(_DWORD *)long long v41 = 136446466;
    *(void *)&v41[4] = v36;
    __int16 v42 = 1026;
    int v43 = a2;
    __int16 v37 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v37);
    if (v37 != buf) {
      free(v37);
    }
    return 0;
  }
  return result;
}

void sub_100FBF890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  sub_1002A50D0(v19, a19);
  _Unwind_Resume(a1);
}

BOOL sub_100FBF8B4(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }
    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }
  else
  {
LABEL_11:
    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v10 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        int v11 = (void *)*v11;
      }
      *(_DWORD *)uint64_t buf = 136446466;
      uint64_t v24 = v11;
      __int16 v25 = 1026;
      int v26 = a2;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }
    BOOL v12 = sub_10013D1A0(115, 0);
    BOOL result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_102308358);
      }
      BOOL v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_100FBFB38(char *a1, int a2, int *a3)
{
  int v32 = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }
          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1000ED9F4((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                __int16 v25 = (uint64_t *)v20;
              }
              else {
                __int16 v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }
            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_10006D9B8((uint64_t)(v22 + 40), &v32);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176))(a1, a3);
              }
            }
            else
            {
LABEL_33:
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_102308358);
              }
              int v26 = qword_102419588;
              if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
              {
                BOOL v27 = a1 + 8;
                if (a1[31] < 0) {
                  BOOL v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160))(__p, a1, a3);
                if (v42 >= 0) {
                  uint64_t v28 = __p;
                }
                else {
                  uint64_t v28 = (void **)__p[0];
                }
                *(_DWORD *)uint64_t buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v34 = 2082;
                long long v35 = v28;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v42 < 0) {
                  operator delete(__p[0]);
                }
              }
              if (sub_10013D1A0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_102419580 != -1) {
                  dispatch_once(&qword_102419580, &stru_102308358);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                (*(void (**)(unsigned char *__return_ptr, char *, int *))(*(void *)a1 + 160))(buf, a1, a3);
                if (v36 >= 0) {
                  uint64_t v30 = buf;
                }
                else {
                  uint64_t v30 = *(unsigned char **)buf;
                }
                int v37 = 136446466;
                int v38 = v29;
                __int16 v39 = 2082;
                int v40 = v30;
                uint64_t v31 = (char *)_os_log_send_and_compose_impl();
                if (v36 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v31);
                if (v31 != (char *)__p) {
                  free(v31);
                }
              }
            }
          }
        }
      }
    }
  }
  return v3 == 0;
}

uint64_t sub_100FBFF0C(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 == v3) {
    return 0;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0;
  }
  uint64_t v11 = *(void *)(v7 + 64);
  if (!v11) {
    return 0;
  }
  *(void *)a3 = *(void *)v11;
  if (v11 != a3) {
    sub_100FCA65C((uint64_t **)(a3 + 8), *(long long **)(v11 + 8), (long long *)(v11 + 16));
  }
  return 1;
}

uint64_t sub_100FBFF94(uint64_t a1, int *a2, void *a3)
{
  sub_100FCAD08(a3, &v10);
  int v9 = *a2;
  uint64_t v11 = &v9;
  uint64_t v5 = sub_10078BC58((uint64_t **)(a1 + 56), &v9, (uint64_t)&unk_101D0B290, &v11);
  long long v6 = v10;
  long long v10 = 0uLL;
  uint64_t v7 = (std::__shared_weak_count *)v5[9];
  *((_OWORD *)v5 + 4) = v6;
  if (v7)
  {
    sub_1000DB0A0(v7);
    if (*((void *)&v10 + 1)) {
      sub_1000DB0A0(*((std::__shared_weak_count **)&v10 + 1));
    }
  }
  return 1;
}

void sub_100FC0028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC0040(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  long long v6 = 0u;
  uint64_t v5 = &v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, a2, &v4, a3, a4, 0);
  sub_1002A50D0((uint64_t)&v5, (void *)v6);
}

void sub_100FC00BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  sub_1002A50D0(v11, a11);
  _Unwind_Resume(a1);
}

void sub_100FC00D4(uint64_t a1, unsigned int *a2, void *a3, int a4)
{
  if (*(unsigned char *)(a1 + 108)) {
    return;
  }
  int v8 = _os_activity_create((void *)&_mh_execute_header, "CL: notifyClientsWithData (Fallback)", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  os_activity_scope_enter(v8, &state);

  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_102308358);
  }
  int v9 = qword_102419588;
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    long long v10 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      long long v10 = (void *)*v10;
    }
    uint64_t v11 = (std::__shared_weak_count *)*a2;
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2082;
    *(void *)&buf[20] = "activity";
    __int16 v23 = 2082;
    BOOL v24 = v10;
    __int16 v25 = 2050;
    int v26 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"notifyClientsWithData\", \"event\":%{public, location:escape_only}s, \"name\":%{public, location:escape_only}s, \"notification\":%{public}lld}", buf, 0x30u);
  }
  uint64_t v12 = *(void *)(a1 + 64);
  if (!v12) {
    goto LABEL_18;
  }
  int v13 = *a2;
  uint64_t v14 = (uint64_t **)(a1 + 64);
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < v13;
    if (v15 >= v13) {
      int v17 = (uint64_t *)v12;
    }
    else {
      int v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      uint64_t v14 = (uint64_t **)v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 == (uint64_t **)(a1 + 64) || v13 < *((_DWORD *)v14 + 8))
  {
LABEL_18:
    BOOL v27 = v28;
    memset(v28, 0, sizeof(v28));
    char v29 = 0;
    sub_100FCB320((uint64_t)buf, a2, (uint64_t)&v27);
    uint64_t v14 = sub_10078A368((uint64_t **)(a1 + 56), (__n128 *)buf);
    if (v26) {
      sub_1000DB0A0(v26);
    }
    sub_10078A7B0((uint64_t)&buf[8], *(char **)&buf[16]);
    if (v29) {
      sub_1000DB0A0(v29);
    }
    sub_10078A7B0((uint64_t)&v27, v28[0]);
  }
  if (!a4)
  {
    uint64_t v20 = (std::__shared_weak_count *)v14[9];
    unsigned char v14[8] = 0;
    v14[9] = 0;
    if (!v20) {
      goto LABEL_29;
    }
LABEL_28:
    sub_1000DB0A0(v20);
    goto LABEL_29;
  }
  sub_100FCAD08(a3, buf);
  long long v18 = *(_OWORD *)buf;
  *(void *)uint64_t buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  int v19 = (std::__shared_weak_count *)v14[9];
  *((_OWORD *)v14 + 4) = v18;
  if (v19)
  {
    sub_1000DB0A0(v19);
    uint64_t v20 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8]) {
      goto LABEL_28;
    }
  }
LABEL_29:
  if (v14[7]) {
    sub_100FCAE54();
  }
  os_activity_scope_leave(&state);
}

void sub_100FC06A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100FC06F0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 108))
  {
    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    __int16 v2 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      *(_DWORD *)uint64_t buf = 136315138;
      BOOL v22 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_102308358);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  else
  {
    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_102308358);
    }
    uint64_t v5 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      long long v6 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        long long v6 = (void *)*v6;
      }
      uint64_t v7 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315394;
      BOOL v22 = v6;
      __int16 v23 = 2048;
      v24[0] = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_102308358);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    int v8 = *(void **)(a1 + 80);
    if (v8 != (void *)(a1 + 88))
    {
      do
      {
        int v9 = (void *)v8[5];
        if (v9 != v8 + 6)
        {
          do
          {
            if (qword_102419580 != -1) {
              dispatch_once(&qword_102419580, &stru_102308358);
            }
            long long v10 = qword_102419588;
            if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v11 = (void *)(a1 + 8);
              if (*(char *)(a1 + 31) < 0) {
                uint64_t v11 = *(void **)(a1 + 8);
              }
              int v12 = *((_DWORD *)v8 + 8);
              int v13 = *((_DWORD *)v9 + 7);
              *(_DWORD *)uint64_t buf = 136315650;
              BOOL v22 = v11;
              __int16 v23 = 1024;
              LODWORD(v24[0]) = v12;
              WORD2(v24[0]) = 1024;
              *(_DWORD *)((char *)v24 + 6) = v13;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }
            if (sub_10013D1A0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_102308358);
              }
              int v17 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v17);
              if (v17 != (char *)buf) {
                free(v17);
              }
            }
            uint64_t v14 = (void *)v9[1];
            if (v14)
            {
              do
              {
                int v15 = v14;
                uint64_t v14 = (void *)*v14;
              }
              while (v14);
            }
            else
            {
              do
              {
                int v15 = (void *)v9[2];
                BOOL v16 = *v15 == (void)v9;
                int v9 = v15;
              }
              while (!v16);
            }
            int v9 = v15;
          }
          while (v15 != v8 + 6);
        }
        long long v18 = (void *)v8[1];
        if (v18)
        {
          do
          {
            int v19 = v18;
            long long v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            int v19 = (void *)v8[2];
            BOOL v16 = *v19 == (void)v8;
            int v8 = v19;
          }
          while (!v16);
        }
        int v8 = v19;
      }
      while (v19 != (void *)(a1 + 88));
    }
  }
}

void sub_100FC0CA0(uint64_t a1)
{
  sub_100FC9AF4(a1);

  operator delete();
}

id sub_100FC0CD8(uint64_t a1, int a2, void *a3)
{
  id result = sub_100FCA414(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0, &v6, result, *(void *)(a1 + 32));
  }
  return result;
}

void sub_100FC0D28(id a1)
{
  qword_102419588 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100FC0D58(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100FC0D88(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void sub_100FC0DE4(uint64_t a1, int a2)
{
}

void sub_100FC0DF4(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  v7.length = CFArrayGetCount(a1);
  v7.location = 0;
  CFArrayApplyFunction(a1, v7, (CFArrayApplierFunction)sub_100FC0EA0, &v4);
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  uint64_t v5 = 0;
  long long v4 = 0uLL;
  int v6 = (void **)&v4;
  sub_1000A7B4C(&v6);
}

void sub_100FC0E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1000A7B4C(&a12);
  _Unwind_Resume(a1);
}

void sub_100FC0EA0(void *a1, uint64_t *a2)
{
  sub_100314C34(a1, __p);
  unint64_t v3 = a2[1];
  if (v3 >= a2[2])
  {
    uint64_t v5 = sub_1016FD368(a2, (long long *)__p);
  }
  else
  {
    if (SHIBYTE(v7) < 0)
    {
      sub_1000DC48C((unsigned char *)a2[1], __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v4 = *(_OWORD *)__p;
      *(void *)(v3 + 16) = v7;
      *(_OWORD *)unint64_t v3 = v4;
    }
    uint64_t v5 = v3 + 24;
    a2[1] = v3 + 24;
  }
  a2[1] = v5;
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FC0F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)(v15 + 8) = v16;
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100FC0F60(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *((unsigned __int8 *)a2 + 72))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      uint64_t v5 = (void **)(a1 + 24);
      if (*(char *)(a1 + 47) < 0) {
        operator delete(*v5);
      }
      long long v6 = *(long long *)((char *)a2 + 24);
      *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = *((void *)a2 + 5);
      *(_OWORD *)uint64_t v5 = v6;
      *((unsigned char *)a2 + 47) = 0;
      *((unsigned char *)a2 + 24) = 0;
      uint64_t v7 = (void **)(a1 + 48);
      if (*(char *)(a1 + 71) < 0) {
        operator delete(*v7);
      }
      __n128 result = (__n128)a2[3];
      *(void *)(a1 + 64) = *((void *)a2 + 8);
      *(__n128 *)uint64_t v7 = result;
      *((unsigned char *)a2 + 71) = 0;
      *((unsigned char *)a2 + 48) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 72))
  {
    sub_100FC10A0(a1);
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v9;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v10 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v10;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    __n128 result = (__n128)a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(__n128 *)(a1 + 48) = result;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(unsigned char *)(a1 + 72) = 1;
  }
  return result;
}

void sub_100FC10A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
}

uint64_t sub_100FC10FC(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    long long v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }
  else
  {
    long long v4 = a1 + 5;
    unint64_t v5 = a1[4];
    long long v6 = &v2[v5 / 0x38];
    unint64_t v7 = (unint64_t)*v6 + 72 * (v5 % 0x38);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x38] + 72 * ((a1[5] + v5) % 0x38);
    if (v7 != v8)
    {
      do
      {
        sub_10041F48C((void *)(v7 + 24));
        v7 += 72;
        if (v7 - (void)*v6 == 4032)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != v8);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 28;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 56;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    int v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

char *sub_100FC1250(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_1000DC48C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  long long v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_1000DC48C(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)long long v6 = v7;
  }
  __dst[72] = 1;
  return __dst;
}

void sub_100FC130C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC1340(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    long long v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }
  else
  {
    long long v4 = a1 + 5;
    unint64_t v5 = a1[4];
    long long v6 = &v2[v5 / 0x66];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 40 * (v5 % 0x66);
    unint64_t v9 = (unint64_t)v2[(a1[5] + v5) / 0x66] + 40 * ((a1[5] + v5) % 0x66);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 40;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 51;
  }
  else
  {
    if (v12 != 2) {
      goto LABEL_18;
    }
    uint64_t v13 = 102;
  }
  a1[4] = v13;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v14 = *v2++;
    operator delete(v14);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

uint64_t sub_100FC14A0(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    long long v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }
  else
  {
    long long v4 = a1 + 5;
    unint64_t v5 = a1[4];
    long long v6 = &v2[v5 / 0x49];
    unint64_t v7 = (char *)*v6 + 56 * (v5 % 0x49);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x49] + 56 * ((a1[5] + v5) % 0x49);
    if (v7 != (char *)v8)
    {
      do
      {
        unint64_t v7 = (char *)(sub_1002CDF4C(v7) + 56);
        if (v7 - (unsigned char *)*v6 == 4088)
        {
          unint64_t v9 = (char *)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 36;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 73;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

void sub_100FC15EC()
{
}

void *sub_100FC1600(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1023087E8;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC1648(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1023087E8;
  a2[1] = v2;
  return result;
}

void sub_100FC1674()
{
}

void sub_100FC16D0()
{
}

uint64_t sub_100FC16F4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FC1734()
{
}

void *sub_100FC1740(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100FC17C8()
{
}

void *sub_100FC17DC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_102308878;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC1824(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_102308878;
  a2[1] = v2;
  return result;
}

void sub_100FC1850()
{
}

void sub_100FC18AC()
{
}

uint64_t sub_100FC18D0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FC1910()
{
}

void *sub_100FC191C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100FC19A4()
{
}

void *sub_100FC19B8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_102308908;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC1A00(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_102308908;
  a2[1] = v2;
  return result;
}

void sub_100FC1A2C()
{
}

void sub_100FC1A88()
{
}

uint64_t sub_100FC1AAC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FC1AEC()
{
}

void *sub_100FC1AF8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100FC1B80()
{
}

void *sub_100FC1B94(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_102308998;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC1BDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_102308998;
  a2[1] = v2;
  return result;
}

void sub_100FC1C08()
{
}

void sub_100FC1C64()
{
}

uint64_t sub_100FC1C88(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FC1CC8()
{
}

void *sub_100FC1CD4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100FC1D5C()
{
}

void *sub_100FC1D70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_102308A28;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC1DB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_102308A28;
  a2[1] = v2;
  return result;
}

void sub_100FC1DE4()
{
}

void sub_100FC1E40()
{
}

uint64_t sub_100FC1E64(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FC1EA4()
{
}

void *sub_100FC1EB0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100FC1F34(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    sub_100FC0D88(v1 + 32);
    operator delete();
  }
  return result;
}

char *sub_100FC1F90(char *__dst, uint64_t a2)
{
  *long long __dst = 0;
  __dst[72] = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    sub_100FC1FE8(__dst, (long long *)a2);
    __dst[72] = 1;
  }
  return __dst;
}

void sub_100FC1FD4(_Unwind_Exception *a1)
{
  sub_100FC0D88(v1);
  _Unwind_Resume(a1);
}

char *sub_100FC1FE8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_1000DC48C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  long long v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_1000DC48C(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)long long v6 = v7;
  }
  return __dst;
}

void sub_100FC209C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC20D0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100FC2134(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  if (v1)
  {
    sub_100FC10FC(v1 + 42);
    sub_1000D80C4(v1 + 28);
    uint64_t v2 = (void *)v1[25];
    if (v2)
    {
      v1[26] = v2;
      operator delete(v2);
    }
    sub_10041F48C(v1 + 12);
    sub_10041F48C(v1 + 3);
    operator delete();
  }
  return result;
}

uint64_t sub_100FC21B8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_100FC22B8(a1 + 8, (void *)(a2 + 8));
  long long v4 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v4;
  sub_100FC2A5C(a1 + 80, (void *)(a2 + 80));
  long long v5 = *(_OWORD *)(a2 + 128);
  long long v6 = *(_OWORD *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  uint64_t v8 = *(void *)(a2 + 176);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 176) = v8;
  *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = v7;
  *(_OWORD *)(a1 + 144) = v6;
  *(_OWORD *)(a1 + 128) = v5;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  sub_1001DD364((void *)(a1 + 184), *(const void **)(a2 + 184), *(void *)(a2 + 192), (uint64_t)(*(void *)(a2 + 192) - *(void *)(a2 + 184)) >> 3);
  sub_100FC3200(a1 + 208, (void *)(a2 + 208));
  long long v9 = *(_OWORD *)(a2 + 256);
  long long v10 = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(_OWORD *)(a1 + 256) = v9;
  *(_OWORD *)(a1 + 272) = v10;
  return a1;
}

void sub_100FC227C(_Unwind_Exception *a1)
{
  long long v6 = *v4;
  if (*v4)
  {
    *(void *)(v2 + 192) = v6;
    operator delete(v6);
  }
  sub_10041F48C(v3);
  sub_10041F48C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC22B8(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  long long v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    uint64_t v8 = 0;
    unint64_t v11 = 0;
    long long v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    uint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    long long v10 = (char *)(v5 + 8 * (v9 >> 9));
    unint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  sub_100FC2364((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC2350(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC2364(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100FC2398(a1, a2, a3, v5);
}

void *sub_100FC2398(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC24D0(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  uint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  __n128 result = sub_100B83A3C((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        int v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            BOOL v22 = a2[1];
            ++a2;
            int v19 = v22;
            a3 = v22;
          }
        }
        while (v20 != (void *)v18);
      }
      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }
    while (v23 != v16);
    a1[5] = v17;
  }
  return result;
}

void sub_100FC24D0(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            long long v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)long long v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          int v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          __int16 v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }
          BOOL v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        __int16 v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              char v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                NSFileAttributeKey v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)NSFileAttributeKey v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              long long v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }
              char v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          __int16 v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      long long v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      long long v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC29E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC2A5C(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  sub_100FC2B08((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC2AF4(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC2B08(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100FC2B3C(a1, a2, a3, v5);
}

void *sub_100FC2B3C(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC2C74(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  __n128 result = sub_100B83A3C((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            BOOL v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }
        while (v20 != (void *)v18);
      }
      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }
    while (v23 != v16);
    a1[5] = v17;
  }
  return result;
}

void sub_100FC2C74(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            long long v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)long long v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          int v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          __int16 v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }
          BOOL v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        __int16 v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              char v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                NSFileAttributeKey v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)NSFileAttributeKey v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              long long v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }
              char v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          __int16 v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      long long v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      long long v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC318C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC3200(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 8));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 8));
  }
  else
  {
    unint64_t v8 = (long long *)(*(void *)v7 + 16 * v4);
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 8));
    uint64_t v11 = (long long *)(*(void *)v10 + 16 * v9);
  }
  sub_100FC32A4((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC3290(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC32A4(void *a1, char *a2, long long *a3, char *a4, long long *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 4) + 32 * (a4 - a2) - (((uint64_t)a3 - *(void *)a2) >> 4);
  }
  return sub_100FC32D8(a1, a2, a3, v5);
}

void *sub_100FC32D8(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 32 * (v9 - v8) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC3408(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 8));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 16 * v11;
  }
  v22[0] = v8 + 8 * (v11 >> 8);
  v22[1] = v14;
  __n128 result = sub_1000D9B0C((uint64_t)v22, a4);
  while (v14 != v16)
  {
    uint64_t v17 = (_OWORD *)(v13 == result ? v16 : *v13 + 4096);
    if ((_OWORD *)v14 == v17)
    {
      uint64_t v17 = (_OWORD *)v14;
    }
    else
    {
      uint64_t v18 = (_OWORD *)v14;
      do
      {
        long long v19 = *a3++;
        *uint64_t v18 = v19;
        if ((long long *)((char *)a3 - *a2) == (long long *)4096)
        {
          uint64_t v20 = (long long *)a2[1];
          ++a2;
          a3 = v20;
        }
        ++v18;
      }
      while (v18 != v17);
    }
    a1[5] += ((uint64_t)v17 - v14) >> 4;
    if (v13 == result) {
      break;
    }
    uint64_t v21 = v13[1];
    ++v13;
    uint64_t v14 = v21;
  }
  return result;
}

void sub_100FC3408(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((_BYTE)v5) {
    unint64_t v6 = (v5 >> 8) + 1;
  }
  else {
    unint64_t v6 = v5 >> 8;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 8) {
    unint64_t v8 = v7 >> 8;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 8)
  {
    for (a1[4] = v7 - (v8 << 8); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            long long v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)long long v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          int v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          __int16 v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }
          BOOL v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 255;
          }
          else {
            uint64_t v64 = 256;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 8);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = v8 << 8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        __int16 v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              char v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                NSFileAttributeKey v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)NSFileAttributeKey v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              long long v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }
              char v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          __int16 v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      long long v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      long long v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC3920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC3994(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    unint64_t v5 = 0;
    unint64_t v8 = 0;
    unint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x38));
  }
  else
  {
    unint64_t v5 = (long long *)(*(void *)(v4 + 8 * (v3 / 0x38)) + 72 * (v3 % 0x38));
    unint64_t v6 = a2[5] + v3;
    unint64_t v7 = (void *)(v4 + 8 * (v6 / 0x38));
    unint64_t v8 = (long long *)(*v7 + 72 * (v6 % 0x38));
  }
  sub_100FC3A64((void *)a1, (void *)(v4 + 8 * (v3 / 0x38)), v5, v7, v8);
  return a1;
}

void sub_100FC3A50(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC3A64(void *a1, void *a2, long long *a3, void *a4, long long *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 56 * (a4 - a2)
  }
       - 0x71C71C71C71C71C7 * (((uint64_t)a5 - *a4) >> 3)
       + 0x71C71C71C71C71C7 * (((uint64_t)a3 - *a2) >> 3);
  return sub_100FC3AC8(a1, a2, a3, v5);
}

uint64_t sub_100FC3AC8(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 56 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC3C94(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 / 0x38));
  if (v9 == v8) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *v13 + 72 * (v11 % 0x38);
  }
  uint64_t v24 = (void *)(v8 + 8 * (v11 / 0x38));
  unint64_t v25 = v14;
  uint64_t result = (uint64_t)sub_1005AACC4(&v24, a4);
  uint64_t v16 = v25;
  if (v14 != v25)
  {
    uint64_t v17 = v24;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4032;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = 0;
        do
        {
          uint64_t v20 = v14 + v19;
          long long v21 = *a3;
          *(void *)(v20 + 16) = *((void *)a3 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t result = sub_100FC2A5C(v14 + v19 + 24, (void *)a3 + 3);
          a3 = (long long *)((char *)a3 + 72);
          if ((long long *)((char *)a3 - *a2) == (long long *)4032)
          {
            BOOL v22 = (long long *)a2[1];
            ++a2;
            a3 = v22;
          }
          v19 += 72;
        }
        while (v14 + v19 != v18);
      }
      a1[5] -= 0x71C71C71C71C71C7 * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v23 = v13[1];
      ++v13;
      unint64_t v14 = v23;
    }
    while (v23 != v16);
  }
  return result;
}

void sub_100FC3C70(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x71C71C71C71C71C7 * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100FC3C94(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x38) {
    unint64_t v6 = v5 / 0x38 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x38;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x38) {
    unint64_t v8 = v7 / 0x38;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x38)
  {
    for (a1[4] = v7 - 56 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            long long v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)long long v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          int v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          BOOL v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFC0uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0xFC0uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 55;
          }
          else {
            uint64_t v64 = 56;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - 56 * v8;
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = -56 * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFC0uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        __int16 v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              char v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                NSFileAttributeKey v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)NSFileAttributeKey v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              long long v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }
              char v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          __int16 v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      long long v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      long long v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC41D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC424C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

double sub_100FC426C(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 56 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FC4364(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x38)) + 72 * (v7 % 0x38);
  long long v9 = *a2;
  *(void *)(v8 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v8 = v9;
  *(void *)(v8 + 24) = *((void *)a2 + 3);
  *(void *)(v8 + 32) = *((void *)a2 + 4);
  *(void *)(v8 + 4sub_100FB8FC8(&a9, 0) = *((void *)a2 + 5);
  *(void *)(v8 + 48) = *((void *)a2 + 6);
  double result = 0.0;
  *(long long *)((char *)a2 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(long long *)((char *)a2 + 24) = 0u;
  *(void *)(v8 + 56) = *((void *)a2 + 7);
  *(void *)(v8 + 64) = *((void *)a2 + 8);
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  ++a1[5];
  return result;
}

void sub_100FC4364(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x38;
  unint64_t v4 = v2 - 56;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFC0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFC0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFC0uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC4630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FC467C(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100FC4704(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_100FC4704(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC49D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FC4A1C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC4CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FC4D34(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC5000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FC504C(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100FC50D4(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_100FC50D4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC53A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100FC53EC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FC547C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *unint64_t v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100FC547C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  BOOL v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC5748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_100FC5794(int64x2_t *a1, void *a2, uint64_t a3, long long *a4)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  long long v9 = (void *)(v7 + 8 * (v6 / 0x66));
  if (v8 == v7) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = *v9 + 40 * (v6 % 0x66);
  }
  if (a3 == v10) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 102 * (a2 - v9)
  }
        - 0x3333333333333333 * ((a3 - *a2) >> 3)
        + 0x3333333333333333 * ((uint64_t)(v10 - *v9) >> 3);
  uint64_t v12 = a1[2].i64[1];
  unint64_t v13 = v12 - v11;
  if (v11 >= v12 - v11)
  {
    if (v8 == v7) {
      uint64_t v24 = 0;
    }
    else {
      uint64_t v24 = 102 * ((v8 - v7) >> 3) - 1;
    }
    if (v24 == v12 + v6)
    {
      sub_100FC6070(a1);
      uint64_t v12 = a1[2].i64[1];
      unint64_t v13 = v12 - v11;
    }
    if (v12 == v11)
    {
      unint64_t v25 = *(void *)(a1->i64[1] + 8 * ((a1[2].i64[0] + v11) / 0x66)) + 40 * ((a1[2].i64[0] + v11) % 0x66);
      long long v26 = *a4;
      *(void *)(v25 + 16) = *((void *)a4 + 2);
      *(_OWORD *)unint64_t v25 = v26;
      *((void *)a4 + 1) = 0;
      *((void *)a4 + 2) = 0;
      *(void *)a4 = 0;
      *(_OWORD *)(v25 + 24) = *(long long *)((char *)a4 + 24);
      ++a1[2].i64[1];
    }
    else
    {
      unint64_t v27 = a1[2].i64[0] + v12;
      uint64_t v28 = a1->i64[1];
      char v29 = (uint64_t *)(v28 + 8 * (v27 / 0x66));
      uint64_t v30 = *v29;
      unint64_t v31 = *v29 + 40 * (v27 % 0x66);
      if (a1[1].i64[0] == v28) {
        uint64_t v32 = 0;
      }
      else {
        uint64_t v32 = v31;
      }
      unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * ((v32 - v30) >> 3);
      if (v32 - v30 < 41)
      {
        unint64_t v45 = 102 - v33;
        long long v35 = &v29[-(v45 / 0x66)];
        uint64_t v36 = *v35 + 40 * (102 * (v45 / 0x66) - v45) + 4040;
      }
      else
      {
        unint64_t v34 = v33 - 1;
        long long v35 = &v29[v34 / 0x66];
        uint64_t v36 = *v35 + 40 * (v34 % 0x66);
      }
      long long v46 = *(_OWORD *)v36;
      *(void *)(v32 + 16) = *(void *)(v36 + 16);
      *(_OWORD *)uint64_t v32 = v46;
      *(void *)(v36 + 8) = 0;
      *(void *)(v36 + 16) = 0;
      *(void *)uint64_t v36 = 0;
      *(_OWORD *)(v32 + 24) = *(_OWORD *)(v36 + 24);
      ++a1[2].i64[1];
      if (v13 >= 2)
      {
        v57.n128_u64[0] = (unint64_t)v29;
        v57.n128_u64[1] = v32;
        sub_100176BF4(&v57, -(uint64_t)v13);
        sub_100FC6580((uint64_t *)v57.n128_u64[0], v57.n128_i64[1], v35, v36, v29, v32, &v57);
        char v29 = v58;
        uint64_t v32 = v59;
      }
      if (v32 == *v29) {
        uint64_t v32 = *(v29 - 1) + 4080;
      }
      uint64_t v47 = (void **)(v32 - 40);
      if (*(char *)(v32 - 17) < 0) {
        operator delete(*v47);
      }
      long long v48 = *a4;
      *(void *)(v32 - 24) = *((void *)a4 + 2);
      *(_OWORD *)uint64_t v47 = v48;
      *((unsigned char *)a4 + 23) = 0;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(v32 - 16) = *(long long *)((char *)a4 + 24);
    }
  }
  else
  {
    if (!v6) {
      sub_100FC5D54((void **)a1);
    }
    unint64_t v14 = a1[2].u64[0];
    uint64_t v15 = a1->i64[1];
    uint64_t v16 = a1[1].i64[0];
    uint64_t v17 = (uint64_t *)(v15 + 8 * (v14 / 0x66));
    uint64_t v18 = *v17;
    if (v11)
    {
      unint64_t v19 = v18 + 40 * (v14 % 0x66);
      if (v16 == v15) {
        unint64_t v20 = 0;
      }
      else {
        unint64_t v20 = v19;
      }
      uint64_t v21 = v20 - v18;
      unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v18) >> 3);
      if (v21 < 41) {
        unint64_t v23 = v17[-((102 - v22) / 0x66)] + 40 * (102 * ((102 - v22) / 0x66) - (102 - v22)) + 4040;
      }
      else {
        unint64_t v23 = v17[(v22 - 1) / 0x66] + 40 * ((v22 - 1) % 0x66);
      }
      long long v39 = *(_OWORD *)v20;
      *(void *)(v23 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)unint64_t v23 = v39;
      *(void *)(v20 + 8) = 0;
      *(void *)(v20 + 16) = 0;
      *(void *)unint64_t v20 = 0;
      *(_OWORD *)(v23 + 24) = *(_OWORD *)(v20 + 24);
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_101D1F270);
      if (v11 != 1)
      {
        uint64_t v40 = v20 - *v17;
        unint64_t v41 = 0xCCCCCCCCCCCCCCCDLL * (v40 >> 3);
        if (v40 < -39)
        {
          unint64_t v49 = 100 - v41;
          uint64_t v43 = (long long **)&v17[-(v49 / 0x66)];
          uint64_t v44 = (long long *)((char *)*v43 + 40 * (102 * (v49 / 0x66) - v49) + 4040);
        }
        else
        {
          unint64_t v42 = v41 + 1;
          uint64_t v43 = (long long **)&v17[v42 / 0x66];
          uint64_t v44 = (long long *)((char *)*v43 + 40 * (v42 % 0x66));
        }
        v57.n128_u64[0] = (unint64_t)v17;
        v57.n128_u64[1] = v20;
        sub_100176BF4(&v57, v11);
        __n128 v50 = v57;
        v57.n128_u64[0] = (unint64_t)v17;
        v57.n128_u64[1] = v20;
        sub_100FC6388(v43, v44, (long long **)v50.n128_u64[0], (long long *)v50.n128_u64[1], (uint64_t)&v57);
        unint64_t v20 = v57.n128_u64[1];
      }
      if (*(char *)(v20 + 23) < 0) {
        operator delete(*(void **)v20);
      }
      long long v51 = *a4;
      *(void *)(v20 + 16) = *((void *)a4 + 2);
      *(_OWORD *)unint64_t v20 = v51;
      *((unsigned char *)a4 + 23) = 0;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(v20 + 24) = *(long long *)((char *)a4 + 24);
    }
    else
    {
      uint64_t v37 = v18 + 40 * (v14 % 0x66);
      if (v16 == v15) {
        uint64_t v37 = 0;
      }
      if (v37 == v18) {
        uint64_t v37 = *(v17 - 1) + 4080;
      }
      long long v38 = *a4;
      *(void *)(v37 - 24) = *((void *)a4 + 2);
      *(_OWORD *)(v37 - 4sub_100FB8FC8(&a9, 0) = v38;
      *((void *)a4 + 1) = 0;
      *((void *)a4 + 2) = 0;
      *(void *)a4 = 0;
      *(_OWORD *)(v37 - 16) = *(long long *)((char *)a4 + 24);
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_101D1F270);
    }
  }
  unint64_t v52 = a1[2].u64[0];
  uint64_t v53 = a1->i64[1];
  long long v54 = (void *)(v53 + 8 * (v52 / 0x66));
  if (a1[1].i64[0] == v53) {
    unint64_t v55 = 0;
  }
  else {
    unint64_t v55 = *v54 + 40 * (v52 % 0x66);
  }
  v57.n128_u64[0] = (unint64_t)v54;
  v57.n128_u64[1] = v55;
  sub_100176BF4(&v57, v11);
  return v57.n128_u64[0];
}

void sub_100FC5D54(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 102 * v4 - 1;
  }
  unint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x66)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    long long v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      long long v46 = a1 + 3;
      std::string __p = sub_1000DA54C(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      unint64_t v45 = (char *)__p + 8 * v12;
      unint64_t v41 = operator new(0xFF0uLL);
      sub_1000DA434(&__p, &v41);
      unint64_t v13 = (char *)a1[1];
      unint64_t v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000DA54C((uint64_t)v46, v23);
              long long v26 = v43;
              unint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                unint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                char v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)char v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              unint64_t v31 = __p;
              std::string __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              unint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                unint64_t v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              unint64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                unint64_t v14 = v43;
              }
              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              unint64_t v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)unint64_t v14 = v32;
          unint64_t v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      uint64_t v43 = v33;
      long long v38 = (char *)a1[3];
      long long v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      unint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 51;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 102;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0xFF0uLL);
        sub_10017F0B4(a1, &__p);
        unint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        std::string __p = operator new(0xFF0uLL);
      }
      sub_1002D02D8((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 51;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 102;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 102;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1002D02D8((uint64_t)a1, &__p);
  }
}

void sub_100FC6024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FC6070(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      long long v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFF0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFF0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      long long v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        long long v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)long long v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFF0uLL);
  sub_1000DA434(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC633C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

double sub_100FC6388(long long **a1, long long *a2, long long **a3, long long *a4, uint64_t a5)
{
  uint64_t v7 = *(uint64_t **)a5;
  uint64_t v8 = *(void *)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (uint64_t i = *a1 + 255; ; uint64_t i = v12 + 255)
    {
      sub_100FC641C(a2, i, v7, v8, &v14);
      uint64_t v8 = *((void *)&v15 + 1);
      uint64_t v7 = (uint64_t *)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      uint64_t v12 = *v10++;
      a2 = v12;
    }
    a2 = *a3;
  }
  sub_100FC641C(a2, a4, v7, v8, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void sub_100FC641C(long long *a1@<X1>, long long *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, long long **a5@<X8>)
{
  uint64_t v5 = a3;
  unint64_t v6 = a1;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = a2;
    uint64_t v5 = a3 + 1;
    uint64_t v9 = *a3;
    while (1)
    {
      int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v9 - a4 + 4080) >> 3);
      if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((char *)v8 - (char *)v6) >> 3)) < v10) {
        int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v8 - (char *)v6) >> 3);
      }
      uint64_t v11 = sub_100FC64FC((uint64_t)&v14, v6, (long long *)((char *)v6 + 40 * v10), a4);
      if (v11 == v8) {
        break;
      }
      unint64_t v6 = v11;
      uint64_t v13 = *v5++;
      uint64_t v9 = v13;
      a4 = v13;
    }
    a4 = v12;
    if (*(v5 - 1) + 4080 == v12) {
      a4 = *v5;
    }
    else {
      --v5;
    }
  }
  *a5 = v8;
  a5[1] = (long long *)v5;
  a5[2] = (long long *)a4;
}

long long *sub_100FC64FC(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if (*(char *)(a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      long long v7 = *v5;
      *(void *)(a4 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a4 = v7;
      *((unsigned char *)v5 + 23) = 0;
      *(unsigned char *)uint64_t v5 = 0;
      *(_OWORD *)(a4 + 24) = *(long long *)((char *)v5 + 24);
      a4 += 40;
      uint64_t v5 = (long long *)((char *)v5 + 40);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

__n128 sub_100FC6580@<Q0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X5>, uint64_t a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    long long v15 = a5;
    uint64_t v16 = a6;
  }
  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v14 = a4;
    long long v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_100FC6650(v12, v14, v15, v16, &v21);
      uint64_t v16 = v22.n128_i64[1];
      long long v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 4080;
    }
    uint64_t v18 = *a1 + 4080;
    uint64_t v19 = a2;
  }
  sub_100FC6650(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = a4;
  a7[1] = result;
  return result;
}

uint64_t sub_100FC6650@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a3;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a3;
    while (1)
    {
      int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((a4 - v9) >> 3);
      if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3)) < v10) {
        int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
      }
      uint64_t v11 = a2 - 40 * v10;
      uint64_t result = sub_100FC672C((uint64_t)&v16, v11, a2, a4);
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v5;
      uint64_t v9 = v14;
      a4 = v14 + 4080;
      a2 = v11;
    }
    a4 = v13;
    if (*v5 + 4080 == v13)
    {
      uint64_t v15 = v5[1];
      ++v5;
      a4 = v15;
    }
  }
  *a5 = v8;
  a5[1] = (uint64_t)v5;
  a5[2] = a4;
  return result;
}

uint64_t sub_100FC672C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (void **)(a4 + v7 - 40);
      if (*(char *)(a4 + v7 - 17) < 0) {
        operator delete(*v8);
      }
      uint64_t v9 = (long long *)(a3 + v7 - 40);
      long long v10 = *v9;
      *(void *)(a4 + v7 - 24) = *(void *)(a3 + v7 - 24);
      *(_OWORD *)uint64_t v8 = v10;
      *(unsigned char *)(a3 + v7 - 17) = 0;
      *(unsigned char *)uint64_t v9 = 0;
      *(_OWORD *)(a4 + v7 - 16) = *(_OWORD *)(a3 + v7 - 16);
      v7 -= 40;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

void sub_100FC67CC(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 73 * v4 - 1;
  }
  unint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x49)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::string __p = sub_1000DA54C(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      unint64_t v41 = operator new(0xFF8uLL);
      sub_1000DA434(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000DA54C((uint64_t)v46, v23);
              uint64_t v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                char v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)char v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              long long v31 = __p;
              std::string __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }
              __n128 v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      uint64_t v43 = v33;
      long long v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 36;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 73;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0xFF8uLL);
        sub_10017F0B4(a1, &__p);
        unint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        std::string __p = operator new(0xFF8uLL);
      }
      sub_1002D02D8((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 36;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 73;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 73;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1002D02D8((uint64_t)a1, &__p);
  }
}

void sub_100FC6A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FC6AE8(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  if (v1)
  {
    sub_10041F48C(v1 + 22);
    sub_100FC1340(v1 + 12);
    sub_1002CDF4C(v1 + 6);
    sub_100FC14A0(v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100FC6B58(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    uint64_t v5 = 0;
    uint64_t v8 = 0;
    uint64_t v7 = (void *)(v4
                  + (((unint64_t)(((a2[5] + v3) * (unsigned __int128)0x70381C0E070381C1uLL) >> 64) >> 2) & 0x1FFFFFFFFFFFFFF8));
  }
  else
  {
    uint64_t v5 = (void *)(*(void *)(v4 + 8 * (v3 / 0x49)) + 56 * (v3 % 0x49));
    unint64_t v6 = a2[5] + v3;
    uint64_t v7 = (void *)(v4 + 8 * (v6 / 0x49));
    uint64_t v8 = (void *)(*v7 + 56 * (v6 % 0x49));
  }
  sub_100FC6C2C((void *)a1, (void *)(v4 + 8 * (v3 / 0x49)), v5, v7, v8);
  return a1;
}

void sub_100FC6C18(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC6C2C(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 73 * (a4 - a2)
  }
       + 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a5 - *a4) >> 3)
       - 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a3 - *a2) >> 3);
  return sub_100FC6C90(a1, a2, a3, v5);
}

uint64_t sub_100FC6C90(void *a1, void *a2, void *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 73 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC6E50(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  uint64_t v13 = (void *)(v8 + 8 * (v11 / 0x49));
  if (v9 == v8) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *v13 + 56 * (v11 % 0x49);
  }
  __n128 v22 = (void *)(v8 + 8 * (v11 / 0x49));
  unint64_t v23 = v14;
  uint64_t result = (uint64_t)sub_10080DF84(&v22, a4);
  uint64_t v16 = v23;
  if (v14 != v23)
  {
    BOOL v17 = v22;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4088;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = 0;
        do
        {
          uint64_t result = sub_100FC7408(v14 + v19, a3);
          *(void *)(result + 48) = a3[6];
          a3 += 7;
          if ((void *)((char *)a3 - *a2) == (void *)4088)
          {
            int64_t v20 = (void *)a2[1];
            ++a2;
            a3 = v20;
          }
          v19 += 56;
        }
        while (v14 + v19 != v18);
      }
      a1[5] += 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v21 = v13[1];
      ++v13;
      unint64_t v14 = v21;
    }
    while (v21 != v16);
  }
  return result;
}

void sub_100FC6E2C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) += 0x6DB6DB6DB6DB6DB7 * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100FC6E50(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x49) {
    unint64_t v6 = v5 / 0x49 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x49;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x49) {
    unint64_t v8 = v7 / 0x49;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x49)
  {
    for (a1[4] = v7 - 73 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF8uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0xFF8uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 72;
          }
          else {
            uint64_t v64 = 73;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - 73 * v8;
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0;
      }
      uint64_t v38 = -73 * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFF8uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              long long v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC7394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC7408(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 7));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 7));
  }
  else
  {
    unint64_t v8 = (long long *)(*(void *)v7 + 32 * (v4 & 0x7F));
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 7));
    uint64_t v11 = (long long *)(*(void *)v10 + 32 * (v9 & 0x7F));
  }
  sub_100FC74B4((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC74A0(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC74B4(void *a1, char *a2, long long *a3, char *a4, long long *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 5) + 16 * (a4 - a2) - (((uint64_t)a3 - *(void *)a2) >> 5);
  }
  return sub_100FC74E8(a1, a2, a3, v5);
}

void *sub_100FC74E8(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 16 * (v9 - v8) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC761C(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 7));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 32 * (v11 & 0x7F);
  }
  v23[0] = v8 + 8 * (v11 >> 7);
  v23[1] = v14;
  uint64_t result = sub_1001732B8((uint64_t)v23, a4);
  while (v14 != v16)
  {
    BOOL v17 = (_OWORD *)(v13 == result ? v16 : *v13 + 4096);
    if ((_OWORD *)v14 == v17)
    {
      BOOL v17 = (_OWORD *)v14;
    }
    else
    {
      uint64_t v18 = (_OWORD *)v14;
      do
      {
        long long v19 = *a3;
        long long v20 = a3[1];
        a3 += 2;
        *uint64_t v18 = v19;
        v18[1] = v20;
        if ((long long *)((char *)a3 - *a2) == (long long *)4096)
        {
          uint64_t v21 = (long long *)a2[1];
          ++a2;
          a3 = v21;
        }
        v18 += 2;
      }
      while (v18 != v17);
    }
    a1[5] += ((uint64_t)v17 - v14) >> 5;
    if (v13 == result) {
      break;
    }
    uint64_t v22 = v13[1];
    ++v13;
    uint64_t v14 = v22;
  }
  return result;
}

void sub_100FC761C(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x7F) != 0) {
    unint64_t v6 = (v5 >> 7) + 1;
  }
  else {
    unint64_t v6 = v5 >> 7;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 7) {
    unint64_t v8 = v7 >> 7;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 7)
  {
    for (a1[4] = v7 - (v8 << 7); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 127;
          }
          else {
            uint64_t v64 = 128;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 7);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0;
      }
      uint64_t v38 = v8 << 7;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              long long v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC7B34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC7BA8(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    unint64_t v5 = 0;
    unint64_t v8 = 0;
    unint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x66));
  }
  else
  {
    unint64_t v5 = (long long *)(*(void *)(v4 + 8 * (v3 / 0x66)) + 40 * (v3 % 0x66));
    unint64_t v6 = a2[5] + v3;
    unint64_t v7 = (void *)(v4 + 8 * (v6 / 0x66));
    unint64_t v8 = (long long *)(*v7 + 40 * (v6 % 0x66));
  }
  sub_100FC7C78((void *)a1, (void *)(v4 + 8 * (v3 / 0x66)), v5, v7, v8);
  return a1;
}

void sub_100FC7C64(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC7C78(void *a1, void *a2, long long *a3, void *a4, long long *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 102 * (a4 - a2)
  }
       - 0x3333333333333333 * (((uint64_t)a5 - *a4) >> 3)
       + 0x3333333333333333 * (((uint64_t)a3 - *a2) >> 3);
  return sub_100FC7CC8(a1, a2, a3, v5);
}

void *sub_100FC7CC8(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 102 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC7E98(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 / 0x66));
  if (v9 == v8) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *v13 + 40 * (v11 % 0x66);
  }
  uint64_t v23 = (void *)(v8 + 8 * (v11 / 0x66));
  unint64_t v24 = v14;
  uint64_t result = sub_100176BF4(&v23, a4);
  uint64_t v16 = v24;
  if (v14 != v24)
  {
    BOOL v17 = v23;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4080;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = 0;
        do
        {
          uint64_t result = (void *)(v14 + v19);
          if (*((char *)a3 + 23) < 0)
          {
            uint64_t result = sub_1000DC48C(result, *(void **)a3, *((void *)a3 + 1));
          }
          else
          {
            long long v20 = *a3;
            result[2] = *((void *)a3 + 2);
            *(_OWORD *)uint64_t result = v20;
          }
          *(_OWORD *)(v14 + v19 + 24) = *(long long *)((char *)a3 + 24);
          a3 = (long long *)((char *)a3 + 40);
          if ((long long *)((char *)a3 - *a2) == (long long *)4080)
          {
            uint64_t v21 = (long long *)a2[1];
            ++a2;
            a3 = v21;
          }
          v19 += 40;
        }
        while (v14 + v19 != v18);
      }
      a1[5] -= 0x3333333333333333 * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v22 = v13[1];
      ++v13;
      unint64_t v14 = v22;
    }
    while (v22 != v16);
  }
  return result;
}

void sub_100FC7E7C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x3333333333333333 * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100FC7E98(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x66) {
    unint64_t v6 = v5 / 0x66 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x66;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x66) {
    unint64_t v8 = v7 / 0x66;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x66)
  {
    for (a1[4] = v7 - 102 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF0uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0xFF0uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 101;
          }
          else {
            uint64_t v64 = 102;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - 102 * v8;
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0;
      }
      uint64_t v38 = -102 * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFF0uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              long long v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC83DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC8450(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  sub_100FC84FC((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC84E8(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC84FC(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100FC8530(a1, a2, a3, v5);
}

void *sub_100FC8530(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC8668(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_100B83A3C((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            BOOL v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }
        while (v20 != (void *)v18);
      }
      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }
    while (v23 != v16);
    a1[5] = v17;
  }
  return result;
}

void sub_100FC8668(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              long long v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC8B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC8BF4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        long long v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)long long v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  NSFileAttributeKey v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  char v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FC8EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100FC8F0C(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100FC8F40(a1, a2, a3, v5);
}

void *sub_100FC8F40(void *a1, char **a2, char *a3, unint64_t a4)
{
  int64_t v20 = a2;
  uint64_t v21 = a3;
  unint64_t v7 = a1[5];
  if (v7 >= a4)
  {
    uint64_t v14 = a1[1];
    uint64_t v15 = (char *)(v14 + 8 * (a1[4] >> 9));
    if (a1[2] == v14) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = *(void *)v15 + 8 * (a1[4] & 0x1FFLL);
    }
    v22[0] = a2;
    v22[1] = a3;
    uint64_t v18 = (char **)sub_100B83A3C((uint64_t)v22, a4);
    uint64_t v23 = v15;
    uint64_t v24 = v16;
    sub_100FC929C(a2, a3, v18, v19, (uint64_t)&v23);
    return (void *)sub_100FC91A0((uint64_t)a1, v23, v24);
  }
  else
  {
    unint64_t v9 = (char **)sub_100B83A3C((uint64_t)&v20, v7);
    uint64_t v10 = v8;
    uint64_t v11 = a1[1];
    if (a1[2] == v11) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = *(void *)(v11 + 8 * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
    }
    uint64_t v23 = (char *)(v11 + 8 * (a1[4] >> 9));
    uint64_t v24 = v12;
    sub_100FC929C(v20, v21, v9, v8, (uint64_t)&v23);
    return sub_100FC9068(a1, v9, v10, a4 - a1[5]);
  }
}

void *sub_100FC9068(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100FC942C(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  uint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_100B83A3C((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = *a2;
        int64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            unint64_t v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }
        while (v20 != (void *)v18);
      }
      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }
    while (v23 != v16);
    a1[5] = v17;
  }
  return result;
}

uint64_t sub_100FC91A0(uint64_t result, char *a2, uint64_t a3)
{
  BOOL v3 = (void *)result;
  unint64_t v4 = *(void *)(result + 32);
  unint64_t v5 = v4 + *(void *)(result + 40);
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v8 = (char *)(v6 + 8 * (v5 >> 9));
  if (v7 == v6) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)v8 + 8 * (v5 & 0x1FF);
  }
  if (v9 != a3)
  {
    uint64_t v10 = ((v9 - *(void *)v8) >> 3) + ((v8 - a2) << 6);
    uint64_t v11 = a3 - *(void *)a2;
    uint64_t v12 = v10 - (v11 >> 3);
    if (v12 >= 1)
    {
      uint64_t v13 = (char *)(v6 + 8 * (v4 >> 9));
      if (v7 == v6) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = *(void *)v13 + 8 * (*(void *)(result + 32) & 0x1FFLL);
      }
      v16[0] = v13;
      v16[1] = v14;
      if (v14 == a3) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = (v11 >> 3) + ((a2 - v13) << 6) - ((v14 - *(void *)v13) >> 3);
      }
      sub_100B83A3C((uint64_t)v16, v15);
      v3[5] -= v12;
      do
        uint64_t result = sub_100B849F0(v3, 1);
      while ((result & 1) != 0);
    }
  }
  return result;
}

double sub_100FC929C(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }
  else
  {
    uint64_t v8 = a1 + 1;
    sub_100FC936C(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      sub_100FC936C(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }
  sub_100FC936C(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_100FC936C@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  uint64_t v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    uint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      long long __dst = v13;
    }
    __dst += 8 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst) {
      long long __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

void sub_100FC942C(void *a1, unint64_t a2)
{
  BOOL v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          char v29 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          long long v32 = (uint64_t *)a1[1];
          BOOL v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            BOOL v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            BOOL v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            BOOL v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          BOOL v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)BOOL v3 = v18;
      BOOL v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10017F0B4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002D02D8((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          long long v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        long long v15 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v13);
      }
      else {
        long long v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000DA434(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000DA54C((uint64_t)v91, v48);
              long long v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              NSFileAttributeKey v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002D03F8((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100FC9944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC99B8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    sub_10041F48C((void *)(v1 + 48));
    operator delete();
  }
  return result;
}

uint64_t sub_100FC9A14(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  sub_100FC9AC0((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100FC9AAC(_Unwind_Exception *a1)
{
  sub_1000D7EB4(v1);
  _Unwind_Resume(a1);
}

void *sub_100FC9AC0(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100FC9068(a1, a2, a3, v5);
}

uint64_t sub_100FC9AF4(uint64_t a1)
{
  *(void *)a1 = &off_102308AB8;
  unint64_t v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  id *v2 = 0;
  *(void *)(a1 + 16) = 0;
  return a1;
}

id sub_100FC9B64(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return sub_100FC9BC4(a1);
}

id sub_100FC9BC4(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (v2)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102308AD0);
      }
      uint64_t v3 = qword_102418F98;
      if (!os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      int v8 = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0;
      __int16 v12 = 2080;
      unint64_t v13 = 0x8000000101D9AFF9 & 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v4 = v3;
      os_log_type_t v5 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102308AD0);
      }
      uint64_t v7 = qword_102418F98;
      if (!os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
      int v8 = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0;
      __int16 v12 = 2080;
      unint64_t v13 = 0x8000000101D9AFF9 & 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v4 = v7;
      os_log_type_t v5 = OS_LOG_TYPE_FAULT;
    }
    _os_log_impl((void *)&_mh_execute_header, v4, v5, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", (uint8_t *)&v8, 0x20u);
    return 0;
  }

  return [a1 cppObjectPtr];
}

void sub_100FC9DAC(id a1)
{
  qword_102418F98 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

void sub_100FC9DDC()
{
}

void sub_100FC9E94()
{
}

unsigned char *sub_100FC9EB8(unsigned char *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32);
    id v9 = sub_100FCA414(a4);
    uint64_t v10 = *(void *)a3 + 80;
    uint64_t v11 = (uint64_t **)(*(void *)a3 + 40);
    unint64_t v14 = (int *)(*(void *)a2 + 32);
    __int16 v12 = sub_1000EAEE4(v11, v14, (uint64_t)&unk_101D0B290, &v14);
    double result = (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192))(v7, v8, &v13, v9, v10, v12 + 5);
    if (result) {
      return [*(id *)(*(void *)a2 + 64) onNotification:*(unsigned int *)(*(void *)a3 + 32) withData:a4 v13];
    }
  }
  return result;
}

uint64_t sub_100FC9FB0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    sub_1002A50D0(v1 + 8, *(void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100FCA010(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100FCA068(a1, *(long long **)a2, (long long *)(a2 + 8));
  return a1;
}

void sub_100FCA050(_Unwind_Exception *a1)
{
  sub_1002A50D0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100FCA068(uint64_t *result, long long *a2, long long *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    os_log_type_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      double result = sub_100FCA0F0(v5, v6, v4 + 2);
      uint64_t v7 = (long long *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(long long **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (long long *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }
        while (!v9);
      }
      unint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100FCA0F0(uint64_t **a1, uint64_t a2, long long *a3)
{
  sub_100FCA180((uint64_t)a1, a3, (uint64_t)v9);
  os_log_type_t v5 = (uint64_t **)sub_100FCA1EC(a1, a2, &v8, (const void **)v9[0] + 4);
  sub_1000EDF90(a1, v8, v5, v9[0]);
  uint64_t v6 = v9[0];
  v9[0] = 0;
  sub_1002A53D4((uint64_t)v9, 0);
  return v6;
}

void sub_100FCA168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002A53D4((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_100FCA180@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0xE0uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  double result = sub_100FCA31C(v6 + 4, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_100FCA1D4(_Unwind_Exception *a1)
{
  sub_1002A53D4(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_100FCA1EC(void *a1, uint64_t a2, void *a3, const void **a4)
{
  uint64_t v6 = (void *)a2;
  if (a1 + 1 != (void *)a2 && sub_100130070((uint64_t)(a1 + 2), (const void **)(a2 + 32), a4))
  {
    return sub_100FCA394((uint64_t)a1, a3, a4);
  }
  if ((void *)*a1 == v6)
  {
    uint64_t v10 = v6;
LABEL_17:
    if (*v6)
    {
      *a3 = v10;
      return v10 + 1;
    }
    else
    {
      *a3 = v6;
    }
    return v6;
  }
  BOOL v9 = (void *)*v6;
  if (*v6)
  {
    do
    {
      uint64_t v10 = v9;
      BOOL v9 = (void *)v9[1];
    }
    while (v9);
  }
  else
  {
    uint64_t v11 = v6;
    do
    {
      uint64_t v10 = (void *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      uint64_t v11 = v10;
    }
    while (v12);
  }
  if (!sub_100130070((uint64_t)(a1 + 2), a4, (const void **)v10 + 4)) {
    goto LABEL_17;
  }

  return sub_1002A5268((uint64_t)a1, a3, a4);
}

void *sub_100FCA31C(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_1002A4F7C((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100FCA378(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100FCA394(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v5 = (void *)v4;
        if (sub_100130070(v7, (const void **)(v4 + 32), a3)) {
          break;
        }
        uint64_t v4 = *v5;
        double result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }
      uint64_t v4 = v5[1];
    }
    while (v4);
    double result = v5 + 1;
  }
  else
  {
    double result = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

id sub_100FCA414(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return sub_100FCA474(a1);
}

id sub_100FCA474(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (v2)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102308AD0);
      }
      uint64_t v3 = qword_102418F98;
      if (!os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      int v8 = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0;
      __int16 v12 = 2080;
      unint64_t v13 = 0x8000000101D9B022 & 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v4 = v3;
      os_log_type_t v5 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (qword_102418F90 != -1) {
        dispatch_once(&qword_102418F90, &stru_102308AD0);
      }
      uint64_t v7 = qword_102418F98;
      if (!os_log_type_enabled((os_log_t)qword_102418F98, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
      int v8 = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0;
      __int16 v12 = 2080;
      unint64_t v13 = 0x8000000101D9B022 & 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v4 = v7;
      os_log_type_t v5 = OS_LOG_TYPE_FAULT;
    }
    _os_log_impl((void *)&_mh_execute_header, v4, v5, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", (uint8_t *)&v8, 0x20u);
    return 0;
  }

  return [a1 cppObjectPtr];
}

uint64_t **sub_100FCA65C(uint64_t **result, long long *a2, long long *a3)
{
  os_log_type_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *double result = (uint64_t *)(result + 1);
    _DWORD v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    long long v15 = result;
    uint64_t v16 = v8;
    uint64_t v17 = (const void **)v8;
    if (v8)
    {
      uint64_t v16 = sub_1002FABD8((uint64_t)v8);
      if (a2 != a3)
      {
        id v9 = a2;
        do
        {
          v18[0] = (uint64_t)(v8 + 4);
          v18[1] = (uint64_t)(v8 + 7);
          sub_100FCA7EC((uint64_t)v18, (uint64_t)(v9 + 2));
          __int16 v10 = (uint64_t **)sub_1002A5268((uint64_t)v5, v18, v17 + 4);
          sub_1000EDF90(v5, v18[0], v10, (uint64_t *)v17);
          uint64_t v17 = (const void **)v16;
          if (v16) {
            uint64_t v16 = sub_1002FABD8((uint64_t)v16);
          }
          uint64_t v11 = (long long *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              uint64_t v11 = *(long long **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (long long *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              id v9 = a2;
            }
            while (!v12);
          }
          int v8 = (uint64_t *)v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          id v9 = a2;
        }
        while (!v12);
      }
    }
    double result = (uint64_t **)sub_100FCAC44((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      double result = (uint64_t **)sub_100FCAC9C(v5, a2 + 2);
      unint64_t v13 = (long long *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          unint64_t v14 = v13;
          unint64_t v13 = *(long long **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          unint64_t v14 = (long long *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_100FCA7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100FCAC44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FCA7EC(uint64_t a1, uint64_t a2)
{
  std::string::operator=(*(std::string **)a1, (const std::string *)a2);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2 + 24) {
    sub_100FCA894(*(char **)(a1 + 8), *(char **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 33) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(v4 + 24) = v5;
  sub_1000D87AC((std::string *)(v4 + 56), (const std::string *)(a2 + 80));
  sub_100FCA9A8(v4 + 88, a2 + 112);
  *(_DWORD *)(v4 + 136) = *(_DWORD *)(a2 + 160);
  if (v4 != a2 + 24) {
    sub_1000FB43C((char *)(v4 + 144), *(char **)(a2 + 168), *(void *)(a2 + 176), (uint64_t)(*(void *)(a2 + 176) - *(void *)(a2 + 168)) >> 2);
  }
  return a1;
}

char *sub_100FCA894(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  id v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 5)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 >> 59) {
      sub_1001D7FD4();
    }
    uint64_t v10 = v8 >> 4;
    if (v8 >> 4 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = sub_100222834(v7, v11);
    unint64_t v13 = (char *)v7[1];
    BOOL v12 = (void **)(v7 + 1);
    id v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      uint64_t v19 = v9;
      uint64_t v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  BOOL v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 5;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[32 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9 - 4);
    id v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    uint64_t v19 = v9;
    uint64_t v20 = v16;
LABEL_18:
    double result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *BOOL v12 = &v9[v17];
  return result;
}

void sub_100FCA9A8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 40) == *(unsigned __int8 *)(a2 + 40))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 40))
    {
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
      id v2 = *(uint64_t **)(a2 + 16);
      sub_100FCAA1C((void *)a1, v2, 0);
    }
  }
  else if (*(unsigned char *)(a1 + 40))
  {
    *(unsigned char *)(sub_1002220F0(a1) + 4sub_100FB8FC8(&a9, 0) = 0;
  }
  else
  {
    *(unsigned char *)(sub_100222178(a1, a2) + 4sub_100FB8FC8(&a9, 0) = 1;
  }
}

void sub_100FCAA1C(void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = a1[1];
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*a1 + 8 * i) = 0;
    uint64_t v8 = (void **)a1[2];
    a1[2] = 0;
    a1[3] = 0;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      uint64_t v10 = v8;
    }
    else
    {
      do
      {
        std::string::operator=((std::string *)(v8 + 2), (const std::string *)(v4 + 2));
        *(_OWORD *)(v8 + 5) = *(_OWORD *)(v4 + 5);
        uint64_t v10 = (void **)*v8;
        sub_100ABBB80(a1, v8);
        uint64_t v4 = (uint64_t *)*v4;
        if (v10) {
          BOOL v11 = v4 == a3;
        }
        else {
          BOOL v11 = 1;
        }
        uint64_t v8 = v10;
      }
      while (!v11);
    }
    sub_10022212C((int)a1, v10);
  }
  while (v4 != a3)
  {
    sub_100FCAB20(a1, (uint64_t)(v4 + 2));
    uint64_t v4 = (uint64_t *)*v4;
  }
}

void sub_100FCAAF0(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10022212C(v1, v2);
  __cxa_rethrow();
}

void sub_100FCAB0C(_Unwind_Exception *a1)
{
}

void *sub_100FCAB20(void *a1, uint64_t a2)
{
  sub_100FCAB80((uint64_t)a1, a2, (uint64_t)&v4);
  return sub_100ABBB80(a1, v4);
}

void sub_100FCAB5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_10022251C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100FCAB80@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a1 + 16;
  uint64_t v7 = (char *)operator new(0x38uLL);
  uint64_t v8 = v7;
  *(void *)(a3 + 8) = v6;
  *(void *)a3 = v7;
  *(unsigned char *)(a3 + 16) = 0;
  BOOL v9 = v7 + 16;
  *(void *)uint64_t v7 = 0;
  *((void *)v7 + 1) = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1000DC48C(v7 + 16, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    _OWORD *v9 = *(_OWORD *)a2;
    *((void *)v7 + 4) = *(void *)(a2 + 16);
  }
  *(_OWORD *)(v8 + 4sub_100FB8FC8(&a9, 0) = *(_OWORD *)(a2 + 24);
  *(unsigned char *)(a3 + 16) = 1;
  unint64_t result = sub_100103388(a1 + 24, (uint64_t)v9);
  *((void *)v8 + 1) = result;
  return result;
}

void sub_100FCAC28(_Unwind_Exception *a1)
{
  void *v2 = 0;
  sub_10022251C(v3, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FCAC44(uint64_t a1)
{
  sub_1002A50D0(*(void *)a1, *(void **)(a1 + 16));
  id v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        id v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1002A50D0(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *sub_100FCAC9C(uint64_t **a1, long long *a2)
{
  sub_100FCA180((uint64_t)a1, a2, (uint64_t)v7);
  uint64_t v3 = (uint64_t **)sub_1002A5268((uint64_t)a1, &v6, (const void **)v7[0] + 4);
  sub_1000EDF90(a1, v6, v3, v7[0]);
  uint64_t v4 = v7[0];
  v7[0] = 0;
  sub_1002A53D4((uint64_t)v7, 0);
  return v4;
}

void *sub_100FCAD08@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x38uLL);
  unint64_t result = sub_100FCAD64(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100FCAD50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100FCAD64(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_102308B00;
  a1[3] = *a2;
  sub_100FCA010(a1 + 4, (uint64_t)(a2 + 1));
  return a1;
}

void sub_100FCADB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100FCADCC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_102308B00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCADEC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_102308B00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCAE40(uint64_t a1)
{
}

void sub_100FCAE54()
{
}

void sub_100FCAF0C()
{
}

void sub_100FCAF30(void *a1, int *a2, void *a3)
{
  if (!*((unsigned char *)a1 + 108))
  {
    long long v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      BOOL v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          BOOL v12 = (uint64_t *)v4;
        }
        else {
          BOOL v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          BOOL v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v49 = v9;
        id v13 = sub_100FCA414(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184))(a1, a2, v13, v9 + 10);
        unint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          unint64_t v15 = a1 + 11;
          uint64_t v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 8);
            uint64_t v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                BOOL v22 = (uint64_t *)v17;
              }
              else {
                BOOL v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              unint64_t v48 = v19;
              sub_100FC9EB8(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              char v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  long long v32 = (uint64_t *)v27;
                }
                else {
                  long long v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  char v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v49 = v29;
              uint64_t v34 = v29[6];
              unint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 32);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 8))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 32);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      unint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  uint64_t v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      unint64_t v14 = v43;
                      uint64_t v43 = (void *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      unint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              unint64_t v48 = a1 + 11;
              if (qword_102419580 != -1) {
                dispatch_once(&qword_102419580, &stru_102308358);
              }
              uint64_t v24 = qword_102419588;
              if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
              {
                unint64_t v25 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  unint64_t v25 = (void *)*v16;
                }
                int v26 = *((_DWORD *)v14 + 8);
                *(_DWORD *)uint64_t buf = 136446466;
                uint64_t v55 = v25;
                __int16 v56 = 1026;
                int v57 = v26;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_10013D1A0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419580 != -1) {
                  dispatch_once(&qword_102419580, &stru_102308358);
                }
                uint64_t v45 = a1 + 1;
                if (*((char *)a1 + 31) < 0) {
                  uint64_t v45 = (void *)*v16;
                }
                int v46 = *((_DWORD *)v14 + 8);
                int v50 = 136446466;
                long long v51 = v45;
                __int16 v52 = 1026;
                int v53 = v46;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 0, "void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]", "%s\n", v47);
                if (v47 != (char *)buf) {
                  free(v47);
                }
              }
            }
          }
          while (v14 != v49 + 6);
        }
      }
    }
  }
}

uint64_t sub_100FCB320(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_100FCB378((uint64_t *)(a1 + 8), a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a3 + 40);
  return a1;
}

uint64_t *sub_100FCB378(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10078A594(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100FCB3B8(_Unwind_Exception *a1)
{
  sub_10078A7B0(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100FCB3D0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    sub_1002A50D0(v1 + 8, *(void **)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100FCB430()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241ADF0, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_10241ADF0))
    {
      uint64_t v1 = 0x7FFFFFFF00000000;
      v0[2] = xmmword_101D9A510;
      v0[3] = unk_101D9A520;
      v0[4] = xmmword_101D9A530;
      v0[0] = xmmword_101D9A4F0;
      v0[1] = unk_101D9A500;
      sub_1003BFBA4((uint64_t)&unk_10241ADD8, (int *)v0, 11);
      __cxa_atexit((void (*)(void *))sub_1003BE998, &unk_10241ADD8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_10241ADF0);
    }
  }
}

void sub_100FCB510(_Unwind_Exception *a1)
{
}

uint64_t sub_100FCB528()
{
  sub_100134750(&qword_1024827C0, "MicroLocationNotifier");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1024827C0, (void *)&_mh_execute_header);
  sub_100134750(qword_1024827D8, "MicroLocation");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_1024827D8, (void *)&_mh_execute_header);
  sub_100134750(qword_1024827F0, "/System/Library/LocationBundles/MicroLocation.bundle");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1024827F0, (void *)&_mh_execute_header);
}

uint64_t sub_100FCB5E8()
{
  if (qword_10248AFD8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248AFD8 + 8))(qword_10248AFD8);
  }
  if (qword_10248AFE0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248AFE0 + 8))(qword_10248AFE0);
  }
  if (qword_10248AFE8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248AFE8 + 8))(qword_10248AFE8);
  }
  if (qword_10248AFF0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248AFF0 + 8))(qword_10248AFF0);
  }
  if (qword_10248AFF8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248AFF8 + 8))(qword_10248AFF8);
  }
  if (qword_10248B000) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B000 + 8))(qword_10248B000);
  }
  if (qword_10248B008) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B008 + 8))(qword_10248B008);
  }
  if (qword_10248B010) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B010 + 8))(qword_10248B010);
  }
  if (qword_10248B018) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B018 + 8))(qword_10248B018);
  }
  if (qword_10248B020) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B020 + 8))(qword_10248B020);
  }
  if (qword_10248B028) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B028 + 8))(qword_10248B028);
  }
  if (qword_10248B030) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B030 + 8))(qword_10248B030);
  }
  if (qword_10248B038) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B038 + 8))(qword_10248B038);
  }
  if (qword_10248B040) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B040 + 8))(qword_10248B040);
  }
  if (qword_10248B048) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B048 + 8))(qword_10248B048);
  }
  if (qword_10248B050) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B050 + 8))(qword_10248B050);
  }
  if (qword_10248B058) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B058 + 8))(qword_10248B058);
  }
  if (qword_10248B060) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B060 + 8))(qword_10248B060);
  }
  if (qword_10248B068) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B068 + 8))(qword_10248B068);
  }
  if (qword_10248B070) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B070 + 8))(qword_10248B070);
  }
  if (qword_10248B078) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B078 + 8))(qword_10248B078);
  }
  if (qword_10248B080) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B080 + 8))(qword_10248B080);
  }
  if (qword_10248B088) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B088 + 8))(qword_10248B088);
  }
  if (qword_10248B090) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B090 + 8))(qword_10248B090);
  }
  if (qword_10248B098) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B098 + 8))(qword_10248B098);
  }
  if (qword_10248B0A0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0A0 + 8))(qword_10248B0A0);
  }
  if (qword_10248B0A8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0A8 + 8))(qword_10248B0A8);
  }
  if (qword_10248B0B0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0B0 + 8))(qword_10248B0B0);
  }
  if (qword_10248B0B8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0B8 + 8))(qword_10248B0B8);
  }
  if (qword_10248B0C0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0C0 + 8))(qword_10248B0C0);
  }
  if (qword_10248B0C8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0C8 + 8))(qword_10248B0C8);
  }
  if (qword_10248B0D0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0D0 + 8))(qword_10248B0D0);
  }
  if (qword_10248B0D8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0D8 + 8))(qword_10248B0D8);
  }
  if (qword_10248B0E0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0E0 + 8))(qword_10248B0E0);
  }
  if (qword_10248B0E8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0E8 + 8))(qword_10248B0E8);
  }
  if (qword_10248B0F0) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0F0 + 8))(qword_10248B0F0);
  }
  if (qword_10248B0F8) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B0F8 + 8))(qword_10248B0F8);
  }
  if (qword_10248B100) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B100 + 8))(qword_10248B100);
  }
  if (qword_10248B108) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B108 + 8))(qword_10248B108);
  }
  if (qword_10248B110) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B110 + 8))(qword_10248B110);
  }
  if (qword_10248B118) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B118 + 8))(qword_10248B118);
  }
  if (qword_10248B120) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B120 + 8))(qword_10248B120);
  }
  if (qword_10248B128) {
    (*(void (**)(uint64_t))(*(void *)qword_10248B128 + 8))(qword_10248B128);
  }
  uint64_t result = qword_10248B130;
  if (qword_10248B130)
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)qword_10248B130 + 8);
    return v1();
  }
  return result;
}

void sub_100FCBE50(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_102482820 & 1) == 0)
  {
    byte_102482820 = 1;
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::VerifyVersion((wireless_diagnostics::google::protobuf::internal *)0x1E9808, 2005000, (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc", a4);
    sub_1007480C0(v4, v5, v6, v7);
    sub_1008C4C78(v8, v9, v10, v11);
    sub_100E18714(v12, v13, v14, v15);
    operator new();
  }
}

double sub_100FCCCA0(uint64_t a1)
{
  *(void *)a1 = off_102308B50;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 36sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 392) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 368) = 0;
  *(void *)(a1 + 396) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_DWORD *)(a1 + 388) = 0;
  *(void *)(a1 + 372) = 0;
  *(void *)(a1 + 38sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

void *sub_100FCCD48(void *result)
{
  *double result = off_102308BC8;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

double sub_100FCCD6C(uint64_t a1)
{
  *(void *)a1 = off_102308C40;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = 0u;
  *(void *)(a1 + 136) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_DWORD *)(a1 + 22sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  return result;
}

uint64_t sub_100FCCDCC(uint64_t result)
{
  *(void *)double result = off_102308DA8;
  *(void *)(result + 8) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

void *sub_100FCCDFC(void *result)
{
  *double result = off_102308E20;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0;
  return result;
}

uint64_t sub_100FCCE28(uint64_t result)
{
  *(void *)double result = &off_102308F10;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

double sub_100FCCE54(uint64_t a1)
{
  *(void *)a1 = off_102308F88;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

void *sub_100FCCE80(void *result)
{
  result[1] = 0;
  result[2] = 0;
  *double result = off_102309000;
  return result;
}

uint64_t sub_100FCCEA4(uint64_t result)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = off_102309168;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FCCED0(uint64_t result)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = off_1023091E0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

double sub_100FCCEFC(uint64_t a1)
{
  *(void *)a1 = off_102309258;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

double sub_100FCCF28(uint64_t a1)
{
  *(void *)a1 = off_1023092D0;
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 54) = 0u;
  return result;
}

double sub_100FCCF60(uint64_t a1)
{
  *(void *)a1 = off_102309348;
  *(void *)(a1 + 8) = 0;
  *(void *)&double result = 0x400000000;
  *(_OWORD *)(a1 + 16) = xmmword_101D9B0E0;
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

double sub_100FCCF90(uint64_t a1)
{
  *(void *)a1 = off_1023093C0;
  *(void *)(a1 + 8) = 0;
  *(void *)&double result = 4;
  *(void *)(a1 + 16) = 4;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

double sub_100FCCFC0(uint64_t a1)
{
  *(void *)a1 = off_102309438;
  *(void *)&double result = 15;
  *(void *)(a1 + 8) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

double sub_100FCCFF0(uint64_t a1)
{
  *(void *)a1 = off_1023094B0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

double sub_100FCD020(uint64_t a1)
{
  *(void *)a1 = off_102309528;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

uint64_t sub_100FCD04C(uint64_t result)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = off_1023095A0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FCD074(uint64_t result)
{
  *(void *)double result = off_102309618;
  *(unsigned char *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

void *sub_100FCD0A0(void *result)
{
  result[1] = 0;
  result[2] = 0;
  *double result = off_102309690;
  return result;
}

uint64_t sub_100FCD0C4(uint64_t result)
{
  *(void *)double result = off_102309708;
  *(_WORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FCD0EC(uint64_t result)
{
  *(void *)double result = off_102309780;
  *(unsigned char *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void *sub_100FCD114(void *result)
{
  *double result = off_102309870;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0;
  return result;
}

double sub_100FCD140(uint64_t a1)
{
  *(void *)a1 = off_102309CA8;
  *(unsigned char *)(a1 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  return result;
}

double sub_100FCD174(uint64_t a1)
{
  *(void *)a1 = &off_102309AC8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  return result;
}

double sub_100FCD1A4(uint64_t a1)
{
  *(void *)a1 = &off_102309B40;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

void *sub_100FCD1D0(void *result)
{
  result[1] = 0;
  result[2] = 0;
  *double result = off_102309BB8;
  return result;
}

uint64_t sub_100FCD1F4(uint64_t result)
{
  *(void *)double result = off_102309C30;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 32) = 0;
  *(void *)(result + 36) = 0;
  *(void *)(result + 52) = 0;
  *(void *)(result + 44) = 0;
  return result;
}

uint64_t sub_100FCD228(uint64_t result)
{
  *(void *)double result = off_102309D20;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void *sub_100FCD24C(void *result)
{
  *double result = off_102309F00;
  result[1] = 0;
  result[5] = 0;
  result[6] = 0;
  result[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[3] = 0;
  result[4] = 0;
  return result;
}

uint64_t sub_100FCD280(uint64_t result)
{
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)double result = off_102309F78;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 15) = 0;
  return result;
}

uint64_t sub_100FCD2A8(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v4 = (void *)a1;
  uint64_t v5 = qword_10248B018;
  if (!qword_10248B018)
  {
    a1 = sub_100FCBE50();
    uint64_t v5 = qword_10248B018;
  }
  v4[3] = v5;
  uint64_t v6 = qword_10248B020;
  if (!qword_10248B020)
  {
    a1 = sub_100FCBE50();
    uint64_t v6 = qword_10248B020;
  }
  v4[4] = v6;
  uint64_t v7 = qword_10248B038;
  if (!qword_10248B038)
  {
    a1 = sub_100FCBE50();
    uint64_t v7 = qword_10248B038;
  }
  void v4[5] = v7;
  uint64_t v8 = qword_10248B040;
  if (!qword_10248B040)
  {
    a1 = sub_100FCBE50();
    uint64_t v8 = qword_10248B040;
  }
  v4[6] = v8;
  uint64_t v9 = qword_10248B048;
  if (!qword_10248B048)
  {
    a1 = sub_100FCBE50();
    uint64_t v9 = qword_10248B048;
  }
  v4[7] = v9;
  uint64_t v10 = qword_10248B050;
  if (!qword_10248B050)
  {
    a1 = sub_100FCBE50();
    uint64_t v10 = qword_10248B050;
  }
  v4[8] = v10;
  uint64_t v11 = qword_10248B058;
  if (!qword_10248B058)
  {
    a1 = sub_100FCBE50();
    uint64_t v11 = qword_10248B058;
  }
  v4[9] = v11;
  uint64_t v12 = qword_10248B060;
  if (!qword_10248B060)
  {
    a1 = sub_100FCBE50();
    uint64_t v12 = qword_10248B060;
  }
  v4[10] = v12;
  uint64_t v13 = qword_10248B068;
  if (!qword_10248B068)
  {
    a1 = sub_100FCBE50();
    uint64_t v13 = qword_10248B068;
  }
  v4[11] = v13;
  uint64_t v14 = qword_10248B070;
  if (!qword_10248B070)
  {
    a1 = sub_100FCBE50();
    uint64_t v14 = qword_10248B070;
  }
  v4[12] = v14;
  uint64_t v15 = qword_10248B078;
  if (!qword_10248B078)
  {
    a1 = sub_100FCBE50();
    uint64_t v15 = qword_10248B078;
  }
  v4[13] = v15;
  uint64_t v16 = qword_10248B080;
  if (!qword_10248B080)
  {
    a1 = sub_100FCBE50();
    uint64_t v16 = qword_10248B080;
  }
  v4[14] = v16;
  uint64_t v17 = qword_10248B000;
  if (!qword_10248B000)
  {
    a1 = sub_100FCBE50();
    uint64_t v17 = qword_10248B000;
  }
  v4[15] = v17;
  uint64_t v18 = qword_10248B008;
  if (!qword_10248B008)
  {
    a1 = sub_100FCBE50();
    uint64_t v18 = qword_10248B008;
  }
  v4[16] = v18;
  uint64_t v19 = qword_10248B010;
  if (!qword_10248B010)
  {
    a1 = sub_100FCBE50();
    uint64_t v19 = qword_10248B010;
  }
  v4[17] = v19;
  uint64_t v20 = qword_10248B028;
  if (!qword_10248B028)
  {
    a1 = sub_100FCBE50();
    uint64_t v20 = qword_10248B028;
  }
  v4[18] = v20;
  uint64_t v21 = qword_10248AFF8;
  if (!qword_10248AFF8)
  {
    a1 = sub_100FCBE50();
    uint64_t v21 = qword_10248AFF8;
  }
  v4[19] = v21;
  uint64_t v22 = qword_10248B030;
  if (!qword_10248B030)
  {
    a1 = sub_100FCBE50();
    uint64_t v22 = qword_10248B030;
  }
  v4[20] = v22;
  uint64_t v23 = qword_10248B090;
  if (!qword_10248B090)
  {
    a1 = sub_100FCBE50();
    uint64_t v23 = qword_10248B090;
  }
  v4[21] = v23;
  uint64_t v24 = qword_10248B098;
  if (!qword_10248B098)
  {
    a1 = sub_100FCBE50();
    uint64_t v24 = qword_10248B098;
  }
  v4[22] = v24;
  uint64_t v25 = qword_10248B0A8;
  if (!qword_10248B0A8)
  {
    a1 = sub_100FCBE50();
    uint64_t v25 = qword_10248B0A8;
  }
  v4[23] = v25;
  uint64_t v26 = qword_10248B0B0;
  if (!qword_10248B0B0)
  {
    a1 = sub_100FCBE50();
    uint64_t v26 = qword_10248B0B0;
  }
  v4[24] = v26;
  uint64_t v27 = qword_10248B0B8;
  if (!qword_10248B0B8)
  {
    a1 = sub_100FCBE50();
    uint64_t v27 = qword_10248B0B8;
  }
  v4[25] = v27;
  uint64_t v28 = qword_10248B0E0;
  if (!qword_10248B0E0)
  {
    a1 = sub_100FCBE50();
    uint64_t v28 = qword_10248B0E0;
  }
  v4[26] = v28;
  uint64_t v29 = qword_10248B130;
  if (!qword_10248B130)
  {
    a1 = sub_100FCBE50();
    uint64_t v29 = qword_10248B130;
  }
  v4[27] = v29;
  uint64_t v30 = qword_10248B108;
  if (!qword_10248B108)
  {
    a1 = sub_100FCBE50();
    uint64_t v30 = qword_10248B108;
  }
  v4[28] = v30;
  uint64_t v31 = qword_10248B088;
  if (!qword_10248B088)
  {
    a1 = sub_100FCBE50();
    uint64_t v31 = qword_10248B088;
  }
  v4[29] = v31;
  uint64_t v32 = qword_10248B0A0;
  if (!qword_10248B0A0)
  {
    a1 = sub_100FCBE50();
    uint64_t v32 = qword_10248B0A0;
  }
  v4[30] = v32;
  uint64_t v33 = sub_1008FB51C(a1, a2, a3, a4);
  v4[31] = v33;
  uint64_t v37 = sub_1008D4C7C(v33, v34, v35, v36);
  v4[33] = v37;
  uint64_t v41 = sub_1008F597C(v37, v38, v39, v40);
  v4[34] = v41;
  uint64_t v45 = sub_1008F678C(v41, v42, v43, v44);
  v4[35] = v45;
  uint64_t v49 = sub_1008F9C30(v45, v46, v47, v48);
  v4[36] = v49;
  uint64_t v53 = sub_1008FCFF0(v49, v50, v51, v52);
  v4[37] = v53;
  uint64_t v57 = sub_1008FE13C(v53, v54, v55, v56);
  v4[39] = v57;
  uint64_t v61 = sub_1008FAA8C(v57, v58, v59, v60);
  v4[40] = v61;
  uint64_t v65 = sub_1008CBD58(v61, v62, v63, v64);
  v4[43] = v65;
  uint64_t v69 = sub_1008D0CEC(v65, v66, v67, v68);
  v4[47] = v69;
  uint64_t result = sub_1008CD600(v69, v70, v71, v72);
  v4[48] = result;
  return result;
}

uint64_t sub_100FCD5C0(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v5 = sub_10074A9A0((uint64_t)a1, a2, a3, a4);
  a1[3] = v5;
  uint64_t v9 = sub_100E37898(v5, v6, v7, v8);
  a1[4] = v9;
  uint64_t v13 = sub_10074DBBC(v9, v10, v11, v12);
  a1[5] = v13;
  uint64_t v17 = qword_10248AFF0;
  if (!qword_10248AFF0)
  {
    uint64_t v13 = sub_100FCBE50();
    uint64_t v17 = qword_10248AFF0;
  }
  a1[6] = v17;
  uint64_t v18 = sub_10074C060(v13, v14, v15, v16);
  a1[7] = v18;
  uint64_t v22 = qword_10248B0C0;
  if (!qword_10248B0C0)
  {
    uint64_t v18 = sub_100FCBE50();
    uint64_t v22 = qword_10248B0C0;
  }
  a1[8] = v22;
  uint64_t v23 = qword_10248B0D8;
  if (!qword_10248B0D8)
  {
    uint64_t v18 = sub_100FCBE50();
    uint64_t v23 = qword_10248B0D8;
  }
  a1[9] = v23;
  uint64_t v24 = sub_10074E7A8(v18, v19, v20, v21);
  a1[10] = v24;
  uint64_t v28 = sub_10074E264(v24, v25, v26, v27);
  a1[11] = v28;
  uint64_t v32 = qword_10248B110;
  if (!qword_10248B110)
  {
    uint64_t v28 = sub_100FCBE50();
    uint64_t v32 = qword_10248B110;
  }
  a1[13] = v32;
  uint64_t v33 = qword_10248B118;
  if (!qword_10248B118)
  {
    uint64_t v28 = sub_100FCBE50();
    uint64_t v33 = qword_10248B118;
  }
  a1[14] = v33;
  uint64_t v34 = qword_10248B120;
  if (!qword_10248B120)
  {
    uint64_t v28 = sub_100FCBE50();
    uint64_t v34 = qword_10248B120;
  }
  a1[15] = v34;
  uint64_t v35 = sub_1008C81C4(v28, v29, v30, v31);
  a1[16] = v35;
  uint64_t v39 = sub_1008E5AFC(v35, v36, v37, v38);
  a1[18] = v39;
  uint64_t v43 = sub_1008EB384(v39, v40, v41, v42);
  a1[19] = v43;
  uint64_t v47 = sub_1008F12E4(v43, v44, v45, v46);
  a1[20] = v47;
  uint64_t v51 = sub_1008FDC54(v47, v48, v49, v50);
  a1[21] = v51;
  uint64_t v55 = sub_100901920(v51, v52, v53, v54);
  a1[22] = v55;
  uint64_t v59 = sub_1008D1D34(v55, v56, v57, v58);
  a1[23] = v59;
  uint64_t v63 = sub_1008CFDE4(v59, v60, v61, v62);
  a1[24] = v63;
  uint64_t result = sub_1008CC840(v63, v64, v65, v66);
  a1[26] = result;
  return result;
}

uint64_t sub_100FCD6E8(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = qword_10248B100;
  if (!qword_10248B100)
  {
    uint64_t result = sub_100FCBE50();
    uint64_t v2 = qword_10248B100;
  }
  _DWORD v1[2] = v2;
  uint64_t v3 = qword_10248B0E8;
  if (!qword_10248B0E8)
  {
    uint64_t result = sub_100FCBE50();
    uint64_t v3 = qword_10248B0E8;
  }
  v1[3] = v3;
  uint64_t v4 = qword_10248B0F0;
  if (!qword_10248B0F0)
  {
    uint64_t result = sub_100FCBE50();
    uint64_t v4 = qword_10248B0F0;
  }
  v1[4] = v4;
  uint64_t v5 = qword_10248B0F8;
  if (!qword_10248B0F8)
  {
    uint64_t result = sub_100FCBE50();
    uint64_t v5 = qword_10248B0F8;
  }
  v1[5] = v5;
  return result;
}

uint64_t sub_100FCD768()
{
  return 1;
}

uint64_t sub_100FCD8DC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_102308B50;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 36sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 392) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 368) = 0;
  *(void *)(a1 + 396) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_DWORD *)(a1 + 388) = 0;
  *(void *)(a1 + 372) = 0;
  *(void *)(a1 + 38sub_100FB8FC8(&a9, 0) = 0;
  sub_100FCD9F4(a1, a2);
  return a1;
}

void sub_100FCD9B8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  if (*v4) {
    operator delete[]();
  }
  sub_101A9BF6C(v2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_100FCD9F4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v95);
  }
  int v4 = *(_DWORD *)(a2 + 336);
  if (v4)
  {
    sub_100221DFC(a1 + 328, *(_DWORD *)(a1 + 336) + v4);
    memcpy((void *)(*(void *)(a1 + 328) + 4 * *(int *)(a1 + 336)), *(const void **)(a2 + 328), 4 * *(int *)(a2 + 336));
    *(_DWORD *)(a1 + 336) += *(_DWORD *)(a2 + 336);
  }
  int v5 = *(_DWORD *)(a2 + 360);
  if (v5)
  {
    sub_100221DFC(a1 + 352, *(_DWORD *)(a1 + 360) + v5);
    memcpy((void *)(*(void *)(a1 + 352) + 4 * *(int *)(a1 + 360)), *(const void **)(a2 + 352), 4 * *(int *)(a2 + 360));
    *(_DWORD *)(a1 + 360) += *(_DWORD *)(a2 + 360);
  }
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if (!(_BYTE)v6) {
    goto LABEL_46;
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 396) |= 1u;
    *(void *)(a1 + 8) = v7;
    unsigned int v6 = *(_DWORD *)(a2 + 396);
    if ((v6 & 2) == 0)
    {
LABEL_10:
      if ((v6 & 4) == 0) {
        goto LABEL_11;
      }
      goto LABEL_19;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_10;
  }
  int v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 396) |= 2u;
  *(_DWORD *)(a1 + 16) = v8;
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 4) == 0)
  {
LABEL_11:
    if ((v6 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_21;
  }
LABEL_19:
  int v9 = *(_DWORD *)(a2 + 20);
  if ((sub_100FCD768() & 1) == 0) {
    sub_101A9BF7C();
  }
  *(_DWORD *)(a1 + 396) |= 4u;
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v9;
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 8) == 0)
  {
LABEL_12:
    if ((v6 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_26;
  }
LABEL_21:
  *(_DWORD *)(a1 + 396) |= 8u;
  uint64_t v10 = *(void *)(a1 + 24);
  if (!v10) {
    operator new();
  }
  uint64_t v11 = *(void *)(a2 + 24);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_10248AFD8 + 24);
  }
  sub_100FD50C4(v10, v11);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x10) == 0)
  {
LABEL_13:
    if ((v6 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_31:
    *(_DWORD *)(a1 + 396) |= 0x20u;
    uint64_t v14 = *(_DWORD **)(a1 + 40);
    if (!v14) {
      operator new();
    }
    uint64_t v15 = *(void *)(a2 + 40);
    if (!v15) {
      uint64_t v15 = *(void *)(qword_10248AFD8 + 40);
    }
    sub_100FD5324(v14, v15);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
    if ((v6 & 0x40) == 0)
    {
LABEL_15:
      if ((v6 & 0x80) == 0) {
        goto LABEL_46;
      }
      goto LABEL_41;
    }
    goto LABEL_36;
  }
LABEL_26:
  *(_DWORD *)(a1 + 396) |= 0x10u;
  uint64_t v12 = *(void *)(a1 + 32);
  if (!v12) {
    operator new();
  }
  uint64_t v13 = *(void *)(a2 + 32);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248AFD8 + 32);
  }
  sub_100FD5238(v12, v13);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x20) != 0) {
    goto LABEL_31;
  }
LABEL_14:
  if ((v6 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_36:
  *(_DWORD *)(a1 + 396) |= 0x40u;
  uint64_t v16 = *(_DWORD **)(a1 + 48);
  if (!v16) {
    operator new();
  }
  uint64_t v17 = *(void *)(a2 + 48);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248AFD8 + 48);
  }
  sub_100FD5464(v16, v17);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x80) != 0)
  {
LABEL_41:
    *(_DWORD *)(a1 + 396) |= 0x80u;
    uint64_t v18 = *(_DWORD **)(a1 + 56);
    if (!v18) {
      operator new();
    }
    uint64_t v19 = *(void *)(a2 + 56);
    if (!v19) {
      uint64_t v19 = *(void *)(qword_10248AFD8 + 56);
    }
    sub_100FD55A4(v18, v19);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
  }
LABEL_46:
  if ((v6 & 0xFF00) == 0) {
    goto LABEL_96;
  }
  if ((v6 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 396) |= 0x100u;
    uint64_t v20 = *(void *)(a1 + 64);
    if (!v20) {
      operator new();
    }
    uint64_t v21 = *(void *)(a2 + 64);
    if (!v21) {
      uint64_t v21 = *(void *)(qword_10248AFD8 + 64);
    }
    sub_100FD56E4(v20, v21);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
    if ((v6 & 0x200) == 0)
    {
LABEL_49:
      if ((v6 & 0x400) == 0) {
        goto LABEL_50;
      }
      goto LABEL_66;
    }
  }
  else if ((v6 & 0x200) == 0)
  {
    goto LABEL_49;
  }
  *(_DWORD *)(a1 + 396) |= 0x200u;
  uint64_t v22 = *(void *)(a1 + 72);
  if (!v22) {
    operator new();
  }
  uint64_t v23 = *(void *)(a2 + 72);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_10248AFD8 + 72);
  }
  sub_100FD57D0(v22, v23);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x400) == 0)
  {
LABEL_50:
    if ((v6 & 0x800) == 0) {
      goto LABEL_51;
    }
    goto LABEL_71;
  }
LABEL_66:
  *(_DWORD *)(a1 + 396) |= 0x400u;
  uint64_t v24 = *(void *)(a1 + 80);
  if (!v24) {
    operator new();
  }
  uint64_t v25 = *(void *)(a2 + 80);
  if (!v25) {
    uint64_t v25 = *(void *)(qword_10248AFD8 + 80);
  }
  sub_100FD5A08(v24, v25);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x800) == 0)
  {
LABEL_51:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_52;
    }
    goto LABEL_76;
  }
LABEL_71:
  *(_DWORD *)(a1 + 396) |= 0x800u;
  uint64_t v26 = *(void *)(a1 + 88);
  if (!v26) {
    operator new();
  }
  uint64_t v27 = *(void *)(a2 + 88);
  if (!v27) {
    uint64_t v27 = *(void *)(qword_10248AFD8 + 88);
  }
  sub_100FD5B3C(v26, v27);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x1000) == 0)
  {
LABEL_52:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_81;
  }
LABEL_76:
  *(_DWORD *)(a1 + 396) |= 0x1000u;
  uint64_t v28 = *(void *)(a1 + 96);
  if (!v28) {
    operator new();
  }
  uint64_t v29 = *(void *)(a2 + 96);
  if (!v29) {
    uint64_t v29 = *(void *)(qword_10248AFD8 + 96);
  }
  sub_100FD5C10(v28, v29);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x2000) == 0)
  {
LABEL_53:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_86;
  }
LABEL_81:
  *(_DWORD *)(a1 + 396) |= 0x2000u;
  uint64_t v30 = *(void *)(a1 + 104);
  if (!v30) {
    operator new();
  }
  uint64_t v31 = *(void *)(a2 + 104);
  if (!v31) {
    uint64_t v31 = *(void *)(qword_10248AFD8 + 104);
  }
  sub_100FD5CC4(v30, v31);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x4000) == 0)
  {
LABEL_54:
    if ((v6 & 0x8000) == 0) {
      goto LABEL_96;
    }
    goto LABEL_91;
  }
LABEL_86:
  *(_DWORD *)(a1 + 396) |= 0x4000u;
  uint64_t v32 = *(void *)(a1 + 112);
  if (!v32) {
    operator new();
  }
  uint64_t v33 = *(void *)(a2 + 112);
  if (!v33) {
    uint64_t v33 = *(void *)(qword_10248AFD8 + 112);
  }
  sub_100FD5DD0(v32, v33);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x8000) != 0)
  {
LABEL_91:
    *(_DWORD *)(a1 + 396) |= 0x8000u;
    uint64_t v34 = *(void *)(a1 + 120);
    if (!v34) {
      operator new();
    }
    uint64_t v35 = *(void *)(a2 + 120);
    if (!v35) {
      uint64_t v35 = *(void *)(qword_10248AFD8 + 120);
    }
    sub_100FD5EBC(v34, v35);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
  }
LABEL_96:
  if ((v6 & 0xFF0000) == 0) {
    goto LABEL_146;
  }
  if ((v6 & 0x10000) != 0)
  {
    *(_DWORD *)(a1 + 396) |= 0x10000u;
    uint64_t v36 = *(void *)(a1 + 128);
    if (!v36) {
      operator new();
    }
    uint64_t v37 = *(void *)(a2 + 128);
    if (!v37) {
      uint64_t v37 = *(void *)(qword_10248AFD8 + 128);
    }
    sub_100FD5FD0(v36, v37);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
    if ((v6 & 0x20000) == 0)
    {
LABEL_99:
      if ((v6 & 0x40000) == 0) {
        goto LABEL_100;
      }
      goto LABEL_116;
    }
  }
  else if ((v6 & 0x20000) == 0)
  {
    goto LABEL_99;
  }
  *(_DWORD *)(a1 + 396) |= 0x20000u;
  uint64_t v38 = *(_DWORD **)(a1 + 136);
  if (!v38) {
    operator new();
  }
  uint64_t v39 = *(void *)(a2 + 136);
  if (!v39) {
    uint64_t v39 = *(void *)(qword_10248AFD8 + 136);
  }
  sub_100FD60B0(v38, v39);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x40000) == 0)
  {
LABEL_100:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_101;
    }
    goto LABEL_121;
  }
LABEL_116:
  *(_DWORD *)(a1 + 396) |= 0x40000u;
  uint64_t v40 = *(void *)(a1 + 144);
  if (!v40) {
    operator new();
  }
  uint64_t v41 = *(void *)(a2 + 144);
  if (!v41) {
    uint64_t v41 = *(void *)(qword_10248AFD8 + 144);
  }
  sub_100FD61F0(v40, v41);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x80000) == 0)
  {
LABEL_101:
    if ((v6 & 0x100000) == 0) {
      goto LABEL_102;
    }
    goto LABEL_126;
  }
LABEL_121:
  *(_DWORD *)(a1 + 396) |= 0x80000u;
  uint64_t v42 = *(void *)(a1 + 152);
  if (!v42) {
    operator new();
  }
  uint64_t v43 = *(unsigned char **)(a2 + 152);
  if (!v43) {
    uint64_t v43 = *(unsigned char **)(qword_10248AFD8 + 152);
  }
  sub_100FD6294(v42, v43);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x100000) == 0)
  {
LABEL_102:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_131;
  }
LABEL_126:
  *(_DWORD *)(a1 + 396) |= 0x100000u;
  uint64_t v44 = *(void *)(a1 + 160);
  if (!v44) {
    operator new();
  }
  uint64_t v45 = *(void *)(a2 + 160);
  if (!v45) {
    uint64_t v45 = *(void *)(qword_10248AFD8 + 160);
  }
  sub_100FD63E0(v44, v45);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x200000) == 0)
  {
LABEL_103:
    if ((v6 & 0x400000) == 0) {
      goto LABEL_104;
    }
    goto LABEL_136;
  }
LABEL_131:
  *(_DWORD *)(a1 + 396) |= 0x200000u;
  uint64_t v46 = *(void *)(a1 + 168);
  if (!v46) {
    operator new();
  }
  uint64_t v47 = *(void *)(a2 + 168);
  if (!v47) {
    uint64_t v47 = *(void *)(qword_10248AFD8 + 168);
  }
  sub_100FD6484(v46, v47);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x400000) == 0)
  {
LABEL_104:
    if ((v6 & 0x800000) == 0) {
      goto LABEL_146;
    }
    goto LABEL_141;
  }
LABEL_136:
  *(_DWORD *)(a1 + 396) |= 0x400000u;
  uint64_t v48 = *(_DWORD **)(a1 + 176);
  if (!v48) {
    operator new();
  }
  uint64_t v49 = *(void *)(a2 + 176);
  if (!v49) {
    uint64_t v49 = *(void *)(qword_10248AFD8 + 176);
  }
  sub_100FD6548(v48, v49);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x800000) != 0)
  {
LABEL_141:
    *(_DWORD *)(a1 + 396) |= 0x800000u;
    uint64_t v50 = *(void *)(a1 + 184);
    if (!v50) {
      operator new();
    }
    uint64_t v51 = *(void *)(a2 + 184);
    if (!v51) {
      uint64_t v51 = *(void *)(qword_10248AFD8 + 184);
    }
    sub_100FD660C(v50, v51);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
  }
LABEL_146:
  if (!HIBYTE(v6)) {
    goto LABEL_196;
  }
  if ((v6 & 0x1000000) != 0)
  {
    *(_DWORD *)(a1 + 396) |= 0x1000000u;
    uint64_t v52 = *(void *)(a1 + 192);
    if (!v52) {
      operator new();
    }
    uint64_t v53 = *(void *)(a2 + 192);
    if (!v53) {
      uint64_t v53 = *(void *)(qword_10248AFD8 + 192);
    }
    sub_100FD66B0(v52, v53);
    unsigned int v6 = *(_DWORD *)(a2 + 396);
    if ((v6 & 0x2000000) == 0)
    {
LABEL_149:
      if ((v6 & 0x4000000) == 0) {
        goto LABEL_150;
      }
      goto LABEL_166;
    }
  }
  else if ((v6 & 0x2000000) == 0)
  {
    goto LABEL_149;
  }
  *(_DWORD *)(a1 + 396) |= 0x2000000u;
  uint64_t v54 = *(void *)(a1 + 200);
  if (!v54) {
    operator new();
  }
  uint64_t v55 = *(void *)(a2 + 200);
  if (!v55) {
    uint64_t v55 = *(void *)(qword_10248AFD8 + 200);
  }
  sub_100FD6790(v54, v55);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x4000000) == 0)
  {
LABEL_150:
    if ((v6 & 0x8000000) == 0) {
      goto LABEL_151;
    }
    goto LABEL_171;
  }
LABEL_166:
  *(_DWORD *)(a1 + 396) |= 0x4000000u;
  uint64_t v56 = *(void *)(a1 + 208);
  if (!v56) {
    operator new();
  }
  uint64_t v57 = *(void *)(a2 + 208);
  if (!v57) {
    uint64_t v57 = *(void *)(qword_10248AFD8 + 208);
  }
  sub_100FD6870(v56, v57);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x8000000) == 0)
  {
LABEL_151:
    if ((v6 & 0x10000000) == 0) {
      goto LABEL_152;
    }
    goto LABEL_176;
  }
LABEL_171:
  *(_DWORD *)(a1 + 396) |= 0x8000000u;
  uint64_t v58 = *(void *)(a1 + 216);
  if (!v58) {
    operator new();
  }
  uint64_t v59 = *(void *)(a2 + 216);
  if (!v59) {
    uint64_t v59 = *(void *)(qword_10248AFD8 + 216);
  }
  sub_100FD6B5C(v58, v59);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x10000000) == 0)
  {
LABEL_152:
    if ((v6 & 0x20000000) == 0) {
      goto LABEL_153;
    }
    goto LABEL_181;
  }
LABEL_176:
  *(_DWORD *)(a1 + 396) |= 0x10000000u;
  uint64_t v60 = *(void *)(a1 + 224);
  if (!v60) {
    operator new();
  }
  uint64_t v61 = *(void *)(a2 + 224);
  if (!v61) {
    uint64_t v61 = *(void *)(qword_10248AFD8 + 224);
  }
  sub_100FD6C68(v60, v61);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x20000000) == 0)
  {
LABEL_153:
    if ((v6 & 0x40000000) == 0) {
      goto LABEL_154;
    }
    goto LABEL_186;
  }
LABEL_181:
  *(_DWORD *)(a1 + 396) |= 0x20000000u;
  uint64_t v62 = *(void *)(a1 + 232);
  if (!v62) {
    operator new();
  }
  uint64_t v63 = *(void *)(a2 + 232);
  if (!v63) {
    uint64_t v63 = *(void *)(qword_10248AFD8 + 232);
  }
  sub_100FD6D18(v62, v63);
  unsigned int v6 = *(_DWORD *)(a2 + 396);
  if ((v6 & 0x40000000) == 0)
  {
LABEL_154:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_196;
    }
    goto LABEL_191;
  }
LABEL_186:
  *(_DWORD *)(a1 + 396) |= 0x40000000u;
  uint64_t v64 = *(void *)(a1 + 240);
  if (!v64) {
    operator new();
  }
  uint64_t v65 = *(unsigned char **)(a2 + 240);
  if (!v65) {
    uint64_t v65 = *(unsigned char **)(qword_10248AFD8 + 240);
  }
  sub_100FD6DDC(v64, v65);
  if ((*(_DWORD *)(a2 + 396) & 0x80000000) != 0)
  {
LABEL_191:
    *(_DWORD *)(a1 + 396) |= 0x80000000;
    uint64_t v66 = *(void *)(a1 + 248);
    if (!v66) {
      operator new();
    }
    uint64_t v67 = *(void *)(a2 + 248);
    if (!v67) {
      uint64_t v67 = *(void *)(qword_10248AFD8 + 248);
    }
    sub_1008FB17C(v66, v67);
  }
LABEL_196:
  int v68 = *(_DWORD *)(a2 + 400);
  if ((_BYTE)v68)
  {
    if (v68)
    {
      uint64_t v69 = *(const std::string **)(a2 + 256);
      *(_DWORD *)(a1 + 400) |= 1u;
      uint64_t v70 = *(std::string **)(a1 + 256);
      if (v70 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v70, v69);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 2) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 2u;
      uint64_t v71 = *(_DWORD **)(a1 + 264);
      if (!v71) {
        operator new();
      }
      uint64_t v72 = *(_DWORD **)(a2 + 264);
      if (!v72) {
        uint64_t v72 = *(_DWORD **)(qword_10248AFD8 + 264);
      }
      sub_1008D4944(v71, v72);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 4) != 0)
    {
      int v73 = *(_DWORD *)(a2 + 304);
      *(_DWORD *)(a1 + 400) |= 4u;
      *(_DWORD *)(a1 + 304) = v73;
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 8) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 8u;
      uint64_t v74 = *(_DWORD **)(a1 + 272);
      if (!v74) {
        operator new();
      }
      uint64_t v75 = *(void *)(a2 + 272);
      if (!v75) {
        uint64_t v75 = *(void *)(qword_10248AFD8 + 272);
      }
      sub_1008F5650(v74, v75);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 0x10) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x10u;
      int64_t v76 = *(_DWORD **)(a1 + 280);
      if (!v76) {
        operator new();
      }
      uint64_t v77 = *(_DWORD **)(a2 + 280);
      if (!v77) {
        uint64_t v77 = *(_DWORD **)(qword_10248AFD8 + 280);
      }
      sub_1008F64A8(v76, v77);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 0x20) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x20u;
      unint64_t v78 = *(_DWORD **)(a1 + 288);
      if (!v78) {
        operator new();
      }
      uint64_t v79 = *(void *)(a2 + 288);
      if (!v79) {
        uint64_t v79 = *(void *)(qword_10248AFD8 + 288);
      }
      sub_1008F9974(v78, v79);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x40u;
      uint64_t v80 = *(void *)(a1 + 296);
      if (!v80) {
        operator new();
      }
      uint64_t v81 = *(void *)(a2 + 296);
      if (!v81) {
        uint64_t v81 = *(void *)(qword_10248AFD8 + 296);
      }
      sub_1008FCC44(v80, v81);
      int v68 = *(_DWORD *)(a2 + 400);
    }
    if ((v68 & 0x80) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x80u;
      uint64_t v82 = *(void *)(a1 + 312);
      if (!v82) {
        operator new();
      }
      uint64_t v83 = *(void *)(a2 + 312);
      if (!v83) {
        uint64_t v83 = *(void *)(qword_10248AFD8 + 312);
      }
      sub_1008FDF1C(v82, v83);
      int v68 = *(_DWORD *)(a2 + 400);
    }
  }
  if ((v68 & 0xFF00) == 0) {
    goto LABEL_256;
  }
  if ((v68 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 400) |= 0x100u;
    uint64_t v84 = *(void *)(a1 + 320);
    if (!v84) {
      operator new();
    }
    uint64_t v85 = *(void *)(a2 + 320);
    if (!v85) {
      uint64_t v85 = *(void *)(qword_10248AFD8 + 320);
    }
    sub_1008FA7C0(v84, v85);
    int v68 = *(_DWORD *)(a2 + 400);
  }
  if ((v68 & 0x400) != 0)
  {
    *(_DWORD *)(a1 + 400) |= 0x400u;
    uint64_t v86 = *(_DWORD **)(a1 + 344);
    if (!v86) {
      operator new();
    }
    uint64_t v87 = *(void *)(a2 + 344);
    if (!v87) {
      uint64_t v87 = *(void *)(qword_10248AFD8 + 344);
    }
    sub_1008CB92C(v86, v87);
    int v68 = *(_DWORD *)(a2 + 400);
  }
  if ((v68 & 0x800) != 0)
  {
    int v88 = *(_DWORD *)(a2 + 308);
    *(_DWORD *)(a1 + 400) |= 0x800u;
    *(_DWORD *)(a1 + 308) = v88;
    int v68 = *(_DWORD *)(a2 + 400);
    if ((v68 & 0x2000) == 0)
    {
LABEL_254:
      if ((v68 & 0x4000) == 0) {
        goto LABEL_255;
      }
      goto LABEL_260;
    }
  }
  else if ((v68 & 0x2000) == 0)
  {
    goto LABEL_254;
  }
  char v89 = *(unsigned char *)(a2 + 368);
  *(_DWORD *)(a1 + 400) |= 0x2000u;
  *(unsigned char *)(a1 + 368) = v89;
  int v68 = *(_DWORD *)(a2 + 400);
  if ((v68 & 0x4000) != 0)
  {
LABEL_260:
    int v90 = *(_DWORD *)(a2 + 372);
    *(_DWORD *)(a1 + 400) |= 0x4000u;
    *(_DWORD *)(a1 + 372) = v90;
    int v68 = *(_DWORD *)(a2 + 400);
    if ((v68 & 0x8000) != 0) {
      goto LABEL_261;
    }
LABEL_256:
    if ((v68 & 0x10000) == 0) {
      return;
    }
    goto LABEL_266;
  }
LABEL_255:
  if ((v68 & 0x8000) == 0) {
    goto LABEL_256;
  }
LABEL_261:
  *(_DWORD *)(a1 + 400) |= 0x8000u;
  uint64_t v91 = *(void *)(a1 + 376);
  if (!v91) {
    operator new();
  }
  uint64_t v92 = *(void *)(a2 + 376);
  if (!v92) {
    uint64_t v92 = *(void *)(qword_10248AFD8 + 376);
  }
  sub_1008D0854(v91, v92);
  if ((*(_DWORD *)(a2 + 400) & 0x10000) != 0)
  {
LABEL_266:
    *(_DWORD *)(a1 + 400) |= 0x10000u;
    v93 = *(_DWORD **)(a1 + 384);
    if (!v93) {
      operator new();
    }
    uint64_t v94 = *(void *)(a2 + 384);
    if (!v94) {
      uint64_t v94 = *(void *)(qword_10248AFD8 + 384);
    }
    sub_1008CD4B0(v93, v94);
  }
}

void sub_100FCEDF8()
{
}

void sub_100FCEF04(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308B50;
  sub_100FCEF90(a1);
  if (*((void *)a1 + 44)) {
    operator delete[]();
  }
  if (*((void *)a1 + 41)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void *sub_100FCEF90(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[32];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  if ((void *)qword_10248AFD8 != result)
  {
    uint64_t v4 = result[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    uint64_t v11 = v1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    uint64_t v12 = v1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = v1[12];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    uint64_t v14 = v1[13];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    uint64_t v15 = v1[14];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v16 = v1[15];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
    uint64_t v17 = v1[16];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    uint64_t v18 = v1[17];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
    uint64_t v19 = v1[18];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    uint64_t v20 = v1[19];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
    uint64_t v21 = v1[20];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    }
    uint64_t v22 = v1[21];
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    uint64_t v23 = v1[22];
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    uint64_t v24 = v1[23];
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    }
    uint64_t v25 = v1[24];
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
    uint64_t v26 = v1[25];
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
    uint64_t v27 = v1[26];
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    uint64_t v28 = v1[27];
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
    }
    uint64_t v29 = v1[28];
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    }
    uint64_t v30 = v1[29];
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
    }
    uint64_t v31 = v1[30];
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
    uint64_t v32 = v1[31];
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
    }
    uint64_t v33 = v1[33];
    if (v33) {
      (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
    }
    uint64_t v34 = v1[34];
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    }
    uint64_t v35 = v1[35];
    if (v35) {
      (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    }
    uint64_t v36 = v1[36];
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
    }
    uint64_t v37 = v1[37];
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
    }
    uint64_t v38 = v1[39];
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
    uint64_t v39 = v1[40];
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
    }
    uint64_t v40 = v1[43];
    if (v40) {
      (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
    }
    uint64_t v41 = v1[47];
    if (v41) {
      (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
    }
    uint64_t result = (void *)v1[48];
    if (result)
    {
      uint64_t v42 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v42();
    }
  }
  return result;
}

void sub_100FCF6D0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100FCEF04(a1);

  operator delete();
}

void sub_100FCF708()
{
}

uint64_t sub_100FCF7D8(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = (unsigned int *)(result + 396);
  unsigned int v3 = *(_DWORD *)(result + 396);
  if ((_BYTE)v3)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    if ((v3 & 8) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result)
      {
        uint64_t result = sub_100FCFDB4(result);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 32);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 36))
        {
          *(void *)(v4 + 8) = 0;
          *(void *)(v4 + 16) = 0;
          *(void *)(v4 + 24) = 0;
        }
        *(_DWORD *)(v4 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 40);
      if (v5)
      {
        uint64_t result = sub_10026DEDC(v5 + 8);
        *(_DWORD *)(v5 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40) != 0)
    {
      uint64_t v6 = *(void *)(v1 + 48);
      if (v6)
      {
        uint64_t result = sub_10026DEDC(v6 + 8);
        *(_DWORD *)(v6 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80) != 0)
    {
      uint64_t v7 = *(void *)(v1 + 56);
      if (v7)
      {
        uint64_t result = sub_10026DEDC(v7 + 8);
        *(_DWORD *)(v7 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF00) != 0)
  {
    if ((v3 & 0x100) != 0)
    {
      uint64_t v8 = *(void *)(v1 + 64);
      if (v8)
      {
        if (*(unsigned char *)(v8 + 36))
        {
          *(void *)(v8 + 8) = 0;
          *(void *)(v8 + 16) = 0;
          *(void *)(v8 + 24) = 0;
        }
        *(_DWORD *)(v8 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x200) != 0)
    {
      uint64_t v9 = *(void *)(v1 + 72);
      if (v9)
      {
        int v10 = *(_DWORD *)(v9 + 76);
        if ((_BYTE)v10)
        {
          *(_OWORD *)(v9 + 49) = 0u;
          *(_OWORD *)(v9 + 4sub_100FB8FC8(&a9, 0) = 0u;
          *(_OWORD *)(v9 + 24) = 0u;
          *(_OWORD *)(v9 + 8) = 0u;
        }
        if ((v10 & 0xFF00) != 0)
        {
          *(unsigned char *)(v9 + 69) = 0;
          *(_DWORD *)(v9 + 65) = 0;
        }
        *(_DWORD *)(v9 + 76) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x400) != 0)
    {
      uint64_t v11 = *(void *)(v1 + 80);
      if (v11)
      {
        if (*(unsigned char *)(v11 + 32))
        {
          *(void *)(v11 + 8) = 0;
          *(void *)(v11 + 16) = 0x400000000;
          *(_DWORD *)(v11 + 24) = 0;
        }
        *(_DWORD *)(v11 + 32) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x800) != 0)
    {
      uint64_t v12 = *(void *)(v1 + 88);
      if (v12)
      {
        if (*(unsigned char *)(v12 + 24))
        {
          *(void *)(v12 + 8) = 0;
          *(_DWORD *)(v12 + 16) = 4;
        }
        *(_DWORD *)(v12 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x1000) != 0)
    {
      uint64_t v13 = *(void *)(v1 + 96);
      if (v13)
      {
        if (*(unsigned char *)(v13 + 16)) {
          *(_DWORD *)(v13 + 8) = 15;
        }
        *(_DWORD *)(v13 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x2000) != 0)
    {
      uint64_t v14 = *(void *)(v1 + 104);
      if (v14)
      {
        if (*(unsigned char *)(v14 + 44))
        {
          *(_OWORD *)(v14 + 24) = 0u;
          *(_OWORD *)(v14 + 8) = 0u;
        }
        *(_DWORD *)(v14 + 44) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x4000) != 0)
    {
      uint64_t v15 = *(void *)(v1 + 112);
      if (v15)
      {
        if (*(unsigned char *)(v15 + 36))
        {
          *(void *)(v15 + 8) = 0;
          *(void *)(v15 + 16) = 0;
          *(void *)(v15 + 24) = 0;
        }
        *(_DWORD *)(v15 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x8000) != 0)
    {
      uint64_t result = *(void *)(v1 + 120);
      if (result)
      {
        uint64_t result = sub_100FCFF74(result);
        unsigned int v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF0000) != 0)
  {
    if ((v3 & 0x10000) != 0)
    {
      uint64_t v16 = *(void *)(v1 + 128);
      if (v16)
      {
        if (*(unsigned char *)(v16 + 20))
        {
          uint64_t v17 = *(void *)(v16 + 8);
          if ((_UNKNOWN *)v17 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v17 + 23) < 0)
            {
              **(unsigned char **)uint64_t v17 = 0;
              *(void *)(v17 + 8) = 0;
            }
            else
            {
              *(unsigned char *)uint64_t v17 = 0;
              *(unsigned char *)(v17 + 23) = 0;
            }
          }
        }
        *(_DWORD *)(v16 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20000) != 0)
    {
      uint64_t v18 = *(void *)(v1 + 136);
      if (v18)
      {
        uint64_t result = sub_10026DEDC(v18 + 8);
        *(_DWORD *)(v18 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40000) != 0)
    {
      uint64_t v19 = *(void *)(v1 + 144);
      if (v19)
      {
        if (*(unsigned char *)(v19 + 20)) {
          *(void *)(v19 + 8) = 0;
        }
        *(_DWORD *)(v19 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80000) != 0)
    {
      uint64_t v20 = *(void *)(v1 + 152);
      if (v20)
      {
        if (*(unsigned char *)(v20 + 20))
        {
          *(unsigned char *)(v20 + 8) = 1;
          *(_DWORD *)(v20 + 9) = 0;
          *(unsigned char *)(v20 + 13) = 0;
        }
        *(_DWORD *)(v20 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x100000) != 0)
    {
      uint64_t v21 = *(void *)(v1 + 160);
      if (v21)
      {
        if (*(unsigned char *)(v21 + 20)) {
          *(void *)(v21 + 8) = 0;
        }
        *(_DWORD *)(v21 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x200000) != 0)
    {
      uint64_t v22 = *(void *)(v1 + 168);
      if (v22)
      {
        if (*(unsigned char *)(v22 + 20))
        {
          *(unsigned char *)(v22 + 8) = 0;
          *(_DWORD *)(v22 + 12) = 0;
        }
        *(_DWORD *)(v22 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x400000) != 0)
    {
      uint64_t v23 = *(void *)(v1 + 176);
      if (v23)
      {
        if (*(unsigned char *)(v23 + 20)) {
          *(void *)(v23 + 8) = 0;
        }
        *(_DWORD *)(v23 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x800000) != 0)
    {
      uint64_t v24 = *(void *)(v1 + 184);
      if (v24)
      {
        if (*(unsigned char *)(v24 + 16)) {
          *(unsigned char *)(v24 + 8) = 0;
        }
        *(_DWORD *)(v24 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
  }
  if (HIBYTE(v3))
  {
    if ((v3 & 0x1000000) != 0)
    {
      uint64_t v25 = *(void *)(v1 + 192);
      if (v25)
      {
        if (*(unsigned char *)(v25 + 20))
        {
          uint64_t v26 = *(void *)(v25 + 8);
          if ((_UNKNOWN *)v26 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v26 + 23) < 0)
            {
              **(unsigned char **)uint64_t v26 = 0;
              *(void *)(v26 + 8) = 0;
            }
            else
            {
              *(unsigned char *)uint64_t v26 = 0;
              *(unsigned char *)(v26 + 23) = 0;
            }
          }
        }
        *(_DWORD *)(v25 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x2000000) != 0)
    {
      uint64_t v27 = *(void *)(v1 + 200);
      if (v27)
      {
        if (*(unsigned char *)(v27 + 20))
        {
          uint64_t v28 = *(void *)(v27 + 8);
          if ((_UNKNOWN *)v28 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v28 + 23) < 0)
            {
              **(unsigned char **)uint64_t v28 = 0;
              *(void *)(v28 + 8) = 0;
            }
            else
            {
              *(unsigned char *)uint64_t v28 = 0;
              *(unsigned char *)(v28 + 23) = 0;
            }
          }
        }
        *(_DWORD *)(v27 + 2sub_100FB8FC8(&a9, 0) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x4000000) != 0)
    {
      uint64_t result = *(void *)(v1 + 208);
      if (result)
      {
        uint64_t result = sub_100FD0140(result);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x8000000) != 0)
    {
      uint64_t v29 = *(void *)(v1 + 216);
      if (v29)
      {
        if (*(unsigned char *)(v29 + 24))
        {
          *(_DWORD *)(v29 + 15) = 0;
          *(void *)(v29 + 8) = 0;
        }
        *(_DWORD *)(v29 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x10000000) != 0)
    {
      uint64_t v30 = *(void *)(v1 + 224);
      if (v30)
      {
        if (*(unsigned char *)(v30 + 16)) {
          *(_DWORD *)(v30 + 8) = 0;
        }
        *(_DWORD *)(v30 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20000000) != 0)
    {
      uint64_t v31 = *(void *)(v1 + 232);
      if (v31)
      {
        if (*(unsigned char *)(v31 + 24))
        {
          *(void *)(v31 + 8) = 0;
          *(_DWORD *)(v31 + 16) = 0;
        }
        *(_DWORD *)(v31 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40000000) != 0)
    {
      uint64_t v32 = *(void *)(v1 + 240);
      if (v32)
      {
        if (*(unsigned char *)(v32 + 16)) {
          *(_WORD *)(v32 + 8) = 0;
        }
        *(_DWORD *)(v32 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = *(void *)(v1 + 248);
      if (result) {
        uint64_t result = sub_1008FB5A8(result);
      }
    }
  }
  int v33 = *(_DWORD *)(v1 + 400);
  if ((_BYTE)v33)
  {
    if (v33)
    {
      uint64_t v34 = *(void *)(v1 + 256);
      if ((_UNKNOWN *)v34 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v34 + 23) < 0)
        {
          **(unsigned char **)uint64_t v34 = 0;
          *(void *)(v34 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v34 = 0;
          *(unsigned char *)(v34 + 23) = 0;
        }
      }
    }
    int v33 = *(_DWORD *)(v1 + 400);
    if ((v33 & 2) != 0)
    {
      uint64_t result = *(void *)(v1 + 264);
      if (result)
      {
        uint64_t result = sub_1008D4D0C(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    *(_DWORD *)(v1 + 304) = 0;
    if ((v33 & 8) != 0)
    {
      uint64_t result = *(void *)(v1 + 272);
      if (result)
      {
        uint64_t result = sub_1008F5A0C(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    if ((v33 & 0x10) != 0)
    {
      uint64_t result = *(void *)(v1 + 280);
      if (result)
      {
        uint64_t result = sub_1008F6818(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    if ((v33 & 0x20) != 0)
    {
      uint64_t result = *(void *)(v1 + 288);
      if (result)
      {
        uint64_t result = sub_1008F9CB8(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    if ((v33 & 0x40) != 0)
    {
      uint64_t result = *(void *)(v1 + 296);
      if (result)
      {
        uint64_t result = sub_1008FD080(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    if ((v33 & 0x80) != 0)
    {
      uint64_t result = *(void *)(v1 + 312);
      if (result)
      {
        uint64_t result = sub_1008FE1B8(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
  }
  if ((v33 & 0xFF00) != 0)
  {
    if ((v33 & 0x100) != 0)
    {
      uint64_t result = *(void *)(v1 + 320);
      if (result)
      {
        uint64_t result = sub_1008FAB08(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    if ((v33 & 0x400) != 0)
    {
      uint64_t result = *(void *)(v1 + 344);
      if (result)
      {
        uint64_t result = sub_1008CBDF0(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
    *(_DWORD *)(v1 + 308) = 0;
    *(unsigned char *)(v1 + 368) = 0;
    *(_DWORD *)(v1 + 372) = 0;
    if ((v33 & 0x8000) != 0)
    {
      uint64_t result = *(void *)(v1 + 376);
      if (result)
      {
        uint64_t result = sub_1008D0D78(result);
        int v33 = *(_DWORD *)(v1 + 400);
      }
    }
  }
  if ((v33 & 0x10000) != 0)
  {
    uint64_t result = *(void *)(v1 + 384);
    if (result) {
      uint64_t result = sub_1008CD688(result);
    }
  }
  *(_DWORD *)(v1 + 336) = 0;
  *(_DWORD *)(v1 + 36sub_100FB8FC8(&a9, 0) = 0;
  *(void *)uint64_t v2 = 0;
  return result;
}

uint64_t sub_100FCFDB4(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned char *)(result + 36))
  {
    if (*(unsigned char *)(result + 36))
    {
      uint64_t result = *(void *)(result + 8);
      if (result) {
        uint64_t result = sub_100748AA0(result);
      }
    }
    *(_DWORD *)(v1 + 16) = 0;
    *(unsigned char *)(v1 + 2sub_100FB8FC8(&a9, 0) = 0;
    *(void *)(v1 + 24) = 0;
  }
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100FCFDFC(uint64_t result)
{
  if (*(unsigned char *)(result + 36))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100FCFE14(uint64_t a1)
{
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t sub_100FCFE40(uint64_t a1)
{
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t sub_100FCFE6C(uint64_t a1)
{
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t sub_100FCFE98(uint64_t result)
{
  if (*(unsigned char *)(result + 36))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100FCFEB0(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 76);
  if ((_BYTE)v1)
  {
    *(_OWORD *)(result + 49) = 0u;
    *(_OWORD *)(result + 4sub_100FB8FC8(&a9, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(unsigned char *)(result + 69) = 0;
    *(_DWORD *)(result + 65) = 0;
  }
  *(_DWORD *)(result + 76) = 0;
  return result;
}

uint64_t sub_100FCFEE8(uint64_t result)
{
  if (*(unsigned char *)(result + 32))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0x400000000;
    *(_DWORD *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FCFF0C(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 4;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FCFF28(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(_DWORD *)(result + 8) = 15;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FCFF40(uint64_t result)
{
  if (*(unsigned char *)(result + 44))
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
  }
  *(_DWORD *)(result + 44) = 0;
  return result;
}

uint64_t sub_100FCFF5C(uint64_t result)
{
  if (*(unsigned char *)(result + 36))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100FCFF74(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    if (*(unsigned char *)(result + 24))
    {
      uint64_t v1 = *(void *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(unsigned char **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v1 = 0;
          *(unsigned char *)(v1 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FCFFC0(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(unsigned char **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v1 = 0;
        *(unsigned char *)(v1 + 23) = 0;
      }
    }
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0004(uint64_t a1)
{
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t sub_100FD0030(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0044(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    *(unsigned char *)(result + 8) = 1;
    *(_DWORD *)(result + 9) = 0;
    *(unsigned char *)(result + 13) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0064(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0078(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    *(unsigned char *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0090(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD00A4(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(unsigned char *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FD00B8(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(unsigned char **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v1 = 0;
        *(unsigned char *)(v1 + 23) = 0;
      }
    }
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD00FC(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(unsigned char **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v1 = 0;
        *(unsigned char *)(v1 + 23) = 0;
      }
    }
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FD0140(uint64_t result)
{
  LOBYTE(v1) = *(unsigned char *)(result + 56);
  if ((_BYTE)v1)
  {
    *(unsigned char *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 48) = 0;
    if ((v1 & 8) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if (v2)
      {
        int v3 = *(_DWORD *)(v2 + 56);
        if ((_BYTE)v3)
        {
          *(_DWORD *)(v2 + 36) = 0;
          *(void *)(v2 + 16) = 0;
          *(void *)(v2 + 24) = 0;
          *(void *)(v2 + 8) = 0;
          *(unsigned char *)(v2 + 32) = 0;
        }
        if ((v3 & 0xFF00) != 0)
        {
          *(void *)(v2 + 4sub_100FB8FC8(&a9, 0) = 0;
          *(_DWORD *)(v2 + 48) = 0;
        }
        *(_DWORD *)(v2 + 56) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }
    if ((v1 & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(result + 24);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 52)) {
          *(void *)(v4 + 8) = 0;
        }
        *(_DWORD *)(v4 + 24) = 0;
        *(_DWORD *)(v4 + 4sub_100FB8FC8(&a9, 0) = 0;
        *(_DWORD *)(v4 + 52) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }
    if ((v1 & 0x20) != 0)
    {
      uint64_t v5 = *(void *)(result + 32);
      if (v5)
      {
        if ((*(_WORD *)(v5 + 36) & 0x1FE) != 0) {
          *(void *)(v5 + 24) = 0;
        }
        *(_DWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 36) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }
    if ((v1 & 0x40) != 0)
    {
      uint64_t v6 = *(void *)(result + 40);
      if (v6)
      {
        if (*(unsigned char *)(v6 + 20)) {
          *(void *)(v6 + 8) = 0;
        }
        *(_DWORD *)(v6 + 2sub_100FB8FC8(&a9, 0) = 0;
      }
    }
  }
  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t sub_100FD0208(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(_DWORD *)(result + 15) = 0;
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FD0220(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(_DWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FD0234(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FD024C(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(_WORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FD0260(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = (char **)((char *)this + 8);
  uint64_t v6 = a1 + 352;
  uint64_t v7 = a1 + 328;
  uint64_t v8 = (unsigned int *)(a1 + 16);
  uint64_t v9 = (unsigned int *)(a1 + 304);
  int v10 = (unsigned int *)(a1 + 308);
  v413 = (unint64_t *)(a1 + 8);
  v414 = (unsigned int *)(a1 + 372);
LABEL_2:
  while (2)
  {
    uint64_t v11 = (char *)*((void *)this + 1);
    if ((unint64_t)v11 >= *((void *)this + 2) || *v11 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v11;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v11 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        if ((unint64_t)v15 >= v14 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v413);
          if (!result) {
            return result;
          }
          uint64_t v16 = (char *)*((void *)this + 1);
          unint64_t v14 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v413 = *v15;
          uint64_t v16 = v15 + 1;
          void *v5 = v16;
        }
        *(_DWORD *)(a1 + 396) |= 1u;
        if ((unint64_t)v16 < v14 && *v16 == 16)
        {
          uint64_t v17 = v16 + 1;
          void *v5 = v17;
          goto LABEL_123;
        }
        continue;
      case 2u:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
LABEL_123:
        if ((unint64_t)v17 >= v14 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          uint64_t v31 = (char *)*((void *)this + 1);
          unint64_t v14 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v8 = *v17;
          uint64_t v31 = v17 + 1;
          void *v5 = v31;
        }
        *(_DWORD *)(a1 + 396) |= 2u;
        if ((unint64_t)v31 >= v14 || *v31 != 24) {
          continue;
        }
        uint64_t v18 = v31 + 1;
        void *v5 = v18;
LABEL_131:
        v416[0] = 0;
        if ((unint64_t)v18 >= v14 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416);
          if (!result) {
            return result;
          }
          unsigned int v32 = v416[0];
        }
        else
        {
          unsigned int v32 = *v18;
          void *v5 = v18 + 1;
        }
        if (sub_100FCD768())
        {
          *(_DWORD *)(a1 + 396) |= 4u;
          *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v32;
        }
        int v33 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v33 >= *((void *)this + 2) || *v33 != 34) {
          continue;
        }
        void *v5 = v33 + 1;
LABEL_141:
        *(_DWORD *)(a1 + 396) |= 8u;
        uint64_t v34 = *(void *)(a1 + 24);
        if (!v34) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v35 = (char *)*((void *)this + 1);
        if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v35;
          void *v5 = v35 + 1;
        }
        int v36 = *((_DWORD *)this + 14);
        int v37 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v36 + 1;
        if (v36 >= v37) {
          return 0;
        }
        int v38 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDD738(v34, this, v39) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v38);
        int v40 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v40, 1);
        int v42 = v40 - 1;
        if (v42 < 0 == v41) {
          *((_DWORD *)this + 14) = v42;
        }
        uint64_t v43 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v43 >= *((void *)this + 2) || *v43 != 42) {
          continue;
        }
        void *v5 = v43 + 1;
LABEL_155:
        *(_DWORD *)(a1 + 396) |= 0x10u;
        uint64_t v44 = *(void *)(a1 + 32);
        if (!v44) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v45 = (char *)*((void *)this + 1);
        if ((unint64_t)v45 >= *((void *)this + 2) || *v45 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v45;
          void *v5 = v45 + 1;
        }
        int v46 = *((_DWORD *)this + 14);
        int v47 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v46 + 1;
        if (v46 >= v47) {
          return 0;
        }
        int v48 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDDDEC(v44, this, v49) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v48);
        int v50 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v50, 1);
        int v51 = v50 - 1;
        if (v51 < 0 == v41) {
          *((_DWORD *)this + 14) = v51;
        }
        uint64_t v52 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v52 >= *((void *)this + 2) || *v52 != 50) {
          continue;
        }
        void *v5 = v52 + 1;
LABEL_169:
        *(_DWORD *)(a1 + 396) |= 0x20u;
        uint64_t v53 = *(int **)(a1 + 40);
        if (!v53) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v54 = (char *)*((void *)this + 1);
        if ((unint64_t)v54 >= *((void *)this + 2) || *v54 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v54;
          void *v5 = v54 + 1;
        }
        int v55 = *((_DWORD *)this + 14);
        int v56 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v55 + 1;
        if (v55 >= v56) {
          return 0;
        }
        int v57 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDE848(v53, this, v58) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v57);
        int v59 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v59, 1);
        int v60 = v59 - 1;
        if (v60 < 0 == v41) {
          *((_DWORD *)this + 14) = v60;
        }
        uint64_t v61 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v61 >= *((void *)this + 2) || *v61 != 58) {
          continue;
        }
        void *v5 = v61 + 1;
LABEL_183:
        *(_DWORD *)(a1 + 396) |= 0x40u;
        uint64_t v62 = *(int **)(a1 + 48);
        if (!v62) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v63 = (char *)*((void *)this + 1);
        if ((unint64_t)v63 >= *((void *)this + 2) || *v63 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v63;
          void *v5 = v63 + 1;
        }
        int v64 = *((_DWORD *)this + 14);
        int v65 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v64 + 1;
        if (v64 >= v65) {
          return 0;
        }
        int v66 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDECA4(v62, this, v67) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v66);
        int v68 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v68, 1);
        int v69 = v68 - 1;
        if (v69 < 0 == v41) {
          *((_DWORD *)this + 14) = v69;
        }
        uint64_t v70 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v70 >= *((void *)this + 2) || *v70 != 66) {
          continue;
        }
        void *v5 = v70 + 1;
LABEL_197:
        *(_DWORD *)(a1 + 396) |= 0x80u;
        uint64_t v71 = *(int **)(a1 + 56);
        if (!v71) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v72 = (char *)*((void *)this + 1);
        if ((unint64_t)v72 >= *((void *)this + 2) || *v72 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v72;
          void *v5 = v72 + 1;
        }
        int v73 = *((_DWORD *)this + 14);
        int v74 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v73 + 1;
        if (v73 >= v74) {
          return 0;
        }
        int v75 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDF100(v71, this, v76) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v75);
        int v77 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v77, 1);
        int v78 = v77 - 1;
        if (v78 < 0 == v41) {
          *((_DWORD *)this + 14) = v78;
        }
        uint64_t v79 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v79 >= *((void *)this + 2) || *v79 != 74) {
          continue;
        }
        void *v5 = v79 + 1;
LABEL_211:
        *(_DWORD *)(a1 + 396) |= 0x100u;
        uint64_t v80 = *(void *)(a1 + 64);
        if (!v80) {
          operator new();
        }
        v416[0] = 0;
        uint64_t v81 = (char *)*((void *)this + 1);
        if ((unint64_t)v81 >= *((void *)this + 2) || *v81 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v81;
          void *v5 = v81 + 1;
        }
        int v82 = *((_DWORD *)this + 14);
        int v83 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v82 + 1;
        if (v82 >= v83) {
          return 0;
        }
        int v84 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDF53C(v80, this, v85) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v84);
        int v86 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v86, 1);
        int v87 = v86 - 1;
        if (v87 < 0 == v41) {
          *((_DWORD *)this + 14) = v87;
        }
        int v88 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v88 >= *((void *)this + 2) || *v88 != 82) {
          continue;
        }
        void *v5 = v88 + 1;
LABEL_225:
        *(_DWORD *)(a1 + 396) |= 0x200u;
        uint64_t v89 = *(void *)(a1 + 72);
        if (!v89) {
          operator new();
        }
        v416[0] = 0;
        int v90 = (char *)*((void *)this + 1);
        if ((unint64_t)v90 >= *((void *)this + 2) || *v90 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v90;
          void *v5 = v90 + 1;
        }
        int v91 = *((_DWORD *)this + 14);
        int v92 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v91 + 1;
        if (v91 >= v92) {
          return 0;
        }
        int v93 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDF990(v89, this, v94) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v93);
        int v95 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v95, 1);
        int v96 = v95 - 1;
        if (v96 < 0 == v41) {
          *((_DWORD *)this + 14) = v96;
        }
        v97 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v97 >= *((void *)this + 2) || *v97 != 90) {
          continue;
        }
        void *v5 = v97 + 1;
LABEL_239:
        *(_DWORD *)(a1 + 396) |= 0x400u;
        v98 = *(_DWORD **)(a1 + 80);
        if (!v98) {
          operator new();
        }
        v416[0] = 0;
        v99 = (char *)*((void *)this + 1);
        if ((unint64_t)v99 >= *((void *)this + 2) || *v99 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v99;
          void *v5 = v99 + 1;
        }
        int v100 = *((_DWORD *)this + 14);
        int v101 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v100 + 1;
        if (v100 >= v101) {
          return 0;
        }
        int v102 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE0424(v98, this, v103) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v102);
        int v104 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v104, 1);
        int v105 = v104 - 1;
        if (v105 < 0 == v41) {
          *((_DWORD *)this + 14) = v105;
        }
        v106 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v106 >= *((void *)this + 2) || *v106 != 98) {
          continue;
        }
        void *v5 = v106 + 1;
LABEL_253:
        *(_DWORD *)(a1 + 396) |= 0x800u;
        uint64_t v107 = *(void *)(a1 + 88);
        if (!v107) {
          operator new();
        }
        v416[0] = 0;
        v108 = (char *)*((void *)this + 1);
        if ((unint64_t)v108 >= *((void *)this + 2) || *v108 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v108;
          void *v5 = v108 + 1;
        }
        int v109 = *((_DWORD *)this + 14);
        int v110 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v109 + 1;
        if (v109 >= v110) {
          return 0;
        }
        int v111 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE0A50(v107, this, v112) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v111);
        int v113 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v113, 1);
        int v114 = v113 - 1;
        if (v114 < 0 == v41) {
          *((_DWORD *)this + 14) = v114;
        }
        v115 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v115 >= *((void *)this + 2) || *v115 != 106) {
          continue;
        }
        void *v5 = v115 + 1;
LABEL_267:
        *(_DWORD *)(a1 + 396) |= 0x1000u;
        uint64_t v116 = *(void *)(a1 + 96);
        if (!v116) {
          operator new();
        }
        v416[0] = 0;
        v117 = (char *)*((void *)this + 1);
        if ((unint64_t)v117 >= *((void *)this + 2) || *v117 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v117;
          void *v5 = v117 + 1;
        }
        int v118 = *((_DWORD *)this + 14);
        int v119 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v118 + 1;
        if (v118 >= v119) {
          return 0;
        }
        int v120 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE0E78(v116, this, v121) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v120);
        int v122 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v122, 1);
        int v123 = v122 - 1;
        if (v123 < 0 == v41) {
          *((_DWORD *)this + 14) = v123;
        }
        v124 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v124 >= *((void *)this + 2) || *v124 != 114) {
          continue;
        }
        void *v5 = v124 + 1;
LABEL_281:
        *(_DWORD *)(a1 + 396) |= 0x2000u;
        uint64_t v125 = *(void *)(a1 + 104);
        if (!v125) {
          operator new();
        }
        v416[0] = 0;
        v126 = (char *)*((void *)this + 1);
        if ((unint64_t)v126 >= *((void *)this + 2) || *v126 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v126;
          void *v5 = v126 + 1;
        }
        int v127 = *((_DWORD *)this + 14);
        int v128 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v127 + 1;
        if (v127 >= v128) {
          return 0;
        }
        int v129 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE1198(v125, this, v130) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v129);
        int v131 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v131, 1);
        int v132 = v131 - 1;
        if (v132 < 0 == v41) {
          *((_DWORD *)this + 14) = v132;
        }
        v133 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v133 >= *((void *)this + 2) || *v133 != 122) {
          continue;
        }
        void *v5 = v133 + 1;
LABEL_295:
        *(_DWORD *)(a1 + 396) |= 0x4000u;
        uint64_t v134 = *(void *)(a1 + 112);
        if (!v134) {
          operator new();
        }
        v416[0] = 0;
        v135 = (char *)*((void *)this + 1);
        if ((unint64_t)v135 >= *((void *)this + 2) || *v135 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v135;
          void *v5 = v135 + 1;
        }
        int v136 = *((_DWORD *)this + 14);
        int v137 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v136 + 1;
        if (v136 >= v137) {
          return 0;
        }
        int v138 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE1684(v134, this, v139) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v138);
        int v140 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v140, 1);
        int v141 = v140 - 1;
        if (v141 < 0 == v41) {
          *((_DWORD *)this + 14) = v141;
        }
        v142 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v142 <= 1 || *v142 != 130 || v142[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v142 + 2);
LABEL_310:
        *(_DWORD *)(a1 + 396) |= 0x8000u;
        uint64_t v143 = *(void *)(a1 + 120);
        if (!v143) {
          operator new();
        }
        v416[0] = 0;
        v144 = (char *)*((void *)this + 1);
        if ((unint64_t)v144 >= *((void *)this + 2) || *v144 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v144;
          void *v5 = v144 + 1;
        }
        int v145 = *((_DWORD *)this + 14);
        int v146 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v145 + 1;
        if (v145 >= v146) {
          return 0;
        }
        int v147 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDCABC(v143, this, v148) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v147);
        int v149 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v149, 1);
        int v150 = v149 - 1;
        if (v150 < 0 == v41) {
          *((_DWORD *)this + 14) = v150;
        }
        v151 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v151 <= 1 || *v151 != 138 || v151[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v151 + 2);
LABEL_325:
        *(_DWORD *)(a1 + 396) |= 0x10000u;
        uint64_t v152 = *(void *)(a1 + 128);
        if (!v152) {
          operator new();
        }
        v416[0] = 0;
        v153 = (char *)*((void *)this + 1);
        if ((unint64_t)v153 >= *((void *)this + 2) || *v153 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v153;
          void *v5 = v153 + 1;
        }
        int v154 = *((_DWORD *)this + 14);
        int v155 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v154 + 1;
        if (v154 >= v155) {
          return 0;
        }
        int v156 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDCF64(v152, this, v157) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v156);
        int v158 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v158, 1);
        int v159 = v158 - 1;
        if (v159 < 0 == v41) {
          *((_DWORD *)this + 14) = v159;
        }
        v160 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v160 <= 1 || *v160 != 146 || v160[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v160 + 2);
LABEL_340:
        *(_DWORD *)(a1 + 396) |= 0x20000u;
        v161 = *(int **)(a1 + 136);
        if (!v161) {
          operator new();
        }
        v416[0] = 0;
        v162 = (char *)*((void *)this + 1);
        if ((unint64_t)v162 >= *((void *)this + 2) || *v162 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v162;
          void *v5 = v162 + 1;
        }
        int v163 = *((_DWORD *)this + 14);
        int v164 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v163 + 1;
        if (v163 >= v164) {
          return 0;
        }
        int v165 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDD2A8(v161, this, v166) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v165);
        int v167 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v167, 1);
        int v168 = v167 - 1;
        if (v168 < 0 == v41) {
          *((_DWORD *)this + 14) = v168;
        }
        v169 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v169 <= 1 || *v169 != 154 || v169[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v169 + 2);
LABEL_355:
        *(_DWORD *)(a1 + 396) |= 0x40000u;
        uint64_t v170 = *(void *)(a1 + 144);
        if (!v170) {
          operator new();
        }
        v416[0] = 0;
        v171 = (char *)*((void *)this + 1);
        if ((unint64_t)v171 >= *((void *)this + 2) || *v171 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v171;
          void *v5 = v171 + 1;
        }
        int v172 = *((_DWORD *)this + 14);
        int v173 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v172 + 1;
        if (v172 >= v173) {
          return 0;
        }
        int v174 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDE280(v170, this, v175) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v174);
        int v176 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v176, 1);
        int v177 = v176 - 1;
        if (v177 < 0 == v41) {
          *((_DWORD *)this + 14) = v177;
        }
        v178 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v178 <= 1 || *v178 != 162 || v178[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v178 + 2);
LABEL_370:
        *(_DWORD *)(a1 + 396) |= 0x80000u;
        uint64_t v179 = *(void *)(a1 + 152);
        if (!v179) {
          operator new();
        }
        v416[0] = 0;
        v180 = (char *)*((void *)this + 1);
        if ((unint64_t)v180 >= *((void *)this + 2) || *v180 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v180;
          void *v5 = v180 + 1;
        }
        int v181 = *((_DWORD *)this + 14);
        int v182 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v181 + 1;
        if (v181 >= v182) {
          return 0;
        }
        int v183 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDC3D8(v179, this, v184) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v183);
        int v185 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v185, 1);
        int v186 = v185 - 1;
        if (v186 < 0 == v41) {
          *((_DWORD *)this + 14) = v186;
        }
        v187 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v187 <= 1 || *v187 != 170 || v187[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v187 + 2);
LABEL_385:
        *(_DWORD *)(a1 + 396) |= 0x100000u;
        uint64_t v188 = *(void *)(a1 + 160);
        if (!v188) {
          operator new();
        }
        v416[0] = 0;
        v189 = (char *)*((void *)this + 1);
        if ((unint64_t)v189 >= *((void *)this + 2) || *v189 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v189;
          void *v5 = v189 + 1;
        }
        int v190 = *((_DWORD *)this + 14);
        int v191 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v190 + 1;
        if (v190 >= v191) {
          return 0;
        }
        int v192 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FDE550(v188, this, v193) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v192);
        int v194 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v194, 1);
        int v195 = v194 - 1;
        if (v195 < 0 == v41) {
          *((_DWORD *)this + 14) = v195;
        }
        v196 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v196 <= 1 || *v196 != 178 || v196[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v196 + 2);
LABEL_400:
        *(_DWORD *)(a1 + 396) |= 0x200000u;
        uint64_t v197 = *(void *)(a1 + 168);
        if (!v197) {
          operator new();
        }
        v416[0] = 0;
        v198 = (char *)*((void *)this + 1);
        if ((unint64_t)v198 >= *((void *)this + 2) || *v198 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v198;
          void *v5 = v198 + 1;
        }
        int v199 = *((_DWORD *)this + 14);
        int v200 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v199 + 1;
        if (v199 >= v200) {
          return 0;
        }
        int v201 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE1EB8(v197, this, v202) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v201);
        int v203 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v203, 1);
        int v204 = v203 - 1;
        if (v204 < 0 == v41) {
          *((_DWORD *)this + 14) = v204;
        }
        v205 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v205 <= 1 || *v205 != 186 || v205[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v205 + 2);
LABEL_415:
        *(_DWORD *)(a1 + 396) |= 0x400000u;
        v206 = *(unsigned int **)(a1 + 176);
        if (!v206) {
          operator new();
        }
        v416[0] = 0;
        v207 = (char *)*((void *)this + 1);
        if ((unint64_t)v207 >= *((void *)this + 2) || *v207 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v207;
          void *v5 = v207 + 1;
        }
        int v208 = *((_DWORD *)this + 14);
        int v209 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v208 + 1;
        if (v208 >= v209) {
          return 0;
        }
        int v210 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE22A4(v206, this, v211) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v210);
        int v212 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v212, 1);
        int v213 = v212 - 1;
        if (v213 < 0 == v41) {
          *((_DWORD *)this + 14) = v213;
        }
        v214 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v214 <= 1 || *v214 != 194 || v214[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v214 + 2);
LABEL_430:
        *(_DWORD *)(a1 + 396) |= 0x800000u;
        uint64_t v215 = *(void *)(a1 + 184);
        if (!v215) {
          operator new();
        }
        v416[0] = 0;
        v216 = (char *)*((void *)this + 1);
        if ((unint64_t)v216 >= *((void *)this + 2) || *v216 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v216;
          void *v5 = v216 + 1;
        }
        int v217 = *((_DWORD *)this + 14);
        int v218 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v217 + 1;
        if (v217 >= v218) {
          return 0;
        }
        int v219 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE2A54(v215, this, v220) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v219);
        int v221 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v221, 1);
        int v222 = v221 - 1;
        if (v222 < 0 == v41) {
          *((_DWORD *)this + 14) = v222;
        }
        v223 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v223 <= 1 || *v223 != 202 || v223[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v223 + 2);
LABEL_445:
        *(_DWORD *)(a1 + 396) |= 0x1000000u;
        uint64_t v224 = *(void *)(a1 + 192);
        if (!v224) {
          operator new();
        }
        v416[0] = 0;
        v225 = (char *)*((void *)this + 1);
        if ((unint64_t)v225 >= *((void *)this + 2) || *v225 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v225;
          void *v5 = v225 + 1;
        }
        int v226 = *((_DWORD *)this + 14);
        int v227 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v226 + 1;
        if (v226 >= v227) {
          return 0;
        }
        int v228 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE2D5C(v224, this, v229) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v228);
        int v230 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v230, 1);
        int v231 = v230 - 1;
        if (v231 < 0 == v41) {
          *((_DWORD *)this + 14) = v231;
        }
        v232 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v232 <= 1 || *v232 != 210 || v232[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v232 + 2);
LABEL_460:
        *(_DWORD *)(a1 + 396) |= 0x2000000u;
        uint64_t v233 = *(void *)(a1 + 200);
        if (!v233) {
          operator new();
        }
        v416[0] = 0;
        v234 = (char *)*((void *)this + 1);
        if ((unint64_t)v234 >= *((void *)this + 2) || *v234 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v234;
          void *v5 = v234 + 1;
        }
        int v235 = *((_DWORD *)this + 14);
        int v236 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v235 + 1;
        if (v235 >= v236) {
          return 0;
        }
        int v237 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE30C8(v233, this, v238) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v237);
        int v239 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v239, 1);
        int v240 = v239 - 1;
        if (v240 < 0 == v41) {
          *((_DWORD *)this + 14) = v240;
        }
        v241 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v241 <= 1 || *v241 != 218 || v241[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v241 + 2);
LABEL_475:
        *(_DWORD *)(a1 + 396) |= 0x4000000u;
        uint64_t v242 = *(void *)(a1 + 208);
        if (!v242) {
          operator new();
        }
        v416[0] = 0;
        v243 = (char *)*((void *)this + 1);
        if ((unint64_t)v243 >= *((void *)this + 2) || *v243 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v243;
          void *v5 = v243 + 1;
        }
        int v244 = *((_DWORD *)this + 14);
        int v245 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v244 + 1;
        if (v244 >= v245) {
          return 0;
        }
        int v246 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE71EC(v242, this, v247) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v246);
        int v248 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v248, 1);
        int v249 = v248 - 1;
        if (v249 < 0 == v41) {
          *((_DWORD *)this + 14) = v249;
        }
        v250 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v250 <= 1 || *v250 != 226 || v250[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v250 + 2);
LABEL_490:
        *(_DWORD *)(a1 + 396) |= 0x8000000u;
        uint64_t v251 = *(void *)(a1 + 216);
        if (!v251) {
          operator new();
        }
        v416[0] = 0;
        v252 = (char *)*((void *)this + 1);
        if ((unint64_t)v252 >= *((void *)this + 2) || *v252 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v252;
          void *v5 = v252 + 1;
        }
        int v253 = *((_DWORD *)this + 14);
        int v254 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v253 + 1;
        if (v253 >= v254) {
          return 0;
        }
        int v255 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE9CD4(v251, this, v256) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v255);
        int v257 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v257, 1);
        int v258 = v257 - 1;
        if (v258 < 0 == v41) {
          *((_DWORD *)this + 14) = v258;
        }
        v259 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v259 <= 1 || *v259 != 234 || v259[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v259 + 2);
LABEL_505:
        *(_DWORD *)(a1 + 396) |= 0x10000000u;
        uint64_t v260 = *(void *)(a1 + 224);
        if (!v260) {
          operator new();
        }
        v416[0] = 0;
        v261 = (char *)*((void *)this + 1);
        if ((unint64_t)v261 >= *((void *)this + 2) || *v261 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v261;
          void *v5 = v261 + 1;
        }
        int v262 = *((_DWORD *)this + 14);
        int v263 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v262 + 1;
        if (v262 >= v263) {
          return 0;
        }
        int v264 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE7D60(v260, this, v265) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v264);
        int v266 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v266, 1);
        int v267 = v266 - 1;
        if (v267 < 0 == v41) {
          *((_DWORD *)this + 14) = v267;
        }
        v268 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v268 <= 1 || *v268 != 242 || v268[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v268 + 2);
LABEL_520:
        *(_DWORD *)(a1 + 396) |= 0x20000000u;
        uint64_t v269 = *(void *)(a1 + 232);
        if (!v269) {
          operator new();
        }
        v416[0] = 0;
        v270 = (char *)*((void *)this + 1);
        if ((unint64_t)v270 >= *((void *)this + 2) || *v270 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v270;
          void *v5 = v270 + 1;
        }
        int v271 = *((_DWORD *)this + 14);
        int v272 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v271 + 1;
        if (v271 >= v272) {
          return 0;
        }
        int v273 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE1AC8(v269, this, v274) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v273);
        int v275 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v275, 1);
        int v276 = v275 - 1;
        if (v276 < 0 == v41) {
          *((_DWORD *)this + 14) = v276;
        }
        v277 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v277 <= 1 || *v277 != 250 || v277[1] != 1) {
          continue;
        }
        void *v5 = (char *)(v277 + 2);
LABEL_535:
        *(_DWORD *)(a1 + 396) |= 0x40000000u;
        uint64_t v278 = *(void *)(a1 + 240);
        if (!v278) {
          operator new();
        }
        v416[0] = 0;
        v279 = (char *)*((void *)this + 1);
        if ((unint64_t)v279 >= *((void *)this + 2) || *v279 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v279;
          void *v5 = v279 + 1;
        }
        int v280 = *((_DWORD *)this + 14);
        int v281 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v280 + 1;
        if (v280 >= v281) {
          return 0;
        }
        int v282 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_100FE26A4(v278, this, v283) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v282);
        int v284 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v284, 1);
        int v285 = v284 - 1;
        if (v285 < 0 == v41) {
          *((_DWORD *)this + 14) = v285;
        }
        v286 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v286 <= 1 || *v286 != 146 || v286[1] != 3) {
          continue;
        }
        void *v5 = (char *)(v286 + 2);
LABEL_550:
        *(_DWORD *)(a1 + 396) |= 0x80000000;
        uint64_t v287 = *(void *)(a1 + 248);
        if (!v287) {
          operator new();
        }
        v416[0] = 0;
        v288 = (char *)*((void *)this + 1);
        if ((unint64_t)v288 >= *((void *)this + 2) || *v288 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v288;
          void *v5 = v288 + 1;
        }
        int v289 = *((_DWORD *)this + 14);
        int v290 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v289 + 1;
        if (v289 >= v290) {
          return 0;
        }
        int v291 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008FB644(v287, this, v292) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v291);
        int v293 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v293, 1);
        int v294 = v293 - 1;
        if (v294 < 0 == v41) {
          *((_DWORD *)this + 14) = v294;
        }
        v295 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v295 <= 1 || *v295 != 154 || v295[1] != 3) {
          continue;
        }
        void *v5 = (char *)(v295 + 2);
LABEL_565:
        *(_DWORD *)(a1 + 400) |= 1u;
        if (*(_UNKNOWN **)(a1 + 256) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        v296 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v296 < 2 || *v296 != 226 || v296[1] != 3) {
          continue;
        }
        void *v5 = (char *)(v296 + 2);
LABEL_572:
        *(_DWORD *)(a1 + 400) |= 2u;
        v297 = *(unsigned int **)(a1 + 264);
        if (!v297) {
          operator new();
        }
        v416[0] = 0;
        v298 = (char *)*((void *)this + 1);
        if ((unint64_t)v298 >= *((void *)this + 2) || *v298 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v298;
          void *v5 = v298 + 1;
        }
        int v299 = *((_DWORD *)this + 14);
        int v300 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v299 + 1;
        if (v299 >= v300) {
          return 0;
        }
        int v301 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008D4D4C(v297, this, v302) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v301);
        int v303 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v303, 1);
        int v304 = v303 - 1;
        if (v304 < 0 == v41) {
          *((_DWORD *)this + 14) = v304;
        }
        v305 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        if ((int)v19 - (int)v305 <= 1 || *v305 != 232 || v305[1] != 3) {
          continue;
        }
        uint64_t v20 = (char *)(v305 + 2);
        void *v5 = v20;
LABEL_587:
        if ((unint64_t)v20 >= v19 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v9);
          if (!result) {
            return result;
          }
          v306 = (char *)*((void *)this + 1);
          unint64_t v19 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v9 = *v20;
          v306 = v20 + 1;
          void *v5 = v306;
        }
        int v28 = *(_DWORD *)(a1 + 400) | 4;
        *(_DWORD *)(a1 + 40sub_100FB8FC8(&a9, 0) = v28;
        if ((int)v19 - (int)v306 < 2 || *v306 != 242 || v306[1] != 3) {
          continue;
        }
        void *v5 = v306 + 2;
LABEL_596:
        *(_DWORD *)(a1 + 40sub_100FB8FC8(&a9, 0) = v28 | 8;
        v307 = *(_DWORD **)(a1 + 272);
        if (!v307) {
          operator new();
        }
        v416[0] = 0;
        v308 = (char *)*((void *)this + 1);
        if ((unint64_t)v308 >= *((void *)this + 2) || *v308 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v308;
          void *v5 = v308 + 1;
        }
        int v309 = *((_DWORD *)this + 14);
        int v310 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v309 + 1;
        if (v309 >= v310) {
          return 0;
        }
        int v311 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008F5A5C(v307, this, v312) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v311);
        int v313 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v313, 1);
        int v314 = v313 - 1;
        if (v314 < 0 == v41) {
          *((_DWORD *)this + 14) = v314;
        }
        v315 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v315 <= 1 || *v315 != 250 || v315[1] != 3) {
          continue;
        }
        void *v5 = (char *)(v315 + 2);
LABEL_611:
        *(_DWORD *)(a1 + 400) |= 0x10u;
        v316 = *(unsigned int **)(a1 + 280);
        if (!v316) {
          operator new();
        }
        v416[0] = 0;
        v317 = (char *)*((void *)this + 1);
        if ((unint64_t)v317 >= *((void *)this + 2) || *v317 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v317;
          void *v5 = v317 + 1;
        }
        int v318 = *((_DWORD *)this + 14);
        int v319 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v318 + 1;
        if (v318 >= v319) {
          return 0;
        }
        int v320 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008F6848(v316, this, v321) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v320);
        int v322 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v322, 1);
        int v323 = v322 - 1;
        if (v323 < 0 == v41) {
          *((_DWORD *)this + 14) = v323;
        }
        v324 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v324 <= 1 || *v324 != 130 || v324[1] != 4) {
          continue;
        }
        void *v5 = (char *)(v324 + 2);
LABEL_626:
        *(_DWORD *)(a1 + 400) |= 0x20u;
        v325 = *(_DWORD **)(a1 + 288);
        if (!v325) {
          operator new();
        }
        v416[0] = 0;
        v326 = (char *)*((void *)this + 1);
        if ((unint64_t)v326 >= *((void *)this + 2) || *v326 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v326;
          void *v5 = v326 + 1;
        }
        int v327 = *((_DWORD *)this + 14);
        int v328 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v327 + 1;
        if (v327 >= v328) {
          return 0;
        }
        int v329 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008F9CF0(v325, this, v330) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v329);
        int v331 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v331, 1);
        int v332 = v331 - 1;
        if (v332 < 0 == v41) {
          *((_DWORD *)this + 14) = v332;
        }
        v333 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v333 <= 1 || *v333 != 138 || v333[1] != 4) {
          continue;
        }
        void *v5 = (char *)(v333 + 2);
LABEL_641:
        *(_DWORD *)(a1 + 400) |= 0x40u;
        uint64_t v334 = *(void *)(a1 + 296);
        if (!v334) {
          operator new();
        }
        v416[0] = 0;
        v335 = (char *)*((void *)this + 1);
        if ((unint64_t)v335 >= *((void *)this + 2) || *v335 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v335;
          void *v5 = v335 + 1;
        }
        int v336 = *((_DWORD *)this + 14);
        int v337 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v336 + 1;
        if (v336 >= v337) {
          return 0;
        }
        int v338 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008FD0CC(v334, this, v339) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v338);
        int v340 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v340, 1);
        int v341 = v340 - 1;
        if (v341 < 0 == v41) {
          *((_DWORD *)this + 14) = v341;
        }
        v342 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v342 <= 1 || *v342 != 146 || v342[1] != 4) {
          continue;
        }
        void *v5 = (char *)(v342 + 2);
LABEL_656:
        *(_DWORD *)(a1 + 400) |= 0x80u;
        uint64_t v343 = *(void *)(a1 + 312);
        if (!v343) {
          operator new();
        }
        v416[0] = 0;
        v344 = (char *)*((void *)this + 1);
        if ((unint64_t)v344 >= *((void *)this + 2) || *v344 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v344;
          void *v5 = v344 + 1;
        }
        int v345 = *((_DWORD *)this + 14);
        int v346 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v345 + 1;
        if (v345 >= v346) {
          return 0;
        }
        int v347 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008FE1F8(v343, this, v348) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v347);
        int v349 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v349, 1);
        int v350 = v349 - 1;
        if (v350 < 0 == v41) {
          *((_DWORD *)this + 14) = v350;
        }
        v351 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v351 <= 1 || *v351 != 154 || v351[1] != 4) {
          continue;
        }
        void *v5 = (char *)(v351 + 2);
LABEL_671:
        *(_DWORD *)(a1 + 400) |= 0x100u;
        uint64_t v352 = *(void *)(a1 + 320);
        if (!v352) {
          operator new();
        }
        v416[0] = 0;
        v353 = (char *)*((void *)this + 1);
        if ((unint64_t)v353 >= *((void *)this + 2) || *v353 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
        }
          }
        else
        {
          v416[0] = *v353;
          void *v5 = v353 + 1;
        }
        int v354 = *((_DWORD *)this + 14);
        int v355 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v354 + 1;
        if (v354 >= v355) {
          return 0;
        }
        int v356 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
        if (!sub_1008FAB6C(v352, this, v357) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v356);
        int v358 = *((_DWORD *)this + 14);
        BOOL v41 = __OFSUB__(v358, 1);
        int v359 = v358 - 1;
        if (v359 < 0 == v41) {
          *((_DWORD *)this + 14) = v359;
        }
        v360 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v21 = *((void *)this + 2);
        if ((int)v21 - (int)v360 > 1 && *v360 == 176 && v360[1] == 4) {
          goto LABEL_685;
        }
        continue;
      case 3u:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_131;
      case 4u:
        int v13 = TagFallback & 7;
        if (v13 != 2) {
          goto LABEL_111;
        }
        goto LABEL_141;
      case 5u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_155;
        }
        goto LABEL_111;
      case 6u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_169;
        }
        goto LABEL_111;
      case 7u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_183;
        }
        goto LABEL_111;
      case 8u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_197;
        }
        goto LABEL_111;
      case 9u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_211;
        }
        goto LABEL_111;
      case 0xAu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_225;
        }
        goto LABEL_111;
      case 0xBu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_239;
        }
        goto LABEL_111;
      case 0xCu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_253;
        }
        goto LABEL_111;
      case 0xDu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_267;
        }
        goto LABEL_111;
      case 0xEu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_281;
        }
        goto LABEL_111;
      case 0xFu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_295;
        }
        goto LABEL_111;
      case 0x10u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_310;
        }
        goto LABEL_111;
      case 0x11u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_325;
        }
        goto LABEL_111;
      case 0x12u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_340;
        }
        goto LABEL_111;
      case 0x13u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_355;
        }
        goto LABEL_111;
      case 0x14u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_370;
        }
        goto LABEL_111;
      case 0x15u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_385;
        }
        goto LABEL_111;
      case 0x16u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_400;
        }
        goto LABEL_111;
      case 0x17u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_415;
        }
        goto LABEL_111;
      case 0x18u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_430;
        }
        goto LABEL_111;
      case 0x19u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_445;
        }
        goto LABEL_111;
      case 0x1Au:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_460;
        }
        goto LABEL_111;
      case 0x1Bu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_475;
        }
        goto LABEL_111;
      case 0x1Cu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_490;
        }
        goto LABEL_111;
      case 0x1Du:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_505;
        }
        goto LABEL_111;
      case 0x1Eu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_520;
        }
        goto LABEL_111;
      case 0x1Fu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_535;
        }
        goto LABEL_111;
      case 0x32u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_550;
        }
        goto LABEL_111;
      case 0x33u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_565;
        }
        goto LABEL_111;
      case 0x3Cu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_572;
        }
        goto LABEL_111;
      case 0x3Du:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v20 = (char *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        goto LABEL_587;
      case 0x3Eu:
        int v13 = TagFallback & 7;
        if (v13 != 2) {
          goto LABEL_111;
        }
        int v28 = *(_DWORD *)(a1 + 400);
        goto LABEL_596;
      case 0x3Fu:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_611;
        }
        goto LABEL_111;
      case 0x40u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_626;
        }
        goto LABEL_111;
      case 0x41u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_641;
        }
        goto LABEL_111;
      case 0x42u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_656;
        }
        goto LABEL_111;
      case 0x43u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_671;
        }
        goto LABEL_111;
      case 0x46u:
        int v13 = TagFallback & 7;
        if (v13 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            uint64_t v22 = (char *)*((void *)this + 1);
            unint64_t v21 = *((void *)this + 2);
            goto LABEL_686;
          }
          goto LABEL_111;
        }
        uint64_t result = sub_1008CEA24(this, v7);
        if (!result) {
          return result;
        }
        while (1)
        {
          v360 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v21 = *((void *)this + 2);
          if ((int)v21 - (int)v360 < 2) {
            goto LABEL_2;
          }
          int v371 = *v360;
          if (v371 == 186)
          {
            if (v360[1] != 4) {
              goto LABEL_2;
            }
            void *v5 = (char *)(v360 + 2);
LABEL_711:
            *(_DWORD *)(a1 + 400) |= 0x400u;
            v372 = *(int **)(a1 + 344);
            if (!v372) {
              operator new();
            }
            v416[0] = 0;
            v373 = (char *)*((void *)this + 1);
            if ((unint64_t)v373 >= *((void *)this + 2) || *v373 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
            }
              }
            else
            {
              v416[0] = *v373;
              void *v5 = v373 + 1;
            }
            int v374 = *((_DWORD *)this + 14);
            int v375 = *((_DWORD *)this + 15);
            *((_DWORD *)this + 14) = v374 + 1;
            if (v374 >= v375) {
              return 0;
            }
            int v376 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
            if (!sub_1008CBE38(v372, this, v377) || !*((unsigned char *)this + 36)) {
              return 0;
            }
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v376);
            int v378 = *((_DWORD *)this + 14);
            BOOL v41 = __OFSUB__(v378, 1);
            int v379 = v378 - 1;
            if (v379 < 0 == v41) {
              *((_DWORD *)this + 14) = v379;
            }
            v380 = (unsigned __int8 *)*((void *)this + 1);
            unint64_t v23 = *((void *)this + 2);
            if ((int)v23 - (int)v380 <= 1 || *v380 != 192 || v380[1] != 4) {
              goto LABEL_2;
            }
            uint64_t v24 = (char *)(v380 + 2);
            void *v5 = v24;
LABEL_726:
            if ((unint64_t)v24 >= v23 || *v24 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v10);
              if (!result) {
                return result;
              }
              v381 = (char *)*((void *)this + 1);
              unint64_t v23 = *((void *)this + 2);
            }
            else
            {
              *int v10 = *v24;
              v381 = v24 + 1;
              void *v5 = v381;
            }
            *(_DWORD *)(a1 + 400) |= 0x800u;
            if ((int)v23 - (int)v381 < 2 || *v381 != 200 || v381[1] != 4) {
              goto LABEL_2;
            }
            goto LABEL_734;
          }
          if (v371 != 176 || v360[1] != 4) {
            goto LABEL_2;
          }
LABEL_685:
          uint64_t v22 = (char *)(v360 + 2);
          void *v5 = v22;
LABEL_686:
          unsigned int v415 = 0;
          if ((unint64_t)v22 >= v21 || *v22 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v415))return 0; {
          }
            }
          else
          {
            unsigned int v415 = *v22;
            void *v5 = v22 + 1;
          }
          int v361 = *(_DWORD *)(a1 + 336);
          if (v361 == *(_DWORD *)(a1 + 340))
          {
            sub_100221DFC(v7, v361 + 1);
            int v361 = *(_DWORD *)(a1 + 336);
          }
          unsigned int v362 = v415;
          uint64_t v363 = *(void *)(a1 + 328);
          *(_DWORD *)(a1 + 336) = v361 + 1;
          *(_DWORD *)(v363 + 4 * v361) = v362;
          int v364 = *(_DWORD *)(a1 + 340) - *(_DWORD *)(a1 + 336);
          if (v364 >= 1)
          {
            int v365 = v364 + 1;
            do
            {
              v366 = (unsigned __int8 *)*((void *)this + 1);
              unint64_t v367 = *((void *)this + 2);
              if ((int)v367 - (int)v366 < 2 || *v366 != 176 || v366[1] != 4) {
                break;
              }
              void *v5 = (char *)(v366 + 2);
              if ((unint64_t)(v366 + 2) >= v367 || (char)v366[2] < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v415))return 0; {
              }
                }
              else
              {
                unsigned int v415 = v366[2];
                void *v5 = (char *)(v366 + 3);
              }
              int v368 = *(_DWORD *)(a1 + 336);
              if (v368 >= *(_DWORD *)(a1 + 340))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v416);
                int v368 = *(_DWORD *)(a1 + 336);
              }
              unsigned int v369 = v415;
              uint64_t v370 = *(void *)(a1 + 328);
              *(_DWORD *)(a1 + 336) = v368 + 1;
              *(_DWORD *)(v370 + 4 * v368) = v369;
              --v365;
            }
            while (v365 > 1);
          }
        }
      case 0x47u:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_711;
        }
        goto LABEL_111;
      case 0x48u:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v24 = (char *)*((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        goto LABEL_726;
      case 0x49u:
        int v13 = TagFallback & 7;
        if (v13 == 2)
        {
          uint64_t result = sub_1008CEA24(this, v6);
          if (!result) {
            return result;
          }
          while (1)
          {
            v381 = (char *)*((void *)this + 1);
            unint64_t v23 = *((void *)this + 2);
            if ((int)v23 - (int)v381 < 2) {
              goto LABEL_2;
            }
            int v392 = *v381;
            if (v392 == 208)
            {
              if (v381[1] == 4)
              {
                uint64_t v26 = v381 + 2;
                void *v5 = v26;
LABEL_760:
                v416[0] = 0;
                if ((unint64_t)v26 >= v23 || *v26 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416);
                  if (!result) {
                    return result;
                  }
                  unsigned int v393 = v416[0];
                  v394 = (char *)*((void *)this + 1);
                  unint64_t v23 = *((void *)this + 2);
                }
                else
                {
                  unsigned int v393 = *v26;
                  v394 = v26 + 1;
                  void *v5 = v394;
                }
                *(unsigned char *)(a1 + 368) = v393 != 0;
                *(_DWORD *)(a1 + 400) |= 0x2000u;
                if ((int)v23 - (int)v394 >= 2 && *v394 == 216 && v394[1] == 4)
                {
                  uint64_t v27 = v394 + 2;
                  void *v5 = v27;
LABEL_769:
                  if ((unint64_t)v27 >= v23 || *v27 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v414);
                    if (!result) {
                      return result;
                    }
                    v395 = (char *)*((void *)this + 1);
                    unint64_t v23 = *((void *)this + 2);
                  }
                  else
                  {
                    unsigned int *v414 = *v27;
                    v395 = v27 + 1;
                    void *v5 = v395;
                  }
                  int v29 = *(_DWORD *)(a1 + 400) | 0x4000;
                  *(_DWORD *)(a1 + 40sub_100FB8FC8(&a9, 0) = v29;
                  if ((int)v23 - (int)v395 >= 2 && *v395 == 226 && v395[1] == 4)
                  {
                    void *v5 = v395 + 2;
LABEL_778:
                    *(_DWORD *)(a1 + 40sub_100FB8FC8(&a9, 0) = v29 | 0x8000;
                    uint64_t v396 = *(void *)(a1 + 376);
                    if (!v396) {
                      operator new();
                    }
                    v416[0] = 0;
                    v397 = (char *)*((void *)this + 1);
                    if ((unint64_t)v397 >= *((void *)this + 2) || *v397 < 0)
                    {
                      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
                    }
                      }
                    else
                    {
                      v416[0] = *v397;
                      void *v5 = v397 + 1;
                    }
                    int v398 = *((_DWORD *)this + 14);
                    int v399 = *((_DWORD *)this + 15);
                    *((_DWORD *)this + 14) = v398 + 1;
                    if (v398 >= v399) {
                      return 0;
                    }
                    int v400 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
                    if (!sub_1008D0E6C(v396, this, v401) || !*((unsigned char *)this + 36)) {
                      return 0;
                    }
                    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v400);
                    int v402 = *((_DWORD *)this + 14);
                    BOOL v41 = __OFSUB__(v402, 1);
                    int v403 = v402 - 1;
                    if (v403 < 0 == v41) {
                      *((_DWORD *)this + 14) = v403;
                    }
                    v404 = (unsigned __int8 *)*((void *)this + 1);
                    if (*((_DWORD *)this + 4) - (int)v404 > 1 && *v404 == 234 && v404[1] == 4)
                    {
                      void *v5 = (char *)(v404 + 2);
LABEL_793:
                      *(_DWORD *)(a1 + 400) |= 0x10000u;
                      v405 = *(int **)(a1 + 384);
                      if (!v405) {
                        operator new();
                      }
                      v416[0] = 0;
                      v406 = (char *)*((void *)this + 1);
                      if ((unint64_t)v406 >= *((void *)this + 2) || *v406 < 0)
                      {
                        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v416))return 0; {
                      }
                        }
                      else
                      {
                        v416[0] = *v406;
                        void *v5 = v406 + 1;
                      }
                      int v407 = *((_DWORD *)this + 14);
                      int v408 = *((_DWORD *)this + 15);
                      *((_DWORD *)this + 14) = v407 + 1;
                      if (v407 >= v408) {
                        return 0;
                      }
                      int v409 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v416[0]);
                      if (!sub_1008CD6C0(v405, this, v410) || !*((unsigned char *)this + 36)) {
                        return 0;
                      }
                      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v409);
                      int v411 = *((_DWORD *)this + 14);
                      BOOL v41 = __OFSUB__(v411, 1);
                      int v412 = v411 - 1;
                      if (v412 < 0 == v41) {
                        *((_DWORD *)this + 14) = v412;
                      }
                      if (*((void *)this + 1) == *((void *)this + 2)
                        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                      {
                        *((_DWORD *)this + 8) = 0;
                        uint64_t result = 1;
                        *((unsigned char *)this + 36) = 1;
                        return result;
                      }
                    }
                  }
                }
              }
              goto LABEL_2;
            }
            if (v392 != 200 || v381[1] != 4) {
              goto LABEL_2;
            }
LABEL_734:
            uint64_t v25 = v381 + 2;
            void *v5 = v25;
LABEL_735:
            unsigned int v415 = 0;
            if ((unint64_t)v25 >= v23 || *v25 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v415))return 0; {
            }
              }
            else
            {
              unsigned int v415 = *v25;
              void *v5 = v25 + 1;
            }
            int v382 = *(_DWORD *)(a1 + 360);
            if (v382 == *(_DWORD *)(a1 + 364))
            {
              sub_100221DFC(v6, v382 + 1);
              int v382 = *(_DWORD *)(a1 + 360);
            }
            unsigned int v383 = v415;
            uint64_t v384 = *(void *)(a1 + 352);
            *(_DWORD *)(a1 + 36sub_100FB8FC8(&a9, 0) = v382 + 1;
            *(_DWORD *)(v384 + 4 * v382) = v383;
            int v385 = *(_DWORD *)(a1 + 364) - *(_DWORD *)(a1 + 360);
            if (v385 >= 1)
            {
              int v386 = v385 + 1;
              do
              {
                v387 = (unsigned __int8 *)*((void *)this + 1);
                unint64_t v388 = *((void *)this + 2);
                if ((int)v388 - (int)v387 < 2 || *v387 != 200 || v387[1] != 4) {
                  break;
                }
                void *v5 = (char *)(v387 + 2);
                if ((unint64_t)(v387 + 2) >= v388 || (char)v387[2] < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v415))return 0; {
                }
                  }
                else
                {
                  unsigned int v415 = v387[2];
                  void *v5 = (char *)(v387 + 3);
                }
                int v389 = *(_DWORD *)(a1 + 360);
                if (v389 >= *(_DWORD *)(a1 + 364))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v416);
                  int v389 = *(_DWORD *)(a1 + 360);
                }
                unsigned int v390 = v415;
                uint64_t v391 = *(void *)(a1 + 352);
                *(_DWORD *)(a1 + 36sub_100FB8FC8(&a9, 0) = v389 + 1;
                *(_DWORD *)(v391 + 4 * v389) = v390;
                --v386;
              }
              while (v386 > 1);
            }
          }
        }
        if ((TagFallback & 7) == 0)
        {
          uint64_t v25 = (char *)*((void *)this + 1);
          unint64_t v23 = *((void *)this + 2);
          goto LABEL_735;
        }
LABEL_111:
        if (v13 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
      case 0x4Au:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v26 = (char *)*((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        goto LABEL_760;
      case 0x4Bu:
        int v13 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_111;
        }
        uint64_t v27 = (char *)*((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        goto LABEL_769;
      case 0x4Cu:
        int v13 = TagFallback & 7;
        if (v13 != 2) {
          goto LABEL_111;
        }
        int v29 = *(_DWORD *)(a1 + 400);
        goto LABEL_778;
      case 0x4Du:
        int v13 = TagFallback & 7;
        if (v13 == 2) {
          goto LABEL_793;
        }
        goto LABEL_111;
      default:
        int v13 = TagFallback & 7;
        goto LABEL_111;
    }
  }
}

void sub_100FD3794()
{
}

uint64_t sub_100FD39D8(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 396);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 396);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_36;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 16), a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_37;
  }
LABEL_36:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 20), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_40;
  }
LABEL_37:
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_10248AFD8 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_43;
  }
LABEL_40:
  uint64_t v8 = *(void *)(v5 + 32);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_10248AFD8 + 32);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_46;
  }
LABEL_43:
  uint64_t v9 = *(void *)(v5 + 40);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248AFD8 + 40);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_49;
  }
LABEL_46:
  uint64_t v10 = *(void *)(v5 + 48);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_10248AFD8 + 48);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v10, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_52;
  }
LABEL_49:
  uint64_t v11 = *(void *)(v5 + 56);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_10248AFD8 + 56);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, v11, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_55;
  }
LABEL_52:
  uint64_t v12 = *(void *)(v5 + 64);
  if (!v12) {
    uint64_t v12 = *(void *)(qword_10248AFD8 + 64);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v12, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_58;
  }
LABEL_55:
  uint64_t v13 = *(void *)(v5 + 72);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248AFD8 + 72);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v13, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_61;
  }
LABEL_58:
  uint64_t v14 = *(void *)(v5 + 80);
  if (!v14) {
    uint64_t v14 = *(void *)(qword_10248AFD8 + 80);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v14, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_64;
  }
LABEL_61:
  uint64_t v15 = *(void *)(v5 + 88);
  if (!v15) {
    uint64_t v15 = *(void *)(qword_10248AFD8 + 88);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v15, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_67;
  }
LABEL_64:
  uint64_t v16 = *(void *)(v5 + 96);
  if (!v16) {
    uint64_t v16 = *(void *)(qword_10248AFD8 + 96);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v16, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x2000) == 0)
  {
LABEL_15:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_70;
  }
LABEL_67:
  uint64_t v17 = *(void *)(v5 + 104);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248AFD8 + 104);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v17, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x4000) == 0)
  {
LABEL_16:
    if ((v6 & 0x8000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_73;
  }
LABEL_70:
  uint64_t v18 = *(void *)(v5 + 112);
  if (!v18) {
    uint64_t v18 = *(void *)(qword_10248AFD8 + 112);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v18, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x8000) == 0)
  {
LABEL_17:
    if ((v6 & 0x10000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_76;
  }
LABEL_73:
  uint64_t v19 = *(void *)(v5 + 120);
  if (!v19) {
    uint64_t v19 = *(void *)(qword_10248AFD8 + 120);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, v19, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x10000) == 0)
  {
LABEL_18:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_79;
  }
LABEL_76:
  uint64_t v20 = *(void *)(v5 + 128);
  if (!v20) {
    uint64_t v20 = *(void *)(qword_10248AFD8 + 128);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v20, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x20000) == 0)
  {
LABEL_19:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_82;
  }
LABEL_79:
  uint64_t v21 = *(void *)(v5 + 136);
  if (!v21) {
    uint64_t v21 = *(void *)(qword_10248AFD8 + 136);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, v21, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x40000) == 0)
  {
LABEL_20:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_85;
  }
LABEL_82:
  uint64_t v22 = *(void *)(v5 + 144);
  if (!v22) {
    uint64_t v22 = *(void *)(qword_10248AFD8 + 144);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v22, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x80000) == 0)
  {
LABEL_21:
    if ((v6 & 0x100000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_88;
  }
LABEL_85:
  uint64_t v23 = *(void *)(v5 + 152);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_10248AFD8 + 152);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, v23, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x100000) == 0)
  {
LABEL_22:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_91;
  }
LABEL_88:
  uint64_t v24 = *(void *)(v5 + 160);
  if (!v24) {
    uint64_t v24 = *(void *)(qword_10248AFD8 + 160);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v24, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x200000) == 0)
  {
LABEL_23:
    if ((v6 & 0x400000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_94;
  }
LABEL_91:
  uint64_t v25 = *(void *)(v5 + 168);
  if (!v25) {
    uint64_t v25 = *(void *)(qword_10248AFD8 + 168);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x16, v25, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x400000) == 0)
  {
LABEL_24:
    if ((v6 & 0x800000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_97;
  }
LABEL_94:
  uint64_t v26 = *(void *)(v5 + 176);
  if (!v26) {
    uint64_t v26 = *(void *)(qword_10248AFD8 + 176);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x17, v26, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x800000) == 0)
  {
LABEL_25:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_100;
  }
LABEL_97:
  uint64_t v27 = *(void *)(v5 + 184);
  if (!v27) {
    uint64_t v27 = *(void *)(qword_10248AFD8 + 184);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x18, v27, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x1000000) == 0)
  {
LABEL_26:
    if ((v6 & 0x2000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_103;
  }
LABEL_100:
  uint64_t v28 = *(void *)(v5 + 192);
  if (!v28) {
    uint64_t v28 = *(void *)(qword_10248AFD8 + 192);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x19, v28, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x2000000) == 0)
  {
LABEL_27:
    if ((v6 & 0x4000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_106;
  }
LABEL_103:
  uint64_t v29 = *(void *)(v5 + 200);
  if (!v29) {
    uint64_t v29 = *(void *)(qword_10248AFD8 + 200);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1A, v29, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x4000000) == 0)
  {
LABEL_28:
    if ((v6 & 0x8000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_109;
  }
LABEL_106:
  uint64_t v30 = *(void *)(v5 + 208);
  if (!v30) {
    uint64_t v30 = *(void *)(qword_10248AFD8 + 208);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1B, v30, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x8000000) == 0)
  {
LABEL_29:
    if ((v6 & 0x10000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_112;
  }
LABEL_109:
  uint64_t v31 = *(void *)(v5 + 216);
  if (!v31) {
    uint64_t v31 = *(void *)(qword_10248AFD8 + 216);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1C, v31, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x10000000) == 0)
  {
LABEL_30:
    if ((v6 & 0x20000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_115;
  }
LABEL_112:
  uint64_t v32 = *(void *)(v5 + 224);
  if (!v32) {
    uint64_t v32 = *(void *)(qword_10248AFD8 + 224);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1D, v32, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x20000000) == 0)
  {
LABEL_31:
    if ((v6 & 0x40000000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_118;
  }
LABEL_115:
  uint64_t v33 = *(void *)(v5 + 232);
  if (!v33) {
    uint64_t v33 = *(void *)(qword_10248AFD8 + 232);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1E, v33, a2, a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 0x40000000) == 0)
  {
LABEL_32:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_124;
    }
    goto LABEL_121;
  }
LABEL_118:
  uint64_t v34 = *(void *)(v5 + 240);
  if (!v34) {
    uint64_t v34 = *(void *)(qword_10248AFD8 + 240);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1F, v34, a2, a4);
  if ((*(_DWORD *)(v5 + 396) & 0x80000000) != 0)
  {
LABEL_121:
    uint64_t v35 = *(void *)(v5 + 248);
    if (!v35) {
      uint64_t v35 = *(void *)(qword_10248AFD8 + 248);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x32, v35, a2, a4);
  }
LABEL_124:
  int v36 = *(_DWORD *)(v5 + 400);
  if (v36)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    int v36 = *(_DWORD *)(v5 + 400);
    if ((v36 & 2) == 0)
    {
LABEL_126:
      if ((v36 & 4) == 0) {
        goto LABEL_127;
      }
      goto LABEL_138;
    }
  }
  else if ((v36 & 2) == 0)
  {
    goto LABEL_126;
  }
  uint64_t v37 = *(void *)(v5 + 264);
  if (!v37) {
    uint64_t v37 = *(void *)(qword_10248AFD8 + 264);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x3C, v37, a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 4) == 0)
  {
LABEL_127:
    if ((v36 & 8) == 0) {
      goto LABEL_128;
    }
    goto LABEL_139;
  }
LABEL_138:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x3D, *(_DWORD *)(v5 + 304), a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 8) == 0)
  {
LABEL_128:
    if ((v36 & 0x10) == 0) {
      goto LABEL_129;
    }
    goto LABEL_142;
  }
LABEL_139:
  uint64_t v38 = *(void *)(v5 + 272);
  if (!v38) {
    uint64_t v38 = *(void *)(qword_10248AFD8 + 272);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x3E, v38, a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 0x10) == 0)
  {
LABEL_129:
    if ((v36 & 0x20) == 0) {
      goto LABEL_130;
    }
    goto LABEL_145;
  }
LABEL_142:
  uint64_t v39 = *(void *)(v5 + 280);
  if (!v39) {
    uint64_t v39 = *(void *)(qword_10248AFD8 + 280);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x3F, v39, a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 0x20) == 0)
  {
LABEL_130:
    if ((v36 & 0x40) == 0) {
      goto LABEL_131;
    }
    goto LABEL_148;
  }
LABEL_145:
  uint64_t v40 = *(void *)(v5 + 288);
  if (!v40) {
    uint64_t v40 = *(void *)(qword_10248AFD8 + 288);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x40, v40, a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 0x40) == 0)
  {
LABEL_131:
    if ((v36 & 0x80) == 0) {
      goto LABEL_132;
    }
    goto LABEL_151;
  }
LABEL_148:
  uint64_t v41 = *(void *)(v5 + 296);
  if (!v41) {
    uint64_t v41 = *(void *)(qword_10248AFD8 + 296);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x41, v41, a2, a4);
  int v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 0x80) == 0)
  {
LABEL_132:
    if ((v36 & 0x100) == 0) {
      goto LABEL_157;
    }
    goto LABEL_154;
  }
LABEL_151:
  uint64_t v42 = *(void *)(v5 + 312);
  if (!v42) {
    uint64_t v42 = *(void *)(qword_10248AFD8 + 312);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x42, v42, a2, a4);
  if ((*(_DWORD *)(v5 + 400) & 0x100) != 0)
  {
LABEL_154:
    uint64_t v43 = *(void *)(v5 + 320);
    if (!v43) {
      uint64_t v43 = *(void *)(qword_10248AFD8 + 320);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x43, v43, a2, a4);
  }
LABEL_157:
  if (*(int *)(v5 + 336) >= 1)
  {
    uint64_t v44 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x46, *(_DWORD *)(*(void *)(v5 + 328) + 4 * v44++), a2, a4);
    while (v44 < *(int *)(v5 + 336));
  }
  int v45 = *(_DWORD *)(v5 + 400);
  if ((v45 & 0x400) != 0)
  {
    uint64_t v46 = *(void *)(v5 + 344);
    if (!v46) {
      uint64_t v46 = *(void *)(qword_10248AFD8 + 344);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x47, v46, a2, a4);
    int v45 = *(_DWORD *)(v5 + 400);
  }
  if ((v45 & 0x800) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x48, *(_DWORD *)(v5 + 308), a2, a4);
  }
  if (*(int *)(v5 + 360) >= 1)
  {
    uint64_t v47 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x49, *(_DWORD *)(*(void *)(v5 + 352) + 4 * v47++), a2, a4);
    while (v47 < *(int *)(v5 + 360));
  }
  int v48 = *(_DWORD *)(v5 + 400);
  if ((v48 & 0x2000) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x4A, *(unsigned __int8 *)(v5 + 368), (BOOL)a2, a4);
    int v48 = *(_DWORD *)(v5 + 400);
    if ((v48 & 0x4000) == 0)
    {
LABEL_171:
      if ((v48 & 0x8000) == 0) {
        goto LABEL_172;
      }
      goto LABEL_176;
    }
  }
  else if ((v48 & 0x4000) == 0)
  {
    goto LABEL_171;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x4B, *(_DWORD *)(v5 + 372), a2, a4);
  int v48 = *(_DWORD *)(v5 + 400);
  if ((v48 & 0x8000) == 0)
  {
LABEL_172:
    if ((v48 & 0x10000) == 0) {
      return result;
    }
    goto LABEL_179;
  }
LABEL_176:
  uint64_t v49 = *(void *)(v5 + 376);
  if (!v49) {
    uint64_t v49 = *(void *)(qword_10248AFD8 + 376);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x4C, v49, a2, a4);
  if ((*(_DWORD *)(v5 + 400) & 0x10000) != 0)
  {
LABEL_179:
    uint64_t v50 = *(void *)(v5 + 384);
    if (!v50) {
      uint64_t v50 = *(void *)(qword_10248AFD8 + 384);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x4D, v50, a2, a4);
  }
  return result;
}

uint64_t sub_100FD4210(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_54;
  }
  if (v3)
  {
    int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 396);
  }
  else
  {
    int v6 = 1;
  }
  v4 += v6 + 1;
LABEL_11:
  if ((v3 & 4) != 0)
  {
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }
    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = *(_DWORD *)(a1 + 396);
    }
    else
    {
      int v8 = 1;
    }
    v4 += v8 + 1;
    if ((v3 & 8) == 0)
    {
LABEL_13:
      if ((v3 & 0x10) == 0) {
        goto LABEL_14;
      }
      goto LABEL_30;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_13;
  }
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248AFD8 + 24);
  }
  uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDDBA8(v9, a2);
  int v11 = (int)v10;
  if (v10 >= 0x80) {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
  }
  else {
    int v12 = 1;
  }
  v4 += v11 + v12 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x10) == 0)
  {
LABEL_14:
    if ((v3 & 0x20) == 0) {
      goto LABEL_15;
    }
    goto LABEL_36;
  }
LABEL_30:
  uint64_t v13 = *(void *)(a1 + 32);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248AFD8 + 32);
  }
  uint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDE09C(v13, a2);
  int v15 = (int)v14;
  if (v14 >= 0x80) {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14, a2);
  }
  else {
    int v16 = 1;
  }
  v4 += v15 + v16 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x20) == 0)
  {
LABEL_15:
    if ((v3 & 0x40) == 0) {
      goto LABEL_16;
    }
    goto LABEL_42;
  }
LABEL_36:
  uint64_t v17 = *(void *)(a1 + 40);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248AFD8 + 40);
  }
  uint64_t v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDEA9C(v17, a2);
  int v19 = (int)v18;
  if (v18 >= 0x80) {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v18, a2);
  }
  else {
    int v20 = 1;
  }
  v4 += v19 + v20 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x40) == 0)
  {
LABEL_16:
    if ((v3 & 0x80) == 0) {
      goto LABEL_54;
    }
    goto LABEL_48;
  }
LABEL_42:
  uint64_t v21 = *(void *)(a1 + 48);
  if (!v21) {
    uint64_t v21 = *(void *)(qword_10248AFD8 + 48);
  }
  uint64_t v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDEEF8(v21, a2);
  int v23 = (int)v22;
  if (v22 >= 0x80) {
    int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, a2);
  }
  else {
    int v24 = 1;
  }
  v4 += v23 + v24 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x80) != 0)
  {
LABEL_48:
    uint64_t v25 = *(void *)(a1 + 56);
    if (!v25) {
      uint64_t v25 = *(void *)(qword_10248AFD8 + 56);
    }
    uint64_t v26 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDF354(v25, a2);
    int v27 = (int)v26;
    if (v26 >= 0x80) {
      int v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v26, a2);
    }
    else {
      int v28 = 1;
    }
    v4 += v27 + v28 + 1;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
  }
LABEL_54:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_112;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v29 = *(void *)(a1 + 64);
    if (!v29) {
      uint64_t v29 = *(void *)(qword_10248AFD8 + 64);
    }
    uint64_t v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDF7B4(v29, a2);
    int v31 = (int)v30;
    if (v30 >= 0x80) {
      int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30, a2);
    }
    else {
      int v32 = 1;
    }
    v4 += v31 + v32 + 1;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
    if ((v3 & 0x200) == 0)
    {
LABEL_57:
      if ((v3 & 0x400) == 0) {
        goto LABEL_58;
      }
      goto LABEL_76;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_57;
  }
  uint64_t v33 = *(void *)(a1 + 72);
  if (!v33) {
    uint64_t v33 = *(void *)(qword_10248AFD8 + 72);
  }
  uint64_t v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE01CC(v33, a2);
  int v35 = (int)v34;
  if (v34 >= 0x80) {
    int v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34, a2);
  }
  else {
    int v36 = 1;
  }
  v4 += v35 + v36 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x400) == 0)
  {
LABEL_58:
    if ((v3 & 0x800) == 0) {
      goto LABEL_59;
    }
    goto LABEL_82;
  }
LABEL_76:
  uint64_t v37 = *(void *)(a1 + 80);
  if (!v37) {
    uint64_t v37 = *(void *)(qword_10248AFD8 + 80);
  }
  uint64_t v38 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE07EC(v37, a2);
  int v39 = (int)v38;
  if (v38 >= 0x80) {
    int v40 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v38, a2);
  }
  else {
    int v40 = 1;
  }
  v4 += v39 + v40 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x800) == 0)
  {
LABEL_59:
    if ((v3 & 0x1000) == 0) {
      goto LABEL_60;
    }
    goto LABEL_88;
  }
LABEL_82:
  uint64_t v41 = *(void *)(a1 + 88);
  if (!v41) {
    uint64_t v41 = *(void *)(qword_10248AFD8 + 88);
  }
  uint64_t v42 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE0C84(v41, a2);
  int v43 = (int)v42;
  if (v42 >= 0x80) {
    int v44 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v42, a2);
  }
  else {
    int v44 = 1;
  }
  v4 += v43 + v44 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x1000) == 0)
  {
LABEL_60:
    if ((v3 & 0x2000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_94;
  }
LABEL_88:
  uint64_t v45 = *(void *)(a1 + 96);
  if (!v45) {
    uint64_t v45 = *(void *)(qword_10248AFD8 + 96);
  }
  uint64_t v46 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE0FD0(v45, a2);
  int v47 = (int)v46;
  if (v46 >= 0x80) {
    int v48 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v46, a2);
  }
  else {
    int v48 = 1;
  }
  v4 += v47 + v48 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x2000) == 0)
  {
LABEL_61:
    if ((v3 & 0x4000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_100;
  }
LABEL_94:
  uint64_t v49 = *(void *)(a1 + 104);
  if (!v49) {
    uint64_t v49 = *(void *)(qword_10248AFD8 + 104);
  }
  uint64_t v50 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE14A8(v49, a2);
  int v51 = (int)v50;
  if (v50 >= 0x80) {
    int v52 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v50, a2);
  }
  else {
    int v52 = 1;
  }
  v4 += v51 + v52 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x4000) == 0)
  {
LABEL_62:
    if ((v3 & 0x8000) == 0) {
      goto LABEL_112;
    }
    goto LABEL_106;
  }
LABEL_100:
  uint64_t v53 = *(void *)(a1 + 112);
  if (!v53) {
    uint64_t v53 = *(void *)(qword_10248AFD8 + 112);
  }
  uint64_t v54 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE18FC(v53, a2);
  int v55 = (int)v54;
  if (v54 >= 0x80) {
    int v56 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v54, a2);
  }
  else {
    int v56 = 1;
  }
  v4 += v55 + v56 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x8000) != 0)
  {
LABEL_106:
    uint64_t v57 = *(void *)(a1 + 120);
    if (!v57) {
      uint64_t v57 = *(void *)(qword_10248AFD8 + 120);
    }
    unsigned int v58 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDCCEC(v57, a2);
    int v59 = (int)v58;
    if (v58 >= 0x80) {
      int v60 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v58, a2);
    }
    else {
      int v60 = 1;
    }
    v4 += v59 + v60 + 2;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
  }
LABEL_112:
  if ((v3 & 0xFF0000) == 0) {
    goto LABEL_174;
  }
  if ((v3 & 0x10000) != 0)
  {
    uint64_t v61 = *(void *)(a1 + 128);
    if (!v61) {
      uint64_t v61 = *(void *)(qword_10248AFD8 + 128);
    }
    uint64_t v62 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDD0A0(v61, a2);
    int v63 = (int)v62;
    if (v62 >= 0x80) {
      int v64 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v62, a2);
    }
    else {
      int v64 = 1;
    }
    v4 += v63 + v64 + 2;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
    if ((v3 & 0x20000) == 0)
    {
LABEL_115:
      if ((v3 & 0x40000) == 0) {
        goto LABEL_116;
      }
      goto LABEL_134;
    }
  }
  else if ((v3 & 0x20000) == 0)
  {
    goto LABEL_115;
  }
  uint64_t v65 = *(void *)(a1 + 136);
  if (!v65) {
    uint64_t v65 = *(void *)(qword_10248AFD8 + 136);
  }
  int v66 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDD4FC(v65, a2);
  int v67 = (int)v66;
  if (v66 >= 0x80) {
    int v68 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v66, a2);
  }
  else {
    int v68 = 1;
  }
  v4 += v67 + v68 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x40000) == 0)
  {
LABEL_116:
    if ((v3 & 0x80000) == 0) {
      goto LABEL_117;
    }
    goto LABEL_142;
  }
LABEL_134:
  uint64_t v69 = *(void *)(a1 + 144);
  if (!v69) {
    uint64_t v69 = *(void *)(qword_10248AFD8 + 144);
  }
  if ((*(unsigned char *)(v69 + 20) & 1) == 0)
  {
    int v70 = 0;
    *(_DWORD *)(v69 + 16) = 0;
LABEL_139:
    int v72 = 1;
    goto LABEL_141;
  }
  int v71 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(v69 + 8), a2);
  int v70 = v71 + 1;
  *(_DWORD *)(v69 + 16) = v71 + 1;
  if ((v71 + 1) < 0x80) {
    goto LABEL_139;
  }
  int v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v71 + 1), a2);
LABEL_141:
  v4 += v70 + v72 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x80000) == 0)
  {
LABEL_117:
    if ((v3 & 0x100000) == 0) {
      goto LABEL_118;
    }
    goto LABEL_148;
  }
LABEL_142:
  uint64_t v73 = *(void *)(a1 + 152);
  if (!v73) {
    uint64_t v73 = *(void *)(qword_10248AFD8 + 152);
  }
  int v74 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDC8A8(v73);
  int v75 = (int)v74;
  if (v74 >= 0x80) {
    int v76 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v74, a2);
  }
  else {
    int v76 = 1;
  }
  v4 += v75 + v76 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x100000) == 0)
  {
LABEL_118:
    if ((v3 & 0x200000) == 0) {
      goto LABEL_119;
    }
    goto LABEL_156;
  }
LABEL_148:
  uint64_t v77 = *(void *)(a1 + 160);
  if (!v77) {
    uint64_t v77 = *(void *)(qword_10248AFD8 + 160);
  }
  if ((*(unsigned char *)(v77 + 20) & 1) == 0)
  {
    int v78 = 0;
    *(_DWORD *)(v77 + 16) = 0;
LABEL_153:
    int v80 = 1;
    goto LABEL_155;
  }
  int v79 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(v77 + 8), a2);
  int v78 = v79 + 1;
  *(_DWORD *)(v77 + 16) = v79 + 1;
  if ((v79 + 1) < 0x80) {
    goto LABEL_153;
  }
  int v80 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v79 + 1), a2);
LABEL_155:
  v4 += v78 + v80 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x200000) == 0)
  {
LABEL_119:
    if ((v3 & 0x400000) == 0) {
      goto LABEL_120;
    }
    goto LABEL_162;
  }
LABEL_156:
  uint64_t v81 = *(unsigned int **)(a1 + 168);
  if (!v81) {
    uint64_t v81 = *(unsigned int **)(qword_10248AFD8 + 168);
  }
  int v82 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE20D4(v81, a2);
  int v83 = (int)v82;
  if (v82 >= 0x80) {
    int v84 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v82, a2);
  }
  else {
    int v84 = 1;
  }
  v4 += v83 + v84 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x400000) == 0)
  {
LABEL_120:
    if ((v3 & 0x800000) == 0) {
      goto LABEL_174;
    }
    goto LABEL_168;
  }
LABEL_162:
  uint64_t v85 = *(void *)(a1 + 176);
  if (!v85) {
    uint64_t v85 = *(void *)(qword_10248AFD8 + 176);
  }
  int v86 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE24B0(v85, a2);
  int v87 = (int)v86;
  if (v86 >= 0x80) {
    int v88 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v86, a2);
  }
  else {
    int v88 = 1;
  }
  v4 += v87 + v88 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x800000) != 0)
  {
LABEL_168:
    uint64_t v89 = *(void *)(a1 + 184);
    if (!v89) {
      uint64_t v89 = *(void *)(qword_10248AFD8 + 184);
    }
    if (*(_DWORD *)(v89 + 16)) {
      int v90 = 2 * (*(_DWORD *)(v89 + 16) & 1);
    }
    else {
      int v90 = 0;
    }
    *(_DWORD *)(v89 + 12) = v90;
    v4 += v90 + 3;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
  }
LABEL_174:
  if (!HIBYTE(v3)) {
    goto LABEL_234;
  }
  if ((v3 & 0x1000000) != 0)
  {
    uint64_t v91 = *(void *)(a1 + 192);
    if (!v91) {
      uint64_t v91 = *(void *)(qword_10248AFD8 + 192);
    }
    int v92 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE2E98(v91, a2);
    int v93 = (int)v92;
    if (v92 >= 0x80) {
      int v94 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v92, a2);
    }
    else {
      int v94 = 1;
    }
    v4 += v93 + v94 + 2;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
    if ((v3 & 0x2000000) == 0)
    {
LABEL_177:
      if ((v3 & 0x4000000) == 0) {
        goto LABEL_178;
      }
      goto LABEL_196;
    }
  }
  else if ((v3 & 0x2000000) == 0)
  {
    goto LABEL_177;
  }
  uint64_t v95 = *(void *)(a1 + 200);
  if (!v95) {
    uint64_t v95 = *(void *)(qword_10248AFD8 + 200);
  }
  int v96 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE3204(v95, a2);
  int v97 = (int)v96;
  if (v96 >= 0x80) {
    int v98 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v96, a2);
  }
  else {
    int v98 = 1;
  }
  v4 += v97 + v98 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x4000000) == 0)
  {
LABEL_178:
    if ((v3 & 0x8000000) == 0) {
      goto LABEL_179;
    }
    goto LABEL_202;
  }
LABEL_196:
  uint64_t v99 = *(void *)(a1 + 208);
  if (!v99) {
    uint64_t v99 = *(void *)(qword_10248AFD8 + 208);
  }
  int v100 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE7A1C(v99, a2);
  int v101 = (int)v100;
  if (v100 >= 0x80) {
    int v102 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v100, a2);
  }
  else {
    int v102 = 1;
  }
  v4 += v101 + v102 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x8000000) == 0)
  {
LABEL_179:
    if ((v3 & 0x10000000) == 0) {
      goto LABEL_180;
    }
    goto LABEL_208;
  }
LABEL_202:
  uint64_t v103 = *(void *)(a1 + 216);
  if (!v103) {
    uint64_t v103 = *(void *)(qword_10248AFD8 + 216);
  }
  int v104 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FEA060(v103, a2);
  int v105 = (int)v104;
  if (v104 >= 0x80) {
    int v106 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v104, a2);
  }
  else {
    int v106 = 1;
  }
  v4 += v105 + v106 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x10000000) == 0)
  {
LABEL_180:
    if ((v3 & 0x20000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_214;
  }
LABEL_208:
  uint64_t v107 = *(void *)(a1 + 224);
  if (!v107) {
    uint64_t v107 = *(void *)(qword_10248AFD8 + 224);
  }
  v108 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE7E9C(v107, a2);
  int v109 = (int)v108;
  if (v108 >= 0x80) {
    int v110 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v108, a2);
  }
  else {
    int v110 = 1;
  }
  v4 += v109 + v110 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x20000000) == 0)
  {
LABEL_181:
    if ((v3 & 0x40000000) == 0) {
      goto LABEL_182;
    }
    goto LABEL_220;
  }
LABEL_214:
  uint64_t v111 = *(void *)(a1 + 232);
  if (!v111) {
    uint64_t v111 = *(void *)(qword_10248AFD8 + 232);
  }
  unsigned int v112 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE1CD4(v111, a2);
  int v113 = (int)v112;
  if (v112 >= 0x80) {
    int v114 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v112, a2);
  }
  else {
    int v114 = 1;
  }
  v4 += v113 + v114 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x40000000) == 0)
  {
LABEL_182:
    if ((v3 & 0x80000000) == 0) {
      goto LABEL_234;
    }
    goto LABEL_228;
  }
LABEL_220:
  uint64_t v115 = *(void *)(a1 + 240);
  if (!v115) {
    uint64_t v115 = *(void *)(qword_10248AFD8 + 240);
  }
  int v116 = 2 * (*(_DWORD *)(v115 + 16) & 1);
  if ((*(_DWORD *)(v115 + 16) & 2) != 0) {
    v116 += 2;
  }
  if (*(_DWORD *)(v115 + 16)) {
    int v117 = v116;
  }
  else {
    int v117 = 0;
  }
  *(_DWORD *)(v115 + 12) = v117;
  v4 += v117 + 3;
  if ((*(_DWORD *)(a1 + 396) & 0x80000000) != 0)
  {
LABEL_228:
    uint64_t v118 = *(void *)(a1 + 248);
    if (!v118) {
      uint64_t v118 = *(void *)(qword_10248AFD8 + 248);
    }
    int v119 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FBB38(v118, a2);
    int v120 = (int)v119;
    if (v119 >= 0x80) {
      int v121 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v119, a2);
    }
    else {
      int v121 = 1;
    }
    v4 += v120 + v121 + 2;
  }
LABEL_234:
  int v122 = *(_DWORD *)(a1 + 400);
  if (!(_BYTE)v122) {
    goto LABEL_293;
  }
  if (v122)
  {
    uint64_t v123 = *(void *)(a1 + 256);
    int v124 = *(unsigned __int8 *)(v123 + 23);
    char v125 = v124;
    uint64_t v126 = *(void *)(v123 + 8);
    if ((v124 & 0x80u) == 0) {
      unint64_t v127 = *(unsigned __int8 *)(v123 + 23);
    }
    else {
      unint64_t v127 = v126;
    }
    if (v127 >= 0x80)
    {
      int v128 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v127, a2);
      int v124 = *(unsigned __int8 *)(v123 + 23);
      uint64_t v126 = *(void *)(v123 + 8);
      int v122 = *(_DWORD *)(a1 + 400);
      char v125 = *(unsigned char *)(v123 + 23);
    }
    else
    {
      int v128 = 1;
    }
    if (v125 < 0) {
      int v124 = v126;
    }
    v4 += v128 + v124 + 2;
    if ((v122 & 2) == 0)
    {
LABEL_237:
      if ((v122 & 4) == 0) {
        goto LABEL_238;
      }
      goto LABEL_259;
    }
  }
  else if ((v122 & 2) == 0)
  {
    goto LABEL_237;
  }
  int v129 = *(unsigned int **)(a1 + 264);
  if (!v129) {
    int v129 = *(unsigned int **)(qword_10248AFD8 + 264);
  }
  unsigned int v130 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008D58B4(v129, a2);
  int v131 = (int)v130;
  if (v130 >= 0x80) {
    int v132 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v130, a2);
  }
  else {
    int v132 = 1;
  }
  v4 += v131 + v132 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 4) == 0)
  {
LABEL_238:
    if ((v122 & 8) == 0) {
      goto LABEL_239;
    }
    goto LABEL_263;
  }
LABEL_259:
  v133 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 304);
  if (v133 >= 0x80)
  {
    int v134 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v133, a2);
    int v122 = *(_DWORD *)(a1 + 400);
  }
  else
  {
    int v134 = 1;
  }
  v4 += v134 + 2;
  if ((v122 & 8) == 0)
  {
LABEL_239:
    if ((v122 & 0x10) == 0) {
      goto LABEL_240;
    }
    goto LABEL_269;
  }
LABEL_263:
  uint64_t v135 = *(void *)(a1 + 272);
  if (!v135) {
    uint64_t v135 = *(void *)(qword_10248AFD8 + 272);
  }
  int v136 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008F61F8(v135, a2);
  int v137 = (int)v136;
  if (v136 >= 0x80) {
    int v138 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v136, a2);
  }
  else {
    int v138 = 1;
  }
  v4 += v137 + v138 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 0x10) == 0)
  {
LABEL_240:
    if ((v122 & 0x20) == 0) {
      goto LABEL_241;
    }
    goto LABEL_275;
  }
LABEL_269:
  unsigned int v139 = *(unsigned int **)(a1 + 280);
  if (!v139) {
    unsigned int v139 = *(unsigned int **)(qword_10248AFD8 + 280);
  }
  int v140 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008F71C0(v139, a2);
  int v141 = (int)v140;
  if (v140 >= 0x80) {
    int v142 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v140, a2);
  }
  else {
    int v142 = 1;
  }
  v4 += v141 + v142 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 0x20) == 0)
  {
LABEL_241:
    if ((v122 & 0x40) == 0) {
      goto LABEL_242;
    }
    goto LABEL_281;
  }
LABEL_275:
  uint64_t v143 = *(void *)(a1 + 288);
  if (!v143) {
    uint64_t v143 = *(void *)(qword_10248AFD8 + 288);
  }
  v144 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FA250(v143, a2);
  int v145 = (int)v144;
  if (v144 >= 0x80) {
    int v146 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v144, a2);
  }
  else {
    int v146 = 1;
  }
  v4 += v145 + v146 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 0x40) == 0)
  {
LABEL_242:
    if ((v122 & 0x80) == 0) {
      goto LABEL_293;
    }
    goto LABEL_287;
  }
LABEL_281:
  uint64_t v147 = *(void *)(a1 + 296);
  if (!v147) {
    uint64_t v147 = *(void *)(qword_10248AFD8 + 296);
  }
  unsigned int v148 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FD894(v147, a2);
  int v149 = (int)v148;
  if (v148 >= 0x80) {
    int v150 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v148, a2);
  }
  else {
    int v150 = 1;
  }
  v4 += v149 + v150 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 0x80) != 0)
  {
LABEL_287:
    uint64_t v151 = *(void *)(a1 + 312);
    if (!v151) {
      uint64_t v151 = *(void *)(qword_10248AFD8 + 312);
    }
    uint64_t v152 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FE588(v151, a2);
    int v153 = (int)v152;
    if (v152 >= 0x80) {
      int v154 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v152, a2);
    }
    else {
      int v154 = 1;
    }
    v4 += v153 + v154 + 2;
    int v122 = *(_DWORD *)(a1 + 400);
  }
LABEL_293:
  if ((v122 & 0xFF00) == 0) {
    goto LABEL_328;
  }
  if ((v122 & 0x100) == 0)
  {
    if ((v122 & 0x400) == 0) {
      goto LABEL_296;
    }
LABEL_304:
    uint64_t v159 = *(void *)(a1 + 344);
    if (!v159) {
      uint64_t v159 = *(void *)(qword_10248AFD8 + 344);
    }
    v160 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008CC504(v159, a2);
    int v161 = (int)v160;
    if (v160 >= 0x80) {
      int v162 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v160, a2);
    }
    else {
      int v162 = 1;
    }
    v4 += v161 + v162 + 2;
    int v122 = *(_DWORD *)(a1 + 400);
    if ((v122 & 0x800) == 0) {
      goto LABEL_314;
    }
    goto LABEL_310;
  }
  uint64_t v155 = *(void *)(a1 + 320);
  if (!v155) {
    uint64_t v155 = *(void *)(qword_10248AFD8 + 320);
  }
  int v156 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FAEF0(v155);
  int v157 = (int)v156;
  if (v156 >= 0x80) {
    int v158 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v156, a2);
  }
  else {
    int v158 = 1;
  }
  v4 += v157 + v158 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 0x400) != 0) {
    goto LABEL_304;
  }
LABEL_296:
  if ((v122 & 0x800) != 0)
  {
LABEL_310:
    int v163 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 308);
    if (v163 >= 0x80)
    {
      int v164 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v163, a2) + 2;
      int v122 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      int v164 = 3;
    }
    v4 += v164;
  }
LABEL_314:
  if ((v122 & 0x2000) != 0) {
    v4 += 3;
  }
  if ((v122 & 0x4000) != 0)
  {
    int v165 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 372);
    if (v165 >= 0x80)
    {
      int v166 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v165, a2) + 2;
      int v122 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      int v166 = 3;
    }
    v4 += v166;
  }
  if ((v122 & 0x8000) != 0)
  {
    uint64_t v167 = *(void *)(a1 + 376);
    if (!v167) {
      uint64_t v167 = *(void *)(qword_10248AFD8 + 376);
    }
    int v168 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008D15C8(v167, a2);
    int v169 = (int)v168;
    if (v168 >= 0x80) {
      int v170 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v168, a2);
    }
    else {
      int v170 = 1;
    }
    v4 += v169 + v170 + 2;
    int v122 = *(_DWORD *)(a1 + 400);
  }
LABEL_328:
  if ((v122 & 0x10000) != 0)
  {
    uint64_t v171 = *(void *)(a1 + 384);
    if (!v171) {
      uint64_t v171 = *(void *)(qword_10248AFD8 + 384);
    }
    int v172 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008CDA08(v171, a2);
    int v173 = (int)v172;
    if (v172 >= 0x80) {
      int v174 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v172, a2);
    }
    else {
      int v174 = 1;
    }
    v4 += v173 + v174 + 2;
  }
  int v175 = *(_DWORD *)(a1 + 336);
  if (v175 < 1)
  {
    int v177 = 0;
  }
  else
  {
    uint64_t v176 = 0;
    int v177 = 0;
    do
    {
      v178 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 328)
                                                                                              + 4 * v176);
      if (v178 >= 0x80)
      {
        int v179 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v178, a2);
        int v175 = *(_DWORD *)(a1 + 336);
      }
      else
      {
        int v179 = 1;
      }
      v177 += v179;
      ++v176;
    }
    while (v176 < v175);
  }
  int v180 = *(_DWORD *)(a1 + 360);
  if (v180 < 1)
  {
    int v182 = 0;
  }
  else
  {
    uint64_t v181 = 0;
    int v182 = 0;
    do
    {
      int v183 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 352)
                                                                                              + 4 * v181);
      if (v183 >= 0x80)
      {
        int v184 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v183, a2);
        int v180 = *(_DWORD *)(a1 + 360);
      }
      else
      {
        int v184 = 1;
      }
      v182 += v184;
      ++v181;
    }
    while (v181 < v180);
  }
  uint64_t result = (v177 + v4 + v182 + 2 * (v180 + v175));
  *(_DWORD *)(a1 + 392) = result;
  return result;
}

void sub_100FD503C(uint64_t a1, void *lpsrc)
{
  sub_100FCD9F4(a1, (uint64_t)lpsrc);
}

void sub_100FD50C4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      *(_DWORD *)(a1 + 36) |= 1u;
      uint64_t v5 = *(void *)(a1 + 8);
      if (!v5) {
        operator new();
      }
      uint64_t v6 = *(void *)(a2 + 8);
      if (!v6) {
        uint64_t v6 = *(void *)(qword_10248B018 + 8);
      }
      sub_10074876C(v5, v6);
      int v4 = *(_DWORD *)(a2 + 36);
    }
    if ((v4 & 2) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 16);
      if (!sub_100165F14(v7)) {
        sub_101A9BFA8();
      }
      *(_DWORD *)(a1 + 36) |= 2u;
      *(_DWORD *)(a1 + 16) = v7;
      int v4 = *(_DWORD *)(a2 + 36);
    }
    if ((v4 & 4) != 0)
    {
      char v8 = *(unsigned char *)(a2 + 20);
      *(_DWORD *)(a1 + 36) |= 4u;
      *(unsigned char *)(a1 + 2sub_100FB8FC8(&a9, 0) = v8;
      int v4 = *(_DWORD *)(a2 + 36);
    }
    if ((v4 & 8) != 0)
    {
      uint64_t v9 = *(void *)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 8u;
      *(void *)(a1 + 24) = v9;
    }
  }
}

void sub_100FD5200()
{
}

void sub_100FD5238(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v4 = *(_DWORD *)(a2 + 36);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_7;
      }
    }
    else if ((*(unsigned char *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v7 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(void *)(a1 + 16) = v7;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return;
    }
LABEL_7:
    uint64_t v5 = *(void *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(void *)(a1 + 24) = v5;
  }
}

void sub_100FD530C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5324(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        sub_100FEA1E0();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_10074C788(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
}

void sub_100FD544C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5464(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        sub_100FEA244();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_10074CC1C(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
}

void sub_100FD558C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD55A4(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        sub_100FEA244();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_10074CC1C(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
}

void sub_100FD56CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

double sub_100FD56E4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v5) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 36);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }
    else if ((*(unsigned char *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + 24) = result;
  }
  return result;
}

void sub_100FD57B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD57D0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v18);
  }
  int v4 = *(_DWORD *)(a2 + 76);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 76) |= 1u;
    *(void *)(a1 + 8) = v7;
    int v4 = *(_DWORD *)(a2 + 76);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  uint64_t v8 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 76) |= 2u;
  *(void *)(a1 + 16) = v8;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
LABEL_23:
  uint64_t v9 = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 76) |= 4u;
  *(void *)(a1 + 24) = v9;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
LABEL_24:
  char v10 = *(unsigned char *)(a2 + 64);
  *(_DWORD *)(a1 + 76) |= 8u;
  *(unsigned char *)(a1 + 64) = v10;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_26:
    uint64_t v12 = *(void *)(a2 + 40);
    *(_DWORD *)(a1 + 76) |= 0x20u;
    *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = v12;
    int v4 = *(_DWORD *)(a2 + 76);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_27;
  }
LABEL_25:
  uint64_t v11 = *(void *)(a2 + 32);
  *(_DWORD *)(a1 + 76) |= 0x10u;
  *(void *)(a1 + 32) = v11;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 0x20) != 0) {
    goto LABEL_26;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_27:
  uint64_t v13 = *(void *)(a2 + 48);
  *(_DWORD *)(a1 + 76) |= 0x40u;
  *(void *)(a1 + 48) = v13;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    uint64_t v5 = *(void *)(a2 + 56);
    *(_DWORD *)(a1 + 76) |= 0x80u;
    *(void *)(a1 + 56) = v5;
    int v4 = *(_DWORD *)(a2 + 76);
  }
LABEL_13:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) != 0)
  {
    char v14 = *(unsigned char *)(a2 + 65);
    *(_DWORD *)(a1 + 76) |= 0x100u;
    *(unsigned char *)(a1 + 65) = v14;
    int v4 = *(_DWORD *)(a2 + 76);
    if ((v4 & 0x200) == 0)
    {
LABEL_16:
      if ((v4 & 0x400) == 0) {
        goto LABEL_17;
      }
      goto LABEL_31;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_16;
  }
  char v15 = *(unsigned char *)(a2 + 66);
  *(_DWORD *)(a1 + 76) |= 0x200u;
  *(unsigned char *)(a1 + 66) = v15;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 0x400) == 0)
  {
LABEL_17:
    if ((v4 & 0x800) == 0) {
      goto LABEL_18;
    }
    goto LABEL_32;
  }
LABEL_31:
  char v16 = *(unsigned char *)(a2 + 67);
  *(_DWORD *)(a1 + 76) |= 0x400u;
  *(unsigned char *)(a1 + 67) = v16;
  int v4 = *(_DWORD *)(a2 + 76);
  if ((v4 & 0x800) == 0)
  {
LABEL_18:
    if ((v4 & 0x1000) == 0) {
      return;
    }
    goto LABEL_19;
  }
LABEL_32:
  char v17 = *(unsigned char *)(a2 + 68);
  *(_DWORD *)(a1 + 76) |= 0x800u;
  *(unsigned char *)(a1 + 68) = v17;
  if ((*(_DWORD *)(a2 + 76) & 0x1000) == 0) {
    return;
  }
LABEL_19:
  char v6 = *(unsigned char *)(a2 + 69);
  *(_DWORD *)(a1 + 76) |= 0x1000u;
  *(unsigned char *)(a1 + 69) = v6;
}

void sub_100FD59F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5A08(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 32);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 32))
    {
      uint64_t v5 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      *(void *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 32);
    }
    if ((v4 & 2) != 0)
    {
      unsigned int v6 = *(_DWORD *)(a2 + 16);
      if (!sub_100748708(v6)) {
        sub_101A9C02C();
      }
      *(_DWORD *)(a1 + 32) |= 2u;
      *(_DWORD *)(a1 + 16) = v6;
      int v4 = *(_DWORD *)(a2 + 32);
    }
    if ((v4 & 4) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 20);
      if (!sub_1001662E0(v7)) {
        sub_101A9C000();
      }
      *(_DWORD *)(a1 + 32) |= 4u;
      *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v7;
      int v4 = *(_DWORD *)(a2 + 32);
    }
    if ((v4 & 8) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 24);
      if (!sub_100748714(v8)) {
        sub_101A9BFD4();
      }
      *(_DWORD *)(a1 + 32) |= 8u;
      *(_DWORD *)(a1 + 24) = v8;
    }
  }
}

void sub_100FD5B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5B3C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      uint64_t v5 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(void *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 24);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 16);
      if (!sub_10023E790(v6)) {
        sub_101A9C058();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v6;
    }
  }
}

void sub_100FD5BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5C10(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if ((sub_100748754(v4) & 1) == 0) {
      sub_101A9C084();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v4;
  }
}

void sub_100FD5CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

double sub_100FD5CC4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v5) = *(unsigned char *)(a2 + 44);
  if ((_BYTE)v5)
  {
    if (*(unsigned char *)(a2 + 44))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 44) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 44);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 44) & 2) == 0)
    {
      goto LABEL_6;
    }
    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 44) |= 2u;
    *(double *)(a1 + 16) = result;
    int v5 = *(_DWORD *)(a2 + 44);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        return result;
      }
      goto LABEL_8;
    }
LABEL_12:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 44) |= 4u;
    *(double *)(a1 + 24) = result;
    if ((*(_DWORD *)(a2 + 44) & 8) == 0) {
      return result;
    }
LABEL_8:
    double result = *(double *)(a2 + 32);
    *(_DWORD *)(a1 + 44) |= 8u;
    *(double *)(a1 + 32) = result;
  }
  return result;
}

void sub_100FD5DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

double sub_100FD5DD0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v5) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 36);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }
    else if ((*(unsigned char *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + 24) = result;
  }
  return result;
}

void sub_100FD5EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5EBC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v5 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      uint64_t v6 = *(std::string **)(a1 + 8);
      if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v6, v5);
      int v4 = *(_DWORD *)(a2 + 24);
    }
    if ((v4 & 2) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 16);
      if (v7 >= 3) {
        sub_101A9C0B0();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v7;
    }
  }
}

void sub_100FD5FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD5FD0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*(unsigned char *)(a2 + 20))
  {
    int v4 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    int v5 = *(std::string **)(a1 + 8);
    if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v5, v4);
  }
}

void sub_100FD6098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD60B0(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        sub_100FEA17C();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_10074D228(*(_DWORD **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
}

void sub_100FD61D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD61F0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 20))
  {
    uint64_t v4 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    *(void *)(a1 + 8) = v4;
  }
}

void sub_100FD627C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6294(uint64_t a1, unsigned char *a2)
{
  if (a2 == (unsigned char *)a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v4) = a2[20];
  if ((_BYTE)v4)
  {
    if (a2[20])
    {
      char v6 = a2[8];
      *(_DWORD *)(a1 + 20) |= 1u;
      *(unsigned char *)(a1 + 8) = v6;
      int v4 = *((_DWORD *)a2 + 5);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((a2[20] & 2) == 0)
    {
      goto LABEL_6;
    }
    char v7 = a2[9];
    *(_DWORD *)(a1 + 20) |= 2u;
    *(unsigned char *)(a1 + 9) = v7;
    int v4 = *((_DWORD *)a2 + 5);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_15;
    }
LABEL_14:
    char v8 = a2[10];
    *(_DWORD *)(a1 + 20) |= 4u;
    *(unsigned char *)(a1 + 1sub_100FB8FC8(&a9, 0) = v8;
    int v4 = *((_DWORD *)a2 + 5);
    if ((v4 & 8) == 0)
    {
LABEL_8:
      if ((v4 & 0x10) == 0) {
        goto LABEL_9;
      }
      goto LABEL_16;
    }
LABEL_15:
    char v9 = a2[11];
    *(_DWORD *)(a1 + 20) |= 8u;
    *(unsigned char *)(a1 + 11) = v9;
    int v4 = *((_DWORD *)a2 + 5);
    if ((v4 & 0x10) == 0)
    {
LABEL_9:
      if ((v4 & 0x20) == 0) {
        return;
      }
      goto LABEL_10;
    }
LABEL_16:
    char v10 = a2[12];
    *(_DWORD *)(a1 + 20) |= 0x10u;
    *(unsigned char *)(a1 + 12) = v10;
    if ((*((_DWORD *)a2 + 5) & 0x20) == 0) {
      return;
    }
LABEL_10:
    char v5 = a2[13];
    *(_DWORD *)(a1 + 20) |= 0x20u;
    *(unsigned char *)(a1 + 13) = v5;
  }
}

void sub_100FD63C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD63E0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 20))
  {
    uint64_t v4 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    *(void *)(a1 + 8) = v4;
  }
}

void sub_100FD646C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6484(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      char v5 = *(unsigned char *)(a2 + 8);
      *(_DWORD *)(a1 + 20) |= 1u;
      *(unsigned char *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(_DWORD *)(a1 + 12) = v6;
    }
  }
}

void sub_100FD6530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6548(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      int v5 = *(_DWORD *)(a2 + 8);
      a1[5] |= 1u;
      a1[2] = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 12);
      a1[5] |= 2u;
      a1[3] = v6;
    }
  }
}

void sub_100FD65F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD660C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    char v4 = *(unsigned char *)(a2 + 8);
    *(_DWORD *)(a1 + 16) |= 1u;
    *(unsigned char *)(a1 + 8) = v4;
  }
}

void sub_100FD6698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD66B0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*(unsigned char *)(a2 + 20))
  {
    char v4 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    int v5 = *(std::string **)(a1 + 8);
    if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v5, v4);
  }
}

void sub_100FD6778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6790(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*(unsigned char *)(a2 + 20))
  {
    char v4 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    int v5 = *(std::string **)(a1 + 8);
    if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v5, v4);
  }
}

void sub_100FD6858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6870(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 56);
  if (!(_BYTE)v4) {
    return;
  }
  if (*(unsigned char *)(a2 + 56))
  {
    char v5 = *(unsigned char *)(a2 + 8);
    *(_DWORD *)(a1 + 56) |= 1u;
    *(unsigned char *)(a1 + 8) = v5;
    int v4 = *(_DWORD *)(a2 + 56);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
  }
  else if ((*(unsigned char *)(a2 + 56) & 2) == 0)
  {
    goto LABEL_6;
  }
  int v6 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 56) |= 2u;
  *(_DWORD *)(a1 + 12) = v6;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }
LABEL_14:
  unsigned int v7 = *(_DWORD *)(a2 + 48);
  if (v7 >= 5) {
    sub_101A9C0DC();
  }
  *(_DWORD *)(a1 + 56) |= 4u;
  *(_DWORD *)(a1 + 48) = v7;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
LABEL_21:
    *(_DWORD *)(a1 + 56) |= 0x10u;
    uint64_t v10 = *(void *)(a1 + 24);
    if (!v10) {
      operator new();
    }
    uint64_t v11 = *(void *)(a2 + 24);
    if (!v11) {
      uint64_t v11 = *(void *)(qword_10248B0E0 + 24);
    }
    sub_100FE4AEC(v10, v11);
    int v4 = *(_DWORD *)(a2 + 56);
    if ((v4 & 0x20) == 0)
    {
LABEL_10:
      if ((v4 & 0x40) == 0) {
        return;
      }
      goto LABEL_31;
    }
    goto LABEL_26;
  }
LABEL_16:
  *(_DWORD *)(a1 + 56) |= 8u;
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    operator new();
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248B0E0 + 16);
  }
  sub_100FE6248(v8, v9);
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 0x10) != 0) {
    goto LABEL_21;
  }
LABEL_9:
  if ((v4 & 0x20) == 0) {
    goto LABEL_10;
  }
LABEL_26:
  *(_DWORD *)(a1 + 56) |= 0x20u;
  uint64_t v12 = *(void *)(a1 + 32);
  if (!v12) {
    operator new();
  }
  uint64_t v13 = *(void *)(a2 + 32);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248B0E0 + 32);
  }
  sub_100FE5568(v12, v13);
  if ((*(_DWORD *)(a2 + 56) & 0x40) != 0)
  {
LABEL_31:
    *(_DWORD *)(a1 + 56) |= 0x40u;
    char v14 = *(_DWORD **)(a1 + 40);
    if (!v14) {
      operator new();
    }
    uint64_t v15 = *(void *)(a2 + 40);
    if (!v15) {
      uint64_t v15 = *(void *)(qword_10248B0E0 + 40);
    }
    sub_100FE5D58(v14, v15);
  }
}

void sub_100FD6B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6B5C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      char v6 = *(unsigned char *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(unsigned char *)(a1 + 16) = v6;
      int v4 = *(_DWORD *)(a2 + 24);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }
    char v7 = *(unsigned char *)(a2 + 17);
    *(_DWORD *)(a1 + 24) |= 2u;
    *(unsigned char *)(a1 + 17) = v7;
    int v4 = *(_DWORD *)(a2 + 24);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    char v8 = *(unsigned char *)(a2 + 18);
    *(_DWORD *)(a1 + 24) |= 4u;
    *(unsigned char *)(a1 + 18) = v8;
    if ((*(_DWORD *)(a2 + 24) & 8) == 0) {
      return;
    }
LABEL_8:
    uint64_t v5 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 24) |= 8u;
    *(void *)(a1 + 8) = v5;
  }
}

void sub_100FD6C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6C68(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4 >= 7) {
      sub_101A9C108();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v4;
  }
}

void sub_100FD6D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6D18(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      uint64_t v5 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(void *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 24);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v6;
    }
  }
}

void sub_100FD6DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6DDC(uint64_t a1, unsigned char *a2)
{
  if (a2 == (unsigned char *)a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = a2[16];
  if ((_BYTE)v4)
  {
    if (a2[16])
    {
      char v5 = a2[8];
      *(_DWORD *)(a1 + 16) |= 1u;
      *(unsigned char *)(a1 + 8) = v5;
      int v4 = *((_DWORD *)a2 + 4);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = a2[9];
      *(_DWORD *)(a1 + 16) |= 2u;
      *(unsigned char *)(a1 + 9) = v6;
    }
  }
}

void sub_100FD6E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD6EA0(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_100FCD9F4(a1, a2);
  }
}

uint64_t sub_100FD6F0C()
{
  return 1;
}

void *sub_100FD6F14@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.Request");
}

void sub_100FD6F24(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 28);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 28))
    {
      int v5 = *(_DWORD *)(a2 + 16);
      if ((sub_100FCD768() & 1) == 0) {
        sub_101A9C160();
      }
      *(_DWORD *)(a1 + 28) |= 1u;
      *(_DWORD *)(a1 + 16) = v5;
      int v4 = *(_DWORD *)(a2 + 28);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 28) |= 2u;
      *(void *)(a1 + 8) = v6;
      int v4 = *(_DWORD *)(a2 + 28);
    }
    if ((v4 & 4) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 20);
      if (!sub_100748708(v7)) {
        sub_101A9C134();
      }
      *(_DWORD *)(a1 + 28) |= 4u;
      *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v7;
    }
  }
}

void sub_100FD7014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FD702C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308BC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FD704C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308BC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FD70A0()
{
}

uint64_t sub_100FD70EC(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_100FD7100(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unint64_t *)(a1 + 2);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (char *)*((void *)this + 1);
        if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v6;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v6 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v8 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v20 = 0;
        uint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v20);
          if (!result) {
            return result;
          }
          unsigned int v13 = v20;
        }
        else
        {
          unsigned int v13 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        if (sub_100FCD768())
        {
          a1[7] |= 1u;
          a1[4] = v13;
        }
        uint64_t v15 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v15 < v10 && *v15 == 16)
        {
          char v14 = v15 + 1;
          *((void *)this + 1) = v14;
          goto LABEL_29;
        }
      }
      if (v8 != 2) {
        break;
      }
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_19;
      }
      char v14 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
LABEL_29:
      if ((unint64_t)v14 >= v10 || *v14 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!result) {
          return result;
        }
        char v16 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }
      else
      {
        unint64_t *v5 = *v14;
        char v16 = v14 + 1;
        *((void *)this + 1) = v16;
      }
      a1[7] |= 2u;
      if ((unint64_t)v16 < v10 && *v16 == 24)
      {
        uint64_t v11 = v16 + 1;
        *((void *)this + 1) = v11;
LABEL_37:
        unsigned int v19 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!result) {
            return result;
          }
          unsigned int v17 = v19;
        }
        else
        {
          unsigned int v17 = *v11;
          *((void *)this + 1) = v11 + 1;
        }
        if (sub_100748708(v17))
        {
          if (!sub_100748708(v17)) {
            sub_101A9C134();
          }
          a1[7] |= 4u;
          a1[5] = v17;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (v8 == 3)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_37;
      }
    }
    else
    {
      int v9 = TagFallback & 7;
    }
LABEL_19:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FD7354(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 8), a2, a4);
    if ((*(_DWORD *)(v5 + 28) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
  int v6 = *(_DWORD *)(v5 + 28);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  int v7 = *(_DWORD *)(v5 + 20);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
}

uint64_t sub_100FD73E0(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_21;
  }
  if ((*(unsigned char *)(a1 + 28) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v4 = 11;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
    uint64_t v4 = 2;
    if ((v3 & 2) != 0)
    {
LABEL_13:
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 28);
    }
  }
LABEL_14:
  if ((v3 & 4) != 0)
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if ((v6 & 0x80000000) != 0)
    {
      int v7 = 11;
    }
    else if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    }
    else
    {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }
LABEL_21:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

void sub_100FD74A4(uint64_t a1, void *lpsrc)
{
  sub_100FD6F24(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FD752C()
{
  return 1;
}

void *sub_100FD7534@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.Response");
}

void sub_100FD7544(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v58);
  }
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((_BYTE)v4)
  {
    if (v4)
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      if (v5 - 9 >= 0x13 && v5 >= 6) {
        sub_101A9C23C();
      }
      *(_DWORD *)(a1 + 224) |= 1u;
      *(_DWORD *)(a1 + 8) = v5;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 12);
      if ((sub_100FCD768() & 1) == 0) {
        sub_101A9C210();
      }
      *(_DWORD *)(a1 + 224) |= 2u;
      *(_DWORD *)(a1 + 12) = v7;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      *(_DWORD *)(a1 + 224) |= 4u;
      *(void *)(a1 + 16) = v8;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 8) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 8u;
      uint64_t v9 = *(void *)(a1 + 24);
      if (!v9) {
        operator new();
      }
      uint64_t v10 = *(void *)(a2 + 24);
      if (!v10) {
        uint64_t v10 = *(void *)(qword_10248AFE8 + 24);
      }
      sub_10074A5A4(v9, v10);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x10) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x10u;
      uint64_t v11 = *(void *)(a1 + 32);
      if (!v11) {
        operator new();
      }
      uint64_t v12 = *(void *)(a2 + 32);
      if (!v12) {
        uint64_t v12 = *(void *)(qword_10248AFE8 + 32);
      }
      sub_100E37154(v11, v12);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x20) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x20u;
      uint64_t v13 = *(void *)(a1 + 40);
      if (!v13) {
        operator new();
      }
      uint64_t v14 = *(void *)(a2 + 40);
      if (!v14) {
        uint64_t v14 = *(void *)(qword_10248AFE8 + 40);
      }
      sub_10074DA10(v13, v14);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x40u;
      uint64_t v15 = *(void *)(a1 + 48);
      if (!v15) {
        operator new();
      }
      uint64_t v16 = *(void *)(a2 + 48);
      if (!v16) {
        uint64_t v16 = *(void *)(qword_10248AFE8 + 48);
      }
      sub_100FDB64C(v15, v16);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x80) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x80u;
      uint64_t v17 = *(void *)(a1 + 56);
      if (!v17) {
        operator new();
      }
      uint64_t v18 = *(void *)(a2 + 56);
      if (!v18) {
        uint64_t v18 = *(void *)(qword_10248AFE8 + 56);
      }
      sub_10074BE0C(v17, v18);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
  }
  if ((v4 & 0xFF00) == 0) {
    goto LABEL_89;
  }
  if ((v4 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 224) |= 0x100u;
    uint64_t v19 = *(void *)(a1 + 64);
    if (!v19) {
      operator new();
    }
    uint64_t v20 = *(void *)(a2 + 64);
    if (!v20) {
      uint64_t v20 = *(void *)(qword_10248AFE8 + 64);
    }
    sub_100FDB778(v19, v20);
    unsigned int v4 = *(_DWORD *)(a2 + 224);
    if ((v4 & 0x200) == 0)
    {
LABEL_48:
      if ((v4 & 0x400) == 0) {
        goto LABEL_49;
      }
      goto LABEL_65;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_48;
  }
  *(_DWORD *)(a1 + 224) |= 0x200u;
  uint64_t v21 = *(void *)(a1 + 72);
  if (!v21) {
    operator new();
  }
  uint64_t v22 = *(void *)(a2 + 72);
  if (!v22) {
    uint64_t v22 = *(void *)(qword_10248AFE8 + 72);
  }
  sub_100FDB970(v21, v22);
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((v4 & 0x400) == 0)
  {
LABEL_49:
    if ((v4 & 0x800) == 0) {
      goto LABEL_50;
    }
    goto LABEL_70;
  }
LABEL_65:
  *(_DWORD *)(a1 + 224) |= 0x400u;
  uint64_t v23 = *(void *)(a1 + 80);
  if (!v23) {
    operator new();
  }
  uint64_t v24 = *(void *)(a2 + 80);
  if (!v24) {
    uint64_t v24 = *(void *)(qword_10248AFE8 + 80);
  }
  sub_10074E618(v23, v24);
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((v4 & 0x800) == 0)
  {
LABEL_50:
    if ((v4 & 0x1000) == 0) {
      goto LABEL_51;
    }
    goto LABEL_75;
  }
LABEL_70:
  *(_DWORD *)(a1 + 224) |= 0x800u;
  uint64_t v25 = *(void *)(a1 + 88);
  if (!v25) {
    operator new();
  }
  uint64_t v26 = *(void *)(a2 + 88);
  if (!v26) {
    uint64_t v26 = *(void *)(qword_10248AFE8 + 88);
  }
  sub_10074E12C(v25, v26);
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((v4 & 0x1000) == 0)
  {
LABEL_51:
    if ((v4 & 0x2000) == 0) {
      goto LABEL_52;
    }
LABEL_77:
    unsigned int v28 = *(_DWORD *)(a2 + 100);
    if (!sub_100748708(v28)) {
      sub_101A9C1B8();
    }
    *(_DWORD *)(a1 + 224) |= 0x2000u;
    *(_DWORD *)(a1 + 10sub_100FB8FC8(&a9, 0) = v28;
    unsigned int v4 = *(_DWORD *)(a2 + 224);
    if ((v4 & 0x4000) == 0)
    {
LABEL_53:
      if ((v4 & 0x8000) == 0) {
        goto LABEL_89;
      }
      goto LABEL_84;
    }
    goto LABEL_79;
  }
LABEL_75:
  unsigned int v27 = *(_DWORD *)(a2 + 96);
  if (!sub_100748708(v27)) {
    sub_101A9C1E4();
  }
  *(_DWORD *)(a1 + 224) |= 0x1000u;
  *(_DWORD *)(a1 + 96) = v27;
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((v4 & 0x2000) != 0) {
    goto LABEL_77;
  }
LABEL_52:
  if ((v4 & 0x4000) == 0) {
    goto LABEL_53;
  }
LABEL_79:
  *(_DWORD *)(a1 + 224) |= 0x4000u;
  uint64_t v29 = *(void *)(a1 + 104);
  if (!v29) {
    operator new();
  }
  uint64_t v30 = *(void *)(a2 + 104);
  if (!v30) {
    uint64_t v30 = *(void *)(qword_10248AFE8 + 104);
  }
  sub_100FDBA20(v29, v30);
  unsigned int v4 = *(_DWORD *)(a2 + 224);
  if ((v4 & 0x8000) != 0)
  {
LABEL_84:
    *(_DWORD *)(a1 + 224) |= 0x8000u;
    int v31 = *(_DWORD **)(a1 + 112);
    if (!v31) {
      operator new();
    }
    uint64_t v32 = *(void *)(a2 + 112);
    if (!v32) {
      uint64_t v32 = *(void *)(qword_10248AFE8 + 112);
    }
    sub_100FDBAC4(v31, v32);
    unsigned int v4 = *(_DWORD *)(a2 + 224);
  }
LABEL_89:
  if ((v4 & 0xFF0000) != 0)
  {
    if ((v4 & 0x10000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x10000u;
      uint64_t v33 = *(void *)(a1 + 120);
      if (!v33) {
        operator new();
      }
      uint64_t v34 = *(void *)(a2 + 120);
      if (!v34) {
        uint64_t v34 = *(void *)(qword_10248AFE8 + 120);
      }
      sub_100FDBBB0(v33, v34);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x20000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x20000u;
      uint64_t v35 = *(void *)(a1 + 128);
      if (!v35) {
        operator new();
      }
      uint64_t v36 = *(void *)(a2 + 128);
      if (!v36) {
        uint64_t v36 = *(void *)(qword_10248AFE8 + 128);
      }
      sub_1008C7E1C(v35, v36);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x40000) != 0)
    {
      uint64_t v37 = *(const std::string **)(a2 + 136);
      *(_DWORD *)(a1 + 224) |= 0x40000u;
      uint64_t v38 = *(std::string **)(a1 + 136);
      if (v38 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v38, v37);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x80000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x80000u;
      uint64_t v39 = *(void *)(a1 + 144);
      if (!v39) {
        operator new();
      }
      uint64_t v40 = *(void *)(a2 + 144);
      if (!v40) {
        uint64_t v40 = *(void *)(qword_10248AFE8 + 144);
      }
      sub_1008E55C4(v39, v40);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x100000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x100000u;
      uint64_t v41 = *(void *)(a1 + 152);
      if (!v41) {
        operator new();
      }
      uint64_t v42 = *(void *)(a2 + 152);
      if (!v42) {
        uint64_t v42 = *(void *)(qword_10248AFE8 + 152);
      }
      sub_1008EAF6C(v41, v42);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x200000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x200000u;
      uint64_t v43 = *(void *)(a1 + 160);
      if (!v43) {
        operator new();
      }
      uint64_t v44 = *(void *)(a2 + 160);
      if (!v44) {
        uint64_t v44 = *(void *)(qword_10248AFE8 + 160);
      }
      sub_1008F0F00(v43, v44);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x400000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x400000u;
      uint64_t v45 = *(void *)(a1 + 168);
      if (!v45) {
        operator new();
      }
      uint64_t v46 = *(void *)(a2 + 168);
      if (!v46) {
        uint64_t v46 = *(void *)(qword_10248AFE8 + 168);
      }
      sub_1008FDB30(v45, v46);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x800000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x800000u;
      uint64_t v47 = *(void *)(a1 + 176);
      if (!v47) {
        operator new();
      }
      uint64_t v48 = *(void *)(a2 + 176);
      if (!v48) {
        uint64_t v48 = *(void *)(qword_10248AFE8 + 176);
      }
      sub_1009014F4(v47, v48);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
  }
  if (HIBYTE(v4))
  {
    if ((v4 & 0x1000000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x1000000u;
      uint64_t v49 = *(void *)(a1 + 184);
      if (!v49) {
        operator new();
      }
      uint64_t v50 = *(void *)(a2 + 184);
      if (!v50) {
        uint64_t v50 = *(void *)(qword_10248AFE8 + 184);
      }
      sub_1008D1874(v49, v50);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x2000000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x2000000u;
      uint64_t v51 = *(void *)(a1 + 192);
      if (!v51) {
        operator new();
      }
      uint64_t v52 = *(void *)(a2 + 192);
      if (!v52) {
        uint64_t v52 = *(void *)(qword_10248AFE8 + 192);
      }
      sub_1008CF980(v51, v52);
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x4000000) != 0)
    {
      int v53 = *(_DWORD *)(a2 + 200);
      *(_DWORD *)(a1 + 224) |= 0x4000000u;
      *(_DWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = v53;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x8000000) != 0)
    {
      unsigned int v54 = *(_DWORD *)(a2 + 204);
      if (v54 >= 3 && v54 != 4) {
        sub_101A9C18C();
      }
      *(_DWORD *)(a1 + 224) |= 0x8000000u;
      *(_DWORD *)(a1 + 204) = v54;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x10000000) != 0)
    {
      int v55 = *(_DWORD *)(a2 + 216);
      *(_DWORD *)(a1 + 224) |= 0x10000000u;
      *(_DWORD *)(a1 + 216) = v55;
      unsigned int v4 = *(_DWORD *)(a2 + 224);
    }
    if ((v4 & 0x20000000) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x20000000u;
      uint64_t v56 = *(void *)(a1 + 208);
      if (!v56) {
        operator new();
      }
      uint64_t v57 = *(void *)(a2 + 208);
      if (!v57) {
        uint64_t v57 = *(void *)(qword_10248AFE8 + 208);
      }
      sub_1008CC708(v56, v57);
    }
  }
}

void sub_100FD7FB4()
{
}

void *sub_100FD80FC(void *result)
{
  int v1 = result;
  uint64_t v2 = result[17];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  if ((void *)qword_10248AFE8 != result)
  {
    uint64_t v4 = result[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    uint64_t v11 = v1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    uint64_t v12 = v1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = v1[13];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    uint64_t v14 = v1[14];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    uint64_t v15 = v1[15];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v16 = v1[16];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
    uint64_t v17 = v1[18];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    uint64_t v18 = v1[19];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
    uint64_t v19 = v1[20];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    uint64_t v20 = v1[21];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
    uint64_t v21 = v1[22];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    }
    uint64_t v22 = v1[23];
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    uint64_t v23 = v1[24];
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    uint64_t result = (void *)v1[26];
    if (result)
    {
      uint64_t v24 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v24();
    }
  }
  return result;
}

void sub_100FD8520(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308C40;
  sub_100FD80FC(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FD8574(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308C40;
  sub_100FD80FC(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FD85DC()
{
}

uint64_t sub_100FD8664(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)(result + 224);
  if ((_BYTE)v2)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    if ((v2 & 8) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result)
      {
        uint64_t result = sub_10074AA28(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      uint64_t result = *(void *)(v1 + 32);
      if (result)
      {
        uint64_t result = sub_100E3793C(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x20) != 0)
    {
      uint64_t result = *(void *)(v1 + 40);
      if (result)
      {
        uint64_t result = sub_10074DC44(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x40) != 0)
    {
      uint64_t v3 = *(void *)(v1 + 48);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 32))
        {
          *(void *)(v3 + 8) = 0;
          *(void *)(v3 + 16) = 0;
          *(_DWORD *)(v3 + 23) = 0;
        }
        *(_DWORD *)(v3 + 32) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x80) != 0)
    {
      uint64_t result = *(void *)(v1 + 56);
      if (result)
      {
        uint64_t result = sub_10074C0E8(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      uint64_t result = *(void *)(v1 + 64);
      if (result)
      {
        uint64_t result = sub_100FD88E8(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x200) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 72);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 16)) {
          *(_DWORD *)(v4 + 8) = 0;
        }
        *(_DWORD *)(v4 + 16) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x400) != 0)
    {
      uint64_t result = *(void *)(v1 + 80);
      if (result)
      {
        uint64_t result = sub_10074E830(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x800) != 0)
    {
      uint64_t result = *(void *)(v1 + 88);
      if (result)
      {
        uint64_t result = sub_10074E2E4(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    *(void *)(v1 + 96) = 0;
    if ((v2 & 0x4000) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 104);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 16)) {
          *(unsigned char *)(v5 + 8) = 0;
        }
        *(_DWORD *)(v5 + 16) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x8000) != 0)
    {
      uint64_t v6 = *(void *)(v1 + 112);
      if (v6)
      {
        if (*(unsigned char *)(v6 + 24))
        {
          *(void *)(v6 + 8) = 0;
          *(_DWORD *)(v6 + 16) = 0;
        }
        *(_DWORD *)(v6 + 24) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }
  if ((v2 & 0xFF0000) != 0)
  {
    if ((v2 & 0x10000) != 0)
    {
      uint64_t result = *(void *)(v1 + 120);
      if (result)
      {
        uint64_t result = sub_100FD8978(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x20000) != 0)
    {
      uint64_t result = *(void *)(v1 + 128);
      if (result)
      {
        uint64_t result = sub_1008C8268(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x40000) != 0)
    {
      uint64_t v7 = *(void *)(v1 + 136);
      if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(unsigned char **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 23) = 0;
        }
      }
    }
    unsigned int v2 = *(_DWORD *)(v1 + 224);
    if ((v2 & 0x80000) != 0)
    {
      uint64_t result = *(void *)(v1 + 144);
      if (result)
      {
        uint64_t result = sub_1008E5B88(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x100000) != 0)
    {
      uint64_t result = *(void *)(v1 + 152);
      if (result)
      {
        uint64_t result = sub_1008EB410(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x200000) != 0)
    {
      uint64_t result = *(void *)(v1 + 160);
      if (result)
      {
        uint64_t result = sub_1008F136C(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x400000) != 0)
    {
      uint64_t result = *(void *)(v1 + 168);
      if (result)
      {
        uint64_t result = sub_1008FDCD0(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x800000) != 0)
    {
      uint64_t result = *(void *)(v1 + 176);
      if (result)
      {
        uint64_t result = sub_1009019AC(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }
  if (HIBYTE(v2))
  {
    if ((v2 & 0x1000000) != 0)
    {
      uint64_t result = *(void *)(v1 + 184);
      if (result)
      {
        uint64_t result = sub_1008D1DCC(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    if ((v2 & 0x2000000) != 0)
    {
      uint64_t result = *(void *)(v1 + 192);
      if (result)
      {
        uint64_t result = sub_1008CFE6C(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
    *(void *)(v1 + 20sub_100FB8FC8(&a9, 0) = 0;
    *(_DWORD *)(v1 + 216) = 0;
    if ((v2 & 0x20000000) != 0)
    {
      uint64_t result = *(void *)(v1 + 208);
      if (result) {
        uint64_t result = sub_1008CC8C4(result);
      }
    }
  }
  *(_DWORD *)(v1 + 224) = 0;
  return result;
}

uint64_t sub_100FD88D0(uint64_t result)
{
  if (*(unsigned char *)(result + 32))
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(_DWORD *)(result + 23) = 0;
  }
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FD88E8(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 44) & 2) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2)
    {
      if (*(unsigned char *)(v2 + 20))
      {
        *(_DWORD *)(v2 + 11) = 0;
        *(_DWORD *)(v2 + 8) = 0;
      }
      *(_DWORD *)(v2 + 2sub_100FB8FC8(&a9, 0) = 0;
    }
  }
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 44) = 0;
  return result;
}

uint64_t sub_100FD8938(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(_DWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FD894C(uint64_t result)
{
  if (*(unsigned char *)(result + 16)) {
    *(unsigned char *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100FD8960(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100FD8978(uint64_t result)
{
  char v1 = *(unsigned char *)(result + 36);
  if (v1)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *(void *)(result + 24);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100FD89C4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 16);
  uint64_t v6 = (unsigned int *)(a1 + 200);
  uint64_t v7 = (unsigned int *)(a1 + 216);
  while (2)
  {
    uint64_t v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        unsigned int v234 = 0;
        uint64_t v11 = (char *)*((void *)this + 1);
        if ((unint64_t)v11 < *((void *)this + 2) && (*v11 & 0x80000000) == 0)
        {
          unsigned int v12 = *v11;
          *((void *)this + 1) = v11 + 1;
          goto LABEL_91;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234);
        if (result)
        {
          unsigned int v12 = v234;
LABEL_91:
          if (v12 - 9 < 0x13 || v12 <= 5)
          {
            if (v12 - 9 >= 0x13 && v12 >= 6) {
              sub_101A9C23C();
            }
            *(_DWORD *)(a1 + 224) |= 1u;
            *(_DWORD *)(a1 + 8) = v12;
          }
          uint64_t v40 = (unsigned char *)*((void *)this + 1);
          unint64_t v15 = *((void *)this + 2);
          if ((unint64_t)v40 < v15 && *v40 == 16)
          {
            uint64_t v16 = v40 + 1;
            *((void *)this + 1) = v16;
            goto LABEL_103;
          }
          continue;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
LABEL_103:
        unsigned int v234 = 0;
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234);
          if (!result) {
            return result;
          }
          unsigned int v41 = v234;
        }
        else
        {
          unsigned int v41 = *v16;
          *((void *)this + 1) = v16 + 1;
        }
        if (sub_100FCD768())
        {
          *(_DWORD *)(a1 + 224) |= 2u;
          *(_DWORD *)(a1 + 12) = v41;
        }
        uint64_t v42 = (unsigned char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        if ((unint64_t)v42 >= v17 || *v42 != 24) {
          continue;
        }
        uint64_t v18 = v42 + 1;
        *((void *)this + 1) = v18;
LABEL_113:
        if ((unint64_t)v18 >= v17 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v43 = (unsigned char *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v18;
          uint64_t v43 = v18 + 1;
          *((void *)this + 1) = v43;
        }
        int v24 = *(_DWORD *)(a1 + 224) | 4;
        *(_DWORD *)(a1 + 224) = v24;
        if ((unint64_t)v43 >= v17 || *v43 != 34) {
          continue;
        }
        *((void *)this + 1) = v43 + 1;
LABEL_121:
        *(_DWORD *)(a1 + 224) = v24 | 8;
        uint64_t v44 = *(void *)(a1 + 24);
        if (!v44) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v45 = (char *)*((void *)this + 1);
        if ((unint64_t)v45 >= *((void *)this + 2) || *v45 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v45;
          *((void *)this + 1) = v45 + 1;
        }
        int v46 = *((_DWORD *)this + 14);
        int v47 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v46 + 1;
        if (v46 >= v47) {
          return 0;
        }
        int v48 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_10074AAF4(v44, this, v49) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v48);
        int v50 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v50, 1);
        int v51 = v50 - 1;
        if (v51 < 0 == v35) {
          *((_DWORD *)this + 14) = v51;
        }
        uint64_t v52 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v52 >= *((void *)this + 2) || *v52 != 42) {
          continue;
        }
        *((void *)this + 1) = v52 + 1;
LABEL_135:
        *(_DWORD *)(a1 + 224) |= 0x10u;
        uint64_t v53 = *(void *)(a1 + 32);
        if (!v53) {
          operator new();
        }
        unsigned int v234 = 0;
        unsigned int v54 = (char *)*((void *)this + 1);
        if ((unint64_t)v54 >= *((void *)this + 2) || *v54 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v54;
          *((void *)this + 1) = v54 + 1;
        }
        int v55 = *((_DWORD *)this + 14);
        int v56 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v55 + 1;
        if (v55 >= v56) {
          return 0;
        }
        int v57 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100E37A08(v53, this, v58) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v57);
        int v59 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v59, 1);
        int v60 = v59 - 1;
        if (v60 < 0 == v35) {
          *((_DWORD *)this + 14) = v60;
        }
        uint64_t v61 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v61 >= *((void *)this + 2) || *v61 != 50) {
          continue;
        }
        *((void *)this + 1) = v61 + 1;
LABEL_149:
        *(_DWORD *)(a1 + 224) |= 0x20u;
        uint64_t v62 = *(void *)(a1 + 40);
        if (!v62) {
          operator new();
        }
        unsigned int v234 = 0;
        int v63 = (char *)*((void *)this + 1);
        if ((unint64_t)v63 >= *((void *)this + 2) || *v63 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v63;
          *((void *)this + 1) = v63 + 1;
        }
        int v64 = *((_DWORD *)this + 14);
        int v65 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v64 + 1;
        if (v64 >= v65) {
          return 0;
        }
        int v66 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_10074DC64(v62, this, v67) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v66);
        int v68 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v68, 1);
        int v69 = v68 - 1;
        if (v69 < 0 == v35) {
          *((_DWORD *)this + 14) = v69;
        }
        int v70 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v70 >= *((void *)this + 2) || *v70 != 74) {
          continue;
        }
        *((void *)this + 1) = v70 + 1;
LABEL_163:
        *(_DWORD *)(a1 + 224) |= 0x40u;
        uint64_t v71 = *(void *)(a1 + 48);
        if (!v71) {
          operator new();
        }
        unsigned int v234 = 0;
        int v72 = (char *)*((void *)this + 1);
        if ((unint64_t)v72 >= *((void *)this + 2) || *v72 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v72;
          *((void *)this + 1) = v72 + 1;
        }
        int v73 = *((_DWORD *)this + 14);
        int v74 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v73 + 1;
        if (v73 >= v74) {
          return 0;
        }
        int v75 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FDBDB8(v71, this, v76) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v75);
        int v77 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v77, 1);
        int v78 = v77 - 1;
        if (v78 < 0 == v35) {
          *((_DWORD *)this + 14) = v78;
        }
        int v79 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v79 >= *((void *)this + 2) || *v79 != 82) {
          continue;
        }
        *((void *)this + 1) = v79 + 1;
LABEL_177:
        *(_DWORD *)(a1 + 224) |= 0x80u;
        uint64_t v80 = *(void *)(a1 + 56);
        if (!v80) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v81 = (char *)*((void *)this + 1);
        if ((unint64_t)v81 >= *((void *)this + 2) || *v81 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v81;
          *((void *)this + 1) = v81 + 1;
        }
        int v82 = *((_DWORD *)this + 14);
        int v83 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v82 + 1;
        if (v82 >= v83) {
          return 0;
        }
        int v84 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_10074C12C(v80, this, v85) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v84);
        int v86 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v86, 1);
        int v87 = v86 - 1;
        if (v87 < 0 == v35) {
          *((_DWORD *)this + 14) = v87;
        }
        int v88 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v88 <= 1 || *v88 != 130 || v88[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v88 + 2;
LABEL_192:
        *(_DWORD *)(a1 + 224) |= 0x100u;
        uint64_t v89 = *(void *)(a1 + 64);
        if (!v89) {
          operator new();
        }
        unsigned int v234 = 0;
        int v90 = (char *)*((void *)this + 1);
        if ((unint64_t)v90 >= *((void *)this + 2) || *v90 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v90;
          *((void *)this + 1) = v90 + 1;
        }
        int v91 = *((_DWORD *)this + 14);
        int v92 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v91 + 1;
        if (v91 >= v92) {
          return 0;
        }
        int v93 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FE4274(v89, this, v94) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v93);
        int v95 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v95, 1);
        int v96 = v95 - 1;
        if (v96 < 0 == v35) {
          *((_DWORD *)this + 14) = v96;
        }
        int v97 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v97 <= 1 || *v97 != 138 || v97[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v97 + 2;
LABEL_207:
        *(_DWORD *)(a1 + 224) |= 0x200u;
        uint64_t v98 = *(void *)(a1 + 72);
        if (!v98) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v99 = (char *)*((void *)this + 1);
        if ((unint64_t)v99 >= *((void *)this + 2) || *v99 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v99;
          *((void *)this + 1) = v99 + 1;
        }
        int v100 = *((_DWORD *)this + 14);
        int v101 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v100 + 1;
        if (v100 >= v101) {
          return 0;
        }
        int v102 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FE48B4(v98, this, v103) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v102);
        int v104 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v104, 1);
        int v105 = v104 - 1;
        if (v105 < 0 == v35) {
          *((_DWORD *)this + 14) = v105;
        }
        int v106 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v106 <= 1 || *v106 != 146 || v106[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v106 + 2;
LABEL_222:
        *(_DWORD *)(a1 + 224) |= 0x400u;
        uint64_t v107 = *(void *)(a1 + 80);
        if (!v107) {
          operator new();
        }
        unsigned int v234 = 0;
        v108 = (char *)*((void *)this + 1);
        if ((unint64_t)v108 >= *((void *)this + 2) || *v108 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v108;
          *((void *)this + 1) = v108 + 1;
        }
        int v109 = *((_DWORD *)this + 14);
        int v110 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v109 + 1;
        if (v109 >= v110) {
          return 0;
        }
        int v111 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_10074E84C(v107, this, v112) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v111);
        int v113 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v113, 1);
        int v114 = v113 - 1;
        if (v114 < 0 == v35) {
          *((_DWORD *)this + 14) = v114;
        }
        uint64_t v115 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v115 <= 1 || *v115 != 154 || v115[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v115 + 2;
LABEL_237:
        *(_DWORD *)(a1 + 224) |= 0x800u;
        uint64_t v116 = *(void *)(a1 + 88);
        if (!v116) {
          operator new();
        }
        unsigned int v234 = 0;
        int v117 = (char *)*((void *)this + 1);
        if ((unint64_t)v117 >= *((void *)this + 2) || *v117 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v117;
          *((void *)this + 1) = v117 + 1;
        }
        int v118 = *((_DWORD *)this + 14);
        int v119 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v118 + 1;
        if (v118 >= v119) {
          return 0;
        }
        int v120 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_10074E2FC(v116, this, v121) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v120);
        int v122 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v122, 1);
        int v123 = v122 - 1;
        if (v123 < 0 == v35) {
          *((_DWORD *)this + 14) = v123;
        }
        int v124 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        if ((int)v19 - (int)v124 <= 1 || *v124 != 160 || v124[1] != 1) {
          continue;
        }
        uint64_t v20 = (char *)(v124 + 2);
        *((void *)this + 1) = v20;
LABEL_252:
        unsigned int v234 = 0;
        if ((unint64_t)v20 >= v19 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234);
          if (!result) {
            return result;
          }
          unsigned int v125 = v234;
        }
        else
        {
          unsigned int v125 = *v20;
          *((void *)this + 1) = v20 + 1;
        }
        if (sub_100748708(v125))
        {
          if (!sub_100748708(v125)) {
            sub_101A9C1B8();
          }
          *(_DWORD *)(a1 + 224) |= 0x2000u;
          *(_DWORD *)(a1 + 10sub_100FB8FC8(&a9, 0) = v125;
        }
        uint64_t v126 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v126 < 2 || *v126 != 170 || v126[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v126 + 2;
LABEL_264:
        *(_DWORD *)(a1 + 224) |= 0x4000u;
        uint64_t v127 = *(void *)(a1 + 104);
        if (!v127) {
          operator new();
        }
        unsigned int v234 = 0;
        int v128 = (char *)*((void *)this + 1);
        if ((unint64_t)v128 >= *((void *)this + 2) || *v128 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v128;
          *((void *)this + 1) = v128 + 1;
        }
        int v129 = *((_DWORD *)this + 14);
        int v130 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v129 + 1;
        if (v129 >= v130) {
          return 0;
        }
        int v131 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FE805C(v127, this, v132) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v131);
        int v133 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v133, 1);
        int v134 = v133 - 1;
        if (v134 < 0 == v35) {
          *((_DWORD *)this + 14) = v134;
        }
        uint64_t v135 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v25 = *((void *)this + 2);
        if ((int)v25 - (int)v135 <= 1 || *v135 != 176 || v135[1] != 1) {
          continue;
        }
        uint64_t v26 = (char *)(v135 + 2);
        *((void *)this + 1) = v26;
LABEL_279:
        unsigned int v234 = 0;
        if ((unint64_t)v26 >= v25 || *v26 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234);
          if (!result) {
            return result;
          }
          unsigned int v136 = v234;
        }
        else
        {
          unsigned int v136 = *v26;
          *((void *)this + 1) = v26 + 1;
        }
        if (sub_100748708(v136))
        {
          if (!sub_100748708(v136)) {
            sub_101A9C1E4();
          }
          *(_DWORD *)(a1 + 224) |= 0x1000u;
          *(_DWORD *)(a1 + 96) = v136;
        }
        int v137 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v137 < 2 || *v137 != 186 || v137[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v137 + 2;
LABEL_291:
        *(_DWORD *)(a1 + 224) |= 0x8000u;
        int v138 = *(_DWORD **)(a1 + 112);
        if (!v138) {
          operator new();
        }
        unsigned int v234 = 0;
        unsigned int v139 = (char *)*((void *)this + 1);
        if ((unint64_t)v139 >= *((void *)this + 2) || *v139 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v139;
          *((void *)this + 1) = v139 + 1;
        }
        int v140 = *((_DWORD *)this + 14);
        int v141 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v140 + 1;
        if (v140 >= v141) {
          return 0;
        }
        int v142 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FE837C(v138, this, v143) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v142);
        int v144 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v144, 1);
        int v145 = v144 - 1;
        if (v145 < 0 == v35) {
          *((_DWORD *)this + 14) = v145;
        }
        int v146 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v146 <= 1 || *v146 != 202 || v146[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v146 + 2;
LABEL_306:
        *(_DWORD *)(a1 + 224) |= 0x10000u;
        uint64_t v147 = *(void *)(a1 + 120);
        if (!v147) {
          operator new();
        }
        unsigned int v234 = 0;
        unsigned int v148 = (char *)*((void *)this + 1);
        if ((unint64_t)v148 >= *((void *)this + 2) || *v148 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v148;
          *((void *)this + 1) = v148 + 1;
        }
        int v149 = *((_DWORD *)this + 14);
        int v150 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v149 + 1;
        if (v149 >= v150) {
          return 0;
        }
        int v151 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100FE88C4(v147, this, v152) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v151);
        int v153 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v153, 1);
        int v154 = v153 - 1;
        if (v154 < 0 == v35) {
          *((_DWORD *)this + 14) = v154;
        }
        uint64_t v155 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v155 <= 1 || *v155 != 242 || v155[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v155 + 2;
LABEL_321:
        *(_DWORD *)(a1 + 224) |= 0x20000u;
        uint64_t v156 = *(void *)(a1 + 128);
        if (!v156) {
          operator new();
        }
        unsigned int v234 = 0;
        int v157 = (char *)*((void *)this + 1);
        if ((unint64_t)v157 >= *((void *)this + 2) || *v157 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v157;
          *((void *)this + 1) = v157 + 1;
        }
        int v158 = *((_DWORD *)this + 14);
        int v159 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v158 + 1;
        if (v158 >= v159) {
          return 0;
        }
        int v160 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008C82B8(v156, this, v161) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v160);
        int v162 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v162, 1);
        int v163 = v162 - 1;
        if (v163 < 0 == v35) {
          *((_DWORD *)this + 14) = v163;
        }
        int v164 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v164 <= 1 || *v164 != 250 || v164[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v164 + 2;
LABEL_336:
        *(_DWORD *)(a1 + 224) |= 0x40000u;
        if (*(_UNKNOWN **)(a1 + 136) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v165 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v165 < 2 || *v165 != 194 || v165[1] != 2) {
          continue;
        }
        *((void *)this + 1) = v165 + 2;
LABEL_343:
        *(_DWORD *)(a1 + 224) |= 0x80000u;
        uint64_t v166 = *(void *)(a1 + 144);
        if (!v166) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v167 = (char *)*((void *)this + 1);
        if ((unint64_t)v167 >= *((void *)this + 2) || *v167 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v167;
          *((void *)this + 1) = v167 + 1;
        }
        int v168 = *((_DWORD *)this + 14);
        int v169 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v168 + 1;
        if (v168 >= v169) {
          return 0;
        }
        int v170 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008E5C3C(v166, this, v171) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v170);
        int v172 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v172, 1);
        int v173 = v172 - 1;
        if (v173 < 0 == v35) {
          *((_DWORD *)this + 14) = v173;
        }
        int v174 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v174 <= 1 || *v174 != 202 || v174[1] != 2) {
          continue;
        }
        *((void *)this + 1) = v174 + 2;
LABEL_358:
        *(_DWORD *)(a1 + 224) |= 0x100000u;
        uint64_t v175 = *(void *)(a1 + 152);
        if (!v175) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v176 = (char *)*((void *)this + 1);
        if ((unint64_t)v176 >= *((void *)this + 2) || *v176 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v176;
          *((void *)this + 1) = v176 + 1;
        }
        int v177 = *((_DWORD *)this + 14);
        int v178 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v177 + 1;
        if (v177 >= v178) {
          return 0;
        }
        int v179 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008EB490(v175, this, v180) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v179);
        int v181 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v181, 1);
        int v182 = v181 - 1;
        if (v182 < 0 == v35) {
          *((_DWORD *)this + 14) = v182;
        }
        int v183 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v183 <= 1 || *v183 != 210 || v183[1] != 2) {
          continue;
        }
        *((void *)this + 1) = v183 + 2;
LABEL_373:
        *(_DWORD *)(a1 + 224) |= 0x200000u;
        uint64_t v184 = *(void *)(a1 + 160);
        if (!v184) {
          operator new();
        }
        unsigned int v234 = 0;
        int v185 = (char *)*((void *)this + 1);
        if ((unint64_t)v185 >= *((void *)this + 2) || *v185 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v185;
          *((void *)this + 1) = v185 + 1;
        }
        int v186 = *((_DWORD *)this + 14);
        int v187 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v186 + 1;
        if (v186 >= v187) {
          return 0;
        }
        int v188 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008F13FC(v184, this, v189) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v188);
        int v190 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v190, 1);
        int v191 = v190 - 1;
        if (v191 < 0 == v35) {
          *((_DWORD *)this + 14) = v191;
        }
        int v192 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v192 <= 1 || *v192 != 218 || v192[1] != 2) {
          continue;
        }
        *((void *)this + 1) = v192 + 2;
LABEL_388:
        *(_DWORD *)(a1 + 224) |= 0x400000u;
        uint64_t v193 = *(void *)(a1 + 168);
        if (!v193) {
          operator new();
        }
        unsigned int v234 = 0;
        int v194 = (char *)*((void *)this + 1);
        if ((unint64_t)v194 >= *((void *)this + 2) || *v194 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v194;
          *((void *)this + 1) = v194 + 1;
        }
        int v195 = *((_DWORD *)this + 14);
        int v196 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v195 + 1;
        if (v195 >= v196) {
          return 0;
        }
        int v197 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008FDCE4(v193, this, v198) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v197);
        int v199 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v199, 1);
        int v200 = v199 - 1;
        if (v200 < 0 == v35) {
          *((_DWORD *)this + 14) = v200;
        }
        int v201 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v201 <= 1 || *v201 != 226 || v201[1] != 2) {
          continue;
        }
        *((void *)this + 1) = v201 + 2;
LABEL_403:
        *(_DWORD *)(a1 + 224) |= 0x800000u;
        uint64_t v202 = *(void *)(a1 + 176);
        if (!v202) {
          operator new();
        }
        unsigned int v234 = 0;
        int v203 = (char *)*((void *)this + 1);
        if ((unint64_t)v203 >= *((void *)this + 2) || *v203 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v203;
          *((void *)this + 1) = v203 + 1;
        }
        int v204 = *((_DWORD *)this + 14);
        int v205 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v204 + 1;
        if (v204 >= v205) {
          return 0;
        }
        int v206 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_100901A2C(v202, this, v207) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v206);
        int v208 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v208, 1);
        int v209 = v208 - 1;
        if (v209 < 0 == v35) {
          *((_DWORD *)this + 14) = v209;
        }
        int v210 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v210 <= 1 || *v210 != 146 || v210[1] != 3) {
          continue;
        }
        *((void *)this + 1) = v210 + 2;
LABEL_418:
        *(_DWORD *)(a1 + 224) |= 0x1000000u;
        uint64_t v211 = *(void *)(a1 + 184);
        if (!v211) {
          operator new();
        }
        unsigned int v234 = 0;
        int v212 = (char *)*((void *)this + 1);
        if ((unint64_t)v212 >= *((void *)this + 2) || *v212 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v212;
          *((void *)this + 1) = v212 + 1;
        }
        int v213 = *((_DWORD *)this + 14);
        int v214 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v213 + 1;
        if (v213 >= v214) {
          return 0;
        }
        int v215 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008D1E84(v211, this, v216) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v215);
        int v217 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v217, 1);
        int v218 = v217 - 1;
        if (v218 < 0 == v35) {
          *((_DWORD *)this + 14) = v218;
        }
        int v219 = (unsigned __int8 *)*((void *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v219 <= 1 || *v219 != 154 || v219[1] != 3) {
          continue;
        }
        *((void *)this + 1) = v219 + 2;
LABEL_433:
        *(_DWORD *)(a1 + 224) |= 0x2000000u;
        uint64_t v220 = *(void *)(a1 + 192);
        if (!v220) {
          operator new();
        }
        unsigned int v234 = 0;
        int v221 = (char *)*((void *)this + 1);
        if ((unint64_t)v221 >= *((void *)this + 2) || *v221 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v221;
          *((void *)this + 1) = v221 + 1;
        }
        int v222 = *((_DWORD *)this + 14);
        int v223 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v222 + 1;
        if (v222 >= v223) {
          return 0;
        }
        int v224 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008CFF08(v220, this, v225) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v224);
        int v226 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v226, 1);
        int v227 = v226 - 1;
        if (v227 < 0 == v35) {
          *((_DWORD *)this + 14) = v227;
        }
        int v228 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        if ((int)v27 - (int)v228 <= 1 || *v228 != 160 || v228[1] != 3) {
          continue;
        }
        unsigned int v28 = v228 + 2;
        *((void *)this + 1) = v28;
LABEL_448:
        if ((unint64_t)v28 >= v27 || (char)*v28 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unsigned int v229 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v27 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v6 = *v28;
          unsigned int v229 = v28 + 1;
          *((void *)this + 1) = v229;
        }
        *(_DWORD *)(a1 + 224) |= 0x4000000u;
        if ((int)v27 - (int)v229 < 2 || *v229 != 168 || v229[1] != 3) {
          continue;
        }
        uint64_t v29 = (char *)(v229 + 2);
        *((void *)this + 1) = v29;
LABEL_457:
        unsigned int v234 = 0;
        if ((unint64_t)v29 >= v27 || *v29 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234);
          if (!result) {
            return result;
          }
          unsigned int v230 = v234;
        }
        else
        {
          unsigned int v230 = *v29;
          *((void *)this + 1) = v29 + 1;
        }
        if (v230 <= 4 && v230 != 3)
        {
          *(_DWORD *)(a1 + 224) |= 0x8000000u;
          *(_DWORD *)(a1 + 204) = v230;
        }
        v232 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        if ((int)v13 - (int)v232 < 2 || *v232 != 176 || v232[1] != 3) {
          continue;
        }
        uint64_t v14 = v232 + 2;
        *((void *)this + 1) = v14;
LABEL_471:
        if ((unint64_t)v14 >= v13 || (char)*v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          uint64_t v233 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v14;
          uint64_t v233 = v14 + 1;
          *((void *)this + 1) = v233;
        }
        int v21 = *(_DWORD *)(a1 + 224) | 0x10000000;
        *(_DWORD *)(a1 + 224) = v21;
        if ((int)v13 - (int)v233 < 2 || *v233 != 186 || v233[1] != 3) {
          continue;
        }
        *((void *)this + 1) = v233 + 2;
LABEL_45:
        *(_DWORD *)(a1 + 224) = v21 | 0x20000000;
        uint64_t v22 = *(void *)(a1 + 208);
        if (!v22) {
          operator new();
        }
        unsigned int v234 = 0;
        uint64_t v23 = (char *)*((void *)this + 1);
        if ((unint64_t)v23 >= *((void *)this + 2) || *v23 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v234))return 0; {
        }
          }
        else
        {
          unsigned int v234 = *v23;
          *((void *)this + 1) = v23 + 1;
        }
        int v30 = *((_DWORD *)this + 14);
        int v31 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v30 + 1;
        if (v30 >= v31) {
          return 0;
        }
        int v32 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v234);
        if (!sub_1008CC8DC(v22, this, v33) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v32);
        int v34 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v34, 1);
        int v36 = v34 - 1;
        if (v36 < 0 == v35) {
          *((_DWORD *)this + 14) = v36;
        }
        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_113;
      case 4u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_75;
        }
        int v24 = *(_DWORD *)(a1 + 224);
        goto LABEL_121;
      case 5u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_135;
        }
        goto LABEL_75;
      case 6u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_149;
        }
        goto LABEL_75;
      case 9u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_163;
        }
        goto LABEL_75;
      case 0xAu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_177;
        }
        goto LABEL_75;
      case 0x10u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_192;
        }
        goto LABEL_75;
      case 0x11u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_207;
        }
        goto LABEL_75;
      case 0x12u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_222;
        }
        goto LABEL_75;
      case 0x13u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_237;
        }
        goto LABEL_75;
      case 0x14u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v20 = (char *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        goto LABEL_252;
      case 0x15u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_264;
        }
        goto LABEL_75;
      case 0x16u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v26 = (char *)*((void *)this + 1);
        unint64_t v25 = *((void *)this + 2);
        goto LABEL_279;
      case 0x17u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_291;
        }
        goto LABEL_75;
      case 0x19u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_306;
        }
        goto LABEL_75;
      case 0x1Eu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_321;
        }
        goto LABEL_75;
      case 0x1Fu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_336;
        }
        goto LABEL_75;
      case 0x28u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_343;
        }
        goto LABEL_75;
      case 0x29u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_358;
        }
        goto LABEL_75;
      case 0x2Au:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_373;
        }
        goto LABEL_75;
      case 0x2Bu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_388;
        }
        goto LABEL_75;
      case 0x2Cu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_403;
        }
        goto LABEL_75;
      case 0x32u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_418;
        }
        goto LABEL_75;
      case 0x33u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_433;
        }
        goto LABEL_75;
      case 0x34u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        unsigned int v28 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        goto LABEL_448;
      case 0x35u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v29 = (char *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        goto LABEL_457;
      case 0x36u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_75;
        }
        uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_471;
      case 0x37u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_75;
        }
        int v21 = *(_DWORD *)(a1 + 224);
        goto LABEL_45;
      default:
        int v10 = TagFallback & 7;
LABEL_75:
        if (v10 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
    return result;
  }
}

void sub_100FDA678()
{
}

uint64_t sub_100FDA888(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 224);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), (int)a2, a4);
    int v6 = *(_DWORD *)(v5 + 224);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_34;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_35;
  }
LABEL_34:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(void *)(v5 + 16), (unint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_38;
  }
LABEL_35:
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_10248AFE8 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_41;
  }
LABEL_38:
  uint64_t v8 = *(void *)(v5 + 32);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_10248AFE8 + 32);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_44;
  }
LABEL_41:
  uint64_t v9 = *(void *)(v5 + 40);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248AFE8 + 40);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_47;
  }
LABEL_44:
  uint64_t v10 = *(void *)(v5 + 48);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_10248AFE8 + 48);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v10, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_50;
  }
LABEL_47:
  uint64_t v11 = *(void *)(v5 + 56);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_10248AFE8 + 56);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v11, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_53;
  }
LABEL_50:
  uint64_t v12 = *(void *)(v5 + 64);
  if (!v12) {
    uint64_t v12 = *(void *)(qword_10248AFE8 + 64);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, v12, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_56;
  }
LABEL_53:
  uint64_t v13 = *(void *)(v5 + 72);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248AFE8 + 72);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v13, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_59;
  }
LABEL_56:
  uint64_t v14 = *(void *)(v5 + 80);
  if (!v14) {
    uint64_t v14 = *(void *)(qword_10248AFE8 + 80);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, v14, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_62;
  }
LABEL_59:
  uint64_t v15 = *(void *)(v5 + 88);
  if (!v15) {
    uint64_t v15 = *(void *)(qword_10248AFE8 + 88);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v15, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x2000) == 0)
  {
LABEL_14:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_63;
  }
LABEL_62:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, *(_DWORD *)(v5 + 100), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x4000) == 0)
  {
LABEL_15:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_66;
  }
LABEL_63:
  uint64_t v16 = *(void *)(v5 + 104);
  if (!v16) {
    uint64_t v16 = *(void *)(qword_10248AFE8 + 104);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v16, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x1000) == 0)
  {
LABEL_16:
    if ((v6 & 0x8000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_67;
  }
LABEL_66:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x16, *(_DWORD *)(v5 + 96), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x8000) == 0)
  {
LABEL_17:
    if ((v6 & 0x10000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_70;
  }
LABEL_67:
  uint64_t v17 = *(void *)(v5 + 112);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248AFE8 + 112);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x17, v17, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x10000) == 0)
  {
LABEL_18:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_73;
  }
LABEL_70:
  uint64_t v18 = *(void *)(v5 + 120);
  if (!v18) {
    uint64_t v18 = *(void *)(qword_10248AFE8 + 120);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x19, v18, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x20000) == 0)
  {
LABEL_19:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_76;
  }
LABEL_73:
  uint64_t v19 = *(void *)(v5 + 128);
  if (!v19) {
    uint64_t v19 = *(void *)(qword_10248AFE8 + 128);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1E, v19, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x40000) == 0)
  {
LABEL_20:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_77;
  }
LABEL_76:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x80000) == 0)
  {
LABEL_21:
    if ((v6 & 0x100000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_80;
  }
LABEL_77:
  uint64_t v20 = *(void *)(v5 + 144);
  if (!v20) {
    uint64_t v20 = *(void *)(qword_10248AFE8 + 144);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x28, v20, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x100000) == 0)
  {
LABEL_22:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_83;
  }
LABEL_80:
  uint64_t v21 = *(void *)(v5 + 152);
  if (!v21) {
    uint64_t v21 = *(void *)(qword_10248AFE8 + 152);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x29, v21, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x200000) == 0)
  {
LABEL_23:
    if ((v6 & 0x400000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_86;
  }
LABEL_83:
  uint64_t v22 = *(void *)(v5 + 160);
  if (!v22) {
    uint64_t v22 = *(void *)(qword_10248AFE8 + 160);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x2A, v22, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x400000) == 0)
  {
LABEL_24:
    if ((v6 & 0x800000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_89;
  }
LABEL_86:
  uint64_t v23 = *(void *)(v5 + 168);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_10248AFE8 + 168);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x2B, v23, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x800000) == 0)
  {
LABEL_25:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_92;
  }
LABEL_89:
  uint64_t v24 = *(void *)(v5 + 176);
  if (!v24) {
    uint64_t v24 = *(void *)(qword_10248AFE8 + 176);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x2C, v24, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x1000000) == 0)
  {
LABEL_26:
    if ((v6 & 0x2000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_95;
  }
LABEL_92:
  uint64_t v25 = *(void *)(v5 + 184);
  if (!v25) {
    uint64_t v25 = *(void *)(qword_10248AFE8 + 184);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x32, v25, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x2000000) == 0)
  {
LABEL_27:
    if ((v6 & 0x4000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_98;
  }
LABEL_95:
  uint64_t v26 = *(void *)(v5 + 192);
  if (!v26) {
    uint64_t v26 = *(void *)(qword_10248AFE8 + 192);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x33, v26, a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x4000000) == 0)
  {
LABEL_28:
    if ((v6 & 0x8000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_99;
  }
LABEL_98:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x34, *(_DWORD *)(v5 + 200), a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x8000000) == 0)
  {
LABEL_29:
    if ((v6 & 0x10000000) == 0) {
      goto LABEL_30;
    }
LABEL_100:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x36, *(_DWORD *)(v5 + 216), a2, a4);
    if ((*(_DWORD *)(v5 + 224) & 0x20000000) == 0) {
      return result;
    }
    goto LABEL_101;
  }
LABEL_99:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x35, *(_DWORD *)(v5 + 204), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x10000000) != 0) {
    goto LABEL_100;
  }
LABEL_30:
  if ((v6 & 0x20000000) == 0) {
    return result;
  }
LABEL_101:
  uint64_t v27 = *(void *)(v5 + 208);
  if (!v27) {
    uint64_t v27 = *(void *)(qword_10248AFE8 + 208);
  }

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x37, v27, a2, a4);
}

uint64_t sub_100FDAD58(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_56;
  }
  if ((v3 & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 10;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v6 = 1;
  }
  uint64_t v4 = (v6 + 1);
  if ((v3 & 2) != 0)
  {
LABEL_12:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }
    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = *(_DWORD *)(a1 + 224);
    }
    else
    {
      int v8 = 1;
    }
    uint64_t v4 = (v4 + v8 + 1);
  }
LABEL_18:
  if ((v3 & 4) != 0)
  {
    uint64_t v4 = v4
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16), a2)+ 1;
    unsigned int v3 = *(_DWORD *)(a1 + 224);
    if ((v3 & 8) == 0)
    {
LABEL_20:
      if ((v3 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_32;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_20;
  }
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248AFE8 + 24);
  }
  uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074B160(v9, a2);
  int v11 = (int)v10;
  if (v10 >= 0x80) {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
  }
  else {
    int v12 = 1;
  }
  uint64_t v4 = (v4 + v11 + v12 + 1);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x10) == 0)
  {
LABEL_21:
    if ((v3 & 0x20) == 0) {
      goto LABEL_22;
    }
    goto LABEL_38;
  }
LABEL_32:
  uint64_t v13 = *(void *)(a1 + 32);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248AFE8 + 32);
  }
  uint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100E38668(v13, a2);
  int v15 = (int)v14;
  if (v14 >= 0x80) {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14, a2);
  }
  else {
    int v16 = 1;
  }
  uint64_t v4 = (v4 + v15 + v16 + 1);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x20) == 0)
  {
LABEL_22:
    if ((v3 & 0x40) == 0) {
      goto LABEL_23;
    }
    goto LABEL_44;
  }
LABEL_38:
  uint64_t v17 = *(void *)(a1 + 40);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248AFE8 + 40);
  }
  uint64_t v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074DFF4(v17, a2);
  int v19 = (int)v18;
  if (v18 >= 0x80) {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v18, a2);
  }
  else {
    int v20 = 1;
  }
  uint64_t v4 = (v4 + v19 + v20 + 1);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x40) == 0)
  {
LABEL_23:
    if ((v3 & 0x80) == 0) {
      goto LABEL_56;
    }
    goto LABEL_50;
  }
LABEL_44:
  uint64_t v21 = *(void *)(a1 + 48);
  if (!v21) {
    uint64_t v21 = *(void *)(qword_10248AFE8 + 48);
  }
  uint64_t v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDC1D8(v21, a2);
  int v23 = (int)v22;
  if (v22 >= 0x80) {
    int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, a2);
  }
  else {
    int v24 = 1;
  }
  uint64_t v4 = (v4 + v23 + v24 + 1);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x80) != 0)
  {
LABEL_50:
    uint64_t v25 = *(void *)(a1 + 56);
    if (!v25) {
      uint64_t v25 = *(void *)(qword_10248AFE8 + 56);
    }
    uint64_t v26 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074C5F8(v25, a2);
    int v27 = (int)v26;
    if (v26 >= 0x80) {
      int v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v26, a2);
    }
    else {
      int v28 = 1;
    }
    uint64_t v4 = (v4 + v27 + v28 + 1);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
LABEL_56:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_114;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v29 = *(void *)(a1 + 64);
    if (!v29) {
      uint64_t v29 = *(void *)(qword_10248AFE8 + 64);
    }
    int v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE4684(v29, a2);
    int v31 = (int)v30;
    if (v30 >= 0x80) {
      int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30, a2);
    }
    else {
      int v32 = 1;
    }
    uint64_t v4 = (v4 + v31 + v32 + 2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
    if ((v3 & 0x200) == 0)
    {
LABEL_59:
      if ((v3 & 0x400) == 0) {
        goto LABEL_60;
      }
      goto LABEL_78;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_59;
  }
  uint64_t v33 = *(void *)(a1 + 72);
  if (!v33) {
    uint64_t v33 = *(void *)(qword_10248AFE8 + 72);
  }
  int v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE49F0(v33, a2);
  int v35 = (int)v34;
  if (v34 >= 0x80) {
    int v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34, a2);
  }
  else {
    int v36 = 1;
  }
  uint64_t v4 = (v4 + v35 + v36 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x400) == 0)
  {
LABEL_60:
    if ((v3 & 0x800) == 0) {
      goto LABEL_61;
    }
    goto LABEL_84;
  }
LABEL_78:
  uint64_t v37 = *(void *)(a1 + 80);
  if (!v37) {
    uint64_t v37 = *(void *)(qword_10248AFE8 + 80);
  }
  uint64_t v38 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074EBE8(v37, a2);
  int v39 = (int)v38;
  if (v38 >= 0x80) {
    int v40 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v38, a2);
  }
  else {
    int v40 = 1;
  }
  uint64_t v4 = (v4 + v39 + v40 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x800) == 0)
  {
LABEL_61:
    if ((v3 & 0x1000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_90;
  }
LABEL_84:
  uint64_t v41 = *(void *)(a1 + 88);
  if (!v41) {
    uint64_t v41 = *(void *)(qword_10248AFE8 + 88);
  }
  uint64_t v42 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074E51C(v41, a2);
  int v43 = (int)v42;
  if (v42 >= 0x80) {
    int v44 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v42, a2);
  }
  else {
    int v44 = 1;
  }
  uint64_t v4 = (v4 + v43 + v44 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x1000) == 0)
  {
LABEL_62:
    if ((v3 & 0x2000) == 0) {
      goto LABEL_63;
    }
    goto LABEL_96;
  }
LABEL_90:
  uint64_t v45 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 96);
  if ((v45 & 0x80000000) != 0)
  {
    int v46 = 10;
  }
  else if (v45 >= 0x80)
  {
    int v46 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v45, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v46 = 1;
  }
  uint64_t v4 = (v4 + v46 + 2);
  if ((v3 & 0x2000) == 0)
  {
LABEL_63:
    if ((v3 & 0x4000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_102;
  }
LABEL_96:
  int v47 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 100);
  if ((v47 & 0x80000000) != 0)
  {
    int v48 = 10;
  }
  else if (v47 >= 0x80)
  {
    int v48 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v47, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v48 = 1;
  }
  uint64_t v4 = (v4 + v48 + 2);
  if ((v3 & 0x4000) == 0)
  {
LABEL_64:
    if ((v3 & 0x8000) == 0) {
      goto LABEL_114;
    }
    goto LABEL_108;
  }
LABEL_102:
  uint64_t v49 = *(void *)(a1 + 104);
  if (!v49) {
    uint64_t v49 = *(void *)(qword_10248AFE8 + 104);
  }
  if (*(_DWORD *)(v49 + 16)) {
    int v50 = 2 * (*(_DWORD *)(v49 + 16) & 1);
  }
  else {
    int v50 = 0;
  }
  *(_DWORD *)(v49 + 12) = v50;
  uint64_t v4 = (v4 + v50 + 3);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x8000) != 0)
  {
LABEL_108:
    uint64_t v51 = *(void *)(a1 + 112);
    if (!v51) {
      uint64_t v51 = *(void *)(qword_10248AFE8 + 112);
    }
    uint64_t v52 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE8630(v51, a2);
    int v53 = (int)v52;
    if (v52 >= 0x80) {
      int v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v52, a2);
    }
    else {
      int v54 = 1;
    }
    uint64_t v4 = (v4 + v53 + v54 + 2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
LABEL_114:
  if ((v3 & 0xFF0000) == 0) {
    goto LABEL_175;
  }
  if ((v3 & 0x10000) != 0)
  {
    uint64_t v55 = *(void *)(a1 + 120);
    if (!v55) {
      uint64_t v55 = *(void *)(qword_10248AFE8 + 120);
    }
    int v56 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE8B6C(v55, a2);
    int v57 = (int)v56;
    if (v56 >= 0x80) {
      int v58 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v56, a2);
    }
    else {
      int v58 = 1;
    }
    uint64_t v4 = (v4 + v57 + v58 + 2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
    if ((v3 & 0x20000) == 0)
    {
LABEL_117:
      if ((v3 & 0x40000) == 0) {
        goto LABEL_118;
      }
      goto LABEL_136;
    }
  }
  else if ((v3 & 0x20000) == 0)
  {
    goto LABEL_117;
  }
  uint64_t v59 = *(void *)(a1 + 128);
  if (!v59) {
    uint64_t v59 = *(void *)(qword_10248AFE8 + 128);
  }
  int v60 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008C8E68(v59, a2);
  int v61 = (int)v60;
  if (v60 >= 0x80) {
    int v62 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v60, a2);
  }
  else {
    int v62 = 1;
  }
  uint64_t v4 = (v4 + v61 + v62 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x40000) == 0)
  {
LABEL_118:
    if ((v3 & 0x80000) == 0) {
      goto LABEL_119;
    }
    goto LABEL_145;
  }
LABEL_136:
  uint64_t v63 = *(void *)(a1 + 136);
  int v64 = *(unsigned __int8 *)(v63 + 23);
  char v65 = v64;
  uint64_t v66 = *(void *)(v63 + 8);
  if ((v64 & 0x80u) == 0) {
    unint64_t v67 = *(unsigned __int8 *)(v63 + 23);
  }
  else {
    unint64_t v67 = v66;
  }
  if (v67 >= 0x80)
  {
    int v68 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v67, a2);
    int v64 = *(unsigned __int8 *)(v63 + 23);
    uint64_t v66 = *(void *)(v63 + 8);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
    char v65 = *(unsigned char *)(v63 + 23);
  }
  else
  {
    int v68 = 1;
  }
  if (v65 < 0) {
    int v64 = v66;
  }
  uint64_t v4 = (v4 + v68 + v64 + 2);
  if ((v3 & 0x80000) == 0)
  {
LABEL_119:
    if ((v3 & 0x100000) == 0) {
      goto LABEL_120;
    }
    goto LABEL_151;
  }
LABEL_145:
  uint64_t v69 = *(void *)(a1 + 144);
  if (!v69) {
    uint64_t v69 = *(void *)(qword_10248AFE8 + 144);
  }
  int v70 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008E65AC(v69, a2);
  int v71 = (int)v70;
  if (v70 >= 0x80) {
    int v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v70, a2);
  }
  else {
    int v72 = 1;
  }
  uint64_t v4 = (v4 + v71 + v72 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x100000) == 0)
  {
LABEL_120:
    if ((v3 & 0x200000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_157;
  }
LABEL_151:
  uint64_t v73 = *(void *)(a1 + 152);
  if (!v73) {
    uint64_t v73 = *(void *)(qword_10248AFE8 + 152);
  }
  int v74 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008EBC10(v73, a2);
  int v75 = (int)v74;
  if (v74 >= 0x80) {
    int v76 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v74, a2);
  }
  else {
    int v76 = 1;
  }
  uint64_t v4 = (v4 + v75 + v76 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x200000) == 0)
  {
LABEL_121:
    if ((v3 & 0x400000) == 0) {
      goto LABEL_122;
    }
    goto LABEL_163;
  }
LABEL_157:
  uint64_t v77 = *(void *)(a1 + 160);
  if (!v77) {
    uint64_t v77 = *(void *)(qword_10248AFE8 + 160);
  }
  int v78 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008F1A50(v77, a2);
  int v79 = (int)v78;
  if (v78 >= 0x80) {
    int v80 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v78, a2);
  }
  else {
    int v80 = 1;
  }
  uint64_t v4 = (v4 + v79 + v80 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x400000) == 0)
  {
LABEL_122:
    if ((v3 & 0x800000) == 0) {
      goto LABEL_175;
    }
    goto LABEL_169;
  }
LABEL_163:
  uint64_t v81 = *(void *)(a1 + 168);
  if (!v81) {
    uint64_t v81 = *(void *)(qword_10248AFE8 + 168);
  }
  int v82 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008FDE20(v81, a2);
  int v83 = (int)v82;
  if (v82 >= 0x80) {
    int v84 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v82, a2);
  }
  else {
    int v84 = 1;
  }
  uint64_t v4 = (v4 + v83 + v84 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x800000) != 0)
  {
LABEL_169:
    uint64_t v85 = *(void *)(a1 + 176);
    if (!v85) {
      uint64_t v85 = *(void *)(qword_10248AFE8 + 176);
    }
    int v86 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1009021C0(v85, a2);
    int v87 = (int)v86;
    if (v86 >= 0x80) {
      int v88 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v86, a2);
    }
    else {
      int v88 = 1;
    }
    uint64_t v4 = (v4 + v87 + v88 + 2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
LABEL_175:
  if (!HIBYTE(v3)) {
    goto LABEL_215;
  }
  if ((v3 & 0x1000000) != 0)
  {
    uint64_t v89 = *(void *)(a1 + 184);
    if (!v89) {
      uint64_t v89 = *(void *)(qword_10248AFE8 + 184);
    }
    int v90 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008D29F0(v89, a2);
    int v91 = (int)v90;
    if (v90 >= 0x80) {
      int v92 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v90, a2);
    }
    else {
      int v92 = 1;
    }
    uint64_t v4 = (v4 + v91 + v92 + 2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
    if ((v3 & 0x2000000) == 0)
    {
LABEL_178:
      if ((v3 & 0x4000000) == 0) {
        goto LABEL_179;
      }
      goto LABEL_195;
    }
  }
  else if ((v3 & 0x2000000) == 0)
  {
    goto LABEL_178;
  }
  uint64_t v93 = *(void *)(a1 + 192);
  if (!v93) {
    uint64_t v93 = *(void *)(qword_10248AFE8 + 192);
  }
  unsigned int v94 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008D060C(v93, a2);
  int v95 = (int)v94;
  if (v94 >= 0x80) {
    int v96 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v94, a2);
  }
  else {
    int v96 = 1;
  }
  uint64_t v4 = (v4 + v95 + v96 + 2);
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x4000000) == 0)
  {
LABEL_179:
    if ((v3 & 0x8000000) == 0) {
      goto LABEL_180;
    }
    goto LABEL_199;
  }
LABEL_195:
  int v97 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 200);
  if (v97 >= 0x80)
  {
    int v98 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v97, a2) + 2;
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v98 = 3;
  }
  uint64_t v4 = (v98 + v4);
  if ((v3 & 0x8000000) == 0)
  {
LABEL_180:
    if ((v3 & 0x10000000) == 0) {
      goto LABEL_181;
    }
LABEL_205:
    int v101 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 216);
    if (v101 >= 0x80)
    {
      int v102 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v101, a2) + 2;
      unsigned int v3 = *(_DWORD *)(a1 + 224);
    }
    else
    {
      int v102 = 3;
    }
    uint64_t v4 = (v102 + v4);
    if ((v3 & 0x20000000) == 0) {
      goto LABEL_215;
    }
    goto LABEL_209;
  }
LABEL_199:
  uint64_t v99 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 204);
  if ((v99 & 0x80000000) != 0)
  {
    int v100 = 12;
  }
  else if (v99 >= 0x80)
  {
    int v100 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v99, a2) + 2;
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v100 = 3;
  }
  uint64_t v4 = (v100 + v4);
  if ((v3 & 0x10000000) != 0) {
    goto LABEL_205;
  }
LABEL_181:
  if ((v3 & 0x20000000) == 0) {
    goto LABEL_215;
  }
LABEL_209:
  uint64_t v103 = *(void *)(a1 + 208);
  if (!v103) {
    uint64_t v103 = *(void *)(qword_10248AFE8 + 208);
  }
  int v104 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1008CCAFC(v103, a2);
  int v106 = (int)v104;
  if (v104 >= 0x80) {
    int v107 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v104, v105);
  }
  else {
    int v107 = 1;
  }
  uint64_t v4 = (v4 + v106 + v107 + 2);
LABEL_215:
  *(_DWORD *)(a1 + 22sub_100FB8FC8(&a9, 0) = v4;
  return v4;
}

void sub_100FDB5C4(uint64_t a1, void *lpsrc)
{
  sub_100FD7544(a1, (uint64_t)lpsrc);
}

void sub_100FDB64C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 32);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 32))
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v4 = *(_DWORD *)(a2 + 32);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_13;
      }
    }
    else if ((*(unsigned char *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v7 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(void *)(a1 + 16) = v7;
    int v4 = *(_DWORD *)(a2 + 32);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_14;
    }
LABEL_13:
    char v8 = *(unsigned char *)(a2 + 24);
    *(_DWORD *)(a1 + 32) |= 4u;
    *(unsigned char *)(a1 + 24) = v8;
    int v4 = *(_DWORD *)(a2 + 32);
    if ((v4 & 8) == 0)
    {
LABEL_8:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_9;
    }
LABEL_14:
    char v9 = *(unsigned char *)(a2 + 25);
    *(_DWORD *)(a1 + 32) |= 8u;
    *(unsigned char *)(a1 + 25) = v9;
    if ((*(_DWORD *)(a2 + 32) & 0x10) == 0) {
      return;
    }
LABEL_9:
    char v5 = *(unsigned char *)(a2 + 26);
    *(_DWORD *)(a1 + 32) |= 0x10u;
    *(unsigned char *)(a1 + 26) = v5;
  }
}

void sub_100FDB760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FDB778(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), *(_DWORD *)(a2 + 16) + *(_DWORD *)(a1 + 16));
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = *(_DWORD *)(a1 + 20);
      uint64_t v7 = *(int *)(a1 + 16);
      if ((int)v7 >= v6)
      {
        if (v6 == *(_DWORD *)(a1 + 24))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8), v6 + 1);
          int v6 = *(_DWORD *)(a1 + 20);
        }
        *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)(a1 + 8);
      *(_DWORD *)(a1 + 16) = v7 + 1;
      sub_100FE39C0(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
  if ((*(unsigned char *)(a2 + 44) & 2) != 0)
  {
    *(_DWORD *)(a1 + 44) |= 2u;
    uint64_t v9 = *(void *)(a1 + 32);
    if (!v9) {
      operator new();
    }
    uint64_t v10 = *(void *)(a2 + 32);
    if (!v10) {
      uint64_t v10 = *(void *)(qword_10248B0C0 + 32);
    }
    sub_100FE3324(v9, v10);
  }
}

void sub_100FDB958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FDB970(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4 >= 5) {
      sub_101A9C268();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v4;
  }
}

void sub_100FDBA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FDBA20(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v5);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    char v4 = *(unsigned char *)(a2 + 8);
    *(_DWORD *)(a1 + 16) |= 1u;
    *(unsigned char *)(a1 + 8) = v4;
  }
}

void sub_100FDBAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FDBAC4(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[6] |= 1u;
      a1[2] = v6;
      int v4 = *(_DWORD *)(a2 + 24);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_7;
      }
    }
    else if ((*(unsigned char *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 12);
    a1[6] |= 2u;
    a1[3] = v7;
    if ((*(_DWORD *)(a2 + 24) & 4) == 0) {
      return;
    }
LABEL_7:
    int v5 = *(_DWORD *)(a2 + 16);
    a1[6] |= 4u;
    a1[4] = v5;
  }
}

void sub_100FDBB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FDBBB0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 36);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 36))
    {
      uint64_t v5 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 36);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_10;
      }
    }
    else if ((*(unsigned char *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v6 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(void *)(a1 + 16) = v6;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return;
    }
LABEL_10:
    int v7 = *(const std::string **)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    uint64_t v8 = *(std::string **)(a1 + 24);
    if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v8, v7);
  }
}

void sub_100FDBCC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FDBCD8()
{
  return 1;
}

void *sub_100FDBCE0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.Indication");
}

void sub_100FDBCF0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308CB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDBD10(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308CB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDBD64()
{
}

uint64_t sub_100FDBDB8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  uint64_t v6 = (unint64_t *)(a1 + 16);
  while (2)
  {
    int v7 = (char *)*((void *)this + 1);
    if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v7;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v7 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v11 < v10 && (*v11 & 0x80000000) == 0)
        {
          unint64_t *v5 = *v11;
          int v12 = v11 + 1;
          *((void *)this + 1) = v12;
LABEL_26:
          *(_DWORD *)(a1 + 32) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 16)
          {
            uint64_t v13 = v12 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_29;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (result)
        {
          int v12 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          goto LABEL_26;
        }
        break;
      case 2u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_29:
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
          if (!result) {
            return result;
          }
          uint64_t v17 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v6 = *v13;
          uint64_t v17 = v13 + 1;
          *((void *)this + 1) = v17;
        }
        *(_DWORD *)(a1 + 32) |= 2u;
        if ((unint64_t)v17 >= v10 || *v17 != 24) {
          continue;
        }
        uint64_t v14 = v17 + 1;
        *((void *)this + 1) = v14;
LABEL_37:
        unsigned int v27 = 0;
        if ((unint64_t)v14 >= v10 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v27);
          if (!result) {
            return result;
          }
          unsigned int v18 = v27;
          int v19 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v18 = *v14;
          int v19 = v14 + 1;
          *((void *)this + 1) = v19;
        }
        *(unsigned char *)(a1 + 24) = v18 != 0;
        *(_DWORD *)(a1 + 32) |= 4u;
        if ((unint64_t)v19 >= v10 || *v19 != 32) {
          continue;
        }
        int v15 = v19 + 1;
        *((void *)this + 1) = v15;
LABEL_45:
        unsigned int v26 = 0;
        if ((unint64_t)v15 >= v10 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v26);
          if (!result) {
            return result;
          }
          unsigned int v20 = v26;
          uint64_t v21 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v20 = *v15;
          uint64_t v21 = v15 + 1;
          *((void *)this + 1) = v21;
        }
        *(unsigned char *)(a1 + 25) = v20 != 0;
        *(_DWORD *)(a1 + 32) |= 8u;
        if ((unint64_t)v21 >= v10 || *v21 != 40) {
          continue;
        }
        int v16 = v21 + 1;
        *((void *)this + 1) = v16;
LABEL_53:
        unsigned int v25 = 0;
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25);
          if (!result) {
            return result;
          }
          unsigned int v22 = v25;
          int v23 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v22 = *v16;
          int v23 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v23;
        }
        *(unsigned char *)(a1 + 26) = v22 != 0;
        *(_DWORD *)(a1 + 32) |= 0x10u;
        if (v23 != (unsigned __int8 *)v10 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_37;
      case 4u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_45;
      case 5u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_53;
      default:
        int v9 = TagFallback & 7;
LABEL_20:
        if (v9 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FDC114(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 16), a2, a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 25), a2, a4);
    if ((*(_DWORD *)(v5 + 32) & 0x10) == 0) {
      return result;
    }
    goto LABEL_11;
  }
LABEL_9:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 24), a2, a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return result;
  }
LABEL_11:
  int v7 = *(unsigned __int8 *)(v5 + 26);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v7, a2, a4);
}

uint64_t sub_100FDC1D8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0;
    goto LABEL_15;
  }
  if ((*(unsigned char *)(a1 + 32) & 1) == 0)
  {
    unsigned int v4 = 0;
    if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
  int v3 = *(_DWORD *)(a1 + 32);
  if ((v3 & 2) != 0)
  {
LABEL_7:
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
LABEL_8:
  unsigned int v6 = v4 + 2;
  if ((v3 & 4) == 0) {
    unsigned int v6 = v4;
  }
  if ((v3 & 8) != 0) {
    v6 += 2;
  }
  if ((v3 & 0x10) != 0) {
    uint64_t result = v6 + 2;
  }
  else {
    uint64_t result = v6;
  }
LABEL_15:
  *(_DWORD *)(a1 + 28) = result;
  return result;
}

void sub_100FDC268(uint64_t a1, void *lpsrc)
{
  sub_100FDB64C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDC2F0()
{
  return 1;
}

void *sub_100FDC2F8@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.Status");
}

void sub_100FDC308(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308D30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDC328(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308D30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDC37C()
{
}

uint64_t sub_100FDC3D8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        unsigned int v28 = 0;
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 < v8 && (*v9 & 0x80000000) == 0)
        {
          unsigned int v10 = *v9;
          int v11 = v9 + 1;
          *((void *)this + 1) = v11;
LABEL_27:
          *(unsigned char *)(a1 + 8) = v10 != 0;
          *(_DWORD *)(a1 + 20) |= 1u;
          if ((unint64_t)v11 < v8 && *v11 == 16)
          {
            int v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_30;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
        if (result)
        {
          unsigned int v10 = v28;
          int v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_27;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_30:
        unsigned int v28 = 0;
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!result) {
            return result;
          }
          unsigned int v17 = v28;
          unsigned int v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v17 = *v12;
          unsigned int v18 = v12 + 1;
          *((void *)this + 1) = v18;
        }
        *(unsigned char *)(a1 + 9) = v17 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        if ((unint64_t)v18 >= v8 || *v18 != 24) {
          continue;
        }
        uint64_t v13 = v18 + 1;
        *((void *)this + 1) = v13;
LABEL_38:
        unsigned int v28 = 0;
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!result) {
            return result;
          }
          unsigned int v19 = v28;
          unsigned int v20 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v19 = *v13;
          unsigned int v20 = v13 + 1;
          *((void *)this + 1) = v20;
        }
        *(unsigned char *)(a1 + 1sub_100FB8FC8(&a9, 0) = v19 != 0;
        *(_DWORD *)(a1 + 20) |= 4u;
        if ((unint64_t)v20 >= v8 || *v20 != 32) {
          continue;
        }
        uint64_t v14 = v20 + 1;
        *((void *)this + 1) = v14;
LABEL_46:
        unsigned int v28 = 0;
        if ((unint64_t)v14 >= v8 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!result) {
            return result;
          }
          unsigned int v21 = v28;
          unsigned int v22 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v21 = *v14;
          unsigned int v22 = v14 + 1;
          *((void *)this + 1) = v22;
        }
        *(unsigned char *)(a1 + 11) = v21 != 0;
        *(_DWORD *)(a1 + 20) |= 8u;
        if ((unint64_t)v22 >= v8 || *v22 != 40) {
          continue;
        }
        int v15 = v22 + 1;
        *((void *)this + 1) = v15;
LABEL_54:
        unsigned int v28 = 0;
        if ((unint64_t)v15 >= v8 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!result) {
            return result;
          }
          unsigned int v23 = v28;
          int v24 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v23 = *v15;
          int v24 = v15 + 1;
          *((void *)this + 1) = v24;
        }
        *(unsigned char *)(a1 + 12) = v23 != 0;
        *(_DWORD *)(a1 + 20) |= 0x10u;
        if ((unint64_t)v24 >= v8 || *v24 != 48) {
          continue;
        }
        int v16 = v24 + 1;
        *((void *)this + 1) = v16;
LABEL_62:
        unsigned int v28 = 0;
        if ((unint64_t)v16 >= v8 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!result) {
            return result;
          }
          unsigned int v25 = v28;
          unsigned int v26 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v25 = *v16;
          unsigned int v26 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v26;
        }
        *(unsigned char *)(a1 + 13) = v25 != 0;
        *(_DWORD *)(a1 + 20) |= 0x20u;
        if (v26 != (unsigned __int8 *)v8 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_38;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_46;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_54;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v16 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_62;
      default:
        int v7 = TagFallback & 7;
LABEL_21:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FDC7C8(uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 9), a2, a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 10), a2, a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned __int8 *)(v5 + 12), a2, a4);
    if ((*(_DWORD *)(v5 + 20) & 0x20) == 0) {
      return result;
    }
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 11), a2, a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 0x10) != 0) {
    goto LABEL_12;
  }
LABEL_6:
  if ((v6 & 0x20) == 0) {
    return result;
  }
LABEL_13:
  int v7 = *(unsigned __int8 *)(v5 + 13);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v7, a2, a4);
}

uint64_t sub_100FDC8A8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((_BYTE)v1)
  {
    unsigned int v2 = 2 * (v1 & 1);
    if ((v1 & 2) != 0) {
      v2 += 2;
    }
    if ((v1 & 4) != 0) {
      v2 += 2;
    }
    if ((v1 & 8) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x10) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x20) != 0) {
      uint64_t v3 = v2 + 2;
    }
    else {
      uint64_t v3 = v2;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  *(_DWORD *)(a1 + 16) = v3;
  return v3;
}

void sub_100FDC908(uint64_t a1, unsigned char *lpsrc)
{
  sub_100FD6294(a1, lpsrc);
}

uint64_t sub_100FDC990()
{
  return 1;
}

void *sub_100FDC998@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetPvtmReport");
}

void sub_100FDC9A8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308DA8;
  sub_1001A4D20((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDC9FC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308DA8;
  sub_1001A4D20((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDCA64()
{
}

uint64_t sub_100FDCABC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if (v7 != 2) {
        goto LABEL_21;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      int v11 = (unsigned char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v11 < v8 && *v11 == 16)
      {
        int v9 = v11 + 1;
        *((void *)this + 1) = v9;
LABEL_17:
        unsigned int v13 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v13);
          if (!result) {
            return result;
          }
          unsigned int v12 = v13;
        }
        else
        {
          unsigned int v12 = *v9;
          *((void *)this + 1) = v9 + 1;
        }
        if (v12 <= 2)
        {
          *(_DWORD *)(a1 + 24) |= 2u;
          *(_DWORD *)(a1 + 16) = v12;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_17;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_21:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDCC80(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 16);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FDCCEC(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 24);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_21;
  }
  if ((*(unsigned char *)(a1 + 24) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v10 = v11 + 1;
    int v3 = *(_DWORD *)(a1 + 24);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 2;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    unsigned int v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v12 & 0x80000000) != 0)
    {
      int v13 = 11;
    }
    else if (v12 >= 0x80)
    {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 1;
    }
    else
    {
      int v13 = 2;
    }
    uint64_t v4 = (v13 + v4);
  }
LABEL_21:
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v4;
  return v4;
}

void sub_100FDCDB4(uint64_t a1, void *lpsrc)
{
  sub_100FD5EBC(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDCE3C()
{
  return 1;
}

void *sub_100FDCE44@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.InjectAssistanceFile");
}

void sub_100FDCE54(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308E20;
  sub_1001A4D20((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDCEA8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308E20;
  sub_1001A4D20((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDCF10()
{
}

uint64_t sub_100FDCF64(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FDD084(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return result;
}

uint64_t sub_100FDD0A0(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8, a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(unsigned char *)(v4 + 23);
    }
    else
    {
      int v9 = 2;
    }
    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100FDD120(uint64_t a1, void *lpsrc)
{
  sub_100FD5FD0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDD1A8()
{
  return 1;
}

void *sub_100FDD1B0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.InjectRtiFile");
}

void sub_100FDD1C0(uint64_t *a1)
{
  *a1 = (uint64_t)off_102308E98;
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_100FDD21C(uint64_t *a1)
{
  sub_100FDD1C0(a1);

  operator delete();
}

void sub_100FDD254()
{
}

uint64_t sub_100FDD2A8(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    char v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }
          a1[5] = v8 + 1;
          sub_100FEA17C();
        }
        uint64_t v10 = *((void *)a1 + 1);
        a1[4] = v9 + 1;
        int v11 = *(unsigned int **)(v10 + 8 * v9);
        unsigned int v23 = 0;
        unsigned int v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23))return 0; {
        }
          }
        else
        {
          unsigned int v23 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        int v13 = *((_DWORD *)this + 14);
        int v14 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v13 + 1;
        if (v13 >= v14) {
          return 0;
        }
        int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v23);
        if (!sub_10074D430(v11, this, v16) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v15);
        int v17 = *((_DWORD *)this + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)this + 14) = v19;
        }
        unsigned int v20 = (unsigned char *)*((void *)this + 1);
        unsigned int v21 = (unsigned char *)*((void *)this + 2);
        if (v20 >= v21 || *v20 != 10)
        {
          if (v20 == v21 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)this + 1) = v20 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDD49C(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_100FDD4FC(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074D848(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100FDD57C(_DWORD *a1, void *lpsrc)
{
  sub_100FD60B0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDD604()
{
  return 1;
}

void *sub_100FDD60C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.InjectSvidBlocklist");
}

void sub_100FDD61C(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102308F10;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_10248B018 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FDD6AC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100FDD61C(a1);

  operator delete();
}

void sub_100FDD6E4()
{
}

uint64_t sub_100FDD738(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 24);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        uint64_t v9 = *(void *)(a1 + 8);
        if (!v9) {
          operator new();
        }
        unsigned int v32 = 0;
        uint64_t v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32))return 0; {
        }
          }
        else
        {
          unsigned int v32 = *v10;
          *((void *)this + 1) = v10 + 1;
        }
        int v16 = *((_DWORD *)this + 14);
        int v17 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v16 + 1;
        if (v16 >= v17) {
          return 0;
        }
        int v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v32);
        if (!sub_100748AD8(v9, this, v19) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v18);
        int v20 = *((_DWORD *)this + 14);
        BOOL v21 = __OFSUB__(v20, 1);
        int v22 = v20 - 1;
        if (v22 < 0 == v21) {
          *((_DWORD *)this + 14) = v22;
        }
        unsigned int v23 = (unsigned char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        if ((unint64_t)v23 >= v13 || *v23 != 16) {
          continue;
        }
        int v14 = v23 + 1;
        *((void *)this + 1) = v14;
        goto LABEL_33;
      case 2u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
LABEL_33:
        unsigned int v30 = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v30);
          if (!result) {
            return result;
          }
          unsigned int v24 = v30;
        }
        else
        {
          unsigned int v24 = *v14;
          *((void *)this + 1) = v14 + 1;
        }
        if (sub_100165F14(v24))
        {
          if (!sub_100165F14(v24)) {
            sub_101A9BFA8();
          }
          *(_DWORD *)(a1 + 36) |= 2u;
          *(_DWORD *)(a1 + 16) = v24;
        }
        unsigned int v26 = (unsigned char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v26 >= v11 || *v26 != 24) {
          continue;
        }
        unsigned int v12 = v26 + 1;
        *((void *)this + 1) = v12;
LABEL_44:
        unsigned int v31 = 0;
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v31);
          if (!result) {
            return result;
          }
          unsigned int v27 = v31;
          unsigned int v28 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v27 = *v12;
          unsigned int v28 = v12 + 1;
          *((void *)this + 1) = v28;
        }
        *(unsigned char *)(a1 + 2sub_100FB8FC8(&a9, 0) = v27 != 0;
        *(_DWORD *)(a1 + 36) |= 4u;
        if ((unint64_t)v28 >= v11 || *v28 != 80) {
          continue;
        }
        int v15 = v28 + 1;
        *((void *)this + 1) = v15;
LABEL_52:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v29 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v15;
          uint64_t v29 = (unsigned __int8 *)(v15 + 1);
          *((void *)this + 1) = v29;
        }
        *(_DWORD *)(a1 + 36) |= 8u;
        if (v29 != (unsigned __int8 *)v11 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        break;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        unsigned int v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_44;
      case 0xAu:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_52;
      default:
        int v8 = TagFallback & 7;
LABEL_20:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

void sub_100FDDAA4()
{
}

uint64_t sub_100FDDAF0(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if (v6)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_10248B018 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, v7, a2, a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_10:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 20), (BOOL)a2, a4);
      if ((*(_DWORD *)(v5 + 36) & 8) == 0) {
        return result;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 16), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 4) != 0) {
    goto LABEL_10;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_11:
  uint64_t v8 = *(void *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v8, (unint64_t)a2, a4);
}

uint64_t sub_100FDDBA8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 36))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (!v5) {
      uint64_t v5 = *(void *)(qword_10248B018 + 8);
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100749224(v5, a2);
    int v7 = (int)v6;
    if (v6 >= 0x80) {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
    }
    else {
      int v8 = 1;
    }
    LODWORD(v4) = v7 + v8 + 1;
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  LODWORD(v4) = 0;
  if ((*(unsigned char *)(a1 + 36) & 2) != 0)
  {
LABEL_12:
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 11;
    }
    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }
    else
    {
      int v10 = 2;
    }
    LODWORD(v4) = v10 + v4;
  }
LABEL_18:
  if ((v3 & 4) != 0) {
    uint64_t v4 = (v4 + 2);
  }
  else {
    uint64_t v4 = v4;
  }
  if ((v3 & 8) != 0) {
    uint64_t v4 = v4
  }
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 24), a2)+ 1;
LABEL_23:
  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

void sub_100FDDC84(uint64_t a1, void *lpsrc)
{
  sub_100FD50C4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDDD0C()
{
  return 1;
}

void *sub_100FDDD14@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.InjectAssistancePosition");
}

void sub_100FDDD24(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308F88;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDDD44(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102308F88;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDDD98()
{
}

uint64_t sub_100FDDDEC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  int v6 = (unint64_t *)(a1 + 16);
  int v7 = (unint64_t *)(a1 + 24);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v8;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v10 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          int v15 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v14;
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        if ((unint64_t)v15 < v12 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *((void *)this + 1) = v16;
          goto LABEL_27;
        }
      }
      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_19;
      }
      int v16 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_27:
      if ((unint64_t)v16 >= v12 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
        if (!result) {
          return result;
        }
        int v17 = (unsigned char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }
      else
      {
        *int v6 = *v16;
        int v17 = v16 + 1;
        *((void *)this + 1) = v17;
      }
      *(_DWORD *)(a1 + 36) |= 2u;
      if ((unint64_t)v17 < v12 && *v17 == 24)
      {
        unint64_t v13 = v17 + 1;
        *((void *)this + 1) = v13;
LABEL_35:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v18 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v7 = *v13;
          int v18 = (unsigned __int8 *)(v13 + 1);
          *((void *)this + 1) = v18;
        }
        *(_DWORD *)(a1 + 36) |= 4u;
        if (v18 == (unsigned __int8 *)v12
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_35;
      }
    }
    else
    {
      int v11 = TagFallback & 7;
    }
LABEL_19:
    if (v11 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDE010(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 16), a2, a4);
    if ((*(_DWORD *)(v5 + 36) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  uint64_t v7 = *(void *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
}

uint64_t sub_100FDE09C(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_10;
  }
  if (*(unsigned char *)(a1 + 36))
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v4 = 0;
  if ((*(unsigned char *)(a1 + 36) & 2) != 0)
  {
LABEL_7:
    uint64_t v4 = v4
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 36);
  }
LABEL_8:
  if ((v3 & 4) != 0) {
    uint64_t v4 = v4
  }
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 24), a2)+ 1;
LABEL_10:
  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

void sub_100FDE120(uint64_t a1, void *lpsrc)
{
  sub_100FD5238(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDE1A8()
{
  return 1;
}

void *sub_100FDE1B0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.InjectAssistanceTime");
}

void sub_100FDE1C0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309000;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDE1E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309000;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDE234()
{
}

uint64_t sub_100FDE280(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v6 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      uint64_t v9 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!result) {
          return result;
        }
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }
      else
      {
        unint64_t *v5 = *v9;
        unsigned int v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)this + 1) = v10;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FDE394(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FDE3B0(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 20)) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
  }
  else {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100FDE3F0(uint64_t a1, void *lpsrc)
{
  sub_100FD61F0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDE478()
{
  return 1;
}

void *sub_100FDE480@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.DeleteGnssData");
}

void sub_100FDE490(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309078;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDE4B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309078;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDE504()
{
}

uint64_t sub_100FDE550(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v6 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      uint64_t v9 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!result) {
          return result;
        }
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }
      else
      {
        unint64_t *v5 = *v9;
        unsigned int v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)this + 1) = v10;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FDE664(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FDE680(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 20)) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
  }
  else {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100FDE6C0(uint64_t a1, void *lpsrc)
{
  sub_100FD63E0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDE748()
{
  return 1;
}

void *sub_100FDE750@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetNmeaHandler");
}

void sub_100FDE760(uint64_t *a1)
{
  *a1 = (uint64_t)off_1023090F0;
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_100FDE7BC(uint64_t *a1)
{
  sub_100FDE760(a1);

  operator delete();
}

void sub_100FDE7F4()
{
}

uint64_t sub_100FDE848(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }
          a1[5] = v8 + 1;
          sub_100FEA1E0();
        }
        uint64_t v10 = *((void *)a1 + 1);
        a1[4] = v9 + 1;
        uint64_t v11 = *(void *)(v10 + 8 * v9);
        unsigned int v23 = 0;
        unint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23))return 0; {
        }
          }
        else
        {
          unsigned int v23 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        int v13 = *((_DWORD *)this + 14);
        int v14 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v13 + 1;
        if (v13 >= v14) {
          return 0;
        }
        int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v23);
        if (!sub_10074C928(v11, this, v16) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v15);
        int v17 = *((_DWORD *)this + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)this + 14) = v19;
        }
        int v20 = (unsigned char *)*((void *)this + 1);
        BOOL v21 = (unsigned char *)*((void *)this + 2);
        if (v20 >= v21 || *v20 != 10)
        {
          if (v20 == v21 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)this + 1) = v20 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDEA3C(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_100FDEA9C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074CB20(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100FDEB1C(_DWORD *a1, void *lpsrc)
{
  sub_100FD5324(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDEBA4()
{
  return 1;
}

void *sub_100FDEBAC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistancePressure");
}

void sub_100FDEBBC(uint64_t *a1)
{
  *a1 = (uint64_t)off_102309168;
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_100FDEC18(uint64_t *a1)
{
  sub_100FDEBBC(a1);

  operator delete();
}

void sub_100FDEC50()
{
}

uint64_t sub_100FDECA4(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }
          a1[5] = v8 + 1;
          sub_100FEA244();
        }
        uint64_t v10 = *((void *)a1 + 1);
        a1[4] = v9 + 1;
        uint64_t v11 = *(_DWORD **)(v10 + 8 * v9);
        unsigned int v23 = 0;
        unint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23))return 0; {
        }
          }
        else
        {
          unsigned int v23 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        int v13 = *((_DWORD *)this + 14);
        int v14 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v13 + 1;
        if (v13 >= v14) {
          return 0;
        }
        int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v23);
        if (!sub_10074CE04(v11, this, v16) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v15);
        int v17 = *((_DWORD *)this + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)this + 14) = v19;
        }
        int v20 = (unsigned char *)*((void *)this + 1);
        BOOL v21 = (unsigned char *)*((void *)this + 2);
        if (v20 >= v21 || *v20 != 10)
        {
          if (v20 == v21 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)this + 1) = v20 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDEE98(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_100FDEEF8(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074D114(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100FDEF78(_DWORD *a1, void *lpsrc)
{
  sub_100FD5464(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDF000()
{
  return 1;
}

void *sub_100FDF008@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceAccel");
}

void sub_100FDF018(uint64_t *a1)
{
  *a1 = (uint64_t)off_1023091E0;
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_100FDF074(uint64_t *a1)
{
  sub_100FDF018(a1);

  operator delete();
}

void sub_100FDF0AC()
{
}

uint64_t sub_100FDF100(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }
          a1[5] = v8 + 1;
          sub_100FEA244();
        }
        uint64_t v10 = *((void *)a1 + 1);
        a1[4] = v9 + 1;
        uint64_t v11 = *(_DWORD **)(v10 + 8 * v9);
        unsigned int v23 = 0;
        unint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23))return 0; {
        }
          }
        else
        {
          unsigned int v23 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        int v13 = *((_DWORD *)this + 14);
        int v14 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v13 + 1;
        if (v13 >= v14) {
          return 0;
        }
        int v15 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v23);
        if (!sub_10074CE04(v11, this, v16) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v15);
        int v17 = *((_DWORD *)this + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)this + 14) = v19;
        }
        int v20 = (unsigned char *)*((void *)this + 1);
        BOOL v21 = (unsigned char *)*((void *)this + 2);
        if (v20 >= v21 || *v20 != 10)
        {
          if (v20 == v21 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)this + 1) = v20 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FDF2F4(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_100FDF354(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10074D114(*(void *)(*(void *)(a1 + 8) + 8 * v4), a2);
      int v6 = (int)v5;
      if (v5 >= 0x80) {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
      }
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }
    while (v4 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100FDF3D4(_DWORD *a1, void *lpsrc)
{
  sub_100FD55A4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDF45C()
{
  return 1;
}

void *sub_100FDF464@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceGyro");
}

void sub_100FDF474(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309258;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDF494(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309258;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDF4E8()
{
}

uint64_t sub_100FDF53C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v6 = (char *)*((void *)this + 1);
          if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
          {
            unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = TagFallback;
            if (!TagFallback) {
              return 1;
            }
          }
          else
          {
            unint64_t TagFallback = *v6;
            *((_DWORD *)this + 8) = TagFallback;
            *((void *)this + 1) = v6 + 1;
            if (!TagFallback) {
              return 1;
            }
          }
          unsigned int v8 = TagFallback >> 3;
          if (TagFallback >> 3 != 1) {
            break;
          }
          int v9 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_19;
          }
          uint64_t v11 = (char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 >= v10 || *v11 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
            if (!result) {
              return result;
            }
            unint64_t v12 = (unsigned char *)*((void *)this + 1);
            unint64_t v10 = *((void *)this + 2);
          }
          else
          {
            unint64_t *v5 = *v11;
            unint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
          }
          *(_DWORD *)(a1 + 36) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 17)
          {
            *((void *)this + 1) = v12 + 1;
            goto LABEL_27;
          }
        }
        if (v8 != 2) {
          break;
        }
        int v9 = TagFallback & 7;
        if (v9 != 1) {
          goto LABEL_19;
        }
LABEL_27:
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) |= 2u;
        int v14 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v14 < *((void *)this + 2) && *v14 == 25)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_31;
        }
      }
      if (v8 != 3) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 1) {
        goto LABEL_19;
      }
LABEL_31:
      unint64_t v15 = 0;
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
        return 0;
      }
      *(void *)(a1 + 24) = v15;
      *(_DWORD *)(a1 + 36) |= 4u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v9 = TagFallback & 7;
LABEL_19:
    if (v9 == 4) {
      return 1;
    }
  }
  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) != 0);
  return 0;
}

uint64_t sub_100FDF728(uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v4, *(double *)(v5 + 16), a3);
    if ((*(_DWORD *)(v5 + 36) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  double v7 = *(double *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v4, v7, a3);
}

uint64_t sub_100FDF7B4(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 36))
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

double sub_100FDF81C(uint64_t a1, void *lpsrc)
{
  return sub_100FD56E4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FDF8A4()
{
  return 1;
}

void *sub_100FDF8AC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceDem");
}

void sub_100FDF8BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023092D0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FDF8DC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023092D0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FDF930()
{
}

uint64_t sub_100FDF990(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        unint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }
        *(_DWORD *)(a1 + 76) |= 1u;
        if ((unint64_t)v11 < v9 && *v11 == 17)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_45;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_36;
        }
LABEL_45:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 16) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 76) |= 2u;
        BOOL v21 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v21 >= *((void *)this + 2) || *v21 != 25) {
          continue;
        }
        *((void *)this + 1) = v21 + 1;
LABEL_49:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 24) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 76) |= 4u;
        int v22 = (unsigned char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v22 >= v12 || *v22 != 32) {
          continue;
        }
        int v13 = v22 + 1;
        *((void *)this + 1) = v13;
LABEL_53:
        v39[0] = 0;
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v23 = v39[0];
          unsigned int v24 = (unsigned char *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int v23 = *v13;
          unsigned int v24 = v13 + 1;
          *((void *)this + 1) = v24;
        }
        *(unsigned char *)(a1 + 64) = v23 != 0;
        *(_DWORD *)(a1 + 76) |= 8u;
        if ((unint64_t)v24 >= v12 || *v24 != 41) {
          continue;
        }
        *((void *)this + 1) = v24 + 1;
LABEL_61:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 32) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 76) |= 0x10u;
        unsigned int v25 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v25 >= *((void *)this + 2) || *v25 != 49) {
          continue;
        }
        *((void *)this + 1) = v25 + 1;
LABEL_65:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 76) |= 0x20u;
        unsigned int v26 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v26 >= *((void *)this + 2) || *v26 != 57) {
          continue;
        }
        *((void *)this + 1) = v26 + 1;
LABEL_69:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 48) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 76) |= 0x40u;
        unsigned int v27 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v27 >= *((void *)this + 2) || *v27 != 65) {
          continue;
        }
        *((void *)this + 1) = v27 + 1;
LABEL_73:
        *(void *)int v39 = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39))
        {
          *(void *)(a1 + 56) = *(void *)v39;
          *(_DWORD *)(a1 + 76) |= 0x80u;
          unsigned int v28 = (unsigned char *)*((void *)this + 1);
          unint64_t v14 = *((void *)this + 2);
          if ((unint64_t)v28 < v14 && *v28 == 72)
          {
            unint64_t v15 = v28 + 1;
            *((void *)this + 1) = v15;
LABEL_77:
            v39[0] = 0;
            if ((unint64_t)v15 >= v14 || *v15 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
              if (!result) {
                return result;
              }
              unsigned int v29 = v39[0];
              unsigned int v30 = (unsigned char *)*((void *)this + 1);
              unint64_t v14 = *((void *)this + 2);
            }
            else
            {
              unsigned int v29 = *v15;
              unsigned int v30 = v15 + 1;
              *((void *)this + 1) = v30;
            }
            *(unsigned char *)(a1 + 65) = v29 != 0;
            *(_DWORD *)(a1 + 76) |= 0x100u;
            if ((unint64_t)v30 < v14 && *v30 == 80)
            {
              unsigned int v16 = v30 + 1;
              *((void *)this + 1) = v16;
LABEL_85:
              v39[0] = 0;
              if ((unint64_t)v16 >= v14 || *v16 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                if (!result) {
                  return result;
                }
                unsigned int v31 = v39[0];
                unsigned int v32 = (unsigned char *)*((void *)this + 1);
                unint64_t v14 = *((void *)this + 2);
              }
              else
              {
                unsigned int v31 = *v16;
                unsigned int v32 = v16 + 1;
                *((void *)this + 1) = v32;
              }
              *(unsigned char *)(a1 + 66) = v31 != 0;
              *(_DWORD *)(a1 + 76) |= 0x200u;
              if ((unint64_t)v32 < v14 && *v32 == 88)
              {
                int v17 = v32 + 1;
                *((void *)this + 1) = v17;
LABEL_93:
                v39[0] = 0;
                if ((unint64_t)v17 >= v14 || *v17 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                  if (!result) {
                    return result;
                  }
                  unsigned int v33 = v39[0];
                  int v34 = (unsigned char *)*((void *)this + 1);
                  unint64_t v14 = *((void *)this + 2);
                }
                else
                {
                  unsigned int v33 = *v17;
                  int v34 = v17 + 1;
                  *((void *)this + 1) = v34;
                }
                *(unsigned char *)(a1 + 67) = v33 != 0;
                *(_DWORD *)(a1 + 76) |= 0x400u;
                if ((unint64_t)v34 < v14 && *v34 == 96)
                {
                  BOOL v18 = v34 + 1;
                  *((void *)this + 1) = v18;
LABEL_101:
                  v39[0] = 0;
                  if ((unint64_t)v18 >= v14 || *v18 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                    if (!result) {
                      return result;
                    }
                    unsigned int v35 = v39[0];
                    int v36 = (unsigned char *)*((void *)this + 1);
                    unint64_t v14 = *((void *)this + 2);
                  }
                  else
                  {
                    unsigned int v35 = *v18;
                    int v36 = v18 + 1;
                    *((void *)this + 1) = v36;
                  }
                  *(unsigned char *)(a1 + 68) = v35 != 0;
                  *(_DWORD *)(a1 + 76) |= 0x800u;
                  if ((unint64_t)v36 < v14 && *v36 == 104)
                  {
                    int v19 = v36 + 1;
                    *((void *)this + 1) = v19;
LABEL_109:
                    v39[0] = 0;
                    if ((unint64_t)v19 >= v14 || *v19 < 0)
                    {
                      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                      if (!result) {
                        return result;
                      }
                      unsigned int v37 = v39[0];
                      uint64_t v38 = (unsigned __int8 *)*((void *)this + 1);
                      unint64_t v14 = *((void *)this + 2);
                    }
                    else
                    {
                      unsigned int v37 = *v19;
                      uint64_t v38 = (unsigned __int8 *)(v19 + 1);
                      *((void *)this + 1) = v38;
                    }
                    *(unsigned char *)(a1 + 69) = v37 != 0;
                    *(_DWORD *)(a1 + 76) |= 0x1000u;
                    if (v38 == (unsigned __int8 *)v14
                      && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                    {
                      *((_DWORD *)this + 8) = 0;
                      uint64_t result = 1;
                      *((unsigned char *)this + 36) = 1;
                      return result;
                    }
                  }
                }
              }
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_49;
        }
        goto LABEL_36;
      case 4u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_53;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_61;
        }
        goto LABEL_36;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_65;
        }
        goto LABEL_36;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_69;
        }
        goto LABEL_36;
      case 8u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_73;
        }
        goto LABEL_36;
      case 9u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        unint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_77;
      case 0xAu:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        unsigned int v16 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_85;
      case 0xBu:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v17 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_93;
      case 0xCu:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        BOOL v18 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_101;
      case 0xDu:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v19 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_109;
      default:
        int v8 = TagFallback & 7;
LABEL_36:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_100FE0028(uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 76);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 76);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v4, *(double *)(v5 + 16), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
LABEL_17:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v4, *(double *)(v5 + 24), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_19;
  }
LABEL_18:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 64), v4, a4);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_20;
  }
LABEL_19:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v4, *(double *)(v5 + 32), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v4, *(double *)(v5 + 40), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_22;
  }
LABEL_21:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v4, *(double *)(v5 + 48), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_23;
  }
LABEL_22:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, v4, *(double *)(v5 + 56), a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_24;
  }
LABEL_23:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(unsigned __int8 *)(v5 + 65), v4, a4);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_25;
  }
LABEL_24:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(unsigned __int8 *)(v5 + 66), v4, a4);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
LABEL_26:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, *(unsigned __int8 *)(v5 + 68), v4, a4);
    if ((*(_DWORD *)(v5 + 76) & 0x1000) == 0) {
      return result;
    }
    goto LABEL_27;
  }
LABEL_25:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(unsigned __int8 *)(v5 + 67), v4, a4);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 0x800) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  if ((v6 & 0x1000) == 0) {
    return result;
  }
LABEL_27:
  int v7 = *(unsigned __int8 *)(v5 + 69);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v7, v4, a4);
}

uint64_t sub_100FE01CC(uint64_t a1, unint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 76);
  if ((_BYTE)v3)
  {
    if (v3)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 76);
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if ((v3 & 8) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x10) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x20) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x40) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x80) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  if ((v3 & 0xFF00) != 0)
  {
    unsigned int v6 = result + 2;
    if ((v3 & 0x100) == 0) {
      unsigned int v6 = result;
    }
    if ((v3 & 0x200) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x400) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x800) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x1000) != 0) {
      uint64_t result = v6 + 2;
    }
    else {
      uint64_t result = v6;
    }
  }
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

void sub_100FE02B8(uint64_t a1, void *lpsrc)
{
  sub_100FD57D0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE0340()
{
  return 1;
}

void *sub_100FE0348@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceMapVector");
}

void sub_100FE0358(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309348;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE0378(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309348;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE03CC()
{
}

uint64_t sub_100FE0424(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 2);
  while (2)
  {
    unsigned int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 < v9 && (*v10 & 0x80000000) == 0)
        {
          unint64_t *v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)this + 1) = v11;
LABEL_24:
          a1[8] |= 1u;
          if ((unint64_t)v11 < v9 && *v11 == 16)
          {
            unint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (result)
        {
          uint64_t v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
LABEL_27:
        unsigned int v25 = 0;
        if ((unint64_t)v12 >= v9 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25);
          if (!result) {
            return result;
          }
          unsigned int v17 = v25;
        }
        else
        {
          unsigned int v17 = *v12;
          *((void *)this + 1) = v12 + 1;
        }
        if (sub_100748708(v17))
        {
          if (!sub_100748708(v17)) {
            sub_101A9C02C();
          }
          a1[8] |= 2u;
          a1[4] = v17;
        }
        BOOL v18 = (unsigned char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        if ((unint64_t)v18 >= v13 || *v18 != 24) {
          continue;
        }
        unint64_t v14 = v18 + 1;
        *((void *)this + 1) = v14;
LABEL_38:
        unsigned int v24 = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
          if (!result) {
            return result;
          }
          unsigned int v19 = v24;
        }
        else
        {
          unsigned int v19 = *v14;
          *((void *)this + 1) = v14 + 1;
        }
        if (sub_1001662E0(v19))
        {
          if (!sub_1001662E0(v19)) {
            sub_101A9C000();
          }
          a1[8] |= 4u;
          a1[5] = v19;
        }
        int v20 = (unsigned char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        if ((unint64_t)v20 >= v15 || *v20 != 32) {
          continue;
        }
        unsigned int v16 = v20 + 1;
        *((void *)this + 1) = v16;
LABEL_49:
        unsigned int v23 = 0;
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23);
          if (!result) {
            return result;
          }
          unsigned int v21 = v23;
        }
        else
        {
          unsigned int v21 = *v16;
          *((void *)this + 1) = v16 + 1;
        }
        if (sub_100748714(v21))
        {
          if (!sub_100748714(v21)) {
            sub_101A9BFD4();
          }
          a1[8] |= 8u;
          a1[6] = v21;
        }
        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_38;
      case 4u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_49;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FE0744(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = (int *)result;
  int v6 = *(_DWORD *)(result + 32);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = v5[8];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[5], v4, a4);
      if ((v5[8] & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[4], v4, a4);
  int v6 = v5[8];
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = v5[6];

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, v4, a4);
}

uint64_t sub_100FE07EC(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_28;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 32);
    if ((v3 & 2) == 0) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
      goto LABEL_13;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 11;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v4 = (v6 + v4);
LABEL_13:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_28;
    }
    goto LABEL_22;
  }
  int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
  if ((v7 & 0x80000000) != 0)
  {
    int v8 = 11;
  }
  else if (v7 >= 0x80)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v8 = 2;
  }
  uint64_t v4 = (v8 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_22:
    unint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 11;
    }
    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
    }
    else
    {
      int v10 = 2;
    }
    uint64_t v4 = (v10 + v4);
  }
LABEL_28:
  *(_DWORD *)(a1 + 28) = v4;
  return v4;
}

void sub_100FE08E4(uint64_t a1, void *lpsrc)
{
  sub_100FD5A08(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE096C()
{
  return 1;
}

void *sub_100FE0974@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceMotionActivityContext");
}

void sub_100FE0984(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023093C0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE09A4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023093C0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE09F8()
{
}

uint64_t sub_100FE0A50(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      uint64_t v11 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!result) {
          return result;
        }
        unint64_t v12 = (unsigned char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }
      else
      {
        unint64_t *v5 = *v11;
        unint64_t v12 = v11 + 1;
        *((void *)this + 1) = v12;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v12 < v9 && *v12 == 16)
      {
        int v10 = v12 + 1;
        *((void *)this + 1) = v10;
LABEL_24:
        unsigned int v15 = 0;
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v15);
          if (!result) {
            return result;
          }
          unsigned int v13 = v15;
        }
        else
        {
          unsigned int v13 = *v10;
          *((void *)this + 1) = v10 + 1;
        }
        if (sub_10023E790(v13))
        {
          if (!sub_10023E790(v13)) {
            sub_101A9C058();
          }
          *(_DWORD *)(a1 + 24) |= 2u;
          *(_DWORD *)(a1 + 16) = v13;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE0C18(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 16);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, v4, a4);
  }
  return result;
}

uint64_t sub_100FE0C84(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      if ((*(_DWORD *)(a1 + 24) & 2) == 0) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v3 = 0;
      if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
        goto LABEL_13;
      }
    }
    int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v4 & 0x80000000) != 0)
    {
      int v5 = 11;
    }
    else if (v4 >= 0x80)
    {
      int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2) + 1;
    }
    else
    {
      int v5 = 2;
    }
    uint64_t v3 = (v5 + v3);
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_13:
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v3;
  return v3;
}

void sub_100FE0D0C(uint64_t a1, void *lpsrc)
{
  sub_100FD5B3C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE0D94()
{
  return 1;
}

void *sub_100FE0D9C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceMountState");
}

void sub_100FE0DAC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309438;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE0DCC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309438;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE0E20()
{
}

uint64_t sub_100FE0E78(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      int v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v10 = 0;
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!result) {
          return result;
        }
        unsigned int v8 = v10;
      }
      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }
      if (sub_100748754(v8))
      {
        if ((sub_100748754(v8) & 1) == 0) {
          sub_101A9C084();
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE0FB4(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FE0FD0(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v4 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100FE102C(uint64_t a1, void *lpsrc)
{
  sub_100FD5C10(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE10B4()
{
  return 1;
}

void *sub_100FE10BC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceSignalEnvironment");
}

void sub_100FE10CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023094B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE10EC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023094B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE1140()
{
}

uint64_t sub_100FE1198(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }
        *(_DWORD *)(a1 + 44) |= 1u;
        if ((unint64_t)v11 < v9 && *v11 == 17)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_26;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_18;
        }
LABEL_26:
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 44) |= 2u;
        unsigned int v13 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v13 >= *((void *)this + 2) || *v13 != 25) {
          continue;
        }
        *((void *)this + 1) = v13 + 1;
LABEL_30:
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0;
        }
        *(void *)(a1 + 24) = v15;
        *(_DWORD *)(a1 + 44) |= 4u;
        unint64_t v14 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 != 33) {
          continue;
        }
        *((void *)this + 1) = v14 + 1;
LABEL_34:
        unint64_t v15 = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15))
        {
          *(void *)(a1 + 32) = v15;
          *(_DWORD *)(a1 + 44) |= 8u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          continue;
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_30;
        }
        goto LABEL_18;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_18;
        }
        goto LABEL_34;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_100FE1400(uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 44);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v4, *(double *)(v5 + 24), a3);
      if ((*(_DWORD *)(v5 + 44) & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v4, *(double *)(v5 + 16), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  double v7 = *(double *)(v5 + 32);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v4, v7, a3);
}

uint64_t sub_100FE14A8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 44);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 44))
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 44);
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if ((v3 & 8) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = result;
  return result;
}

double sub_100FE151C(uint64_t a1, void *lpsrc)
{
  return sub_100FD5CC4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE15A4()
{
  return 1;
}

void *sub_100FE15AC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceSpeedConstraint");
}

void sub_100FE15BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309528;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE15DC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309528;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE1630()
{
}

uint64_t sub_100FE1684(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v6 = (char *)*((void *)this + 1);
          if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
          {
            unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = TagFallback;
            if (!TagFallback) {
              return 1;
            }
          }
          else
          {
            unint64_t TagFallback = *v6;
            *((_DWORD *)this + 8) = TagFallback;
            *((void *)this + 1) = v6 + 1;
            if (!TagFallback) {
              return 1;
            }
          }
          unsigned int v8 = TagFallback >> 3;
          if (TagFallback >> 3 != 1) {
            break;
          }
          int v9 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_19;
          }
          uint64_t v11 = (char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 >= v10 || *v11 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
            if (!result) {
              return result;
            }
            unint64_t v12 = (unsigned char *)*((void *)this + 1);
            unint64_t v10 = *((void *)this + 2);
          }
          else
          {
            unint64_t *v5 = *v11;
            unint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
          }
          *(_DWORD *)(a1 + 36) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 17)
          {
            *((void *)this + 1) = v12 + 1;
            goto LABEL_27;
          }
        }
        if (v8 != 2) {
          break;
        }
        int v9 = TagFallback & 7;
        if (v9 != 1) {
          goto LABEL_19;
        }
LABEL_27:
        unint64_t v15 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) |= 2u;
        unint64_t v14 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v14 < *((void *)this + 2) && *v14 == 25)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_31;
        }
      }
      if (v8 != 3) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 1) {
        goto LABEL_19;
      }
LABEL_31:
      unint64_t v15 = 0;
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
        return 0;
      }
      *(void *)(a1 + 24) = v15;
      *(_DWORD *)(a1 + 36) |= 4u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v9 = TagFallback & 7;
LABEL_19:
    if (v9 == 4) {
      return 1;
    }
  }
  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) != 0);
  return 0;
}

uint64_t sub_100FE1870(uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v4, *(double *)(v5 + 16), a3);
    if ((*(_DWORD *)(v5 + 36) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  double v7 = *(double *)(v5 + 24);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v4, v7, a3);
}

uint64_t sub_100FE18FC(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 36);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 36))
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

double sub_100FE1964(uint64_t a1, void *lpsrc)
{
  return sub_100FD5DD0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE19EC()
{
  return 1;
}

void *sub_100FE19F4@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetAssistanceAlongTrackVelocity");
}

void sub_100FE1A04(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023095A0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE1A24(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023095A0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE1A78()
{
}

uint64_t sub_100FE1AC8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  int v6 = (unsigned int *)(a1 + 16);
  while (1)
  {
    while (1)
    {
      double v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v7;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v7 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unint64_t v12 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!result) {
          return result;
        }
        unsigned int v13 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }
      else
      {
        unint64_t *v5 = *v12;
        unsigned int v13 = v12 + 1;
        *((void *)this + 1) = v13;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        uint64_t v11 = v13 + 1;
        *((void *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v11;
          unint64_t v14 = (unsigned __int8 *)(v11 + 1);
          *((void *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 24) |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = TagFallback & 7;
    }
LABEL_16:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE1C68(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 16);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, v4, a4);
  }
  return result;
}

uint64_t sub_100FE1CD4(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
      if ((*(_DWORD *)(a1 + 24) & 2) == 0) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v3 = 0;
      if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
        goto LABEL_11;
      }
    }
    unsigned int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v4 >= 0x80) {
      int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2) + 1;
    }
    else {
      int v5 = 2;
    }
    uint64_t v3 = (v5 + v3);
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_11:
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v3;
  return v3;
}

void sub_100FE1D50(uint64_t a1, void *lpsrc)
{
  sub_100FD6D18(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE1DD8()
{
  return 1;
}

void *sub_100FE1DE0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetThermalRiskState");
}

void sub_100FE1DF0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309618;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE1E10(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309618;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE1E64()
{
}

uint64_t sub_100FE1EB8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      int v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v16 = 0;
      unint64_t v10 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v10 >= v8 || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
        if (!result) {
          return result;
        }
        unsigned int v11 = v16;
        unint64_t v12 = (unsigned char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }
      else
      {
        unsigned int v11 = *v10;
        unint64_t v12 = v10 + 1;
        *((void *)this + 1) = v12;
      }
      *(unsigned char *)(a1 + 8) = v11 != 0;
      *(_DWORD *)(a1 + 20) |= 1u;
      if ((unint64_t)v12 < v8 && *v12 == 16)
      {
        int v9 = v12 + 1;
        *((void *)this + 1) = v9;
LABEL_23:
        unsigned int v17 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
          if (!result) {
            return result;
          }
          unsigned int v13 = v17;
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v13 = *v9;
          unint64_t v14 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 12) = v13;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v14 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_23;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE2068(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FE20D4(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[5];
  if ((_BYTE)v3)
  {
    uint64_t v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[3];
      if ((v5 & 0x80000000) != 0)
      {
        int v6 = 11;
      }
      else if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      }
      else
      {
        int v6 = 2;
      }
      uint64_t v4 = (v6 + v4);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[4] = v4;
  return v4;
}

void sub_100FE2144(uint64_t a1, void *lpsrc)
{
  sub_100FD6484(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE21CC()
{
  return 1;
}

void *sub_100FE21D4@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetConfigSimulatorMode");
}

void sub_100FE21E4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309690;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE2204(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309690;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE2258()
{
}

uint64_t sub_100FE22A4(unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = a1 + 2;
  int v6 = a1 + 3;
  while (1)
  {
    while (1)
    {
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v7;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v7 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unint64_t v12 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (!result) {
          return result;
        }
        unsigned int v13 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }
      else
      {
        unsigned int *v5 = *v12;
        unsigned int v13 = v12 + 1;
        *((void *)this + 1) = v13;
      }
      a1[5] |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        unsigned int v11 = v13 + 1;
        *((void *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v11;
          unint64_t v14 = (unsigned __int8 *)(v11 + 1);
          *((void *)this + 1) = v14;
        }
        a1[5] |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = TagFallback & 7;
    }
LABEL_16:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE2444(uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FE24B0(uint64_t a1, unsigned int a2)
{
  char v3 = *(unsigned char *)(a1 + 20);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if (v5 >= 0x80)
      {
        uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v4 = 2;
        if ((v3 & 2) == 0) {
          goto LABEL_14;
        }
      }
    }
    else
    {
      uint64_t v4 = 0;
      if ((*(unsigned char *)(a1 + 20) & 2) == 0) {
        goto LABEL_14;
      }
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if (v6 >= 0x80) {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    }
    else {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }
  else
  {
    uint64_t v4 = 0;
  }
LABEL_14:
  *(_DWORD *)(a1 + 16) = v4;
  return v4;
}

void sub_100FE2540(_DWORD *a1, void *lpsrc)
{
  sub_100FD6548(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE25C8()
{
  return 1;
}

void *sub_100FE25D0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetConfigEnableGnssConstellations");
}

void sub_100FE25E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309708;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE2600(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309708;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE2654()
{
}

uint64_t sub_100FE26A4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v17 = 0;
      unint64_t v10 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v10 >= v8 || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
        if (!result) {
          return result;
        }
        unsigned int v11 = v17;
        unint64_t v12 = (unsigned char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }
      else
      {
        unsigned int v11 = *v10;
        unint64_t v12 = v10 + 1;
        *((void *)this + 1) = v12;
      }
      *(unsigned char *)(a1 + 8) = v11 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if ((unint64_t)v12 < v8 && *v12 == 16)
      {
        int v9 = v12 + 1;
        *((void *)this + 1) = v9;
LABEL_23:
        unsigned int v16 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
          if (!result) {
            return result;
          }
          unsigned int v13 = v16;
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v13 = *v9;
          unint64_t v14 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v14;
        }
        *(unsigned char *)(a1 + 9) = v13 != 0;
        *(_DWORD *)(a1 + 16) |= 2u;
        if (v14 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_23;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE285C(uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 16);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(unsigned __int8 *)(v5 + 9);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FE28C8(uint64_t a1)
{
  unsigned int v1 = 2 * (*(_DWORD *)(a1 + 16) & 1);
  if ((*(_DWORD *)(a1 + 16) & 2) != 0) {
    v1 += 2;
  }
  if (*(_DWORD *)(a1 + 16)) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  *(_DWORD *)(a1 + 12) = v2;
  return v2;
}

void sub_100FE28F0(uint64_t a1, unsigned char *lpsrc)
{
  sub_100FD6DDC(a1, lpsrc);
}

uint64_t sub_100FE2978()
{
  return 1;
}

void *sub_100FE2980@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetConfigRfBandEnable");
}

void sub_100FE2990(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309780;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE29B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309780;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE2A04()
{
}

uint64_t sub_100FE2A54(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v12 = 0;
      unint64_t v8 = (char *)*((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      if ((unint64_t)v8 >= v7 || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!result) {
          return result;
        }
        unsigned int v9 = v12;
        unint64_t v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v7 = *((void *)this + 2);
      }
      else
      {
        unsigned int v9 = *v8;
        unint64_t v10 = (unsigned __int8 *)(v8 + 1);
        *((void *)this + 1) = v10;
      }
      *(unsigned char *)(a1 + 8) = v9 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if (v10 == (unsigned __int8 *)v7 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE2B74(uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FE2B90(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16)) {
    uint64_t v1 = 2 * (*(_DWORD *)(a1 + 16) & 1u);
  }
  else {
    uint64_t v1 = 0;
  }
  *(_DWORD *)(a1 + 12) = v1;
  return v1;
}

void sub_100FE2BAC(uint64_t a1, void *lpsrc)
{
  sub_100FD660C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE2C34()
{
  return 1;
}

void *sub_100FE2C3C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.SetConfigDutyCycling");
}

void sub_100FE2C4C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023097F8;
  sub_1001A4D20((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE2CA0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023097F8;
  sub_1001A4D20((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE2D08()
{
}

uint64_t sub_100FE2D5C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE2E7C(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return result;
}

uint64_t sub_100FE2E98(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8, a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(unsigned char *)(v4 + 23);
    }
    else
    {
      int v9 = 2;
    }
    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100FE2F18(uint64_t a1, void *lpsrc)
{
  sub_100FD66B0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE2FA0()
{
  return 1;
}

void *sub_100FE2FA8@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.TerminationImminent");
}

void sub_100FE2FB8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309870;
  sub_1001A4D20((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE300C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309870;
  sub_1001A4D20((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE3074()
{
}

uint64_t sub_100FE30C8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      int v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE31E8(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return result;
}

uint64_t sub_100FE3204(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8, a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(unsigned char *)(v4 + 23);
    }
    else
    {
      int v9 = 2;
    }
    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100FE3284(uint64_t a1, void *lpsrc)
{
  sub_100FD6790(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE330C()
{
  return 1;
}

void *sub_100FE3314@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.ExitMessage");
}

void sub_100FE3324(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      char v6 = *(unsigned char *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 1u;
      *(unsigned char *)(a1 + 12) = v6;
      int v4 = *(_DWORD *)(a2 + 20);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 20) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 2u;
    *(_DWORD *)(a1 + 8) = v7;
    int v4 = *(_DWORD *)(a2 + 20);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_12:
    char v8 = *(unsigned char *)(a2 + 13);
    *(_DWORD *)(a1 + 20) |= 4u;
    *(unsigned char *)(a1 + 13) = v8;
    if ((*(_DWORD *)(a2 + 20) & 8) == 0) {
      return;
    }
LABEL_8:
    char v5 = *(unsigned char *)(a2 + 14);
    *(_DWORD *)(a1 + 20) |= 8u;
    *(unsigned char *)(a1 + 14) = v5;
  }
}

void sub_100FE3418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE3430(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023098E8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE3450(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1023098E8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE34A4()
{
}

uint64_t sub_100FE34F8(uint64_t result)
{
  if (*(unsigned char *)(result + 20))
  {
    *(_DWORD *)(result + 11) = 0;
    *(_DWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FE3510(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    char v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_17;
        }
        unsigned int v22 = 0;
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 < v8 && (*v9 & 0x80000000) == 0)
        {
          unsigned int v10 = *v9;
          unsigned int v11 = v9 + 1;
          *((void *)this + 1) = v11;
LABEL_23:
          *(unsigned char *)(a1 + 12) = v10 != 0;
          *(_DWORD *)(a1 + 20) |= 1u;
          if ((unint64_t)v11 < v8 && *v11 == 16)
          {
            unsigned int v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_26;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
        if (result)
        {
          unsigned int v10 = v22;
          unsigned int v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_23;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_17;
        }
        unsigned int v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_26:
        unsigned int v22 = 0;
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v15 = v22;
          unsigned int v16 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v15 = *v12;
          unsigned int v16 = v12 + 1;
          *((void *)this + 1) = v16;
        }
        *(_DWORD *)(a1 + 8) = v15;
        *(_DWORD *)(a1 + 20) |= 2u;
        if ((unint64_t)v16 >= v8 || *v16 != 24) {
          continue;
        }
        unsigned int v13 = v16 + 1;
        *((void *)this + 1) = v13;
LABEL_34:
        unsigned int v22 = 0;
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v17 = v22;
          BOOL v18 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v17 = *v13;
          BOOL v18 = v13 + 1;
          *((void *)this + 1) = v18;
        }
        *(unsigned char *)(a1 + 13) = v17 != 0;
        *(_DWORD *)(a1 + 20) |= 4u;
        if ((unint64_t)v18 >= v8 || *v18 != 32) {
          continue;
        }
        unint64_t v14 = v18 + 1;
        *((void *)this + 1) = v14;
LABEL_42:
        unsigned int v22 = 0;
        if ((unint64_t)v14 >= v8 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v19 = v22;
          int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v19 = *v14;
          int v20 = (unsigned __int8 *)(v14 + 1);
          *((void *)this + 1) = v20;
        }
        *(unsigned char *)(a1 + 14) = v19 != 0;
        *(_DWORD *)(a1 + 20) |= 8u;
        if (v20 != (unsigned __int8 *)v8 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_17;
        }
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_34;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_17;
        }
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_42;
      default:
        int v7 = TagFallback & 7;
LABEL_17:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FE37F0(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 12), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 13), a2, a4);
      if ((*(_DWORD *)(v5 + 20) & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 8), a2, a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  int v7 = *(unsigned __int8 *)(v5 + 14);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t sub_100FE3898(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[5];
  if ((_BYTE)v3)
  {
    int v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[2];
      if ((v5 & 0x80000000) != 0)
      {
        int v6 = 11;
      }
      else if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
        unsigned int v3 = a1[5];
      }
      else
      {
        int v6 = 2;
      }
      v4 += v6;
    }
    unsigned int v8 = v4 + 2;
    if ((v3 & 4) == 0) {
      unsigned int v8 = v4;
    }
    if ((v3 & 8) != 0) {
      uint64_t result = v8 + 2;
    }
    else {
      uint64_t result = v8;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  a1[4] = result;
  return result;
}

void sub_100FE3920(uint64_t a1, void *lpsrc)
{
  sub_100FE3324(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE39A8()
{
  return 1;
}

void *sub_100FE39B0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.RecoveryStatistics.RecoveryStatus");
}

void sub_100FE39C0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 32);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 32))
    {
      uint64_t v5 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      int v6 = *(std::string **)(a1 + 8);
      if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v6, v5);
      int v4 = *(_DWORD *)(a2 + 32);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v7 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(_DWORD *)(a1 + 24) = v7;
    if ((*(_DWORD *)(a2 + 32) & 4) == 0) {
      return;
    }
LABEL_12:
    unsigned int v8 = *(const std::string **)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 4u;
    int v9 = *(std::string **)(a1 + 16);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v9, v8);
  }
}

void sub_100FE3B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE3B24(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309960;
  sub_100258038((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE3B78(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309960;
  sub_100258038((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE3BE0()
{
}

uint64_t sub_100FE3C38(uint64_t result)
{
  if (*(unsigned char *)(result + 32))
  {
    if (*(unsigned char *)(result + 32))
    {
      uint64_t v1 = *(void *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(unsigned char **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v1 = 0;
          *(unsigned char *)(v1 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(result + 24) = 0;
    if ((*(unsigned char *)(result + 32) & 4) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FE3CB8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v5 = (char *)*((void *)this + 1);
          if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
          {
            unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = TagFallback;
            if (!TagFallback) {
              return 1;
            }
          }
          else
          {
            unint64_t TagFallback = *v5;
            *((_DWORD *)this + 8) = TagFallback;
            *((void *)this + 1) = v5 + 1;
            if (!TagFallback) {
              return 1;
            }
          }
          unsigned int v7 = TagFallback >> 3;
          if (TagFallback >> 3 != 1) {
            break;
          }
          int v8 = TagFallback & 7;
          if (v8 != 2) {
            goto LABEL_24;
          }
          *(_DWORD *)(a1 + 32) |= 1u;
          if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
          if (!result) {
            return result;
          }
          unsigned int v12 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          if ((unint64_t)v12 < v11 && *v12 == 16)
          {
            unsigned int v13 = v12 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_20;
          }
        }
        if (v7 != 2) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_24;
        }
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_20:
        unsigned int v16 = 0;
        if ((unint64_t)v13 >= v11 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
          if (!result) {
            return result;
          }
          unsigned int v14 = v16;
          unsigned int v15 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v14 = *v13;
          unsigned int v15 = v13 + 1;
          *((void *)this + 1) = v15;
        }
        *(_DWORD *)(a1 + 24) = v14;
        int v9 = *(_DWORD *)(a1 + 32) | 2;
        *(_DWORD *)(a1 + 32) = v9;
        if ((unint64_t)v15 < v11 && *v15 == 26)
        {
          *((void *)this + 1) = v15 + 1;
          goto LABEL_32;
        }
      }
      if (v7 != 3) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_24;
      }
      int v9 = *(_DWORD *)(a1 + 32);
LABEL_32:
      *(_DWORD *)(a1 + 32) = v9 | 4;
      if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v8 = TagFallback & 7;
LABEL_24:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE3EF8(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 24), a2, a4);
    if ((*(_DWORD *)(v5 + 32) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t sub_100FE3F84(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_31;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v10 = v11 + 1;
      int v3 = *(_DWORD *)(a1 + 32);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 2;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v4 = (v10 + v6);
    if ((v3 & 2) == 0) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
      goto LABEL_21;
    }
  }
  unsigned int v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if ((v12 & 0x80000000) != 0)
  {
    int v13 = 11;
  }
  else if (v12 >= 0x80)
  {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v13 = 2;
  }
  uint64_t v4 = (v13 + v4);
LABEL_21:
  if ((v3 & 4) != 0)
  {
    uint64_t v14 = *(void *)(a1 + 16);
    int v15 = *(unsigned __int8 *)(v14 + 23);
    char v16 = v15;
    uint64_t v17 = *(void *)(v14 + 8);
    if ((v15 & 0x80u) == 0) {
      unint64_t v18 = *(unsigned __int8 *)(v14 + 23);
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18 >= 0x80)
    {
      int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18, a2);
      int v15 = *(unsigned __int8 *)(v14 + 23);
      uint64_t v17 = *(void *)(v14 + 8);
      char v16 = *(unsigned char *)(v14 + 23);
    }
    else
    {
      int v19 = 1;
    }
    if (v16 < 0) {
      int v15 = v17;
    }
    uint64_t v4 = (v4 + v19 + v15 + 1);
  }
LABEL_31:
  *(_DWORD *)(a1 + 28) = v4;
  return v4;
}

void sub_100FE40AC(uint64_t a1, void *lpsrc)
{
  sub_100FE39C0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE4134()
{
  return 1;
}

void *sub_100FE413C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.RecoveryStatistics.RecoveryPoint");
}

void sub_100FE414C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1023099D8;
  if ((uint64_t *)qword_10248B0C0 != a1)
  {
    uint64_t v2 = a1[4];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_100FE41E8(uint64_t *a1)
{
  sub_100FE414C(a1);

  operator delete();
}

void sub_100FE4220()
{
}

uint64_t sub_100FE4274(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8);
  do
  {
    while (1)
    {
LABEL_2:
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 == 2)
      {
        while (1)
        {
          int v11 = *(_DWORD *)(a1 + 20);
          uint64_t v12 = *(int *)(a1 + 16);
          if ((int)v12 >= v11)
          {
            if (v11 == *(_DWORD *)(a1 + 24))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v11 + 1);
              int v11 = *(_DWORD *)(a1 + 20);
            }
            *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v11 + 1;
            operator new();
          }
          uint64_t v13 = *(void *)(a1 + 8);
          *(_DWORD *)(a1 + 16) = v12 + 1;
          uint64_t v14 = *(void *)(v13 + 8 * v12);
          unsigned int v32 = 0;
          int v15 = (char *)*((void *)this + 1);
          if ((unint64_t)v15 >= *((void *)this + 2) || *v15 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32))return 0; {
          }
            }
          else
          {
            unsigned int v32 = *v15;
            *((void *)this + 1) = v15 + 1;
          }
          int v16 = *((_DWORD *)this + 14);
          int v17 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v16 + 1;
          if (v16 >= v17) {
            return 0;
          }
          int v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v32);
          if (!sub_100FE3CB8(v14, this, v19) || !*((unsigned char *)this + 36)) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v18);
          int v20 = *((_DWORD *)this + 14);
          BOOL v21 = __OFSUB__(v20, 1);
          int v22 = v20 - 1;
          if (v22 < 0 == v21) {
            *((_DWORD *)this + 14) = v22;
          }
          unsigned int v23 = (unsigned __int8 *)*((void *)this + 1);
          if ((unint64_t)v23 >= *((void *)this + 2)) {
            goto LABEL_2;
          }
          int v24 = *v23;
          if (v24 != 10)
          {
            if (v24 != 18) {
              goto LABEL_2;
            }
            *((void *)this + 1) = v23 + 1;
            goto LABEL_10;
          }
          *((void *)this + 1) = v23 + 1;
        }
      }
LABEL_34:
      if (v8 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
    }
      }
    if (TagFallback >> 3 != 2)
    {
      int v8 = TagFallback & 7;
      goto LABEL_34;
    }
    int v8 = TagFallback & 7;
    if (v8 != 2) {
      goto LABEL_34;
    }
LABEL_10:
    *(_DWORD *)(a1 + 44) |= 2u;
    uint64_t v9 = *(void *)(a1 + 32);
    if (!v9) {
      operator new();
    }
    unsigned int v33 = 0;
    int v10 = (char *)*((void *)this + 1);
    if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33)) {
        return 0;
      }
    }
    else
    {
      unsigned int v33 = *v10;
      *((void *)this + 1) = v10 + 1;
    }
    int v25 = *((_DWORD *)this + 14);
    int v26 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v25 + 1;
    if (v25 >= v26) {
      return 0;
    }
    int v27 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v33);
    if (!sub_100FE3510(v9, this, v28) || !*((unsigned char *)this + 36)) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v27);
    int v29 = *((_DWORD *)this + 14);
    BOOL v21 = __OFSUB__(v29, 1);
    int v30 = v29 - 1;
    if (v30 < 0 == v21) {
      *((_DWORD *)this + 14) = v30;
    }
  }
  while (*((void *)this + 1) != *((void *)this + 2)
       || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10));
  *((_DWORD *)this + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)this + 36) = 1;
  return result;
}

uint64_t sub_100FE45E0(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  if ((*(unsigned char *)(v5 + 44) & 2) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 32);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_10248B0C0 + 32);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FE4684(uint64_t a1, unsigned int a2)
{
  if ((*(unsigned char *)(a1 + 44) & 2) != 0)
  {
    uint64_t v4 = *(unsigned int **)(a1 + 32);
    if (!v4) {
      uint64_t v4 = *(unsigned int **)(qword_10248B0C0 + 32);
    }
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE3898(v4, a2);
    int v6 = (int)v5;
    if (v5 >= 0x80) {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    }
    else {
      int v7 = 1;
    }
    int v3 = v6 + v7 + 1;
  }
  else
  {
    int v3 = 0;
  }
  int v8 = *(_DWORD *)(a1 + 16);
  uint64_t v9 = (v8 + v3);
  if (v8 >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE3F84(*(void *)(*(void *)(a1 + 8) + 8 * v10), a2);
      int v12 = (int)v11;
      if (v11 >= 0x80) {
        int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
      }
      else {
        int v13 = 1;
      }
      uint64_t v9 = (v12 + v9 + v13);
      ++v10;
    }
    while (v10 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = v9;
  return v9;
}

void sub_100FE4754(uint64_t a1, void *lpsrc)
{
  sub_100FDB778(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE47DC()
{
  return 1;
}

void *sub_100FE47E4@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.RecoveryStatistics");
}

void sub_100FE47F4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE4814(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE4868()
{
}

uint64_t sub_100FE48B4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v10 = 0;
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!result) {
          return result;
        }
        unsigned int v8 = v10;
      }
      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }
      if (v8 <= 4)
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE49D4(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FE49F0(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v4 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100FE4A4C(uint64_t a1, void *lpsrc)
{
  sub_100FDB970(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE4AD4()
{
  return 1;
}

void *sub_100FE4ADC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfoRequest");
}

void sub_100FE4AEC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  int v4 = *(_DWORD *)(a2 + 24);
  if (v4)
  {
    sub_100221DFC(a1 + 16, *(_DWORD *)(a1 + 24) + v4);
    memcpy((void *)(*(void *)(a1 + 16) + 4 * *(int *)(a1 + 24)), *(const void **)(a2 + 16), 4 * *(int *)(a2 + 24));
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
  }
  int v5 = *(_DWORD *)(a2 + 40);
  if (v5)
  {
    sub_100221DFC(a1 + 32, *(_DWORD *)(a1 + 40) + v5);
    memcpy((void *)(*(void *)(a1 + 32) + 4 * *(int *)(a1 + 40)), *(const void **)(a2 + 32), 4 * *(int *)(a2 + 40));
    *(_DWORD *)(a1 + 40) += *(_DWORD *)(a2 + 40);
  }
  LOBYTE(v6) = *(unsigned char *)(a2 + 52);
  if ((_BYTE)v6)
  {
    if (*(unsigned char *)(a2 + 52))
    {
      int v7 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 52) |= 1u;
      *(_DWORD *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 52);
    }
    if ((v6 & 2) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 52) |= 2u;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }
}

void sub_100FE4C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE4C38(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102309AC8;
  if (*((void *)this + 4)) {
    operator delete[]();
  }
  if (*((void *)this + 2)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FE4CC4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100FE4C38(a1);

  operator delete();
}

void sub_100FE4CFC()
{
}

uint64_t sub_100FE4D54(uint64_t result)
{
  if (*(unsigned char *)(result + 52)) {
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 4sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

uint64_t sub_100FE4D70(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 32;
  uint64_t v6 = a1 + 16;
  int v7 = (unsigned int *)(a1 + 8);
  int v8 = (unsigned int *)(a1 + 12);
LABEL_2:
  while (2)
  {
    uint64_t v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v9;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v13 = (char *)*((void *)this + 1);
        int v12 = (char *)*((void *)this + 2);
        if (v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          uint64_t v14 = (char *)*((void *)this + 1);
          int v12 = (char *)*((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v13;
          uint64_t v14 = v13 + 1;
          *((void *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 52) |= 1u;
        if (v14 < v12 && *v14 == 16)
        {
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
          goto LABEL_33;
        }
        continue;
      case 2u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        int v15 = (char *)*((void *)this + 1);
        int v12 = (char *)*((void *)this + 2);
LABEL_33:
        if (v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!result) {
            return result;
          }
          unsigned int v19 = (char *)*((void *)this + 1);
          int v12 = (char *)*((void *)this + 2);
        }
        else
        {
          *int v8 = *v15;
          unsigned int v19 = v15 + 1;
          *((void *)this + 1) = v19;
        }
        *(_DWORD *)(a1 + 52) |= 2u;
        if (v19 >= v12) {
          continue;
        }
        int v20 = *v19;
        goto LABEL_61;
      case 3u:
        int v11 = TagFallback & 7;
        if (v11 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            int v16 = (char *)*((void *)this + 1);
            int v12 = (char *)*((void *)this + 2);
            goto LABEL_40;
          }
          goto LABEL_21;
        }
        uint64_t result = sub_100B73850(this, v6);
        if (!result) {
          return result;
        }
        while (1)
        {
          unsigned int v19 = (char *)*((void *)this + 1);
          int v12 = (char *)*((void *)this + 2);
          if (v19 >= v12) {
            goto LABEL_2;
          }
          int v20 = *v19;
          if (v20 == 32) {
            goto LABEL_82;
          }
LABEL_61:
          if (v20 != 24) {
            goto LABEL_2;
          }
          int v16 = v19 + 1;
          *((void *)this + 1) = v16;
LABEL_40:
          v42[0] = 0;
          if (v16 >= v12 || *v16 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v42);
            if (!result) {
              return result;
            }
            unsigned int v21 = v42[0];
          }
          else
          {
            unsigned int v21 = *v16;
            *((void *)this + 1) = v16 + 1;
          }
          int v22 = *(_DWORD *)(a1 + 24);
          if (v22 == *(_DWORD *)(a1 + 28))
          {
            sub_100221DFC(v6, v22 + 1);
            int v22 = *(_DWORD *)(a1 + 24);
          }
          uint64_t v23 = *(void *)(a1 + 16);
          *(_DWORD *)(a1 + 24) = v22 + 1;
          *(_DWORD *)(v23 + 4 * v22) = v21;
          int v24 = *(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 24);
          if (v24 >= 1)
          {
            int v25 = v24 + 1;
            do
            {
              int v26 = (unsigned char *)*((void *)this + 1);
              unint64_t v27 = *((void *)this + 2);
              if ((unint64_t)v26 >= v27 || *v26 != 24) {
                break;
              }
              *((void *)this + 1) = v26 + 1;
              v42[0] = 0;
              if ((unint64_t)(v26 + 1) >= v27 || (char)v26[1] < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v42);
                if (!result) {
                  return result;
                }
                unsigned int v28 = v42[0];
              }
              else
              {
                unsigned int v28 = v26[1];
                *((void *)this + 1) = v26 + 2;
              }
              int v29 = *(_DWORD *)(a1 + 24);
              if (v29 >= *(_DWORD *)(a1 + 28))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v42);
                int v29 = *(_DWORD *)(a1 + 24);
              }
              uint64_t v30 = *(void *)(a1 + 16);
              *(_DWORD *)(a1 + 24) = v29 + 1;
              *(_DWORD *)(v30 + 4 * v29) = v28;
              --v25;
            }
            while (v25 > 1);
          }
        }
      case 4u:
        int v11 = TagFallback & 7;
        if (v11 == 2)
        {
          uint64_t result = sub_1008CEA24(this, v5);
          if (!result) {
            return result;
          }
          while (1)
          {
            unsigned int v19 = (char *)*((void *)this + 1);
            int v12 = (char *)*((void *)this + 2);
            if (v19 >= v12 || *v19 != 32) {
              break;
            }
LABEL_82:
            int v17 = v19 + 1;
            *((void *)this + 1) = v17;
LABEL_63:
            unsigned int v41 = 0;
            if (v17 >= v12 || *v17 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v41))return 0; {
            }
              }
            else
            {
              unsigned int v41 = *v17;
              *((void *)this + 1) = v17 + 1;
            }
            int v31 = *(_DWORD *)(a1 + 40);
            if (v31 == *(_DWORD *)(a1 + 44))
            {
              sub_100221DFC(v5, v31 + 1);
              int v31 = *(_DWORD *)(a1 + 40);
            }
            unsigned int v32 = v41;
            uint64_t v33 = *(void *)(a1 + 32);
            *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = v31 + 1;
            *(_DWORD *)(v33 + 4 * v31) = v32;
            int v34 = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 40);
            if (v34 >= 1)
            {
              int v35 = v34 + 1;
              do
              {
                int v36 = (unsigned char *)*((void *)this + 1);
                unint64_t v37 = *((void *)this + 2);
                if ((unint64_t)v36 >= v37 || *v36 != 32) {
                  break;
                }
                *((void *)this + 1) = v36 + 1;
                if ((unint64_t)(v36 + 1) >= v37 || (char)v36[1] < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v41))return 0; {
                }
                  }
                else
                {
                  unsigned int v41 = v36[1];
                  *((void *)this + 1) = v36 + 2;
                }
                int v38 = *(_DWORD *)(a1 + 40);
                if (v38 >= *(_DWORD *)(a1 + 44))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v42);
                  int v38 = *(_DWORD *)(a1 + 40);
                }
                unsigned int v39 = v41;
                uint64_t v40 = *(void *)(a1 + 32);
                *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = v38 + 1;
                *(_DWORD *)(v40 + 4 * v38) = v39;
                --v35;
              }
              while (v35 > 1);
            }
          }
          if (v19 == v12 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          int v17 = (char *)*((void *)this + 1);
          int v12 = (char *)*((void *)this + 2);
          goto LABEL_63;
        }
LABEL_21:
        if (v11 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
      default:
        int v11 = TagFallback & 7;
        goto LABEL_21;
    }
  }
}

void sub_100FE5284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FE52B4(uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 52);
  }
  if ((v6 & 2) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  }
  if (*(int *)(v5 + 24) >= 1)
  {
    uint64_t v7 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(*(void *)(v5 + 16) + 4 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 24));
  }
  if (*(int *)(v5 + 40) >= 1)
  {
    uint64_t v8 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(*(void *)(v5 + 32) + 4 * v8++), a2, a4);
    while (v8 < *(int *)(v5 + 40));
  }
  return result;
}

uint64_t sub_100FE5378(uint64_t a1, unsigned int a2)
{
  char v3 = *(unsigned char *)(a1 + 52);
  if (!v3)
  {
    int v4 = 0;
    goto LABEL_14;
  }
  if (*(unsigned char *)(a1 + 52))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 52) & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    int v4 = 0;
    if ((*(unsigned char *)(a1 + 52) & 2) == 0) {
      goto LABEL_14;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if (v6 >= 0x80) {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
  }
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 < 1)
  {
    int v10 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 0;
    do
    {
      int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 16)
                                                                                             + 4 * v9);
      if ((v11 & 0x80000000) != 0)
      {
        int v12 = 10;
      }
      else if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v12 = 1;
      }
      v10 += v12;
      ++v9;
    }
    while (v9 < v8);
  }
  int v13 = *(_DWORD *)(a1 + 40);
  if (v13 < 1)
  {
    int v15 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    int v15 = 0;
    do
    {
      int v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 32)
                                                                                             + 4 * v14);
      if (v16 >= 0x80)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, a2);
        int v13 = *(_DWORD *)(a1 + 40);
      }
      else
      {
        int v17 = 1;
      }
      v15 += v17;
      ++v14;
    }
    while (v14 < v13);
  }
  uint64_t result = (v10 + v4 + v13 + v8 + v15);
  *(_DWORD *)(a1 + 48) = result;
  return result;
}

void sub_100FE54C8(uint64_t a1, void *lpsrc)
{
  sub_100FE4AEC(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE5550()
{
  return 1;
}

void *sub_100FE5558@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfo.LtlLutParams");
}

void sub_100FE5568(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  int v4 = *(_DWORD *)(a2 + 16);
  if (v4)
  {
    sub_100221DFC(a1 + 8, *(_DWORD *)(a1 + 16) + v4);
    memcpy((void *)(*(void *)(a1 + 8) + 4 * *(int *)(a1 + 16)), *(const void **)(a2 + 8), 4 * *(int *)(a2 + 16));
    *(_DWORD *)(a1 + 16) += *(_DWORD *)(a2 + 16);
  }
  int v5 = *(_DWORD *)(a2 + 36);
  if ((v5 & 0x1FE) != 0)
  {
    if ((v5 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 2u;
      *(_DWORD *)(a1 + 24) = v6;
      int v5 = *(_DWORD *)(a2 + 36);
    }
    if ((v5 & 4) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a1 + 36) |= 4u;
      *(_DWORD *)(a1 + 28) = v7;
    }
  }
}

void sub_100FE565C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE5674(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_102309B40;
  if (*((void *)this + 1)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FE56E4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_100FE5674(a1);

  operator delete();
}

void sub_100FE571C()
{
}

uint64_t sub_100FE5770(uint64_t result)
{
  if ((*(_WORD *)(result + 36) & 0x1FE) != 0) {
    *(void *)(result + 24) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100FE578C(uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 8;
  int v6 = (unsigned int *)(a1 + 24);
  int v7 = (unsigned int *)(a1 + 28);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_2:
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v8;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v10 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v11 = TagFallback & 7;
        if (v11 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            uint64_t v14 = (char *)*((void *)this + 1);
            unint64_t v12 = *((void *)this + 2);
            goto LABEL_23;
          }
          goto LABEL_18;
        }
        uint64_t result = sub_100B73850(this, v5);
        if (!result) {
          return result;
        }
        while (1)
        {
          int v26 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
          if ((unint64_t)v26 >= v12) {
            break;
          }
          int v27 = *v26;
          if (v27 == 16)
          {
            int v15 = (char *)(v26 + 1);
            *((void *)this + 1) = v15;
            goto LABEL_47;
          }
          if (v27 != 8) {
            goto LABEL_2;
          }
          uint64_t v14 = (char *)(v26 + 1);
          *((void *)this + 1) = v14;
LABEL_23:
          v31[0] = 0;
          if ((unint64_t)v14 >= v12 || *v14 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v31);
            if (!result) {
              return result;
            }
            unsigned int v16 = v31[0];
          }
          else
          {
            unsigned int v16 = *v14;
            *((void *)this + 1) = v14 + 1;
          }
          int v17 = *(_DWORD *)(a1 + 16);
          if (v17 == *(_DWORD *)(a1 + 20))
          {
            sub_100221DFC(v5, v17 + 1);
            int v17 = *(_DWORD *)(a1 + 16);
          }
          uint64_t v18 = *(void *)(a1 + 8);
          *(_DWORD *)(a1 + 16) = v17 + 1;
          *(_DWORD *)(v18 + 4 * v17) = v16;
          int v19 = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16);
          if (v19 >= 1)
          {
            int v20 = v19 + 1;
            do
            {
              unsigned int v21 = (unsigned char *)*((void *)this + 1);
              unint64_t v22 = *((void *)this + 2);
              if ((unint64_t)v21 >= v22 || *v21 != 8) {
                break;
              }
              *((void *)this + 1) = v21 + 1;
              v31[0] = 0;
              if ((unint64_t)(v21 + 1) >= v22 || (char)v21[1] < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v31);
                if (!result) {
                  return result;
                }
                unsigned int v23 = v31[0];
              }
              else
              {
                unsigned int v23 = v21[1];
                *((void *)this + 1) = v21 + 2;
              }
              int v24 = *(_DWORD *)(a1 + 16);
              if (v24 >= *(_DWORD *)(a1 + 20))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v31);
                int v24 = *(_DWORD *)(a1 + 16);
              }
              uint64_t v25 = *(void *)(a1 + 8);
              *(_DWORD *)(a1 + 16) = v24 + 1;
              *(_DWORD *)(v25 + 4 * v24) = v23;
              --v20;
            }
            while (v20 > 1);
          }
        }
      }
      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_18;
      }
      int v15 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_47:
      if ((unint64_t)v15 >= v12 || *v15 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
        if (!result) {
          return result;
        }
        unsigned int v28 = (unsigned char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }
      else
      {
        *int v6 = *v15;
        unsigned int v28 = v15 + 1;
        *((void *)this + 1) = v28;
      }
      *(_DWORD *)(a1 + 36) |= 2u;
      if ((unint64_t)v28 < v12 && *v28 == 24)
      {
        int v13 = v28 + 1;
        *((void *)this + 1) = v13;
LABEL_55:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          int v29 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v13;
          int v29 = (unsigned __int8 *)(v13 + 1);
          *((void *)this + 1) = v29;
        }
        *(_DWORD *)(a1 + 36) |= 4u;
        if (v29 == (unsigned __int8 *)v12
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_55;
      }
    }
    else
    {
      int v11 = TagFallback & 7;
    }
LABEL_18:
    if (v11 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

void sub_100FE5AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FE5B14(uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(*(void *)(v5 + 8) + 4 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  int v7 = *(_DWORD *)(v5 + 36);
  if ((v7 & 2) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 24), a2, a4);
    int v7 = *(_DWORD *)(v5 + 36);
  }
  if ((v7 & 4) != 0)
  {
    int v8 = *(_DWORD *)(v5 + 28);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v8, a2, a4);
  }
  return result;
}

uint64_t sub_100FE5BC0(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 36);
  if ((v3 & 0x1FE) == 0)
  {
    int v4 = 0;
    goto LABEL_14;
  }
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 36) & 4) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      int v4 = 2;
      if ((v3 & 4) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    int v4 = 0;
    if ((v3 & 4) == 0) {
      goto LABEL_14;
    }
  }
  uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 28);
  if (v6 >= 0x80) {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
  }
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 16);
  if (v8 < 1)
  {
    int v10 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 0;
    do
    {
      int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 8)
                                                                                             + 4 * v9);
      if ((v11 & 0x80000000) != 0)
      {
        int v12 = 10;
      }
      else if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 16);
      }
      else
      {
        int v12 = 1;
      }
      v10 += v12;
      ++v9;
    }
    while (v9 < v8);
  }
  uint64_t result = (v10 + v4 + v8);
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

void sub_100FE5CB8(uint64_t a1, void *lpsrc)
{
  sub_100FE5568(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE5D40()
{
  return 1;
}

void *sub_100FE5D48@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfo.LtlCurrentSrcCalibData");
}

void sub_100FE5D58(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      int v5 = *(_DWORD *)(a2 + 8);
      a1[5] |= 1u;
      a1[2] = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 12);
      a1[5] |= 2u;
      a1[3] = v6;
    }
  }
}

void sub_100FE5E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE5E1C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE5E3C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE5E90()
{
}

uint64_t sub_100FE5EDC(uint64_t result)
{
  if (*(unsigned char *)(result + 20)) {
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = 0;
  return result;
}

uint64_t sub_100FE5EF0(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 3;
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v6;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v16 = 0;
      int v11 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
        if (!result) {
          return result;
        }
        unsigned int v12 = v16;
        int v13 = (unsigned char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }
      else
      {
        unsigned int v12 = *v11;
        int v13 = v11 + 1;
        *((void *)this + 1) = v13;
      }
      a1[2] = v12;
      a1[5] |= 1u;
      if ((unint64_t)v13 < v9 && *v13 == 16)
      {
        int v10 = v13 + 1;
        *((void *)this + 1) = v10;
LABEL_24:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v5 = *v10;
          uint64_t v14 = (unsigned __int8 *)(v10 + 1);
          *((void *)this + 1) = v14;
        }
        a1[5] |= 2u;
        if (v14 == (unsigned __int8 *)v9 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_100FE609C(uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100FE6108(uint64_t a1, unsigned int a2)
{
  char v3 = *(unsigned char *)(a1 + 20);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v4 = 11;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }
      else if (v5 >= 0x80)
      {
        uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v4 = 2;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }
    }
    else
    {
      uint64_t v4 = 0;
      if ((*(unsigned char *)(a1 + 20) & 2) == 0) {
        goto LABEL_17;
      }
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if (v6 >= 0x80) {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    }
    else {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }
  else
  {
    uint64_t v4 = 0;
  }
LABEL_17:
  *(_DWORD *)(a1 + 16) = v4;
  return v4;
}

void sub_100FE61A8(_DWORD *a1, void *lpsrc)
{
  sub_100FE5D58(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE6230()
{
  return 1;
}

void *sub_100FE6238@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfo.LtlRacPmicAdcPreCalData");
}

void sub_100FE6248(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }
  int v4 = *(_DWORD *)(a2 + 56);
  if (!(_BYTE)v4) {
    goto LABEL_13;
  }
  if (v4)
  {
    int v7 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 56) |= 1u;
    *(_DWORD *)(a1 + 8) = v7;
    int v4 = *(_DWORD *)(a2 + 56);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 56) |= 2u;
  *(_DWORD *)(a1 + 12) = v8;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_22;
  }
LABEL_21:
  int v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 56) |= 4u;
  *(_DWORD *)(a1 + 16) = v9;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_23;
  }
LABEL_22:
  int v10 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 56) |= 8u;
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v10;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_24:
    int v12 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 56) |= 0x20u;
    *(_DWORD *)(a1 + 28) = v12;
    int v4 = *(_DWORD *)(a2 + 56);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    goto LABEL_25;
  }
LABEL_23:
  int v11 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 56) |= 0x10u;
  *(_DWORD *)(a1 + 24) = v11;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 0x20) != 0) {
    goto LABEL_24;
  }
LABEL_10:
  if ((v4 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_25:
  char v13 = *(unsigned char *)(a2 + 32);
  *(_DWORD *)(a1 + 56) |= 0x40u;
  *(unsigned char *)(a1 + 32) = v13;
  int v4 = *(_DWORD *)(a2 + 56);
  if ((v4 & 0x80) != 0)
  {
LABEL_12:
    int v5 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 56) |= 0x80u;
    *(_DWORD *)(a1 + 36) = v5;
    int v4 = *(_DWORD *)(a2 + 56);
  }
LABEL_13:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) != 0)
  {
    int v14 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 56) |= 0x100u;
    *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = v14;
    int v4 = *(_DWORD *)(a2 + 56);
    if ((v4 & 0x200) == 0)
    {
LABEL_16:
      if ((v4 & 0x400) == 0) {
        return;
      }
      goto LABEL_17;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_16;
  }
  int v15 = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 56) |= 0x200u;
  *(_DWORD *)(a1 + 44) = v15;
  if ((*(_DWORD *)(a2 + 56) & 0x400) == 0) {
    return;
  }
LABEL_17:
  int v6 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 56) |= 0x400u;
  *(_DWORD *)(a1 + 48) = v6;
}

void sub_100FE6428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100FE6440(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309C30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE6460(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309C30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE64B4()
{
}

uint64_t sub_100FE6510(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 56);
  if ((_BYTE)v1)
  {
    *(_DWORD *)(result + 36) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)(result + 8) = 0;
    *(unsigned char *)(result + 32) = 0;
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(result + 4sub_100FB8FC8(&a9, 0) = 0;
    *(_DWORD *)(result + 48) = 0;
  }
  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t sub_100FE6544(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unsigned int *)(a1 + 40);
  int v6 = (unsigned int *)(a1 + 44);
  int v7 = (unsigned int *)(a1 + 48);
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v8;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        unsigned int v43 = 0;
        int v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          unsigned int v13 = *v12;
          int v14 = v12 + 1;
          *((void *)this + 1) = v14;
LABEL_38:
          *(_DWORD *)(a1 + 8) = v13;
          *(_DWORD *)(a1 + 56) |= 1u;
          if ((unint64_t)v14 < v11 && *v14 == 16)
          {
            int v15 = v14 + 1;
            *((void *)this + 1) = v15;
            goto LABEL_41;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
        if (result)
        {
          unsigned int v13 = v43;
          int v14 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          goto LABEL_38;
        }
        break;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_41:
        unsigned int v43 = 0;
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v25 = v43;
          int v26 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v25 = *v15;
          int v26 = v15 + 1;
          *((void *)this + 1) = v26;
        }
        *(_DWORD *)(a1 + 12) = v25;
        *(_DWORD *)(a1 + 56) |= 2u;
        if ((unint64_t)v26 >= v11 || *v26 != 24) {
          continue;
        }
        unsigned int v16 = v26 + 1;
        *((void *)this + 1) = v16;
LABEL_49:
        unsigned int v43 = 0;
        if ((unint64_t)v16 >= v11 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v27 = v43;
          unsigned int v28 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v27 = *v16;
          unsigned int v28 = v16 + 1;
          *((void *)this + 1) = v28;
        }
        *(_DWORD *)(a1 + 16) = v27;
        *(_DWORD *)(a1 + 56) |= 4u;
        if ((unint64_t)v28 >= v11 || *v28 != 32) {
          continue;
        }
        int v17 = v28 + 1;
        *((void *)this + 1) = v17;
LABEL_57:
        unsigned int v43 = 0;
        if ((unint64_t)v17 >= v11 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v29 = v43;
          uint64_t v30 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v29 = *v17;
          uint64_t v30 = v17 + 1;
          *((void *)this + 1) = v30;
        }
        *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v29;
        *(_DWORD *)(a1 + 56) |= 8u;
        if ((unint64_t)v30 >= v11 || *v30 != 40) {
          continue;
        }
        uint64_t v18 = v30 + 1;
        *((void *)this + 1) = v18;
LABEL_65:
        unsigned int v43 = 0;
        if ((unint64_t)v18 >= v11 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v31 = v43;
          unsigned int v32 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v31 = *v18;
          unsigned int v32 = v18 + 1;
          *((void *)this + 1) = v32;
        }
        *(_DWORD *)(a1 + 24) = v31;
        *(_DWORD *)(a1 + 56) |= 0x10u;
        if ((unint64_t)v32 >= v11 || *v32 != 48) {
          continue;
        }
        int v19 = v32 + 1;
        *((void *)this + 1) = v19;
LABEL_73:
        unsigned int v43 = 0;
        if ((unint64_t)v19 >= v11 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v33 = v43;
          int v34 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v33 = *v19;
          int v34 = v19 + 1;
          *((void *)this + 1) = v34;
        }
        *(_DWORD *)(a1 + 28) = v33;
        *(_DWORD *)(a1 + 56) |= 0x20u;
        if ((unint64_t)v34 >= v11 || *v34 != 56) {
          continue;
        }
        int v20 = v34 + 1;
        *((void *)this + 1) = v20;
LABEL_81:
        unsigned int v43 = 0;
        if ((unint64_t)v20 >= v11 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v35 = v43;
          int v36 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v35 = *v20;
          int v36 = v20 + 1;
          *((void *)this + 1) = v36;
        }
        *(unsigned char *)(a1 + 32) = v35 != 0;
        *(_DWORD *)(a1 + 56) |= 0x40u;
        if ((unint64_t)v36 >= v11 || *v36 != 64) {
          continue;
        }
        unsigned int v21 = v36 + 1;
        *((void *)this + 1) = v21;
LABEL_89:
        unsigned int v43 = 0;
        if ((unint64_t)v21 >= v11 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!result) {
            return result;
          }
          unsigned int v37 = v43;
          int v38 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int v37 = *v21;
          int v38 = v21 + 1;
          *((void *)this + 1) = v38;
        }
        *(_DWORD *)(a1 + 36) = v37;
        *(_DWORD *)(a1 + 56) |= 0x80u;
        if ((unint64_t)v38 >= v11 || *v38 != 72) {
          continue;
        }
        unint64_t v22 = v38 + 1;
        *((void *)this + 1) = v22;
LABEL_97:
        if ((unint64_t)v22 >= v11 || *v22 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!result) {
            return result;
          }
          unsigned int v39 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v5 = *v22;
          unsigned int v39 = v22 + 1;
          *((void *)this + 1) = v39;
        }
        *(_DWORD *)(a1 + 56) |= 0x100u;
        if ((unint64_t)v39 >= v11 || *v39 != 80) {
          continue;
        }
        unsigned int v23 = v39 + 1;
        *((void *)this + 1) = v23;
LABEL_105:
        if ((unint64_t)v23 >= v11 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!result) {
            return result;
          }
          uint64_t v40 = (unsigned char *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          *int v6 = *v23;
          uint64_t v40 = v23 + 1;
          *((void *)this + 1) = v40;
        }
        *(_DWORD *)(a1 + 56) |= 0x200u;
        if ((unint64_t)v40 >= v11 || *v40 != 88) {
          continue;
        }
        int v24 = v40 + 1;
        *((void *)this + 1) = v24;
LABEL_113:
        if ((unint64_t)v24 >= v11 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!result) {
            return result;
          }
          unsigned int v41 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }
        else
        {
          unsigned int *v7 = *v24;
          unsigned int v41 = (unsigned __int8 *)(v24 + 1);
          *((void *)this + 1) = v41;
        }
        *(_DWORD *)(a1 + 56) |= 0x400u;
        if (v41 != (unsigned __int8 *)v11 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        unsigned int v16 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_49;
      case 4u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v17 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_57;
      case 5u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_65;
      case 6u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v19 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_73;
      case 7u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v20 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_81;
      case 8u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        unsigned int v21 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_89;
      case 9u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        unint64_t v22 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_97;
      case 0xAu:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        unsigned int v23 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_105;
      case 0xBu:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_32;
        }
        int v24 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_113;
      default:
        int v10 = TagFallback & 7;
LABEL_32:
        if (v10 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FE6B7C(uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 56);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 56);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_15;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_16;
  }
LABEL_15:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 16), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_17;
  }
LABEL_16:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(_DWORD *)(v5 + 20), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
LABEL_17:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 24), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_19;
  }
LABEL_18:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(v5 + 28), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }
LABEL_19:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(unsigned __int8 *)(v5 + 32), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(_DWORD *)(v5 + 36), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
LABEL_22:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(_DWORD *)(v5 + 44), a2, a4);
    if ((*(_DWORD *)(v5 + 56) & 0x400) == 0) {
      return result;
    }
    goto LABEL_23;
  }
LABEL_21:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(_DWORD *)(v5 + 40), a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x200) != 0) {
    goto LABEL_22;
  }
LABEL_11:
  if ((v6 & 0x400) == 0) {
    return result;
  }
LABEL_23:
  int v7 = *(_DWORD *)(v5 + 48);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v7, a2, a4);
}

uint64_t sub_100FE6CE8(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[14];
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_57;
  }
  if ((v3 & 1) == 0)
  {
    LODWORD(v4) = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[2];
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 10;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = a1[14];
  }
  else
  {
    int v6 = 1;
  }
  LODWORD(v4) = v6 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_12:
    int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[3];
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }
    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = a1[14];
    }
    else
    {
      int v8 = 1;
    }
    LODWORD(v4) = v4 + v8 + 1;
  }
LABEL_18:
  if ((v3 & 4) != 0)
  {
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[4];
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 10;
    }
    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
      unsigned int v3 = a1[14];
    }
    else
    {
      int v10 = 1;
    }
    LODWORD(v4) = v4 + v10 + 1;
    if ((v3 & 8) == 0)
    {
LABEL_20:
      if ((v3 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_35;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_20;
  }
  unint64_t v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[5];
  if ((v11 & 0x80000000) != 0)
  {
    int v12 = 11;
  }
  else if (v11 >= 0x80)
  {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2) + 1;
    unsigned int v3 = a1[14];
  }
  else
  {
    int v12 = 2;
  }
  LODWORD(v4) = v12 + v4;
  if ((v3 & 0x10) == 0)
  {
LABEL_21:
    if ((v3 & 0x20) == 0) {
      goto LABEL_47;
    }
    goto LABEL_41;
  }
LABEL_35:
  unsigned int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[6];
  if ((v13 & 0x80000000) != 0)
  {
    int v14 = 11;
  }
  else if (v13 >= 0x80)
  {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2) + 1;
    unsigned int v3 = a1[14];
  }
  else
  {
    int v14 = 2;
  }
  LODWORD(v4) = v14 + v4;
  if ((v3 & 0x20) != 0)
  {
LABEL_41:
    int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[7];
    if ((v15 & 0x80000000) != 0)
    {
      int v16 = 11;
    }
    else if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2) + 1;
      unsigned int v3 = a1[14];
    }
    else
    {
      int v16 = 2;
    }
    LODWORD(v4) = v16 + v4;
  }
LABEL_47:
  if ((v3 & 0x40) != 0) {
    uint64_t v4 = (v4 + 2);
  }
  else {
    uint64_t v4 = v4;
  }
  if ((v3 & 0x80) != 0)
  {
    int v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[9];
    if ((v17 & 0x80000000) != 0)
    {
      int v18 = 11;
    }
    else if (v17 >= 0x80)
    {
      int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2) + 1;
      unsigned int v3 = a1[14];
    }
    else
    {
      int v18 = 2;
    }
    uint64_t v4 = (v18 + v4);
  }
LABEL_57:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_74;
  }
  if ((v3 & 0x100) != 0)
  {
    int v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[10];
    if (v19 >= 0x80)
    {
      int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19, a2) + 1;
      unsigned int v3 = a1[14];
    }
    else
    {
      int v20 = 2;
    }
    uint64_t v4 = (v20 + v4);
    if ((v3 & 0x200) == 0)
    {
LABEL_60:
      if ((v3 & 0x400) == 0) {
        goto LABEL_74;
      }
      goto LABEL_70;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_60;
  }
  unsigned int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[11];
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2) + 1;
    unsigned int v3 = a1[14];
  }
  else
  {
    int v22 = 2;
  }
  uint64_t v4 = (v22 + v4);
  if ((v3 & 0x400) != 0)
  {
LABEL_70:
    unsigned int v23 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[12];
    if (v23 >= 0x80) {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v23, a2) + 1;
    }
    else {
      int v24 = 2;
    }
    uint64_t v4 = (v24 + v4);
  }
LABEL_74:
  a1[13] = v4;
  return v4;
}

void sub_100FE6F3C(uint64_t a1, void *lpsrc)
{
  sub_100FE6248(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE6FC4()
{
  return 1;
}

void *sub_100FE6FCC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfo.LtlInitialParams");
}

void *sub_100FE6FDC(void *result)
{
  if ((void *)qword_10248B0E0 != result)
  {
    int v1 = result;
    uint64_t v2 = result[2];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[3];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[4];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t result = (void *)v1[5];
    if (result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v5();
    }
  }
  return result;
}

void sub_100FE70D4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309CA8;
  sub_100FE6FDC(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE7128(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309CA8;
  sub_100FE6FDC(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE7190()
{
}

uint64_t sub_100FE71EC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 < *((void *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_6;
    }
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v55 = 0;
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!result) {
            return result;
          }
          unsigned int v10 = v55;
          unint64_t v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v10 = *v9;
          unint64_t v11 = v9 + 1;
          *((void *)this + 1) = v11;
        }
        *(unsigned char *)(a1 + 8) = v10 != 0;
        *(_DWORD *)(a1 + 56) |= 1u;
        if ((unint64_t)v11 < v8 && *v11 == 16)
        {
          int v12 = v11 + 1;
          *((void *)this + 1) = v12;
          goto LABEL_31;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        int v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_31:
        unsigned int v55 = 0;
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!result) {
            return result;
          }
          unsigned int v15 = v55;
          int v16 = (unsigned char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v15 = *v12;
          int v16 = v12 + 1;
          *((void *)this + 1) = v16;
        }
        *(_DWORD *)(a1 + 12) = v15;
        *(_DWORD *)(a1 + 56) |= 2u;
        if ((unint64_t)v16 >= v8 || *v16 != 24) {
          continue;
        }
        unsigned int v13 = v16 + 1;
        *((void *)this + 1) = v13;
LABEL_39:
        unsigned int v55 = 0;
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!result) {
            return result;
          }
          unsigned int v17 = v55;
        }
        else
        {
          unsigned int v17 = *v13;
          *((void *)this + 1) = v13 + 1;
        }
        if (v17 <= 4)
        {
          *(_DWORD *)(a1 + 56) |= 4u;
          *(_DWORD *)(a1 + 48) = v17;
        }
        int v18 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v18 >= *((void *)this + 2) || *v18 != 34) {
          continue;
        }
        *((void *)this + 1) = v18 + 1;
LABEL_49:
        *(_DWORD *)(a1 + 56) |= 8u;
        uint64_t v19 = *(void *)(a1 + 16);
        if (!v19) {
          operator new();
        }
        unsigned int v55 = 0;
        int v20 = (char *)*((void *)this + 1);
        if ((unint64_t)v20 >= *((void *)this + 2) || *v20 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55))return 0; {
        }
          }
        else
        {
          unsigned int v55 = *v20;
          *((void *)this + 1) = v20 + 1;
        }
        int v21 = *((_DWORD *)this + 14);
        int v22 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v21 + 1;
        if (v21 >= v22) {
          return 0;
        }
        int v23 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        if (!sub_100FE6544(v19, this, v24) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v23);
        int v25 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v25, 1);
        int v27 = v25 - 1;
        if (v27 < 0 == v26) {
          *((_DWORD *)this + 14) = v27;
        }
        unsigned int v28 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v28 >= *((void *)this + 2) || *v28 != 42) {
          continue;
        }
        *((void *)this + 1) = v28 + 1;
LABEL_63:
        *(_DWORD *)(a1 + 56) |= 0x10u;
        uint64_t v29 = *(void *)(a1 + 24);
        if (!v29) {
          operator new();
        }
        unsigned int v55 = 0;
        uint64_t v30 = (char *)*((void *)this + 1);
        if ((unint64_t)v30 >= *((void *)this + 2) || *v30 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55))return 0; {
        }
          }
        else
        {
          unsigned int v55 = *v30;
          *((void *)this + 1) = v30 + 1;
        }
        int v31 = *((_DWORD *)this + 14);
        int v32 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v31 + 1;
        if (v31 >= v32) {
          return 0;
        }
        int v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        if (!sub_100FE4D70(v29, this, v34) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v33);
        int v35 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v35, 1);
        int v36 = v35 - 1;
        if (v36 < 0 == v26) {
          *((_DWORD *)this + 14) = v36;
        }
        unsigned int v37 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v37 >= *((void *)this + 2) || *v37 != 50) {
          continue;
        }
        *((void *)this + 1) = v37 + 1;
LABEL_77:
        *(_DWORD *)(a1 + 56) |= 0x20u;
        uint64_t v38 = *(void *)(a1 + 32);
        if (!v38) {
          operator new();
        }
        unsigned int v55 = 0;
        unsigned int v39 = (char *)*((void *)this + 1);
        if ((unint64_t)v39 >= *((void *)this + 2) || *v39 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55))return 0; {
        }
          }
        else
        {
          unsigned int v55 = *v39;
          *((void *)this + 1) = v39 + 1;
        }
        int v40 = *((_DWORD *)this + 14);
        int v41 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v40 + 1;
        if (v40 >= v41) {
          return 0;
        }
        int v42 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        if (!sub_100FE578C(v38, this, v43) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v42);
        int v44 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v44, 1);
        int v45 = v44 - 1;
        if (v45 < 0 == v26) {
          *((_DWORD *)this + 14) = v45;
        }
        int v46 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v46 >= *((void *)this + 2) || *v46 != 58) {
          continue;
        }
        *((void *)this + 1) = v46 + 1;
LABEL_91:
        *(_DWORD *)(a1 + 56) |= 0x40u;
        int v47 = *(_DWORD **)(a1 + 40);
        if (!v47) {
          operator new();
        }
        unsigned int v55 = 0;
        int v48 = (char *)*((void *)this + 1);
        if ((unint64_t)v48 >= *((void *)this + 2) || *v48 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55))return 0; {
        }
          }
        else
        {
          unsigned int v55 = *v48;
          *((void *)this + 1) = v48 + 1;
        }
        int v49 = *((_DWORD *)this + 14);
        int v50 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v49 + 1;
        if (v49 >= v50) {
          return 0;
        }
        int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        if (!sub_100FE5EF0(v47, this, v52) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v51);
        int v53 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v53, 1);
        int v54 = v53 - 1;
        if (v54 < 0 == v26) {
          *((_DWORD *)this + 14) = v54;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
        break;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_39;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_49;
        }
        goto LABEL_23;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_63;
        }
        goto LABEL_23;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_77;
        }
        goto LABEL_23;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_23;
        }
        goto LABEL_91;
      default:
        int v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_100FE78E0(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 56);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), (BOOL)a2, a4);
    int v6 = *(_DWORD *)(v5 + 56);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 48), (int)a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v7 = *(void *)(v5 + 16);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_10248B0E0 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
LABEL_15:
  uint64_t v8 = *(void *)(v5 + 24);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_10248B0E0 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      return result;
    }
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v9 = *(void *)(v5 + 32);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_10248B0E0 + 32);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  if ((*(_DWORD *)(v5 + 56) & 0x40) != 0)
  {
LABEL_21:
    uint64_t v10 = *(void *)(v5 + 40);
    if (!v10) {
      uint64_t v10 = *(void *)(qword_10248B0E0 + 40);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v10, a2, a4);
  }
  return result;
}

uint64_t sub_100FE7A1C(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 56);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_46;
  }
  uint64_t v4 = 2 * (v3 & 1u);
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v5 & 0x80000000) != 0)
    {
      int v6 = 11;
    }
    else if (v5 >= 0x80)
    {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 56);
    }
    else
    {
      int v6 = 2;
    }
    uint64_t v4 = (v6 + v4);
    if ((v3 & 4) == 0)
    {
LABEL_4:
      if ((v3 & 8) == 0) {
        goto LABEL_5;
      }
      goto LABEL_22;
    }
  }
  else if ((v3 & 4) == 0)
  {
    goto LABEL_4;
  }
  uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 48);
  if ((v7 & 0x80000000) != 0)
  {
    int v8 = 11;
  }
  else if (v7 >= 0x80)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 56);
  }
  else
  {
    int v8 = 2;
  }
  uint64_t v4 = (v8 + v4);
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_28;
  }
LABEL_22:
  uint64_t v9 = *(unsigned int **)(a1 + 16);
  if (!v9) {
    uint64_t v9 = *(unsigned int **)(qword_10248B0E0 + 16);
  }
  uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE6CE8(v9, a2);
  int v11 = (int)v10;
  if (v10 >= 0x80) {
    int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
  }
  else {
    int v12 = 1;
  }
  uint64_t v4 = (v4 + v11 + v12 + 1);
  int v3 = *(_DWORD *)(a1 + 56);
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_34;
  }
LABEL_28:
  uint64_t v13 = *(void *)(a1 + 24);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_10248B0E0 + 24);
  }
  int v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE5378(v13, a2);
  int v15 = (int)v14;
  if (v14 >= 0x80) {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14, a2);
  }
  else {
    int v16 = 1;
  }
  uint64_t v4 = (v4 + v15 + v16 + 1);
  int v3 = *(_DWORD *)(a1 + 56);
  if ((v3 & 0x20) == 0)
  {
LABEL_7:
    if ((v3 & 0x40) == 0) {
      goto LABEL_46;
    }
    goto LABEL_40;
  }
LABEL_34:
  uint64_t v17 = *(void *)(a1 + 32);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_10248B0E0 + 32);
  }
  int v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE5BC0(v17, a2);
  int v19 = (int)v18;
  if (v18 >= 0x80) {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v18, a2);
  }
  else {
    int v20 = 1;
  }
  uint64_t v4 = (v4 + v19 + v20 + 1);
  if ((*(_DWORD *)(a1 + 56) & 0x40) != 0)
  {
LABEL_40:
    uint64_t v21 = *(void *)(a1 + 40);
    if (!v21) {
      uint64_t v21 = *(void *)(qword_10248B0E0 + 40);
    }
    int v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FE6108(v21, a2);
    int v24 = (int)v22;
    if (v22 >= 0x80) {
      int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, v23);
    }
    else {
      int v25 = 1;
    }
    uint64_t v4 = (v4 + v24 + v25 + 1);
  }
LABEL_46:
  *(_DWORD *)(a1 + 52) = v4;
  return v4;
}

void sub_100FE7C00(uint64_t a1, void *lpsrc)
{
  sub_100FD6870(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE7C88()
{
  return 1;
}

void *sub_100FE7C90@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LtlInfo");
}

void sub_100FE7CA0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309D20;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE7CC0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309D20;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE7D14()
{
}

uint64_t sub_100FE7D60(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v10 = 0;
      uint64_t v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!result) {
          return result;
        }
        unsigned int v8 = v10;
      }
      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }
      if (v8 <= 6)
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE7E80(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FE7E9C(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v4 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100FE7EF8(uint64_t a1, void *lpsrc)
{
  sub_100FD6C68(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE7F80()
{
  return 1;
}

void *sub_100FE7F88@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.CntinStatusMessage");
}

void sub_100FE7F98(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309D98;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE7FB8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309D98;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE800C()
{
}

uint64_t sub_100FE805C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v12 = 0;
      unsigned int v8 = (char *)*((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      if ((unint64_t)v8 >= v7 || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!result) {
          return result;
        }
        unsigned int v9 = v12;
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v7 = *((void *)this + 2);
      }
      else
      {
        unsigned int v9 = *v8;
        unsigned int v10 = (unsigned __int8 *)(v8 + 1);
        *((void *)this + 1) = v10;
      }
      *(unsigned char *)(a1 + 8) = v9 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if (v10 == (unsigned __int8 *)v7 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_100FE817C(uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_100FE8198(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16)) {
    uint64_t v1 = 2 * (*(_DWORD *)(a1 + 16) & 1u);
  }
  else {
    uint64_t v1 = 0;
  }
  *(_DWORD *)(a1 + 12) = v1;
  return v1;
}

void sub_100FE81B4(uint64_t a1, void *lpsrc)
{
  sub_100FDBA20(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE823C()
{
  return 1;
}

void *sub_100FE8244@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.CntinClockControl");
}

uint64_t sub_100FE8254(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_102309E10;
  *(_DWORD *)(a1 + 24) = 0;
  sub_100FDBAC4((_DWORD *)a1, a2);
  return a1;
}

void sub_100FE82A0(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_100FE82B8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309E10;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE82D8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309E10;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE832C()
{
}

uint64_t sub_100FE837C(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v5;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v22 = 0;
        int v11 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v11 >= v9 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v12 = v22;
          uint64_t v13 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unsigned int v12 = *v11;
          uint64_t v13 = v11 + 1;
          *((void *)this + 1) = v13;
        }
        a1[2] = v12;
        a1[6] |= 1u;
        if ((unint64_t)v13 < v9 && *v13 == 16)
        {
          int v14 = v13 + 1;
          *((void *)this + 1) = v14;
          goto LABEL_26;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_18;
      }
      int v14 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
LABEL_26:
      unsigned int v21 = 0;
      if ((unint64_t)v14 >= v9 || *v14 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v21);
        if (!result) {
          return result;
        }
        unsigned int v15 = v21;
        int v16 = (unsigned char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }
      else
      {
        unsigned int v15 = *v14;
        int v16 = v14 + 1;
        *((void *)this + 1) = v16;
      }
      a1[3] = v15;
      a1[6] |= 2u;
      if ((unint64_t)v16 < v9 && *v16 == 24)
      {
        unsigned int v10 = v16 + 1;
        *((void *)this + 1) = v10;
LABEL_34:
        unsigned int v20 = 0;
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v20);
          if (!result) {
            return result;
          }
          unsigned int v17 = v20;
          int v18 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unsigned int v17 = *v10;
          int v18 = (unsigned __int8 *)(v10 + 1);
          *((void *)this + 1) = v18;
        }
        a1[4] = v17;
        a1[6] |= 4u;
        if (v18 == (unsigned __int8 *)v9 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_18:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

int *sub_100FE85A4(int *result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = result[6];
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v5[3], a2, a4);
    if ((v5[6] & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, result[2], a2, a4);
  int v6 = v5[6];
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  int v7 = v5[4];

  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
}

uint64_t sub_100FE8630(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 24);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v4 = 11;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 24);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      goto LABEL_19;
    }
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 11;
  }
  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    int v7 = 2;
  }
  uint64_t v4 = (v7 + v4);
LABEL_19:
  if ((v3 & 4) != 0)
  {
    int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v8 & 0x80000000) != 0)
    {
      int v9 = 11;
    }
    else if (v8 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    }
    else
    {
      int v9 = 2;
    }
    uint64_t v4 = (v9 + v4);
  }
LABEL_26:
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v4;
  return v4;
}

void sub_100FE8710(_DWORD *a1, void *lpsrc)
{
  sub_100FDBAC4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE8798()
{
  return 1;
}

void *sub_100FE87A0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.Exception");
}

void sub_100FE87B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309E88;
  sub_100241350((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE8804(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309E88;
  sub_100241350((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE886C()
{
}

uint64_t sub_100FE88C4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v5 = (char *)*((void *)this + 1);
          if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
          {
            unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = TagFallback;
            if (!TagFallback) {
              return 1;
            }
          }
          else
          {
            unint64_t TagFallback = *v5;
            *((_DWORD *)this + 8) = TagFallback;
            *((void *)this + 1) = v5 + 1;
            if (!TagFallback) {
              return 1;
            }
          }
          unsigned int v7 = TagFallback >> 3;
          if (TagFallback >> 3 != 1) {
            break;
          }
          int v8 = TagFallback & 7;
          if (v8 != 1) {
            goto LABEL_22;
          }
          unint64_t v16 = 0;
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v16) & 1) == 0) {
            return 0;
          }
          *(void *)(a1 + 8) = v16;
          *(_DWORD *)(a1 + 36) |= 1u;
          int v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 < v10 && *v11 == 16)
          {
            unsigned int v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_18;
          }
        }
        if (v7 != 2) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unsigned int v12 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_18:
        unint64_t v16 = 0;
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, &v16);
          if (!result) {
            return result;
          }
          unint64_t v13 = v16;
          int v14 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unint64_t v13 = *v12;
          int v14 = v12 + 1;
          *((void *)this + 1) = v14;
        }
        *(void *)(a1 + 16) = v13;
        int v9 = *(_DWORD *)(a1 + 36) | 2;
        *(_DWORD *)(a1 + 36) = v9;
        if ((unint64_t)v14 < v10 && *v14 == 26)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_30;
        }
      }
      if (v7 != 3) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_22;
      }
      int v9 = *(_DWORD *)(a1 + 36);
LABEL_30:
      *(_DWORD *)(a1 + 36) = v9 | 4;
      if (*(_UNKNOWN **)(a1 + 24) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v8 = TagFallback & 7;
LABEL_22:
    if (v8 == 4) {
      return 1;
    }
  }
  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) != 0);
  return 0;
}

uint64_t sub_100FE8AE0(uint64_t result, uint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 16), a2, a4);
    if ((*(_DWORD *)(v5 + 36) & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, a2, *(double *)(result + 8), a3);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t sub_100FE8B6C(uint64_t a1, unint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 36);
  if (*(unsigned char *)(a1 + 36))
  {
    uint64_t v4 = (v3 << 31 >> 31) & 9;
    if ((v3 & 2) != 0)
    {
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16), a2)+ 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }
    if ((v3 & 4) != 0)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      char v7 = v6;
      uint64_t v8 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
      }
      else {
        unint64_t v9 = v8;
      }
      if (v9 >= 0x80)
      {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
        int v6 = *(unsigned __int8 *)(v5 + 23);
        uint64_t v8 = *(void *)(v5 + 8);
        char v7 = *(unsigned char *)(v5 + 23);
      }
      else
      {
        int v10 = 1;
      }
      if (v7 < 0) {
        int v6 = v8;
      }
      uint64_t v4 = (v4 + v10 + v6 + 1);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

void sub_100FE8C24(uint64_t a1, void *lpsrc)
{
  sub_100FDBBB0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE8CAC()
{
  return 1;
}

void *sub_100FE8CB4@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.AskBasebandReset");
}

void sub_100FE8CC4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 52);
  if (!(_BYTE)v4) {
    return;
  }
  if (*(unsigned char *)(a2 + 52))
  {
    uint64_t v5 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 52) |= 1u;
    *(void *)(a1 + 8) = v5;
    int v4 = *(_DWORD *)(a2 + 52);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
LABEL_14:
      *(_DWORD *)(a1 + 52) |= 4u;
      uint64_t v8 = *(void *)(a1 + 24);
      if (!v8) {
        operator new();
      }
      uint64_t v9 = *(void *)(a2 + 24);
      if (!v9) {
        uint64_t v9 = *(void *)(qword_10248B128 + 24);
      }
      sub_100FCD9F4(v8, v9);
      int v4 = *(_DWORD *)(a2 + 52);
      if ((v4 & 8) == 0)
      {
LABEL_8:
        if ((v4 & 0x10) == 0) {
          return;
        }
        goto LABEL_24;
      }
      goto LABEL_19;
    }
  }
  else if ((*(unsigned char *)(a2 + 52) & 2) == 0)
  {
    goto LABEL_6;
  }
  int v6 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 52) |= 2u;
  char v7 = *(std::string **)(a1 + 16);
  if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v7, v6);
  int v4 = *(_DWORD *)(a2 + 52);
  if ((v4 & 4) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((v4 & 8) == 0) {
    goto LABEL_8;
  }
LABEL_19:
  *(_DWORD *)(a1 + 52) |= 8u;
  uint64_t v10 = *(void *)(a1 + 32);
  if (!v10) {
    operator new();
  }
  uint64_t v11 = *(void *)(a2 + 32);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_10248B128 + 32);
  }
  sub_100FD6F24(v10, v11);
  if ((*(_DWORD *)(a2 + 52) & 0x10) != 0)
  {
LABEL_24:
    *(_DWORD *)(a1 + 52) |= 0x10u;
    uint64_t v12 = *(void *)(a1 + 40);
    if (!v12) {
      operator new();
    }
    uint64_t v13 = *(void *)(a2 + 40);
    if (!v13) {
      uint64_t v13 = *(void *)(qword_10248B128 + 40);
    }
    sub_100FD7544(v12, v13);
  }
}

void sub_100FE8FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void *sub_100FE8FF0(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[2];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  if ((void *)qword_10248B128 != result)
  {
    uint64_t v4 = result[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t result = (void *)v1[5];
    if (result)
    {
      int v6 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v6();
    }
  }
  return result;
}

void sub_100FE90FC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309F00;
  sub_100FE8FF0(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE9150(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309F00;
  sub_100FE8FF0(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

uint64_t sub_100FE91B8(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_10248B128;
  if (!qword_10248B128)
  {
    sub_100FCBE50(0, a2, a3, a4);
    return qword_10248B128;
  }
  return result;
}

void sub_100FE91E8()
{
}

uint64_t sub_100FE9244(uint64_t result)
{
  uint64_t v1 = result;
  char v2 = *(unsigned char *)(result + 52);
  if (v2)
  {
    *(void *)(result + 8) = 0;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(result + 16);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    int v4 = *(_DWORD *)(result + 52);
    if ((v4 & 4) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result)
      {
        uint64_t result = sub_100FCF7D8(result);
        int v4 = *(_DWORD *)(v1 + 52);
      }
    }
    if ((v4 & 8) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 32);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 28))
        {
          *(void *)(v5 + 8) = 0;
          *(void *)(v5 + 16) = 0;
        }
        *(_DWORD *)(v5 + 28) = 0;
        int v4 = *(_DWORD *)(v1 + 52);
      }
    }
    if ((v4 & 0x10) != 0)
    {
      uint64_t result = *(void *)(v1 + 40);
      if (result) {
        uint64_t result = sub_100FD8664(result);
      }
    }
  }
  *(_DWORD *)(v1 + 52) = 0;
  return result;
}

uint64_t sub_100FE92F4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 < *((void *)this + 2) && (*v6 & 0x80000000) == 0)
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_7;
    }
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        uint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          uint64_t v11 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }
        int v12 = *(_DWORD *)(a1 + 52) | 1;
        *(_DWORD *)(a1 + 52) = v12;
        if ((unint64_t)v11 < v9 && *v11 == 18)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_28;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        int v12 = *(_DWORD *)(a1 + 52);
LABEL_28:
        *(_DWORD *)(a1 + 52) = v12 | 2;
        if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v14 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 != 42) {
          continue;
        }
        *((void *)this + 1) = v14 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 52) |= 4u;
        uint64_t v15 = *(void *)(a1 + 24);
        if (!v15) {
          operator new();
        }
        unsigned int v42 = 0;
        unint64_t v16 = (char *)*((void *)this + 1);
        if ((unint64_t)v16 >= *((void *)this + 2) || *v16 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v42))return 0; {
        }
          }
        else
        {
          unsigned int v42 = *v16;
          *((void *)this + 1) = v16 + 1;
        }
        int v17 = *((_DWORD *)this + 14);
        int v18 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v17 + 1;
        if (v17 >= v18) {
          return 0;
        }
        int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v42);
        if (!sub_100FD0260(v15, this, v20) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v19);
        int v21 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v21, 1);
        int v23 = v21 - 1;
        if (v23 < 0 == v22) {
          *((_DWORD *)this + 14) = v23;
        }
        int v24 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v24 >= *((void *)this + 2) || *v24 != 50) {
          continue;
        }
        *((void *)this + 1) = v24 + 1;
LABEL_48:
        *(_DWORD *)(a1 + 52) |= 8u;
        int v25 = *(_DWORD **)(a1 + 32);
        if (!v25) {
          operator new();
        }
        unsigned int v43 = 0;
        BOOL v26 = (char *)*((void *)this + 1);
        if ((unint64_t)v26 >= *((void *)this + 2) || *v26 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43))return 0; {
        }
          }
        else
        {
          unsigned int v43 = *v26;
          *((void *)this + 1) = v26 + 1;
        }
        int v27 = *((_DWORD *)this + 14);
        int v28 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v27 + 1;
        if (v27 >= v28) {
          return 0;
        }
        int v29 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v43);
        if (!sub_100FD7100(v25, this, v30) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v29);
        int v31 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v31, 1);
        int v32 = v31 - 1;
        if (v32 < 0 == v22) {
          *((_DWORD *)this + 14) = v32;
        }
        int v33 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v33 >= *((void *)this + 2) || *v33 != 58) {
          continue;
        }
        *((void *)this + 1) = v33 + 1;
LABEL_62:
        *(_DWORD *)(a1 + 52) |= 0x10u;
        uint64_t v34 = *(void *)(a1 + 40);
        if (!v34) {
          operator new();
        }
        unsigned int v44 = 0;
        int v35 = (char *)*((void *)this + 1);
        if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v44))return 0; {
        }
          }
        else
        {
          unsigned int v44 = *v35;
          *((void *)this + 1) = v35 + 1;
        }
        int v36 = *((_DWORD *)this + 14);
        int v37 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v36 + 1;
        if (v36 >= v37) {
          return 0;
        }
        int v38 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v44);
        if (!sub_100FD89C4(v34, this, v39) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v38);
        int v40 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v40, 1);
        int v41 = v40 - 1;
        if (v41 < 0 == v22) {
          *((_DWORD *)this + 14) = v41;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
        break;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_34;
        }
        goto LABEL_20;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_48;
        }
        goto LABEL_20;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        goto LABEL_62;
      default:
        int v8 = TagFallback & 7;
LABEL_20:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_100FE98E4(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(result + 8), (unint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 52);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 52);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_10248B128 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v7, a2, a4);
  int v6 = *(_DWORD *)(v5 + 52);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      return result;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v8 = *(void *)(v5 + 32);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_10248B128 + 32);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v8, a2, a4);
  if ((*(_DWORD *)(v5 + 52) & 0x10) != 0)
  {
LABEL_15:
    uint64_t v9 = *(void *)(v5 + 40);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_10248B128 + 40);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v9, a2, a4);
  }
  return result;
}

uint64_t sub_100FE99D8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 52);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_38;
  }
  if (*(unsigned char *)(a1 + 52))
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
    int v3 = *(_DWORD *)(a1 + 52);
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 52) & 2) == 0) {
      goto LABEL_16;
    }
  }
  uint64_t v5 = *(void *)(a1 + 16);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v3 = *(_DWORD *)(a1 + 52);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v4 + v10 + v6 + 1);
LABEL_16:
  if ((v3 & 4) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 24);
    if (!v11) {
      uint64_t v11 = *(void *)(qword_10248B128 + 24);
    }
    int v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FD4210(v11, a2);
    int v13 = (int)v12;
    if (v12 >= 0x80) {
      int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2);
    }
    else {
      int v14 = 1;
    }
    uint64_t v4 = (v4 + v13 + v14 + 1);
    int v3 = *(_DWORD *)(a1 + 52);
    if ((v3 & 8) == 0)
    {
LABEL_18:
      if ((v3 & 0x10) == 0) {
        goto LABEL_38;
      }
      goto LABEL_32;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_18;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  if (!v15) {
    uint64_t v15 = *(void *)(qword_10248B128 + 32);
  }
  unint64_t v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FD73E0(v15, a2);
  int v17 = (int)v16;
  if (v16 >= 0x80) {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, a2);
  }
  else {
    int v18 = 1;
  }
  uint64_t v4 = (v4 + v17 + v18 + 1);
  if ((*(_DWORD *)(a1 + 52) & 0x10) != 0)
  {
LABEL_32:
    uint64_t v19 = *(void *)(a1 + 40);
    if (!v19) {
      uint64_t v19 = *(void *)(qword_10248B128 + 40);
    }
    unsigned int v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FDAD58(v19, a2);
    int v22 = (int)v20;
    if (v20 >= 0x80) {
      int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20, v21);
    }
    else {
      int v23 = 1;
    }
    uint64_t v4 = (v4 + v22 + v23 + 1);
  }
LABEL_38:
  *(_DWORD *)(a1 + 48) = v4;
  return v4;
}

void sub_100FE9B70(uint64_t a1, void *lpsrc)
{
  sub_100FE8CC4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FE9BF8()
{
  return 1;
}

void *sub_100FE9C00@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.LogEntry");
}

void sub_100FE9C10(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309F78;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FE9C30(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_102309F78;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100FE9C84()
{
}

uint64_t sub_100FE9CD4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v24 = 0;
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 < v9 && (*v10 & 0x80000000) == 0)
        {
          unsigned int v11 = *v10;
          int v12 = v10 + 1;
          *((void *)this + 1) = v12;
LABEL_24:
          *(unsigned char *)(a1 + 16) = v11 != 0;
          *(_DWORD *)(a1 + 24) |= 1u;
          if ((unint64_t)v12 < v9 && *v12 == 16)
          {
            int v13 = v12 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_27;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
        if (result)
        {
          unsigned int v11 = v24;
          int v12 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
          goto LABEL_24;
        }
        break;
      case 2u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v13 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
LABEL_27:
        unsigned int v23 = 0;
        if ((unint64_t)v13 >= v9 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23);
          if (!result) {
            return result;
          }
          unsigned int v16 = v23;
          int v17 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unsigned int v16 = *v13;
          int v17 = v13 + 1;
          *((void *)this + 1) = v17;
        }
        *(unsigned char *)(a1 + 17) = v16 != 0;
        *(_DWORD *)(a1 + 24) |= 2u;
        if ((unint64_t)v17 >= v9 || *v17 != 24) {
          continue;
        }
        int v14 = v17 + 1;
        *((void *)this + 1) = v14;
LABEL_35:
        unsigned int v22 = 0;
        if ((unint64_t)v14 >= v9 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!result) {
            return result;
          }
          unsigned int v18 = v22;
          uint64_t v19 = (unsigned char *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unsigned int v18 = *v14;
          uint64_t v19 = v14 + 1;
          *((void *)this + 1) = v19;
        }
        *(unsigned char *)(a1 + 18) = v18 != 0;
        *(_DWORD *)(a1 + 24) |= 4u;
        if ((unint64_t)v19 >= v9 || *v19 != 32) {
          continue;
        }
        uint64_t v15 = v19 + 1;
        *((void *)this + 1) = v15;
LABEL_43:
        if ((unint64_t)v15 >= v9 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!result) {
            return result;
          }
          unsigned int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }
        else
        {
          unint64_t *v5 = *v15;
          unsigned int v20 = (unsigned __int8 *)(v15 + 1);
          *((void *)this + 1) = v20;
        }
        *(_DWORD *)(a1 + 24) |= 8u;
        if (v20 != (unsigned __int8 *)v9 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        uint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100FE9FB8(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(result + 16), a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 18), a2, a4);
      if ((*(_DWORD *)(v5 + 24) & 8) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 17), a2, a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return result;
  }
LABEL_9:
  uint64_t v7 = *(void *)(v5 + 8);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t sub_100FEA060(uint64_t a1, unint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  if ((_BYTE)v3)
  {
    unsigned int v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0) {
      v4 += 2;
    }
    if ((v3 & 4) != 0) {
      uint64_t v5 = v4 + 2;
    }
    else {
      uint64_t v5 = v4;
    }
    if ((v3 & 8) != 0) {
      uint64_t v5 = (v5 | 1)
    }
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2);
  }
  else
  {
    uint64_t v5 = 0;
  }
  *(_DWORD *)(a1 + 2sub_100FB8FC8(&a9, 0) = v5;
  return v5;
}

void sub_100FEA0CC(uint64_t a1, void *lpsrc)
{
  sub_100FD6B5C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FEA154()
{
  return 1;
}

void *sub_100FEA15C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "proto.gpsd.StartContext");
}

uint64_t sub_100FEA16C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 392);
}

uint64_t sub_100FEA174(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

void sub_100FEA17C()
{
}

void sub_100FEA1BC()
{
}

void sub_100FEA1E0()
{
}

void sub_100FEA220()
{
}

void sub_100FEA244()
{
}

void sub_100FEA284()
{
}

void sub_100FEA2A8()
{
}

void sub_100FEA5B0(id a1)
{
  qword_102419568 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

uint64_t sub_100FEA5E0(uint64_t a1)
{
  *(void *)a1 = &off_10230A430;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  if (objc_opt_class()) {
    *(void *)(a1 + 104) = objc_alloc_init((Class)HKHealthStore);
  }
  return a1;
}

void sub_100FEA65C(_Unwind_Exception *a1)
{
  sub_1000D80C4((void *)(v1 + 48));
  _Unwind_Resume(a1);
}

void *sub_100FEA674(void *a1)
{
  *a1 = &off_10230A430;
  char v2 = (void *)a1[13];
  if (v2)
  {

    a1[13] = 0;
  }
  sub_1000D80C4(a1 + 6);
  return a1;
}

void sub_100FEA6D4(void *a1)
{
  sub_100FEA674(a1);

  operator delete();
}

void sub_100FEA70C(int64x2_t *a1, __int32 a2, double a3, float a4)
{
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_10230A478);
  }
  int v8 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134284033;
    *(double *)&uint8_t buf[4] = a3;
    *(_WORD *)&unsigned char buf[12] = 2049;
    *(double *)&buf[14] = a4;
    *(_WORD *)&buf[22] = 1025;
    *(_DWORD *)&buf[24] = a2;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] aggregateWRMets - time: %{private}f, mets: %{private}f, activity: %{private}d", buf, 0x1Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    uint64_t v59 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v59);
    if (v59 != buf) {
      free(v59);
    }
  }
  if (*(double *)&a1[1].i64[1] > a3)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    unint64_t v9 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = a1[1].i64[0];
      uint64_t v10 = a1[1].i64[1];
      __int32 v12 = a1[2].i32[2];
      uint64_t v13 = a1->i64[1];
      *(_DWORD *)uint64_t buf = 134350081;
      *(double *)&uint8_t buf[4] = a3;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(void *)&buf[14] = v10;
      *(_WORD *)&buf[22] = 1025;
      *(_DWORD *)&buf[24] = v12;
      *(_WORD *)&unsigned char buf[28] = 2049;
      *(void *)&buf[30] = v13;
      *(_WORD *)&unsigned char buf[38] = 2049;
      *(void *)&buf[40] = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "[PhysicalEffort] Time went backwards (time=%{public}f,lastTime=%{public}f,type=%{private}d,sampleStart=%{private}f,sampleStop=%{private}f)", buf, 0x30u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      int v60 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v60);
      if (v60 != buf) {
        free(v60);
      }
    }
  }
  if (a4 <= 0.0 || a4 > 20.0)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    unsigned int v20 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      *(double *)&uint8_t buf[4] = a4;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid value for METs received: %{public}f", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      unsigned int v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v21);
      if (v21 != buf) {
        free(v21);
      }
    }
  }
  else
  {
    float v14 = fmaxf(a4, 1.0);
    double v15 = *(double *)&a1->i64[1];
    if (v15 <= 0.0)
    {
LABEL_40:
      *(double *)&a1[1].i64[1] = a3;
LABEL_41:
      *(double *)&a1->i64[1] = a3 + -2.56;
      *(double *)a1[1].i64 = a3;
      *(float *)a1[2].i32 = v14;
      *(float *)&a1[2].i32[1] = v14;
      a1[2].i32[2] = a2;
      a1[2].i32[3] = 0;
      return;
    }
    double v16 = *(double *)&a1[1].i64[1];
    if (v16 > 0.0)
    {
      if (vabdd_f64(a3, v16) > 11.52)
      {
        if (qword_102418FF0 != -1) {
          dispatch_once(&qword_102418FF0, &stru_10230A478);
        }
        int v17 = qword_102418FF8;
        if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_INFO))
        {
          uint64_t v18 = a1[1].i64[1];
          *(_DWORD *)uint64_t buf = 134349312;
          *(double *)&uint8_t buf[4] = a3;
          *(_WORD *)&unsigned char buf[12] = 2050;
          *(void *)&buf[14] = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "[PhysicalEffort] Unexpected jump in time between mets. Current time: %{public}f, last update time: %{public}f, ending sample", buf, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FF0 != -1) {
            dispatch_once(&qword_102418FF0, &stru_10230A478);
          }
          int v61 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v61);
          if (v61 != buf) {
            free(v61);
          }
        }
        int v19 = 1;
LABEL_39:
        a1[2].i32[3] = v19;
        sub_100FEB5C8((uint64_t)a1);
        (*(void (**)(int64x2_t *, void, double, double, float))(a1->i64[0] + 16))(a1, a1[2].u32[2], *(double *)&a1->i64[1], *(double *)a1[1].i64, (float)(int)(float)((float)(*(float *)a1[2].i32 * 10.0) + 0.5) / 10.0);
        a1->i64[1] = 0;
        a1[1].i64[0] = 0;
        a1[2].i64[0] = 0;
        a1[2].i64[1] = 0;
        a1[6].i64[0] = 0;
        goto LABEL_40;
      }
      if (v15 + dbl_101D9B710[*(float *)a1[2].i32 > 2.4] < a3)
      {
        if (qword_102418FF0 != -1) {
          dispatch_once(&qword_102418FF0, &stru_10230A478);
        }
        unsigned int v22 = qword_102418FF8;
        if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
        {
          __int32 v23 = a1[2].i32[2];
          double v24 = *(double *)&a1->i64[1];
          double v25 = *(double *)a1[1].i64 - v24;
          *(_DWORD *)uint64_t buf = 67175169;
          *(_DWORD *)&uint8_t buf[4] = v23;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v25;
          *(_WORD *)&unsigned char buf[18] = 2049;
          *(double *)&buf[20] = v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] max duration reached, ending sample with type %{private}d, length %{private}f (start: %{private}f)", buf, 0x1Cu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FF0 != -1) {
            dispatch_once(&qword_102418FF0, &stru_10230A478);
          }
          uint64_t v63 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v63);
          if (v63 != buf) {
            free(v63);
          }
        }
        int v19 = 2;
        goto LABEL_39;
      }
    }
    *(double *)&a1[1].i64[1] = a3;
    if (v15 <= 0.0) {
      goto LABEL_41;
    }
    BOOL v26 = (float *)&a1[2].i32[1];
    if (a1[2].i32[2] != a2) {
      goto LABEL_54;
    }
    BOOL v27 = 0;
    float v28 = *v26;
    float v29 = vabds_f32(*v26, v14);
    BOOL v30 = v14 < 2.4;
    if (*v26 >= 2.4) {
      BOOL v30 = 0;
    }
    if (v28 < 6.5 && a2 == 1 && v28 >= 2.4)
    {
      BOOL v27 = v14 >= 2.4;
      if (v14 >= 6.5) {
        BOOL v27 = 0;
      }
    }
    if (v29 < 0.2 || v30 || v27)
    {
      __int32 v56 = a1[6].i32[0];
      BOOL v57 = __OFSUB__(v56, 1);
      int v58 = v56 - 1;
      if (v58 < 0 != v57
        || (a1[6].i32[0] = v58, a1[6].i32[1] = 1, !v58) && (sub_100FEB5C8((uint64_t)a1), a1[6].i32[0] < 1))
      {
        sub_100FEB900((uint64_t)a1, 0, a3, v14);
        a1[6].i64[0] = 0;
      }
      else
      {
        *(double *)uint64_t buf = a3;
        *(void *)&uint8_t buf[8] = __PAIR64__(a2, LODWORD(v14));
        sub_100FEB874((int64x2_t *)a1[3].i64, (__n128 *)buf);
      }
    }
    else
    {
LABEL_54:
      uint64_t v31 = a1[5].i64[1];
      if (!v31) {
        goto LABEL_71;
      }
      unint64_t v32 = v31 + a1[5].i64[0] - 1;
      uint64_t v33 = *(void *)(a1[3].i64[1] + ((v32 >> 5) & 0x7FFFFFFFFFFFFF8));
      if (*(_DWORD *)(v33 + 16 * v32 + 12) != a2) {
        goto LABEL_71;
      }
      BOOL v34 = 0;
      float v35 = *(float *)(v33 + 16 * v32 + 8);
      float v36 = vabds_f32(v35, v14);
      BOOL v37 = v14 < 2.4;
      if (v35 >= 2.4) {
        BOOL v37 = 0;
      }
      if (v35 < 6.5 && a2 == 1 && v35 >= 2.4)
      {
        BOOL v34 = v14 >= 2.4;
        if (v14 >= 6.5) {
          BOOL v34 = 0;
        }
      }
      int v39 = v37 || v34;
      if (v36 < 0.2 || v39 != 0) {
        int v41 = a1[6].i32[1] + 1;
      }
      else {
LABEL_71:
      }
        int v41 = 1;
      a1[6].i32[1] = v41;
      ++a1[6].i32[0];
      *(double *)uint64_t buf = a3;
      *(void *)&uint8_t buf[8] = __PAIR64__(a2, LODWORD(v14));
      sub_100FEB874((int64x2_t *)a1[3].i64, (__n128 *)buf);
      if (a1[6].i32[0] > 3 || a1[6].i32[1] >= 3)
      {
        if (qword_102418FF0 != -1) {
          dispatch_once(&qword_102418FF0, &stru_10230A478);
        }
        unsigned int v42 = qword_102418FF8;
        if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
        {
          __int32 v43 = a1[2].i32[2];
          double v44 = *(double *)&a1->i64[1];
          double v45 = *(double *)a1[1].i64 - v44;
          *(_DWORD *)uint64_t buf = 67175169;
          *(_DWORD *)&uint8_t buf[4] = v43;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v45;
          *(_WORD *)&unsigned char buf[18] = 2049;
          *(double *)&buf[20] = v44;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] outliers flagged. ending sample with type %{private}d, length %{private}f (start: %{private}f)", buf, 0x1Cu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102418FF0 != -1) {
            dispatch_once(&qword_102418FF0, &stru_10230A478);
          }
          int v62 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)", "%s\n", v62);
          if (v62 != buf) {
            free(v62);
          }
        }
        unint64_t v46 = a1[6].u32[1];
        if ((int)v46 < 2) {
          goto LABEL_84;
        }
        for (; a1[5].i64[1] > v46; unint64_t v46 = a1[6].i32[1])
        {
          uint64_t v47 = *(void *)(a1[3].i64[1] + (((unint64_t)a1[5].i64[0] >> 5) & 0x7FFFFFFFFFFFFF8))
              + 16 * a1[5].i64[0];
          sub_100FEB900((uint64_t)a1, 0, *(double *)v47, *(float *)(v47 + 8));
          a1[5] = vaddq_s64(a1[5], (int64x2_t)xmmword_101D0A740);
          sub_100096314((uint64_t)a1[3].i64, 1);
        }
        if ((int)v46 <= 2) {
LABEL_84:
        }
          int v48 = 4;
        else {
          int v48 = 3;
        }
        a1[2].i32[3] = v48;
        (*(void (**)(int64x2_t *, void, double, double, float))(a1->i64[0] + 16))(a1, a1[2].u32[2], *(double *)&a1->i64[1], *(double *)a1[1].i64, (float)(int)(float)((float)(*(float *)a1[2].i32 * 10.0) + 0.5) / 10.0);
        uint64_t v49 = a1[3].i64[1];
        unint64_t v50 = a1[5].u64[0];
        uint64_t v51 = a1[5].i64[1];
        double v52 = *(double *)(*(void *)(v49 + ((v50 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v50);
        LODWORD(v49) = *(_DWORD *)(*(void *)(v49 + (((v50 + v51 - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                                 + 16 * (v50 + v51 - 1)
                                 + 12);
        double v53 = v52 + -2.56;
        *(double *)&a1->i64[1] = v53;
        *(double *)a1[1].i64 = v53;
        a1[2].i64[0] = 0;
        a1[2].i32[2] = v49;
        a1[2].i32[3] = 0;
        *(void *)uint64_t buf = off_1022C3DA0;
        *(_DWORD *)&uint8_t buf[8] = v51;
        memset(&buf[16], 0, 48);
        v66[0] = 0;
        v66[1] = 0;
        char v65 = v66;
        while (a1[5].i64[1])
        {
          unint64_t v54 = a1[5].u64[0];
          uint64_t v55 = *(void *)(a1[3].i64[1] + ((v54 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v54;
          sub_100FEB900((uint64_t)a1, 0, *(double *)v55, *(float *)(v55 + 8));
          sub_1006B4700((uint64_t)buf, (float *)(v55 + 8));
          a1[5] = vaddq_s64(a1[5], (int64x2_t)xmmword_101D0A740);
          sub_100096314((uint64_t)a1[3].i64, 1);
        }
        sub_100A6E134(buf, 2, &a1[2].i32[1]);
        a1[6].i64[0] = 0;
        *(void *)uint64_t buf = off_1022C3DA0;
        sub_1000F5BB0((uint64_t)&v65, v66[0]);
        sub_10041F48C(&buf[16]);
      }
    }
  }
}

void sub_100FEB5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1006B4640((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100FEB5C8(uint64_t a1)
{
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_10230A478);
  }
  char v2 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 88);
    *(_DWORD *)uint64_t buf = 134283521;
    uint64_t v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] appending pending buffer of size %{private}lu", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    __int32 v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::appendPendingBuffer()", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  while (*(void *)(a1 + 88))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 56) + ((*(void *)(a1 + 80) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * *(void *)(a1 + 80);
    float v5 = *(float *)(v4 + 8);
    int v6 = *(_DWORD *)(a1 + 40);
    if (v6 == *(_DWORD *)(v4 + 12))
    {
      BOOL v7 = 0;
      float v8 = *(float *)(a1 + 36);
      BOOL v9 = v5 < 2.4;
      if (v8 >= 2.4) {
        BOOL v9 = 0;
      }
      if (v8 < 6.5 && v6 == 1 && v8 >= 2.4)
      {
        BOOL v7 = v5 >= 2.4;
        if (v5 >= 6.5) {
          BOOL v7 = 0;
        }
      }
      char v11 = vabds_f32(v8, v5) < 0.2 || v9 || v7;
    }
    else
    {
      char v11 = 0;
    }
    sub_100FEB900(a1, v11 ^ 1, *(double *)v4, v5);
    *(int64x2_t *)(a1 + 8sub_100FB8FC8(&a9, 0) = vaddq_s64(*(int64x2_t *)(a1 + 80), (int64x2_t)xmmword_101D0A740);
    sub_100096314(a1 + 48, 1);
  }
}

__n128 sub_100FEB874(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FEC63C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100FEB900(uint64_t a1, char a2, double a3, float a4)
{
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_10230A478);
  }
  float v8 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134283777;
    double v21 = a3;
    __int16 v22 = 2049;
    double v23 = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] adding sample {time=%{private}f,mets=%{private}f}", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::addToSample(CFAbsoluteTime, float, BOOL)", "%s\n", v18);
    if (v18 != (char *)buf) {
      free(v18);
    }
  }
  double v9 = *(double *)(a1 + 8);
  double v10 = *(double *)(a1 + 16);
  double v11 = fmax(v10 - v9, 0.0) + 2.56;
  float v12 = (float)(a4 - *(float *)(a1 + 32)) * 2.56 / v11 + *(float *)(a1 + 32);
  *(float *)(a1 + 32) = v12;
  if ((a2 & 1) == 0)
  {
    float v13 = (float)(a4 - *(float *)(a1 + 36)) * 2.56 / v11 + *(float *)(a1 + 36);
    *(float *)(a1 + 36) = v13;
  }
  double v14 = fmax(v10, a3);
  *(double *)(a1 + 16) = v14;
  if (v14 <= v9)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    double v15 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_INFO))
    {
      double v16 = *(double *)(a1 + 8);
      double v17 = *(double *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 134284033;
      double v21 = v16;
      __int16 v22 = 2049;
      double v23 = v17;
      __int16 v24 = 2050;
      double v25 = a3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "[PhysicalEffort] Invalid sample: sampleStart=%{private}f, sampleStop=%{private}f at %{public}f", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      int v19 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLPhysicalEffortAggregator::addToSample(CFAbsoluteTime, float, BOOL)", "%s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
  }
}

void sub_100FEBCD8(uint64_t a1, unsigned int a2, double a3, double a4, float a5)
{
  if (qword_102418FF0 != -1) {
    dispatch_once(&qword_102418FF0, &stru_10230A478);
  }
  double v10 = qword_102418FF8;
  if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134284289;
    double v31 = a3;
    __int16 v32 = 2049;
    double v33 = a4;
    __int16 v34 = 2049;
    double v35 = a5;
    __int16 v36 = 1025;
    unsigned int v37 = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] sending sample: start=%{private}f, end=%{private}f, mets=%{private}f, type=%{private}d", buf, 0x26u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    int v22 = 134284289;
    double v23 = a3;
    __int16 v24 = 2049;
    double v25 = a4;
    __int16 v26 = 2049;
    double v27 = a5;
    __int16 v28 = 1025;
    unsigned int v29 = a2;
    unsigned int v20 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLPhysicalEffortAggregator::sendSampleToHealthKit(CFAbsoluteTime, CFAbsoluteTime, float, CLMetsType)", "%s\n", v20);
    if (v20 != (char *)buf) {
      free(v20);
    }
  }
  if (a3 < a4 && a5 > 0.0 && a2)
  {
    uint64_t v11 = 77;
    uint64_t v12 = 1;
    uint64_t v13 = 11;
    switch(a2)
    {
      case 2u:
      case 3u:
        uint64_t v13 = 13;
        goto LABEL_21;
      case 4u:
        goto LABEL_40;
      case 5u:
        goto LABEL_39;
      case 6u:
        uint64_t v11 = 16;
        goto LABEL_39;
      case 7u:
        uint64_t v12 = 1;
        uint64_t v13 = 20;
        goto LABEL_40;
      case 8u:
        uint64_t v11 = 35;
        goto LABEL_39;
      case 9u:
        uint64_t v11 = 37;
        goto LABEL_39;
      case 0xAu:
        uint64_t v11 = 44;
        goto LABEL_39;
      case 0xBu:
        uint64_t v11 = 46;
        goto LABEL_39;
      case 0xCu:
        uint64_t v11 = 52;
        goto LABEL_39;
      case 0xDu:
        uint64_t v11 = 57;
        goto LABEL_39;
      case 0xEu:
        uint64_t v12 = 1;
        uint64_t v13 = 61;
        goto LABEL_40;
      case 0xFu:
        uint64_t v11 = 63;
        goto LABEL_39;
      case 0x10u:
        uint64_t v11 = 65;
        goto LABEL_39;
      case 0x11u:
        uint64_t v11 = 70;
        goto LABEL_39;
      case 0x12u:
        uint64_t v11 = 71;
        goto LABEL_39;
      case 0x13u:
        uint64_t v11 = 72;
        goto LABEL_39;
      case 0x14u:
        uint64_t v11 = 80;
        goto LABEL_39;
      default:
        uint64_t v13 = 3000;
LABEL_21:
        if (a2 <= 0x15)
        {
          uint64_t v12 = 1;
          if (((1 << a2) & 0x204098) != 0) {
            goto LABEL_40;
          }
        }
        uint64_t v11 = v13;
LABEL_39:
        uint64_t v12 = 2;
        uint64_t v13 = v11;
LABEL_40:
        double v16 = +[NSMutableDictionary dictionaryWithCapacity:5];
        [(NSMutableDictionary *)v16 setObject:+[NSNumber numberWithUnsignedInteger:v13] forKeyedSubscript:HKMetadataKeyActivityType];
        [(NSMutableDictionary *)v16 setObject:+[NSNumber numberWithInteger:v12] forKeyedSubscript:HKMetadataKeyPhysicalEffortEstimationType];
        [(NSMutableDictionary *)v16 setObject:&off_102393890 forKeyedSubscript:HKMetadataKeyAlgorithmVersion];
        if (a2 == 2)
        {
          double v17 = &off_1023938A8;
        }
        else
        {
          if (a2 != 3) {
            goto LABEL_45;
          }
          double v17 = &off_102393890;
        }
        [(NSMutableDictionary *)v16 setObject:v17 forKeyedSubscript:HKMetadataKeyIndoorWorkout];
LABEL_45:
        uint64_t v18 = +[HKQuantitySample quantitySampleWithType:quantity:startDate:endDate:metadata:](HKQuantitySample, "quantitySampleWithType:quantity:startDate:endDate:metadata:", +[HKObjectType quantityTypeForIdentifier:](HKObjectType, "quantityTypeForIdentifier:", HKQuantityTypeIdentifierPhysicalEffort), +[HKQuantity quantityWithUnit:doubleValue:](HKQuantity, "quantityWithUnit:doubleValue:", +[HKUnit unitFromString:](HKUnit, "unitFromString:", @"kcal/(kg*hr)"), a5), +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", a3), +[NSDate dateWithTimeIntervalSinceReferenceDate:a4],
                v16);
        int v19 = *(void **)(a1 + 104);
        double v21 = v18;
        [v19 saveObjects:[+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v21, 1) withCompletion:&stru_10230A448];
        break;
    }
  }
  else
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    double v14 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349825;
      double v31 = a3;
      __int16 v32 = 2050;
      double v33 = a4;
      __int16 v34 = 2049;
      double v35 = a5;
      __int16 v36 = 1026;
      unsigned int v37 = a2;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[PhysicalEffort] attempt to send invalid sample to healthkit start:%{public}f stop:%{public}f mets:%{private}f, type:%{public}d", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      int v22 = 134349825;
      double v23 = a3;
      __int16 v24 = 2050;
      double v25 = a4;
      __int16 v26 = 2049;
      double v27 = a5;
      __int16 v28 = 1026;
      unsigned int v29 = a2;
      double v15 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLPhysicalEffortAggregator::sendSampleToHealthKit(CFAbsoluteTime, CFAbsoluteTime, float, CLMetsType)", "%s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
  }
}

void sub_100FEC348(id a1, BOOL a2, NSError *a3)
{
  if (a2)
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    uint64_t v3 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "[PhysicalEffort] successfully pushed to HKHealthStore", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      uint64_t v4 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLPhysicalEffortAggregator::sendSampleToHealthKit(CFAbsoluteTime, CFAbsoluteTime, float, CLMetsType)_block_invoke", "%s\n");
LABEL_19:
      if (v4 != buf) {
        free(v4);
      }
    }
  }
  else
  {
    if (qword_102418FF0 != -1) {
      dispatch_once(&qword_102418FF0, &stru_10230A478);
    }
    uint64_t v6 = qword_102418FF8;
    if (os_log_type_enabled((os_log_t)qword_102418FF8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 138543362;
      float v8 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "[PhysicalEffort] HKHealthStore saveObjects failed on, %{public}@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FF0 != -1) {
        dispatch_once(&qword_102418FF0, &stru_10230A478);
      }
      uint64_t v4 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLPhysicalEffortAggregator::sendSampleToHealthKit(CFAbsoluteTime, CFAbsoluteTime, float, CLMetsType)_block_invoke", "%s\n");
      goto LABEL_19;
    }
  }
}

void sub_100FEC60C(id a1)
{
  qword_102418FF8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_100FEC63C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    float v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)float v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int16 v34 = (char *)sub_1000DA54C(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      float v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        float v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      double v9 = (char *)a1[1];
    }
    float v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    double v44 = (void *)a1[1];
    float v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    double v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int16 v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      double v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      int v48 = (uint64_t *)a1[1];
      float v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        float v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        float v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  __int32 v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  double v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  unsigned int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FEC908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100FEC954(void *result, void *a2)
{
  if (a2)
  {
    BOOL v3 = result;
    __n128 result = (void *)sub_100F91E80((uint64_t)result);
    if (result)
    {
      uint64_t v5 = (uint64_t *)a2[2];
      if (v5)
      {
        while (1)
        {
          uint64_t v8 = v5[2];
          uint64_t v7 = *(void *)nullsub_41(v3, v4);
          if (sub_100B39178(&v8, &v7)) {
            break;
          }
          uint64_t v5 = (uint64_t *)*v5;
          if (!v5) {
            goto LABEL_8;
          }
        }
        sub_100E4680C(a2, v5);
      }
LABEL_8:
      uint64_t v6 = (void *)nullsub_41(v3, v4);
      return sub_10050EED0((uint64_t)a2, v6, (uint64_t)v6);
    }
  }
  return result;
}

void sub_100FEC9F8(uint64_t a1)
{
  __chkstk_darwin(a1);
  uint64_t v2 = v1;
  uint64_t v4 = (uint64_t)v3;
  sub_1000DF230(v3, v1);
  if (*(unsigned char *)(v2 + 6376))
  {
    if (*(unsigned char *)(v2 + 808))
    {
      sub_100FECB14(v2, v2, v5);
      sub_1000D76D0(v4, (uint64_t)v5);
      sub_1000D846C(v4 + 808, (uint64_t)v6);
      sub_1000D9488(v4 + 3016, (uint64_t)v7);
      sub_1000D7DCC((uint64_t)v7);
      sub_1000D7C60((uint64_t)v6);
      sub_1000D7B80((uint64_t)v5);
    }
  }
}

void sub_100FECAF0(_Unwind_Exception *a1)
{
  sub_10050BAA0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FECB14@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  sub_1000DF230(a3, a2);
  double v6 = sub_100FED230(a2);
  sub_100FED058(*(void *)(a1 + 3160), (uint64_t)v20, *(double *)(a1 + 6384), v6);
  sub_100FEC954((void *)(a1 + 3208), v20);
  uint64_t v7 = v21;
  uint64_t v8 = v22;
  if (v21)
  {
    uint64_t v9 = 0;
    do
    {
      v9 += sub_100D550A4(*((_DWORD *)v7 + 14));
      uint64_t v7 = (void *)*v7;
    }
    while (v7);
    uint64_t v10 = v21;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  memset(v18, 0, sizeof(v18));
  int v19 = 1065353216;
  memset(v16, 0, sizeof(v16));
  for (i = 1065353216; v10; uint64_t v10 = (void *)*v10)
  {
    *(void *)uint64_t buf = v10[2];
    sub_1000E34E4((uint64_t)v16, buf, buf);
    *(void *)uint64_t buf = v10[2];
    sub_100FED428((uint64_t)v18, buf, buf, (uint64_t)(v10 + 2));
  }
  if (qword_1024193B0 != -1) {
    dispatch_once(&qword_1024193B0, &stru_10230A498);
  }
  uint64_t v11 = qword_1024193B8;
  if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 3160) + 24);
    *(_DWORD *)uint64_t buf = 134350080;
    *(void *)&uint8_t buf[4] = v12;
    __int16 v34 = 2050;
    uint64_t v35 = v8;
    __int16 v36 = 2050;
    uint64_t v37 = v9;
    __int16 v38 = 2050;
    uint64_t v39 = v8 - v9;
    __int16 v40 = 2050;
    unint64_t v41 = (unint64_t)v6;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "@WifiFlow, aps, history, %{public}lu, fresh, %{public}llu, 2ghz, %{public}llu, 5ghz, %{public}llu, agethresh, %{public}llu,", buf, 0x34u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193B0 != -1) {
      dispatch_once(&qword_1024193B0, &stru_10230A498);
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 3160) + 24);
    int v23 = 134350080;
    uint64_t v24 = v14;
    __int16 v25 = 2050;
    uint64_t v26 = v8;
    __int16 v27 = 2050;
    uint64_t v28 = v9;
    __int16 v29 = 2050;
    uint64_t v30 = v8 - v9;
    __int16 v31 = 2050;
    unint64_t v32 = (unint64_t)v6;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "Output CL::Wifi1::Policies::FilterScanHistory::HandleEvent::selectApsForLocationComputation(const Input &) const", "%s\n", v15);
    if (v15 != buf) {
      free(v15);
    }
  }
  sub_1000E2E9C((uint64_t)(a3 + 276), (uint64_t *)v16);
  sub_100FED7B8((uint64_t)(a3 + 286), (uint64_t *)v18);
  sub_1000D7D80((uint64_t)v16);
  sub_1000D82B4((uint64_t)v18);
  return sub_1000DB114((uint64_t)v20);
}

void sub_100FECE38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  sub_1000D7D80((uint64_t)va);
  sub_1000D82B4((uint64_t)va1);
  sub_1000DB114((uint64_t)va2);
  sub_10050BAA0(v3);
  _Unwind_Resume(a1);
}

_DWORD *sub_100FECE88@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 6376) && (*(int *)(a1 + 6400) > 0 || *(int *)(a1 + 6404) > 0 || *(int *)(a1 + 6408) > 0)) {
    return (_DWORD *)sub_100FECB14(a1, a1, a2);
  }
  else {
    return sub_1000DF230(a2, a1);
  }
}

void sub_100FECECC(uint64_t a1)
{
  __chkstk_darwin(a1);
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  sub_1000DF230(v5, v1);
  if (*(unsigned char *)(v2 + 6376) && *(unsigned char *)(v2 + 6379)) {
    sub_100FECB14(v2, v2, v4);
  }
  else {
    sub_1000DF9A4((uint64_t)v4, (uint64_t)v5);
  }
  sub_1000D7DCC((uint64_t)&v7);
  sub_1000D7C60((uint64_t)&v6);
  sub_1000D7B80((uint64_t)v5);
}

void sub_100FECFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100FECFC4@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t result = (uint64_t)sub_1000DF230(a2, a1);
  if (*(unsigned char *)(a1 + 6376))
  {
    uint64_t v5 = a1 + 3208;
    uint64_t result = sub_100F91E80(v5);
    if (result)
    {
      uint64_t v7 = (uint64_t *)nullsub_41(v5, v6);
      uint64_t v8 = *v7;
      return (uint64_t)sub_100FED428((uint64_t)(a2 + 286), &v8, &v8, (uint64_t)v7);
    }
  }
  return result;
}

void sub_100FED03C(_Unwind_Exception *a1)
{
  sub_10050BAA0(v1);
  _Unwind_Resume(a1);
}

void sub_100FED058(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  for (int i = *(double **)(a1 + 16); i; int i = *(double **)i)
  {
    double v8 = vabdd_f64(a3, i[9]);
    if (a4 >= v8)
    {
      sub_10050EED0(a2, (void *)i + 2, (uint64_t)(i + 2));
    }
    else
    {
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_10230A498);
      }
      uint64_t v9 = qword_1024193B8;
      if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_DEBUG))
      {
        sub_10006DE8C(&__p);
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t buf = 68289539;
        int v13 = 0;
        __int16 v14 = 2082;
        uint64_t v15 = "";
        __int16 v16 = 2081;
        uint64_t v17 = p_p;
        __int16 v18 = 2050;
        double v19 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"filtering out access point from calculation based on scan timestamp\", \"mac\":%{private, location:escape_only}s, \"age_seconds_s\":\"%{public}.09f\"}", buf, 0x26u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
  }
}

void sub_100FED218(_Unwind_Exception *a1)
{
  sub_1000DB114(v1);
  _Unwind_Resume(a1);
}

double sub_100FED230(uint64_t a1)
{
  double v2 = 1.0;
  if (!sub_1006D30E0((_DWORD *)(a1 + 5968)))
  {
    uint64_t v3 = *(void *)(a1 + 3192);
    uint64_t v7 = *(void *)(a1 + 6384);
    if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v3 + 16))(v3, &v7))
    {
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_10230A498);
      }
      uint64_t v4 = qword_1024193B8;
      double v2 = 30.0;
      if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = 68289282;
        __int16 v8 = 2082;
        uint64_t v9 = "";
        __int16 v10 = 2050;
        uint64_t v11 = 0x403E000000000000;
        uint64_t v5 = "{\"msg%{public}.0s\":\"elevation is steady\", \"max_ap_age_s\":\"%{public}.09f\"}";
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, v5, (uint8_t *)&v7, 0x1Cu);
      }
    }
    else
    {
      if (qword_1024193B0 != -1) {
        dispatch_once(&qword_1024193B0, &stru_10230A498);
      }
      uint64_t v4 = qword_1024193B8;
      double v2 = 5.0;
      if (os_log_type_enabled((os_log_t)qword_1024193B8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = 68289282;
        __int16 v8 = 2082;
        uint64_t v9 = "";
        __int16 v10 = 2050;
        uint64_t v11 = 0x4014000000000000;
        uint64_t v5 = "{\"msg%{public}.0s\":\"elevation is not steady\", \"max_ap_age_s\":\"%{public}.09f\"}";
        goto LABEL_11;
      }
    }
  }
  return v2;
}

void sub_100FED3F8(id a1)
{
  qword_1024193B8 = (uint64_t)os_log_create("com.apple.locationd.Position", "WifiPosition");
}

void *sub_100FED428(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  unint64_t v9 = sub_1000D8908((uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    __int16 v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v10)
          {
            if (sub_100B39178(v15 + 2, a2)) {
              return v15;
            }
          }
          else
          {
            if (v13 > 1)
            {
              if (v16 >= v11) {
                v16 %= v11;
              }
            }
            else
            {
              v16 &= v11 - 1;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
  sub_100FED69C(a1, v10, a3, a4, (uint64_t)&v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100100330(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  int v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *uint64_t v26 = *v23;
    *int v23 = v26;
  }
  else
  {
    *uint64_t v26 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26;
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*v26)
    {
      unint64_t v24 = *(void *)(*v26 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26;
    }
  }
  uint64_t v15 = v26;
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_100FED678(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_1001F7F34((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FED69C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  unint64_t v10 = operator new(0x70uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *unint64_t v10 = 0;
  v10[1] = a2;
  uint64_t result = sub_100FED738((uint64_t)(v10 + 2), a3, a4);
  *(unsigned char *)(a5 + 16) = 1;
  return result;
}

void sub_100FED71C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1001F7F34(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100FED738(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = *(void *)a3;
  uint64_t v5 = a1 + 16;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_1000DC48C((unsigned char *)v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(v5 + 16) = *(void *)(a3 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }
  long long v7 = *(_OWORD *)(a3 + 32);
  long long v8 = *(_OWORD *)(a3 + 48);
  long long v9 = *(_OWORD *)(a3 + 64);
  *(void *)(a1 + 88) = *(void *)(a3 + 80);
  *(_OWORD *)(a1 + 72) = v9;
  *(_OWORD *)(a1 + 56) = v8;
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = v7;
  return a1;
}

void sub_100FED7B8(uint64_t a1, uint64_t *a2)
{
  sub_100FED85C(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  long long v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    void *v7 = 0;
    v7[1] = 0;
  }
}

void sub_100FED85C(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1000D82F0(a1, *(void ***)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_100FED954()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419688, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419688))
  {
    qword_102419670 = 0;
    qword_102419678 = 0;
    qword_102419680 = 0;
    uint64_t v0 = operator new(6uLL);
    qword_102419678 = (uint64_t)(v0 + 3);
    qword_102419680 = (uint64_t)(v0 + 3);
    *(_DWORD *)uint64_t v0 = 151521030;
    v0[2] = 3082;
    qword_102419670 = (uint64_t)v0;
    __cxa_atexit((void (*)(void *))sub_1001C6FD8, &qword_102419670, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419688);
  }
}

void sub_100FEDA0C(_Unwind_Exception *a1)
{
}

void sub_100FEDA24()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024196A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1024196A8))
  {
    qword_102419690 = 0;
    qword_102419698 = 0;
    qword_1024196A0 = 0;
    uint64_t v0 = operator new(2uLL);
    qword_102419690 = (uint64_t)v0;
    _WORD *v0 = 256;
    qword_102419698 = (uint64_t)(v0 + 1);
    qword_1024196A0 = (uint64_t)(v0 + 1);
    __cxa_atexit((void (*)(void *))sub_1001C700C, &qword_102419690, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1024196A8);
  }
}

void sub_100FEDACC(_Unwind_Exception *a1)
{
}

void sub_100FEDAE4(double *a1, double *a2, uint64_t a3)
{
  if (rand() % 100 <= 0)
  {
    sub_100FEDBD4(a1, a2);
    sub_100134750(__p, "WifiHarvest");
    sub_100FEDF50(a1, a3, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    sub_100134750(__p, "GpsHarvest");
    sub_100FEDF50(a2, a3, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100FEDBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FEDBD4(double *a1, double *a2)
{
  id v4 = +[NSMutableDictionary dictionary];
  BOOL v5 = 0;
  double v6 = *a1;
  if (*a1 >= -90.0 && v6 <= 90.0)
  {
    double v6 = a1[1];
    BOOL v5 = v6 <= 180.0 && v6 >= -180.0;
  }
  [v4 setObject:[+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v5, v6)] forKeyedSubscript:@"isWifiHarvestCentroidValid"];
  BOOL v7 = 0;
  double v8 = *a2;
  if (*a2 >= -90.0 && v8 <= 90.0)
  {
    double v8 = a2[1];
    BOOL v7 = v8 <= 180.0 && v8 >= -180.0;
  }
  [v4 setObject:[+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v7, v8) forKeyedSubscript:@"isGpsHarvestCentroidValid"];
  double v9 = *a1;
  if (*a1 >= -90.0 && v9 <= 90.0)
  {
    double v10 = a1[1];
    if (v10 <= 180.0 && v10 >= -180.0)
    {
      double v11 = *a2;
      if (*a2 >= -90.0 && v11 <= 90.0)
      {
        double v12 = a2[1];
        if (v12 <= 180.0 && v12 >= -180.0) {
          [v4 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", sub_1000A3D9C(v9, v10, v11, v12))] forKeyedSubscript:@"wifiHarvestCentroidAndGpsHarvestCentroidDistance"];
        }
      }
    }
  }
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10230A4B8);
  }
  unint64_t v13 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 138543362;
    id v17 = v4;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Submitting CoreAnalytics event for associated AP harvest centroid comparisons, %{public}@", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10230A4B8);
    }
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static void CLWifiAssociatedApHarvestComparator::submitHarvestCentroidComparisonMetrics(const CLWifiAccessPoint &, const CLWifiAccessPoint &)", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  return AnalyticsSendEventLazy();
}

double *sub_100FEDF50(double *result, uint64_t a2, uint64_t *a3)
{
  if (*result >= -90.0 && *result <= 90.0)
  {
    uint64_t v3 = (uint64_t)result;
    double v4 = result[1];
    if (v4 <= 180.0 && v4 >= -180.0)
    {
      uint64_t result = (double *)sub_1000E6DB4(a2);
      if (result)
      {
        sub_100F83A18(v3, (uint64_t)buf);
        sub_10106EA88((uint64_t)buf, (uint64_t)v13);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        sub_101284D6C((uint64_t)v12, a2);
        uint64_t result = (double *)sub_101284DA0((uint64_t)v12, (uint64_t)v13);
        if (result)
        {
          id v7 = +[NSMutableDictionary dictionary];
          sub_101284E28((uint64_t)v12, (uint64_t)v13);
          [v7 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:")] forKeyedSubscript:@"horizontalError"];
          *(void *)&double v8 = sub_101284E3C((uint64_t)v12, buf).n128_u64[0];
          [v7 setObject:+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v18, v8) forKeyedSubscript:@"referenceLocationType"];
          if (*((char *)a3 + 23) >= 0) {
            double v9 = a3;
          }
          else {
            double v9 = (uint64_t *)*a3;
          }
          [v7 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9) forKeyedSubscript:@"harvestType"];
          if (qword_1024193A0 != -1) {
            dispatch_once(&qword_1024193A0, &stru_10230A4B8);
          }
          double v10 = qword_1024193A8;
          if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t buf = 138543362;
            *(void *)&uint8_t buf[4] = v7;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Submitting CoreAnalytics event for associated AP harvest centroid error, %{public}@", buf, 0xCu);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193A0 != -1) {
              dispatch_once(&qword_1024193A0, &stru_10230A4B8);
            }
            int v15 = 138543362;
            id v16 = v7;
            double v11 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "static void CLWifiAssociatedApHarvestComparator::submitHarvestCentroidHorizontalErrorMetrics(const CLWifiAccessPoint &, const CLDaemonLocation &, const std::string &)", "%s\n", v11);
            if (v11 != (char *)buf) {
              free(v11);
            }
          }
          return (double *)AnalyticsSendEventLazy();
        }
      }
    }
  }
  return result;
}

uint64_t sub_100FEE28C(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_100FEE294(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_100FEE29C(id a1)
{
  qword_1024193A8 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

id sub_100FEE2CC(void *a1, unsigned int a2, void *a3)
{
  if (!a1 || !a3)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    double v11 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedDataAndKey,data and/or key pointer are nil", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_44;
    }
    goto LABEL_50;
  }
  if (a2 != 16 && a2 != 32)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    double v12 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v22 = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedDataAndKey,unsupported AES key length,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_44;
    }
LABEL_50:
    dispatch_once(&qword_1024193E0, &stru_10230A4D8);
LABEL_44:
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)", "%s\n", v19);
    if (v19 != (char *)buf) {
      free(v19);
    }
    return 0;
  }
  size_t v6 = a2;
  id v7 = [objc_alloc((Class)NSMutableData) initWithLength:a2];
  int v8 = SecRandomCopyBytes(kSecRandomDefault, v6, [v7 mutableBytes]);
  if (v8)
  {
    int v9 = v8;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    double v10 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v22 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedDataAndKey,failed to generate AES key,error,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_11;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1)
    {
LABEL_41:
      unsigned int v18 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)", "%s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
LABEL_11:

      return 0;
    }
LABEL_51:
    dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    goto LABEL_41;
  }
  id v15 = sub_100FEE928(a1, v7);
  if (!v15)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    id v17 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedDataAndKey,failed to create AES encrypted data", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_11;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_41;
    }
    goto LABEL_51;
  }
  id v13 = v15;
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230A4D8);
  }
  id v16 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#CLEU,createAESEncryptedDataAndKey,successfully created AES key and encrypted data", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    unint64_t v20 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)", "%s\n", v20);
    if (v20 != (char *)buf) {
      free(v20);
    }
  }
  *a3 = v7;
  return v13;
}

id sub_100FEE928(void *a1, void *a2)
{
  if (!a1 || !a2)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    int v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedData,data and/or key pointer are nil", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
LABEL_46:
    id v16 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)", "%s\n", v16);
    if (v16 != (char *)buf) {
      free(v16);
    }
    return 0;
  }
  if ([a2 length] != (id)16 && objc_msgSend(a2, "length") != (id)32)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    double v12 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v19 = [a2 length];
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedData,unsupported AES key length,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    [a2 length];
    goto LABEL_46;
  }
  id v4 = [objc_alloc((Class)NSMutableData) initWithLength:((((void)objc_msgSend(a1, "length") << 32) + 0x2000000000) >> 32)];
  int v5 = SecRandomCopyBytes(kSecRandomDefault, 0x10uLL, [v4 mutableBytes]);
  if (v5)
  {
    unsigned int v6 = v5;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    id v7 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedData,failed to generate AES IV,error,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1)
    {
LABEL_49:
      id v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)", "%s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
LABEL_26:

      return 0;
    }
LABEL_52:
    dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    goto LABEL_49;
  }
  [v4 mutableBytes];
  [a2 bytes];
  [a2 length];
  [v4 mutableBytes];
  [a1 bytes];
  unsigned int v9 = CCCryptorGCMOneshotEncrypt();
  if (v9)
  {
    unsigned int v10 = v9;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    double v11 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#CLEU,createAESEncryptedData,failed to encrypt data,error,%{public}d", buf, 8u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_49;
    }
    goto LABEL_52;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230A4D8);
  }
  __int16 v14 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#CLEU,createAESEncryptedData,successfully encrypted data", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    id v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  return v4;
}

id sub_100FEF048(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v61 = a2;
  if (a3 && a4)
  {
    unsigned int v6 = +[NSMutableData dataWithCapacity:40];
    [(NSMutableData *)v6 appendData:a3];
    [(NSMutableData *)v6 appendData:+[NSData dataWithBytes:&v61 length:8]];
    id v55 = [objc_alloc((Class)NSMutableArray) initWithCapacity:*(void *)(a1 + 24)];
    id v7 = *(uint64_t **)(a1 + 16);
    if (v7)
    {
      while (1)
      {
        if (*((char *)v7 + 39) < 0)
        {
          sub_1000DC48C(__dst, (void *)v7[2], v7[3]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v7 + 1);
          uint64_t v60 = v7[4];
        }
        if (*((char *)v7 + 63) < 0)
        {
          sub_1000DC48C(__p, (void *)v7[5], v7[6]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v7 + 5);
          uint64_t v58 = v7[7];
        }
        int v8 = sub_100A7D8F0((uint64_t *)__p);
        unsigned int v9 = v8;
        if (!v8) {
          break;
        }
        SecKeyRef v10 = SecCertificateCopyKey(v8);
        CFRelease(v9);
        if (!v10)
        {
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230A4D8);
          }
          __int16 v27 = qword_1024193E8;
          if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v28 = __dst;
            if (v60 < 0) {
              uint64_t v28 = (void **)__dst[0];
            }
            *(_DWORD *)uint64_t buf = 136446210;
            int v75 = v28;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "#CLEU,createWrappedKeyArray,couldn't extract partner key from cert so not creating wrapping key,partner,%{public}s", buf, 0xCu);
          }
          if (!sub_10013D1A0(115, 0)) {
            goto LABEL_75;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230A4D8);
          }
          __int16 v29 = __dst;
          if (v60 < 0) {
            __int16 v29 = (void **)__dst[0];
          }
          int v64 = 136446210;
          char v65 = v29;
          uint64_t v26 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)", "%s\n", v26);
          goto LABEL_69;
        }
        double v11 = [(NSMutableData *)v6 length];
        unint64_t v12 = HIBYTE(v60);
        if (v60 < 0) {
          unint64_t v12 = (unint64_t)__dst[1];
        }
        id v13 = +[NSMutableData dataWithCapacity:&v11[v12]];
        [(NSMutableData *)v13 appendData:v6];
        if (v60 >= 0) {
          __int16 v14 = __dst;
        }
        else {
          __int16 v14 = (void **)__dst[0];
        }
        if (v60 >= 0) {
          id v15 = (void *)HIBYTE(v60);
        }
        else {
          id v15 = __dst[1];
        }
        [(NSMutableData *)v13 appendData:+[NSData dataWithBytes:v14 length:v15]];
        CFErrorRef error = 0;
        SecKeyKeyExchangeParameter v72 = kSecKeyKeyExchangeParameterSharedInfo;
        uint64_t v73 = v13;
        +[NSDictionary dictionaryWithObjects:&v73 forKeys:&v72 count:1];
        EncryptedDataWithParameters = (void *)SecKeyCreateEncryptedDataWithParameters();
        id v17 = EncryptedDataWithParameters;
        if (error)
        {
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230A4D8);
          }
          unsigned int v18 = qword_1024193E8;
          if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
          {
            if (v60 >= 0) {
              unsigned int v19 = __dst;
            }
            else {
              unsigned int v19 = (void **)__dst[0];
            }
            unsigned int v20 = [(__CFError *)error code];
            id v21 = [[-[__CFError domain](error, "domain") UTF8String];
            id v22 = [[-[__CFError localizedDescription](error, "localizedDescription") UTF8String];
            *(_DWORD *)uint64_t buf = 136446978;
            int v75 = v19;
            __int16 v76 = 1026;
            unsigned int v77 = v20;
            __int16 v78 = 2082;
            id v79 = v21;
            __int16 v80 = 2082;
            id v81 = v22;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "#CLEU,createWrappedKeyArray,failed to encrypt key for partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s", buf, 0x26u);
          }
          if (sub_10013D1A0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193E0 != -1) {
              dispatch_once(&qword_1024193E0, &stru_10230A4D8);
            }
            if (v60 >= 0) {
              uint64_t v47 = __dst;
            }
            else {
              uint64_t v47 = (void **)__dst[0];
            }
            unsigned int v48 = [(__CFError *)error code];
            id v49 = [[-[__CFError domain](error, "domain") UTF8String];
            id v50 = [[-[__CFError localizedDescription](error, "localizedDescription") UTF8String];
            int v64 = 136446978;
            char v65 = v47;
            __int16 v66 = 1026;
            unsigned int v67 = v48;
            __int16 v68 = 2082;
            id v69 = v49;
            __int16 v70 = 2082;
            id v71 = v50;
            uint64_t v51 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)", "%s\n", v51);
            if (v51 != (char *)buf) {
              free(v51);
            }
          }
          CFRelease(v10);
        }
        else
        {
          CFDataRef v30 = SecKeyCopyExternalRepresentation(v10, &error);
          if (error)
          {
            if (qword_1024193E0 != -1) {
              dispatch_once(&qword_1024193E0, &stru_10230A4D8);
            }
            __int16 v31 = qword_1024193E8;
            if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
            {
              if (v60 >= 0) {
                unint64_t v32 = __dst;
              }
              else {
                unint64_t v32 = (void **)__dst[0];
              }
              unsigned int v33 = [(__CFError *)error code];
              id v34 = [[-[__CFError domain](error, "domain") UTF8String];
              id v35 = [[-[__CFError localizedDescription](error, "localizedDescription") UTF8String];
              *(_DWORD *)uint64_t buf = 136446978;
              int v75 = v32;
              __int16 v76 = 1026;
              unsigned int v77 = v33;
              __int16 v78 = 2082;
              id v79 = v34;
              __int16 v80 = 2082;
              id v81 = v35;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "#CLEU,createWrappedKeyArray,failed to create DER data for partner public key,partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s", buf, 0x26u);
            }
            if (!sub_10013D1A0(115, 0)) {
              goto LABEL_75;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1024193E0 != -1) {
              dispatch_once(&qword_1024193E0, &stru_10230A4D8);
            }
            if (v60 >= 0) {
              __int16 v36 = __dst;
            }
            else {
              __int16 v36 = (void **)__dst[0];
            }
            unsigned int v37 = [(__CFError *)error code];
            id v38 = [[-[__CFError domain](error, "domain") UTF8String];
            id v39 = [[-[__CFError localizedDescription](error, "localizedDescription") UTF8String];
            int v64 = 136446978;
            char v65 = v36;
            __int16 v66 = 1026;
            unsigned int v67 = v37;
            __int16 v68 = 2082;
            id v69 = v38;
            __int16 v70 = 2082;
            id v71 = v39;
            uint64_t v26 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)", "%s\n", v26);
            goto LABEL_69;
          }
          CFDataRef v40 = v30;
          id v41 = [objc_alloc((Class)NSMutableData) initWithLength:32];
          CC_SHA256(-[__CFData bytes](v40, "bytes"), (CC_LONG)-[__CFData length](v40, "length"), (unsigned __int8 *)[v41 mutableBytes]);
          id v42 = [v41 subdataWithRange:0, 2];
          CFRelease(v10);

          __int32 v43 = +[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", (char *)[EncryptedDataWithParameters length] + 2);
          [(NSMutableData *)v43 appendData:v42];
          [(NSMutableData *)v43 appendData:EncryptedDataWithParameters];
          id v44 = [(NSMutableData *)v43 base64EncodedStringWithOptions:0];
          v62[0] = @"partner_ID";
          if (v60 >= 0) {
            uint64_t v45 = __dst;
          }
          else {
            uint64_t v45 = (void **)__dst[0];
          }
          unint64_t v46 = +[NSString stringWithUTF8String:v45];
          v62[1] = @"wrapped_key";
          v63[0] = v46;
          v63[1] = v44;
          [v55 addObject:+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v63, v62, 2)];
        }
LABEL_75:
        if (SHIBYTE(v58) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v60) < 0) {
          operator delete(__dst[0]);
        }
        id v7 = (uint64_t *)*v7;
        if (!v7) {
          return v55;
        }
      }
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230A4D8);
      }
      int v23 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
      {
        unint64_t v24 = __dst;
        if (v60 < 0) {
          unint64_t v24 = (void **)__dst[0];
        }
        *(_DWORD *)uint64_t buf = 136380675;
        int v75 = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "#CLEU,createWrappedKeyArray,unable to convert cert data to SecCertificateRef for partner %{private}s", buf, 0xCu);
      }
      if (!sub_10013D1A0(115, 0)) {
        goto LABEL_75;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230A4D8);
      }
      __int16 v25 = __dst;
      if (v60 < 0) {
        __int16 v25 = (void **)__dst[0];
      }
      int v64 = 136380675;
      char v65 = v25;
      uint64_t v26 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)", "%s\n", v26);
LABEL_69:
      if (v26 != (char *)buf) {
        free(v26);
      }
      goto LABEL_75;
    }
    return v55;
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230A4D8);
    }
    uint64_t v52 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "#CLEU,createWrappedKeyArray,hash of encrypted ADR data or key is nil so not computing wrapped keys", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230A4D8);
      }
      LOWORD(v64) = 0;
      long long v54 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)", "%s\n", v54);
      if (v54 != (char *)buf) {
        free(v54);
      }
    }
    return 0;
  }
}

void sub_100FEFC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEFC8C(id a1)
{
  qword_1024193E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

uint64_t sub_100FF08B4(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    switch((v6 >> 3))
    {
      case 0x15u:
        id v13 = objc_alloc_init(ALSCdmaCellTower);
        [a1 addCdmaCellTower:v13];

        if PBReaderPlaceMark() && (sub_100F691BC((uint64_t)v13, a2)) {
          goto LABEL_40;
        }
        return 0;
      case 0x16u:
        id v15 = objc_alloc_init(ALSCdmaEvdoTower);
        [a1 addCdmaEvdoTower:v15];

        if (!PBReaderPlaceMark() || (sub_100F72FF0((uint64_t)v15, a2) & 1) == 0) {
          return 0;
        }
        goto LABEL_40;
      case 0x17u:
        id v16 = objc_alloc_init(ALSLteCellTower);
        [a1 addLteCellTower:v16];

        if (!PBReaderPlaceMark() || (sub_100F9DCE8((uint64_t)v16, a2) & 1) == 0) {
          return 0;
        }
        goto LABEL_40;
      case 0x18u:
        id v17 = objc_alloc_init(ALSScdmaCellTower);
        [a1 addScdmaCellTower:v17];

        if (!PBReaderPlaceMark() || (sub_1013D6054((uint64_t)v17, a2) & 1) == 0) {
          return 0;
        }
        goto LABEL_40;
      case 0x19u:
        unsigned int v18 = objc_alloc_init(ALSNr5GCellTower);
        [a1 addNr5GCellTower:v18];

        if (!PBReaderPlaceMark() || (sub_101556CDC((uint64_t)v18, a2) & 1) == 0) {
          return 0;
        }
        goto LABEL_40;
      default:
        if (v12 != 2)
        {
          if (v12 == 1)
          {
            __int16 v14 = objc_alloc_init(ALSCellTower);
            [a1 addCellTower:v14];

            if (!PBReaderPlaceMark() || (sub_100F92BD8((uint64_t)v14, a2) & 1) == 0) {
              return 0;
            }
            goto LABEL_40;
          }
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
LABEL_41:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }
        unsigned int v19 = objc_alloc_init(ALSWirelessAP);
        [a1 addWirelessAP:v19];

        if PBReaderPlaceMark() && (sub_100FF36F8((uint64_t)v19, a2))
        {
LABEL_40:
          PBReaderRecallMark();
          goto LABEL_41;
        }
        return 0;
    }
  }
}

void sub_100FF2064(_Unwind_Exception *a1)
{
  for (uint64_t i = 432; i != -48; i -= 48)
    sub_1000DAF68((void *)(v1 + i));
  _Unwind_Resume(a1);
}

void sub_100FF2098(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_10230A508;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v3 = (id *)(a1 + 16);
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  sub_10144DA50((void *)(a1 + 56));
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 24) = [[CLSubHarvesterAltimeterIntersiloAdapter alloc] initWithHarvesterExternal:a1];
  id v4 = [[objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLBarometerCalibration"];
  *(void *)(a1 + 16) = v4;
  [v4 registerDelegate:*(void *)(a1 + 24) inSilo:objc_msgSend(*(id *)(a1 + 8), "silo")];
  [*v3 setDelegateEntityName:"CLSubHarvesterAltimeterExternal"];
  sub_10060F068();
}

void sub_100FF225C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[10];
  v1[10] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  id v4 = (std::__shared_weak_count *)v1[8];
  if (v4) {
    sub_1000DB0A0(v4);
  }
  uint64_t v5 = v1[6];
  v1[6] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF22E8(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230A590);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    unint64_t v7 = _os_activity_create((void *)&_mh_execute_header, "CL: CLSubHarvesterAltimeterExternal::onStatusNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230A590);
    }
    char v8 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2082;
      id v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLSubHarvesterAltimeterExternal::onStatusNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v10 = 0;
  }
  if (*a2 == 6) {
    *(_DWORD *)(a4 + 88) = *(_DWORD *)(a3 + 4);
  }
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FF24A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF24C8(uint64_t a1)
{
  *(void *)a1 = off_10230A508;

  uint64_t v2 = *(void *)(a1 + 80);
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_1000DB0A0(v3);
  }
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_100FF2594(uint64_t a1)
{
  sub_100FF24C8(a1);

  operator delete();
}

uint64_t sub_100FF25CC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100FF2604()
{
}

void sub_100FF26BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230A590);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    char v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLSubHarvesterAltimeterExternal::onNetworkLocationNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230A590);
    }
    unsigned int v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLSubHarvesterAltimeterExternal::onNetworkLocationNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a4 + 40) + 24))(*(void *)(a4 + 40), a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FF28A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF28C8()
{
  return *sub_101069E58();
}

id sub_100FF28E8(uint64_t a1)
{
  if (qword_1024191E0 != -1) {
    dispatch_once(&qword_1024191E0, &stru_10230A5B0);
  }
  uint64_t v2 = qword_1024191E8;
  if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "registering for baro cal", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230A5B0);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLSubHarvesterAltimeterExternal::registerForBarometerCalibrationNotification()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return [*(id *)(a1 + 16) registerClient:*(void *)(a1 + 24) forNotification:0];
}

id sub_100FF2A88(uint64_t a1)
{
  if (qword_1024191E0 != -1) {
    dispatch_once(&qword_1024191E0, &stru_10230A5B0);
  }
  uint64_t v2 = qword_1024191E8;
  if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "unregistering for baro cal", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230A5B0);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLSubHarvesterAltimeterExternal::unregisterForBarometerCalibrationNotification()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return [*(id *)(a1 + 16) unregisterClient:*(void *)(a1 + 24) forNotification:0];
}

unsigned char *sub_100FF2C28(unsigned char *result)
{
  if (!result[72])
  {
    uint64_t v1 = result;
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230A5B0);
    }
    uint64_t v2 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "registering for network location provider notification", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230A5B0);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLSubHarvesterAltimeterExternal::registerForNetworkLocationProviderNotification()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
    [*(id *)(*((void *)v1 + 6) + 16) register:*(void *)(*((void *)v1 + 6) + 8) forNotification:1 registrationInfo:0];
    uint64_t result = [*(id *)(*((void *)v1 + 6) + 16) register:*(void *)(*((void *)v1 + 6) + 8) forNotification:3 registrationInfo:0];
    v1[72] = 1;
  }
  return result;
}

unsigned char *sub_100FF2DF4(unsigned char *result)
{
  if (result[72])
  {
    uint64_t v1 = result;
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230A5B0);
    }
    uint64_t v2 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "unregistering for network location provider notification", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230A5B0);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLSubHarvesterAltimeterExternal::unregisterForNetworkLocationProviderNotification()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
    [*(id *)(*((void *)v1 + 6) + 16) unregister:*(void *)(*((void *)v1 + 6) + 8) forNotification:1];
    uint64_t result = [*(id *)(*((void *)v1 + 6) + 16) unregister:*(void *)(*((void *)v1 + 6) + 8) forNotification:3];
    v1[72] = 0;
  }
  return result;
}

BOOL sub_100FF2FB4(uint64_t a1, uint64_t *a2)
{
  *a2 = 0;
  if (!*((unsigned char *)sub_101069E58() + 12)) {
    *a2 |= 4uLL;
  }
  int v4 = sub_1001198CC();
  uint64_t v5 = *a2;
  if (v4 != 1)
  {
    v5 |= 1uLL;
    *a2 = v5;
  }
  if (*(_DWORD *)(a1 + 88) != 2)
  {
    *a2 = v5 | 2;
    uint64_t v5 = 1;
  }
  return v5 == 0;
}

void sub_100FF302C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v7 = *(void **)(a1 + 32);
  char v11 = 0;
  uint64_t v12 = 0;
  std::string __p = 0;
  sub_1001DD364(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  id v8 = sub_100FF3174((uint64_t)&__p);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100FF3340;
  v13[3] = &unk_10230A600;
  int v14 = a5;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100FF323C;
  v9[3] = &unk_1022BA9F0;
  v9[4] = a1;
  [v7 fetchQueryLocationsForWifis:v8 useCache:1 piggyback:1 config:[v13 copy] withReply:v9];
  if (__p)
  {
    char v11 = __p;
    operator delete(__p);
  }
}

void sub_100FF3158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100FF3174(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100FF32F0;
  v3[3] = &unk_10230A5D0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  std::string __p = 0;
  sub_1001DD364(&__p, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  id v1 = [v3 copy];
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }
  return v1;
}

void sub_100FF3220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF323C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 40) + 32))();
}

uint64_t sub_100FF3268(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))();
}

void sub_100FF3290(id a1)
{
  qword_102419588 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100FF32C0(id a1)
{
  qword_1024191E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

void *sub_100FF32F0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1001DD364(a2, *(const void **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3);
}

void *sub_100FF330C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  uint64_t v2 = (void *)(a1 + 32);
  v2[2] = 0;
  return sub_1001DD364(v2, *(const void **)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
}

void sub_100FF3328(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = v2;
    operator delete(v2);
  }
}

uint64_t sub_100FF3340(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

void sub_100FF3348()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241AD20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241AD20))
  {
    qword_10241AD08 = 0;
    qword_10241AD10 = 0;
    qword_10241AD18 = 0;
    __cxa_atexit((void (*)(void *))sub_1003BE920, &qword_10241AD08, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241AD20);
  }
}

void sub_100FF33C8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241ADD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241ADD0))
  {
    std::__shared_mutex_base::__shared_mutex_base(&stru_10241AD28);
    __cxa_atexit((void (*)(void *))sub_1003BE954, &stru_10241AD28, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241ADD0);
  }
}

void sub_100FF3458(_Unwind_Exception *a1)
{
}

uint64_t sub_100FF36F8(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) > 20)
    {
      if (v12 == 21)
      {
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v16 = 0;
        *(unsigned char *)(a1 + 36) |= 1u;
        while (1)
        {
          unint64_t v22 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v22 == -1 || v22 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v22);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v22 + 1;
          v16 |= (unint64_t)(v23 & 0x7F) << v20;
          if ((v23 & 0x80) == 0) {
            goto LABEL_47;
          }
          v20 += 7;
          BOOL v9 = v21++ >= 9;
          if (v9)
          {
            LODWORD(v16) = 0;
            goto LABEL_49;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_47:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_49:
        uint64_t v25 = 8;
      }
      else
      {
        if (v12 != 22)
        {
LABEL_40:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        char v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = 0;
        *(unsigned char *)(a1 + 36) |= 2u;
        while (1)
        {
          unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v17 == -1 || v17 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v18 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 1;
          v16 |= (unint64_t)(v18 & 0x7F) << v14;
          if ((v18 & 0x80) == 0) {
            goto LABEL_43;
          }
          v14 += 7;
          BOOL v9 = v15++ >= 9;
          if (v9)
          {
            LODWORD(v16) = 0;
            goto LABEL_45;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_43:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_45:
        uint64_t v25 = 32;
      }
      *(_DWORD *)(a1 + v25) = v16;
    }
    else if (v12 == 1)
    {
      String = (void *)PBReaderReadString();

      *(void *)(a1 + 24) = String;
    }
    else
    {
      if (v12 != 2) {
        goto LABEL_40;
      }
      int v13 = objc_alloc_init(ALSLocation);

      *(void *)(a1 + 16) = v13;
      if (!PBReaderPlaceMark() || (sub_100F95DD8((uint64_t)v13, a2) & 1) == 0) {
        return 0;
      }
      PBReaderRecallMark();
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void *sub_100FF3F40(void *a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = sub_1011C08D4((uint64_t)a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = off_10230A630;
  *(unsigned char *)(v8 + 20sub_100FB8FC8(&a9, 0) = 0;
  BOOL v9 = _os_activity_create((void *)&_mh_execute_header, "CL: CLDaemonFullAccuracySession(ctor) #clfas", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v9, &state);

  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A6B8);
  }
  int v10 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = a1[2];
    *(_DWORD *)uint64_t buf = 68289794;
    int v17 = 0;
    __int16 v18 = 2082;
    uint64_t v19 = "";
    __int16 v20 = 2082;
    unsigned int v21 = "activity";
    __int16 v22 = 2114;
    uint64_t v23 = v11;
    __int16 v24 = 2050;
    uint64_t v25 = a1;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLDaemonFullAccuracySession(ctor) #clfas\", \"event\":%{public, location:escape_only}s, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x30u);
  }
  uint64_t v12 = a1[3];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  int v14[2] = sub_100FF4140;
  _OWORD v14[3] = &unk_1022BF730;
  std::bad_cast v14[4] = a1;
  sub_1007B39D0(v12, (uint64_t)v14);
  a1[23] = [a4 objectForKeyedSubscript:@"kCLConnectionMessagePurposeKey"];
  sub_100FF4414((uint64_t)a1);
  os_activity_scope_leave(&state);
  return a1;
}

void sub_100FF4124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  sub_1011C0F50(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100FF4140(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ((*(unsigned int (**)(const void *))(*(void *)a2 + 24))(a2) != 5) {
    return 0;
  }
  unsigned int v4 = [*(id *)(v3 + 16) isEqual:sub_10014D19C((uint64_t)a2)];
  if (!v4 || v5 == 0) {
    return 0;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_10230A6D8);
  }
  uint64_t v8 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24))(a2);
    uint64_t v10 = *(void *)(v3 + 16);
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    int v17 = "";
    __int16 v18 = 1026;
    int v19 = v9;
    __int16 v20 = 2114;
    uint64_t v21 = v10;
    __int16 v22 = 2050;
    uint64_t v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#clfas consumeMatchingButterfly\", \"dicType\":%{public}d, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", (uint8_t *)&v14, 0x2Cu);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A6D8);
    }
  }
  uint64_t v11 = qword_102419538;
  if (os_signpost_enabled((os_log_t)qword_102419538))
  {
    int v12 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24))(a2);
    uint64_t v13 = *(void *)(v3 + 16);
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    int v17 = "";
    __int16 v18 = 1026;
    int v19 = v12;
    __int16 v20 = 2114;
    uint64_t v21 = v13;
    __int16 v22 = 2050;
    uint64_t v23 = v3;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#clfas consumeMatchingButterfly", "{\"msg%{public}.0s\":\"#clfas consumeMatchingButterfly\", \"dicType\":%{public}d, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", (uint8_t *)&v14, 0x2Cu);
  }
  return 1;
}

void sub_100FF4414(uint64_t a1)
{
  if (sub_1011C38AC(a1))
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230A6B8);
    }
    uint64_t v2 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2114;
      *(void *)&buf[20] = v3;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#clfas trying WIU #AutoPrompt-ing\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
    sub_1011C3A24(a1);
  }
  sub_1011C3B0C((id *)a1);
  unint64_t v4 = (unint64_t)[*(id *)(a1 + 40) diagnosticMask];
  BOOL v5 = [*(id *)(a1 + 40) transientAwareRegistrationResult] != 1
    && [*(id *)(a1 + 40) registrationResult] != 8
    && [*(id *)(a1 + 40) registrationResult] != 0;
  unsigned int v6 = [*(id *)(a1 + 40) isAuthorizedForServiceType:12];
  uint64_t v7 = (v4 >> 11) & 1;
  if (!(((sub_1011C0EB4(a1) || v5) | v6) & 1 | (v4 >> 11) & 1))
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230A6B8);
    }
    uint64_t v8 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2114;
      *(void *)&buf[20] = v9;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#clfas trying FullAccuracy Prompt\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
    *(unsigned char *)(a1 + 20sub_100FB8FC8(&a9, 0) = 1;
    if (!sub_1011C2EC4(a1, 9))
    {
      uint64_t v10 = *(void **)(a1 + 184);
      if (v10) {
        sub_100134750(buf, (char *)[v10 UTF8String]);
      }
      else {
        sub_100134750(buf, "");
      }
      id v11 = [*(id *)(a1 + 32) silo];
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3321888768;
      uint64_t v12[2] = sub_100FF4D1C;
      v12[3] = &unk_1022A5828;
      v12[4] = a1;
      if ((buf[23] & 0x80000000) != 0)
      {
        sub_1000DC48C(&__p, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long __p = *(_OWORD *)buf;
        uint64_t v14 = *(void *)&buf[16];
      }
      [v11 async:v12];
      if (SHIBYTE(v14) < 0) {
        operator delete((void *)__p);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  if (*(unsigned char *)(a1 + 200) && v6 | v7) {
    *(unsigned char *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  }
  sub_1011C3CD8(a1);
}

void sub_100FF4754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF4794(void *a1)
{
  *a1 = off_10230A630;
  sub_1011C2B50();

  return sub_1011C0F50((uint64_t)a1);
}

void sub_100FF47F4(void *a1)
{
  sub_100FF4794(a1);

  operator delete();
}

void sub_100FF482C(uint64_t a1, CLConnectionMessage **a2)
{
  unint64_t v4 = (void *)CLConnectionMessage::name(*a2);
  int v5 = *((char *)v4 + 23);
  if (v5 < 0)
  {
    if (v4[1] != 44) {
      goto LABEL_7;
    }
    unint64_t v4 = (void *)*v4;
  }
  else if (v5 != 44)
  {
    goto LABEL_7;
  }
  if (!memcmp(v4, "kCLConnectionMessageDestroyUponDisconnection", 0x2CuLL))
  {
    *(unsigned char *)(a1 + 48) = 1;
    return;
  }
LABEL_7:
  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A6B8);
  }
  unsigned int v6 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v8 = CLConnectionMessage::name(*a2);
    uint64_t v9 = *(char *)(v8 + 23) >= 0 ? v8 : *(void *)v8;
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2114;
    uint64_t v19 = v7;
    __int16 v20 = 2050;
    uint64_t v21 = a1;
    __int16 v22 = 2082;
    uint64_t v23 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning #clfas received unhandled message\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"message\":%{public, location:escape_only}s}", (uint8_t *)&v14, 0x30u);
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230A6B8);
    }
  }
  uint64_t v10 = qword_102419528;
  if (os_signpost_enabled((os_log_t)qword_102419528))
  {
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = CLConnectionMessage::name(*a2);
    if (*(char *)(v12 + 23) >= 0) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = *(void *)v12;
    }
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2114;
    uint64_t v19 = v11;
    __int16 v20 = 2050;
    uint64_t v21 = a1;
    __int16 v22 = 2082;
    uint64_t v23 = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning #clfas received unhandled message", "{\"msg%{public}.0s\":\"#Warning #clfas received unhandled message\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"message\":%{public, location:escape_only}s}", (uint8_t *)&v14, 0x30u);
  }
}

uint64_t sub_100FF4A74()
{
  return 5;
}

uint64_t sub_100FF4A7C()
{
  return 14359;
}

void sub_100FF4A84(uint64_t a1)
{
  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A6B8);
  }
  uint64_t v2 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    int v6 = 68289538;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2114;
    uint64_t v11 = v3;
    __int16 v12 = 2050;
    uint64_t v13 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#clfas authContext has changed\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", (uint8_t *)&v6, 0x26u);
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230A6B8);
    }
  }
  unint64_t v4 = qword_102419528;
  if (os_signpost_enabled((os_log_t)qword_102419528))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    int v6 = 68289538;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2114;
    uint64_t v11 = v5;
    __int16 v12 = 2050;
    uint64_t v13 = a1;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#clfas authContext has changed", "{\"msg%{public}.0s\":\"#clfas authContext has changed\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", (uint8_t *)&v6, 0x26u);
  }
  sub_100FF4414(a1);
}

uint64_t sub_100FF4C34(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

NSDictionary *sub_100FF4C3C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  v3[1] = @"SDKAtLeast2024";
  v4[0] = v1;
  v3[0] = @"kCLConnectionMessagePurposeKey";
  v4[1] = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 80)];
  return +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:2];
}

BOOL sub_100FF4CD0(uint64_t a1)
{
  return ([*(id *)(a1 + 40) diagnosticMask] & 0x800) != 0
      || [*(id *)(a1 + 40) registrationResult] == 2;
}

uint64_t sub_100FF4D14(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

void sub_100FF4D1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 16);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_1000DC48C(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 56);
  }
  sub_1007E1DB0((uint64_t)v5, 9, v2, 0, (long long *)__p);
  sub_1011C326C(v1, v5, 0);
  sub_1007E1E64((uint64_t)v5);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FF4DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FF4DE0(id a1)
{
  qword_102419528 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_100FF4E10(id a1)
{
  qword_102419538 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_100FF4E40(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = (uint64_t *)(a1 + 672);
  if (a2) {
    char v5 = sub_1008813E8(v4, a3);
  }
  else {
    char v5 = sub_10088169C(v4, a3);
  }
  if (*(void *)(a1 + 24)) {
    sub_100180260(a1, v5);
  }
  return 1;
}

double sub_100FF4E94(void *a1, int a2, __n128 *a3)
{
  switch(a2)
  {
    case 0:
      *(void *)&double result = sub_100FF4F04(a1 + 7, a3).n128_u64[0];
      break;
    case 1:
      *(void *)&double result = sub_100FF52CC(a1 + 47, (uint64_t)a3).n128_u64[0];
      break;
    case 2:
      *(void *)&double result = sub_100FF5674(a1 + 27, a3).n128_u64[0];
      break;
    case 3:
      *(void *)&double result = sub_100FF5A18(a1 + 67, a3).n128_u64[0];
      break;
    default:
      return result;
  }
  return result;
}

__n128 sub_100FF4F04(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FF4FB4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __int16 v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *__int16 v8 = result;
  ++a1[5];
  return result;
}

void sub_100FF4FB4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int16 v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C(v5, v33);
      id v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int16 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        id v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)id v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    __int16 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFF0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFF0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    id v44 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      id v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      unsigned int v48 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int16 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        __int16 v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  __int32 v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0xFF0uLL);
  sub_1000DA434(&v54, &v53);
  __int16 v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FF5280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100FF52CC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FF535C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __int16 v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *__int16 v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100FF535C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int16 v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C(v5, v33);
      id v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int16 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        id v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)id v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    __int16 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    id v44 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      id v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      unsigned int v48 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int16 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        __int16 v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  __int32 v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  __int16 v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FF5628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100FF5674(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FF5700(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100FF5700(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int16 v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C(v5, v33);
      id v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int16 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        id v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)id v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    __int16 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    id v44 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      id v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      unsigned int v48 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int16 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        __int16 v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  __int32 v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  __int16 v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FF59CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100FF5A18(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100FF5AC8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __int16 v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *__int16 v8 = result;
  ++a1[5];
  return result;
}

void sub_100FF5AC8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int16 v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C(v5, v33);
      id v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int16 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        id v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)id v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    __int16 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFF0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFF0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    id v44 = (void *)a1[1];
    __int16 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      id v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      unsigned int v48 = (uint64_t *)a1[1];
      __int16 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int16 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        __int16 v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  __int32 v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0xFF0uLL);
  sub_1000DA434(&v54, &v53);
  __int16 v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FF5D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FF5DE0(uint64_t result, char a2, double a3, double a4)
{
  *(double *)__n128 result = a3;
  *(double *)(result + 8) = a4;
  *(unsigned char *)(result + 16) = a2;
  return result;
}

uint64_t sub_100FF5DEC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

__n128 sub_100FF5DF4(uint64_t a1, _OWORD *a2, __n128 *a3)
{
  *(_OWORD *)a1 = *a2;
  __n128 result = *a3;
  *(__n128 *)(a1 + 16) = *a3;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  return result;
}

void sub_100FF5E10(void *a1, long long *a2)
{
  unint64_t v6 = a1[6];
  uint64_t v4 = (uint64_t)(a1 + 6);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (void **)(v4 - 16);
    uint64_t v11 = *(void *)(v4 - 16);
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v11) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - v11) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      uint64_t v16 = (char *)sub_1000DA5D8(v4, v15);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v17 = &v16[24 * v12];
    uint64_t v18 = &v16[24 * v15];
    long long v19 = *a2;
    *((void *)v17 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v17 = v19;
    uint64_t v9 = v17 + 24;
    uint64_t v21 = (char *)a1[4];
    int64_t v20 = (char *)a1[5];
    if (v20 != v21)
    {
      do
      {
        long long v22 = *(_OWORD *)(v20 - 24);
        *(v17 - 8) = *(v20 - 8);
        *(_OWORD *)(v17 - 24) = v22;
        v17 -= 24;
        v20 -= 24;
      }
      while (v20 != v21);
      int64_t v20 = (char *)*v10;
    }
    a1[4] = v17;
    a1[5] = v9;
    a1[6] = v18;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    uint64_t v9 = (char *)(v7 + 24);
  }
  a1[5] = v9;
}

BOOL sub_100FF5F3C(double *a1, uint64_t a2)
{
  double v2 = *(double *)(a2 + 4);
  if (v2 <= *a1 && v2 >= a1[2] && (double v3 = *(double *)(a2 + 12), v3 >= a1[1])) {
    return v3 <= a1[3];
  }
  else {
    return 0;
  }
}

uint64_t sub_100FF5F80(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_100FF5F88()
{
  sub_10010F274((uint64_t)v10);
  sub_100132EFC(v11, (uint64_t)"Market, Bounds", 14);
  uint64_t v0 = sub_100132EFC(v11, (uint64_t)", nwLat, ", 9);
  uint64_t v1 = *v0;
  *(uint64_t *)((char *)v0 + *(void *)(*v0 - 24) + 24) = 13;
  *(uint64_t *)((char *)v0 + *(void *)(v1 - 24) + 16) = 8;
  *(_DWORD *)((char *)v0 + *(void *)(v1 - 24) + 8) = *(_DWORD *)((unsigned char *)v0 + *(void *)(v1 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  double v2 = sub_100132EFC(v11, (uint64_t)", nwLon, ", 9);
  uint64_t v3 = *v2;
  *(uint64_t *)((char *)v2 + *(void *)(*v2 - 24) + 24) = 13;
  *(uint64_t *)((char *)v2 + *(void *)(v3 - 24) + 16) = 8;
  *(_DWORD *)((char *)v2 + *(void *)(v3 - 24) + 8) = *(_DWORD *)((unsigned char *)v2 + *(void *)(v3 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  uint64_t v4 = sub_100132EFC(v11, (uint64_t)", seLat, ", 9);
  uint64_t v5 = *v4;
  *(uint64_t *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 13;
  *(uint64_t *)((char *)v4 + *(void *)(v5 - 24) + 16) = 8;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v4 + *(void *)(v5 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  unint64_t v6 = sub_100132EFC(v11, (uint64_t)", seLon, ", 9);
  uint64_t v7 = *v6;
  *(uint64_t *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 13;
  *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 16) = 8;
  *(_DWORD *)((char *)v6 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(v7 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  std::stringbuf::str();
  *(void *)((char *)v10
  v11[0] = v8;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100FF6344(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FF6368(uint64_t a1, int a2)
{
  *(void *)a1 = &off_10230A708;
  *(unsigned char *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a1 + 16;
  *(void *)(a1 + 24) = a1 + 16;
  *(void *)(a1 + 32) = 0;
  if (qword_102419010 != -1) {
    dispatch_once(&qword_102419010, &stru_10230A7F0);
  }
  uint64_t v4 = qword_102419018;
  if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Enabled, %d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230A7F0);
    }
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLMotionStateFilter::CLMotionStateFilter(BOOL)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  return a1;
}

void sub_100FF6550(_Unwind_Exception *a1)
{
  sub_1003B2350(v1);
  _Unwind_Resume(a1);
}

__n128 sub_100FF656C@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v6 = (uint64_t **)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7
      && ((int v8 = *v6, !*((unsigned char *)*v6 + 177))
       || (uint64_t v9 = *v8,
           *(void *)(v9 + 8) = v8[1],
           *(void *)v8[1] = v9,
           *(void *)(a1 + 32) = v7 - 1,
           operator delete(v8),
           (uint64_t v7 = *(void *)(a1 + 32)) != 0))
      && *((double *)*v6 + 3) > *(double *)(a2 + 8))
    {
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230A7F0);
      }
      uint64_t v10 = qword_102419018;
      if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = (*v6)[3];
        uint64_t v12 = *(void *)(a2 + 8);
        *(_DWORD *)uint64_t buf = 134218240;
        uint64_t v29 = v11;
        __int16 v30 = 2048;
        uint64_t v31 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Warning Time went backwards: Before - %f, Current - %f.  Clearing buffers and ignoring current entry.", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419010 != -1) {
          dispatch_once(&qword_102419010, &stru_10230A7F0);
        }
        __int16 v27 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMotionStateFilter::MotionState> CLMotionStateFilter::insert(const CLMotionStateFilter::MotionState &)", "%s\n", v27);
        if (v27 != (char *)buf) {
          free(v27);
        }
      }
      sub_1003B2350(v6);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
    else
    {
      unint64_t v14 = operator new(0xB8uLL);
      long long v15 = *(_OWORD *)(a2 + 112);
      v14[7] = *(_OWORD *)(a2 + 96);
      unsigned char v14[8] = v15;
      long long v16 = *(_OWORD *)(a2 + 144);
      v14[9] = *(_OWORD *)(a2 + 128);
      v14[10] = v16;
      long long v17 = *(_OWORD *)(a2 + 48);
      _OWORD v14[3] = *(_OWORD *)(a2 + 32);
      std::bad_cast v14[4] = v17;
      long long v18 = *(_OWORD *)(a2 + 80);
      void v14[5] = *(_OWORD *)(a2 + 64);
      v14[6] = v18;
      long long v19 = *(_OWORD *)(a2 + 16);
      v14[1] = *(_OWORD *)a2;
      int v14[2] = v19;
      *((_WORD *)v14 + 88) = 0;
      uint64_t v20 = *(void *)(a1 + 16);
      *(void *)unint64_t v14 = v20;
      *((void *)v14 + 1) = v6;
      *(void *)(v20 + 8) = v14;
      *(void *)(a1 + 16) = v14;
      *(void *)(a1 + 32) = v7 + 1;
      sub_100FF68A4(a1, (char **)a3);
    }
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v21 = operator new(0xA0uLL);
    *(void *)(a3 + 16) = v21 + 10;
    long long v22 = *(_OWORD *)(a2 + 112);
    v21[6] = *(_OWORD *)(a2 + 96);
    v21[7] = v22;
    long long v23 = *(_OWORD *)(a2 + 144);
    v21[8] = *(_OWORD *)(a2 + 128);
    v21[9] = v23;
    long long v24 = *(_OWORD *)(a2 + 48);
    uint64_t v21[2] = *(_OWORD *)(a2 + 32);
    v21[3] = v24;
    long long v25 = *(_OWORD *)(a2 + 80);
    _DWORD v21[4] = *(_OWORD *)(a2 + 64);
    v21[5] = v25;
    __n128 result = *(__n128 *)a2;
    long long v26 = *(_OWORD *)(a2 + 16);
    *uint64_t v21 = *(_OWORD *)a2;
    v21[1] = v26;
    *(void *)a3 = v21;
    *(void *)(a3 + 8) = v21 + 10;
  }
  return result;
}

void sub_100FF68A4(uint64_t a1@<X0>, char **a2@<X8>)
{
  unint64_t v4 = *(void *)(a1 + 32);
  double v5 = sub_1000D3E50();
  if (v4 >= 0x12D)
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230A7F0);
    }
    unint64_t v6 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)uint64_t buf = 134349312;
      uint64_t v16 = v7;
      __int16 v17 = 2050;
      double v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Excessive size detected, Begin Filter, Entries, %{public}lu, Time, %{public}lf", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230A7F0);
      }
      unint64_t v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::vector<CLMotionStateFilter::MotionState> CLMotionStateFilter::process()", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
  sub_100FF6C40(a1);
  double v8 = sub_1000D3E50();
  if (v4 >= 0x12D)
  {
    double v9 = v8;
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230A7F0);
    }
    uint64_t v10 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      double v12 = sub_1000D3E50();
      *(_DWORD *)uint64_t buf = 134349568;
      uint64_t v16 = v11;
      __int16 v17 = 2050;
      double v18 = v12;
      __int16 v19 = 2050;
      double v20 = v9 - v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Excessive size detected, End Filter, Entries, %{public}lu, Time, %{public}lf, Duration, %{public}.6lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230A7F0);
      }
      sub_1000D3E50();
      unint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::vector<CLMotionStateFilter::MotionState> CLMotionStateFilter::process()", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
  }
  sub_100FF6D04(a1, a2);
}

uint64_t sub_100FF6C40(uint64_t result)
{
  if (*(void *)(result + 32) >= 2uLL)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(void *)(result + 16);
    uint64_t v3 = *(void *)(*(void *)(result + 24) + 8);
    while (v3 != v2)
    {
      if (*(unsigned char *)(v3 + 176)) {
        goto LABEL_6;
      }
      if (*(unsigned char *)(v3 + 177))
      {
        uint64_t v4 = sub_101A9C2C0();
        return sub_100FF6D04(v4);
      }
      sub_100FF7904(v5, (uint64_t)(v1 + 2), v3, *(void *)(v3 + 8));
      __n128 result = (*(uint64_t (**)(void *, void *))(*v1 + 16))(v1, v5);
      if (result)
      {
        uint64_t v2 = v1[2];
        uint64_t v3 = *(void *)(v1[3] + 8);
      }
      else
      {
LABEL_6:
        uint64_t v3 = *(void *)(v3 + 8);
      }
    }
  }
  return result;
}

void sub_100FF6D04(uint64_t a1@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = a1 + 16;
  if (v3 != a1 + 16)
  {
    double v6 = *(double *)(*(void *)(a1 + 16) + 24) + -75.0;
    do
    {
      uint64_t v7 = v3;
      while (*(unsigned char *)(v7 + 176))
      {
        uint64_t v7 = *(void *)(v7 + 8);
        if (v7 == v4) {
          return;
        }
      }
      if (v7 == v4 || *(double *)(v7 + 24) >= v6) {
        break;
      }
      if (!*(unsigned char *)(v7 + 177))
      {
        double v8 = (_OWORD *)(v7 + 16);
        uint64_t v10 = a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          __int16 v19 = *a2;
          unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - *a2) >> 5);
          unint64_t v21 = v20 + 1;
          if (v20 + 1 > 0x199999999999999) {
            sub_1001D7FD4();
          }
          unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - (void)v19) >> 5);
          if (2 * v22 > v21) {
            unint64_t v21 = 2 * v22;
          }
          if (v22 >= 0xCCCCCCCCCCCCCCLL) {
            unint64_t v23 = 0x199999999999999;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23)
          {
            long long v24 = (char *)sub_1004F46B0((uint64_t)(a2 + 2), v23);
            __int16 v19 = *a2;
            uint64_t v10 = a2[1];
          }
          else
          {
            long long v24 = 0;
          }
          long long v25 = &v24[160 * v20];
          long long v26 = *(_OWORD *)(v7 + 32);
          *(_OWORD *)long long v25 = *v8;
          *((_OWORD *)v25 + 1) = v26;
          long long v27 = *(_OWORD *)(v7 + 48);
          long long v28 = *(_OWORD *)(v7 + 64);
          long long v29 = *(_OWORD *)(v7 + 96);
          *((_OWORD *)v25 + 4) = *(_OWORD *)(v7 + 80);
          *((_OWORD *)v25 + 5) = v29;
          *((_OWORD *)v25 + 2) = v27;
          *((_OWORD *)v25 + 3) = v28;
          long long v30 = *(_OWORD *)(v7 + 112);
          long long v31 = *(_OWORD *)(v7 + 128);
          long long v32 = *(_OWORD *)(v7 + 160);
          *((_OWORD *)v25 + 8) = *(_OWORD *)(v7 + 144);
          *((_OWORD *)v25 + 9) = v32;
          *((_OWORD *)v25 + 6) = v30;
          *((_OWORD *)v25 + 7) = v31;
          if (v10 == v19)
          {
            id v41 = &v24[160 * v20];
          }
          else
          {
            unint64_t v33 = &v24[160 * v20];
            do
            {
              long long v34 = *((_OWORD *)v10 - 9);
              *((_OWORD *)v33 - 1sub_100FB8FC8(&a9, 0) = *((_OWORD *)v10 - 10);
              *((_OWORD *)v33 - 9) = v34;
              long long v35 = *((_OWORD *)v10 - 8);
              long long v36 = *((_OWORD *)v10 - 7);
              long long v37 = *((_OWORD *)v10 - 5);
              *((_OWORD *)v33 - 6) = *((_OWORD *)v10 - 6);
              *((_OWORD *)v33 - 5) = v37;
              *((_OWORD *)v33 - 8) = v35;
              *((_OWORD *)v33 - 7) = v36;
              long long v38 = *((_OWORD *)v10 - 4);
              long long v39 = *((_OWORD *)v10 - 3);
              long long v40 = *((_OWORD *)v10 - 1);
              id v41 = v33 - 160;
              *((_OWORD *)v33 - 2) = *((_OWORD *)v10 - 2);
              *((_OWORD *)v33 - 1) = v40;
              *((_OWORD *)v33 - 4) = v38;
              *((_OWORD *)v33 - 3) = v39;
              v10 -= 160;
              v33 -= 160;
            }
            while (v10 != v19);
          }
          double v18 = v25 + 160;
          *a2 = v41;
          a2[1] = v25 + 160;
          a2[2] = &v24[160 * v23];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          long long v11 = *(_OWORD *)(v7 + 32);
          *(_OWORD *)uint64_t v10 = *v8;
          *((_OWORD *)v10 + 1) = v11;
          long long v12 = *(_OWORD *)(v7 + 48);
          long long v13 = *(_OWORD *)(v7 + 64);
          long long v14 = *(_OWORD *)(v7 + 96);
          *((_OWORD *)v10 + 4) = *(_OWORD *)(v7 + 80);
          *((_OWORD *)v10 + 5) = v14;
          *((_OWORD *)v10 + 2) = v12;
          *((_OWORD *)v10 + 3) = v13;
          long long v15 = *(_OWORD *)(v7 + 112);
          long long v16 = *(_OWORD *)(v7 + 128);
          long long v17 = *(_OWORD *)(v7 + 160);
          *((_OWORD *)v10 + 8) = *(_OWORD *)(v7 + 144);
          *((_OWORD *)v10 + 9) = v17;
          *((_OWORD *)v10 + 6) = v15;
          *((_OWORD *)v10 + 7) = v16;
          double v18 = v10 + 160;
        }
        a2[1] = v18;
        uint64_t v3 = *(void *)(a1 + 24);
      }
      if (*(unsigned char *)(v3 + 176))
      {
        sub_1005AED4C(v4, (uint64_t *)v3, (uint64_t *)v7);
        *(unsigned char *)(v7 + 176) = 1;
        uint64_t v3 = *(void *)(a1 + 24);
      }
      else
      {
        *(unsigned char *)(v7 + 176) = 1;
      }
    }
    while (v3 != v4);
  }
}

void sub_100FF6F44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF6F68(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = a1 + 16;
    uint64_t v7 = *(void *)(a1 + 16);
    if (*(double *)(v7 + 24) <= a3) {
      double v8 = a3;
    }
    else {
      double v8 = *(double *)(v7 + 24);
    }
    if (*(unsigned char *)(v7 + 177))
    {
      *(double *)(v7 + 24) = v8;
    }
    else
    {
      uint64_t v9 = *(void *)(v7 + 16);
      long long v19 = *(_OWORD *)(v7 + 128);
      long long v20 = *(_OWORD *)(v7 + 144);
      long long v21 = *(_OWORD *)(v7 + 160);
      char v22 = *(unsigned char *)(v7 + 176);
      long long v15 = *(_OWORD *)(v7 + 64);
      long long v16 = *(_OWORD *)(v7 + 80);
      long long v17 = *(_OWORD *)(v7 + 96);
      long long v18 = *(_OWORD *)(v7 + 112);
      long long v13 = *(_OWORD *)(v7 + 32);
      long long v14 = *(_OWORD *)(v7 + 48);
      int v11 = *(_DWORD *)(v7 + 178);
      __int16 v12 = *(_WORD *)(v7 + 182);
      uint64_t v10 = (char *)operator new(0xB8uLL);
      *((void *)v10 + 2) = v9;
      *((double *)v10 + 3) = v8;
      *((_OWORD *)v10 + 8) = v19;
      *((_OWORD *)v10 + 9) = v20;
      *((_OWORD *)v10 + 1sub_100FB8FC8(&a9, 0) = v21;
      v10[176] = v22;
      *((_OWORD *)v10 + 4) = v15;
      *((_OWORD *)v10 + 5) = v16;
      *((_OWORD *)v10 + 6) = v17;
      *((_OWORD *)v10 + 7) = v18;
      *((_OWORD *)v10 + 2) = v13;
      *((_OWORD *)v10 + 3) = v14;
      v10[177] = 1;
      *(_DWORD *)(v10 + 178) = v11;
      *((_WORD *)v10 + 91) = v12;
      *(void *)uint64_t v10 = v7;
      *((void *)v10 + 1) = v6;
      *(void *)(v7 + 8) = v10;
      *(void *)(a1 + 16) = v10;
      *(void *)(a1 + 32) = v4 + 1;
    }
    sub_100FF68A4(a1, (char **)a2);
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

void sub_100FF7114(uint64_t a1, uint64_t *a2)
{
  if (a2[1] == *(void *)(*a2 + 8))
  {
    long long v16 = (uint64_t *)sub_101A9C430();
    sub_100FF7590(v16, v17);
    return;
  }
  sub_100FF7590(a2, &v25);
  uint64_t v3 = v26;
  uint64_t v4 = a2[1];
  int v5 = *(_DWORD *)(v4 + 40);
  if (*(_DWORD *)(v26 + 40) == v5)
  {
    if (v26 != v27)
    {
      for (uint64_t i = *(void *)(v26 + 8); i != v27; uint64_t i = *(void *)(i + 8))
      {
        if (*(unsigned __int8 *)(i + 44) < *(unsigned __int8 *)(v3 + 44)) {
          uint64_t v3 = i;
        }
      }
    }
    int v7 = *(unsigned __int8 *)(v3 + 44);
    double v8 = (uint64_t *)a2[2];
    uint64_t v9 = a2[1];
    if ((uint64_t *)v4 != v8)
    {
      uint64_t v10 = *(void *)(v4 + 8);
      uint64_t v9 = a2[1];
      if ((uint64_t *)v10 != v8)
      {
        uint64_t v9 = a2[1];
        do
        {
          if (*(unsigned __int8 *)(v10 + 44) < *(unsigned __int8 *)(v9 + 44)) {
            uint64_t v9 = v10;
          }
          uint64_t v10 = *(void *)(v10 + 8);
        }
        while ((uint64_t *)v10 != v8);
      }
    }
    if (v7 == *(unsigned __int8 *)(v9 + 44))
    {
      uint64_t v11 = *a2;
LABEL_17:
      sub_1005AED4C(v11, (uint64_t *)v4, v8);
      return;
    }
  }
  if (v5 == 32 || (*(_DWORD *)(v4 + 40) & 0x70) != 0)
  {
    sub_100FF7678((uint64_t **)a2, (uint64_t)&stru_10230A740, &v25);
    if (v26 != *(void *)(v25 + 8) && *(void *)(v27 + 8) != v25)
    {
      sub_100FF7590(&v25, &v22);
      if (*(_DWORD *)(v23 + 40) != 32 && (*(_DWORD *)(v23 + 40) & 0x70) == 0)
      {
        sub_100FF75D0(&v25, &v19);
        int v15 = *(_DWORD *)(v20 + 40);
        if (v15 != 32 && (v15 & 0x70) == 0)
        {
          sub_100FF7590(&v25, &v19);
          sub_100FF7678(&v19, (uint64_t)&stru_10230A7A0, &v22);
          sub_100FF75D0(&v25, v18);
          sub_100FF7678(v18, (uint64_t)&stru_10230A7A0, &v19);
          if (*(double *)(v24 + 24) - *(double *)(v23 + 24) > 10.0)
          {
            uint64_t v4 = v26;
            double v8 = (uint64_t *)v27;
            if (*(double *)(v27 + 24) - *(double *)(v26 + 24) < 5.0
              && *(double *)(v21 + 24) - *(double *)(v20 + 24) > 10.0)
            {
              goto LABEL_55;
            }
          }
        }
      }
    }
    int v5 = *(_DWORD *)(a2[1] + 40);
  }
  if ((v5 & 0x7300) != 0)
  {
    sub_100FF7678((uint64_t **)a2, (uint64_t)&stru_10230A760, &v25);
    if (v26 != *(void *)(v25 + 8) && *(void *)(v27 + 8) != v25)
    {
      sub_100FF7590(&v25, &v22);
      if ((*(unsigned char *)(v23 + 41) & 0x73) == 0)
      {
        sub_100FF75D0(&v25, &v19);
        if ((*(_DWORD *)(v20 + 40) & 0x7300) == 0)
        {
          sub_100FF7590(&v25, &v19);
          sub_100FF7678(&v19, (uint64_t)&stru_10230A780, &v22);
          sub_100FF75D0(&v25, v18);
          sub_100FF7678(v18, (uint64_t)&stru_10230A780, &v19);
          if (*(double *)(v24 + 24) - *(double *)(v23 + 24) > 25.0)
          {
            uint64_t v4 = v26;
            double v8 = (uint64_t *)v27;
            if (*(double *)(v27 + 24) - *(double *)(v26 + 24) < 20.0
              && *(double *)(v21 + 24) - *(double *)(v20 + 24) > 25.0)
            {
              goto LABEL_55;
            }
          }
        }
      }
    }
    int v5 = *(_DWORD *)(a2[1] + 40);
  }
  if ((v5 & 0x7300) != 0) {
    goto LABEL_45;
  }
  sub_100FF7678((uint64_t **)a2, (uint64_t)&stru_10230A780, &v25);
  if (v26 != *(void *)(v25 + 8) && *(void *)(v27 + 8) != v25)
  {
    sub_100FF7590(&v25, &v22);
    sub_100FF75D0(&v25, &v19);
    if ((*(unsigned char *)(v23 + 41) & 0x73) != 0)
    {
      uint64_t v4 = v26;
      double v8 = (uint64_t *)v27;
      if (*(double *)(v27 + 24) - *(double *)(v26 + 24) < 15.0 && (*(unsigned char *)(v20 + 41) & 0x73) != 0)
      {
LABEL_55:
        uint64_t v11 = v25;
        goto LABEL_17;
      }
    }
  }
  int v5 = *(_DWORD *)(a2[1] + 40);
LABEL_45:
  if (v5 == 16 || v5 == 4)
  {
    sub_100FF7678((uint64_t **)a2, (uint64_t)&stru_10230A7C0, &v25);
    if (v26 != *(void *)(v25 + 8) && *(void *)(v27 + 8) != v25)
    {
      sub_100FF7590(&v25, &v22);
      sub_100FF75D0(&v25, &v19);
      if (*(_DWORD *)(v23 + 40) == 64)
      {
        uint64_t v4 = v26;
        double v8 = (uint64_t *)v27;
        if (*(double *)(v27 + 24) - *(double *)(v26 + 24) < 8.0 && *(_DWORD *)(v20 + 40) == 64) {
          goto LABEL_55;
        }
      }
    }
  }
}

void sub_100FF7590(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (uint64_t *)a1[1];
  if (v3 == *(uint64_t **)(*a1 + 8))
  {
    uint64_t v5 = sub_101A9C5A0();
    sub_100FF75D0(v5);
  }
  else
  {
    uint64_t v4 = *v3;
    sub_100FF7904(a2, v2, v4, (uint64_t)v3);
  }
}

void sub_100FF75D0(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = *(void *)(v2 + 8);
  uint64_t v4 = *a1;
  if (v3 == *a1)
  {
    uint64_t v5 = sub_101A9C708();
    sub_100FF7610(v5, v6);
  }
  else
  {
    sub_100FF7904(a2, v4, v2, v3);
  }
}

uint64_t sub_100FF7610(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = a1 + 16;
  for (uint64_t i = *(void *)(a1 + 24); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v2) {
      return 0;
    }
    if (!*(unsigned char *)(i + 176)) {
      break;
    }
  }
  if (i == v2 || *(unsigned char *)(i + 177)) {
    return 0;
  }
  long long v5 = *(_OWORD *)(i + 32);
  *a2 = *(_OWORD *)(i + 16);
  a2[1] = v5;
  long long v6 = *(_OWORD *)(i + 48);
  long long v7 = *(_OWORD *)(i + 64);
  long long v8 = *(_OWORD *)(i + 96);
  a2[4] = *(_OWORD *)(i + 80);
  a2[5] = v8;
  a2[2] = v6;
  a2[3] = v7;
  long long v9 = *(_OWORD *)(i + 112);
  long long v10 = *(_OWORD *)(i + 128);
  long long v11 = *(_OWORD *)(i + 160);
  a2[8] = *(_OWORD *)(i + 144);
  a2[9] = v11;
  a2[6] = v9;
  a2[7] = v10;
  return 1;
}

void sub_100FF7678(uint64_t **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  long long v6 = *a1;
  long long v7 = a1[1];
  long long v8 = (uint64_t *)(*a1)[1];
  if (v8 != v7)
  {
    while ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, *v7 + 16))
    {
      long long v7 = (uint64_t *)*v7;
      if (v7 == v8)
      {
        long long v7 = v8;
        break;
      }
    }
    long long v6 = *a1;
  }
  uint64_t v9 = (uint64_t)a1[2];
  uint64_t v10 = *v6;
  if (*v6 != v9)
  {
    while (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v9 + 16) & 1) != 0)
    {
      uint64_t v9 = *(void *)(v9 + 8);
      if (v9 == v10) {
        goto LABEL_11;
      }
    }
    uint64_t v10 = v9;
LABEL_11:
    long long v6 = *a1;
  }

  sub_100FF7904(a3, (uint64_t)v6, (uint64_t)v7, v10);
}

BOOL sub_100FF7754(id a1, const void *a2)
{
  return ((*((_DWORD *)a2 + 6) - 16) < 0x31) & (0x1000000010001uLL >> (*((unsigned char *)a2 + 24) - 16));
}

BOOL sub_100FF7778(id a1, const void *a2)
{
  int v2 = *((_DWORD *)a2 + 6);
  BOOL result = 1;
  if (v2 > 4095)
  {
    if (v2 == 4096 || v2 == 0x2000 || v2 == 12288) {
      return result;
    }
    return 0;
  }
  if (v2 != 256 && v2 != 512) {
    return 0;
  }
  return result;
}

BOOL sub_100FF77BC(id a1, const void *a2)
{
  BOOL result = 0;
  int v3 = *((_DWORD *)a2 + 6);
  if (v3 > 4095)
  {
    if (v3 == 4096 || v3 == 0x2000 || v3 == 12288) {
      return result;
    }
    return 1;
  }
  if (v3 != 256 && v3 != 512) {
    return 1;
  }
  return result;
}

BOOL sub_100FF7800(id a1, const void *a2)
{
  int v2 = *((_DWORD *)a2 + 6);
  return (v2 & 0x70) == 0 && v2 != 32;
}

BOOL sub_100FF7818(id a1, const void *a2)
{
  int v2 = *((_DWORD *)a2 + 6);
  return v2 == 4 || v2 == 16;
}

void *sub_100FF782C(void *a1)
{
  *a1 = &off_10230A708;
  sub_1003B2350(a1 + 2);
  return a1;
}

void sub_100FF7870(void *a1)
{
  *a1 = &off_10230A708;
  sub_1003B2350(a1 + 2);

  operator delete();
}

void sub_100FF78D4(id a1)
{
  qword_102419018 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Activity");
}

void sub_100FF7904(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  if (a3 == a4)
  {
    uint64_t v4 = (void *)sub_101A9C878();
    sub_100FF792C(v4);
  }
}

void sub_100FF792C(id a1)
{
  qword_102419638 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

BOOL sub_100FF795C()
{
  uint64_t v1 = qword_102419018;
  return os_log_type_enabled(v1, OS_LOG_TYPE_FAULT);
}

BOOL sub_100FF797C()
{
  int v2 = *(NSObject **)(v0 + 24);
  return os_log_type_enabled(v2, OS_LOG_TYPE_INFO);
}

BOOL sub_100FF7998()
{
  int v2 = *(NSObject **)(v0 + 24);
  return os_signpost_enabled(v2);
}

void sub_100FF79B0(id a1)
{
  qword_102418FF8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100FF79E0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v13 = sub_1011C08D4(a1, a2, a3, a5, a4, a6);
  *(void *)uint64_t v13 = off_10230A8B8;
  *(unsigned char *)(v13 + 184) = 0;
  *(_OWORD *)(v13 + 192) = 0u;
  uint64_t v36 = v13 + 192;
  *(_OWORD *)(v13 + 24sub_100FB8FC8(&a9, 0) = 0u;
  long long v14 = (void **)(v13 + 240);
  uint64_t v35 = v13 + 216;
  *(_OWORD *)(v13 + 208) = 0u;
  *(_OWORD *)(v13 + 224) = 0u;
  int v15 = _os_activity_create((void *)&_mh_execute_header, "CL: #monitor(ctor)", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v15, &state);

  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A9B8);
  }
  unsigned int v34 = a7;
  long long v16 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    long long v17 = *(const char **)(a1 + 16);
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2082;
    *(void *)&buf[20] = "activity";
    __int16 v44 = 2114;
    uint64_t v45 = v17;
    __int16 v46 = 2050;
    uint64_t v47 = (const char *)a1;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor(ctor)\", \"event\":%{public, location:escape_only}s, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x30u);
  }
  id v18 = +[NSMutableDictionary dictionary];
  id v19 = [a5 objectForKeyedSubscript:@"kCLConnectionMessageMonitorNameKey"];
  id v20 = [a5 objectForKeyedSubscript:@"kCLConnectionMessageMonitorProcessNameKey"];
  if (!v19)
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    long long v30 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
    {
      id v31 = [0 UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v31;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "ledgerName";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor missing ledger name\", \"LedgerName\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
    }
    long long v32 = qword_102419538;
    if (os_signpost_enabled((os_log_t)qword_102419538))
    {
      id v33 = [0 UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v33;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "ledgerName";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor missing ledger name", "{\"msg%{public}.0s\":\"#monitor missing ledger name\", \"LedgerName\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
    }
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
      sub_101A9CA04((uint64_t)[0 UTF8String], (uint64_t)buf);
    }
    abort_report_np();
    goto LABEL_36;
  }
  uint64_t v21 = v20;
  uint64_t v38 = 0;
  long long v39 = &v38;
  uint64_t v40 = 0x2020000000;
  char v41 = 1;
  sub_100134750(buf, (char *)[v19 UTF8String]);
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)v36);
  }
  *(_OWORD *)uint64_t v36 = *(_OWORD *)buf;
  *(void *)(v36 + 16) = *(void *)&buf[16];
  sub_100134750(buf, (char *)[v21 UTF8String]);
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)v35);
  }
  *(_OWORD *)uint64_t v35 = *(_OWORD *)buf;
  *(void *)(v35 + 16) = *(void *)&buf[16];
  uint64_t v22 = *(void *)(a1 + 24);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472;
  v37[2] = sub_100FF8254;
  _OWORD v37[3] = &unk_10230A930;
  v37[4] = &v38;
  v37[5] = a1;
  sub_1007B39D0(v22, (uint64_t)v37);
  id v23 = sub_100FF876C(a1);
  if (*((unsigned char *)v39 + 24))
  {
    [v18 setObject:v19 forKeyedSubscript:@"kCLMonitorLedgerNameKey"];
    [v18 setObject:v21 forKeyedSubscript:@"kCLMonitorLedgerProcessNameKey"];
    id v24 = sub_1007BEB00(a4, (uint64_t)a2);
    if (v24)
    {
      [v18 setObject:v24 forKeyedSubscript:@"kCLMonitorLedgerAccessKey"];
      sub_10088BEFC(v14, [[CLDaemonConditionLedger alloc] initWithConfiguration:v18 clientKeyPath:a2 authorizationContext:*(void *)(a1 + 40) universe:a6 hasClassCAccess:v34 callbackHandler:v23]);
      goto LABEL_13;
    }
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    uint64_t v26 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
    {
      id v27 = [[[a2 clientKey] UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v27;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "clientStorageToken";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor client doesn't have the storage token\", \"clientKey\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
    }
    long long v28 = qword_102419538;
    if (os_signpost_enabled((os_log_t)qword_102419538))
    {
      id v29 = [[objc_msgSend(a2, "clientKey") UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v29;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "clientStorageToken";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor client doesn't have the storage token", "{\"msg%{public}.0s\":\"#monitor client doesn't have the storage token\", \"clientKey\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
    }
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_INFO)) {
      sub_101A9CA74([[objc_msgSend(objc_msgSend(a2, "clientKey")) UTF8String] UTF8String], (uint64_t)buf);
    }
    abort_report_np();
LABEL_36:
    __break(1u);
  }
LABEL_13:
  sub_100FF886C(a1);
  [*v14 updateCallbackHandler:v23];
  sub_100FF8ABC(a1);
  [*v14 validateClientMonitoringRecordsByIdenitifier:[a5 objectForKeyedSubscript:@"kCLConnectionMessageMonitorLedger"]];
  _Block_object_dispose(&v38, 8);
  os_activity_scope_leave(&state);
  return a1;
}

void sub_100FF81B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  sub_10048B098(v26);
  if (*(char *)(v25 + 239) < 0) {
    operator delete(*a13);
  }
  if (*(char *)(v25 + 215) < 0) {
    operator delete(*a14);
  }
  sub_1011C0F50(v25);
  _Unwind_Resume(a1);
}

uint64_t sub_100FF8254(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = sub_100FF8468(v4, a2);
  if (v5)
  {
    if (a2) {
    else
    }
      long long v6 = 0;
    sub_100FF86F0((uint64_t)v6, &v11);
    sub_10088BEFC((void **)(v4 + 240), v11);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(v4 + 240) == 0;
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    long long v7 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      int v8 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24))(a2);
      uint64_t v9 = *(void *)(v4 + 16);
      *(_DWORD *)uint64_t buf = 68289794;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 1026;
      int v17 = v8;
      __int16 v18 = 2114;
      uint64_t v19 = v9;
      __int16 v20 = 2050;
      uint64_t v21 = v4;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor consumeMatchingButterfly\", \"dicType\":%{public}d, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x2Cu);
    }
  }
  return v5;
}

void sub_100FF8434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100FF8468(uint64_t a1, const void *a2)
{
  unsigned int v4 = [*(id *)(a1 + 16) isEqual:sub_10014D19C((uint64_t)a2)];
  if ((*(unsigned int (**)(const void *))(*(void *)a2 + 24))(a2) != 4)
  {
    BOOL v7 = 0;
    return v4 & v7;
  }
  long long v6 = v5;
  if (v5[215] < 0)
  {
    sub_1000DC48C(__p, *((void **)v5 + 24), *((void *)v5 + 25));
  }
  else
  {
    *(_OWORD *)long long __p = *((_OWORD *)v5 + 12);
    uint64_t v31 = *((void *)v5 + 26);
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 215);
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = (void *)*(unsigned __int8 *)(a1 + 215);
  }
  else {
    uint64_t v9 = *(void **)(a1 + 200);
  }
  uint64_t v10 = (void *)HIBYTE(v31);
  char v11 = HIBYTE(v31);
  if (v31 < 0) {
    uint64_t v10 = __p[1];
  }
  if (v9 == v10)
  {
    __int16 v12 = (const void **)(a1 + 192);
    if (v31 >= 0) {
      int v13 = __p;
    }
    else {
      int v13 = (void **)__p[0];
    }
    if ((v8 & 0x80) != 0)
    {
      if (memcmp(*v12, v13, *(void *)(a1 + 200))) {
        goto LABEL_21;
      }
    }
    else if (*(unsigned char *)(a1 + 215))
    {
      while (*(unsigned __int8 *)v12 == *(unsigned __int8 *)v13)
      {
        __int16 v12 = (const void **)((char *)v12 + 1);
        int v13 = (void **)((char *)v13 + 1);
        if (!--v8) {
          goto LABEL_24;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    if (v6[239] < 0)
    {
      sub_1000DC48C(v28, *((void **)v6 + 27), *((void *)v6 + 28));
    }
    else
    {
      *(_OWORD *)long long v28 = *(_OWORD *)(v6 + 216);
      uint64_t v29 = *((void *)v6 + 29);
    }
    uint64_t v15 = *(unsigned __int8 *)(a1 + 239);
    if ((v15 & 0x80u) == 0) {
      __int16 v16 = (void *)*(unsigned __int8 *)(a1 + 239);
    }
    else {
      __int16 v16 = *(void **)(a1 + 224);
    }
    int v17 = (void *)HIBYTE(v29);
    int v18 = SHIBYTE(v29);
    if (v29 < 0) {
      int v17 = v28[1];
    }
    if (v16 == v17)
    {
      uint64_t v19 = (const void **)(a1 + 216);
      if (v29 >= 0) {
        __int16 v20 = v28;
      }
      else {
        __int16 v20 = (void **)v28[0];
      }
      if ((v15 & 0x80) != 0)
      {
        BOOL v7 = memcmp(*v19, v20, *(void *)(a1 + 224)) == 0;
        goto LABEL_48;
      }
      if (*(unsigned char *)(a1 + 239))
      {
        uint64_t v21 = v15 - 1;
        do
        {
          int v23 = *(unsigned __int8 *)v19;
          uint64_t v19 = (const void **)((char *)v19 + 1);
          int v22 = v23;
          int v25 = *(unsigned __int8 *)v20;
          __int16 v20 = (void **)((char *)v20 + 1);
          int v24 = v25;
          BOOL v27 = v21-- != 0;
          BOOL v7 = v22 == v24;
        }
        while (v22 == v24 && v27);
LABEL_48:
        if ((v18 & 0x80000000) == 0) {
          goto LABEL_50;
        }
        goto LABEL_49;
      }
      BOOL v7 = 1;
      if ((SHIBYTE(v29) & 0x80000000) == 0)
      {
LABEL_50:
        if ((v31 & 0x8000000000000000) == 0) {
          return v4 & v7;
        }
        goto LABEL_22;
      }
    }
    else
    {
      BOOL v7 = 0;
      if ((SHIBYTE(v29) & 0x80000000) == 0) {
        goto LABEL_50;
      }
    }
LABEL_49:
    operator delete(v28[0]);
    goto LABEL_50;
  }
LABEL_21:
  BOOL v7 = 0;
  if (v11 < 0) {
LABEL_22:
  }
    operator delete(__p[0]);
  return v4 & v7;
}

void sub_100FF86D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100FF86F0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  *a2 = *(id *)(a1 + 240);
  int v3 = *(void **)(a1 + 240);
  *(void *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;

  return [*(id *)(a1 + 248) setNextFireDelay:1.79769313e308];
}

void sub_100FF8744(_Unwind_Exception *a1)
{
  sub_10048B098(v1);
  _Unwind_Resume(a1);
}

id sub_100FF876C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 64);
  int v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_1000DB0A0(v2);
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  v6[2] = sub_100FFAF28;
  v6[3] = &unk_10230A968;
  v6[4] = a1;
  void v6[5] = v3;
  BOOL v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  id v4 = [v6 copy];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return v4;
}

void sub_100FF8848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

id sub_100FF886C(uint64_t a1)
{
  sub_1011C3B0C((id *)a1);
  int v2 = *(void **)(a1 + 240);
  [v2 updateAuthorizationContext:*(void *)(a1 + 40)];
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_10230A9D8);
  }
  uint64_t v3 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 16);
    [*(id *)(a1 + 40) registrationResult];
    unsigned int v5 = [*(id *)(a1 + 40) registrationResult];
    *(_DWORD *)uint64_t buf = 68289794;
    int v11 = 0;
    __int16 v12 = 2082;
    int v13 = "";
    __int16 v14 = 2114;
    uint64_t v15 = v4;
    __int16 v16 = 2050;
    uint64_t v17 = a1;
    __int16 v18 = 2050;
    uint64_t v19 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor managing monitored conditions\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"RegistrationResult\":%{public, location:CLClientRegistrationResult}lld}", buf, 0x30u);
  }
  if (objc_msgSend(objc_msgSend(v2, "allMonitoringRecordsByIdentifier"), "count") && sub_1011C38AC(a1))
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    long long v6 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      int v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v7;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor manageMonitoredConditions trying #AutoPrompt\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
    sub_1011C3A24(a1);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100FFAFC8;
  v9[3] = &unk_10230A998;
  v9[4] = a1;
  return [objc_msgSend(objc_msgSend(v2, "allMonitoringRecordsByIdentifier"), "enumerateKeysAndObjectsUsingBlock:", v9);
}

id sub_100FF8ABC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 240) allMonitoringRecordsByIdentifier];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id result = [v2 countByEnumeratingWithState:&v17 objects:v29 count:16];
  id v5 = result;
  if (result)
  {
    uint64_t v6 = *(void *)v18;
    *(void *)&long long v4 = 68289538;
    long long v15 = v4;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v2);
        }
        uint64_t v8 = *(void **)(*((void *)&v17 + 1) + 8 * (void)v7);
        id v9 = [v2 objectForKey:v8, v15];
        if ([v9 daemonState])
        {
          id v10 = [v9 daemonState];
          if (v10 != [v9 clientState])
          {
            if (qword_102419530 != -1) {
              dispatch_once(&qword_102419530, &stru_10230A9D8);
            }
            int v11 = qword_102419538;
            if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v12 = a1 + 192;
              if (*(char *)(a1 + 215) < 0) {
                uint64_t v12 = *(void *)(a1 + 192);
              }
              id v13 = [v8 UTF8String];
              *(_DWORD *)uint64_t buf = v15;
              int v22 = 0;
              __int16 v23 = 2082;
              int v24 = "";
              __int16 v25 = 2082;
              uint64_t v26 = v12;
              __int16 v27 = 2082;
              id v28 = v13;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor needs to send a pending event to client\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s}", buf, 0x26u);
            }
            id v14 = [v9 getMonitoringRecordToNotifyClient];
            id v16 = 0;
            id v16 = v14;
            sub_100FF9D7C(a1, &v16, (uint64_t)[v9 serviceTypeMask]);
          }
        }
        uint64_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id result = [v2 countByEnumeratingWithState:&v17 objects:v29 count:16];
      id v5 = result;
    }
    while (result);
  }
  return result;
}

void sub_100FF8CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF8D38(uint64_t a1)
{
  *(void *)a1 = off_10230A8B8;
  id v2 = _os_activity_create((void *)&_mh_execute_header, "CL: #monitor(dtor)", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &v7);

  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A9B8);
  }
  uint64_t v3 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 16);
    *(_DWORD *)uint64_t buf = 68289794;
    int v9 = 0;
    __int16 v10 = 2082;
    int v11 = "";
    __int16 v12 = 2082;
    id v13 = "activity";
    __int16 v14 = 2114;
    uint64_t v15 = v4;
    __int16 v16 = 2050;
    uint64_t v17 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor(dtor)\", \"event\":%{public, location:escape_only}s, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x30u);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  sub_1011C2B50();
  [*(id *)(a1 + 248) invalidate];

  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;
  id v5 = *(void **)(a1 + 240);
  *(void *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;

  os_activity_scope_leave(&v7);
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  sub_1011C0F50(a1);
  return a1;
}

void sub_100FF8F2C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1001C7F8C(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100FF8F48(uint64_t a1)
{
  sub_100FF8D38(a1);

  operator delete();
}

NSDictionary *sub_100FF8F80(uint64_t a1)
{
  v5[0] = @"kCLConnectionMessageMonitorNameKey";
  id v2 = (void *)(a1 + 192);
  if (*(char *)(a1 + 215) < 0) {
    id v2 = (void *)*v2;
  }
  v6[0] = +[NSString stringWithUTF8String:v2];
  v5[1] = @"kCLConnectionMessageMonitorProcessNameKey";
  uint64_t v3 = (void *)(a1 + 216);
  if (*(char *)(a1 + 239) < 0) {
    uint64_t v3 = (void *)*v3;
  }
  v6[1] = +[NSString stringWithUTF8String:v3];
  void v5[2] = @"SDKAtLeast2024";
  v6[2] = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 80)];
  return +[NSDictionary dictionaryWithObjects:v6 forKeys:v5 count:3];
}

void sub_100FF9060(uint64_t a1, CLConnectionMessage **a2)
{
  id v3 = objc_alloc((Class)NSSet);
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v41 = objc_opt_class();
  uint64_t v11 = a1;
  __int16 v12 = (NSSet *)[v3 initWithObjects:v4, v5, v6, v7, v8, v9, v10, v41, objc_opt_class(), 0];
  id v13 = *(void **)(a1 + 240);
  uint64_t DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v12);
  if (DictionaryOfClasses)
  {
    uint64_t v15 = (void *)DictionaryOfClasses;
    __int16 v16 = (void *)CLConnectionMessage::name(*a2);
    int v17 = *((char *)v16 + 23);
    if (v17 < 0)
    {
      if (v16[1] != 38) {
        goto LABEL_21;
      }
      __int16 v16 = (void *)*v16;
    }
    else if (v17 != 38)
    {
      goto LABEL_21;
    }
    if (!memcmp(v16, "Monitor/kCLConnectionMessageMonitorAdd", 0x26uLL))
    {
      if (sub_1011C38AC(a1))
      {
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_10230A9D8);
        }
        unsigned int v34 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = *(void *)(v11 + 16);
          *(_DWORD *)uint64_t buf = 68289538;
          int v44 = 0;
          __int16 v45 = 2082;
          __int16 v46 = "";
          __int16 v47 = 2114;
          uint64_t v48 = v35;
          __int16 v49 = 2050;
          uint64_t v50 = v11;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor add-record trying #AutoPrompt\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", buf, 0x26u);
        }
        sub_1011C3A24(v11);
      }
      id v36 = [v15 objectForKeyedSubscript:@"kCLConnectionMessageMonitorMonitoringRecordKey"];
      [v13 addMonitoringRecord:v36 forIdentifier:[v36 identifier]];
      id v37 = [objc_msgSend(objc_msgSend(v13, "allMonitoringRecordsByIdentifier"), "objectForKey:", objc_msgSend(v36, "identifier"))];
      sub_100FF9794(v11, v37);
      if (([v37 conditionLimitExceeded] & 1) != 0
        || ([v37 conditionUnsupported] & 1) != 0
        || [v37 persistenceUnavailable])
      {
        if (qword_102419520 != -1) {
          dispatch_once(&qword_102419520, &stru_10230A9B8);
        }
        uint64_t v38 = qword_102419528;
        if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = *(void *)(v11 + 16);
          *(_DWORD *)uint64_t buf = 68289795;
          int v44 = 0;
          __int16 v45 = 2082;
          __int16 v46 = "";
          __int16 v47 = 2114;
          uint64_t v48 = v39;
          __int16 v49 = 2050;
          uint64_t v50 = v11;
          __int16 v51 = 2113;
          id v52 = v37;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"error while adding #monitor record\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"record\":%{private, location:escape_only}@}", buf, 0x30u);
        }
        [v13 removeRecordFromMonitoringWithIdentifier:[v36 identifier]];
      }
      goto LABEL_62;
    }
LABEL_21:
    int v24 = (void *)CLConnectionMessage::name(*a2);
    int v25 = *((char *)v24 + 23);
    if (v25 < 0)
    {
      if (v24[1] != 41) {
        goto LABEL_27;
      }
      int v24 = (void *)*v24;
    }
    else if (v25 != 41)
    {
      goto LABEL_27;
    }
    if (!memcmp(v24, "Monitor/kCLConnectionMessageMonitorRemove", 0x29uLL))
    {
      [v13 removeRecordFromMonitoringWithIdentifier:[v15 objectForKeyedSubscript:@"kCLConnectionMessageMonitorIdentifierKey"]];
      goto LABEL_62;
    }
LABEL_27:
    uint64_t v26 = (void *)CLConnectionMessage::name(*a2);
    int v27 = *((char *)v26 + 23);
    if (v27 < 0)
    {
      if (v26[1] != 46)
      {
LABEL_33:
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_10230A9D8);
        }
        id v28 = qword_102419538;
        if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
        {
          uint64_t v29 = CLConnectionMessage::name(*a2);
          uint64_t v30 = *(char *)(v29 + 23) >= 0 ? v29 : *(void *)v29;
          *(_DWORD *)uint64_t buf = 68289282;
          int v44 = 0;
          __int16 v45 = 2082;
          __int16 v46 = "";
          __int16 v47 = 2082;
          uint64_t v48 = v30;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor unsupported message received\", \"name\":%{public, location:escape_only}s}", buf, 0x1Cu);
          if (qword_102419530 != -1) {
            dispatch_once(&qword_102419530, &stru_10230A9D8);
          }
        }
        uint64_t v31 = qword_102419538;
        if (os_signpost_enabled((os_log_t)qword_102419538))
        {
          uint64_t v32 = CLConnectionMessage::name(*a2);
          if (*(char *)(v32 + 23) >= 0) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = *(void *)v32;
          }
          *(_DWORD *)uint64_t buf = 68289282;
          int v44 = 0;
          __int16 v45 = 2082;
          __int16 v46 = "";
          __int16 v47 = 2082;
          uint64_t v48 = v33;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor unsupported message received", "{\"msg%{public}.0s\":\"#monitor unsupported message received\", \"name\":%{public, location:escape_only}s}", buf, 0x1Cu);
        }
        goto LABEL_62;
      }
      uint64_t v26 = (void *)*v26;
    }
    else if (v27 != 46)
    {
      goto LABEL_33;
    }
    if (memcmp(v26, "Monitor/kCLConnectionMessageMonitorUpdateEvent", 0x2EuLL)) {
      goto LABEL_33;
    }
    id v40 = [v15 objectForKeyedSubscript:@"kCLConnectionMessageMonitorEventKey"];
    [v13 updateClientEvent:v40 forIdentifier:[v40 identifier]];
LABEL_62:
    [v13 refillAwaitingMonitoringConditions:[v15 objectForKeyedSubscript:@"kCLConnectionMessageMonitorLedger"]];
    return;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_10230A9D8);
  }
  long long v18 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
  {
    uint64_t v19 = CLConnectionMessage::name(*a2);
    uint64_t v20 = *(char *)(v19 + 23) >= 0 ? v19 : *(void *)v19;
    *(_DWORD *)uint64_t buf = 68289282;
    int v44 = 0;
    __int16 v45 = 2082;
    __int16 v46 = "";
    __int16 v47 = 2082;
    uint64_t v48 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor received a wronly encoded message\", \"message\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
  }
  uint64_t v21 = qword_102419538;
  if (os_signpost_enabled((os_log_t)qword_102419538))
  {
    uint64_t v22 = CLConnectionMessage::name(*a2);
    if (*(char *)(v22 + 23) >= 0) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = *(void *)v22;
    }
    *(_DWORD *)uint64_t buf = 68289282;
    int v44 = 0;
    __int16 v45 = 2082;
    __int16 v46 = "";
    __int16 v47 = 2082;
    uint64_t v48 = v23;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor received a wronly encoded message", "{\"msg%{public}.0s\":\"#monitor received a wronly encoded message\", \"message\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
}

void sub_100FF9794(uint64_t a1, void *a2)
{
  if (!sub_1011C0EB4(a1))
  {
    id v4 = (id)sub_100FFA920(a1, a2);
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    uint64_t v5 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289794;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2114;
      uint64_t v16 = v6;
      __int16 v17 = 2050;
      uint64_t v18 = a1;
      __int16 v19 = 1026;
      int v20 = (int)v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor updating diagnosticMask\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"diagnosticMask\":%{public}d}", buf, 0x2Cu);
    }
    if (![a2 daemonEvent]) {
      [a2 updateDaemonEvent:[objc_alloc((Class)CLMonitoringEvent) initWithIdentifier:[objc_msgSend(objc_msgSend(a2, "clientEvent"), "identifier")] refinement:0 state:0 date:[+[NSDate now](NSDate, "now")] diagnostics:0]];
    }
    if (objc_msgSend(objc_msgSend(a2, "daemonEvent"), "diagnosticMask") == v4)
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
      uint64_t v7 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 16);
        *(_DWORD *)uint64_t buf = 68289794;
        int v12 = 0;
        __int16 v13 = 2082;
        __int16 v14 = "";
        __int16 v15 = 2114;
        uint64_t v16 = v8;
        __int16 v17 = 2050;
        uint64_t v18 = a1;
        __int16 v19 = 1026;
        int v20 = (int)v4;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor skip update - existing mask is same as new mask\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"diagnosticMask\":%{public}d}", buf, 0x2Cu);
      }
    }
    else
    {
      [objc_msgSend(a2, "daemonEvent") updateDiagnosticMask:v4];
      if (([a2 conditionLimitExceeded] & 1) != 0
        || ([a2 persistenceUnavailable] & 1) != 0
        || [a2 conditionUnsupported])
      {
        [objc_msgSend(a2, "daemonEvent") updateMonitoringState:3];
      }
      id v9 = [a2 getMonitoringRecordToNotifyClient];
      id v10 = v9;
      sub_100FF9D7C(a1, &v10, 0);
    }
  }
}

void sub_100FF9A6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FF9AB0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    id v2 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = *(unsigned __int8 *)(a1 + 48);
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 1026;
      unsigned int v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor eligibleForDestructionUponDisconnection\", \"destroyUponDisconnection\":%{public}hhd}", (uint8_t *)&v8, 0x18u);
    }
    return *(unsigned char *)(a1 + 48) != 0;
  }
  else
  {
    unsigned int v5 = [*(id *)(a1 + 240) isMonitoring];
    uint64_t v4 = v5 ^ 1;
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    uint64_t v6 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 1026;
      unsigned int v13 = v5;
      __int16 v14 = 1026;
      int v15 = v5 ^ 1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor eligibleForDestructionUponDisconnection\", \"isMonitoring\":%{public}hhd, \"isElibleForDestruction\":%{public}hhd}", (uint8_t *)&v8, 0x1Eu);
    }
  }
  return v4;
}

uint64_t sub_100FF9C6C()
{
  return 4;
}

uint64_t sub_100FF9C74()
{
  return 13271;
}

id sub_100FF9C7C(uint64_t a1)
{
  if (qword_102419520 != -1) {
    dispatch_once(&qword_102419520, &stru_10230A9B8);
  }
  id v2 = qword_102419528;
  if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    v5[0] = 68289538;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    __int16 v8 = 2114;
    uint64_t v9 = v3;
    __int16 v10 = 2050;
    uint64_t v11 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor authContext has changed\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}", (uint8_t *)v5, 0x26u);
  }
  return sub_100FF886C(a1);
}

void sub_100FF9D7C(uint64_t a1, void **a2, uint64_t a3)
{
  if (sub_1011C0EB4(a1))
  {
    if (!*(unsigned char *)(a1 + 184))
    {
      id v6 = [[objc_msgSend(*(id *)(a1 + 32), "vendor") proxyForService:@"CLApplicationLifecycleManager"];
      id v7 = [*(id *)(a1 + 16) legacyClientKey];
      [v6 launchApplication:v7 requiringAuthForServiceMask:a3 | 0x80000];
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
      __int16 v8 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 215) < 0)
        {
          sub_1000DC48C(__p, *(void **)(a1 + 192), *(void *)(a1 + 200));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(a1 + 192);
          uint64_t v17 = *(void *)(a1 + 208);
        }
        uint64_t v9 = v17 >= 0 ? __p : (void **)__p[0];
        id v10 = [v7 UTF8String];
        BOOL v11 = sub_1011C0EB4(a1);
        int v12 = *(unsigned __int8 *)(a1 + 184);
        *(_DWORD *)uint64_t buf = 68290050;
        int v19 = 0;
        __int16 v20 = 2082;
        uint64_t v21 = "";
        __int16 v22 = 2082;
        uint64_t v23 = v9;
        __int16 v24 = 2082;
        id v25 = v10;
        __int16 v26 = 1026;
        BOOL v27 = v11;
        __int16 v28 = 1026;
        int v29 = v12;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor launch app\", \"monitor\":%{public, location:escape_only}s, \"clientKey\":%{public, location:escape_only}s, \"IsDisconnected\":%{public}hhd, \"wasPreviouslyLaunched\":%{public}hhd}", buf, 0x32u);
        if (SHIBYTE(v17) < 0) {
          operator delete(__p[0]);
        }
      }
      id v13 = [[objc_msgSend(*(id *)(a1 + 32), "silo") newTimer];
      *(void *)(a1 + 248) = v13;
      __int16 v14 = *(std::__shared_weak_count **)(a1 + 72);
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_1000DB0A0(v14);
        id v13 = *(id *)(a1 + 248);
      }
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      uint64_t v15[2] = sub_100FFAB58;
      _OWORD v15[3] = &unk_1022A3020;
      v15[4] = a1;
      [v13 setHandler:v15];
      [*(id *)(a1 + 248) setNextFireDelay:600.0];
      *(unsigned char *)(a1 + 184) = 1;
      if (v14) {
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  else
  {
    sub_100FFABA8(a1, *a2, a3);

    *a2 = 0;
  }
}

void sub_100FFA004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FFA03C(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  if (a4)
  {
    if (a2)
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
      id v10 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
      {
        BOOL v11 = (void *)(a1 + 192);
        if (*(char *)(a1 + 215) < 0) {
          BOOL v11 = (void *)*v11;
        }
        int v16 = 68290051;
        int v17 = 0;
        __int16 v18 = 2082;
        int v19 = "";
        __int16 v20 = 2082;
        uint64_t v21 = v11;
        __int16 v22 = 2082;
        id v23 = [a2 UTF8String];
        __int16 v24 = 2049;
        id v25 = a4;
        __int16 v26 = 2113;
        BOOL v27 = a3;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld, \"condition\":%{private, location:escape_only}@}", (uint8_t *)&v16, 0x3Au);
      }
      sub_100FFA2F8(a1, a2, a3, a4, a5);
    }
    else
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
      int v12 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
      {
        id v13 = (void *)(a1 + 192);
        if (*(char *)(a1 + 215) < 0) {
          id v13 = (void *)*v13;
        }
        int v16 = 68289539;
        int v17 = 0;
        __int16 v18 = 2082;
        int v19 = "";
        __int16 v20 = 2082;
        uint64_t v21 = v13;
        __int16 v22 = 2049;
        id v23 = a4;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor identifier nil onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld}", (uint8_t *)&v16, 0x26u);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_10230A9D8);
        }
      }
      __int16 v14 = qword_102419538;
      if (os_signpost_enabled((os_log_t)qword_102419538))
      {
        int v15 = (void *)(a1 + 192);
        if (*(char *)(a1 + 215) < 0) {
          int v15 = (void *)*v15;
        }
        int v16 = 68289539;
        int v17 = 0;
        __int16 v18 = 2082;
        int v19 = "";
        __int16 v20 = 2082;
        uint64_t v21 = v15;
        __int16 v22 = 2049;
        id v23 = a4;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor identifier nil onConditionUpdate", "{\"msg%{public}.0s\":\"#monitor identifier nil onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld}", (uint8_t *)&v16, 0x26u);
      }
    }
  }
}

void sub_100FFA2F8(uint64_t a1, void *a2, void *a3, id a4, uint64_t a5)
{
  id v10 = *(void **)(a1 + 240);
  id v11 = [objc_msgSend(v10, "allMonitoringRecordsByIdentifier") objectForKey:a2];
  if (v11) {
    uint64_t v12 = sub_100FFA920(a1, v11);
  }
  else {
    uint64_t v12 = 0;
  }
  id v13 = [objc_alloc((Class)CLMonitoringEvent) initWithIdentifier:a2 refinement:a5 state:a4 date:[+[NSDate now](NSDate, "now")] diagnostics:v12];
  if (!v11)
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    id v23 = qword_102419538;
    BOOL v24 = os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT);
    if (v24)
    {
      id v25 = (void *)(a1 + 192);
      if (*(char *)(a1 + 215) < 0) {
        id v25 = (void *)*v25;
      }
      *(_DWORD *)uint64_t buf = 68289795;
      int v41 = 0;
      __int16 v42 = 2082;
      __int32 v43 = "";
      __int16 v44 = 2082;
      __int16 v45 = v25;
      __int16 v46 = 2082;
      id v47 = [a2 UTF8String];
      __int16 v48 = 2049;
      id v49 = a4;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor no daemon monitoring record found\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld}", buf, 0x30u);
    }
    id v22 = sub_100FFA9E8(v24, a3, (uint64_t)v13);
    goto LABEL_30;
  }
  if (qword_102419530 != -1) {
    dispatch_once(&qword_102419530, &stru_10230A9D8);
  }
  __int16 v14 = qword_102419538;
  if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEFAULT))
  {
    id v38 = v13;
    int v15 = (void *)(a1 + 192);
    if (*(char *)(a1 + 215) < 0) {
      int v15 = (void *)*v15;
    }
    id v16 = [a2 UTF8String];
    [v11 clientState];
    id v17 = [v11 clientState];
    [v11 daemonState];
    *(_DWORD *)uint64_t buf = 68290307;
    int v41 = 0;
    __int16 v42 = 2082;
    __int32 v43 = "";
    __int16 v44 = 2082;
    __int16 v45 = v15;
    __int16 v46 = 2082;
    id v47 = v16;
    __int16 v48 = 2049;
    id v49 = v17;
    __int16 v50 = 2049;
    id v51 = [v11 daemonState];
    __int16 v52 = 2049;
    id v53 = a4;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#monitor update record to send to client\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"clientState\":%{private, location:CLMonitoringState}lld, \"daemonState\":%{private, location:CLMonitoringState}lld, \"newDaemonState\":%{private, location:CLMonitoringState}lld}", buf, 0x44u);
    id v13 = v38;
  }
  if (a4
    && objc_msgSend(objc_msgSend(v11, "condition"), "isEqual:", a3)
    && [v11 daemonState] != a4)
  {
    [v10 updateDaemonEvent:v13 forIdentifier:a2];
  }
  id v18 = [v11 daemonState];
  if (v18 != [v11 clientState])
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    int v19 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      __int16 v20 = (void *)(a1 + 192);
      if (*(char *)(a1 + 215) < 0) {
        __int16 v20 = (void *)*v20;
      }
      id v21 = [a2 UTF8String];
      *(_DWORD *)uint64_t buf = 68289538;
      int v41 = 0;
      __int16 v42 = 2082;
      __int32 v43 = "";
      __int16 v44 = 2082;
      __int16 v45 = v20;
      __int16 v46 = 2082;
      id v47 = v21;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor condition update to client\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s}", buf, 0x26u);
    }
    id v22 = [v11 getMonitoringRecordToNotifyClient];
LABEL_30:
    __int16 v26 = v22;
    id v27 = v22;
    if (objc_msgSend(objc_msgSend(v26, "lastEvent"), "state"))
    {
      id v39 = v27;
      sub_100FF9D7C(a1, &v39, (unint64_t)[v11 serviceTypeMask] | 0x80000);
    }
    else
    {
      if (qword_102419530 != -1) {
        dispatch_once(&qword_102419530, &stru_10230A9D8);
      }
      __int16 v28 = qword_102419538;
      if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_FAULT))
      {
        int v29 = (void *)(a1 + 192);
        if (*(char *)(a1 + 215) < 0) {
          int v29 = (void *)*v29;
        }
        uint64_t v30 = *(void **)(a1 + 16);
        id v31 = [a2 UTF8String];
        [v11 daemonState];
        id v32 = [v11 daemonState];
        *(_DWORD *)uint64_t buf = 68290051;
        int v41 = 0;
        __int16 v42 = 2082;
        __int32 v43 = "";
        __int16 v44 = 2114;
        __int16 v45 = v30;
        __int16 v46 = 2082;
        id v47 = v29;
        __int16 v48 = 2082;
        id v49 = v31;
        __int16 v50 = 2049;
        id v51 = v32;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client\", \"ClientKeyPath\":%{public, location:escape_only}@, \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"daemonState\":%{private, location:CLMonitoringState}lld}", buf, 0x3Au);
        if (qword_102419530 != -1) {
          dispatch_once(&qword_102419530, &stru_10230A9D8);
        }
      }
      uint64_t v33 = qword_102419538;
      if (os_signpost_enabled((os_log_t)qword_102419538))
      {
        unsigned int v34 = (void *)(a1 + 192);
        if (*(char *)(a1 + 215) < 0) {
          unsigned int v34 = (void *)*v34;
        }
        uint64_t v35 = *(void **)(a1 + 16);
        id v36 = [a2 UTF8String];
        [v11 daemonState];
        id v37 = [v11 daemonState];
        *(_DWORD *)uint64_t buf = 68290051;
        int v41 = 0;
        __int16 v42 = 2082;
        __int32 v43 = "";
        __int16 v44 = 2114;
        __int16 v45 = v35;
        __int16 v46 = 2082;
        id v47 = v34;
        __int16 v48 = 2082;
        id v49 = v36;
        __int16 v50 = 2049;
        id v51 = v37;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v33, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client", "{\"msg%{public}.0s\":\"#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client\", \"ClientKeyPath\":%{public, location:escape_only}@, \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"daemonState\":%{private, location:CLMonitoringState}lld}", buf, 0x3Au);
      }
    }
  }
}

void sub_100FFA8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100FFA920(uint64_t a1, void *a2)
{
  unint64_t v4 = (unint64_t)[*(id *)(a1 + 40) diagnosticMask];
  if (*(unsigned char *)(a1 + 136)) {
    v4 |= sub_1011C2EC4(a1, 2) | 0x2000;
  }
  if ([a2 conditionLimitExceeded]) {
    v4 |= 0x100uLL;
  }
  if ([a2 persistenceUnavailable]) {
    v4 |= 0x200uLL;
  }
  if ([a2 conditionUnsupported]) {
    v4 |= 0x80uLL;
  }
  unint64_t v5 = v4 | (unint64_t)[a2 diagnosticMaskIfMonitoringIsNonFunctional];
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) & v5;
}

id sub_100FFA9E8(uint64_t a1, void *a2, uint64_t a3)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v5 = objc_alloc((Class)CLCircularGeographicCondition);
    [a2 center];
    double v7 = v6;
    double v9 = v8;
    [a2 radius];
    id v11 = [v5 initWithCenter:v7 radius:v9];
LABEL_7:
    id v13 = v11;
    goto LABEL_8;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v11 = [objc_alloc((Class)CLBeaconIdentityCondition) _initWithUUID:objc_msgSend(a2, "UUID") major:objc_msgSend(a2, "major") minor:objc_msgSend(a2, "minor")];
    goto LABEL_7;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v12 = objc_alloc((Class)CLMinimumAltitudeCondition);
    [a2 altitude];
    id v11 = [v12 initWithAltitude:x0];
    goto LABEL_7;
  }
  id v13 = 0;
LABEL_8:
  id v14 = [objc_alloc((Class)CLMonitoringRecord) initRecordWithCondition:v13 options:0 event:a3];

  return v14;
}

void sub_100FFAB58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(void **)(v1 + 240);
  if (v2)
  {
    [v2 stopMonitoringAllConditions];
    sub_1011C1390(v1, 5.0);
  }
}

void sub_100FFABA8(uint64_t a1, void *a2, uint64_t a3)
{
  if (sub_1011C0EB4(a1))
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230A9B8);
    }
    double v6 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)id v17 = 2082;
      *(void *)&uint64_t v17[2] = "";
      __int16 v18 = 2113;
      int v19 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#monitor connection not valid\", \"record\":%{private, location:escape_only}@}", buf, 0x1Cu);
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_10230A9B8);
      }
    }
    double v7 = qword_102419528;
    if (os_signpost_enabled((os_log_t)qword_102419528))
    {
      *(_DWORD *)uint64_t buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)id v17 = 2082;
      *(void *)&uint64_t v17[2] = "";
      __int16 v18 = 2113;
      int v19 = a2;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#monitor connection not valid", "{\"msg%{public}.0s\":\"#monitor connection not valid\", \"record\":%{private, location:escape_only}@}", buf, 0x1Cu);
    }
  }
  else
  {
    if ([*(id *)(a1 + 16) bundlePath] == @"/System/Library/LocationBundles/NanoCompassAlerts.bundle")
    {
      sub_100134750(buf, "ShowAlert");
      sub_100134750(__p, "locationd.fence.elevatedPriority");
    }
    else
    {
      sub_100134750(buf, "FenceEvent");
      sub_100134750(__p, "locationd.fence");
    }
    sub_1011C1534(a1, (uint64_t *)buf, (uint64_t *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE3(v19) < 0) {
      operator delete(*(void **)buf);
    }
    id v8 = [objc_alloc((Class)CLMonitoringRecord) initRecordWithMonitoringRecord:a2];
    CFStringRef v14 = @"kCLConnectionMessageMonitorMonitoringRecordKey";
    id v15 = v8;
    __p[0] = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    sub_100FFB21C("Monitor/kCLConnectionMessageMonitorUpdateEvent", buf);
    if (a3) {
      char v9 = objc_msgSend(objc_msgSend(a2, "lastEvent"), "state") != (id)1
    }
        && [objc_msgSend(objc_msgSend(a2, "lastEvent"), "state") != (id)2];
    else {
      char v9 = 1;
    }
    double v10 = *(void **)buf;
    id v11 = *(std::__shared_weak_count **)v17;
    if (*(void *)v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)v17 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1011C187C(a1, (uint64_t)&v10, a3, v9, 0.0);
    if (v11) {
      sub_1000DB0A0(v11);
    }

    if (*(void *)v17) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v17);
    }
  }
}

void sub_100FFAEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FFAF28(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  if (v7)
  {
    if (*(void *)(v7 + 8) != -1) {
      sub_100FFA03C(v6, a2, a3, a4, a5);
    }
  }
}

void sub_100FFAFB4(uint64_t a1)
{
}

void sub_100FFAFC8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = [a3 daemonCondition];
  [v5 setAuthorizationContext:*(void *)(v4 + 40)];
  if ([v5 isAuthorized])
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    uint64_t v6 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(v4 + 16);
      int v10 = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      char v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v7;
      __int16 v16 = 2050;
      uint64_t v17 = v4;
      __int16 v18 = 2113;
      int v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor trying to jump start condition due to auth context change\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"record\":%{private, location:escape_only}@}", (uint8_t *)&v10, 0x30u);
    }
    [v5 startMonitoring];
  }
  else
  {
    if (qword_102419530 != -1) {
      dispatch_once(&qword_102419530, &stru_10230A9D8);
    }
    id v8 = qword_102419538;
    if (os_log_type_enabled((os_log_t)qword_102419538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(v4 + 16);
      int v10 = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      char v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v9;
      __int16 v16 = 2050;
      uint64_t v17 = v4;
      __int16 v18 = 2113;
      int v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#monitor trying to force stop condition due to auth context change\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\", \"record\":%{private, location:escape_only}@}", (uint8_t *)&v10, 0x30u);
    }
    [v5 stopMonitoring];
  }
  sub_100FF9794(v4, a3);
}

void sub_100FFB1BC(id a1)
{
  qword_102419528 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_100FFB1EC(id a1)
{
  qword_102419538 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void *sub_100FFB21C@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  id result = sub_10017E9C0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100FFB26C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100FFB280(float a1, uint64_t a2, uint64_t a3)
{
  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 0;
  *(_WORD *)(a3 + 8) = 2082;
}

uint64_t sub_100FFB294@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, __int16 a3@<W8>)
{
  *(void *)(a2 + 1sub_100FB8FC8(&a9, 0) = v3;
  *(_WORD *)(a2 + 18) = a3;
  *(void *)(a2 + 2sub_100FB8FC8(&a9, 0) = result;
  *(_WORD *)(a2 + 28) = a3;
  return result;
}

void *sub_100FFB380(void *result, uint64_t a2)
{
  *id result = a2;
  result[1] = 0xBFF0000000000000;
  result[2] = 0;
  return result;
}

id sub_100FFB390(uint64_t a1)
{
  id result = [*(id *)a1 assertInside];
  *(void *)(a1 + 8) = 0xBFF0000000000000;
  *(void *)(a1 + 16) = 0;
  return result;
}

void sub_100FFB3C0(uint64_t a1, double a2)
{
  [*(id *)a1 assertInside];
  *(double *)(a1 + 8) = a2;
  ++*(void *)(a1 + 16);
  if (qword_1024193A0 != -1) {
    dispatch_once(&qword_1024193A0, &stru_10230A9F8);
  }
  uint64_t v4 = qword_1024193A8;
  if (os_log_type_enabled((os_log_t)qword_1024193A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v5 = *(void *)(a1 + 16);
    *(_DWORD *)uint64_t buf = 67240448;
    int v9 = v5;
    __int16 v10 = 2050;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "TileDl, backoff, count, %{public}d, time, %{public}0.1f", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193A0 != -1) {
      dispatch_once(&qword_1024193A0, &stru_10230A9F8);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLTileDownloadPolicy::receivedDownloadFailedAt(CFAbsoluteTime)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
}

void sub_100FFB5B0(id a1)
{
  qword_1024193A8 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

uint64_t sub_100FFB5E0()
{
  return AnalyticsSendEventLazy();
}

NSDictionary *sub_100FFB654(uint64_t a1)
{
  v12[0] = @"timestamp";
  v13[0] = +[NSNumber numberWithUnsignedLongLong:*(void *)(*(void *)(a1 + 32) + 1)];
  v12[1] = @"isSaturated";
  v13[1] = +[NSNumber numberWithBool:*(unsigned __int8 *)(*(void *)(a1 + 32) + 9)];
  uint64_t v12[2] = @"isFaulted";
  v13[2] = +[NSNumber numberWithBool:*(unsigned __int8 *)(*(void *)(a1 + 32) + 10)];
  v12[3] = @"maxAbsBx";
  LODWORD(v2) = *(_DWORD *)(*(void *)(a1 + 32) + 11);
  v13[3] = +[NSNumber numberWithFloat:v2];
  v12[4] = @"maxAbsBy";
  LODWORD(v3) = *(_DWORD *)(*(void *)(a1 + 32) + 15);
  void v13[4] = +[NSNumber numberWithFloat:v3];
  void v12[5] = @"maxAbsBz";
  LODWORD(v4) = *(_DWORD *)(*(void *)(a1 + 32) + 19);
  v13[5] = +[NSNumber numberWithFloat:v4];
  v12[6] = @"meanAbsBx";
  LODWORD(v5) = *(_DWORD *)(*(void *)(a1 + 32) + 23);
  v13[6] = +[NSNumber numberWithFloat:v5];
  v12[7] = @"meanAbsBy";
  LODWORD(v6) = *(_DWORD *)(*(void *)(a1 + 32) + 27);
  v13[7] = +[NSNumber numberWithFloat:v6];
  unsigned char v12[8] = @"meanAbsBz";
  LODWORD(v7) = *(_DWORD *)(*(void *)(a1 + 32) + 31);
  v13[8] = +[NSNumber numberWithFloat:v7];
  v12[9] = @"varBx";
  LODWORD(v8) = *(_DWORD *)(*(void *)(a1 + 32) + 35);
  void v13[9] = +[NSNumber numberWithFloat:v8];
  v12[10] = @"varBy";
  LODWORD(v9) = *(_DWORD *)(*(void *)(a1 + 32) + 39);
  v13[10] = +[NSNumber numberWithFloat:v9];
  v12[11] = @"varBz";
  LODWORD(v1sub_100FB8FC8(&a9, 0) = *(_DWORD *)(*(void *)(a1 + 32) + 43);
  v13[11] = +[NSNumber numberWithFloat:v10];
  return +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:12];
}

_OWORD *sub_100FFB844(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  sub_100E6B140((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  sub_100E6B1D8((uint64_t)(a1 + 3), (uint64_t)(a2 + 3));
  a1[5] = 0u;
  a1[6] = 0u;
  return a1;
}

void sub_100FFB89C(_Unwind_Exception *a1)
{
  sub_1004A2C4C(v1);
  _Unwind_Resume(a1);
}

void *sub_100FFB8B0(void *a1)
{
  double v2 = (void *)a1[13];
  if (v2) {

  }
  double v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  sub_1004A2EB8(a1 + 6);
  sub_1004A2C4C(a1 + 2);
  return a1;
}

void sub_100FFB904(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  double v5 = (void **)(a1 + 80);
  double v6 = a2 + 1;
  uint64_t v8 = *a2;
  double v7 = a2 + 5;
  uint64_t v9 = v8;
  if ((*(_DWORD *)a1 & 0xFFFFFFFC) == 4) {
    double v6 = v7;
  }
  uint64_t v10 = *v6;
  uint64_t v11 = *(char **)(a1 + 88);
  uint64_t v12 = a1 + 96;
  unint64_t v13 = *(void *)(a1 + 96);
  if ((unint64_t)v11 >= v13)
  {
    uint64_t v15 = (char *)*v5;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v11 - (unsigned char *)*v5) >> 3);
    unint64_t v17 = v16 + 1;
    if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x555555555555555) {
      unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      __int16 v20 = (char *)sub_1000DA5D8(v12, v19);
      uint64_t v15 = *(char **)(a1 + 80);
      uint64_t v11 = *(char **)(a1 + 88);
    }
    else
    {
      __int16 v20 = 0;
    }
    id v21 = &v20[24 * v16];
    id v22 = &v20[24 * v19];
    *(void *)id v21 = v9;
    *((void *)v21 + 1) = v9;
    *((void *)v21 + 2) = v10;
    __int16 v14 = v21 + 24;
    if (v11 != v15)
    {
      do
      {
        long long v23 = *(_OWORD *)(v11 - 24);
        *((void *)v21 - 1) = *((void *)v11 - 1);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 24;
        v11 -= 24;
      }
      while (v11 != v15);
      uint64_t v15 = (char *)*v5;
    }
    *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = v21;
    *(void *)(a1 + 88) = v14;
    *(void *)(a1 + 96) = v22;
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    *(void *)uint64_t v11 = v9;
    *((void *)v11 + 1) = v9;
    __int16 v14 = v11 + 24;
    *((void *)v11 + 2) = v10;
  }
  *(void *)(a1 + 88) = v14;
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_10230AA18);
  }
  BOOL v24 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    id v25 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    uint64_t v26 = *(void *)(a1 + 88);
    double v27 = *(double *)(v26 - 24);
    uint64_t v28 = *(void *)(v26 - 8);
    *(_DWORD *)uint64_t buf = 136315650;
    id v81 = v25;
    __int16 v82 = 2048;
    double v83 = v27;
    __int16 v84 = 2048;
    uint64_t v85 = v28;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "[workout distance] aggregator %s, adding odometer sample %f, %f", buf, 0x20u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    id v58 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    uint64_t v59 = *(void *)(a1 + 88);
    double v60 = *(double *)(v59 - 24);
    uint64_t v61 = *(void *)(v59 - 8);
    int v72 = 136315650;
    id v73 = v58;
    __int16 v74 = 2048;
    double v75 = v60;
    __int16 v76 = 2048;
    uint64_t v77 = v61;
    int v62 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)", "%s\n", v62);
    if (v62 != (char *)buf) {
      free(v62);
    }
  }
  uint64_t v30 = *(double **)(a1 + 80);
  uint64_t v29 = *(void *)(a1 + 88);
  if (0xAAAAAAAAAAAAAAABLL * ((v29 - (uint64_t)v30) >> 3) <= 1
    || (double v31 = *(double *)(v29 - 24) - *v30, v32 = *(double *)(a1 + 8), v31 < v32 + 1.0 + -0.5))
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  if (v31 > v32 + 10.0)
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    uint64_t v33 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_ERROR))
    {
      id v34 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315394;
      id v81 = v34;
      __int16 v82 = 2048;
      double v83 = v31;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "[workout distance] aggregator %s, interval exceeds expected interval, %f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_10230AA18);
      }
      id v63 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      int v72 = 136315394;
      id v73 = v63;
      __int16 v74 = 2048;
      double v75 = v31;
      int v64 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)", "%s\n", v64);
      if (v64 != (char *)buf) {
        free(v64);
      }
    }
  }
  double v35 = *(double *)(a1 + 8);
  id v36 = *(const void **)(a1 + 80);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 88) - (void)v36) >> 3) - 1 >= (unint64_t)v35) {
    unint64_t v37 = (unint64_t)v35;
  }
  else {
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 88) - (void)v36) >> 3) - 1;
  }
  id v69 = 0;
  __int16 v70 = 0;
  uint64_t v71 = 0;
  sub_1001F703C(&v69, v36, (uint64_t)v36 + 24 * v37, v37);
  if (v70 != (unsigned char *)v69)
  {
    unint64_t v38 = (v70 - (unsigned char *)v69) / 24;
    uint64_t v39 = *(void *)(a1 + 80);
    unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 88) - v39) >> 3);
    if (v40 <= 1) {
      unint64_t v40 = 1;
    }
    unint64_t v41 = v40 - 1;
    if (v38 <= 1) {
      unint64_t v38 = 1;
    }
    __int16 v42 = v69 + 1;
    __int32 v43 = (uint64_t *)(v39 + 24);
    do
    {
      if (!v41) {
        sub_100273D6C();
      }
      uint64_t v44 = *v43;
      v43 += 3;
      *__int16 v42 = v44;
      v42 += 3;
      --v41;
      --v38;
    }
    while (v38);
  }
  uint64_t v45 = *(void *)(a1 + 40);
  if (!v45) {
    sub_10015E48C();
  }
  *(void *)&long long v67 = (*(double (**)(uint64_t, void **))(*(void *)v45 + 48))(v45, &v69);
  *((void *)&v67 + 1) = v46;
  uint64_t v68 = v47;
  uint64_t v48 = *(void *)(a1 + 72);
  if (!v48) {
    sub_10015E48C();
  }
  if (!(*(unsigned int (**)(uint64_t, long long *))(*(void *)v48 + 48))(v48, &v67))
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    id v51 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
    {
      id v52 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315906;
      id v81 = v52;
      __int16 v82 = 2048;
      double v83 = *(double *)&v67;
      __int16 v84 = 2048;
      uint64_t v85 = *((void *)&v67 + 1);
      __int16 v86 = 2048;
      uint64_t v87 = v68;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "[workout distance] aggregator %s, suppressing entry <startTime=%f, endTime=%f, metric=%f>", buf, 0x2Au);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_60;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024191C0 == -1) {
      goto LABEL_75;
    }
    goto LABEL_81;
  }
  if (qword_1024191C0 != -1) {
    dispatch_once(&qword_1024191C0, &stru_10230AA18);
  }
  id v49 = qword_1024191C8;
  if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEBUG))
  {
    id v50 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    *(_DWORD *)uint64_t buf = 136315906;
    id v81 = v50;
    __int16 v82 = 2048;
    double v83 = *(double *)&v67;
    __int16 v84 = 2048;
    uint64_t v85 = *((void *)&v67 + 1);
    __int16 v86 = 2048;
    uint64_t v87 = v68;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "[workout distance] aggregator %s, writing entry <startTime=%f, endTime=%f, metric=%f>", buf, 0x2Au);
  }
  if (!sub_10013D1A0(115, 2)) {
    goto LABEL_60;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1024191C0 != -1) {
LABEL_81:
  }
    dispatch_once(&qword_1024191C0, &stru_10230AA18);
LABEL_75:
  id v65 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
  int v72 = 136315906;
  id v73 = v65;
  __int16 v74 = 2048;
  double v75 = *(double *)&v67;
  __int16 v76 = 2048;
  uint64_t v77 = *((void *)&v67 + 1);
  __int16 v78 = 2048;
  uint64_t v79 = v68;
  __int16 v66 = (char *)_os_log_send_and_compose_impl();
  sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)", "%s\n", v66);
  if (v66 != (char *)buf) {
    free(v66);
  }
LABEL_60:
  if (v37)
  {
    id v53 = (char *)*v5;
    long long v54 = &v53[24 * v37];
    long long v55 = *(unsigned char **)(a1 + 88);
    uint64_t v56 = v55 - v54;
    if (v55 != v54) {
      memmove(v53, v54, v55 - v54);
    }
    *(void *)(a1 + 88) = &v53[v56];
  }
  *(_OWORD *)a3 = v67;
  BOOL v57 = v69;
  *(void *)(a3 + 16) = v68;
  *(unsigned char *)(a3 + 24) = 1;
  if (v57)
  {
    __int16 v70 = v57;
    operator delete(v57);
  }
}

void sub_100FFC2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100FFC324(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t sub_100FFC334(void *a1)
{
  uint64_t v2 = a1[1];
  if (a1[2] != v2)
  {
    unint64_t v3 = a1[4];
    double v4 = (void *)(v2 + 8 * (v3 >> 9));
    double v5 = (void **)(*v4 + 8 * (v3 & 0x1FF));
    uint64_t v6 = *(void *)(v2 + (((a1[5] + v3) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v3) & 0x1FF);
    while (v5 != (void **)v6)
    {
      sub_100FFC3DC(v5++, 0);
      if ((void **)((char *)v5 - *v4) == (void **)4096)
      {
        double v7 = (void **)v4[1];
        ++v4;
        double v5 = v7;
      }
    }
  }

  return sub_100FFCEE4(a1);
}

void *sub_100FFC3DC(void **a1, void *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100FFB8B0(result);
    operator delete();
  }
  return result;
}

void sub_100FFC430(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1];
  if (a1[2] != v2)
  {
    unint64_t v3 = a1[4];
    double v4 = (void *)(v2 + 8 * (v3 >> 9));
    double v5 = (uint64_t *)(*v4 + 8 * (v3 & 0x1FF));
    uint64_t v6 = *(void *)(v2 + (((a1[5] + v3) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v3) & 0x1FF);
    while (v5 != (uint64_t *)v6)
    {
      uint64_t v8 = *v5++;
      sub_100FFB904(v8, a2, (uint64_t)&v10);
      if ((uint64_t *)((char *)v5 - *v4) == (uint64_t *)4096)
      {
        uint64_t v9 = (uint64_t *)v4[1];
        ++v4;
        double v5 = v9;
      }
    }
  }
}

void sub_100FFC4D0(void *a1, int *a2)
{
  if (!*((void *)a2 + 5) || (*((void *)a2 + 9) ? (BOOL v3 = *a2 == 7) : (BOOL v3 = 1), v3 || *((double *)a2 + 1) <= 0.0))
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    __int16 v14 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_ERROR))
    {
      int v15 = *a2;
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[workout distance] not adding aggregator for type %d because settings are nonsensical", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_10230AA18);
      }
      unint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)", "%s\n", v18);
      goto LABEL_36;
    }
  }
  else
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    double v5 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *a2;
      uint64_t v7 = *((void *)a2 + 1);
      *(_DWORD *)uint64_t buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v6;
      __int16 v21 = 2048;
      uint64_t v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[workout distance] adding aggregator of type %d with interval %f", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_10230AA18);
      }
      unint64_t v19 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)", "%s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
    uint64_t v8 = a1[1];
    if (a1[2] == v8
      || (unint64_t v9 = a1[4],
          uint64_t v10 = (void *)(v8 + 8 * (v9 >> 9)),
          uint64_t v11 = (_DWORD **)(*v10 + 8 * (v9 & 0x1FF)),
          uint64_t v12 = *(void *)(v8 + (((a1[5] + v9) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v9) & 0x1FF),
          v11 == (_DWORD **)v12))
    {
LABEL_18:
      operator new();
    }
    while (**v11 != *a2)
    {
      if ((_DWORD **)((char *)++v11 - *v10) == (_DWORD **)4096)
      {
        unint64_t v13 = (_DWORD **)v10[1];
        ++v10;
        uint64_t v11 = v13;
      }
      if (v11 == (_DWORD **)v12) {
        goto LABEL_18;
      }
    }
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230AA18);
    }
    unint64_t v16 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *a2;
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "[workout distance] already have an aggregator of that type %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_10230AA18);
      }
      unint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)", "%s\n", v18);
LABEL_36:
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
  }
}

void sub_100FFCA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100FFC3DC((void **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100FFCA74(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100FFD020(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  uint64_t v9 = *(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8));
  uint64_t v10 = *a2;
  *a2 = 0;
  *(void *)(v9 + 8 * (v8 & 0x1FF)) = v10;
  a1[5] = v7 + 1;
}

void sub_100FFCB00(id a1)
{
  qword_1024191C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_100FFCB34()
{
}

void *sub_100FFCB48()
{
  double result = operator new(0x10uLL);
  *double result = off_10230AA48;
  return result;
}

void sub_100FFCB80(uint64_t a1, void *a2)
{
  *a2 = off_10230AA48;
}

double sub_100FFCBA8(uint64_t a1, double **a2)
{
  uint64_t v2 = *a2;
  double result = **a2;
  double v4 = 0.0;
  while (v2 != a2[1])
  {
    double v4 = v4 + v2[2];
    v2 += 3;
  }
  return result;
}

uint64_t sub_100FFCBD4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FFCC14()
{
}

void sub_100FFCC24()
{
}

void *sub_100FFCC38()
{
  double result = operator new(0x10uLL);
  *double result = off_10230AAC8;
  return result;
}

void sub_100FFCC70(uint64_t a1, void *a2)
{
  *a2 = off_10230AAC8;
}

double sub_100FFCC98(uint64_t a1, double **a2)
{
  uint64_t v2 = a2[1];
  double result = **a2;
  double v4 = 0.0;
  if (*a2 != v2)
  {
    uint64_t v5 = *a2;
    do
    {
      double v4 = v4 + v5[2];
      v5 += 3;
    }
    while (v5 != v2);
  }
  return result;
}

uint64_t sub_100FFCCE8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FFCD28()
{
}

void sub_100FFCD38()
{
}

void *sub_100FFCD4C()
{
  double result = operator new(0x10uLL);
  *double result = off_10230AB48;
  return result;
}

void sub_100FFCD84(uint64_t a1, void *a2)
{
  *a2 = off_10230AB48;
}

BOOL sub_100FFCDAC(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) >= 0.0;
}

uint64_t sub_100FFCDBC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FFCDFC()
{
}

void sub_100FFCE0C()
{
}

void *sub_100FFCE20()
{
  double result = operator new(0x10uLL);
  *double result = off_10230ABC8;
  return result;
}

void sub_100FFCE58(uint64_t a1, void *a2)
{
  *a2 = off_10230ABC8;
}

BOOL sub_100FFCE80(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) > 2.22044605e-16;
}

uint64_t sub_100FFCE98(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FFCED8()
{
}

uint64_t sub_100FFCEE4(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    double v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }
  else
  {
    double v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (char *)*v6 + 8 * (v5 & 0x1FF);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_100FFC3DC((void **)v7, 0);
        v7 += 8;
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 512;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    unint64_t v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

void sub_100FFD020(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      id v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      double v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        id v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)id v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int32 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  id v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  double v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100FFD2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FFD338()
{
  qword_102482828 = (uint64_t)off_10230AA48;
  qword_102482840 = (uint64_t)&qword_102482828;
  __cxa_atexit((void (*)(void *))sub_10049ED98, &qword_102482828, (void *)&_mh_execute_header);
  qword_102482848 = (uint64_t)off_10230AAC8;
  qword_102482860 = (uint64_t)&qword_102482848;
  __cxa_atexit((void (*)(void *))sub_10049ED98, &qword_102482848, (void *)&_mh_execute_header);
  qword_102482868 = (uint64_t)off_10230AB48;
  qword_102482880 = (uint64_t)&qword_102482868;
  __cxa_atexit((void (*)(void *))sub_10049ED9C, &qword_102482868, (void *)&_mh_execute_header);
  qword_102482888 = (uint64_t)off_10230ABC8;
  qword_1024828A0 = (uint64_t)&qword_102482888;

  return __cxa_atexit((void (*)(void *))sub_10049ED9C, &qword_102482888, (void *)&_mh_execute_header);
}

uint64_t sub_100FFD458(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 1;
  uint64_t v5 = *(_OWORD **)a2;
  unint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    *(_OWORD *)a1 = *v5;
    *(unsigned char *)(a1 + 16) = a3;
    sub_1000DB0A0(v4);
  }
  else
  {
    *(_OWORD *)a1 = *v5;
    *(unsigned char *)(a1 + 16) = a3;
  }
  return a1;
}

__n128 sub_100FFD4BC(__n128 *a1, __n128 **a2, unsigned __int8 a3)
{
  __n128 result = **a2;
  *a1 = result;
  a1[1].n128_u8[0] = a3;
  return result;
}

uint64_t sub_100FFD4D4(uint64_t a1, void *a2, char a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 1;
  *(void *)a1 = [a2 roadID];
  *(void *)(a1 + 8) = sub_100D2B5E8(a2);
  *(unsigned char *)(a1 + 16) = a3;
  return a1;
}

BOOL sub_100FFD530(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a2 + 16)
      && *(void *)(a1 + 8) == *(void *)(a2 + 8);
}

BOOL sub_100FFD56C(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return *(void *)a1 < *(void *)a2;
  }
  int v2 = *(unsigned __int8 *)(a2 + 16);
  if (*(unsigned char *)(a1 + 16)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    return *(void *)(a1 + 8) < *(void *)(a2 + 8);
  }
  return *(unsigned char *)(a1 + 16) && v2 == 0;
}

BOOL sub_100FFD5BC(unsigned __int8 *a1, uint64_t *a2, void *a3, int a4, double a5)
{
  int v5 = a4;
  *a2 = 0xBFF0000000000000;
  if (!*a1
    || (uint64_t v7 = *((void *)a1 + 8)) == 0
    || !*(unsigned char *)(v7 + 18)
    || (double v11 = *((double *)a1 + 22), v11 > 0.0) && vabdd_f64(a5, v11) <= 0.9)
  {
    if (!a4) {
      return 0;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    BOOL v14 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = *((void *)a1 + 8);
      if (v15) {
        int v16 = *(unsigned __int8 *)(v15 + 18);
      }
      else {
        int v16 = -1;
      }
      int v46 = *a1;
      uint64_t v47 = *((void *)a1 + 22);
      *(_DWORD *)uint64_t buf = 67240704;
      *(_DWORD *)int v133 = v16;
      *(_WORD *)&v133[4] = 1026;
      *(_DWORD *)&v133[6] = v46;
      *(_WORD *)int v134 = 2050;
      *(void *)&v134[2] = v47;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "CLMM,no TEPA,isTunnel,%{public}d,isSnapUsable,%{public}d,lastAssistanceTime,%{public}.1lf", buf, 0x18u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v81 = *((void *)a1 + 8);
    if (v81) {
      int v82 = *(unsigned __int8 *)(v81 + 18);
    }
    else {
      int v82 = -1;
    }
    int v83 = *a1;
    uint64_t v84 = *((void *)a1 + 22);
    *(_DWORD *)v108 = 67240704;
    *(_DWORD *)&v108[4] = v82;
    *(_WORD *)&v108[8] = 1026;
    *(_DWORD *)&v108[10] = v83;
    *(_WORD *)&v108[14] = 2050;
    *(void *)&v108[16] = v84;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v13);
    goto LABEL_146;
  }
  if (+[GEOLocationShifter isLocationShiftRequiredForCoordinate:](GEOLocationShifter, "isLocationShiftRequiredForCoordinate:", *((double *)a1 + 12), *((double *)a1 + 13)))
  {
    if (!v5) {
      return 0;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v12 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      *(double *)int v133 = a5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,no TEPA, shifted coordinates", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    *(_DWORD *)v108 = 134349056;
    *(double *)&v108[4] = a5;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v13);
LABEL_146:
    if (v13 != (char *)buf) {
      free(v13);
    }
    return 0;
  }
  uint64_t v17 = *((void *)a1 + 8);
  uint64_t v18 = (std::__shared_weak_count *)*((void *)a1 + 9);
  int v104 = (double *)v17;
  unsigned int v105 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v99 = a3;
  int v19 = *(unsigned __int8 *)(v17 + 18);
  double v20 = *((double *)a1 + 14);
  *((unsigned char *)a2 + 72) = 0;
  int v98 = v5;
  int v21 = 0;
  if (!v19)
  {
    double v22 = 0.0;
    goto LABEL_86;
  }
  double v22 = 0.0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v97 = _Q0;
  while (1)
  {
    uint64_t v28 = v104;
    if (!v104) {
      goto LABEL_86;
    }
    if (v21 == 200) {
      break;
    }
    sub_10039C4B4(v104);
    double v29 = v28[5];
    *(double *)a2 = a5;
    long long v30 = (uint64_t *)v104;
    uint64_t v31 = *((void *)v104 + 18);
    if (v31 == *((void *)v104 + 17))
    {
      a2[1] = 0;
      uint64_t v32 = 0;
    }
    else
    {
      a2[1] = *(void *)(v31 - 16);
      uint64_t v32 = *(void *)(v31 - 8);
    }
    a2[2] = v32;
    *((double *)a2 + 4) = sub_10039CED4(v30);
    unint64_t v33 = (uint64_t *)v104;
    a2[8] = *((void *)v104 + 12);
    if ((int)sub_10039CF68(v33) >= 1) {
      *((unsigned char *)a2 + 72) = 1;
    }
    double v34 = fmod(*((float *)a1 + 22) - *((double *)a2 + 4), 360.0);
    if (v34 < 0.0) {
      double v34 = v34 + 360.0;
    }
    if (v34 > 180.0) {
      double v34 = v34 + -360.0;
    }
    if (fabs(v34) > 7.5) {
      *((unsigned char *)a2 + 72) = 1;
    }
    double v35 = v104;
    sub_10039C4B4(v104);
    double v36 = 1.0 - v20;
    double v37 = v35[5];
    uint64_t v102 = 0;
    double v103 = 0.0;
    uint64_t v100 = (uint64_t)&v100;
    int v101 = &v100;
    *(void *)v108 = 0;
    *(_OWORD *)&v108[16] = v97;
    *(_OWORD *)int v109 = 0uLL;
    *(void *)&v109[16] = 0xBFF0000000000000;
    uint64_t v121 = 0;
    int v122 = 0;
    long long v118 = 0u;
    long long v119 = 0u;
    __int16 v120 = 0;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    memset(v126, 0, sizeof(v126));
    long long v127 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v116 = 0u;
    memset(v117, 0, sizeof(v117));
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    *(_OWORD *)&v109[24] = 0u;
    memset(v110, 0, sizeof(v110));
    unint64_t v131 = 0xBFF0000000000000;
    uint64_t v130 = 0;
    *(double *)&v108[8] = a5;
    if ((*(unsigned int (**)(void, unsigned char *, uint64_t *, void, uint64_t, double **, uint64_t, double *, double, double))(*(void *)*a3 + 80))(*a3, v108, &v100, 0, 1, &v104, 1, &v103, v20, v37 * (1.0 - v20) + 1.0))
    {
      if (v102 == 1 && v103 >= 0.0)
      {
        unint64_t v38 = (double *)v101[2];
        uint64_t v39 = (std::__shared_weak_count *)v101[3];
        if (v39) {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v40 = v105;
        int v104 = v38;
        unsigned int v105 = v39;
        int v5 = v98;
        if (v40)
        {
          sub_1000DB0A0(v40);
          unint64_t v38 = v104;
        }
        double v41 = sub_10039CEF4((uint64_t)v38, 0, 1);
        if (v41 < 0.0) {
          goto LABEL_52;
        }
        double v42 = fmod(v41 - *((double *)a2 + 4), 360.0);
        if (v42 < 0.0) {
          double v42 = v42 + 360.0;
        }
        if (v42 > 180.0) {
          double v42 = v42 + -360.0;
        }
        if (fabs(v42) > 7.5) {
LABEL_52:
        }
          *((unsigned char *)a2 + 72) = 1;
        double v20 = 0.0;
        if (v104) {
          BOOL v43 = *((unsigned char *)v104 + 18) != 0;
        }
        else {
          BOOL v43 = 0;
        }
        goto LABEL_64;
      }
      if (v98)
      {
        if (qword_102419430 != -1) {
          dispatch_once(&qword_102419430, &stru_10230AC38);
        }
        uint64_t v44 = qword_102419438;
        if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 67240192;
          *(_DWORD *)int v133 = v102;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEBUG, "CLMM,no TEPA,multi-outbound,%{public}d", buf, 8u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419430 != -1) {
            dispatch_once(&qword_102419430, &stru_10230AC38);
          }
          int v106 = 67240192;
          int v107 = v102;
          uint64_t v45 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v45);
          if (v45 != (char *)buf) {
            free(v45);
          }
        }
      }
      BOOL v43 = 0;
      *a2 = 0xBFF0000000000000;
    }
    else
    {
      BOOL v43 = 0;
    }
    int v5 = v98;
LABEL_64:
    if (SHIBYTE(v113) < 0) {
      operator delete(*((void **)&v112 + 1));
    }
    double v22 = v22 + v29 * v36;
    sub_10017FF2C(&v100);
    ++v21;
    if (!v43) {
      goto LABEL_86;
    }
  }
  *a2 = 0xBFF0000000000000;
  if (v5)
  {
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v50 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)int v133 = 201;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "CLMM,TEPA,outgoing reached max iterations,%{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_10230AC38);
      }
      *(void *)v108 = 0xC904020100;
      unsigned int v94 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v94);
      if (v94 != (char *)buf) {
        free(v94);
      }
      int v21 = 201;
      int v5 = v98;
    }
    else
    {
      int v21 = 201;
    }
LABEL_86:
    uint64_t v51 = *a2;
    if (*(double *)a2 > 0.0)
    {
      *((double *)a2 + 14) = v22;
      a2[3] = 0x4039000000000000;
      *(_OWORD *)(a2 + 5) = xmmword_101D9BCE0;
      a2[7] = 0xBFF0000000000000;
      double v52 = *((double *)a1 + 4);
      if (v52 > 0.0)
      {
        a2[6] = *((void *)a1 + 5);
        *((double *)a2 + 7) = v52;
      }
      *((void *)a1 + 22) = v51;
      a2[11] = 0;
      a2[12] = 0;
      id v53 = a2 + 11;
      *((double *)a2 + 13) = v22;
      long long v54 = (double *)*((void *)a1 + 8);
      long long v55 = (std::__shared_weak_count *)*((void *)a1 + 9);
      if (v55) {
        atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v56 = v105;
      int v104 = v54;
      unsigned int v105 = v55;
      if (v56)
      {
        sub_1000DB0A0(v56);
        long long v54 = v104;
      }
      if (*((unsigned char *)v54 + 18))
      {
        int v57 = 0;
        double v58 = *((double *)a1 + 14);
        __asm { FMOV            V0.2D, #-1.0 }
        long long v96 = _Q0;
        while (1)
        {
          double v60 = v104;
          if (!v104) {
            goto LABEL_133;
          }
          if (v57 == 200)
          {
            a2[13] = 0xBFF0000000000000;
            *id v53 = 0;
            a2[12] = 0;
            if (v5)
            {
              if (qword_102419430 != -1) {
                dispatch_once(&qword_102419430, &stru_10230AC38);
              }
              uint64_t v71 = qword_102419438;
              if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)uint64_t buf = 67240192;
                *(_DWORD *)int v133 = 201;
                _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEBUG, "CLMM,TEPA,incoming reached max iterations,%{public}d", buf, 8u);
              }
              if (sub_10013D1A0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_102419430 != -1) {
                  dispatch_once(&qword_102419430, &stru_10230AC38);
                }
                *(void *)v108 = 0xC904020100;
                int v95 = (char *)_os_log_send_and_compose_impl();
                sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v95);
                if (v95 != (char *)buf) {
                  free(v95);
                }
              }
            }
            int v57 = 201;
            goto LABEL_133;
          }
          sub_10039C4B4(v104);
          *((double *)a2 + 13) = *((double *)a2 + 13) + v60[5] * v58;
          uint64_t v61 = v104;
          int v62 = (long long *)*((void *)v104 + 17);
          if (*((long long **)v104 + 18) == v62) {
            long long v63 = 0uLL;
          }
          else {
            long long v63 = *v62;
          }
          *(_OWORD *)id v53 = v63;
          sub_10039C4B4(v61);
          double v64 = v61[5];
          uint64_t v102 = 0;
          double v103 = 0.0;
          uint64_t v100 = (uint64_t)&v100;
          int v101 = &v100;
          *(void *)v108 = 0;
          *(_OWORD *)&v108[16] = v96;
          *(_OWORD *)int v109 = 0uLL;
          *(void *)&v109[16] = 0xBFF0000000000000;
          uint64_t v121 = 0;
          int v122 = 0;
          long long v118 = 0u;
          long long v119 = 0u;
          __int16 v120 = 0;
          long long v123 = 0u;
          long long v124 = 0u;
          long long v125 = 0u;
          memset(v126, 0, sizeof(v126));
          long long v127 = 0u;
          long long v128 = 0u;
          long long v129 = 0u;
          long long v116 = 0u;
          memset(v117, 0, sizeof(v117));
          long long v114 = 0u;
          long long v115 = 0u;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          *(_OWORD *)&v109[24] = 0u;
          memset(v110, 0, sizeof(v110));
          unint64_t v131 = 0xBFF0000000000000;
          uint64_t v130 = 0;
          *(double *)&v108[8] = a5;
          if (!(*(unsigned int (**)(void, unsigned char *, void, uint64_t *, void, double **, uint64_t, double *, double, double))(*(void *)*v99 + 80))(*v99, v108, 0, &v100, 0, &v104, 1, &v103, v58, v64 * v58 + 1.0))goto LABEL_115; {
          if (v102 != 1 || v103 < 0.0)
          }
            break;
          id v65 = (double *)v101[2];
          __int16 v66 = (std::__shared_weak_count *)v101[3];
          if (v66) {
            atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          long long v67 = v105;
          int v104 = v65;
          unsigned int v105 = v66;
          if (v67)
          {
            sub_1000DB0A0(v67);
            id v65 = v104;
          }
          double v58 = 1.0;
          if (!v65) {
            goto LABEL_115;
          }
          BOOL v68 = *((unsigned char *)v65 + 18) != 0;
LABEL_116:
          if (SHIBYTE(v113) < 0) {
            operator delete(*((void **)&v112 + 1));
          }
          sub_10017FF2C(&v100);
          ++v57;
          if (!v68) {
            goto LABEL_133;
          }
        }
        a2[13] = 0xBFF0000000000000;
        *id v53 = 0;
        a2[12] = 0;
        if (v5)
        {
          if (qword_102419430 != -1) {
            dispatch_once(&qword_102419430, &stru_10230AC38);
          }
          id v69 = qword_102419438;
          if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t buf = 67240192;
            *(_DWORD *)int v133 = v102;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEBUG, "CLMM,no TEPA,multi-inbound,%{public}d", buf, 8u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419430 != -1) {
              dispatch_once(&qword_102419430, &stru_10230AC38);
            }
            int v106 = 67240192;
            int v107 = v102;
            __int16 v70 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v70);
            if (v70 != (char *)buf) {
              free(v70);
            }
            BOOL v68 = 0;
            int v5 = v98;
            goto LABEL_116;
          }
        }
LABEL_115:
        BOOL v68 = 0;
        goto LABEL_116;
      }
      int v57 = 0;
LABEL_133:
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_10230AC38);
      }
      int v72 = qword_102419438;
      if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v73 = a2[1];
        uint64_t v74 = a2[2];
        uint64_t v75 = a2[11];
        uint64_t v76 = a2[12];
        uint64_t v77 = a2[6];
        uint64_t v78 = a2[7];
        uint64_t v79 = a2[13];
        uint64_t v80 = a2[14];
        *(_DWORD *)uint64_t buf = 134351617;
        *(double *)int v133 = a5;
        *(_WORD *)&v133[8] = 2049;
        *(void *)int v134 = v73;
        *(_WORD *)&v134[8] = 2049;
        uint64_t v135 = v74;
        __int16 v136 = 2049;
        uint64_t v137 = v75;
        __int16 v138 = 2049;
        uint64_t v139 = v76;
        __int16 v140 = 2050;
        uint64_t v141 = v77;
        __int16 v142 = 2050;
        uint64_t v143 = v78;
        __int16 v144 = 2050;
        uint64_t v145 = v79;
        __int16 v146 = 2050;
        uint64_t v147 = v80;
        __int16 v148 = 1026;
        int v149 = v21;
        __int16 v150 = 1026;
        int v151 = v57;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,TEPA,ell,%{private}.7lf,%{private}.7lf,sll,%{private}.7lf,%{private}.7lf,alt,%{public}.1lf,vUnc,%{public}.1lf,length,%{public}.2lf,distFromCurrentParticle,%{public}.1lf,iterCountOut,%{public}d,iterCountIn,%{public}d", buf, 0x68u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419430 != -1) {
          dispatch_once(&qword_102419430, &stru_10230AC38);
        }
        uint64_t v85 = a2[1];
        uint64_t v86 = a2[2];
        uint64_t v87 = a2[11];
        uint64_t v88 = a2[12];
        uint64_t v89 = a2[6];
        uint64_t v90 = a2[7];
        uint64_t v91 = a2[13];
        uint64_t v92 = a2[14];
        *(_DWORD *)v108 = 134351617;
        *(double *)&v108[4] = a5;
        *(_WORD *)&v108[12] = 2049;
        *(void *)&v108[14] = v85;
        *(_WORD *)&v108[22] = 2049;
        *(void *)&v108[24] = v86;
        *(_WORD *)int v109 = 2049;
        *(void *)&v109[2] = v87;
        *(_WORD *)&v109[10] = 2049;
        *(void *)&v109[12] = v88;
        *(_WORD *)&v109[20] = 2050;
        *(void *)&v109[22] = v89;
        *(_WORD *)&v109[30] = 2050;
        *(void *)&v109[32] = v90;
        LOWORD(v110[0]) = 2050;
        *(void *)((char *)v110 + 2) = v91;
        HIWORD(v110[2]) = 2050;
        *(void *)&v110[3] = v92;
        LOWORD(v110[5]) = 1026;
        *(_DWORD *)((char *)&v110[5] + 2) = v21;
        HIWORD(v110[6]) = 1026;
        v110[7] = v57;
        uint64_t v93 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)", "%s\n", v93);
        if (v93 != (char *)buf) {
          free(v93);
        }
      }
    }
  }
  BOOL v48 = *(double *)a2 > 0.0;
  if (v105) {
    sub_1000DB0A0(v105);
  }
  return v48;
}

void sub_100FFE70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a24) {
    sub_1000DB0A0(a24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FFE77C(double *a1, uint64_t a2, void *a3, int a4)
{
  int v8 = *(_DWORD *)(a2 + 96);
  double v9 = *(double *)(a2 + 76);
  double v10 = *(double *)(a2 + 44);
  if (v10 >= 0.0)
  {
    a1[6] = v9;
    a1[1] = v10;
  }
  if (!*(unsigned char *)a1
    || (uint64_t v11 = *((void *)a1 + 8)) == 0
    || ((double v12 = a1[7], v13 = v9 - v12, v12 > 0.0) ? (v14 = v13 > 5.0) : (v14 = 1),
        v14
     || !*(unsigned char *)(v11 + 18)
     || (v8 == 3 || a1[2] <= 0.0) && ((double v15 = a1[6], v15 <= 0.0) || (v13 = a1[1], v13 < 0.0) || v9 - v15 > 15.0)))
  {
    if (!a4) {
      return 0;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    double v20 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v21 = *(void *)(a2 + 76);
      uint64_t v22 = *((void *)a1 + 8);
      if (v22) {
        int v23 = *(unsigned __int8 *)(v22 + 18);
      }
      else {
        int v23 = -1;
      }
      int v24 = *(unsigned __int8 *)a1;
      uint64_t v26 = *((void *)a1 + 6);
      uint64_t v25 = *((void *)a1 + 7);
      uint64_t v27 = *((void *)a1 + 1);
      uint64_t v28 = *((void *)a1 + 2);
      *(_DWORD *)uint64_t buf = 134351104;
      unint64_t v126 = v21;
      __int16 v127 = 1026;
      *(_DWORD *)long long v128 = v23;
      *(_WORD *)&v128[4] = 1026;
      *(_DWORD *)&v128[6] = v24;
      *(_WORD *)long long v129 = 2050;
      *(void *)&v129[2] = v25;
      *(_WORD *)uint64_t v130 = 2050;
      *(void *)&v130[2] = 0x4014000000000000;
      *(_WORD *)unint64_t v131 = 2050;
      *(void *)&v131[2] = v27;
      *(_WORD *)unsigned int v132 = 2050;
      *(void *)&v132[2] = v26;
      __int16 v133 = 2050;
      uint64_t v134 = 0x402E000000000000;
      __int16 v135 = 2050;
      uint64_t v136 = v28;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,NotPropagating,isTunnel,%{public}d,isSnapUsable,%{public}d,particleTime,%{public}.2lf,particleTimeOut,%{public}.1lf,speed,%{public}.2lf,speedTime,%{public}.2lf,speedTimeOut,%{public}.1lf,speedLimit,%{public}.1lf", buf, 0x54u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v71 = *(void *)(a2 + 76);
    uint64_t v72 = *((void *)a1 + 8);
    if (v72) {
      int v73 = *(unsigned __int8 *)(v72 + 18);
    }
    else {
      int v73 = -1;
    }
    int v74 = *(unsigned __int8 *)a1;
    uint64_t v76 = *((void *)a1 + 6);
    uint64_t v75 = *((void *)a1 + 7);
    uint64_t v77 = *((void *)a1 + 1);
    uint64_t v78 = *((void *)a1 + 2);
    *(_DWORD *)int v107 = 134351104;
    *(void *)&v107[4] = v71;
    *(_WORD *)&v107[12] = 1026;
    *(_DWORD *)&v107[14] = v73;
    *(_WORD *)&v107[18] = 1026;
    *(_DWORD *)&v107[20] = v74;
    *(_WORD *)&v107[24] = 2050;
    *(void *)&v107[26] = v75;
    *(_WORD *)&v107[34] = 2050;
    *(void *)&v107[36] = 0x4014000000000000;
    *(_WORD *)&v107[44] = 2050;
    *(void *)&v107[46] = v77;
    *(_WORD *)&v107[54] = 2050;
    *(void *)&v107[56] = v76;
    *(_WORD *)&v107[64] = 2050;
    *(void *)&v107[66] = 0x402E000000000000;
    *(_WORD *)&v107[74] = 2050;
    *(void *)&v107[76] = v78;
    int v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v19);
    goto LABEL_140;
  }
  if (+[GEOLocationShifter isLocationShiftRequiredForCoordinate:](GEOLocationShifter, "isLocationShiftRequiredForCoordinate:", a1[12], a1[13], v13)&& *(_DWORD *)(a2 + 132) != 2)
  {
    if (!a4) {
      return 0;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    int v16 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v17 = *(void *)(a2 + 76);
      *(_DWORD *)uint64_t buf = 134349056;
      unint64_t v126 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,NotPropagating, shifting is required but accessory is outputting  unshifted coordinates", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v18 = *(void *)(a2 + 76);
    *(_DWORD *)int v107 = 134349056;
    *(void *)&v107[4] = v18;
    int v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v19);
LABEL_140:
    if (v19 != (char *)buf) {
      free(v19);
    }
    return 0;
  }
  double v31 = *(double *)(a2 + 76) - a1[7];
  if (v31 < 0.0)
  {
    if (!a4) {
      return 0;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v32 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v33 = *(void *)(a2 + 76);
      uint64_t v34 = *((void *)a1 + 7);
      *(_DWORD *)uint64_t buf = 134349312;
      unint64_t v126 = v33;
      __int16 v127 = 2050;
      *(void *)long long v128 = v34;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,NotPropagating,time lower than particleTime, %{public}.2lf", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v35 = *(void *)(a2 + 76);
    uint64_t v36 = *((void *)a1 + 7);
    *(_DWORD *)int v107 = 134349312;
    *(void *)&v107[4] = v35;
    *(_WORD *)&v107[12] = 2050;
    *(void *)&v107[14] = v36;
    int v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v19);
    goto LABEL_140;
  }
  if (v8 == 3 || (double v37 = a1[2], v37 <= 0.0))
  {
    double v37 = a1[1];
  }
  else if (a1[1] >= v37)
  {
    double v37 = a1[1];
  }
  double v38 = v31 * v37;
  if (v31 * v37 <= 225.0) {
    double v39 = v31 * v37;
  }
  else {
    double v39 = 225.0;
  }
  if (v31 * v37 > 225.0 && a4 != 0)
  {
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    double v41 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v42 = *(void *)(a2 + 76);
      *(_DWORD *)uint64_t buf = 134349568;
      unint64_t v126 = v42;
      __int16 v127 = 2050;
      *(double *)long long v128 = v38;
      *(_WORD *)&v128[8] = 2050;
      *(void *)long long v129 = 0x406C200000000000;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,limit distance to propagate,orig,%{public}.1lf,new,%{public}.1lf", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_10230AC38);
      }
      uint64_t v79 = *(void *)(a2 + 76);
      *(_DWORD *)int v107 = 134349568;
      *(void *)&v107[4] = v79;
      *(_WORD *)&v107[12] = 2050;
      *(double *)&v107[14] = v38;
      *(_WORD *)&v107[22] = 2050;
      *(void *)&v107[24] = 0x406C200000000000;
      uint64_t v80 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v80);
      if (v80 != (char *)buf) {
        free(v80);
      }
    }
    double v39 = 225.0;
  }
  *(void *)int v107 = 0;
  *(void *)&v107[8] = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v85 = _Q0;
  *(_OWORD *)&v107[16] = _Q0;
  *(void *)&v107[32] = 0;
  *(void *)&v107[40] = 0;
  *(void *)&v107[48] = 0xBFF0000000000000;
  uint64_t v117 = 0;
  int v118 = 0;
  memset(&v115[32], 0, 32);
  __int16 v116 = 0;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  memset(v122, 0, 27);
  memset(&v122[32], 0, 48);
  memset(v115, 0, 30);
  long long v114 = 0u;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  long long v109 = 0u;
  long long v108 = 0u;
  memset(&v107[56], 0, 32);
  unint64_t v124 = 0xBFF0000000000000;
  uint64_t v123 = 0;
  v88[0] = (uint64_t)v88;
  v88[1] = (uint64_t)v88;
  unint64_t v89 = 0;
  uint64_t v87 = 0;
  if (((*(uint64_t (**)(void, unsigned char *, uint64_t *, void, uint64_t, unsigned __int8 *, void, uint64_t *, double, double))(*(void *)*a3 + 80))(*a3, v107, v88, 0, 1, (unsigned __int8 *)a1 + 64, *((unsigned __int8 *)a1 + 84), &v87, a1[14], v39) & 1) == 0)
  {
    if (!a4) {
      goto LABEL_83;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v49 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "CLMM,NotPropagating,roadsAtIntersection returned false", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_83;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    *(_WORD *)uint64_t v102 = 0;
    BOOL v48 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v48);
    goto LABEL_149;
  }
  if (v89 >= 2)
  {
    if (!a4) {
      goto LABEL_83;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v47 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      unint64_t v126 = v89;
      __int16 v127 = 2050;
      *(double *)long long v128 = v39;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEBUG, "CLMM,NotPropagating,multi-outbound,%{public}lu,intersection within the distance,%{public}.2lf, needed to be travelled returned", buf, 0x16u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_83;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    *(_DWORD *)uint64_t v102 = 134349312;
    *(void *)&v102[4] = v89;
    __int16 v103 = 2050;
    double v104 = v39;
    BOOL v48 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v48);
LABEL_149:
    if (v48 != (char *)buf) {
      free(v48);
    }
LABEL_83:
    uint64_t v29 = 0;
    goto LABEL_124;
  }
  sub_100FFFA78((uint64_t)v102, (uint64_t)(a1 + 8));
  v86[0] = v86;
  v86[1] = v86;
  v86[2] = 0;
  if (((*(uint64_t (**)(void, unsigned char *, void *, double))(*(void *)*a3 + 88))(*a3, v102, v86, v39) & 1) == 0)
  {
    if (!a4) {
      goto LABEL_122;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    uint64_t v61 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEBUG, "CLMM,NotPropagating,moveOnRoad returned false", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_122;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 == -1) {
      goto LABEL_156;
    }
    goto LABEL_159;
  }
  if (!*(void *)v102)
  {
    if (!a4) {
      goto LABEL_122;
    }
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    int v62 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, "CLMM,NotPropagating,NULL road", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_122;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    LOWORD(v9sub_100FB8FC8(&a9, 0) = 0;
    long long v63 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v63);
    goto LABEL_157;
  }
  if (*(unsigned char *)(*(void *)v102 + 18))
  {
    if (a4)
    {
      if (qword_102419430 != -1) {
        dispatch_once(&qword_102419430, &stru_10230AC38);
      }
      uint64_t v50 = qword_102419438;
      if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v51 = *(void *)(a2 + 76);
        uint64_t v52 = *((void *)a1 + 1);
        uint64_t v53 = *((void *)a1 + 2);
        *(_DWORD *)uint64_t buf = 134350337;
        unint64_t v126 = v51;
        __int16 v127 = 2049;
        *(void *)long long v128 = v106;
        *(_WORD *)&v128[8] = 2049;
        *(void *)long long v129 = *((void *)&v106 + 1);
        *(_WORD *)&v129[8] = 2050;
        *(double *)uint64_t v130 = v105;
        *(_WORD *)&v130[8] = 2050;
        *(void *)unint64_t v131 = v52;
        *(_WORD *)&v131[8] = 2050;
        *(void *)unsigned int v132 = v53;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "CLMM,%{public}.1lf,Propagating,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,speed,%{public}.1lf,speedLimit,%{public}.1lf", buf, 0x3Eu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419430 != -1) {
          dispatch_once(&qword_102419430, &stru_10230AC38);
        }
        uint64_t v81 = *(void *)(a2 + 76);
        uint64_t v82 = *((void *)a1 + 1);
        uint64_t v83 = *((void *)a1 + 2);
        int v90 = 134350337;
        uint64_t v91 = v81;
        __int16 v92 = 2049;
        uint64_t v93 = v106;
        __int16 v94 = 2049;
        uint64_t v95 = *((void *)&v106 + 1);
        __int16 v96 = 2050;
        double v97 = v105;
        __int16 v98 = 2050;
        uint64_t v99 = v82;
        __int16 v100 = 2050;
        uint64_t v101 = v83;
        uint64_t v84 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v84);
        if (v84 != (char *)buf) {
          free(v84);
        }
      }
    }
    double v54 = *(double *)(a2 + 76);
    a1[6] = v54;
    *(_OWORD *)(a2 + 4) = v106;
    *(double *)(a2 + 6sub_100FB8FC8(&a9, 0) = v105;
    *(void *)(a2 + 52) = 0x3FC999999999999ALL;
    *(void *)(a2 + 68) = 0x4008000000000000;
    *(_OWORD *)(a2 + 28) = xmmword_101D1C570;
    int v55 = *(_DWORD *)(a2 + 96);
    if (v55 != 3) {
      *(_OWORD *)(a2 + 44) = v85;
    }
    double v56 = a1[4];
    if (v56 <= 0.0)
    {
      double v58 = 0.0;
      double v60 = -1.0;
    }
    else
    {
      int v57 = (double *)(a2 + 36);
      double v58 = a1[5];
      *(double *)(a2 + 28) = v58;
      double v59 = v56 + v31 * 0.15;
      *(double *)(a2 + 36) = v59;
      if (v59 > 200.0) {
        int v57 = (double *)&unk_101D9BCF0;
      }
      double v60 = *v57;
      *(double *)(a2 + 36) = *v57;
    }
    *(void *)(a2 + 2sub_100FB8FC8(&a9, 0) = 0x4024000000000000;
    id v65 = (double *)(a2 + 20);
    double v66 = 10.0;
    if ((v55 & 0xFFFFFFF7) == 1)
    {
      double v67 = a1[3] + v31 * 0.5;
      *id v65 = v67;
      BOOL v68 = (double *)&unk_101D9BCF8;
      if (v67 >= 10.0) {
        BOOL v68 = v65;
      }
      double v69 = *v68;
      *id v65 = *v68;
      __int16 v70 = (double *)&unk_101D9BD00;
      if (v69 <= 149.0) {
        __int16 v70 = v65;
      }
      double v66 = *v70;
      *id v65 = *v70;
    }
    uint64_t v29 = 1;
    sub_100FFFB20((uint64_t)a1, (uint64_t *)v102, 1, v54, v66, v58, v60);
    goto LABEL_123;
  }
  if (a4)
  {
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    double v64 = qword_102419438;
    if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEBUG, "CLMM,NotPropagating,solution moved away from tunnel", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419430 == -1)
      {
LABEL_156:
        LOWORD(v9sub_100FB8FC8(&a9, 0) = 0;
        long long v63 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)", "%s\n", v63);
LABEL_157:
        if (v63 != (char *)buf) {
          free(v63);
        }
        goto LABEL_122;
      }
LABEL_159:
      dispatch_once(&qword_102419430, &stru_10230AC38);
      goto LABEL_156;
    }
  }
LABEL_122:
  uint64_t v29 = 0;
LABEL_123:
  sub_1003B2350(v86);
  sub_100FFFC10(v102);
LABEL_124:
  sub_10017FF2C(v88);
  if (SHIBYTE(v111) < 0) {
    operator delete(*((void **)&v110 + 1));
  }
  return v29;
}

void sub_100FFFA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  sub_1003B2350(&a14);
  sub_100FFFC10(&a29);
  sub_10017FF2C(&a18);
  if (a64 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FFFA78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 65);
  *(void *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 65) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  sub_101000368((void *)(a1 + 88), *(const void **)(a2 + 88), *(void *)(a2 + 96), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3));
  return a1;
}

void sub_100FFFB08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_1000DB0A0(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FFFB20(uint64_t a1, uint64_t *a2, char a3, double a4, double a5, double a6, double a7)
{
  *(double *)(a1 + 56) = a4;
  uint64_t v13 = *a2;
  uint64_t v14 = a2[1];
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  double v15 = (uint64_t *)(a1 + 64);
  int v16 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = v13;
  *(void *)(a1 + 72) = v14;
  if (v16) {
    sub_1000DB0A0(v16);
  }
  long long v17 = *((_OWORD *)a2 + 1);
  long long v18 = *((_OWORD *)a2 + 2);
  *(void *)(a1 + 112) = a2[6];
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = v17;
  *(_OWORD *)(a1 + 96) = v18;
  long long v19 = *(_OWORD *)(a2 + 7);
  *(_OWORD *)(a1 + 129) = *(_OWORD *)((char *)a2 + 65);
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = v19;
  if (v15 != a2) {
    sub_1010003E4((char *)(a1 + 152), (char *)a2[11], a2[12], 0x8E38E38E38E38E39 * ((a2[12] - a2[11]) >> 3));
  }
  *(unsigned char *)a1 = a3;
  *(double *)(a1 + 32) = a7;
  *(double *)(a1 + 4sub_100FB8FC8(&a9, 0) = a6;
  *(double *)(a1 + 24) = a5;
  uint64_t v20 = *(void *)(a1 + 64);
  if (v20)
  {
    double v21 = *(double *)(v20 + 32);
    if (v21 <= 0.0) {
      double v21 = -1.0;
    }
    *(double *)(a1 + 16) = v21;
  }
}

void *sub_100FFFC10(void *a1)
{
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3) {
    sub_1000DB0A0(v3);
  }
  return a1;
}

void sub_100FFFC50(uint64_t a1, long long *a2)
{
  double v3 = *((double *)a2 + 1);
  *(double *)a1 = v3;
  if (*((unsigned char *)a2 + 264))
  {
    double v27 = 0.0;
    uint64_t v28 = 0;
    double v25 = 0.0;
    double v26 = 0.0;
    double v24 = 0.0;
    *(unsigned char *)(a1 + 56) = 0;
    if (!*(_DWORD *)(a1 + 8))
    {
      int v7 = 1;
      double v8 = 0.0;
      double v9 = 0.0;
      double v10 = 0.0;
      double v11 = 0.0;
LABEL_10:
      double v12 = *(double *)(a1 + 16);
      double v13 = *(double *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = v7;
      *(double *)(a1 + 16) = v11 + v12;
      *(double *)(a1 + 24) = v10 + v13;
      double v14 = v8 + *(double *)(a1 + 40);
      *(double *)(a1 + 32) = v9 + *(double *)(a1 + 32);
      *(double *)(a1 + 4sub_100FB8FC8(&a9, 0) = v14;
      long long v15 = *a2;
      long long v16 = a2[1];
      long long v17 = a2[3];
      *(_OWORD *)(a1 + 96) = a2[2];
      *(_OWORD *)(a1 + 112) = v17;
      *(_OWORD *)(a1 + 64) = v15;
      *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = v16;
      long long v18 = a2[4];
      long long v19 = a2[5];
      long long v20 = a2[7];
      *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = a2[6];
      *(_OWORD *)(a1 + 176) = v20;
      *(_OWORD *)(a1 + 128) = v18;
      *(_OWORD *)(a1 + 144) = v19;
      std::string::operator=((std::string *)(a1 + 192), (const std::string *)(a2 + 8));
      memcpy((void *)(a1 + 216), (char *)a2 + 152, 0x118uLL);
      return;
    }
    double v5 = v3 - *(double *)(a1 + 72);
    if (v5 >= 0.0 && v5 <= 2.2)
    {
      if (!sub_1000F17A8((double *)(a1 + 496), &v25, &v24, (double *)&v28, *((double *)a2 + 36), *((double *)a2 + 37), *((double *)a2 + 9), *(double *)(a1 + 352), *(double *)(a1 + 360), *(double *)(a1 + 136))|| sqrt(v24 * v24 + v25 * v25) / v5 > 3.8|| !*((unsigned char *)a2 + 228)&& *((double *)a2 + 12) > 2.2&& !sub_1000F17A8((double *)(a1 + 496), &v27, &v26, (double *)&v28, *((double *)a2 + 7),
              *((double *)a2 + 8),
              *((double *)a2 + 9),
              *(double *)(a1 + 120),
              *(double *)(a1 + 128),
              *(double *)(a1 + 136)))
      {
        *(void *)a1 = 0;
        *(_DWORD *)(a1 + 8) = 0;
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_OWORD *)(a1 + 41) = 0u;
        sub_101000548(a1 + 64);
        return;
      }
      double v22 = 0.0;
      uint64_t v23 = 0;
      sub_101172040((double *)(a1 + 496), (double *)&v23, &v22, *((double *)a2 + 36), *((double *)a2 + 37), *((double *)a2 + 9), *((double *)a2 + 21), *((double *)a2 + 7), *((double *)a2 + 8));
      double v21 = v22;
      if (v22 > *(double *)(a1 + 48)) {
        *(unsigned char *)(a1 + 56) = 1;
      }
      *(double *)(a1 + 48) = v21;
      double v10 = v26;
      double v11 = v27;
      double v8 = v24;
      double v9 = v25;
      int v7 = *(_DWORD *)(a1 + 8) + 1;
      goto LABEL_10;
    }
    *(void *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
    uint64_t v6 = a1 + 64;
  }
  else
  {
    *(void *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    uint64_t v6 = a1 + 64;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
  }

  sub_101000548(v6);
}

BOOL sub_100FFFEA8(uint64_t *a1, int a2)
{
  if (*((_DWORD *)a1 + 2) < 4u) {
    return 0;
  }
  double v3 = sqrt(*((double *)a1 + 3) * *((double *)a1 + 3) + *((double *)a1 + 2) * *((double *)a1 + 2));
  double v4 = sqrt(*((double *)a1 + 5) * *((double *)a1 + 5) + *((double *)a1 + 4) * *((double *)a1 + 4));
  if (*((unsigned char *)a1 + 56))
  {
    double v5 = v3 - v4;
    if (*((double *)a1 + 6) > 15.0 && v5 > 29.0)
    {
      if (a2)
      {
        if (qword_102419430 != -1) {
          dispatch_once(&qword_102419430, &stru_10230AC38);
        }
        uint64_t v6 = qword_102419438;
        if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_INFO))
        {
          uint64_t v7 = *a1;
          uint64_t v8 = a1[6];
          *(_DWORD *)uint64_t buf = 134350080;
          uint64_t v17 = v7;
          __int16 v18 = 2050;
          *(void *)long long v19 = v8;
          *(_WORD *)&v19[8] = 2050;
          *(double *)&unsigned char v19[10] = v3;
          *(_WORD *)&std::bad_cast v19[18] = 2050;
          *(double *)&v19[20] = v4;
          *(_WORD *)&v19[28] = 2050;
          *(void *)&v19[30] = 0x403D000000000000;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "CLMM,%{public}.1lf,detected stuck,alongTrackRawToSnap,%{public}.1lf,deltaPosChange,%{public}.1lf,deltaSnapChange,%{public}.1lf,thresholdDiff,%{public}.1lf", buf, 0x34u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419430 != -1) {
            dispatch_once(&qword_102419430, &stru_10230AC38);
          }
          long long v15 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::StuckAtEndOfRoad::isStuckAtEndOfRoad(const BOOL)", "%s\n", v15);
          if (v15 != (char *)buf) {
            free(v15);
          }
        }
      }
      return 1;
    }
  }
  else
  {
    double v5 = v3 - v4;
  }
  if (v5 <= 5.0 || a2 == 0) {
    return 0;
  }
  if (qword_102419430 != -1) {
    dispatch_once(&qword_102419430, &stru_10230AC38);
  }
  double v11 = qword_102419438;
  if (os_log_type_enabled((os_log_t)qword_102419438, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v12 = *a1;
    int v13 = *((unsigned __int8 *)a1 + 56);
    *(_DWORD *)uint64_t buf = 134350080;
    uint64_t v17 = v12;
    __int16 v18 = 1026;
    *(_DWORD *)long long v19 = v13;
    *(_WORD *)&std::bad_cast v19[4] = 2050;
    *(double *)&v19[6] = v3;
    *(_WORD *)&v19[14] = 2050;
    *(double *)&unsigned char v19[16] = v4;
    *(_WORD *)&v19[24] = 2050;
    *(void *)&v19[26] = 0x403D000000000000;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "CLMM, %{public}.1lf,isMovingAway,%{public}d,deltaPosChange,%{public}.1lf,deltaSnapChange,%{public}.1lf,thresholdDiff,%{public}.1lf", buf, 0x30u);
  }
  BOOL result = sub_10013D1A0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419430 != -1) {
      dispatch_once(&qword_102419430, &stru_10230AC38);
    }
    double v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLParticleMapMatcherCommon::StuckAtEndOfRoad::isStuckAtEndOfRoad(const BOOL)", "%s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
    return 0;
  }
  return result;
}

BOOL sub_1010002E8(double *a1, double a2, double a3)
{
  return vabdd_f64(a2, *a1) >= a3;
}

double *sub_1010002FC(double *result, double a2)
{
  if (*result >= 0.0)
  {
    int v2 = result + 1;
    if (vabdd_f64(result[1], a2) > 6.0) {
      *BOOL result = a2;
    }
  }
  else
  {
    *result++ = a2;
    int v2 = result;
  }
  double *v2 = a2;
  return result;
}

void sub_101000338(id a1)
{
  qword_102419438 = (uint64_t)os_log_create("com.apple.locationd.Position", "MapMatcher");
}

void *sub_101000368(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = sub_100EA3658(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1010003C8(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1010003E4(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  double v9 = *(char **)result;
  if (0x8E38E38E38E38E39 * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 > 0x38E38E38E38E38ELL) {
      sub_1001D7FD4();
    }
    unint64_t v10 = 0x8E38E38E38E38E39 * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x1C71C71C71C71C7) {
      unint64_t v12 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v12 = v11;
    }
    BOOL result = sub_100EA3658(v7, v12);
    double v14 = (char *)v7[1];
    int v13 = (void **)(v7 + 1);
    double v9 = v14;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      long long v19 = v9;
      long long v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int v13 = (void **)(result + 8);
  long long v15 = (unsigned char *)*((void *)result + 1);
  if (0x8E38E38E38E38E39 * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    double v9 = (char *)*v13;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    long long v19 = v9;
    long long v20 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  char *v13 = &v9[v17];
  return result;
}

void sub_101000548(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }
  *(void *)uint64_t v7 = 0xBFF0000000000000;
  *(void *)&v9[120] = 0;
  *(_DWORD *)&v9[128] = 0;
  memset(&v9[80], 0, 34);
  memset(&v9[136], 0, 75);
  memset(&v9[216], 0, 56);
  memset(&v7[8], 0, 80);
  memset(v9, 0, 78);
  long long v8 = 0u;
  *(void *)&v9[272] = 0xBFF0000000000000;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)v7;
  *(_OWORD *)a1 = 0uLL;
  *(_OWORD *)(a1 + 16) = _Q0;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v7[48];
  *(_OWORD *)(a1 + 112) = *(_OWORD *)&v7[64];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v7[16];
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = *(_OWORD *)&v7[32];
  std::string::operator=((std::string *)(a1 + 128), (const std::string *)&v7[80]);
  memcpy((void *)(a1 + 152), v9, 0x118uLL);
  if (SHIBYTE(v8) < 0) {
    operator delete(*(void **)&v7[80]);
  }
}

void sub_101000640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101000C54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101000EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100DE6E84((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_101000FD8(id a1)
{
  qword_1024193A8 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_101001008()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419688, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419688))
  {
    qword_102419670 = 0;
    qword_102419678 = 0;
    qword_102419680 = 0;
    uint64_t v0 = operator new(6uLL);
    qword_102419678 = (uint64_t)(v0 + 3);
    qword_102419680 = (uint64_t)(v0 + 3);
    *(_DWORD *)uint64_t v0 = 151521030;
    v0[2] = 3082;
    qword_102419670 = (uint64_t)v0;
    __cxa_atexit((void (*)(void *))sub_1001C6FD8, &qword_102419670, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419688);
  }
}

void sub_1010010C0(_Unwind_Exception *a1)
{
}

void sub_1010010D8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024196A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1024196A8))
  {
    qword_102419690 = 0;
    qword_102419698 = 0;
    qword_1024196A0 = 0;
    uint64_t v0 = operator new(2uLL);
    qword_102419690 = (uint64_t)v0;
    _WORD *v0 = 256;
    qword_102419698 = (uint64_t)(v0 + 1);
    qword_1024196A0 = (uint64_t)(v0 + 1);
    __cxa_atexit((void (*)(void *))sub_1001C700C, &qword_102419690, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1024196A8);
  }
}

void sub_101001180(_Unwind_Exception *a1)
{
}

uint64_t sub_101001198(uint64_t a1, uint64_t a2)
{
  return sub_1010011A4(a1, a2, (const char **)&off_10230AC78);
}

uint64_t sub_1010011A4(uint64_t a1, uint64_t a2, const char **a3)
{
  uint64_t v5 = sub_1005F54CC(a1, a2);
  if (sub_10014C3C0(v5))
  {
    sub_1005F7B0C(a1, "Vertices", a3, 0, 0);
  }
  else
  {
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_10230AD38);
    }
    uint64_t v6 = qword_1024193C8;
    if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Fence: No access to vertices DB", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193C0 != -1) {
        dispatch_once(&qword_1024193C0, &stru_10230AD38);
      }
      long long v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLFenceVertexDatabase::CLFenceVertexDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  return a1;
}

void sub_10100136C(_Unwind_Exception *a1)
{
  sub_1005F5850(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101001384(uint64_t a1, void *a2, int a3)
{
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_10230AD38);
  }
  uint64_t v6 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = (uint64_t)(a2[1] - *a2) >> 4;
    *(_DWORD *)uint64_t buf = 67240448;
    *(_DWORD *)&uint8_t buf[4] = a3;
    __int16 v26 = 2050;
    uint64_t v27 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Fence: addVertices, key, %{public}d, num %{public}lu", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_10230AD38);
    }
    uint64_t v19 = (uint64_t)(a2[1] - *a2) >> 4;
    v22[0] = 67240448;
    v22[1] = a3;
    __int16 v23 = 2050;
    uint64_t v24 = v19;
    long long v20 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)", "%s\n", v20);
    if (v20 != (char *)buf) {
      free(v20);
    }
  }
  if (a3 != -1)
  {
    sub_10010F274((uint64_t)v22);
    double v9 = sub_100132EFC((uint64_t *)((char *)&v24 + 6), (uint64_t)"INSERT INTO ", 12);
    unint64_t v10 = sub_100132EFC(v9, (uint64_t)"Vertices", 8);
    uint64_t v11 = sub_100132EFC(v10, (uint64_t)" (", 2);
    unint64_t v12 = sub_100132EFC(v11, (uint64_t)"Latitude", 8);
    int v13 = sub_100132EFC(v12, (uint64_t)", ", 2);
    double v14 = sub_100132EFC(v13, (uint64_t)"Longitude", 9);
    long long v15 = sub_100132EFC(v14, (uint64_t)", ", 2);
    long long v16 = sub_100132EFC(v15, (uint64_t)"FenceForeignKey", 15);
    sub_100132EFC(v16, (uint64_t)") VALUES (?, ?, ?)", 18);
    std::stringbuf::str();
    if (v28 >= 0) {
      uint64_t v17 = buf;
    }
    else {
      uint64_t v17 = *(uint8_t **)buf;
    }
    sub_10014D518(a1, (uint64_t)v17);
  }
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_10230AD38);
  }
  long long v8 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Fence: attempting to add vertices to db without a key", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_10230AD38);
    }
    LOWORD(v22[0]) = 0;
    double v21 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)", "%s\n", v21);
    if (v21 != (char *)buf) {
      free(v21);
    }
  }
  return 0;
}

void sub_101001AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  sub_101A129A8((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_101001B34(uint64_t a1, int a2)
{
  if (qword_1024193C0 != -1) {
    dispatch_once(&qword_1024193C0, &stru_10230AD38);
  }
  double v4 = qword_1024193C8;
  if (os_log_type_enabled((os_log_t)qword_1024193C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Fence: Removing vertices, key, %{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193C0 != -1) {
      dispatch_once(&qword_1024193C0, &stru_10230AD38);
    }
    v11[0] = 67240192;
    v11[1] = a2;
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLFenceVertexDatabase::removeVertices(int)", "%s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
  sub_10010F274((uint64_t)v11);
  uint64_t v5 = sub_100132EFC(&v12, (uint64_t)"DELETE FROM ", 12);
  uint64_t v6 = sub_100132EFC(v5, (uint64_t)"Vertices", 8);
  uint64_t v7 = sub_100132EFC(v6, (uint64_t)" WHERE ", 7);
  long long v8 = sub_100132EFC(v7, (uint64_t)"FenceForeignKey", 15);
  sub_100132EFC(v8, (uint64_t)"=?", 2);
  std::stringbuf::str();
  if (v14 >= 0) {
    double v9 = buf;
  }
  else {
    double v9 = *(uint8_t **)buf;
  }
  sub_10014D518(a1, (uint64_t)v9);
}

void sub_101002074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  sub_101A129A8((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1010020E4(uint64_t a1, uint64_t a2, void *a3)
{
  a3[1] = *a3;
  sub_10010F274((uint64_t)&v13);
  double v4 = sub_100132EFC(&v14, (uint64_t)"SELECT ", 7);
  uint64_t v5 = sub_100132EFC(v4, (uint64_t)"Latitude", 8);
  uint64_t v6 = sub_100132EFC(v5, (uint64_t)", ", 2);
  uint64_t v7 = sub_100132EFC(v6, (uint64_t)"Longitude", 9);
  long long v8 = sub_100132EFC(v7, (uint64_t)" FROM ", 6);
  double v9 = sub_100132EFC(v8, (uint64_t)"Vertices", 8);
  unint64_t v10 = sub_100132EFC(v9, (uint64_t)" WHERE ", 7);
  uint64_t v11 = sub_100132EFC(v10, (uint64_t)"FenceForeignKey", 15);
  sub_100132EFC(v11, (uint64_t)"=?", 2);
  std::stringbuf::str();
  if (v16 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  sub_10014D518(a1, (uint64_t)p_p);
}

void sub_1010028EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
  }
  sub_101A129A8((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_101002970(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 16);
  double v4 = *(char **)a1;
  uint64_t v5 = *(unsigned char **)(a1 + 8);
  unint64_t v6 = (v5 - v4) >> 4;
  if (v6 >= (v3 - (uint64_t)v4) >> 4) {
    return;
  }
  if (v5 == v4)
  {
    uint64_t v11 = 0;
    uint64_t v9 = 16 * v6;
    goto LABEL_8;
  }
  uint64_t v7 = (char *)sub_1000C571C(v2, v6);
  double v4 = *(char **)a1;
  long long v8 = *(char **)(a1 + 8);
  uint64_t v9 = (uint64_t)&v7[16 * v6];
  uint64_t v11 = &v7[16 * v10];
  if (v8 == *(char **)a1)
  {
LABEL_8:
    uint64_t v12 = v9;
    goto LABEL_9;
  }
  uint64_t v12 = v9;
  do
  {
    *(_OWORD *)(v12 - 16) = *((_OWORD *)v8 - 1);
    v12 -= 16;
    v8 -= 16;
  }
  while (v8 != v4);
  double v4 = *(char **)a1;
LABEL_9:
  *(void *)a1 = v12;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v11;
  if (v4)
  {
    operator delete(v4);
  }
}

void sub_101002A48(id a1)
{
  qword_1024193C8 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeoFencing");
}

void sub_101002B04()
{
}

void sub_101002F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_101002FF4(id a1)
{
  qword_102419568 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

void *sub_101003024(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  BOOL result = (void *)sub_100054C14(a1, a2, a3, a4, a5);
  *BOOL result = &off_10230AD88;
  return result;
}

void sub_10100305C(uint64_t a1)
{
  sub_100029A7C(a1);

  operator delete();
}

void *sub_101003094@<X0>(uint64_t a1@<X8>)
{
  v6[0] = off_10230AE28;
  v6[1] = sub_1010032E4;
  v6[2] = 0;
  void v6[3] = v6;
  sub_100134750(v7, "kCLConnectionMessageKappaStatsAvailable");
  sub_100BFA250((uint64_t)&v8, (uint64_t)v6);
  v5[0] = off_10230AE28;
  v5[1] = sub_10100340C;
  _DWORD v5[2] = 0;
  void v5[3] = v5;
  sub_100134750(v9, "kCLConnectionMessageKappaSendAPCommand");
  sub_100BFA250((uint64_t)&v10, (uint64_t)v5);
  v4[0] = off_10230AE28;
  v4[1] = sub_1010039FC;
  void v4[2] = 0;
  v4[3] = v4;
  sub_100134750(v11, "kCLConnectionMessageSafetyAnomalyNotify");
  sub_100BFA250((uint64_t)v12, (uint64_t)v4);
  sub_1010042EC(a1, (unsigned __int8 *)v7, 3);
  for (uint64_t i = 0; i != -21; i -= 7)
  {
    sub_100BFA76C(&v12[i * 8]);
    if (SHIBYTE(v11[i + 2]) < 0) {
      operator delete((void *)v11[i]);
    }
  }
  sub_100BFA76C(v4);
  sub_100BFA76C(v5);
  return sub_100BFA76C(v6);
}

void sub_10100325C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  for (uint64_t i = 112; i != -56; i -= 56)
    sub_101003CC0((uint64_t)(&a21 + i));
  sub_100BFA76C(&a9);
  sub_100BFA76C(&a13);
  sub_100BFA76C(&a17);
  _Unwind_Resume(a1);
}

void sub_1010032E4(uint64_t a1, uint64_t a2)
{
  id v4 = objc_alloc_init((Class)NSAutoreleasePool);
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = sub_101003CFC(a1);
  if (v5) {
    sub_1000DB0A0(v5);
  }
  if (v6)
  {
    uint64_t v7 = CMAvailable;
    uint64_t v8 = &__kCFBooleanTrue;
    +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
    CLConnectionMessage::sendReply();
  }
}

void sub_1010033D0(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_1001C7F8C(exception_object);
}

void sub_10100340C(uint64_t a1, uint64_t a2)
{
  id v4 = objc_alloc_init((Class)NSAutoreleasePool);
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v6 = sub_101003CFC(a1);
  if (v5) {
    sub_1000DB0A0(v5);
  }
  if (v6)
  {
    Dictionary = (void *)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2);
    id v8 = [Dictionary objectForKeyedSubscript:CMKappaCmdKey];
    id v9 = [Dictionary objectForKeyedSubscript:CMKappaArgKey];
    unsigned int v10 = [v8 intValue];
    id v11 = [v9 intValue];
    if (qword_102419100 != -1) {
      dispatch_once(&qword_102419100, &stru_10230ADD8);
    }
    uint64_t v12 = qword_102419108;
    if (os_log_type_enabled((os_log_t)qword_102419108, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 67109376;
      unsigned int v27 = v10;
      __int16 v28 = 1024;
      int v29 = (int)v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "received AP command %d arg %d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419100 != -1) {
        dispatch_once(&qword_102419100, &stru_10230ADD8);
      }
      int v22 = 67109376;
      unsigned int v23 = v10;
      __int16 v24 = 1024;
      int v25 = (int)v11;
      char v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLSafetyAnomalySubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)", "%s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
    id v13 = [[objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLKappaNotifier"];
    uint64_t v14 = 2;
    switch(v10)
    {
      case 0u:
        [v13 startDem];
        goto LABEL_33;
      case 1u:
        [v13 stopDem];
        goto LABEL_33;
      case 2u:
        [v13 forceCompanionHeartbeat];
        goto LABEL_33;
      case 3u:
        [v13 remoteTimeout];
        goto LABEL_33;
      case 4u:
        [v13 collect:65793 isLocal:1];
        goto LABEL_33;
      case 5u:
        [v13 dontcollect:257 isLocal:1];
        goto LABEL_33;
      case 6u:
        [v13 simulateTriggerWithDelay:v11, 2];
        goto LABEL_33;
      case 7u:
        goto LABEL_31;
      case 8u:
        uint64_t v14 = 4;
LABEL_31:
        [v13 simulateTriggerWithDelay:v11 forMode:v14];
        goto LABEL_33;
      case 9u:
        [v13 collect:0x101000001 isLocal:1];
        goto LABEL_33;
      case 0xAu:
        [v13 dontcollect:16777217 isLocal:1];
        goto LABEL_33;
      case 0xBu:
        [v13 collect:0x1010000000001 isLocal:1];
        goto LABEL_33;
      case 0xCu:
        [v13 dontcollect:0x10000000001 isLocal:1];
        goto LABEL_33;
      case 0xDu:
        [v13 collect:0x100000101000001 isLocal:1];
        goto LABEL_33;
      case 0xEu:
        [v13 dontcollect:0x100000001000001 isLocal:1];
LABEL_33:
        uint64_t v18 = CMReturnCode;
        uint64_t v19 = &__kCFBooleanTrue;
        +[NSDictionary dictionaryWithObjects:&v19 forKeys:&v18 count:1];
        break;
      default:
        if (qword_102419100 != -1) {
          dispatch_once(&qword_102419100, &stru_10230ADD8);
        }
        long long v15 = qword_102419108;
        if (os_log_type_enabled((os_log_t)qword_102419108, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "invalid AP command", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419100 != -1) {
            dispatch_once(&qword_102419100, &stru_10230ADD8);
          }
          LOWORD(v22) = 0;
          uint64_t v17 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLSafetyAnomalySubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)", "%s\n", v17);
          if (v17 != (char *)buf) {
            free(v17);
          }
        }
        uint64_t v20 = CMReturnCode;
        double v21 = &__kCFBooleanFalse;
        +[NSDictionary dictionaryWithObjects:&v21 forKeys:&v20 count:1];
        break;
    }
    CLConnectionMessage::sendReply();
  }
}

void sub_101003948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1010039FC(uint64_t a1, uint64_t a2)
{
  id v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v5 = sub_101003CFC(a1);
  if (v4) {
    sub_1000DB0A0(v4);
  }
  if (v5)
  {
    id v6 = [[objc_msgSend((id)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2), "objectForKeyedSubscript:", CMSafetyAnomalyPropertiesKey), "objectForKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Guid")];
    if (qword_102419320 != -1) {
      dispatch_once(&qword_102419320, &stru_10230ADF8);
    }
    uint64_t v7 = qword_102419328;
    if (os_log_type_enabled((os_log_t)qword_102419328, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      id v14 = [v6 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "handleMessageSafetyAnomalyNotification, retrieved guid %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419320 != -1) {
        dispatch_once(&qword_102419320, &stru_10230ADF8);
      }
      int v11 = 136315138;
      id v12 = [v6 UTF8String];
      id v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLSafetyAnomalySubscription::handleMessageSafetyAnomalyNotification(std::shared_ptr<CLConnectionMessage>)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    [objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLKappaNotifier") forceTriggerIgneous:v6];
    uint64_t v9 = CMReturnCode;
    unsigned int v10 = &__kCFBooleanTrue;
    +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];
    CLConnectionMessage::sendReply();
  }
}

void sub_101003CA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1000DB0A0(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101003CC0(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_101003CFC(uint64_t a1)
{
  sub_100134750(__p, "com.apple.locationd.activity");
  char v2 = sub_1010A4BAC(a1);
  char v3 = v2;
  if (v20 < 0)
  {
    operator delete(*(void **)__p);
    if (v3) {
      goto LABEL_3;
    }
LABEL_6:
    if (qword_102419100 != -1) {
      dispatch_once(&qword_102419100, &stru_10230ADD8);
    }
    char v5 = qword_102419108;
    if (os_log_type_enabled((os_log_t)qword_102419108, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 24);
      *(_DWORD *)long long __p = 138477827;
      *(void *)&__p[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Client %{private}@ does not have appropriate motion entitlement.", __p, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419100 != -1) {
        dispatch_once(&qword_102419100, &stru_10230ADD8);
      }
      uint64_t v9 = *(void *)(a1 + 24);
      int v17 = 138477827;
      uint64_t v18 = v9;
      unsigned int v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLSafetyAnomalySubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)", "%s\n", v10);
      if (v10 != __p) {
        free(v10);
      }
    }
    uint64_t v15 = CMErrorMessage;
    char v16 = &off_1023938C0;
    +[NSDictionary dictionaryWithObjects:&v16 forKeys:&v15 count:1];
    CLConnectionMessage::sendReply();
    return 0;
  }
  if ((v2 & 1) == 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (sub_101523560()) {
    return 1;
  }
  if (qword_102419100 != -1) {
    dispatch_once(&qword_102419100, &stru_10230ADD8);
  }
  uint64_t v7 = qword_102419108;
  if (os_log_type_enabled((os_log_t)qword_102419108, OS_LOG_TYPE_ERROR))
  {
    uint64_t v8 = *(void *)(a1 + 24);
    *(_DWORD *)long long __p = 138477827;
    *(void *)&__p[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Client %{private}@ is not available on this platform.", __p, 0xCu);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419100 != -1) {
      dispatch_once(&qword_102419100, &stru_10230ADD8);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    int v17 = 138477827;
    uint64_t v18 = v11;
    id v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLSafetyAnomalySubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)", "%s\n", v12);
    if (v12 != __p) {
      free(v12);
    }
  }
  uint64_t v13 = CMErrorMessage;
  id v14 = &off_1023938D8;
  +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
  CLConnectionMessage::sendReply();
  return 0;
}

void sub_1010040D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010040F8(id a1)
{
  qword_102419108 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Kappa");
}

void sub_101004128(id a1)
{
  qword_102419328 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Igneous");
}

__n128 sub_101004158(uint64_t a1)
{
  char v2 = (char *)operator new(0x18uLL);
  *(void *)char v2 = off_10230AE28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010041A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230AE28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010041D4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_1010041DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100421C()
{
}

void sub_101004228(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  id v4 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  char v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if (v6) {
    char v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v8 = v3;
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v5(v7, &v8);
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v4) {
    sub_1000DB0A0(v4);
  }
}

void sub_1010042C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  if (v10) {
    sub_1000DB0A0(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010042EC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_101004368(a1, a2, (long long *)a2);
      a2 += 56;
      v5 -= 56;
    }
    while (v5);
  }
  return a1;
}

void sub_101004354(_Unwind_Exception *a1)
{
  sub_100BFA7F0(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_101004368(uint64_t a1, unsigned __int8 *a2, long long *a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }
  sub_1010045EC(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100100330(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  int v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *int v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  sub_1010046DC((uint64_t)v25, 0);
  return i;
}

void sub_1010045D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1010046DC((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_1010045EC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  __n128 result = sub_101004664(v8 + 2, a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_10100464C(_Unwind_Exception *a1)
{
  sub_1010046DC(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_101004664(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_100BF9FA8((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_1010046C0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010046DC(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100BFA870((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t sub_101004734(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (*(double *)(a2 + 288) != -1.79769313e308 && *(double *)(a2 + 328) == 0.0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v9 = Current + -8.0;
    uint64_t v8 = 0;
    float v7 = 0.0;
    long long v4 = (void *)(*(uint64_t (**)(void))(**(void **)a1 + 16))();
    uint64_t v5 = operator new(0x30uLL);
    void *v5 = off_10230AEB8;
    v5[1] = &v9;
    _DWORD v5[2] = &Current;
    void v5[3] = (char *)&v8 + 4;
    void v5[4] = &v8;
    v5[5] = &v7;
    void v11[3] = v5;
    sub_1005E68B4(v4, (uint64_t)v11);
    sub_1005E73C4(v11);
    if (SHIDWORD(v8) >= 6)
    {
      if ((float)(*(float *)&v8 - v7) > 2.0 || *(float *)&v8 > 6.0) {
        return 2;
      }
      else {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_101004880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1005E73C4((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101004894(_DWORD *a1)
{
  int v1 = *a1 - 4;
  if (v1 > 8) {
    return 0;
  }
  else {
    return byte_101D9CB1E[v1];
  }
}

std::string *sub_1010048BC@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  int v13 = 0;
  long long v4 = v31;
  for (unint64_t i = 7; i > 1; --i)
  {
    v4[8] = xmmword_101D9C8F8;
    v4[9] = unk_101D9C908;
    v4[10] = xmmword_101D9C918;
    v4[11] = unk_101D9C928;
    void v4[4] = xmmword_101D9C8B8;
    void v4[5] = unk_101D9C8C8;
    v4[6] = xmmword_101D9C8D8;
    v4[7] = unk_101D9C8E8;
    _OWORD *v4 = xmmword_101D9C878;
    v4[1] = unk_101D9C888;
    void v4[2] = xmmword_101D9C898;
    v4[3] = unk_101D9C8A8;
    v4 += 12;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v11 = Current + -8.0;
  uint64_t v6 = (void *)(*(uint64_t (**)(void))(**(void **)a1 + 16))();
  float v7 = operator new(0x28uLL);
  void *v7 = off_10230AF38;
  v7[1] = &v11;
  _DWORD v7[2] = &Current;
  void v7[3] = &v13;
  v7[4] = v31;
  v30[3] = v7;
  sub_1005E68B4(v6, (uint64_t)v30);
  sub_1005E73C4(v30);
  sub_100134750(a2, "");
  unint64_t v8 = 0;
  double v9 = (double *)v31;
  do
  {
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    *(_OWORD *)std::string __str = 0u;
    snprintf(__str, 0x100uLL, "gpsStartTime%d,%.4f,gpsRawSpeed%d,%.4f,gpsDist%d,%.4f", v8, *v9, v8, v9[5], v8, v9[1]);
    uint64_t result = std::string::append(a2, __str);
    if (v8 <= 4) {
      uint64_t result = std::string::append(a2, ",");
    }
    ++v8;
    v9 += 24;
  }
  while (v8 != 6);
  return result;
}

void sub_101004AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

void sub_101004B00()
{
}

__n128 sub_101004B14(uint64_t a1)
{
  char v2 = (char *)operator new(0x30uLL);
  *(void *)char v2 = off_10230AEB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_101004B70(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230AEB8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4sub_100FB8FC8(&a9, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float sub_101004BB0(uint64_t a1, double *a2)
{
  double v2 = *a2;
  if (*a2 >= **(double **)(a1 + 8) && v2 <= **(double **)(a1 + 16))
  {
    long long v3 = *(int **)(a1 + 24);
    int v4 = *v3;
    unsigned int v5 = *v3 + 1;
    *long long v3 = v5;
    if (v4 <= 2)
    {
      uint64_t v6 = (float **)(a1 + 32);
LABEL_7:
      float v7 = *v6;
      *(float *)&double v2 = a2[1] + *v7;
      float *v7 = *(float *)&v2;
      return *(float *)&v2;
    }
    if (v5 <= 6)
    {
      uint64_t v6 = (float **)(a1 + 40);
      goto LABEL_7;
    }
  }
  return *(float *)&v2;
}

uint64_t sub_101004C20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101004C60()
{
}

void sub_101004C70()
{
}

__n128 sub_101004C84(uint64_t a1)
{
  double v2 = (char *)operator new(0x28uLL);
  *(void *)double v2 = off_10230AF38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101004CD8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230AF38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_101004D10(uint64_t a1, long long *a2)
{
  result.n128_u64[0] = *(void *)a2;
  if (*(double *)a2 >= **(double **)(a1 + 8) && result.n128_f64[0] <= **(double **)(a1 + 16))
  {
    int v3 = **(_DWORD **)(a1 + 24);
    if (v3 <= 5)
    {
      uint64_t v4 = *(void *)(a1 + 32) + 192 * v3;
      long long v5 = *a2;
      long long v6 = a2[1];
      long long v7 = a2[3];
      *(_OWORD *)(v4 + 32) = a2[2];
      *(_OWORD *)(v4 + 48) = v7;
      *(_OWORD *)uint64_t v4 = v5;
      *(_OWORD *)(v4 + 16) = v6;
      long long v8 = a2[4];
      long long v9 = a2[5];
      long long v10 = a2[7];
      *(_OWORD *)(v4 + 96) = a2[6];
      *(_OWORD *)(v4 + 112) = v10;
      *(_OWORD *)(v4 + 64) = v8;
      *(_OWORD *)(v4 + 8sub_100FB8FC8(&a9, 0) = v9;
      __n128 result = (__n128)a2[8];
      long long v11 = a2[9];
      long long v12 = a2[11];
      *(_OWORD *)(v4 + 16sub_100FB8FC8(&a9, 0) = a2[10];
      *(_OWORD *)(v4 + 176) = v12;
      *(__n128 *)(v4 + 128) = result;
      *(_OWORD *)(v4 + 144) = v11;
      ++**(_DWORD **)(a1 + 24);
    }
  }
  return result;
}

uint64_t sub_101004D94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101004DD4()
{
}

void sub_101004DE0(id a1)
{
  qword_1024828B8 = [CLClientKeyPath_32 alloc];
  if (_os_feature_enabled_impl())
  {
    strlcat((char *)(qword_1024828B8 + 8), (const char *)[(id)qword_1024828B0 UTF8String], 0x18uLL);
    strlcat((char *)(qword_1024828B8 + 8), ":", 0x18uLL);
  }
  int v1 = (char *)(qword_1024828B8 + 8);

  strlcat(v1, "!:", 0x18uLL);
}

BOOL sub_101004E8C(BOOL result)
{
  if (result)
  {
    int v1 = (void *)result;
    if (([(id)result isEqualToString:qword_1024828A8] & 1) != 0
      || ([v1 isEqualToString:qword_1024828B0] & 1) != 0)
    {
      return 1;
    }
    else
    {
      return sub_1004BF638(v1);
    }
  }
  return result;
}

uint64_t sub_101005C68()
{
  if (qword_1024828C8 != -1) {
    dispatch_once(&qword_1024828C8, &stru_10230AFC8);
  }
  return qword_1024828D0;
}

void sub_101005CAC(id a1)
{
  qword_1024828D0 = (uint64_t)[objc_alloc((Class)NSPointerFunctions) initWithOptions:0];
  [(id)qword_1024828D0 setHashFunction:sub_100170A98];
  int v1 = (void *)qword_1024828D0;

  _[v1 setIsEqualFunction:sub_100170B08];
}

uint64_t sub_101005D1C()
{
  if (qword_1024828D8 != -1) {
    dispatch_once(&qword_1024828D8, &stru_10230AFE8);
  }
  return qword_1024828E0;
}

void sub_101005D60(id a1)
{
  qword_1024828E0 = (uint64_t)[objc_alloc((Class)NSPointerFunctions) initWithOptions:0];
}

void sub_101005D90(id a1)
{
  qword_102419538 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

BOOL sub_101005DC0()
{
  double v2 = *(NSObject **)(v0 + 1336);
  return os_signpost_enabled(v2);
}

void sub_101005DD8()
{
  sub_10151FB90(__p);
  if (v5 >= 0) {
    uint64_t v0 = __p;
  }
  else {
    uint64_t v0 = (void **)__p[0];
  }
  uint64_t v1 = +[NSString stringWithUTF8String:v0];
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  qword_1024828A8 = (uint64_t)v1;
  sub_10151FBA0(__p);
  if (v5 >= 0) {
    double v2 = __p;
  }
  else {
    double v2 = (void **)__p[0];
  }
  int v3 = +[NSString stringWithUTF8String:v2];
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  qword_1024828B0 = (uint64_t)v3;
}

void sub_101005E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101005EB8(uint64_t a1, int a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  uint64_t v4 = (uint64_t *)(a1 + 88);
  char v5 = (std::string *)(a1 + 96);
  *(_OWORD *)(a1 + 104) = 0u;
  *(unsigned char *)(a1 + 12sub_100FB8FC8(&a9, 0) = 0;
  sub_100513074(a1 + 128, "CMHealthColdStorageManager", 0, 1);
  *(_WORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  long long v6 = (char *)operator new(0x58uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)long long v6 = off_10230B058;
  *(_OWORD *)(v6 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *((void *)v6 + 9) = 0;
  *((void *)v6 + 1sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((void *)v6 + 6) = v6 + 56;
  long long v7 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = v6 + 24;
  *(void *)(a1 + 48) = v6;
  if (v7) {
    sub_1000DB0A0(v7);
  }
  if (a2)
  {
    *(unsigned char *)(a1 + 12sub_100FB8FC8(&a9, 0) = 1;
    *(unsigned char *)(*(void *)(a1 + 40) + 48) = 1;
    *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = [[CMHealthColdStorageCloudKitManager alloc] initWithColdStorageManager:a1];
  }
  uint64_t v8 = sub_1000A6958();
  sub_1000A6A10(v8, @"kColdStorageSyncStartTime", v4);
  if (qword_102419300 != -1) {
    dispatch_once(&qword_102419300, &stru_10230B028);
  }
  long long v9 = qword_102419308;
  if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *v4;
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "[Manager] CMHealthColdStorageManager fStartSyncTime: %f", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    uint64_t v16 = *v4;
    LODWORD(v18) = 134217984;
    *(void *)((char *)&v18 + 4) = v16;
    long long v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CMHealthColdStorageManager::CMHealthColdStorageManager(BOOL)", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
  std::string::assign(v5, "");
  uint64_t v11 = sub_1000A6958();
  sub_1000A7CF8(v11, @"kColdStorageInstanceUUID", v5);
  if (*(char *)(a1 + 119) < 0)
  {
    if (*(void *)(a1 + 104)) {
      goto LABEL_17;
    }
  }
  else if (*(unsigned char *)(a1 + 119))
  {
    goto LABEL_17;
  }
  memset(out, 0, sizeof(out));
  uuid_generate(out);
  *(_OWORD *)uint64_t buf = 0u;
  memset(v22, 0, sizeof(v22));
  uuid_unparse(out, (char *)buf);
  sub_100134750(&v18, (char *)buf);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(v5->__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v18;
  v5->__r_.__value_.__r.__words[2] = v19;
  uint64_t v12 = sub_1000A6958();
  sub_1004D3820(v12, @"kColdStorageInstanceUUID", (char *)v5);
  uint64_t v13 = sub_1000A6958();
  (*(void (**)(uint64_t))(*(void *)v13 + 944))(v13);
LABEL_17:
  uint64_t v14 = sub_1000A6958();
  sub_1000D29FC(v14, @"HealthColdStorageVO2MaxDeletionComplete", (BOOL *)(a1 + 148));
  return a1;
}

void sub_101006274(_Unwind_Exception *a1)
{
  sub_10051310C(v4);
  if (*(char *)(v1 + 119) < 0) {
    operator delete(*v3);
  }
  sub_1010090E8(v2, *(void **)(v1 + 64));
  long long v6 = *(std::__shared_weak_count **)(v1 + 48);
  if (v6) {
    sub_1000DB0A0(v6);
  }
  sub_101009004(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010062D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 80);
    if (v2)
    {

      *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
    }
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  if (v3) {
    sub_1000DB0A0(v3);
  }
  sub_10051310C(a1 + 128);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  sub_1010090E8(a1 + 56, *(void **)(a1 + 64));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_1000DB0A0(v4);
  }

  return sub_101009004(a1);
}

void sub_10100636C(uint64_t a1, uint64_t a2, std::string::size_type a3, unsigned __int8 a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  unsigned __int8 v25 = a4;
  uint64_t v24 = a6;
  unsigned __int8 v23 = a7;
  if (*(char *)(a2 + 23) >= 0) {
    size_t v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v10 = *(void *)(a2 + 8);
  }
  p_p = &__p;
  sub_1001110E4((uint64_t)&__p, v10 + 1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v10)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v12 = (const void *)a2;
    }
    else {
      uint64_t v12 = *(const void **)a2;
    }
    memmove(p_p, v12, v10);
  }
  *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v1sub_100FB8FC8(&a9, 0) = 46;
  int v13 = *(char *)(a3 + 23);
  if (v13 >= 0) {
    uint64_t v14 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v14 = *(const std::string::value_type **)a3;
  }
  if (v13 >= 0) {
    std::string::size_type v15 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v15 = *(void *)(a3 + 8);
  }
  uint64_t v16 = std::string::append(&__p, v14, v15);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  std::string::size_type v22 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long v21 = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*(char *)(a3 + 23) >= 0) {
    std::string::size_type v18 = a3;
  }
  else {
    std::string::size_type v18 = *(void *)a3;
  }
  __p.__r_.__value_.__r.__words[0] = v18;
  uint64_t v27 = a1;
  int v20 = 1106247680;
  sub_101009220((uint64_t)&v26, &__p.__r_.__value_.__l.__data_, &v25, &v27, &v23, (float *)&v20, a2, &v24);
}

void sub_101006620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21) {
    sub_1000DB0A0(a21);
  }
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101006690(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1010066D0(uint64_t a1, uint64_t a2)
{
  sub_1000E1294((uint64_t *)v37, (uint64_t)"CMHealthColdStorageManager.sync", 0);
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  if (v4)
  {
    char v5 = (unsigned __int16 *)(a1 + 144);
    long long v6 = (unsigned __int16 *)(a1 + 146);
    uint64_t v7 = 100;
    while (1)
    {
      int v8 = *((_DWORD *)v4 + 17);
      long long v9 = v6;
      if (v8)
      {
        if (v8 != 1) {
          goto LABEL_10;
        }
        long long v9 = v5;
      }
      unsigned int v10 = *v9;
      if (v10 >= 0x100 && v10 == 0)
      {
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        char v26 = v4 + 5;
        uint64_t v27 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
        {
          long long v28 = v4 + 5;
          if (*((char *)v4 + 63) < 0) {
            long long v28 = (void *)*v26;
          }
          int v29 = *((_DWORD *)v4 + 17);
          *(_DWORD *)uint64_t buf = 67240450;
          LODWORD(v43[0]) = v29;
          WORD2(v43[0]) = 2082;
          *(void *)((char *)v43 + 6) = v28;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "[Manager] FitnessTracking disabled, preventing sync (source=%{public}d, table=%{public}s)", buf, 0x12u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          int v30 = *((_DWORD *)v4 + 17);
          if (*((char *)v4 + 63) < 0) {
            char v26 = (void *)*v26;
          }
          LODWORD(__p) = 67240450;
          HIDWORD(__p) = v30;
          LOWORD(v41) = 2082;
          *(void *)((char *)&v41 + 2) = v26;
          double v31 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "CMError CMHealthColdStorageManager::sync(ShouldInterruptCheck)", "%s\n", v31);
          if (v31 != (char *)buf) {
            free(v31);
          }
        }
        goto LABEL_59;
      }
LABEL_10:
      uint64_t v12 = v4[9];
      double v13 = *(double *)(a1 + 88);
      uint64_t v14 = *(std::__shared_weak_count **)(a1 + 48);
      uint64_t v35 = *(void *)(a1 + 40);
      uint64_t v36 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = sub_10044B008(v12, a1 + 96, &v35, v13);
      if (v36) {
        sub_1000DB0A0(v36);
      }
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
      std::string::size_type v15 = v4 + 2;
      uint64_t v16 = qword_102419308;
      if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
      {
        long long v17 = v4 + 2;
        if (*((char *)v4 + 39) < 0) {
          long long v17 = (void *)*v15;
        }
        *(_DWORD *)uint64_t buf = 67109378;
        LODWORD(v43[0]) = v7;
        WORD2(v43[0]) = 2080;
        *(void *)((char *)v43 + 6) = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "[Manager] syncFromHot returned %d for DB: %s", buf, 0x12u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        if (*((char *)v4 + 39) < 0) {
          std::string::size_type v15 = (void *)*v15;
        }
        LODWORD(__p) = 67109378;
        HIDWORD(__p) = v7;
        LOWORD(v41) = 2080;
        *(void *)((char *)&v41 + 2) = v15;
        uint64_t v32 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "CMError CMHealthColdStorageManager::sync(ShouldInterruptCheck)", "%s\n", v32);
        if (v32 != (char *)buf) {
          free(v32);
        }
      }
      if ((v7 == 112 || v7 == 100) && sub_10044D294(v4[9]))
      {
        uint64_t v18 = v4[9];
        long long v41 = 0uLL;
        std::string __p = 0;
        sub_10010F834(&__p, *(const void **)(v18 + 320), *(void *)(v18 + 328), (uint64_t)(*(void *)(v18 + 328) - *(void *)(v18 + 320)) >> 2);
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        std::string::size_type v19 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 134217984;
          v43[0] = (uint64_t)(v41 - (void)__p) >> 2;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "[Manager] Number of pending samples to send to cloud: %zu", buf, 0xCu);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          int v38 = 134217984;
          uint64_t v39 = (uint64_t)(v41 - (void)__p) >> 2;
          unint64_t v33 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "CMError CMHealthColdStorageManager::sync(ShouldInterruptCheck)", "%s\n", v33);
          if (v33 != (char *)buf) {
            free(v33);
          }
        }
        int v20 = __p;
        if (__p == (void *)v41)
        {
          long long v6 = (unsigned __int16 *)(a1 + 146);
          if (__p) {
            goto LABEL_54;
          }
        }
        else
        {
          long long v21 = v5;
          std::string::size_type v22 = +[NSMutableArray arrayWithCapacity:(uint64_t)(v41 - (void)__p) >> 2];
          uint64_t v24 = (unsigned int *)__p;
          unsigned __int8 v23 = (unsigned int *)v41;
          while (v24 != v23)
          {
            uint64_t v25 = a1 + 96;
            if (*(char *)(a1 + 119) < 0) {
              uint64_t v25 = *(void *)(a1 + 96);
            }
            [(NSMutableArray *)v22 addObject:+[NSString stringWithFormat:@"%d-%s", *v24++, v25]];
          }
          char v5 = v21;
          long long v6 = (unsigned __int16 *)(a1 + 146);
          if (!*(unsigned char *)(a1 + 120)
            || (objc_msgSend(*(id *)(a1 + 80), "addPendingRecordChanges:forZoneName:", +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v22), objc_msgSend((id)(*(uint64_t (**)(void))(*(void *)(v4[9] + 72) + 40))(), "zoneName")) & 1) != 0)
          {
            *(void *)(v4[9] + 328) = *(void *)(v4[9] + 320);
          }
          int v20 = __p;
          if (__p)
          {
LABEL_54:
            *(void *)&long long v41 = v20;
            operator delete(v20);
          }
        }
      }
      else if (!sub_10044D294(v4[9]))
      {
        *(void *)(v4[9] + 328) = *(void *)(v4[9] + 320);
      }
      if (a2 && ((*(uint64_t (**)(uint64_t))(a2 + 16))(a2) & 1) != 0 || v7 != 112 && v7 != 100) {
        goto LABEL_74;
      }
LABEL_59:
      uint64_t v4 = (uint64_t *)*v4;
      if (!v4) {
        goto LABEL_74;
      }
    }
  }
  uint64_t v7 = 100;
LABEL_74:
  sub_1000E1098(v37);
  return v7;
}

void sub_101006E10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000E1098(&a21);
  _Unwind_Resume(a1);
}

void sub_101006E78(uint64_t a1, const void **a2, void *a3)
{
  uint64_t v5 = sub_10012FFE0(a1 + 56, a2);
  if (a1 + 64 != v5)
  {
    uint64_t v7 = *(void *)(v5 + 56);
    uint64_t v6 = *(void *)(v5 + 64);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    int v8 = (std::__shared_weak_count *)a3[1];
    *a3 = v7;
    a3[1] = v6;
    if (v8)
    {
      sub_1000DB0A0(v8);
    }
  }
}

void *sub_101006EEC(void *result, uint64_t a2)
{
  if (*((unsigned char *)result + 120))
  {
    __n128 result = (void *)result[10];
    if (result) {
      return _[result updateDeviceUnlockedState:a2];
    }
  }
  return result;
}

id sub_101006F08(uint64_t a1, void *a2)
{
  sub_100134750(__p, (char *)[objc_msgSend(objc_msgSend(objc_msgSend(a2, "zoneID"), "zoneName"), "UTF8String"]);
  uint64_t v16 = 0;
  long long v17 = 0;
  sub_101006E78(a1, (const void **)__p, &v16);
  uint64_t v4 = v16;
  if (v16 && (uint64_t v5 = v16 + 9, (*(uint64_t (**)(void *))(v16[9] + 40))(v16 + 9)))
  {
    sub_1000E1294((uint64_t *)v15, (uint64_t)"CMHealthColdStorageManager.ckRecordForRecordID", 0);
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10044E06C(v4, a2, &v14);
    if (v14)
    {
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
      uint64_t v6 = qword_102419308;
      if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "[Manager] ckRecordForRecordID, no system field exists, creating a new record", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        LOWORD(v2sub_100FB8FC8(&a9, 0) = 0;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "CKRecord *CMHealthColdStorageManager::ckRecordForRecordID(CKRecordID *)", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
      id v7 = [objc_alloc((Class)CKRecord) initWithRecordType:[(*(uint64_t (**)(void *))(*v5 + 40))(v5) recordType] recordID:a2];
      id v8 = [v7 encryptedValues];
      [v8 setObject:v14 forKey:[(*(uint64_t (**)(void *))(*v5 + 40))(v5) dataFieldKey]];
    }
    else
    {
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
      long long v9 = qword_102419308;
      if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 138412290;
        unsigned __int8 v23 = a2;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#warning: Requested CKRecord for a record ID that does not exist (%@)", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        int v20 = 138412290;
        long long v21 = a2;
        uint64_t v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "CKRecord *CMHealthColdStorageManager::ckRecordForRecordID(CKRecordID *)", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
      id v7 = 0;
    }
    sub_1000E1098(v15);
  }
  else
  {
    id v7 = 0;
  }
  if (v17) {
    sub_1000DB0A0(v17);
  }
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_10100755C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17) {
    sub_1000DB0A0(a17);
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1010075B0(uint64_t a1, void *a2, void *a3)
{
  if (!a2) {
    return 0;
  }
  sub_100134750(__p, (char *)[objc_msgSend(objc_msgSend(objc_msgSend(a2, "zoneID"), "zoneName"), "UTF8String"]);
  uint64_t v8 = 0;
  long long v9 = 0;
  sub_101006E78(a1, (const void **)__p, &v8);
  if (v8) {
    uint64_t v6 = sub_10044E388(v8, a2, a3);
  }
  else {
    uint64_t v6 = 0;
  }
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_101007664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10100768C(CFAbsoluteTime *a1)
{
  uint64_t v1 = a1;
  a1[11] = CFAbsoluteTimeGetCurrent();
  v1 += 11;
  uint64_t v2 = sub_1000A6958();
  sub_100163398(v2, @"kColdStorageSyncStartTime", v1);
  uint64_t v3 = *(void *)sub_1000A6958();
  uint64_t result = (*(uint64_t (**)(void))(v3 + 944))();
  for (unint64_t i = (void *)*((void *)v1 - 9); i; unint64_t i = (void *)*i)
    uint64_t result = sub_1011F9E28((void *)(i[9] + 72));
  return result;
}

uint64_t sub_101007720(uint64_t result)
{
  for (unint64_t i = *(void **)(result + 16); i; unint64_t i = (void *)*i)
    uint64_t result = sub_10044E670(i[9]);
  return result;
}

void sub_101007754(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100134750(__p, (char *)[a2 UTF8String]);
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    sub_101006E78(a1, (const void **)__p, &v3);
    if (v3) {
      sub_10044E670(v3);
    }
    if (v4) {
      sub_1000DB0A0(v4);
    }
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1010077D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010077F8(uint64_t a1, void *a2)
{
  sub_100134750(__p, (char *)[objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordID"), "zoneID"), "zoneName") UTF8String]);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  sub_101006E78(a1, (const void **)__p, &v4);
  if (v4) {
    sub_10044E67C(v4, a2);
  }
  if (v5) {
    sub_1000DB0A0(v5);
  }
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_101007884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010078AC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (!v1) {
    return 1;
  }
  LOBYTE(result) = 1;
  do
  {
    if (result) {
      uint64_t result = sub_100082064(v1[9] + 72);
    }
    else {
      uint64_t result = 0;
    }
    uint64_t v1 = (void *)*v1;
  }
  while (v1);
  return result;
}

uint64_t sub_1010078FC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101007918(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = result;
    uint64_t result = CKErrorIsCode();
    if (result)
    {
      ++*(_DWORD *)(*(void *)(v2 + 40) + 8);
    }
    else
    {
      uint64_t result = CKErrorIsCode();
      if (result)
      {
        ++*(_DWORD *)(*(void *)(v2 + 40) + 12);
      }
      else
      {
        uint64_t result = CKErrorIsCode();
        if (result)
        {
          ++*(_DWORD *)(*(void *)(v2 + 40) + 16);
        }
        else
        {
          uint64_t result = CKErrorIsCode();
          uint64_t v3 = *(_DWORD **)(v2 + 40);
          if (result) {
            ++v3[1];
          }
          else {
            ++*v3;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1010079E0(uint64_t a1)
{
  uint64_t v2 = a1 + 128;
  uint64_t v1 = *(void *)(a1 + 128);
  v36[1] = a1 + 128;
  (*(void (**)(uint64_t))(v1 + 16))(a1 + 128);
  __int16 v37 = 256;
  sub_10053B70C(0, (std::string *)__p);
  if (__p[23] >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = *(unsigned char **)__p;
  }
  uint64_t v4 = +[NSString stringWithUTF8String:v3];
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v5 = +[NSFileManager defaultManager];
  if (![(NSFileManager *)v5 fileExistsAtPath:v4])
  {
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    uint64_t v16 = qword_102419308;
    if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "[Migration] No legacy database to migrate", __p, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
      LOWORD(v38) = 0;
      int v30 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v30);
      if (v30 != __p) {
        free(v30);
      }
    }
    goto LABEL_41;
  }
  uint64_t v35 = [[CLOSTransaction alloc] initWithDescription:"CMHealthColdStorageManager.preinitialization"];
  if (qword_102419300 != -1) {
    dispatch_once(&qword_102419300, &stru_10230B028);
  }
  char v6 = qword_102419308;
  if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 138412290;
    *(void *)&__p[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[Migration] Migrating database at path %@", __p, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    int v38 = 138412290;
    uint64_t v39 = v4;
    double v31 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v31);
    if (v31 != __p) {
      free(v31);
    }
  }
  sub_10053B70C(2, (std::string *)__p);
  if (__p[23] >= 0) {
    char v7 = __p;
  }
  else {
    char v7 = *(unsigned char **)__p;
  }
  uint64_t v8 = +[NSString stringWithUTF8String:v7];
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  long long v9 = [(NSString *)v8 UTF8String];
  uid_t v10 = getuid();
  gid_t v11 = getgid();
  if (!sub_1004BB250(v9, v10, v11))
  {
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    uint64_t v18 = qword_102419308;
    if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_FAULT))
    {
      char v19 = [(NSString *)v8 UTF8String];
      *(void *)std::string __p = 68289282;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(void *)&__p[20] = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"could not create path\", \"path\":%{public, location:escape_only}s}", __p, 0x1Cu);
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
    }
    int v20 = qword_102419308;
    if (os_signpost_enabled((os_log_t)qword_102419308))
    {
      long long v21 = [(NSString *)v8 UTF8String];
      *(void *)std::string __p = 68289282;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(void *)&__p[20] = v21;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "could not create path", "{\"msg%{public}.0s\":\"could not create path\", \"path\":%{public, location:escape_only}s}", __p, 0x1Cu);
    }

LABEL_87:
    uint64_t v17 = 0;
    goto LABEL_88;
  }
  chmod([(NSString *)v8 UTF8String], 0x1EFu);
  sub_10053B70C(1, (std::string *)__p);
  if (__p[23] >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = *(unsigned char **)__p;
  }
  uint64_t v13 = +[NSString stringWithUTF8String:v12];
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  v36[0] = 0;
  if (![(NSFileManager *)v5 fileExistsAtPath:v13])
  {
    for (unint64_t i = 0; ; ++i)
    {
      if ((unint64_t)[&off_102397EF0 count] <= i) {
        goto LABEL_73;
      }
      unsigned __int8 v23 = (NSString *)[&off_102397EF0 objectAtIndex:i];
      if ([(NSFileManager *)v5 moveItemAtPath:[(NSString *)v4 stringByAppendingString:v23] toPath:[(NSString *)v13 stringByAppendingString:v23] error:v36])
      {
        chmod([[(NSString *)v13 stringByAppendingString:v23] UTF8String], 0x1EFu);
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        uint64_t v24 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 138543875;
          *(void *)&__p[4] = v23;
          *(_WORD *)&unsigned char __p[12] = 2113;
          *(void *)&__p[14] = v4;
          *(_WORD *)&__p[22] = 2113;
          *(void *)&__p[24] = v13;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "[Migration] Successfully moved db%{public}@ from %{private}@ to %{private}@", __p, 0x20u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          int v38 = 138543875;
          uint64_t v39 = v23;
          __int16 v40 = 2113;
          long long v41 = v4;
          __int16 v42 = 2113;
          BOOL v43 = v13;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v25);
LABEL_71:
          if (v25 != __p) {
            free(v25);
          }
          continue;
        }
      }
      else
      {
        if (!i)
        {
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          uint64_t v27 = qword_102419308;
          if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 138412802;
            *(void *)&__p[4] = v36[0];
            *(_WORD *)&unsigned char __p[12] = 2112;
            *(void *)&__p[14] = v4;
            *(_WORD *)&__p[22] = 2112;
            *(void *)&__p[24] = v13;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "[Migration] Unable to move root file, error: %@, move from %@ to %@", __p, 0x20u);
          }
          if (sub_10013D1A0(115, 0))
          {
            bzero(__p, 0x65CuLL);
            if (qword_102419300 != -1) {
              dispatch_once(&qword_102419300, &stru_10230B028);
            }
            int v38 = 138412802;
            uint64_t v39 = (NSString *)v36[0];
            __int16 v40 = 2112;
            long long v41 = v4;
            __int16 v42 = 2112;
            BOOL v43 = v13;
            uint64_t v34 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v34);
            if (v34 != __p) {
              free(v34);
            }
          }
          if ([(NSFileManager *)v5 removeItemAtPath:v13 error:v36]) {
            goto LABEL_86;
          }
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          long long v28 = qword_102419308;
          if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 138412290;
            *(void *)&__p[4] = v36[0];
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "[Migration] Unable to remove corrupted mobile file, error: %@", __p, 0xCu);
          }
          if (!sub_10013D1A0(115, 0)) {
            goto LABEL_86;
          }
          bzero(__p, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          int v38 = 138412290;
          uint64_t v39 = (NSString *)v36[0];
          unint64_t v33 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v33);
          if (v33 == __p) {
            goto LABEL_86;
          }
          goto LABEL_112;
        }
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        char v26 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 138412546;
          *(void *)&__p[4] = v23;
          *(_WORD *)&unsigned char __p[12] = 2112;
          *(void *)&__p[14] = v36[0];
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[Migration] #Warning: Unable to move %@, error: %@", __p, 0x16u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          int v38 = 138412546;
          uint64_t v39 = v23;
          __int16 v40 = 2112;
          long long v41 = (NSString *)v36[0];
          uint64_t v25 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v25);
          goto LABEL_71;
        }
      }
    }
  }
  if (qword_102419300 != -1) {
    dispatch_once(&qword_102419300, &stru_10230B028);
  }
  uint64_t v14 = qword_102419308;
  if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "[Migration] DB exists in two locations. Deleting root", __p, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    LOWORD(v38) = 0;
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v32);
    if (v32 != __p) {
      free(v32);
    }
  }
  [(NSFileManager *)v5 removeItemAtPath:v4 error:v36];
  if (v36[0])
  {
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    std::string::size_type v15 = qword_102419308;
    if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 138412290;
      *(void *)&__p[4] = v36[0];
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[ColdStorage] Unable to delete mobile cold storage directory, error: %@", __p, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419300 != -1) {
        dispatch_once(&qword_102419300, &stru_10230B028);
      }
      int v38 = 138412290;
      uint64_t v39 = (NSString *)v36[0];
      unint64_t v33 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v33);
      if (v33 != __p) {
LABEL_112:
      }
        free(v33);
    }
LABEL_86:

    goto LABEL_87;
  }
LABEL_73:

LABEL_41:
  uint64_t v17 = 1;
LABEL_88:
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  return v17;
}

void sub_1010088E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_101008974(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 144) = a2 | 0x100;
  if ((a2 & 1) == 0) {
    sub_10100898C(a1, 1);
  }
}

void sub_10100898C(uint64_t a1, int a2)
{
  for (unint64_t i = *(uint64_t **)(a1 + 16); i; unint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 17) == a2)
    {
      uint64_t v4 = i + 5;
      if (sub_100082064(i[9] + 72))
      {
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        uint64_t v5 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEFAULT))
        {
          char v6 = i + 5;
          if (*((char *)i + 63) < 0) {
            char v6 = (uint64_t *)*v4;
          }
          *(_DWORD *)uint64_t buf = 136446466;
          uint64_t v12 = v6;
          __int16 v13 = 1026;
          int v14 = a2;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[Manager] Deleting Table: %{public}s, source: %{public}d", buf, 0x12u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          long long v9 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CMHealthColdStorageManager::deleteTablesBySource(SourceDevice)", "%s\n", v9);
          if (v9 != (char *)buf) {
            free(v9);
          }
        }
        sub_1011F9E28((void *)(i[9] + 72));
      }
      else
      {
        if (qword_102419300 != -1) {
          dispatch_once(&qword_102419300, &stru_10230B028);
        }
        char v7 = qword_102419308;
        if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = i + 5;
          if (*((char *)i + 63) < 0) {
            uint64_t v8 = (uint64_t *)*v4;
          }
          *(_DWORD *)uint64_t buf = 136446466;
          uint64_t v12 = v8;
          __int16 v13 = 1026;
          int v14 = a2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[Manager] Database inaccessible, could not delete table: %{public}s, source: %{public}d", buf, 0x12u);
        }
        if (sub_10013D1A0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419300 != -1) {
            dispatch_once(&qword_102419300, &stru_10230B028);
          }
          uid_t v10 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 0, "void CMHealthColdStorageManager::deleteTablesBySource(SourceDevice)", "%s\n", v10);
          if (v10 != (char *)buf) {
            free(v10);
          }
        }
      }
    }
  }
}

void sub_101008D1C(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 146) = a2 | 0x100;
  if ((a2 & 1) == 0) {
    sub_10100898C(a1, 0);
  }
}

id *sub_101008D34(uint64_t a1)
{
  sub_1000E1294((uint64_t *)v10, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0);
  uint64_t v2 = (uint64_t *)(a1 + 16);
  do
  {
    uint64_t v2 = (uint64_t *)*v2;
    if (!v2)
    {
      uint64_t v3 = 0;
      goto LABEL_13;
    }
  }
  while (!*((unsigned char *)v2 + 64));
  uint64_t v4 = v2[9];
  uint64_t v3 = (std::__shared_weak_count *)v2[10];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4 && (sub_100082064(v4 + 72) & 1) != 0)
  {
    if (!*(unsigned char *)(a1 + 148) && sub_10044A868(v4, "VO2MaxInputHistory"))
    {
      *(unsigned char *)(a1 + 148) = 1;
      uint64_t v5 = sub_1000A6958();
      sub_1000EA52C(v5, @"HealthColdStorageVO2MaxDeletionComplete", (unsigned char *)(a1 + 148));
      uint64_t v6 = sub_1000A6958();
      (*(void (**)(uint64_t))(*(void *)v6 + 944))(v6);
    }
    *(unsigned char *)(a1 + 149) = sub_10044F8D0(v4);
    goto LABEL_18;
  }
LABEL_13:
  if (qword_102419300 != -1) {
    dispatch_once(&qword_102419300, &stru_10230B028);
  }
  char v7 = qword_102419308;
  if (os_log_type_enabled((os_log_t)qword_102419308, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[Manager] #warning: Cannot run database clean up, db is inaccessible", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419300 != -1) {
      dispatch_once(&qword_102419300, &stru_10230B028);
    }
    long long v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CMHealthColdStorageManager::cleanUpDatabase()", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
LABEL_18:
  if (v3) {
    sub_1000DB0A0(v3);
  }
  return sub_1000E1098(v10);
}

void sub_101008FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if (v5) {
    sub_1000DB0A0(v5);
  }
  sub_1000E1098((id *)va);
  _Unwind_Resume(a1);
}

void sub_101008FD4(id a1)
{
  qword_102419308 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
}

uint64_t sub_101009004(uint64_t a1)
{
  sub_101009040(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_101009040(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_101009084((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_101009084(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_1010090E8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1010090E8(a1, *a2);
    sub_1010090E8(a1, a2[1]);
    sub_101009144((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_101009144(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_101009198(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10230B058;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1010091B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10230B058;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10100920C(uint64_t a1)
{
}

void sub_101009220(uint64_t a1, char **a2, unsigned __int8 *a3, uint64_t *a4, unsigned __int8 *a5, float *a6, uint64_t a7, uint64_t *a8)
{
  std::string::size_type v15 = operator new(0x188uLL);
  sub_1010092C4(v15, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1010092B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1010092C4(void *a1, char **a2, unsigned __int8 *a3, uint64_t *a4, unsigned __int8 *a5, float *a6, uint64_t a7, uint64_t *a8)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_10230B0A8;
  sub_1010093EC((uint64_t)&v8, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7, a8);
}

void sub_10100933C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_101009350(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10230B0A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101009370(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10230B0A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1010093C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void sub_1010093EC(uint64_t a1, uint64_t a2, char **a3, unsigned __int8 *a4, uint64_t *a5, unsigned __int8 *a6, float *a7, uint64_t a8, uint64_t *a9)
{
  gid_t v11 = *a3;
  int v12 = *a4;
  uint64_t v13 = *a5;
  int v14 = *a6;
  float v15 = *a7;
  uint64_t v16 = *a9;
  sub_100134750(&v18, "startTime");
  sub_100134750(&__p, "id");
  sub_10044893C(a2, v11, v12 != 0, v13, v14 != 0, a8, v15, v16, &v18, &__p);
}

void sub_1010094CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_101009500(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  char v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    int v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (unint64_t i = *v14; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  sub_10100979C(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100100330(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  unsigned __int8 v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *unsigned __int8 v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  unint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  sub_101009848((uint64_t)v26, 0);
  return i;
}

void sub_101009784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_101009848((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double sub_10100979C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  char v8 = (char *)operator new(0x58uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)char v8 = 0;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = v8 + 16;
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    sub_1000DC48C(v9, *(void **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)unint64_t v9 = v11;
  }
  double result = 0.0;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_101009830(_Unwind_Exception *a1)
{
  sub_101009848(v1, 0);
  _Unwind_Resume(a1);
}

void sub_101009848(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_101009084((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

_OWORD *sub_1010098A0(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_1001070AC((uint64_t)a1, &v14, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    char v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x48uLL);
    v12[1] = a1 + 1;
    unint64_t v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    _DWORD v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    void *v9 = 0;
    *((void *)v7 + 7) = 0;
    *((void *)v7 + 8) = 0;
    char v13 = 1;
    sub_1000EDF90(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    sub_101009964((uint64_t)v12, 0);
  }
  return v7;
}

void sub_101009964(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_101009144((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_1010099BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  uint64_t v6 = (uint64_t *)(a1 + 48);
  sub_10158E260(a1 + 48, 300);
  *(_WORD *)(a1 + 128) = 0;
  sub_100B3F944(a1 + 136);
  *(void *)a1 = a2;
  uint64_t v7 = [[CLProactiveInertialOdometryClientDelegate alloc] initWithLocationController:a3];
  *(void *)(a1 + 8) = v7;
  [(CLProactiveInertialOdometryClientDelegate *)v7 setValid:1];
  id v8 = [[[*(id *)a1 vendor] proxyForService:@"CLBackgroundInertialOdometryService"];
  *(void *)(a1 + 16) = v8;
  [v8 registerDelegate:*(void *)(a1 + 8) inSilo:[*(id *)a1 silo]];
  [*(id *)(a1 + 16) setDelegateEntityName:"CLBackgroundInertialOdometryService"];
  sub_100103240();
  if (sub_10016CCBC())
  {
    sub_1000C7F88(buf);
    LOBYTE(v25[0]) = 0;
    sub_1000D2988(*(uint64_t *)buf, "CLProactiveInertialOdometryForwardSamplesToRoutine", (BOOL *)v25);
    if (v27) {
      sub_1000DB0A0(v27);
    }
    operator new();
  }
  sub_100103240();
  if (sub_10010145C())
  {
    sub_1000C7F88(buf);
    uint64_t v9 = *(void *)buf;
    _os_feature_enabled_impl();
    LOBYTE(v25[0]) = 0;
    sub_1000D2988(v9, "CLProactiveInertialOdometryForwardSamplesToRoutine", (BOOL *)v25);
    if (v27) {
      sub_1000DB0A0(v27);
    }
    operator new();
  }
  uint64_t v10 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  double v11 = sub_10016BA54(v10, buf);
  sub_10016C480(a1, v11);
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  uint8x8_t v12 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#pbio not enabling forward of samples to routined.", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    LOWORD(v25[0]) = 0;
    size_t v22 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLProactiveInertialOdometryManager::CLProactiveInertialOdometryManager(id<CLIntersiloUniverse>, CLLocationController &)", "%s\n", v22);
    if (v22 != (char *)buf) {
      free(v22);
    }
  }
  sub_1000C7F88(buf);
  LOBYTE(v25[0]) = 0;
  char v13 = sub_1000D2988(*(uint64_t *)buf, "CLProactiveInertialOdometryEnableDebugLogs", (BOOL *)v25);
  if (LOBYTE(v25[0])) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  *(unsigned char *)(a1 + 129) = v14;
  if (v27) {
    sub_1000DB0A0(v27);
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  float v15 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    int v16 = *(unsigned __int8 *)(a1 + 129);
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#pbio CLProactiveInertialOdometryManager::CLProactiveInertialOdometryManager(),enableDebugLogs,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    int v20 = *(unsigned __int8 *)(a1 + 129);
    v25[0] = 67109120;
    v25[1] = v20;
    unint64_t v21 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLProactiveInertialOdometryManager::CLProactiveInertialOdometryManager(id<CLIntersiloUniverse>, CLLocationController &)", "%s\n", v21);
    if (v21 != (char *)buf) {
      free(v21);
    }
  }
  float v17 = operator new(0x20uLL);
  void *v17 = off_10230B118;
  v17[1] = sub_10100A350;
  uint64_t v17[2] = 0;
  v17[3] = a1;
  v24[3] = v17;
  sub_10158E264(v6, (uint64_t)v24, 1, 4);
  sub_10100BFD0(v24);
  float v18 = operator new(0x20uLL);
  *float v18 = off_10230B118;
  v18[1] = sub_10100A54C;
  _OWORD v18[2] = 0;
  std::bad_cast v18[3] = a1;
  v23[3] = v18;
  sub_10158E264(v6, (uint64_t)v23, 60, 180);
  sub_10100BFD0(v23);
  return a1;
}

void sub_10100A16C(_Unwind_Exception *a1)
{
  sub_10100A760(v2);
  uint64_t v4 = *(void *)(v1 + 40);
  *(void *)(v1 + 4sub_100FB8FC8(&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  _Unwind_Resume(a1);
}

void sub_10100A274(id *a1, uint64_t *a2)
{
  id v4 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 3)];
  uint64_t v6 = *a2;
  for (uint64_t i = a2[1]; v6 != i; v6 += 72)
  {
    id v7 = objc_alloc((Class)CLBackgroundInertialOdometrySample);
    v11[0] = *(_OWORD *)v6;
    long long v9 = *(_OWORD *)(v6 + 32);
    long long v8 = *(_OWORD *)(v6 + 48);
    long long v10 = *(_OWORD *)(v6 + 16);
    uint64_t v12 = *(void *)(v6 + 64);
    uint64_t v11[2] = v9;
    void v11[3] = v8;
    v11[1] = v10;
    [v4 addObject:[v7 initWithCLPIOSample:v11]];
  }
  sub_10100B618(a1, v4);
}

void sub_10100A350(uint64_t a1, uint64_t *a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  id v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    unint64_t v5 = 0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)uint64_t buf = 134349056;
    unint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "#pbio forwarding %{public}zu samples to fuser", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::forwardBackgroundInertialOdometrySamplesToFuser(const std::vector<CLPIOSample> &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  sub_100681164(*(void *)(a1 + 24), a2);
}

void sub_10100A54C(uint64_t a1, uint64_t *a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  id v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    unint64_t v5 = 0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)uint64_t buf = 134349056;
    unint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "#pbio forwarding %{public}zu samples to telemetry calculator", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    unint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::forwardBackgroundInertialOdometrySamplesToTelemetryCalculator(const std::vector<CLPIOSample> &)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  uint64_t v6 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  double v7 = sub_10016BA54(v6, buf);
  sub_100B3F948(a1 + 136, a2, v7);
}

uint64_t sub_10100A760(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  id v4 = (void **)a1;
  sub_10100BE4C(&v4);
  return a1;
}

uint64_t sub_10100A7AC(uint64_t a1)
{
  [*(id *)(a1 + 16) stopBackgroundInertialOdometryUpdatesForClient:*(void *)(a1 + 8)];
  [*(id *)(a1 + 8) setValid:0];

  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;

  *(void *)(a1 + 32) = 0;
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  uint64_t v2 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#pbio CLProactiveInertialOdometryManager::~CLProactiveInertialOdometryManager()", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLProactiveInertialOdometryManager::~CLProactiveInertialOdometryManager()", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 96) = v3;
    operator delete(v3);
  }
  *(void *)uint64_t buf = a1 + 48;
  sub_10100BE4C((void ***)buf);
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  return a1;
}

void sub_10100A9D0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_10100A9E0(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  *((_DWORD *)a4 + 14) = 0;
  *(_OWORD *)(a4 + 5) = 0u;
  *(_OWORD *)(a4 + 3) = 0u;
  *(_OWORD *)(a4 + 1) = 0u;
  *((_WORD *)a4 + 3sub_100FB8FC8(&a9, 0) = 257;
  *(_DWORD *)((char *)a4 + 62) = 0;
  *a4 = *a2;
  [a3 timestamp];
  a4[1] = v7;
  *((_DWORD *)a4 + 4) = 1065353216;
  if ([a3 deltaPositionX] && objc_msgSend(a3, "deltaPositionY") && objc_msgSend(a3, "deltaPositionZ"))
  {
    *((unsigned char *)a4 + 63) = 1;
    [objc_msgSend(a3, "deltaPositionX") floatValue];
    *((_DWORD *)a4 + 5) = v8;
    [objc_msgSend(a3, "deltaPositionY") floatValue];
    *((_DWORD *)a4 + 6) = v9;
    [objc_msgSend(a3, "deltaPositionZ") floatValue];
    *((_DWORD *)a4 + 7) = v10;
  }
  if ([a3 deltaVelocityX] && objc_msgSend(a3, "deltaVelocityY") && objc_msgSend(a3, "deltaVelocityZ"))
  {
    *((unsigned char *)a4 + 64) = 1;
    [objc_msgSend(a3, "deltaVelocityX") floatValue];
    *((_DWORD *)a4 + 8) = v11;
    [objc_msgSend(a3, "deltaVelocityY") floatValue];
    *((_DWORD *)a4 + 9) = v12;
    [objc_msgSend(a3, "deltaVelocityZ") floatValue];
    *((_DWORD *)a4 + 1sub_100FB8FC8(&a9, 0) = v13;
  }
  if ([a3 quaternionX]
    && [a3 quaternionY]
    && [a3 quaternionZ]
    && [a3 quaternionW])
  {
    *((unsigned char *)a4 + 65) = 1;
    [objc_msgSend(a3, "quaternionX") floatValue];
    *((_DWORD *)a4 + 11) = v14;
    [objc_msgSend(a3, "quaternionY") floatValue];
    *((_DWORD *)a4 + 12) = v15;
    [objc_msgSend(a3, "quaternionZ") floatValue];
    *((_DWORD *)a4 + 13) = v16;
    [objc_msgSend(a3, "quaternionW") floatValue];
    *((_DWORD *)a4 + 14) = v17;
    *((unsigned char *)a4 + 6sub_100FB8FC8(&a9, 0) = *(unsigned char *)(a1 + 128) ^ 1;
    *(unsigned char *)(a1 + 128) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 128) = 0;
  }
  if ([a3 referenceFrame] == (id)8) {
    char v18 = 8;
  }
  else {
    char v18 = 1;
  }
  *((unsigned char *)a4 + 61) = v18;
  *((unsigned char *)a4 + 62) = 0;
  id v19 = [a3 staticFlag];
  if ((unint64_t)v19 <= 2) {
    *((unsigned char *)a4 + 62) = (_BYTE)v19;
  }
  if (*(unsigned char *)(a1 + 129))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    int v20 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = *a4;
      uint64_t v21 = a4[1];
      double v23 = *((float *)a4 + 4);
      double v24 = *((float *)a4 + 6);
      double v45 = *((float *)a4 + 7);
      double v46 = *((float *)a4 + 5);
      double v25 = *((float *)a4 + 8);
      double v26 = *((float *)a4 + 10);
      double v43 = *((float *)a4 + 11);
      double v44 = *((float *)a4 + 9);
      double v27 = *((float *)a4 + 12);
      double v42 = *((float *)a4 + 13);
      double v28 = *((float *)a4 + 14);
      int v29 = *((unsigned __int8 *)a4 + 60);
      int v30 = *((unsigned __int8 *)a4 + 61);
      int v31 = *((unsigned __int8 *)a4 + 62);
      int v32 = *((unsigned __int8 *)a4 + 63);
      int v33 = *((unsigned __int8 *)a4 + 64);
      int v47 = *((unsigned __int8 *)a4 + 65);
      uint64_t v34 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 0;
      double v35 = sub_10016BA54(v34, buf);
      uint64_t v36 = sub_10016BA10();
      *(_DWORD *)uint64_t buf = 0;
      double v37 = sub_10016BA54(v36, buf) - *(double *)a4;
      uint64_t v38 = sub_10016BA10();
      double v39 = sub_10018202C(v38);
      *(_DWORD *)uint64_t buf = 134354433;
      uint64_t v49 = v22;
      __int16 v50 = 2050;
      uint64_t v51 = v21;
      __int16 v52 = 2050;
      double v53 = v23;
      __int16 v54 = 2049;
      double v55 = v46;
      __int16 v56 = 2049;
      double v57 = v24;
      __int16 v58 = 2049;
      double v59 = v45;
      __int16 v60 = 2049;
      double v61 = v25;
      __int16 v62 = 2049;
      double v63 = v44;
      __int16 v64 = 2049;
      double v65 = v26;
      __int16 v66 = 2049;
      double v67 = v43;
      __int16 v68 = 2049;
      double v69 = v27;
      __int16 v70 = 2049;
      double v71 = v42;
      __int16 v72 = 2049;
      double v73 = v28;
      __int16 v74 = 1026;
      int v75 = v29;
      __int16 v76 = 1026;
      int v77 = v30;
      __int16 v78 = 1026;
      int v79 = v31;
      __int16 v80 = 1025;
      int v81 = v32;
      __int16 v82 = 1024;
      int v83 = v33;
      __int16 v84 = 1025;
      int v85 = v47;
      __int16 v86 = 2050;
      double v87 = v35;
      __int16 v88 = 2050;
      double v89 = v37;
      __int16 v90 = 2050;
      double v91 = v39;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "#pbio CLPIOSample, userCfAbsoluteTimestamp_s, %{public}.3f, machContinuousTimestamp_s, %{public}.3f, sampleInterval_s, %{public}.3f, dPosX_m, %{private}.3f, dPosY_m, %{private}.3f, dPosZ_m, %{private}.3f, dVelX_mps, %{private}.3f, dVelY_mps, %{private}.3f, dVelZ_mps, %{private}.3f, qX, %{private}.3f, qY, %{private}.3f, qZ, %{private}.3f, qW, %{private}.3f, referenceFrameContinuity, %{public}d, referenceFrame, %{public}d, staticFlag, %{public}d, isDeltaPositionValid, %{private}d, isDeltaVelocityValid, %d, isAttitudeValid, %{private}d, now, %{public}.3f, diffNowMinusSample, %{public}.3f, propagation_us, %{public}.3f", buf, 0xC6u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230B0E8);
      }
      sub_1005BFA38();
      sub_1005BFA38();
      uint64_t v40 = sub_10016BA10();
      sub_10018202C(v40);
      long long v41 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLPIOSample CLProactiveInertialOdometryManager::createCLPIOSample(const CFAbsoluteTime &, const CMOdometry *)", "%s\n", v41);
      if (v41 != (char *)buf) {
        free(v41);
      }
    }
  }
}

void sub_10100B06C(uint64_t a1, void *a2)
{
  double v9 = 0.0;
  uint64_t v4 = (__n128 *)sub_10016BA10();
  sub_100168854(v4, v8);
  if (sub_100AFF4CC((uint64_t)v8, &v9))
  {
    [a2 timestamp];
    v10[0] = v5 + v9;
    sub_10100A9E0(a1, (uint64_t *)v10, a2, (uint64_t *)buf);
    sub_10100B274(a1, (uint64_t)buf);
  }
  else
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      int v12 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "#pbio cannot compute fMachContinuousToCFAbsoluteOffset_s, discarding sample %@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230B0E8);
      }
      LODWORD(v10[0]) = 138412290;
      *(void *)((char *)v10 + 4) = a2;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::onBackgroundInertialOdometryState(const CMOdometry *)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

void sub_10100B274(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10016BA10();
  *(_DWORD *)uint64_t buf = 1;
  double v5 = sub_10016BA54(v4, buf) - *(double *)(a2 + 8);
  if (*(unsigned char *)(a1 + 129))
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v6 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      double v11 = v5;
      __int16 v12 = 1026;
      BOOL v13 = v5 < 2.0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#pbio onCLPIOSample, sample age %{public}.3f s, isPromptSample, %{public}d", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230B0E8);
      }
      int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::onCLPIOSample(const CLPIOSample &)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (v5 < 0.0)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      double v11 = v5;
      __int16 v12 = 1026;
      BOOL v13 = v5 < 2.0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "#pbio onCLPIOSample, unexpected sample age %{public}.3f s, isPromptSample, %{public}d", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230B0E8);
      }
      double v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLProactiveInertialOdometryManager::onCLPIOSample(const CLPIOSample &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  sub_10158E76C((uint64_t *)(a1 + 48), a2, v5 < 2.0);
}

void sub_10100B618(id *a1, void *a2)
{
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  uint64_t v4 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t buf = 134349056;
    id v11 = [a2 count];
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "#pbio forwarding %{public}zu samples to routine", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    int v8 = 134349056;
    id v9 = [a2 count];
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::performExportToRoutine(NSMutableArray<CLBackgroundInertialOdometrySample *> *)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  double v5 = [*a1 silo].queue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10100B838;
  block[3] = &unk_1022A56E0;
  block[4] = a2;
  void block[5] = a1;
  dispatch_async(v5, block);
}

id sub_10100B838(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  uint64_t v3 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    id v4 = [*(id *)(a1 + 32) count];
    *(_DWORD *)uint64_t buf = 134283521;
    id v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "#pbio adding %{private}zu background inertial odometry samples to fRoutineManager", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    [*(id *)(a1 + 32) count];
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::performExportToRoutine(NSMutableArray<CLBackgroundInertialOdometrySample *> *)_block_invoke", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  return [*(id *)(v2 + 32) addBackgroundInertialOdometrySamples:handler:];
}

void sub_10100BA54(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    uint64_t v3 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      id v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#pbio error adding background inertial odometry samples to routine: %@", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    id v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "void CLProactiveInertialOdometryManager::performExportToRoutine(NSMutableArray<CLBackgroundInertialOdometrySample *> *)_block_invoke", "%s\n", v4);
    if (v4 == (char *)buf) {
      return;
    }
LABEL_20:
    free(v4);
    return;
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230B0E8);
  }
  uint64_t v6 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    id v7 = [*(id *)(a1 + 32) count];
    *(_DWORD *)uint64_t buf = 134349056;
    id v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "#pbio successfully added %{public}zu background inertial odometry samples to routined.", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230B0E8);
    }
    [*(id *)(a1 + 32) count];
    id v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLProactiveInertialOdometryManager::performExportToRoutine(NSMutableArray<CLBackgroundInertialOdometrySample *> *)_block_invoke", "%s\n", v4);
    if (v4 != (char *)buf) {
      goto LABEL_20;
    }
  }
}

void sub_10100BD54(uint64_t a1, char a2, double a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    sub_100EB9710(v6, a2, a3);
  }
  sub_10016C480(a1, a3);

  sub_100B3FA68(a1 + 136, a2, a3);
}

void sub_10100BDC0(uint64_t a1, char a2, double a3)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    sub_100EB98EC(v5, a2, a3);
  }

  sub_10016C480(a1, a3);
}

void sub_10100BE14(uint64_t a1, _DWORD *a2, _DWORD *a3, double a4)
{
}

void sub_10100BE1C(id a1)
{
  qword_102419388 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void sub_10100BE4C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    id v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        id v4 = sub_10100BFD0(v4 - 7);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

__n128 sub_10100BED0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_10230B118;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100BF24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230B118;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100BF5C(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_10100BF84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100BFC4()
{
}

void *sub_10100BFD0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10100C054()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241ADF0, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_10241ADF0))
    {
      uint64_t v1 = 0x7FFFFFFF00000000;
      v0[2] = xmmword_101D9CBE8;
      v0[3] = unk_101D9CBF8;
      v0[4] = xmmword_101D9CC08;
      v0[0] = xmmword_101D9CBC8;
      v0[1] = unk_101D9CBD8;
      sub_1003BFBA4((uint64_t)&unk_10241ADD8, (int *)v0, 11);
      __cxa_atexit((void (*)(void *))sub_1003BE998, &unk_10241ADD8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_10241ADF0);
    }
  }
}

void sub_10100C134(_Unwind_Exception *a1)
{
}

void sub_10100CABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  sub_100488394((uint64_t)&a68);
  if (a61 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10100CB80()
{
}

void sub_10100CC50()
{
}

void sub_10100CF94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,char a58)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10100D420(id a1)
{
  qword_102419538 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_10100D450(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10100D8CC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        LODWORD(v6) = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v6) = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((unsigned __int16)(v6 >> 3))
    {
      case 1u:
        String = (void *)PBReaderReadString();

        *(void *)(a1 + 24) = String;
        goto LABEL_35;
      case 2u:
        *(unsigned char *)(a1 + 40) |= 1u;
        unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v15 <= 0xFFFFFFFFFFFFFFF7 && v15 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v16 = 0;
        }
        uint64_t v19 = 8;
        goto LABEL_34;
      case 3u:
        *(unsigned char *)(a1 + 40) |= 2u;
        unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v17 <= 0xFFFFFFFFFFFFFFF7 && v17 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v16 = 0;
        }
        uint64_t v19 = 16;
LABEL_34:
        *(void *)(a1 + v19) = v16;
        goto LABEL_35;
      case 4u:
        char v18 = objc_alloc_init(TRANSITPbMacModePair);
        [(id)a1 addMacModes:v18];

        if PBReaderPlaceMark() && (sub_101380458((uint64_t)v18, a2))
        {
          PBReaderRecallMark();
LABEL_35:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }
        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_35;
    }
  }
}

void sub_10100E3B0(uint64_t a1, void *a2, double a3)
{
  if (sub_100F61EE4())
  {
    if (*(void *)(a1 + 240)) {
      sub_10100E7A0(a1);
    }
    if (qword_1024192E0 != -1) {
      dispatch_once(&qword_1024192E0, &stru_10230B1E8);
    }
    uint64_t v6 = qword_1024192E8;
    if (os_log_type_enabled((os_log_t)qword_1024192E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 138543618;
      id v11 = [a2 identifier];
      __int16 v12 = 2050;
      double v13 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[CLInertialOdometryNotifierClient] %{public}@ requesting updates with interval: %{public}f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024192E0 != -1) {
        dispatch_once(&qword_1024192E0, &stru_10230B1E8);
      }
      [a2 identifier];
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLInertialOdometryNotifierClient::startOdometryUpdates(CLSilo *, CFTimeInterval)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    operator new();
  }
  if (qword_1024192E0 != -1) {
    dispatch_once(&qword_1024192E0, &stru_10230B1E8);
  }
  uint64_t v7 = qword_1024192E8;
  if (os_log_type_enabled((os_log_t)qword_1024192E8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't start updates", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024192E0 != -1) {
      dispatch_once(&qword_1024192E0, &stru_10230B1E8);
    }
    char v9 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "void CLInertialOdometryNotifierClient::startOdometryUpdates(CLSilo *, CFTimeInterval)", "%s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
}

void sub_10100E774()
{
}

void sub_10100E7A0(uint64_t a1)
{
  if (sub_100F61EE4())
  {
    *(unsigned char *)(a1 + 8) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    if (*(void *)(a1 + 240))
    {
      uint64_t v2 = sub_100F61EE4();
      sub_1009D26C4(v2, 0, *(void *)(a1 + 240));
      uint64_t v3 = *(void *)(a1 + 240);
      *(void *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;
      if (v3)
      {
        char v4 = *(void (**)(void))(*(void *)v3 + 8);
        v4();
      }
    }
  }
  else
  {
    if (qword_1024192E0 != -1) {
      dispatch_once(&qword_1024192E0, &stru_10230B1E8);
    }
    unsigned int v5 = qword_1024192E8;
    if (os_log_type_enabled((os_log_t)qword_1024192E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't stop updates", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024192E0 != -1) {
        dispatch_once(&qword_1024192E0, &stru_10230B1E8);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLInertialOdometryNotifierClient::stopOdometryUpdates()", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

void sub_10100E9D8(id a1)
{
  qword_1024192E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "InertialOdometry");
}

void *sub_10100EA08(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a1 = off_10234BF80;
  id v9 = a5;
  *a1 = off_10230B218;
  a1[1] = v9;
  a1[2] = a3;
  a1[3] = a4;
  id v10 = a2;
  a1[5] = 0;
  a1[4] = v10;
  a1[6] = 0;
  v14[0] = 0;
  v14[1] = v14;
  int v14[2] = 0x2020000000;
  char v15 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472;
  aBlock[2] = sub_10100EB90;
  aBlock[3] = &unk_1022B6BE8;
  aBlock[4] = v14;
  a1[5] = _Block_copy(aBlock);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  void v12[2] = sub_100177288;
  v12[3] = &unk_1022B6C10;
  v12[4] = v14;
  a1[6] = _Block_copy(v12);
  _Block_object_dispose(v14, 8);
  return a1;
}

void sub_10100EB68(_Unwind_Exception *a1)
{
  sub_1019D78CC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10100EB90(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

void sub_10100EBA8(uint64_t a1)
{
  sub_10100EBE0(a1);

  operator delete();
}

uint64_t sub_10100EBE0(uint64_t a1)
{
  *(void *)a1 = off_10230B218;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));

  return sub_1019D78CC(a1);
}

void sub_10100EC5C(id a1)
{
  qword_102418FD8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_10100EC8C@<X0>(void *a1@<X8>)
{
  sub_100103240();
  uint64_t result = sub_10010145C();
  if (result)
  {
    sub_1000C7F88(&v3);
    uint64_t v5 = 0;
    sub_1000A699C(v3, "halfMarathonCompletionTime", &v5);
    if (v4) {
      sub_1000DB0A0(v4);
    }
    sub_1000C7F88(&v3);
    uint64_t v5 = 0;
    sub_1000A699C(v3, "fullMarathonCompletionTime", &v5);
    if (v4) {
      sub_1000DB0A0(v4);
    }
    sub_1000C7F88(&v3);
    uint64_t v5 = 0;
    sub_1000A699C(v3, "ravenAndL5OnToOffHysteresis", &v5);
    if (v4) {
      sub_1000DB0A0(v4);
    }
    sub_1000C7F88(&v3);
    LODWORD(v5) = 0;
    sub_10006EF84(v3, "hkWorkoutStitchThreshold", &v5);
    if (v4) {
      sub_1000DB0A0(v4);
    }
    operator new();
  }
  *a1 = 0;
  return result;
}

void sub_10100EE28()
{
}

void sub_10100EE6C(uint64_t a1, void *a2, uint64_t a3, double a4, double a5, double a6)
{
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 3) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(double *)(a1 + 48) = a4;
  *(double *)(a1 + 56) = a5;
  *(double *)(a1 + 64) = a6;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = a3;
  *(void *)(a1 + 96) = a2;
  *(void *)(a1 + 104) = 0;
  *(double *)(a1 + 88) = (double)(*(void *)(a1 + 72) / 2);
  operator new();
}

void sub_10100F034()
{
}

uint64_t sub_10100F094(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    unint64_t v5 = 0xBFF0000000000000;
    sub_10053D348(v2, (double *)&v5, 0);
  }

  uint64_t v3 = *(void *)(a1 + 104);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

BOOL sub_10100F11C(uint64_t a1, double a2)
{
  if (!*(unsigned char *)a1 || !*(unsigned char *)(a1 + 1)) {
    return 1;
  }
  int v4 = *(unsigned __int8 *)(a1 + 6);
  double v5 = a2 - *(double *)(a1 + 32);
  BOOL v6 = *(double *)(a1 + 56) >= v5 + *(double *)(a1 + 80);
  unsigned int v7 = *(_DWORD *)(a1 + 40) - 3;
  BOOL v8 = v7 < 2;
  if (*(double *)(a1 + 56) >= v5 + *(double *)(a1 + 80) || v7 <= 1)
  {
    *(unsigned char *)(a1 + 6) = 1;
    *(double *)(a1 + 16) = a2;
  }
  else if (*(unsigned char *)(a1 + 6))
  {
    double v9 = *(double *)(a1 + 64);
    if (a2 - *(double *)(a1 + 8) > v9 && v5 > v9) {
      *(unsigned char *)(a1 + 6) = 0;
    }
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  __int16 v12 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
  {
    int v13 = *(unsigned __int8 *)(a1 + 6);
    double v14 = *(double *)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 80);
    v16[0] = 68290306;
    v16[1] = 0;
    __int16 v17 = 2082;
    char v18 = "";
    __int16 v19 = 1026;
    int v20 = v6 || v8;
    __int16 v21 = 1026;
    int v22 = v13;
    __int16 v23 = 2050;
    double v24 = a2 - v14;
    __int16 v25 = 2050;
    uint64_t v26 = v15;
    __int16 v27 = 2050;
    double v28 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,isRavenAllowed\", \"allowRaven\":%{public}hhd, \"fIsRavenAllowed\":%{public}hhd, \"currentWorkoutDuration\":\"%{public}f\", \"fStitchedPreviousWorkoutDuration\":\"%{public}f\", \"fHkWorkoutStartMCT\":\"%{public}f\"}", (uint8_t *)v16, 0x3Cu);
  }
  if (v4 != *(unsigned __int8 *)(a1 + 6))
  {
    sub_10100F300(a1);
    int v4 = *(unsigned __int8 *)(a1 + 6);
  }
  return v4 != 0;
}

uint64_t sub_10100F300(uint64_t result)
{
  if (*(void *)(result + 104))
  {
    uint64_t v1 = result;
    sub_10101054C(result);
    uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 104) + 944);
    return v2();
  }
  return result;
}

BOOL sub_10100F374(uint64_t a1, double a2)
{
  if (!*(unsigned char *)a1 || !*(unsigned char *)(a1 + 1)) {
    return 1;
  }
  int v4 = *(unsigned __int8 *)(a1 + 5);
  double v5 = a2 - *(double *)(a1 + 32);
  BOOL v6 = *(double *)(a1 + 56) < v5 + *(double *)(a1 + 80);
  int v7 = *(_DWORD *)(a1 + 40);
  BOOL v8 = (v7 - 3) < 2 || *(double *)(a1 + 56) >= v5 + *(double *)(a1 + 80);
  if (*(double *)(a1 + 56) >= v5 + *(double *)(a1 + 80) || (v7 - 5) >= 0xFFFFFFFE)
  {
    *(unsigned char *)(a1 + 5) = (v7 - 3) < 2 || *(double *)(a1 + 56) >= v5 + *(double *)(a1 + 80);
    *(double *)(a1 + 8) = a2;
  }
  else if (*(unsigned char *)(a1 + 5))
  {
    double v9 = *(double *)(a1 + 64);
    if (a2 - *(double *)(a1 + 8) > v9 && v5 > v9) {
      *(unsigned char *)(a1 + 5) = 0;
    }
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  __int16 v12 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEBUG))
  {
    int v13 = *(unsigned __int8 *)(a1 + 5);
    int v14 = *(_DWORD *)(a1 + 40);
    double v15 = *(double *)(a1 + 32);
    uint64_t v16 = *(void *)(a1 + 80);
    v17[0] = 68290818;
    __int16 v18 = 2082;
    v17[1] = 0;
    __int16 v19 = "";
    __int16 v20 = 1026;
    int v21 = v8;
    __int16 v22 = 1026;
    int v23 = v13;
    __int16 v24 = 1026;
    int v25 = v6;
    __int16 v26 = 1026;
    int v27 = v14;
    __int16 v28 = 2050;
    double v29 = a2 - v15;
    __int16 v30 = 2050;
    uint64_t v31 = v16;
    __int16 v32 = 2050;
    double v33 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,isL5Allowed\", \"allowL5\":%{public}hhd, \"fIsL5Allowed\":%{public}hhd, \"pastFullMarathon\":%{public}hhd, \"fCurrentSigEnv\":%{public}d, \"currentWorkoutDuration\":\"%{public}f\", \"fStitchedPreviousWorkoutDuration\":\"%{public}f\", \"fHkWorkoutStartMCT\":\"%{public}f\"}", (uint8_t *)v17, 0x48u);
  }
  if (v4 != *(unsigned __int8 *)(a1 + 5))
  {
    sub_10100F300(a1);
    int v4 = *(unsigned __int8 *)(a1 + 5);
  }
  return v4 != 0;
}

void sub_10100F578(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = a2;
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  uint64_t v3 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 40);
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    int v7 = "";
    __int16 v8 = 1026;
    int v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,feedSignalEnvironment\", \"fCurrentSigEnv\":%{public}d}", (uint8_t *)v5, 0x18u);
  }
}

void sub_10100F668(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 1);
  switch(*(void *)(a2 + 16))
  {
    case 0:
    case 2:
    case 3:
    case 4:
    case 0x11:
      if (*(unsigned char *)(a1 + 1)) {
        goto LABEL_27;
      }
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
      double v5 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "GnssWorkoutPwrSaver,implicit start", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLGnssWorkoutPowerSaver::feedHkWorkout(const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
      goto LABEL_8;
    case 0xDLL:
LABEL_8:
      *(unsigned char *)(a1 + 1) = 1;
      goto LABEL_22;
    case 0xFLL:
      sub_10100FAE8(a1);
      goto LABEL_22;
    case 0x10:
      *(unsigned char *)(a1 + 2) = 1;
      int v9 = *(_DWORD *)(a1 + 24);
      if (v9) {
        *(_DWORD *)(a1 + 24) = v9 - 1;
      }
      goto LABEL_22;
    case 0x12:
      sub_10100FB44(a1, *(void *)(a2 + 112));
LABEL_22:
      if (v4) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = *(unsigned char *)(a1 + 1) == 0;
      }
      if (!v10) {
        sub_10100FC7C(a1, *(void *)(a2 + 112));
      }
LABEL_27:
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
      id v11 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a2 + 16);
        uint64_t v13 = *(void *)(a2 + 112);
        int v14 = *(unsigned __int8 *)(a1 + 1);
        int v15 = *(_DWORD *)(a1 + 24);
        *(_DWORD *)uint64_t buf = 68290306;
        int v18 = 0;
        __int16 v19 = 2082;
        __int16 v20 = "";
        __int16 v21 = 1026;
        int v22 = v12;
        __int16 v23 = 1026;
        int v24 = v13;
        __int16 v25 = 1026;
        int v26 = v4;
        __int16 v27 = 1026;
        int v28 = v14;
        __int16 v29 = 1026;
        int v30 = v15;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,feedHkWorkout\", \"eventType\":%{public}d, \"workoutType\":%{public}d, \"previousHkWorkoutOn\":%{public}hhd, \"currentHkWorkoutOn\":%{public}hhd, \"fGnssResetsWhileInWorkout\":%{public}u}", buf, 0x30u);
      }
      break;
    default:
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
      __int16 v6 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a2 + 16);
        *(_DWORD *)uint64_t buf = 67240192;
        int v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "GnssWorkoutPwrSaver,feedHkWorkout,Unhandled,eventType,%{public}d", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        __int16 v8 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLGnssWorkoutPowerSaver::feedHkWorkout(const CLMotionStateMediator_Type::NotificationData &)", "%s\n", v8);
        if (v8 != (char *)buf) {
          free(v8);
        }
      }
      break;
  }
}

void sub_10100FAE8(uint64_t a1)
{
  sub_10100F300(a1);
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    unint64_t v3 = 0xBFF0000000000000;
    sub_10053D348(v2, (double *)&v3, 0);
  }
  *(_WORD *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 4) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
}

void sub_10100FB44(uint64_t a1, unint64_t a2)
{
  if (a2 <= 0x21)
  {
    int v2 = a2;
    if (((1 << a2) & 0x200080010) != 0)
    {
      int v4 = *(unsigned __int8 *)(a1 + 4);
      *(unsigned char *)(a1 + 4) = 1;
      if (!v4)
      {
        sub_10100F300(a1);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        double v5 = qword_1024193D8;
        if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(unsigned __int8 *)(a1 + 4);
          v7[0] = 68289538;
          v7[1] = 0;
          __int16 v8 = 2082;
          int v9 = "";
          __int16 v10 = 1026;
          int v11 = v6;
          __int16 v12 = 1026;
          int v13 = v2;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,updateHkWorkoutType\", \"fIsPotentiallyMultiSportWorkout\":%{public}hhd, \"workoutType\":%{public}d}", (uint8_t *)v7, 0x1Eu);
        }
      }
    }
  }
}

void sub_10100FC7C(uint64_t a1, unint64_t a2)
{
  *(double *)(a1 + 32) = sub_10016C458();
  sub_101010A60(a1);
  sub_10100FB44(a1, a2);
  *(unsigned char *)(a1 + 2) = 0;
}

void sub_10100FCC0(unsigned char *a1, char a2)
{
  *a1 = a2;
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  unint64_t v3 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *a1;
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    __int16 v8 = 1026;
    int v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,feedBatterySaverMode\", \"fIsBatterySaverMode\":%{public}hhd}", (uint8_t *)v5, 0x18u);
  }
}

void sub_10100FDB0(uint64_t a1)
{
}

void sub_10100FDB8(uint64_t a1, char a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 3);
  *(unsigned char *)(a1 + 3) = a2;
  if (v3)
  {
    if ((a2 & 1) == 0)
    {
      if (*(unsigned char *)(a1 + 1))
      {
        if (!*(unsigned char *)(a1 + 2))
        {
          unsigned int v4 = *(_DWORD *)(a1 + 24) + 1;
          *(_DWORD *)(a1 + 24) = v4;
          if (v4 >= 0xB) {
            sub_10100FEE8(a1);
          }
        }
      }
    }
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  double v5 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 24);
    v7[0] = 68289282;
    v7[1] = 0;
    __int16 v8 = 2082;
    int v9 = "";
    __int16 v10 = 1026;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,feedGnssStatus\", \"fGnssResetsWhileInWorkout\":%{public}u}", (uint8_t *)v7, 0x18u);
  }
}

void sub_10100FEE0(uint64_t a1)
{
}

void sub_10100FEE8(uint64_t a1)
{
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  int v2 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 24);
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    int v6 = "";
    __int16 v7 = 1026;
    int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,resetOnGetOutOfHoleDetection\", \"fGnssResetsWhileInWorkout\":%{public}u}", (uint8_t *)v4, 0x18u);
  }
  sub_10100FAE8(a1);
}

void sub_10100FFDC(uint64_t a1)
{
  time_t v19 = 0;
  time_t v20 = 0;
  if (time(&v20) == -1)
  {
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10230B278);
    }
    int v3 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v22 = 0;
      __int16 v23 = 2082;
      int v24 = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,std::time,-1\"}", buf, 0x12u);
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
    }
    unsigned int v4 = qword_1024193D8;
    if (os_signpost_enabled((os_log_t)qword_1024193D8))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v22 = 0;
      __int16 v23 = 2082;
      int v24 = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "GnssWorkoutPwrSaver,stitchWorkout,std::time,-1", "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,std::time,-1\"}", buf, 0x12u);
    }
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 104) + 936))(*(void *)(a1 + 104));
    if (sub_1004D0F14(*(void *)(a1 + 104), @"kGnssWorkoutChkpointUTC", &v19))
    {
      if (v20 > v19 && v20 - v19 > *(void *)(a1 + 72))
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        int v2 = qword_1024193D8;
        if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 68289538;
          int v22 = 0;
          __int16 v23 = 2082;
          int v24 = "";
          __int16 v25 = 2050;
          time_t v26 = v20;
          __int16 v27 = 2050;
          time_t v28 = v19;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,newWorkout,notstitched\", \"currentUtcEpochSeconds\":%{public}ld, \"kGnssWorkoutChkpointTime\":%{public}ld}", buf, 0x26u);
        }
        *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = 0;
        return;
      }
      unsigned int v18 = 0;
      if (sub_1004D08E4(*(void *)(a1 + 104), @"kGnssHkWorkoutStatus", &v18))
      {
        char v9 = v18;
        *(double *)(a1 + 8sub_100FB8FC8(&a9, 0) = (double)(v18 >> 8);
        *(unsigned char *)(a1 + 4) = v9 & 1;
        *(unsigned char *)(a1 + 5) = (v9 & 2) != 0;
        *(unsigned char *)(a1 + 6) = (v9 & 4) != 0;
      }
      else
      {
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        __int16 v10 = qword_1024193D8;
        if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 68289026;
          int v22 = 0;
          __int16 v23 = 2082;
          int v24 = "";
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,kGnssHkWorkoutDurationSec,notavailable\"}", buf, 0x12u);
          if (qword_1024193D0 != -1) {
            dispatch_once(&qword_1024193D0, &stru_10230B278);
          }
        }
        int v11 = qword_1024193D8;
        if (!os_signpost_enabled((os_log_t)qword_1024193D8)) {
          goto LABEL_32;
        }
        *(_DWORD *)uint64_t buf = 68289026;
        int v22 = 0;
        __int16 v23 = 2082;
        int v24 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "GnssWorkoutPwrSaver,stitchWorkout,kGnssHkWorkoutDurationSec,notavailable", "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,kGnssHkWorkoutDurationSec,notavailable\"}", buf, 0x12u);
      }
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
LABEL_32:
      uint64_t v12 = qword_1024193D8;
      if (!os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v13 = *(void *)(a1 + 80);
      int v14 = *(unsigned __int8 *)(a1 + 5);
      int v15 = *(unsigned __int8 *)(a1 + 6);
      int v16 = *(unsigned __int8 *)(a1 + 4);
      uint64_t v17 = *(void *)(a1 + 32);
      *(_DWORD *)uint64_t buf = 68291074;
      int v22 = 0;
      __int16 v23 = 2082;
      int v24 = "";
      __int16 v25 = 2050;
      time_t v26 = v20;
      __int16 v27 = 2050;
      time_t v28 = v19;
      __int16 v29 = 2050;
      uint64_t v30 = v13;
      __int16 v31 = 1026;
      unsigned int v32 = v18;
      __int16 v33 = 1026;
      int v34 = v14;
      __int16 v35 = 1026;
      int v36 = v15;
      __int16 v37 = 1026;
      int v38 = v16;
      __int16 v39 = 2050;
      uint64_t v40 = v17;
      int v6 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout\", \"currentUtcEpochSeconds\":%{public}ld, \"kGnssWo"
           "rkoutChkpointTime\":%{public}ld, \"fStitchedPreviousWorkoutDuration\":\"%{public}f\", \"workoutStatus\":%{pub"
           "lic}u, \"fIsL5Allowed\":%{public}hhd, \"fIsRavenAllowed\":%{public}hhd, \"fIsPotentiallyMultiSportWorkout\":%"
           "{public}hhd, \"fHkWorkoutStartMCT\":\"%{public}f\"}";
      __int16 v7 = v12;
      uint32_t v8 = 82;
      goto LABEL_34;
    }
    if (qword_1024193D0 != -1) {
      dispatch_once(&qword_1024193D0, &stru_10230B278);
    }
    uint64_t v5 = qword_1024193D8;
    if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v22 = 0;
      __int16 v23 = 2082;
      int v24 = "";
      int v6 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchWorkout,noKey,newWorkout\"}";
      __int16 v7 = v5;
      uint32_t v8 = 18;
LABEL_34:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

void sub_10101054C(uint64_t a1)
{
  double v2 = sub_10016C458();
  if (*(unsigned char *)(a1 + 1))
  {
    time_t v24 = 0;
    if (time(&v24) == -1)
    {
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
      unsigned int v18 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        int v26 = 0;
        __int16 v27 = 2082;
        time_t v28 = "";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint,std::time,-1\"}", buf, 0x12u);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
      }
      time_t v19 = qword_1024193D8;
      if (!os_signpost_enabled((os_log_t)qword_1024193D8)) {
        return;
      }
      *(_DWORD *)uint64_t buf = 68289026;
      int v26 = 0;
      __int16 v27 = 2082;
      time_t v28 = "";
      time_t v20 = "GnssWorkoutPwrSaver,stitchCheckpoint,std::time,-1";
      __int16 v21 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint,std::time,-1\"}";
    }
    else
    {
      if (sub_1004D3224(*(void *)(a1 + 104), @"kGnssWorkoutChkpointUTC", &v24))
      {
        unsigned int v3 = (v2 - *(double *)(a1 + 32) + *(double *)(a1 + 80));
        if (v3 >= 0xFFFFFF) {
          unsigned int v3 = 0xFFFFFF;
        }
        unsigned int v4 = v3 << 8;
        int v23 = v4;
        if (*(unsigned char *)(a1 + 4))
        {
          v4 |= 1u;
          int v23 = v4;
        }
        if (*(unsigned char *)(a1 + 5))
        {
          v4 |= 2u;
          int v23 = v4;
        }
        if (*(unsigned char *)(a1 + 6)) {
          int v23 = v4 | 4;
        }
        BOOL v5 = sub_1004D2C30(*(void *)(a1 + 104), @"kGnssHkWorkoutStatus", (unsigned int *)&v23);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
        uint64_t v6 = qword_1024193D8;
        if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = *(_DWORD *)(a1 + 40);
          uint64_t v8 = *(void *)(a1 + 80);
          uint64_t v9 = *(void *)(a1 + 32);
          int v10 = *(unsigned __int8 *)(a1 + 5);
          int v11 = *(unsigned __int8 *)(a1 + 6);
          int v12 = *(unsigned __int8 *)(a1 + 4);
          *(_DWORD *)uint64_t buf = 68291586;
          __int16 v27 = 2082;
          int v26 = 0;
          time_t v28 = "";
          __int16 v29 = 2050;
          time_t v30 = v24;
          __int16 v31 = 1026;
          int v32 = v7;
          __int16 v33 = 1026;
          unsigned int v34 = v23;
          __int16 v35 = 2050;
          uint64_t v36 = v8;
          __int16 v37 = 2050;
          double v38 = v2;
          __int16 v39 = 2050;
          uint64_t v40 = v9;
          __int16 v41 = 1026;
          BOOL v42 = v5;
          __int16 v43 = 1026;
          int v44 = v10;
          __int16 v45 = 1026;
          int v46 = v11;
          __int16 v47 = 1026;
          int v48 = v12;
          uint64_t v13 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint\", \"kGnssWorkoutChkpointTime\":%{public}ld,"
                " \"fCurrentSigEnv\":%{public}d, \"workoutStatus\":%{public}u, \"fStitchedPreviousWorkoutDuration\":\"%{p"
                "ublic}f\", \"currentMCT\":\"%{public}f\", \"fHkWorkoutStartMCT\":\"%{public}f\", \"wkStatusUpdate\":%{pu"
                "blic}hhd, \"fIsL5Allowed\":%{public}hhd, \"fIsRavenAllowed\":%{public}hhd, \"fIsPotentiallyMultiSportWor"
                "kout\":%{public}hhd}";
          int v14 = v6;
          uint32_t v15 = 94;
LABEL_20:
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
          return;
        }
        return;
      }
      if (qword_1024193D0 != -1) {
        dispatch_once(&qword_1024193D0, &stru_10230B278);
      }
      int v22 = qword_1024193D8;
      if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        int v26 = 0;
        __int16 v27 = 2082;
        time_t v28 = "";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint,kGnssWorkoutChkpointUTC update failed\"}", buf, 0x12u);
        if (qword_1024193D0 != -1) {
          dispatch_once(&qword_1024193D0, &stru_10230B278);
        }
      }
      time_t v19 = qword_1024193D8;
      if (!os_signpost_enabled((os_log_t)qword_1024193D8)) {
        return;
      }
      *(_DWORD *)uint64_t buf = 68289026;
      int v26 = 0;
      __int16 v27 = 2082;
      time_t v28 = "";
      time_t v20 = "GnssWorkoutPwrSaver,stitchCheckpoint,kGnssWorkoutChkpointUTC update failed";
      __int16 v21 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint,kGnssWorkoutChkpointUTC update failed\"}";
    }
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v20, v21, buf, 0x12u);
    return;
  }
  if (qword_1024193D0 != -1) {
    dispatch_once(&qword_1024193D0, &stru_10230B278);
  }
  uint64_t v16 = qword_1024193D8;
  if (os_log_type_enabled((os_log_t)qword_1024193D8, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(unsigned __int8 *)(a1 + 1);
    *(_DWORD *)uint64_t buf = 68289538;
    int v26 = 0;
    __int16 v27 = 2082;
    time_t v28 = "";
    __int16 v29 = 2050;
    time_t v30 = *(void *)&v2;
    __int16 v31 = 1026;
    int v32 = v17;
    uint64_t v13 = "{\"msg%{public}.0s\":\"GnssWorkoutPwrSaver,stitchCheckpoint,notNeeded\", \"currentMCT\":\"%{public}f\", \"fIsI"
          "nHkWorkout\":%{public}hhd}";
    int v14 = v16;
    uint32_t v15 = 34;
    goto LABEL_20;
  }
}

void *sub_101010A14(void *result)
{
  if (result[13])
  {
    uint64_t v1 = result;
    sub_10101054C((uint64_t)result);
    double v2 = (double *)v1[13];
    return sub_10053D700(v2);
  }
  return result;
}

void sub_101010A60(uint64_t a1)
{
  if (*(void *)(a1 + 104))
  {
    sub_10100FFDC(a1);
    uint64_t v2 = *(void *)(a1 + 104);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    void v3[2] = sub_101010AEC;
    v3[3] = &unk_1022A3020;
    void v3[4] = a1;
    sub_10053D348(v2, (double *)(a1 + 88), (uint64_t)v3);
  }
}

void *sub_101010AEC(uint64_t a1)
{
  return sub_101010A14(*(void **)(a1 + 32));
}

void sub_101010AF4(id a1)
{
  qword_1024193D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Gnss");
}

void sub_101010B24(uint64_t a1)
{
}

void sub_101010B90(_Unwind_Exception *a1)
{
  sub_101039104(v1);
  _Unwind_Resume(a1);
}

void sub_101010BAC(_DWORD *a1)
{
  sub_101039104(a1);

  operator delete();
}

void sub_101010BE8(float32x2_t *a1)
{
  bzero(&v9, 0x12uLL);
  __int32 v2 = a1[8].i32[0];
  unsigned int v3 = (char *)&a1[21] + 6;
  if (v2 != 2) {
    unsigned int v3 = (char *)&a1[14] + 2;
  }
  if (v2 == 1) {
    unsigned int v4 = (char *)&a1[17] + 2;
  }
  else {
    unsigned int v4 = v3;
  }
  uint64_t v9 = *(void *)v4;
  int v10 = *((_DWORD *)v4 + 2);
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230B308);
  }
  BOOL v5 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    __int32 v6 = a1[8].i32[0];
    *(_DWORD *)uint64_t buf = 67110656;
    int v26 = (__int16)v9;
    __int16 v27 = 1024;
    int v28 = SWORD1(v9);
    __int16 v29 = 1024;
    int v30 = SWORD2(v9);
    __int16 v31 = 1024;
    int v32 = SHIWORD(v9);
    __int16 v33 = 1024;
    int v34 = (__int16)v10;
    __int16 v35 = 1024;
    int v36 = SHIWORD(v10);
    __int16 v37 = 1024;
    __int32 v38 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d", buf, 0x2Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230B308);
    }
    __int32 v7 = a1[8].i32[0];
    int v11 = 67110656;
    int v12 = (__int16)v9;
    __int16 v13 = 1024;
    int v14 = SWORD1(v9);
    __int16 v15 = 1024;
    int v16 = SWORD2(v9);
    __int16 v17 = 1024;
    int v18 = SHIWORD(v9);
    __int16 v19 = 1024;
    int v20 = (__int16)v10;
    __int16 v21 = 1024;
    int v22 = SHIWORD(v10);
    __int16 v23 = 1024;
    __int32 v24 = v7;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV10::chooseOffsetData()", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  sub_101039F24(a1, (__int16 *)&v9);
}

void sub_101010E7C(id a1)
{
  qword_1024190A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

uint64_t sub_101010EAC(uint64_t result, uint64_t a2, int a3, int a4, int a5, int a6)
{
  *(void *)uint64_t result = off_10230B338;
  *(void *)(result + 8) = a2;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 2sub_100FB8FC8(&a9, 0) = a4;
  *(_DWORD *)(result + 24) = a5;
  *(_DWORD *)(result + 28) = a6;
  return result;
}

uint64_t sub_101010ED4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_101010EDC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

uint64_t sub_101010EE4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_101010EEC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_101010EF4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

id sub_1010111C8(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *(double *)(v3 + 96);
  if (v4 == 0.0)
  {
    *(double *)(v3 + 96) = Current - (*(double *)(a1 + 40) + 5.0);
    uint64_t v3 = *(void *)(a1 + 32);
    double v4 = *(double *)(v3 + 96);
  }
  double v5 = *(double *)(v3 + 104);
  if (Current - v4 >= v5) {
    double v4 = Current - v5;
  }
  *(double *)(v3 + 96) = v4;
  if ([*(id *)(a1 + 32) registeredXPCTaskElevationProfile])
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    __int32 v6 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(*(void *)(a1 + 32) + 96) + 5.0;
      *(_DWORD *)uint64_t buf = 134218240;
      double v13 = v7;
      __int16 v14 = 2048;
      double v15 = Current;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "delay registration of XPC task for elevation profile calculation with startTime,%f,endTime,%f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 == -1)
      {
LABEL_22:
        int v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile initWithUniverse:delegate:withBuffer:withSourceAggregator:]_block_invoke", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
        return [*(id *)(*(void *)(a1 + 32) + 88) setNextFireDelay:*(double *)(a1 + 40)];
      }
LABEL_24:
      dispatch_once(&qword_1024191E0, &stru_10230B438);
      goto LABEL_22;
    }
  }
  else
  {
    double v8 = *(double *)(*(void *)(a1 + 32) + 96) + 5.0;
    if (+[CLContextManagerElevationProfileBase isQueryValidWithStartTime:v8 andEndTime:Current])
    {
      [*(id *)(a1 + 32) pushElevationsFromTime:*(double *)(*(void *)(a1 + 32) + 96) + 5.0 toTime:Current];
      return [*(id *)(*(void *)(a1 + 32) + 88) setNextFireDelay:*(double *)(a1 + 40)];
    }
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    uint64_t v9 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134218240;
      double v13 = v8;
      __int16 v14 = 2048;
      double v15 = Current;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "skip elevation profile calculation due to false startTime,%f,endTime,%f", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 == -1) {
        goto LABEL_22;
      }
      goto LABEL_24;
    }
  }
  return [*(id *)(*(void *)(a1 + 32) + 88) setNextFireDelay:*(double *)(a1 + 40)];
}

uint64_t sub_101011B60(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    double v4 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)int v77 = 0;
      *(_WORD *)&v77[4] = 2082;
      *(void *)&v77[6] = "";
      *(_WORD *)&v77[14] = 2114;
      *(void *)&v77[16] = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"error fetching routine visits\", \"error\":%{public, location:escape_only}@}", buf, 0x1Cu);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230B438);
      }
    }
    double v5 = qword_1024191E8;
    if (os_signpost_enabled((os_log_t)qword_1024191E8))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)int v77 = 0;
      *(_WORD *)&v77[4] = 2082;
      *(void *)&v77[6] = "";
      *(_WORD *)&v77[14] = 2114;
      *(void *)&v77[16] = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "error fetching routine visits", "{\"msg%{public}.0s\":\"error fetching routine visits\", \"error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    __int32 v6 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
    return v6();
  }
  double v7 = a2;
  if ([a2 count])
  {
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    id v8 = [v7 countByEnumeratingWithState:&v57 objects:v75 count:16];
    if (!v8) {
      goto LABEL_45;
    }
    id v9 = v8;
    int v10 = &qword_102419000;
    int v11 = &qword_102419000;
    uint64_t v56 = *(void *)v58;
    double v53 = v7;
    while (1)
    {
      int v12 = 0;
      id v54 = v9;
      do
      {
        if (*(void *)v58 != v56) {
          objc_enumerationMutation(v7);
        }
        double v13 = *(void **)(*((void *)&v57 + 1) + 8 * (void)v12);
        __int16 v14 = objc_alloc_init(CLVisitTimePeriod);
        if (v10[60] != -1) {
          dispatch_once(&qword_1024191E0, &stru_10230B438);
        }
        double v15 = v11[61];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          id v16 = [v13 date];
          unsigned int v17 = [v13 type];
          id v18 = [v13 entry];
          id v19 = [v13 exit];
          [v13 confidence];
          uint64_t v21 = v20;
          unsigned int v22 = [v13 source];
          *(_DWORD *)uint64_t buf = 136317954;
          *(void *)int v77 = "date";
          *(_WORD *)&v77[8] = 2112;
          *(void *)&v77[10] = v16;
          *(_WORD *)&v77[18] = 2080;
          *(void *)&v77[20] = "type";
          __int16 v78 = 1024;
          *(_DWORD *)int v79 = v17;
          double v7 = v53;
          id v9 = v54;
          *(_WORD *)&v79[4] = 2080;
          *(void *)&v79[6] = "entryDate";
          *(_WORD *)&v79[14] = 2112;
          *(void *)&v79[16] = v18;
          int v10 = &qword_102419000;
          *(_WORD *)&v79[24] = 2080;
          *(void *)&v79[26] = "exitDate";
          *(_WORD *)&v79[34] = 2112;
          *(void *)&v79[36] = v19;
          int v11 = &qword_102419000;
          *(_WORD *)&v79[44] = 2080;
          *(void *)&v79[46] = "confidence";
          __int16 v80 = 2048;
          uint64_t v81 = v21;
          __int16 v82 = 2080;
          int v83 = "source";
          __int16 v84 = 1024;
          unsigned int v85 = v22;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "visit from Routine,%s,%@,%s,%d,%s,%@,%s,%@,%s,%f,%s,%d", buf, 0x72u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (v10[60] != -1) {
            dispatch_once(&qword_1024191E0, &stru_10230B438);
          }
          id v33 = [v13 date];
          unsigned int v34 = [v13 type];
          id v35 = [v13 entry];
          id v36 = [v13 exit];
          [v13 confidence];
          uint64_t v38 = v37;
          unsigned int v39 = [v13 source];
          int v61 = 136317954;
          __int16 v62 = "date";
          __int16 v63 = 2112;
          id v64 = v33;
          __int16 v65 = 2080;
          __int16 v66 = "type";
          __int16 v67 = 1024;
          *(_DWORD *)__int16 v68 = v34;
          *(_WORD *)&v68[4] = 2080;
          *(void *)&v68[6] = "entryDate";
          *(_WORD *)&v68[14] = 2112;
          *(void *)&v68[16] = v35;
          *(_WORD *)&v68[24] = 2080;
          *(void *)&v68[26] = "exitDate";
          *(_WORD *)&v68[34] = 2112;
          *(void *)&v68[36] = v36;
          *(_WORD *)&v68[44] = 2080;
          *(void *)&v68[46] = "confidence";
          __int16 v69 = 2048;
          uint64_t v70 = v38;
          __int16 v71 = 2080;
          __int16 v72 = "source";
          __int16 v73 = 1024;
          unsigned int v74 = v39;
          uint64_t v40 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke", "%s\n", v40);
          if (v40 != (char *)buf) {
            free(v40);
          }
          double v7 = v53;
          id v9 = v54;
          int v10 = &qword_102419000;
          int v11 = &qword_102419000;
        }
        if ([v13 exit])
        {
          [objc_msgSend(v13, "entry") timeIntervalSinceReferenceDate];
          -[CLVisitTimePeriod setStartTime:](v14, "setStartTime:");
          [objc_msgSend(v13, "exit") timeIntervalSinceReferenceDate];
        }
        else
        {
          if (objc_msgSend(objc_msgSend(v7, "firstObject"), "exit")) {
            goto LABEL_30;
          }
          [objc_msgSend(v13, "entry") timeIntervalSinceReferenceDate];
          double v31 = v30;
          [objc_msgSend(objc_msgSend(objc_msgSend(v7, "firstObject"), "entry"), "timeIntervalSinceReferenceDate");
          if (v31 != v32) {
            goto LABEL_30;
          }
          [objc_msgSend(objc_msgSend(objc_msgSend(v7, "firstObject"), "entry"), "timeIntervalSinceReferenceDate")];
          -[CLVisitTimePeriod setStartTime:](v14, "setStartTime:");
        }
        -[CLVisitTimePeriod setEndTime:](v14, "setEndTime:");
        if (v10[60] != -1) {
          dispatch_once(&qword_1024191E0, &stru_10230B438);
        }
        __int16 v23 = v11[61];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          [(CLVisitTimePeriod *)v14 startTime];
          uint64_t v25 = v24;
          [(CLVisitTimePeriod *)v14 endTime];
          uint64_t v27 = v26;
          id v28 = [v13 entry];
          id v29 = [v13 exit];
          *(_DWORD *)uint64_t buf = 136316930;
          *(void *)int v77 = "entryTimestamp";
          *(_WORD *)&v77[8] = 2048;
          *(void *)&v77[10] = v25;
          *(_WORD *)&v77[18] = 2080;
          *(void *)&v77[20] = "exitTimestamp";
          __int16 v78 = 2048;
          *(void *)int v79 = v27;
          *(_WORD *)&v79[8] = 2080;
          *(void *)&v79[10] = "entryDate";
          *(_WORD *)&v79[18] = 2112;
          *(void *)&v79[20] = v28;
          int v11 = &qword_102419000;
          *(_WORD *)&v79[28] = 2080;
          *(void *)&v79[30] = "exitDate";
          *(_WORD *)&v79[38] = 2112;
          *(void *)&v79[40] = v29;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "filtered visit from Routine,%s,%f,%s,%f,%s,%@,%s,%@", buf, 0x52u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (v10[60] != -1) {
            dispatch_once(&qword_1024191E0, &stru_10230B438);
          }
          [(CLVisitTimePeriod *)v14 startTime];
          BOOL v42 = v41;
          [(CLVisitTimePeriod *)v14 endTime];
          uint64_t v44 = v43;
          id v45 = [v13 entry];
          id v46 = [v13 exit];
          int v61 = 136316930;
          __int16 v62 = "entryTimestamp";
          __int16 v63 = 2048;
          id v64 = v42;
          __int16 v65 = 2080;
          __int16 v66 = "exitTimestamp";
          __int16 v67 = 2048;
          *(void *)__int16 v68 = v44;
          *(_WORD *)&v68[8] = 2080;
          *(void *)&v68[10] = "entryDate";
          *(_WORD *)&v68[18] = 2112;
          *(void *)&v68[20] = v45;
          *(_WORD *)&v68[28] = 2080;
          *(void *)&v68[30] = "exitDate";
          *(_WORD *)&v68[38] = 2112;
          *(void *)&v68[40] = v46;
          __int16 v47 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke", "%s\n", v47);
          if (v47 != (char *)buf) {
            free(v47);
          }
          int v10 = &qword_102419000;
          int v11 = &qword_102419000;
        }
        [*(id *)(a1 + 32) addObject:v14];
LABEL_30:

        int v12 = (char *)v12 + 1;
      }
      while (v9 != v12);
      id v48 = [v7 countByEnumeratingWithState:&v57 objects:v75 count:16];
      id v9 = v48;
      if (!v48)
      {
LABEL_45:
        uint64_t v49 = *(void *)(a1 + 40);
        [*(id *)(a1 + 32) count];
        __int32 v6 = *(uint64_t (**)(void))(v49 + 16);
        return v6();
      }
    }
  }
  if (qword_1024191E0 != -1) {
    dispatch_once(&qword_1024191E0, &stru_10230B438);
  }
  __int16 v50 = qword_1024191E8;
  if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "empty visit fetched from Routine", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    LOWORD(v61) = 0;
    __int16 v52 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke", "%s\n", v52);
    if (v52 != (char *)buf) {
      free(v52);
    }
  }
  __int32 v6 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v6();
}

void sub_101012688(uint64_t a1, void *a2, void *a3, int a4)
{
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id v8 = [a2 countByEnumeratingWithState:&v35 objects:v51 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v36;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v36 != v10) {
          objc_enumerationMutation(a2);
        }
        int v12 = *(void **)(*((void *)&v35 + 1) + 8 * i);
        if (objc_msgSend(*(id *)(a1 + 32), "isLocationUsefulForCalibration:", objc_msgSend(v12, "type")))
        {
          double v13 = objc_alloc_init(CLLocationPreFilterEntry);
          [objc_msgSend(v12, "timestamp") timeIntervalSinceReferenceDate];
          -[CLLocationDBEntry setTimestamp:](v13, "setTimestamp:");
          [v12 altitude];
          -[CLLocationDBEntry setElevation:](v13, "setElevation:");
          [v12 verticalAccuracy];
          -[CLLocationDBEntry setVerticalAccuracy:](v13, "setVerticalAccuracy:");
          [v12 coordinate];
          -[CLLocationDBEntry setLatitude:](v13, "setLatitude:");
          [v12 coordinate];
          [(CLLocationDBEntry *)v13 setLongitude:v14];
          [v12 horizontalAccuracy];
          -[CLLocationPreFilterEntry setHorizontalAccuracy:](v13, "setHorizontalAccuracy:");
          [*(id *)(a1 + 40) addObject:v13];
        }
      }
      id v9 = [a2 countByEnumeratingWithState:&v35 objects:v51 count:16];
    }
    while (v9);
  }
  if (qword_1024191E0 != -1) {
    dispatch_once(&qword_1024191E0, &stru_10230B438);
  }
  double v15 = qword_1024191E8;
  if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_INFO))
  {
    id v16 = [a2 count];
    *(_DWORD *)uint64_t buf = 134349056;
    id v46 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "received stored locations,count,%{public}lu", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    id v25 = [a2 count];
    int v39 = 134349056;
    id v40 = v25;
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisitSearchStartIndex:andCompletionBlock:]_block_invoke", "%s\n", v26);
    if (v26 != (char *)buf) {
      free(v26);
    }
  }
  if (a3)
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    unsigned int v17 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      id v46 = a3;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "error enumerating stored locations, %@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230B438);
      }
      int v39 = 138412290;
      id v40 = a3;
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisitSearchStartIndex:andCompletionBlock:]_block_invoke", "%s\n", v27);
      if (v27 != (char *)buf) {
        free(v27);
      }
    }
  }
  if (a4)
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    id v18 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_INFO))
    {
      [objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "startDate") timeIntervalSinceReferenceDate];
      uint64_t v20 = v19;
      [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "endDate"), "timeIntervalSinceReferenceDate"]
      uint64_t v22 = v21;
      id v23 = [*(id *)(a1 + 40) count];
      *(_DWORD *)uint64_t buf = 134349568;
      id v46 = v20;
      __int16 v47 = 2050;
      uint64_t v48 = v22;
      __int16 v49 = 2050;
      id v50 = v23;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "received all stored locations,startDate,%{public}f,endDate,%{public}f,count,%{public}lu", buf, 0x20u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230B438);
      }
      [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "startDate"), "timeIntervalSinceReferenceDate");
      id v29 = v28;
      [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "endDate"), "timeIntervalSinceReferenceDate");
      uint64_t v31 = v30;
      id v32 = [*(id *)(a1 + 40) count];
      int v39 = 134349568;
      id v40 = v29;
      __int16 v41 = 2050;
      uint64_t v42 = v31;
      __int16 v43 = 2050;
      id v44 = v32;
      id v33 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisitSearchStartIndex:andCompletionBlock:]_block_invoke", "%s\n", v33);
      if (v33 != (char *)buf) {
        free(v33);
      }
    }
    uint64_t v24 = [objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "silo") queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_101012D14;
    block[3] = &unk_1022D7BF0;
    block[4] = *(void *)(a1 + 56);
    dispatch_async(v24, block);
  }
}

uint64_t sub_101012D14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_101013440(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 112))
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    __int32 v2 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEBUG))
    {
      id v3 = [*(id *)(a1 + 40) count];
      [[[*(id *)(a1 + 40) firstObject] endDate] timeIntervalSinceReferenceDate];
      uint64_t v5 = v4;
      [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate"), "timeIntervalSinceReferenceDate");
      uint64_t v7 = v6;
      id v8 = [[objc_msgSend(*(id *)(a1 + 40), "firstObject") endDate];
      id v9 = [[objc_msgSend(*(id *)(a1 + 40), "lastObject") endDate];
      uint64_t v10 = *(void *)(a1 + 64);
      uint64_t v11 = *(void *)(a1 + 72);
      *(_DWORD *)uint64_t buf = 134219522;
      id v15 = v3;
      __int16 v16 = 2048;
      uint64_t v17 = v5;
      __int16 v18 = 2048;
      uint64_t v19 = v7;
      __int16 v20 = 2112;
      id v21 = v8;
      __int16 v22 = 2112;
      id v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = v10;
      __int16 v26 = 2048;
      uint64_t v27 = v11;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "pushing elevation profile batch,batchSize,%lu,firstElevationTime,%f,lastElevationTime,%f,firstElevationDate,%@,lastElevationDate,%@,startIndex,%lu,endIndex,%lu", buf, 0x48u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230B438);
      }
      [*(id *)(a1 + 40) count];
      [objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "firstObject"), "endDate"), "timeIntervalSinceReferenceDate");
      [objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate") timeIntervalSinceReferenceDate];
      [objc_msgSend(*(id *)(a1 + 40), "firstObject") endDate];
      [objc_msgSend(*(id *)(a1 + 40), "lastObject") endDate];
      double v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile _sendElevationsFromEstimates:startIndex:withCompletionBlock:]_block_invoke", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
  return [*(id *)(*(void *)(a1 + 32) + 120) addElevations:handler:];
}

void sub_1010137A0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (qword_1024191E0 != -1) {
      dispatch_once(&qword_1024191E0, &stru_10230B438);
    }
    uint64_t v4 = qword_1024191E8;
    if (os_log_type_enabled((os_log_t)qword_1024191E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      uint64_t v10 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "error adding elevations to routine: %@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191E0 != -1) {
        dispatch_once(&qword_1024191E0, &stru_10230B438);
      }
      id v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "-[CLContextManagerElevationProfile _sendElevationsFromEstimates:startIndex:withCompletionBlock:]_block_invoke", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    [objc_msgSend(*(id *)(a1 + 48), "objectAtIndexedSubscript:", *(void *)(a1 + 64)) timestamp];
    *(void *)(*(void *)(a1 + 40) + 96) = v5;
    [*(id *)(a1 + 40) saveLastPushedTime:*(double *)(*(void *)(a1 + 40) + 96)];
    uint64_t v6 = *(unsigned char **)(a1 + 64);
    if (v6 == (char *)[*(id *)(a1 + 48) count] - 1) {
      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    }
    else {
      [*(id *)(a1 + 40) _sendElevationsFromEstimates:*(void *)(a1 + 48) startIndex:*(void *)(a1 + 64) + 1 withCompletionBlock:*(void *)(a1 + 56)];
    }
    uint64_t v7 = *(void **)(a1 + 32);
  }
}

void sub_1010141BC(id a1)
{
  qword_1024191E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

uint64_t sub_1010141EC()
{
  sub_100134750(qword_1024828E8, "VO2MaxPowerBudgetEstimatorLastExtendedBudgetAllotmentReason");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1024828E8, (void *)&_mh_execute_header);
}

unsigned __int8 *sub_10101424C(unsigned __int8 *a1)
{
  return a1;
}

unsigned __int8 *sub_101014274(unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return a1;
}

uuid_t sub_10101429C(uuid_t uu, char *in)
{
  return uu;
}

uint64_t sub_1010142CC(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) >> 31;
}

BOOL sub_1010142E8(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) == 0;
}

BOOL sub_101014308(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) != 0;
}

void *sub_101014328@<X0>(const unsigned __int8 *a1@<X0>, void *a2@<X8>)
{
  memset(v4, 0, sizeof(v4));
  uuid_unparse(a1, v4);
  return sub_100134750(a2, v4);
}

uint64_t sub_10101439C(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (v1 > 0xA) {
    return 0;
  }
  else {
    return dword_101D9CFC8[v1];
  }
}

BOOL sub_1010143C0(uint64_t a1)
{
  return (unint64_t)(a1 - 3) < 3;
}

BOOL sub_1010143D0(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFFFDLL) == 16;
}

BOOL sub_1010143E0(uint64_t a1)
{
  return (unint64_t)(*(void *)(a1 + 16) - 13) < 6;
}

uint64_t sub_1010143F4(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (v1 <= 0x11)
  {
    if (((1 << v1) & 0x18002) != 0) {
      return 2;
    }
    if (((1 << v1) & 0x22001) != 0) {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_101014448(uint64_t result, uint64_t a2)
{
  switch(result)
  {
    case 1:
      if (a2 == 1)
      {
        return 16;
      }
      else if (a2 == 2)
      {
        return 15;
      }
      break;
    case 2:
      if (a2 == 1)
      {
        return 18;
      }
      else if (a2 == 2)
      {
        return 17;
      }
      break;
    case 3:
      if (a2 == 1)
      {
        return 5;
      }
      else if (a2 == 2)
      {
        return 4;
      }
      break;
  }
  return result;
}

uint64_t sub_1010144C0(unint64_t a1)
{
  if (((1 << a1) & 0x2408801328010) != 0) {
    uint64_t v1 = 2;
  }
  else {
    uint64_t v1 = ((1 << a1) & 0x1810000050020) != 0;
  }
  if (a1 <= 0x31) {
    return v1;
  }
  else {
    return 0;
  }
}

BOOL sub_101014514(uint64_t a1)
{
  return (unint64_t)(a1 - 1) < 2;
}

std::string *sub_101014524@<X0>(unint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t result = (std::string *)sub_100134750(a2, "invalid");
  if (a1 < 0x18 && ((0xFFFFDFu >> a1) & 1) != 0) {
    return std::string::assign(a2, (&off_10230B478)[a1]);
  }
  return result;
}

void sub_101014584(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010145A0(uint64_t a1)
{
  uint64_t result = 0;
  switch(*(void *)(a1 + 16))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 6:
    case 7:
    case 9:
    case 0xBLL:
    case 0xELL:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x17:
      uint64_t result = 6;
      break;
    case 4:
      uint64_t result = 5;
      break;
    case 8:
      uint64_t result = 2;
      break;
    case 0xCLL:
    case 0xDLL:
    case 0x11:
      uint64_t result = 1;
      break;
    case 0x10:
      uint64_t result = 3;
      break;
    case 0x16:
      uint64_t v3 = *(void *)(a1 + 112);
      if (v3 == 26 || v3 == 0) {
        uint64_t result = 3;
      }
      else {
        uint64_t result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_101014674(unint64_t a1)
{
  if (a1 > 6) {
    return 0;
  }
  unint64_t v1 = a1;
  if (((1 << a1) & 0x4B) != 0)
  {
    if (qword_1024191C0 != -1) {
      dispatch_once(&qword_1024191C0, &stru_10230B458);
    }
    __int32 v2 = qword_1024191C8;
    if (os_log_type_enabled((os_log_t)qword_1024191C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Unexpected state for user dismiss, keeping as is", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024191C0 != -1) {
        dispatch_once(&qword_1024191C0, &stru_10230B458);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CMWorkoutState CLWorkoutUtil::stateAfterUserDismiss(CMWorkoutState)", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
  else if (a1 == 4)
  {
    return 3;
  }
  else
  {
    return a1 == 5;
  }
  return v1;
}

uint64_t sub_101014848(uint64_t a1, uint64_t *a2)
{
  uint64_t result = 1;
  switch(a1)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 82:
    case 83:
      break;
    case 14:
    case 15:
    case 30:
    case 81:
      goto LABEL_4;
    default:
      if (a1 != 3000)
      {
LABEL_4:
        uint64_t result = 0;
        a1 = 3000;
      }
      break;
  }
  *a2 = a1;
  return result;
}

void sub_1010149E4(id a1)
{
  qword_1024191C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_101014A14()
{
}

void sub_101014A5C()
{
}

void sub_101014B30(id a1)
{
  qword_102482978 = (uint64_t)[objc_alloc((Class)CLDispatchSilo) initWithIdentifier:@"CLEmergencyControllerAdapterSilo"];
}

void sub_101014BB0(id a1)
{
  if (!objc_opt_class())
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unint64_t v1 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#EmergCon not supported on this platform because TelephonyUtilities.framework is not present", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int32 v2 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "+[CLEmergencyControllerAdapter isSupported]_block_invoke", "%s\n", v2);
      if (v2 != (char *)buf) {
        free(v2);
      }
    }
    byte_102482988 = 1;
  }
}

id sub_101014EC0(uint64_t a1)
{
  return [*(id *)(a1 + 32) checkEmergencyCallStatus];
}

void sub_101014F38(uint64_t a1)
{
  __chkstk_darwin(a1);
  id v16 = v2;
  if (v2)
  {
    uint64_t v3 = v1;
    id v4 = v2;
    sub_1002F9B84((uint64_t **)(v3 + 16), (unint64_t *)&v16, (uint64_t *)&v16);
    *(_DWORD *)uint64_t buf = 0;
    uint64_t v5 = sub_10011853C((void *)(v3 + 160), (int *)buf);
    if (v5)
    {
      id v6 = v16;
      sub_10102ECD4((uint64_t)v15, v5 + 3);
      [v6 emergencySettingsChange:sub_10101B1A0(v15) withReason:0];
      sub_10084DD34((uint64_t)v15);
    }
    else
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v7 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#EmergCon #Warning inst0 settings find returned null", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        __int16 v14 = 0;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::registerObserver(id<CLEmergencyClientProtocol>)", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
    }
    if (*(unsigned char *)(v3 + 133))
    {
      *(_DWORD *)uint64_t buf = 1;
      id v8 = sub_10011853C((void *)(v3 + 160), (int *)buf);
      if (v8)
      {
        id v9 = v16;
        sub_10102ECD4((uint64_t)v13, v8 + 3);
        [v9 emergencySettingsChange:sub_10101B1A0(v13) withReason:0];
        sub_10084DD34((uint64_t)v13);
      }
      else
      {
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v10 = qword_1024193E8;
        if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#EmergCon #Warning inst1 settings find returned null", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230B640);
          }
          __int16 v14 = 0;
          int v12 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::registerObserver(id<CLEmergencyClientProtocol>)", "%s\n", v12);
          if (v12 != (char *)buf) {
            free(v12);
          }
        }
      }
    }
    long long v21 = *(_OWORD *)(v3 + 72);
    int v22 = *(_DWORD *)(v3 + 88);
    *(void *)uint64_t buf = _NSConcreteStackBlock;
    uint64_t v18 = 3221225472;
    uint64_t v19 = sub_10103210C;
    __int16 v20 = &unk_10230B7C0;
    [v16 emergencyStateChange:-[uint8_t copy](buf, "copy")];
    [v16 shouldLockoutNilr:*(unsigned __int8 *)(v3 + 1)];
  }
}

void sub_101015354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10084DD34((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10101538C(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (a2)
  {
    sub_100700910(a1 + 16, (unint64_t *)&v2);
  }
}

void sub_1010153D4(uint64_t a1, int a2)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  id v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    id v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = "emergencyenablementassertion";
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon E911Event\", \"event\":%{public, location:escape_only}s, \"CLEEA\":%{public}d}", (uint8_t *)v6, 0x22u);
  }
  *(unsigned char *)(a1 + 56) = a2;
  if (a2) {
    unsigned int v5 = 5;
  }
  else {
    unsigned int v5 = 0;
  }
  sub_10101F880(a1, v5);
  sub_101019704(a1);
}

void sub_101015684(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) name];
  if ([v2 isEqualToString:TUCallCenterCallStatusChangedNotification])
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v3 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#EmergCon received TUCallCenterCallStatusChangedNotification notification", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      id v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "-[CLEmergencyControllerAdapter callEventHandler:]_block_invoke", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    id v4 = [*(id *)(a1 + 32) object];
    if (v4)
    {
      unsigned int v5 = v4;
      if ([v4 isEmergency]) {
        sub_1010159C0(qword_10248B150, v5);
      }
    }
    [*(id *)(a1 + 40) checkEmergencyCallStatus];
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      id v7 = [[objc_msgSend(*(id *)(a1 + 32), "name") UTF8String];
      *(_DWORD *)uint64_t buf = 136315138;
      id v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#EmergCon unexpected call event notification %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      [objc_msgSend(*(id *)(a1 + 32), "name") UTF8String];
      __int16 v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "-[CLEmergencyControllerAdapter callEventHandler:]_block_invoke", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1010159C0(uint64_t a1, void *a2)
{
  if (sub_10101A5A0([a2 status]) == 7)
  {
    *(_DWORD *)(a1 + 248) = sub_10101ABD0((uint64_t)[a2 disconnectedReason]);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 248);
      *(_DWORD *)uint64_t buf = 67109120;
      int v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#ADR,processCallStatusChanged,call disconnected reason:%d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      id v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::processCallStatusChanged(TUCall *)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 248) = -1;
  }
}

void sub_101015CB0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10101A314(a1);
    *(unsigned char *)(a1 + 134) = 1;
    if (*(unsigned char *)(a1 + 132))
    {
      *(unsigned char *)(a1 + 132) = 0;
      *(_OWORD *)(a1 + 92) = *(_OWORD *)(a1 + 112);
      *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 128);
      sub_101019704(a1);
    }
    uint64_t v4 = sub_10101A5A0([a2 status]);
    id v5 = [a2 originatingUIType];
    uint64_t v6 = sub_10101A77C((int)[a2 isSOS], (uint64_t)v5);
    *(_DWORD *)(a1 + 24sub_100FB8FC8(&a9, 0) = v6;
    *(_DWORD *)(a1 + 244) = v6;
    *(_DWORD *)uint64_t buf = 82;
    *(_DWORD *)id v33 = sub_10101AE34(v6);
    LODWORD(v39) = 0;
    id v28 = 0;
    id v29 = 0;
    uint64_t v27 = 0;
    id v23 = &v27;
    char v24 = 0;
    uint64_t v27 = (char *)operator new(0x28uLL);
    id v28 = v27;
    id v29 = v27 + 40;
    id v28 = (unsigned char *)sub_100682A48((uint64_t)&v29, (uint64_t)buf, (uint64_t)&v40, (uint64_t)v27);
    sub_100118010((uint64_t)v33);
    id v7 = *(void **)(a1 + 712);
    memset(v26, 0, sizeof(v26));
    sub_100682C20(v26, (uint64_t)v27, (uint64_t)v28, 0xCCCCCCCCCCCCCCCDLL * ((v28 - v27) >> 3));
    [v7 setMeasurements:sub_10067C03C(v26)];
    *(void *)uint64_t buf = v26;
    sub_100682B1C((void ***)buf);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v9 = [a2 isConnected];
      unsigned int v10 = [a2 isSOS];
      id v11 = &v23;
      sub_10101A58C(v4, &v23);
      if (v25 < 0) {
        id v11 = v23;
      }
      sub_10101A768(*(_DWORD *)(a1 + 244), __p);
      int v12 = v22;
      double v13 = (void **)__p[0];
      unsigned int v14 = [a2 isEndpointOnCurrentDevice];
      *(_DWORD *)uint64_t buf = 68290562;
      id v15 = __p;
      if (v12 < 0) {
        id v15 = v13;
      }
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)id v33 = 2082;
      *(void *)&v33[2] = "";
      __int16 v34 = 1026;
      unsigned int v35 = v9;
      __int16 v36 = 1026;
      unsigned int v37 = v10;
      __int16 v38 = 2082;
      int v39 = v11;
      __int16 v40 = 1026;
      int v41 = (int)v5;
      __int16 v42 = 2082;
      __int16 v43 = v15;
      __int16 v44 = 1026;
      unsigned int v45 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,onEmergencyCallStatusChanged\", \"call connected\":%{public}hhd, \"isSOS\":%{public}hhd, \"call status\":%{public, location:escape_only}s, \"TU trigger\":%{public}d, \"trigger\":%{public, location:escape_only}s, \"endpointOnCurrentDevice\":%{public}hhd}", buf, 0x3Eu);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
      if (v25 < 0) {
        operator delete(v23);
      }
    }
    sub_10147A928(*(void *)(a1 + 688), (uint64_t)[a2 callUUID], *(unsigned int *)(a1 + 244), v4, (uint64_t)[a2 isEndpointOnCurrentDevice]);
    uint64_t v16 = a1 + 584;
    if (!*(void *)(a1 + 584)) {
      operator new();
    }
    if (*(unsigned __int8 *)(a1 + 68) != [a2 isConnected])
    {
      unsigned int v17 = [a2 isConnected];
      *(unsigned char *)(a1 + 68) = v17;
      if (v17)
      {
        sub_101019354(a1, *(_DWORD *)(a1 + 64));
        sub_101019704(a1);
        if (*(void *)v16)
        {
          *(unsigned char *)(*(void *)v16 + 33) = 1;
          *(double *)(*(void *)v16 + 552) = sub_10016C458();
        }
      }
    }
    *(void *)uint64_t buf = &v27;
    sub_100682B1C((void ***)buf);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v18 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "#EmergCon,onEmergencyCallStatusChanged,no emergency call active", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LOWORD(v27) = 0;
      __int16 v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::onEmergencyCallStatusChanged(TUCall *)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    *(unsigned char *)(a1 + 68) = 0;
    sub_10147A928(*(void *)(a1 + 688), 0, 0, 0, 0);
    if (sub_100D33CB4(a1 + 72)) {
      sub_10101EDC8(a1);
    }
    *(unsigned char *)(a1 + 134) = 0;
    uint64_t v19 = *(void *)(a1 + 584);
    if (v19) {
      sub_10101FB80(v19);
    }
    if (*(_DWORD *)(a1 + 240)
      && objc_opt_class()
      && objc_msgSend(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"), "isSafetyDataSubmissionAllowed"))
    {
      CFStringRef v30 = @"callTriggerType";
      uint64_t v31 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 240)];
      +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      AnalyticsSendEvent();
    }
    *(void *)(a1 + 256) = 0;
    *(_DWORD *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;
  }
}

void sub_10101624C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
}

void sub_101016310(uint64_t a1)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  id v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#EmergCon,CLEmergencyController,interactiveStateChanged", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::interactiveStateChanged()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  uint64_t v3 = *(void *)(a1 + 584);
  if (v3) {
    sub_101020738(v3);
  }
}

void sub_1010164B0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 6sub_100FB8FC8(&a9, 0) = 0;
  *(_WORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 255;
  *(void *)(a1 + 84) = 0;
  *(void *)(a1 + 76) = 0;
  *(unsigned char *)(a1 + 92) = 0;
  *(void *)(a1 + 96) = 0x400000000;
  *(_WORD *)(a1 + 104) = 256;
  *(unsigned char *)(a1 + 106) = 0;
  *(_DWORD *)(a1 + 108) = 255;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0x400000000;
  *(_WORD *)(a1 + 124) = 256;
  *(unsigned char *)(a1 + 126) = 0;
  *(_DWORD *)(a1 + 128) = 255;
  *(unsigned char *)(a1 + 132) = 0;
  char v3 = sub_1000FFBA8();
  *(_OWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0u;
  *(unsigned char *)(a1 + 133) = v3;
  *(unsigned char *)(a1 + 134) = 0;
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 1065353216;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 232) = 1065353216;
  *(void *)(a1 + 24sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 248) = -1;
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 1065353216;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_DWORD *)(a1 + 344) = 1065353216;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_DWORD *)(a1 + 384) = 1065353216;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 424) = 1065353216;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_DWORD *)(a1 + 464) = 1065353216;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_DWORD *)(a1 + 504) = 1065353216;
  *(_DWORD *)(a1 + 512) = 0;
  *(unsigned char *)(a1 + 516) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 52sub_100FB8FC8(&a9, 0) = 0u;
  *(unsigned char *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 552) = 0u;
  *(unsigned char *)(a1 + 64sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(void *)(a1 + 68sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  operator new();
}

void sub_101017D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void **a13, uint64_t *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t *a28,uint64_t *a29,uint64_t *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  uint64_t v38 = *a30;
  *a30 = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
  sub_1010315F4(v34 + 87, 0);
  sub_1010315A4((uint64_t *)(v35 + 488), 0);
  sub_1010316C4(a14, 0);
  uint64_t v39 = v34[82];
  v34[82] = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  uint64_t v40 = *v36;
  *__int16 v36 = 0;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
  }
  sub_10041F48C(a11);
  sub_101020170((uint64_t *)(v35 + 384), 0);
  uint64_t v41 = *a29;
  *a29 = 0;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
  }
  uint64_t v42 = v34[70];
  v34[70] = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  uint64_t v43 = v34[66];
  v34[66] = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  uint64_t v44 = *a28;
  *a28 = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  sub_1000D7D80(v35 + 272);
  sub_1000D7D80(a31);
  sub_1000D7D80(v35 + 192);
  sub_1000D7D80(a32);
  sub_1000DB114(v35 + 112);
  sub_1000D7D80(a33);
  sub_101031644(v35);
  sub_10085044C(a34);
  sub_1000F5BB0(a12, *a13);
  _Unwind_Resume(a1);
}

void sub_101018118(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    id v7 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onMobileAssetNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    int v8 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      unsigned int v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onMobileAssetNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v10 = 0;
  }
  sub_10101C038(a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_1010182D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010182F4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onDaemonStatusNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    unsigned int v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onDaemonStatusNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_10101CA48(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1010184B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010184D0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onClientNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    unsigned int v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onClientNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_10101CF24(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10101868C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010186AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  long long v6 = *((_OWORD *)a2 + 5);
  long long v5 = *((_OWORD *)a2 + 6);
  long long v7 = *((_OWORD *)a2 + 4);
  *(void *)(a1 + 112) = a2[14];
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = v6;
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 64) = v7;
  long long v8 = *((_OWORD *)a2 + 1);
  long long v9 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + 48) = v9;
  *(_OWORD *)(a1 + 16) = v8;
  sub_10102EA4C(a1 + 120, (long long *)(a2 + 15));
  char v10 = (void **)(a1 + 944);
  if (*(char *)(a1 + 967) < 0) {
    operator delete(*v10);
  }
  long long v11 = *((_OWORD *)a2 + 59);
  *(void *)(a1 + 96sub_100FB8FC8(&a9, 0) = a2[120];
  *(_OWORD *)char v10 = v11;
  *((unsigned char *)a2 + 967) = 0;
  *((unsigned char *)a2 + 944) = 0;
  int v12 = (void **)(a1 + 968);
  if (*(char *)(a1 + 991) < 0) {
    operator delete(*v12);
  }
  long long v13 = *(_OWORD *)(a2 + 121);
  *(void *)(a1 + 984) = a2[123];
  *(_OWORD *)int v12 = v13;
  *((unsigned char *)a2 + 991) = 0;
  *((unsigned char *)a2 + 968) = 0;
  int v14 = *((_DWORD *)a2 + 250);
  *(void *)(a1 + 992) = a2[124];
  *(_DWORD *)(a1 + 100sub_100FB8FC8(&a9, 0) = v14;
  uint64_t v15 = a2[132];
  long long v16 = *((_OWORD *)a2 + 65);
  long long v17 = *((_OWORD *)a2 + 64);
  *(_OWORD *)(a1 + 1008) = *((_OWORD *)a2 + 63);
  *(_OWORD *)(a1 + 1024) = v17;
  *(_OWORD *)(a1 + 104sub_100FB8FC8(&a9, 0) = v16;
  *(void *)(a1 + 1056) = v15;
  *(unsigned char *)(a1 + 1064) = *((unsigned char *)a2 + 1064);
  __int16 v18 = (void **)(a1 + 1072);
  if (*(char *)(a1 + 1095) < 0) {
    operator delete(*v18);
  }
  long long v19 = *((_OWORD *)a2 + 67);
  *(void *)(a1 + 1088) = a2[136];
  *(_OWORD *)__int16 v18 = v19;
  *((unsigned char *)a2 + 1095) = 0;
  *((unsigned char *)a2 + 1072) = 0;
  long long v20 = *(_OWORD *)(a2 + 137);
  *(_OWORD *)(a1 + 1108) = *(_OWORD *)((char *)a2 + 1108);
  *(_OWORD *)(a1 + 1096) = v20;
  sub_100341210((void **)(a1 + 1128));
  *(void *)(a1 + 1128) = a2[141];
  *(void *)(a1 + 1136) = a2[142];
  *(void *)(a1 + 1144) = a2[143];
  a2[143] = 0;
  a2[142] = 0;
  a2[141] = 0;
  *(unsigned char *)(a1 + 1152) = *((unsigned char *)a2 + 1152);
  long long v21 = (void **)(a1 + 1160);
  if (*(char *)(a1 + 1183) < 0) {
    operator delete(*v21);
  }
  long long v22 = *(_OWORD *)(a2 + 145);
  *(void *)(a1 + 1176) = a2[147];
  *(_OWORD *)long long v21 = v22;
  *((unsigned char *)a2 + 1183) = 0;
  *((unsigned char *)a2 + 116sub_100FB8FC8(&a9, 0) = 0;
  long long v23 = *((_OWORD *)a2 + 74);
  *(_OWORD *)(a1 + 1196) = *(_OWORD *)((char *)a2 + 1196);
  *(_OWORD *)(a1 + 1184) = v23;
  sub_100341210((void **)(a1 + 1216));
  *(_OWORD *)(a1 + 1216) = *((_OWORD *)a2 + 76);
  *(void *)(a1 + 1232) = a2[154];
  a2[153] = 0;
  a2[152] = 0;
  a2[154] = 0;
  char v24 = (void **)(a1 + 1240);
  if (*(char *)(a1 + 1263) < 0) {
    operator delete(*v24);
  }
  long long v25 = *(_OWORD *)(a2 + 155);
  *(void *)(a1 + 1256) = a2[157];
  *(_OWORD *)char v24 = v25;
  *((unsigned char *)a2 + 1263) = 0;
  *((unsigned char *)a2 + 124sub_100FB8FC8(&a9, 0) = 0;
  __int16 v26 = (void **)(a1 + 1264);
  if (*(char *)(a1 + 1287) < 0) {
    operator delete(*v26);
  }
  long long v27 = *((_OWORD *)a2 + 79);
  *(void *)(a1 + 128sub_100FB8FC8(&a9, 0) = a2[160];
  *(_OWORD *)__int16 v26 = v27;
  *((unsigned char *)a2 + 1287) = 0;
  *((unsigned char *)a2 + 1264) = 0;
  id v28 = (void **)(a1 + 1288);
  if (*(char *)(a1 + 1311) < 0) {
    operator delete(*v28);
  }
  long long v29 = *(_OWORD *)(a2 + 161);
  *(void *)(a1 + 1304) = a2[163];
  *(_OWORD *)id v28 = v29;
  *((unsigned char *)a2 + 1311) = 0;
  *((unsigned char *)a2 + 1288) = 0;
  CFStringRef v30 = (void **)(a1 + 1312);
  if (*(char *)(a1 + 1335) < 0) {
    operator delete(*v30);
  }
  long long v31 = *((_OWORD *)a2 + 82);
  *(void *)(a1 + 1328) = a2[166];
  *(_OWORD *)CFStringRef v30 = v31;
  *((unsigned char *)a2 + 1335) = 0;
  *((unsigned char *)a2 + 1312) = 0;
  return a1;
}

void sub_10101894C(uint64_t a1)
{
  sub_100103240();
  if (sub_10010145C() && !qword_102482998)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "EMERGENCY: addException", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LOWORD(v16) = 0;
      long long v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::connectToCT()", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    _CTServerConnectionAddIdentifierException();
  }
  [objc_msgSend(*(id *)(a1 + 8), "silo") queue];
  uint64_t v3 = _CTServerConnectionCreateOnTargetQueue();
  *(void *)(a1 + 552) = v3;
  if (v3)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      v19[0] = qword_102482998 + 1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#EmergCon EMERGENCY: Connected to CT after %lld attempts", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v16 = 134217984;
      v17[0] = qword_102482998 + 1;
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::connectToCT()", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
    qword_102482998 = 0;
  }
  else
  {
    ++qword_102482998;
    dispatch_time_t v5 = dispatch_time(0, 2000000000 * qword_102482998);
    long long v6 = [objc_msgSend(*(id *)(a1 + 8), "silo") queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10101B78C;
    block[3] = &unk_1022A3020;
    block[4] = a1;
    dispatch_after(v5, v6, block);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    long long v7 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      v19[0] = qword_102482998;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#EmergCon #Warning EMERGENCY: Did not connect to CT after %lld attempts", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v16 = 134217984;
      v17[0] = qword_102482998;
      int v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::connectToCT()", "%s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
  }
  sub_100103240();
  if (sub_10010145C())
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    long long v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = *(void *)(a1 + 552) != 0;
      *(_DWORD *)uint64_t buf = 67109376;
      LODWORD(v19[0]) = v9;
      WORD2(v19[0]) = 2048;
      *(void *)((char *)v19 + 6) = qword_102482998;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "EMERGENCY: connected?, %d, failed, %lld", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v12 = *(void *)(a1 + 552) != 0;
      int v16 = 67109376;
      LODWORD(v17[0]) = v12;
      WORD2(v17[0]) = 2048;
      *(void *)((char *)v17 + 6) = qword_102482998;
      long long v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::connectToCT()", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
}

void sub_101018FEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  id v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#Warning #EmergCon call connect timeout fired", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLEmergencyController::CLEmergencyController(id<CLIntersiloUniverse>)_block_invoke", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  sub_1010191A4((id *)v1);
  *(unsigned char *)(v1 + 68) = 1;
  sub_101019354(v1, *(_DWORD *)(v1 + 64));
  sub_101019704(v1);
}

id *sub_1010191A4(id *result)
{
  if (*((unsigned char *)result + 144))
  {
    uint64_t v1 = result;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon clearing call connect timeout", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::clearCallConnectTimeout()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
    uint64_t result = (id *)[v1[17] setNextFireDelay:1.79769313e308];
    *((unsigned char *)v1 + 144) = 0;
  }
  return result;
}

void sub_101019354(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  if (*(_DWORD *)(a1 + 60) == a2)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)uint64_t buf = 67109376;
      int v22 = v5;
      __int16 v23 = 1024;
      LODWORD(v24) = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon,newState,ignoring,fEmergencyStateOld,%d,state,%d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v6 = *(_DWORD *)(a1 + 60);
      LODWORD(__p) = 67109376;
      HIDWORD(__p) = v6;
      __int16 v18 = 1024;
      unsigned int v19 = a2;
      long long v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::newState(EmergencyState)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    return;
  }
  if (*(unsigned char *)(a1 + 69)) {
    BOOL v8 = a2 > 0xA;
  }
  else {
    BOOL v8 = 1;
  }
  BOOL v9 = v8 || ((1 << a2) & 0x442) == 0;
  if (v9 || *(unsigned char *)(a1 + 68))
  {
    *(_DWORD *)(a1 + 6sub_100FB8FC8(&a9, 0) = a2;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v10 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      sub_10101DC90(a2, &__p);
      if (v20 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)uint64_t buf = 68289794;
      int v22 = 0;
      __int16 v23 = 2082;
      char v24 = "";
      __int16 v25 = 2082;
      *(void *)__int16 v26 = "newState";
      *(_WORD *)&v26[8] = 1026;
      *(_DWORD *)&v26[10] = a2;
      __int16 v27 = 2082;
      id v28 = p_p;
      BOOL v12 = "{\"msg%{public}.0s\":\"#EmergCon E911Event\", \"event\":%{public, location:escape_only}s, \"Emergency: state"
            "\":%{public}d, \"Emergency: StringifiedState\":%{public, location:escape_only}s}";
      long long v13 = v10;
      uint32_t v14 = 44;
      goto LABEL_26;
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v15 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      sub_10101DC90(a2, &__p);
      if (v20 >= 0) {
        int v16 = &__p;
      }
      else {
        int v16 = __p;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      char v24 = "";
      __int16 v25 = 1026;
      *(_DWORD *)__int16 v26 = a2;
      *(_WORD *)&v26[4] = 2082;
      *(void *)&v26[6] = v16;
      BOOL v12 = "{\"msg%{public}.0s\":\"#EmergCon delaying emergency state until call connects\", \"state\":%{public}d, \"Str"
            "ingifiedState\":%{public, location:escape_only}s}";
      long long v13 = v15;
      uint32_t v14 = 34;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      if (v20 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_101019704(uint64_t a1)
{
  long long v24 = *(_OWORD *)(a1 + 92);
  int v25 = *(_DWORD *)(a1 + 108);
  sub_100D33A40((uint64_t)v26, (unsigned __int8 *)&v24, *(unsigned __int8 *)(a1 + 56));
  if (*(_DWORD *)v26 == *(_DWORD *)(a1 + 72)
    && *(void *)&v26[4] == *(void *)(a1 + 76)
    && *(void *)&v26[12] == *(void *)(a1 + 84))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100D335B8(v26, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)id v28 = 2082;
      *(void *)&v28[2] = "";
      *(_WORD *)&v28[10] = 2082;
      *(void *)&v28[12] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,updateEmergencyState,ignoring as it is same as current state\", \"state\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1010191A4((id *)a1);
  }
  else
  {
    if (sub_100D33CB4((uint64_t)v26))
    {
      if (!*(unsigned char *)(a1 + 134))
      {
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v4 = qword_1024193E8;
        if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#EmergCon,updateEmergencyState,emergency call not active but CT in voice emergency", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230B640);
          }
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          __int16 v18 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateEmergencyState()", "%s\n", v18);
          if (v18 != (char *)buf) {
            free(v18);
          }
        }
        sub_10101EDC8(a1);
      }
    }
    else
    {
      sub_10101A314(a1);
    }
    if (*(unsigned char *)(a1 + 69) && sub_100D33C70((uint64_t)v26) && !*(unsigned char *)(a1 + 68))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v16 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        sub_100D335B8(v26, &__p);
        long long v17 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)id v28 = 2082;
        *(void *)&v28[2] = "";
        *(_WORD *)&v28[10] = 2082;
        *(void *)&v28[12] = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,updateEmergencyState,delaying emergency state until call connects\", \"State\":%{public, location:escape_only}s}", buf, 0x1Cu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      sub_10101F2B8((id *)a1);
    }
    else
    {
      sub_1010191A4((id *)a1);
      BOOL v5 = sub_100D33D08((uint64_t)v26);
      sub_10101D934((unsigned __int8 *)a1, !v5);
      BOOL v6 = sub_100D33CD4(a1 + 72);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)v26;
      *(_DWORD *)(a1 + 88) = *(_DWORD *)&v26[16];
      BOOL v7 = sub_100D33CD4(a1 + 72);
      if (!v6 || v7)
      {
        if (!v6 && v7) {
          sub_10101E264(a1);
        }
      }
      else
      {
        sub_10101EBF4(a1);
      }
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v8 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        sub_100D335B8(v26, &__p);
        BOOL v9 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
           ? &__p
           : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)id v28 = 2082;
        *(void *)&v28[2] = "";
        *(_WORD *)&v28[10] = 2082;
        *(void *)&v28[12] = "newStateClass";
        *(_WORD *)&v28[20] = 2082;
        *(void *)&v28[22] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon E911Event\", \"event\":%{public, location:escape_only}s, \"Emergency: StringifiedState\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v10 = *(void **)(a1 + 16);
      if (v10 != (void *)(a1 + 24))
      {
        do
        {
          long long v11 = (void *)v10[4];
          *(_OWORD *)&v28[24] = *(_OWORD *)v26;
          int v29 = *(_DWORD *)&v26[16];
          *(void *)uint64_t buf = _NSConcreteStackBlock;
          *(void *)id v28 = 3221225472;
          *(void *)&void v28[8] = sub_10103210C;
          *(void *)&v28[16] = &unk_10230B7C0;
          [v11 emergencyStateChange:-[uint8_t copy](buf, "copy")];
          BOOL v12 = (void *)v10[1];
          if (v12)
          {
            do
            {
              long long v13 = v12;
              BOOL v12 = (void *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              long long v13 = (void *)v10[2];
              BOOL v14 = *v13 == (void)v10;
              uint64_t v10 = v13;
            }
            while (!v14);
          }
          uint64_t v10 = v13;
        }
        while (v13 != (void *)(a1 + 24));
      }
      uint64_t v15 = *(void *)(a1 + 688);
      long long v21 = *(_OWORD *)v26;
      int v22 = *(_DWORD *)&v26[16];
      sub_101479DA4(v15, &v21);
      long long v19 = *(_OWORD *)v26;
      int v20 = *(_DWORD *)&v26[16];
      sub_10101F488(a1, &v19);
    }
  }
}

void sub_101019D40(uint64_t a1, uint64_t a2)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a2 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onDeviceOrientation", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    BOOL v5 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      long long v11 = "";
      __int16 v12 = 2082;
      long long v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onDeviceOrientation\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v7 = 0;
  }
  sub_10101D03C(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_101019EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_101019F14(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    BOOL v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onMotionNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    int v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      long long v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onMotionNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_10101D26C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10101A0D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10101A0F0(uint64_t a1, _DWORD *a2, unsigned char *a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230B660);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    uint64_t v7 = _os_activity_create((void *)&_mh_execute_header, "CL: CLEmergencyController::onCompanionNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230B660);
    }
    BOOL v8 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2082;
      __int16 v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLEmergencyController::onCompanionNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v10 = 0;
  }
  if (*a2 == 5 && sub_10016CCBC()) {
    *(unsigned char *)(a4 + 516) = *a3;
  }
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_10101A2B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10101A2D8(id a1)
{
  uint64_t v1 = +[SOSManager sharedInstance];

  [(SOSManager *)v1 mostRecentLocationSentWithCompletion:&stru_10230B5D8];
}

void sub_10101A314(uint64_t a1)
{
  id v2 = *(void **)(a1 + 152);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 152) = 0;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v3 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#EmergCon,clearLongEemTimeout,timer cleared", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1)
      {
LABEL_16:
        BOOL v5 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::clearLongEemTimeout()", "%s\n", v5);
        if (v5 != (char *)buf) {
          free(v5);
        }
        return;
      }
LABEL_18:
      dispatch_once(&qword_1024193E0, &stru_10230B640);
      goto LABEL_16;
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon,clearLongEemTimeout,no timer exists", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1) {
        goto LABEL_16;
      }
      goto LABEL_18;
    }
  }
}

void *sub_10101A58C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_10230BEF8[a1]);
}

uint64_t sub_10101A5A0(unsigned int a1)
{
  if (a1 < 7) {
    return a1 + 1;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v3 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    unsigned int v7 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#EmergCon unhandled TUCallStatus %{public}d", buf, 8u);
  }
  BOOL v4 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v4)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static CLEmergencyController::CallStatus CLEmergencyController::toCallStatus(TUCallStatus)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
    return 0;
  }
  return result;
}

void *sub_10101A768@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_10230BF38[a1]);
}

uint64_t sub_10101A77C(int a1, uint64_t a2)
{
  uint64_t v2 = a2;
  switch((int)a2)
  {
    case 0:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v4 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning #EmergCon TU trigger was not filled in", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_30;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static CLEmergencyController::EmergencyTriggerType CLEmergencyController::toEmergencyTriggerType(BOOL, TUCallOriginatingUIType)", "%s\n");
      goto LABEL_38;
    case 1:
      return v2;
    case 2:
      return 2;
    case 3:
      return 4;
    case 4:
      return 5;
    case 5:
      return 6;
    case 6:
      return 7;
    case 7:
      return 8;
    case 8:
      return 12;
    case 9:
      return 13;
    case 10:
      BOOL v6 = !sub_10101AB74();
      unsigned int v7 = 9;
      unsigned int v8 = 17;
      goto LABEL_21;
    case 11:
      return 14;
    case 12:
      BOOL v6 = !sub_10101AB74();
      unsigned int v7 = 10;
      unsigned int v8 = 18;
LABEL_21:
      if (v6) {
        uint64_t v2 = v7;
      }
      else {
        uint64_t v2 = v8;
      }
      break;
    case 13:
      uint64_t v2 = 11;
      break;
    case 26:
      uint64_t v2 = 16;
      break;
    default:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v9 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 67240192;
        int v12 = v2;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "#EmergCon unhandled TU trigger %{public}d", buf, 8u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        BOOL v5 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static CLEmergencyController::EmergencyTriggerType CLEmergencyController::toEmergencyTriggerType(BOOL, TUCallOriginatingUIType)", "%s\n");
LABEL_38:
        if (v5 != buf) {
          free(v5);
        }
      }
LABEL_30:
      if (a1) {
        uint64_t v2 = 3;
      }
      else {
        uint64_t v2 = 0;
      }
      break;
  }
  return v2;
}

BOOL sub_10101AB74()
{
  uint64_t v0 = (id)CFPreferencesCopyValue(@"SafetySOSEvent", @"com.apple.anomalydetectiond", @"mobile", kCFPreferencesCurrentHost);
  return v0 && [v0 intValue] == 2;
}

uint64_t sub_10101ABD0(uint64_t result)
{
  if (result > 0x24 || ((1 << result) & 0x17FFEFFFFFLL) == 0)
  {
    if ((result - 1000) >= 2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t sub_10101AC10(uint64_t a1)
{
  uint64_t v1 = sub_10101AE34(a1);
  uint64_t result = 0;
  switch((int)v1)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      uint64_t result = v1;
      break;
    case 9:
    case 10:
    case 11:
    case 15:
      uint64_t result = 3;
      break;
    case 19:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v3 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#EmergCon,mapCallTriggerType,invalid enum value", buf, 2u);
      }
      BOOL v4 = sub_10013D1A0(115, 0);
      uint64_t result = 0;
      if (v4)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        BOOL v5 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static Emergency::CallTriggerType CLEmergencyController::mapCallTriggerType(EmergencyTriggerType)", "%s\n", v5);
        if (v5 != (char *)buf) {
          free(v5);
        }
        uint64_t result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10101AE34(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1 <= 0x12
    && ((1 << a1) & 0x60E80) != 0
    && (!objc_opt_class()
     || (objc_msgSend(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"), "isSafetyDataSubmissionAllowed") & 1) == 0))
  {
    return 15;
  }
  return v1;
}

void *sub_10101AE9C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
      BOOL v4 = "kClientRegistration";
      goto LABEL_14;
    case 1:
      BOOL v4 = "kCTConnectionEstablished";
      goto LABEL_14;
    case 2:
      BOOL v4 = "kCarrierChanged";
      goto LABEL_14;
    case 3:
      BOOL v4 = "kOperatorChanged";
      goto LABEL_14;
    case 4:
      BOOL v4 = "kVoiceCarrierChanged";
      goto LABEL_14;
    case 5:
      BOOL v4 = "kDEMAreaMonitorStatusChanged";
LABEL_14:
      uint64_t result = sub_100134750(a2, v4);
      break;
    default:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v5 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 67109120;
        int v9 = a1;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "#EmergCon Unknown settings changed reason %d", buf, 8u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        unsigned int v7 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static std::string CLEmergencyController::toString(SettingsChangedReason)", "%s\n", v7);
        if (v7 != (char *)buf) {
          free(v7);
        }
      }
      uint64_t result = sub_100134750(a2, "UnhandledReason");
      break;
  }
  return result;
}

id sub_10101B1A0(uint64_t *a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  void v3[2] = sub_1010320EC;
  v3[3] = &unk_10230B790;
  sub_10102ECD4((uint64_t)v4, a1);
  id v1 = [v3 copy];
  sub_10084DD34((uint64_t)v4);
  return v1;
}

void sub_10101B23C(_Unwind_Exception *a1)
{
  sub_10084DD34(v1);
  _Unwind_Resume(a1);
}

void sub_10101B250(uint64_t a1, int a2)
{
  sub_1000C7F88(buf);
  v13[0] = 0;
  int v4 = sub_1000D2988(*(uint64_t *)buf, "EmergencyCellularDataToggleAllowed", v13);
  if (v13[0]) {
    int v5 = 0;
  }
  else {
    int v5 = v4;
  }
  if (*(void *)v15) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v15);
  }
  if (v5)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    BOOL v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmergCon,enableCellularData,not allowed", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v13 = 0;
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enableCellularData(BOOL)", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
    *(unsigned char *)(a1 + 568) = 0;
  }
  else
  {
    if (a2)
    {
      _CTServerConnectionGetCellularDataIsEnabled();
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned int v7 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int16 v15 = 2082;
        *(void *)&id v15[2] = "";
        __int16 v16 = 1026;
        int v17 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmgContext\", \"CellData\":%{public}d}", buf, 0x18u);
      }
      *(unsigned char *)(a1 + 568) = 1;
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned int v8 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#EmergCon forcing cellular data on", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        *(_WORD *)__int16 v13 = 0;
        int v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enableCellularData(BOOL)", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 568)) {
        return;
      }
      *(unsigned char *)(a1 + 568) = 0;
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v9 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#EmergCon forcing cellular data off", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        *(_WORD *)__int16 v13 = 0;
        char v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enableCellularData(BOOL)", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
    }
    _CTServerConnectionSetCellularDataIsEnabled();
  }
}

void sub_10101B76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10101B78C(uint64_t a1)
{
  return sub_10101894C(*(void *)(a1 + 32));
}

void sub_10101B794(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = &qword_102419000;
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  int v5 = &qword_102419000;
  BOOL v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *((_DWORD *)a2 + 4);
    int v8 = *a2;
    uint64_t v9 = *((int *)a2 + 1);
    sub_10055E278((uint64_t)a2, &v42);
    int v10 = SHIBYTE(v46);
    char v11 = (void **)v42;
    uint64_t v12 = *((int *)a2 + 2);
    sub_10055E2A8((uint64_t)a2, __p);
    __int16 v13 = &v42;
    if (v10 < 0) {
      __int16 v13 = v11;
    }
    __int16 v14 = (void **)__p[0];
    int v15 = a2[12];
    if (v41 >= 0) {
      __int16 v14 = __p;
    }
    *(_DWORD *)uint64_t buf = 67110658;
    int v56 = v7;
    __int16 v57 = 1024;
    int v58 = v8;
    __int16 v59 = 2048;
    uint64_t v60 = v9;
    __int16 v61 = 2080;
    __int16 v62 = v13;
    __int16 v63 = 2048;
    uint64_t v64 = v12;
    __int16 v65 = 2080;
    __int16 v66 = v14;
    __int16 v67 = 1024;
    int v68 = v15;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmergCon onEmergencyModeChanged sim,%d,enabled,%d,type,%ld,CLCTEmergencyModeType_%s,state,%ld,CLCTEmergencyModeState_%s,isEmergencyText,%d", buf, 0x3Cu);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    int v5 = &qword_102419000;
    int v4 = &qword_102419000;
    if (SHIBYTE(v46) < 0) {
      operator delete(v42);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v28 = *((_DWORD *)a2 + 4);
    int v29 = *a2;
    uint64_t v30 = *((int *)a2 + 1);
    sub_10055E278((uint64_t)a2, __p);
    int v31 = v41;
    id v32 = (void **)__p[0];
    uint64_t v33 = *((int *)a2 + 2);
    sub_10055E2A8((uint64_t)a2, v38);
    __int16 v34 = __p;
    if (v31 < 0) {
      __int16 v34 = v32;
    }
    if (v39 >= 0) {
      uint64_t v35 = v38;
    }
    else {
      uint64_t v35 = (void **)v38[0];
    }
    int v36 = a2[12];
    LODWORD(v42) = 67110658;
    HIDWORD(v42) = v28;
    __int16 v43 = 1024;
    int v44 = v29;
    __int16 v45 = 2048;
    uint64_t v46 = v30;
    __int16 v47 = 2080;
    uint64_t v48 = v34;
    __int16 v49 = 2048;
    uint64_t v50 = v33;
    __int16 v51 = 2080;
    __int16 v52 = v35;
    __int16 v53 = 1024;
    int v54 = v36;
    unsigned int v37 = (char *)_os_log_send_and_compose_impl();
    if (v39 < 0) {
      operator delete(v38[0]);
    }
    int v5 = &qword_102419000;
    int v4 = &qword_102419000;
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::onEmergencyModeChanged(CLCTEmergencyMode)", "%s\n", v37);
    if (v37 != (char *)buf) {
      free(v37);
    }
  }
  long long v16 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 128) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 112) = v16;
  if (!*(unsigned char *)(a1 + 132)) {
    goto LABEL_16;
  }
  if (a2[12] || !*a2 || !*((_DWORD *)a2 + 1))
  {
    *(unsigned char *)(a1 + 132) = 0;
LABEL_16:
    long long v17 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 108) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 92) = v17;
  }
  sub_101019704(a1);
  int v19 = *((_DWORD *)a2 + 1);
  int v20 = *a2;
  int v21 = a2[12];
  unsigned int v22 = *((_DWORD *)a2 + 4);
  if (v22 < 2 || v22 == 255)
  {
    if (v22 != 1 || *(unsigned char *)(a1 + 133))
    {
      if (!v20 || v19)
      {
        if (v22)
        {
          if (v22 == 1)
          {
            *(_DWORD *)(a1 + 52) = v19;
            unsigned int v26 = sub_10102B6A8(v18, 1, v19, v21 != 0);
            sub_10101BE7C(a1, v26);
          }
          else if (!v20)
          {
            *(_DWORD *)(a1 + 48) = v19;
            *(_DWORD *)(a1 + 52) = v19;
            sub_10101BE7C(a1, 0);
          }
        }
        else
        {
          *(_DWORD *)(a1 + 48) = v19;
          unsigned int v27 = sub_10102B6A8(v18, 0, v19, v21 != 0);
          sub_10101BE7C(a1, v27);
        }
      }
      else
      {
        sub_10101BE7C(a1, 0xAu);
      }
    }
    else
    {
      if (v4[124] != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v23 = v5[125];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 67109120;
        int v56 = 1;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "#EmergCon Unexpected Sim Instance received %d", buf, 8u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (v4[124] != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v42 = (void *)0x104000100;
        long long v24 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::onEmergencyModeChanged(CLCTEmergencyMode)", "%s\n", v24);
LABEL_40:
        if (v24 != (char *)buf) {
          free(v24);
        }
      }
    }
  }
  else
  {
    if (v4[124] != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v25 = v5[125];
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 67109120;
      int v56 = v22;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "#EmergCon,InvalidSim,%d", buf, 8u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (v4[124] != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LODWORD(v42) = 67109120;
      HIDWORD(v42) = v22;
      long long v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::onEmergencyModeChanged(CLCTEmergencyMode)", "%s\n", v24);
      goto LABEL_40;
    }
  }
}

void sub_10101BE44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10101BE7C(uint64_t a1, unsigned int a2)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  int v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    unsigned int v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon,updateCtEmergencyState,state,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateCtEmergencyState(EmergencyState)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  sub_101020A5C(a1, a2);
}

uint64_t sub_10101C038(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (*a3 == 1)
  {
    uint64_t v3 = result;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v7 = 0;
      __int16 v8 = 2082;
      uint64_t v9 = "";
      __int16 v10 = 2082;
      char v11 = "CLMobileAssetManager_Type::kNotificationEmergencyCarrierSettings";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#EmergCon,#cb,#EmergSettings CB:notification\", \"notif\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
    sub_1004CE794(v5);
    sub_10101C178(v3);
    return sub_10013F3C4(v5);
  }
  return result;
}

void sub_10101C15C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10101C178(uint64_t a1)
{
  __chkstk_darwin(a1);
  uint64_t v3 = v2;
  uint64_t v4 = v2 + 200;
  int v5 = *(void **)(v2 + 216);
  if (v5)
  {
    uint64_t v6 = v1;
    do
    {
      int v7 = (void *)sub_1000E9358(v6);
      sub_100556180((uint64_t)(v5 + 3), v7);
      int v5 = (void *)*v5;
    }
    while (v5);
  }
  int v41 = 0;
  *(void *)uint64_t buf = &v41;
  __int16 v8 = sub_101031714(v4, &v41, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
  int v38 = 1;
  *(void *)uint64_t buf = &v38;
  uint64_t v9 = sub_101031714(v4, &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
  sub_101021C14(v3, (uint64_t)(v8 + 3), (uint64_t)(v9 + 3), (uint64_t)__p);
  int v37 = 0;
  *(void *)uint64_t buf = &v37;
  __int16 v10 = sub_1008567B8(v3 + 160, &v37, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
  sub_1010186AC((uint64_t)(v10 + 3), (uint64_t *)__p);
  sub_10084DD34((uint64_t)__p);
  *(_DWORD *)uint64_t buf = 0;
  __p[0] = buf;
  *((_DWORD *)sub_1008567B8(v3 + 160, (int *)buf, (uint64_t)&unk_101D0B290, (_DWORD **)__p) + 6) = 0;
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  char v11 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v41 = 0;
    __p[0] = &v41;
    uint64_t v12 = sub_1008567B8(v3 + 160, &v41, (uint64_t)&unk_101D0B290, (_DWORD **)__p);
    sub_10101E8B4((uint64_t)(v12 + 3));
    __int16 v13 = v44 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t buf = 136380675;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#cb, New Location Settings for sim 1,%{private}s", buf, 0xCu);
    if (v44 < 0) {
      operator delete(__p[0]);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v38 = 0;
    *(void *)uint64_t buf = &v38;
    unsigned int v27 = sub_1008567B8(v3 + 160, &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    sub_10101E8B4((uint64_t)(v27 + 3));
    if (v40 >= 0) {
      int v28 = buf;
    }
    else {
      int v28 = *(unsigned char **)buf;
    }
    int v41 = 136380675;
    uint64_t v42 = v28;
    int v29 = (char *)_os_log_send_and_compose_impl();
    if (v40 < 0) {
      operator delete(*(void **)buf);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateEmergencySettings(CLNameValuePair)", "%s\n", v29);
    if (v29 != (char *)__p) {
      free(v29);
    }
  }
  if (*(unsigned char *)(v3 + 133))
  {
    int v41 = 2;
    *(void *)uint64_t buf = &v41;
    __int16 v14 = sub_101031714(v4, &v41, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    int v38 = 3;
    *(void *)uint64_t buf = &v38;
    int v15 = sub_101031714(v4, &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    sub_101021C14(v3, (uint64_t)(v14 + 3), (uint64_t)(v15 + 3), (uint64_t)__p);
    int v37 = 1;
    *(void *)uint64_t buf = &v37;
    long long v16 = sub_1008567B8(v3 + 160, &v37, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    sub_1010186AC((uint64_t)(v16 + 3), (uint64_t *)__p);
    sub_10084DD34((uint64_t)__p);
    *(_DWORD *)uint64_t buf = 1;
    __p[0] = buf;
    *((_DWORD *)sub_1008567B8(v3 + 160, (int *)buf, (uint64_t)&unk_101D0B290, (_DWORD **)__p) + 6) = 1;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    long long v17 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      int v41 = 1;
      __p[0] = &v41;
      uint64_t v18 = sub_1008567B8(v3 + 160, &v41, (uint64_t)&unk_101D0B290, (_DWORD **)__p);
      sub_10101E8B4((uint64_t)(v18 + 3));
      int v19 = v44 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)uint64_t buf = 136380675;
      *(void *)&uint8_t buf[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#cb, New Location Settings for sim 2,%{private}s", buf, 0xCu);
      if (v44 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v38 = 1;
      *(void *)uint64_t buf = &v38;
      id v32 = sub_1008567B8(v3 + 160, &v38, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      sub_10101E8B4((uint64_t)(v32 + 3));
      if (v40 >= 0) {
        uint64_t v33 = buf;
      }
      else {
        uint64_t v33 = *(unsigned char **)buf;
      }
      int v41 = 136380675;
      uint64_t v42 = v33;
      __int16 v34 = (char *)_os_log_send_and_compose_impl();
      if (v40 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateEmergencySettings(CLNameValuePair)", "%s\n", v34);
      if (v34 != (char *)__p) {
        free(v34);
      }
    }
  }
  *(unsigned char *)(v3 + 69) = 0;
  int v20 = *(uint64_t **)(v3 + 176);
  if (v20)
  {
    int v21 = 0;
    do
    {
      v21 |= *((unsigned char *)v20 + 32) != 0;
      *(unsigned char *)(v3 + 69) = v21 & 1;
      int v20 = (uint64_t *)*v20;
    }
    while (v20);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  unsigned int v22 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v23 = *(unsigned __int8 *)(v3 + 69);
    LODWORD(__p[0]) = 67109120;
    HIDWORD(__p[0]) = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "#EmeregCon,#EmergSettings,#cb,fDelayEmergencyUntilCallConnect,%d", (uint8_t *)__p, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v30 = *(unsigned __int8 *)(v3 + 69);
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v30;
    int v31 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateEmergencySettings(CLNameValuePair)", "%s\n", v31);
    if (v31 != (char *)__p) {
      free(v31);
    }
  }
  *(_DWORD *)uint64_t buf = 0;
  __p[0] = buf;
  long long v24 = sub_1008567B8(v3 + 160, (int *)buf, (uint64_t)&unk_101D0B290, (_DWORD **)__p);
  sub_10102ECD4((uint64_t)v36, v24 + 3);
  sub_101021FF8(v3, 2, v36);
  uint64_t result = sub_10084DD34((uint64_t)v36);
  if (*(unsigned char *)(v3 + 133))
  {
    *(_DWORD *)uint64_t buf = 1;
    __p[0] = buf;
    unsigned int v26 = sub_1008567B8(v3 + 160, (int *)buf, (uint64_t)&unk_101D0B290, (_DWORD **)__p);
    sub_10102ECD4((uint64_t)v35, v26 + 3);
    sub_101021FF8(v3, 2, v35);
    return sub_10084DD34((uint64_t)v35);
  }
  return result;
}

void sub_10101CA10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10084DD34((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10101CA48(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  switch(*a3)
  {
    case 6:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v6 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = *(unsigned int *)(a4 + 4);
        *(_DWORD *)uint64_t buf = 134349056;
        *(void *)int v20 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#EmergCon,onDaemonStatusNotification,kNotificationReachability,[%{public}ld]", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        long long v17 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v17);
        if (v17 != (char *)buf) {
          free(v17);
        }
      }
      uint64_t v8 = *(unsigned int *)(a4 + 4);
      *(_DWORD *)(a1 + 512) = v8;
      sub_10147DD38(*(void *)(a1 + 688), v8);
      break;
    case 7:
      *(_DWORD *)(a1 + 544) = *(_DWORD *)(a4 + 12);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v9 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(_DWORD *)(a4 + 12);
        int v11 = (int)*(double *)a4;
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)int v20 = 0;
        *(_WORD *)&v20[4] = 2082;
        *(void *)&void v20[6] = "";
        __int16 v21 = 1025;
        int v22 = v10;
        __int16 v23 = 1026;
        int v24 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,onDaemonStatusNotification\", \"chargerType\":%{private}d, \"batteryLevel\":%{public}d}", buf, 0x1Eu);
      }
      sub_10147DA8C(*(void *)(a1 + 688), a4);
      break;
    case 8:
      uint64_t v12 = *(uint64_t **)(a1 + 672);
      if (v12)
      {
        uint64_t v13 = *v12;
        if (*v12)
        {
          if (*(unsigned char *)a4) {
            __int16 v14 = (const char *)(v13 + 24);
          }
          else {
            __int16 v14 = (const char *)*v12;
          }
          sub_100F7D63C(v13, v14);
        }
      }
      break;
    case 0xB:
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v15 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        if (*(unsigned char *)a4) {
          long long v16 = "locked";
        }
        else {
          long long v16 = "unlocked";
        }
        *(_DWORD *)uint64_t buf = 136446210;
        *(void *)int v20 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#EmergCon,onDaemonStatusNotification,kNotificationLockScreen,display [%{public}s]", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)", "%s\n", v18);
        if (v18 != (char *)buf) {
          free(v18);
        }
      }
      *(unsigned char *)(a1 + 64sub_100FB8FC8(&a9, 0) = *(unsigned char *)a4;
      break;
    default:
      return;
  }
}

double sub_10101CF24(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 4)
  {
    int v5 = *(_DWORD *)(a4 + 188);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 68289282;
      v8[1] = 0;
      __int16 v9 = 2082;
      int v10 = "";
      __int16 v11 = 1026;
      BOOL v12 = v5 == 1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon Location Services status change\", \"enabled\":%{public}hhd}", (uint8_t *)v8, 0x18u);
    }
    return sub_10147BB7C(*(void *)(a1 + 688), v5 == 1);
  }
  return result;
}

void sub_10101D03C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)uint64_t buf = 68289283;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 1025;
      int v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,onDeviceOrientation,\", \"deviceOrientation\":%{private}d}", buf, 0x18u);
    }
    *(_DWORD *)(a1 + 536) = *(_DWORD *)(a2 + 8);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#warning,#EmergCon,onDeviceOrientation,data nullptr", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::onDeviceOrientation(const CLOrientationNotifier::Sample *)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

void sub_10101D26C(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 1)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)(a4 + 12);
      v8[0] = 68289283;
      v8[1] = 0;
      __int16 v9 = 2082;
      __int16 v10 = "";
      __int16 v11 = 1025;
      int v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,handleAssistanceMotion,\", \"mountState\":%{private}d}", (uint8_t *)v8, 0x18u);
    }
    *(_DWORD *)(a1 + 54sub_100FB8FC8(&a9, 0) = *(_DWORD *)(a4 + 12);
  }
}

CLOSTransaction *sub_10101D378(uint64_t a1)
{
  if (*(void *)(a1 + 664))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "#EmergCon Creating new transaction without releasing previous one", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::createTransaction()", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    sub_10101D660(a1);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v3 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#EmergCon Creating os transaction CLEmergency", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::createTransaction()", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  double result = [[CLOSTransaction alloc] initWithDescription:"CLEmergency"];
  *(void *)(a1 + 664) = result;
  return result;
}

void sub_10101D660(uint64_t a1)
{
  if (*(void *)(a1 + 664))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon Release os transaction CLEmergency", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::releaseTransaction()", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }

    *(void *)(a1 + 664) = 0;
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v3 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#EmergCon Attempt to release transaction that was already released", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::releaseTransaction()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_10101D934(unsigned __int8 *a1, int a2)
{
  if (*a1 == a2)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *a1;
      *(_DWORD *)uint64_t buf = 67109376;
      int v11 = v5;
      __int16 v12 = 1024;
      int v13 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon setCLEEA,Current,%d,New,%d,ignoring", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::setCLEEA(BOOL)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v7 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *a1;
      *(_DWORD *)uint64_t buf = 67109376;
      int v11 = v8;
      __int16 v12 = 1024;
      int v13 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#EmergCon setCLEEA,Current,%d,New,%d", buf, 0xEu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::setCLEEA(BOOL)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    *a1 = a2;
    [objc_msgSend(*((id *)a1 + 1), "vendor") proxyForService:@"CLClientManager"] markClientEmergencyEnablementTransition:*a1];
  }
}

void *sub_10101DC90@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 0xE) {
    uint64_t v2 = "UnknownState";
  }
  else {
    uint64_t v2 = off_10230BFD8[a1];
  }
  return sub_100134750(a2, v2);
}

id sub_10101DCBC(uint64_t a1, int a2)
{
  id result = (id)sub_10010145C();
  if (result)
  {
    id v5 = *(id *)(a1 + 680);
    if (a2)
    {
      if (!v5)
      {
        id v5 = [[[*(id *)(a1 + 8) vendor] proxyForService:@"CLStreamingAwareLocationProvider" forClient:@"CLEmergencyController"];
        *(void *)(a1 + 68sub_100FB8FC8(&a9, 0) = v5;
      }
      uint64_t v6 = CLISP_ME_TOKEN;
      return [v5 takeAccuracyEnablementAssertionForClient:v6 withDesiredAccuracy:-1.0];
    }
    else
    {
      uint64_t v7 = CLISP_ME_TOKEN;
      return [v5 releaseAccuracyEnablementAssertionForClient:v7];
    }
  }
  return result;
}

void sub_10101DD6C()
{
  if (objc_opt_class())
  {
    sub_1000C7F88(buf);
    v5[0] = 0;
    int v0 = sub_1000D2988(*(uint64_t *)buf, "EmergencyUnpickAirPlayRoutesEnabled", v5);
    if (v5[0]) {
      int v1 = 0;
    }
    else {
      int v1 = v0;
    }
    if (v7) {
      sub_1000DB0A0(v7);
    }
    if (v1)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v2 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,unpick AirPlay routes is disabled", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        *(_WORD *)id v5 = 0;
        uint64_t v3 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::unpickAirPlayRoutes()", "%s\n", v3);
        if (v3 != (char *)buf) {
          free(v3);
        }
      }
    }
    else
    {
      global_queue = dispatch_get_global_queue(0, 0);
      dispatch_async(global_queue, &stru_10230B5F8);
    }
  }
}

void sub_10101DF5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10101DF7C(id a1)
{
  uint64_t v5 = 0;
  id v1 = +[AVSystemController sharedAVSystemController];
  if ([v1 setAttribute:&__kCFBooleanTrue forKey:AVSystemController_RouteAwayFromAirPlayAttribute error:&v5])
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,successfully unpicked AirPlay routes", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LOWORD(v6) = 0;
      uint64_t v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::unpickAirPlayRoutes()_block_invoke", "%s\n");
LABEL_19:
      if (v3 != buf) {
        free(v3);
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v4 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 138543362;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#EmergCon,error unpicking AirPlay routes,%{public}@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v6 = 138543362;
      uint64_t v7 = v5;
      uint64_t v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::unpickAirPlayRoutes()_block_invoke", "%s\n");
      goto LABEL_19;
    }
  }
}

id sub_10101E264(uint64_t a1)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,EnterEmergency", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    *(_WORD *)int v20 = 0;
    __int16 v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enterEmergency()", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v3 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 0;
    *(void *)uint64_t buf = &v22;
    uint64_t v4 = sub_1008567B8(a1 + 160, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    sub_10101E8B4((uint64_t)(v4 + 3));
    uint64_t v5 = v28 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)int v20 = 136380675;
    *(void *)&v20[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#EmgContext,repeating current settings for sim 1,%{private}s", v20, 0xCu);
    if (SHIBYTE(v28) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v19 = 0;
    *(void *)int v20 = &v19;
    int v13 = sub_1008567B8(a1 + 160, &v19, (uint64_t)&unk_101D0B290, (_DWORD **)v20);
    sub_10101E8B4((uint64_t)(v13 + 3));
    if (v21 >= 0) {
      __int16 v14 = v20;
    }
    else {
      __int16 v14 = *(unsigned char **)v20;
    }
    int v22 = 136380675;
    __int16 v23 = v14;
    int v15 = (char *)_os_log_send_and_compose_impl();
    if (v21 < 0) {
      operator delete(*(void **)v20);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enterEmergency()", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  if (*(unsigned char *)(a1 + 133))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = 1;
      *(void *)uint64_t buf = &v22;
      uint64_t v7 = sub_1008567B8(a1 + 160, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
      sub_10101E8B4((uint64_t)(v7 + 3));
      int v8 = v28 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)int v20 = 136380675;
      *(void *)&v20[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmgContext,repeating current settings for sim 2,%{private}s", v20, 0xCu);
      if (SHIBYTE(v28) < 0) {
        operator delete(*(void **)buf);
      }
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v19 = 1;
      *(void *)int v20 = &v19;
      long long v16 = sub_1008567B8(a1 + 160, &v19, (uint64_t)&unk_101D0B290, (_DWORD **)v20);
      sub_10101E8B4((uint64_t)(v16 + 3));
      if (v21 >= 0) {
        long long v17 = v20;
      }
      else {
        long long v17 = *(unsigned char **)v20;
      }
      int v22 = 136380675;
      __int16 v23 = v17;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      if (v21 < 0) {
        operator delete(*(void **)v20);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::enterEmergency()", "%s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v9 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v25 = 2082;
    unsigned int v26 = "";
    __int16 v27 = 1026;
    int v28 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmgContext\", \"CleeaAsserted\":%{public}d}", buf, 0x18u);
  }
  sub_10101D378(a1);
  sub_10101DCBC(a1, 1);
  sub_10101B250(a1, 1);
  sub_10101DD6C();
  return [*(id *)(a1 + 40) setE911Active:1];
}

uint64_t sub_10101E8B4(uint64_t a1)
{
  sub_10010F274((uint64_t)v26);
  sub_100132EFC(v27, (uint64_t)"ins,", 4);
  uint64_t v2 = (void *)std::ostream::operator<<();
  uint64_t v3 = sub_100132EFC(v2, (uint64_t)",Location", 9);
  sub_100132EFC(v3, (uint64_t)",enableCpiDuringEmergencyMode,", 30);
  uint64_t v4 = (void *)std::ostream::operator<<();
  sub_100132EFC(v4, (uint64_t)",enableEarlyReturnDuringEmergencyMode,", 38);
  uint64_t v5 = (void *)std::ostream::operator<<();
  sub_100132EFC(v5, (uint64_t)",allowOTDOADuringEmergencyMode,", 31);
  int v6 = (void *)std::ostream::operator<<();
  uint64_t v7 = sub_100132EFC(v6, (uint64_t)",EmergencyLocation,", 19);
  sub_10102F5C4((int *)(a1 + 16));
  if ((v25 & 0x80u) == 0) {
    int v8 = v24;
  }
  else {
    int v8 = (void **)v24[0];
  }
  if ((v25 & 0x80u) == 0) {
    uint64_t v9 = v25;
  }
  else {
    uint64_t v9 = (uint64_t)v24[1];
  }
  int v10 = sub_100132EFC(v7, (uint64_t)v8, v9);
  int v11 = sub_100132EFC(v10, (uint64_t)",SUPL,", 6);
  sub_10102F904(a1 + 944);
  if ((v23 & 0x80u) == 0) {
    __int16 v12 = v22;
  }
  else {
    __int16 v12 = (void **)v22[0];
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v13 = v23;
  }
  else {
    uint64_t v13 = (uint64_t)v22[1];
  }
  __int16 v14 = sub_100132EFC(v11, (uint64_t)v12, v13);
  int v15 = sub_100132EFC(v14, (uint64_t)",BAA,", 5);
  sub_101026000();
  if ((v21 & 0x80u) == 0) {
    long long v16 = __p;
  }
  else {
    long long v16 = (void **)__p[0];
  }
  if ((v21 & 0x80u) == 0) {
    uint64_t v17 = v21;
  }
  else {
    uint64_t v17 = (uint64_t)__p[1];
  }
  sub_100132EFC(v15, (uint64_t)v16, v17);
  if ((char)v21 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v23 < 0) {
    operator delete(v22[0]);
  }
  if ((char)v25 < 0) {
    operator delete(v24[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v26
  v27[0] = v18;
  if (v28 < 0) {
    operator delete((void *)v27[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10101EB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_101A129A8((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_10101EBF4(uint64_t a1)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,ExitEmergency", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::exitEmergency()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  [*(id *)(a1 + 40) setE911Active:0];
  *(unsigned char *)(a1 + 68) = 0;
  sub_10101B250(a1, 0);
  if (sub_10010145C()) {
    [*(id *)(a1 + 680) releaseAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN];
  }
  sub_10101D660(a1);
}

void sub_10101EDC8(uint64_t a1)
{
  if (*(void *)(a1 + 152))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v1 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#EmergCon,createLongEemTimeout,timer already exists", (uint8_t *)buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LOWORD(v15) = 0;
      uint64_t v2 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::createLongEemTimeout()", "%s\n", v2);
LABEL_27:
      if (v2 != (char *)buf) {
        free(v2);
      }
    }
  }
  else
  {
    if (*(double *)(a1 + 256) == 0.0)
    {
      *(_DWORD *)(a1 + 264) = 0;
    }
    else
    {
      unsigned int v4 = vcvtpd_u64_f64(sub_10016C458() - *(double *)(a1 + 256));
      *(_DWORD *)(a1 + 264) = v4;
      LODWORD(buf[0]) = 32;
      DWORD2(buf[0]) = v4;
      int v13 = 3;
      uint64_t v16 = 0;
      long long v15 = 0uLL;
      v10[3] = (uint64_t)&v15;
      char v11 = 0;
      *(void *)&long long v15 = operator new(0x28uLL);
      *((void *)&v15 + 1) = v15;
      uint64_t v16 = v15 + 40;
      *((void *)&v15 + 1) = sub_100682A48((uint64_t)&v16, (uint64_t)buf, (uint64_t)&v14, v15);
      sub_100118010((uint64_t)buf + 8);
      uint64_t v5 = *(void **)(a1 + 712);
      memset(v10, 0, 24);
      sub_100682C20(v10, v15, *((uint64_t *)&v15 + 1), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v15 + 1) - v15) >> 3));
      [v5 setMeasurements:sub_10067C03C(v10)];
      *(void *)&buf[0] = v10;
      sub_100682B1C((void ***)buf);
      *(void *)&buf[0] = &v15;
      sub_100682B1C((void ***)buf);
    }
    id v6 = [objc_msgSend(*(id *)(a1 + 8), "silo") newTimer];
    *(void *)(a1 + 152) = v6;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_101020E9C;
    void v9[3] = &unk_1022A3020;
    v9[4] = a1;
    [v6 setHandler:v9];
    sub_1000C7F88(buf);
    *(void *)&long long v15 = 0;
    if (sub_1000A699C(*(uint64_t *)&buf[0], "EEMTimeout", &v15)) {
      double v7 = *(double *)&v15;
    }
    else {
      double v7 = 420.0;
    }
    if (*((void *)&buf[0] + 1)) {
      sub_1000DB0A0(*((std::__shared_weak_count **)&buf[0] + 1));
    }
    [*(id *)(a1 + 152) setNextFireDelay:v7];
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 134349056;
      *(double *)((char *)buf + 4) = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#EmergCon,createLongEemTimeout,started timer for %{public}f", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LODWORD(v15) = 134349056;
      *(double *)((char *)&v15 + 4) = v7;
      uint64_t v2 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::createLongEemTimeout()", "%s\n", v2);
      goto LABEL_27;
    }
  }
}

void sub_10101F248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21)
{
  a21 = (void **)(v21 - 96);
  sub_100682B1C(&a21);
  _Unwind_Resume(a1);
}

id *sub_10101F2B8(id *result)
{
  if (!*((unsigned char *)result + 144))
  {
    id v1 = result;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      uint64_t v5 = 0x4034000000000000;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon setting call connect timeout for %{public}f s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::initCallConnectTimeout()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
    id result = (id *)[v1[17] setNextFireDelay:20.0];
    *((unsigned char *)v1 + 144) = 1;
  }
  return result;
}

void sub_10101F488(uint64_t a1, _DWORD *a2)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  unsigned int v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100D335B8(a2, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(void *)uint64_t buf = 68289282;
    *(_WORD *)uint64_t v17 = 2082;
    *(void *)&_DWORD v17[2] = "";
    __int16 v18 = 2082;
    int v19 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon logCommType\", \"Emergency: StringifiedState\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (!sub_100D33CD4((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)uint64_t v17 = 0;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100682A48((uint64_t)&__p.__r_.__value_.__r.__words[2], (uint64_t)buf, (uint64_t)&v21, (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_100118010((uint64_t)v17);
    int v8 = *(void **)(a1 + 712);
    memset(v12, 0, sizeof(v12));
    sub_100682C20(v12, (uint64_t)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v8 setMeasurements:sub_10067C03C(v12)];
    double v7 = v12;
    goto LABEL_13;
  }
  if (sub_100D33CB4((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)uint64_t v17 = 1;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100682A48((uint64_t)&__p.__r_.__value_.__r.__words[2], (uint64_t)buf, (uint64_t)&v21, (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_100118010((uint64_t)v17);
    id v6 = *(void **)(a1 + 712);
    memset(v11, 0, sizeof(v11));
    sub_100682C20(v11, (uint64_t)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v6 setMeasurements:sub_10067C03C(v11)];
    double v7 = v11;
LABEL_13:
    *(void *)uint64_t buf = v7;
    sub_100682B1C((void ***)buf);
    *(void *)uint64_t buf = &__p;
    sub_100682B1C((void ***)buf);
    return;
  }
  if (sub_100D33CC4((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)uint64_t v17 = 2;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100682A48((uint64_t)&__p.__r_.__value_.__r.__words[2], (uint64_t)buf, (uint64_t)&v21, (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_100118010((uint64_t)v17);
    uint64_t v9 = *(void **)(a1 + 712);
    memset(v10, 0, sizeof(v10));
    sub_100682C20(v10, (uint64_t)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v9 setMeasurements:sub_10067C03C(v10)];
    double v7 = v10;
    goto LABEL_13;
  }
}

void sub_10101F804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  *(void *)(v18 - 96) = &a18;
  sub_100682B1C((void ***)(v18 - 96));
  _Unwind_Resume(a1);
}

void sub_10101F880(uint64_t a1, unsigned int a2)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  unsigned int v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    unsigned int v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon,updateCleeaEmergencyState,state,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateCleeaEmergencyState(EmergencyState)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  int v5 = *(_DWORD *)(a1 + 60);
  if (v5 != 5 && v5)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmergCon,skipping updateEmergencyState, do not clear telephony determined emergency state", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateCleeaEmergencyState(EmergencyState)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  else
  {
    sub_101020A5C(a1, a2);
  }
}

id sub_10101FB80(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 56sub_100FB8FC8(&a9, 0) = CFAbsoluteTimeGetCurrent();
  if (objc_opt_class() && *(_DWORD *)(*(void *)(a1 + 528) + 244) == 5 && *(void *)(a1 + 688) == 1)
  {
    *(unsigned char *)(a1 + 432) = 1;
    double v2 = sub_10016C458();
    double v3 = *(double *)(*(void *)(a1 + 528) + 256);
    BOOL v4 = v2 < v3 || v3 == 0.0;
    unsigned int v5 = vcvtpd_s64_f64(v2 - v3);
    if (v4) {
      unsigned int v5 = -1;
    }
    *(_DWORD *)(a1 + 428) = v5;
  }
  unsigned int v6 = *(unsigned __int8 *)(a1 + 33);
  if (*(unsigned char *)(a1 + 33)) {
    unsigned int v6 = vcvtpd_s64_f64(sub_10016C458() - *(double *)(a1 + 552));
  }
  *(_DWORD *)(a1 + 36) = v6;
  sub_1000C7F88(buf);
  *(void *)unsigned __int8 v23 = 0;
  if (sub_1000A699C(*(uint64_t *)buf, "EmergencyPreCallMotionActivityInterval", v23)) {
    double v7 = *(double *)v23;
  }
  else {
    double v7 = 1800.0;
  }
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  int v8 = +[NSDate dateWithTimeIntervalSinceReferenceDate:*(double *)(a1 + 544) - v7];
  uint64_t v9 = +[NSDate dateWithTimeIntervalSinceReferenceDate:*(double *)(a1 + 560)];
  id v10 = objc_alloc_init((Class)NSDateFormatter);
  [v10 setLocale:[objc_alloc((Class)NSLocale) initWithLocaleIdentifier:@"en_US_POSIX"]];
  [v10 setTimeZone:+[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone")];
  [v10 setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
  id v11 = [v10 stringFromDate:v8];
  id v12 = [v10 stringFromDate:v9];
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  int v13 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    id v14 = [v11 UTF8String];
    id v15 = [v12 UTF8String];
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#EmergCon,initiateCallTriggerMetric,Request motion activity from,%{public}s,toDate,%{public}s", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    id v19 = [v11 UTF8String];
    id v20 = [v12 UTF8String];
    *(_DWORD *)unsigned __int8 v23 = 136446466;
    *(void *)&void v23[4] = v19;
    __int16 v24 = 2082;
    id v25 = v20;
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::initiateCallTriggerMetric()", "%s\n", v21);
    if (v21 != buf) {
      free(v21);
    }
  }
  id v16 = objc_alloc_init((Class)CMMotionActivityManager);
  *(void *)(a1 + 536) = v16;
  id v17 = [objc_msgSend(*(id *)(*(void *)(a1 + 528) + 8), "silo") operationQueue];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  _DWORD v22[2] = sub_10102C734;
  v22[3] = &unk_10230B620;
  v22[5] = v12;
  v22[6] = a1;
  v22[4] = v11;
  return [v16 queryActivityStartingFromDate:v8 toDate:v9 toQueue:v17 withHandler:v22];
}

void sub_10101FF7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    sub_1000DB0A0(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10101FF9C(uint64_t a1)
{
  if (*(void *)(a1 + 584))
  {
    id v1 = (uint64_t *)(a1 + 584);
    sub_101020170(v1, 0);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#ADR,cleanupEmergencyCallTriggersMetric,fEmergencyCallTriggerMetric is nil", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      double v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::cleanupEmergencyCallTriggersMetric()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
}

uint64_t sub_101020170(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_10102C5C8(result);
    operator delete();
  }
  return result;
}

void sub_1010201C0(int64x2_t *a1, double a2)
{
  double v18 = a2;
  uint64_t i64 = (uint64_t)a1[37].i64;
  sub_10017CCF0((int64x2_t *)a1[37].i64, &v18);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  BOOL v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = a1[39].i64[1];
    LODWORD(buf[0]) = 67240192;
    DWORD1(buf[0]) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#EmergCon,addEmergencyCallToHistory,Q size after addition %{public}d", (uint8_t *)buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v14 = a1[39].i64[1];
    LODWORD(v19[0]) = 67240192;
    HIDWORD(v19[0]) = v14;
    id v15 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::addEmergencyCallToHistory(CFAbsoluteTime)", "%s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  sub_1000C7F88(buf);
  v19[0] = 0.0;
  if (sub_1000A699C(*(uint64_t *)&buf[0], "EmergencyCallHistoryInterval", v19)) {
    double v6 = v19[0];
  }
  else {
    double v6 = 86400.0;
  }
  if (*((void *)&buf[0] + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&buf[0] + 1));
  }
  if (a1[39].i64[1])
  {
    double v7 = v18 - v6;
    do
    {
      if (*(double *)(*(void *)(a1[37].i64[1] + (((unint64_t)a1[39].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * (a1[39].i64[0] & 0x1FF)) >= v7)
        break;
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v8 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = *(void *)(*(void *)(a1[37].i64[1] + (((unint64_t)a1[39].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                       + 8 * (a1[39].i64[0] & 0x1FF));
        LODWORD(buf[0]) = 134349056;
        *(void *)((char *)buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#EmergCon,addEmergencyCallToHistory,element being deleted %{public}f", (uint8_t *)buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v10 = *(void *)(*(void *)(a1[37].i64[1] + (((unint64_t)a1[39].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                        + 8 * (a1[39].i64[0] & 0x1FF));
        LODWORD(v19[0]) = 134349056;
        *(void *)((char *)v19 + 4) = v10;
        id v11 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::addEmergencyCallToHistory(CFAbsoluteTime)", "%s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
      a1[39] = vaddq_s64(a1[39], (int64x2_t)xmmword_101D0A740);
      sub_10007F07C(i64, 1);
    }
    while (a1[39].i64[1]);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  id v12 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v13 = a1[39].i64[1];
    LODWORD(buf[0]) = 67240192;
    DWORD1(buf[0]) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#EmergCon,addEmergencyCallToHistory,Q size after cleanup %{public}d", (uint8_t *)buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v16 = a1[39].i64[1];
    LODWORD(v19[0]) = 67240192;
    HIDWORD(v19[0]) = v16;
    id v17 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::addEmergencyCallToHistory(CFAbsoluteTime)", "%s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
}

void sub_101020718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_1000DB0A0(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_101020738(uint64_t a1)
{
  if (objc_opt_class())
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v2 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#EmergCon,interactiveStateChanged", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v7 = 0;
      BOOL v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::interactiveStateChanged()", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10102E58C;
    block[3] = &unk_1022A3020;
    block[4] = a1;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v3 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#EmergCon,interactiveStateChanged, SOS not supported. Early return", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v7 = 0;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::interactiveStateChanged()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_101020A5C(uint64_t a1, unsigned int a2)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  BOOL v4 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = *(_DWORD *)(a1 + 48);
    sub_101020E74(v5, &v28);
    if (v32 >= 0) {
      double v6 = &v28;
    }
    else {
      double v6 = v28;
    }
    int v7 = *(_DWORD *)(a1 + 48);
    sub_101020E74(*(_DWORD *)(a1 + 52), v26);
    int v8 = v27;
    uint64_t v9 = (void **)v26[0];
    int v10 = *(unsigned __int8 *)(a1 + 56);
    sub_10101DC90(a2, __p);
    id v11 = v26;
    if (v8 < 0) {
      id v11 = v9;
    }
    if (v25 >= 0) {
      id v12 = __p;
    }
    else {
      id v12 = (void **)__p[0];
    }
    *(_DWORD *)uint64_t buf = 67110402;
    unsigned int v40 = v5;
    __int16 v41 = 2080;
    uint64_t v42 = v6;
    __int16 v43 = 1024;
    int v44 = v7;
    __int16 v45 = 2080;
    uint64_t v46 = v11;
    __int16 v47 = 1024;
    int v48 = v10;
    __int16 v49 = 2080;
    uint64_t v50 = v12;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#EmergCon updateEmergencyState,fS1ModeFromCT,%d,%s,fS2ModeFromCT,%d,%s,fIsCleeaAsserted,%d,state,%s", buf, 0x32u);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    if (v27 < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(v28);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unsigned int v13 = *(_DWORD *)(a1 + 48);
    uint64_t v14 = v26;
    sub_101020E74(v13, v26);
    if (v27 < 0) {
      uint64_t v14 = (void **)v26[0];
    }
    int v15 = *(_DWORD *)(a1 + 48);
    sub_101020E74(*(_DWORD *)(a1 + 52), __p);
    int v16 = v25;
    id v17 = (void **)__p[0];
    int v18 = *(unsigned __int8 *)(a1 + 56);
    sub_10101DC90(a2, v22);
    id v19 = __p;
    if (v16 < 0) {
      id v19 = v17;
    }
    if (v23 >= 0) {
      id v20 = v22;
    }
    else {
      id v20 = (void **)v22[0];
    }
    LODWORD(v28) = 67110402;
    HIDWORD(v28) = v13;
    __int16 v29 = 2080;
    int v30 = v14;
    __int16 v31 = 1024;
    int v32 = v15;
    __int16 v33 = 2080;
    __int16 v34 = v19;
    __int16 v35 = 1024;
    int v36 = v18;
    __int16 v37 = 2080;
    int v38 = v20;
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();
    if (v23 < 0) {
      operator delete(v22[0]);
    }
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    if (v27 < 0) {
      operator delete(v26[0]);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::updateEmergencyState(EmergencyState)", "%s\n", v21);
    if (v21 != (char *)buf) {
      free(v21);
    }
  }
  if (!a2)
  {
    if (*(unsigned char *)(a1 + 56)) {
      a2 = 5;
    }
    else {
      a2 = 0;
    }
    goto LABEL_27;
  }
  if (a2 != 5)
  {
LABEL_27:
    sub_101019354(a1, a2);
    return;
  }
  if (!*(_DWORD *)(a1 + 60) && !*(_DWORD *)(a1 + 64))
  {
    a2 = 5;
    goto LABEL_27;
  }
}

void sub_101020E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void *sub_101020E74@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 5) {
    double v2 = "UnknownMode";
  }
  else {
    double v2 = off_10230C050[a1];
  }
  return sub_100134750(a2, v2);
}

void sub_101020E9C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  double v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "#EmergCon,longEemTimeout,longer than expected EEM detected", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::createLongEemTimeout()_block_invoke", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  sub_10101A314(v1);
  sub_101021040(v1);
}

void sub_101021040(uint64_t a1)
{
  uint64_t v2 = sub_1006D40B0((unsigned int *)(a1 + 72));
  int v18 = v2;
  *(unsigned char *)(a1 + 132) = 1;
  *(unsigned char *)(a1 + 92) = 0;
  *(void *)(a1 + 96) = 0x400000000;
  *(_WORD *)(a1 + 104) = 256;
  *(unsigned char *)(a1 + 106) = 0;
  *(_DWORD *)(a1 + 108) = 255;
  sub_101019704(a1);
  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  [v3 setValue:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v2)] forKey:@"simSlot"];
  [v3 setValue:@"Voice" forKey:@"communicationType"];
  int v4 = sub_10101AE34(*(unsigned int *)(a1 + 244));
  sub_10101A768(v4, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v3 setValue:[NSString stringWithUTF8String:p_p] forKey:@"callTriggerType"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  [v3 setValue:[NSNumber numberWithUnsignedInt:*((unsigned int *)(a1 + 264))] forKey:@"callDuration"];
  sub_10055E278(a1 + 92, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    double v6 = &__p;
  }
  else {
    double v6 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v3 setValue:[NSString stringWithUTF8String:v6] forKey:@"emergencyModeRat"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  id v19 = &v18;
  int v7 = sub_1000F3C48(a1 + 272, &v18, (uint64_t)&unk_101D0B290, &v19);
  sub_1001170C0(*((_DWORD *)v7 + 5), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v8 = &__p;
  }
  else {
    int v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v3 setValue:[NSString stringWithUTF8String:v8] forKey:@"ratType"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  LODWORD(v19) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
  uint64_t v9 = sub_1000F3C48(a1 + 352, (int *)&v19, (uint64_t)&unk_101D0B290, &__p);
  [v3 setValue:sub_101021560(*((unsigned int *)v9 + 5)) forKey:@"simCountry1"];
  sub_1010215D4(a1, 0, 0, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v10 = &__p;
  }
  else {
    int v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v3 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10) forKey:@"simBundleId1"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  LODWORD(v19) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
  id v11 = sub_1000F3C48(a1 + 432, (int *)&v19, (uint64_t)&unk_101D0B290, &__p);
  [v3 setValue:sub_101021560(*((unsigned int *)v11 + 5)) forKey:@"operatorCountry1"];
  sub_1010215D4(a1, 0, 1, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v12 = &__p;
  }
  else {
    id v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v3 setValue:[NSString stringWithUTF8String:v12] forKey:@"operatorBundleId1"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*(unsigned char *)(a1 + 133))
  {
    LODWORD(v19) = 1;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
    unsigned int v13 = sub_1000F3C48(a1 + 352, (int *)&v19, (uint64_t)&unk_101D0B290, &__p);
    [v3 setValue:sub_101021560(*((unsigned int *)v13 + 5)) forKey:@"simCountry2"];
    sub_1010215D4(a1, 1, 0, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v14 = &__p;
    }
    else {
      uint64_t v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    [v3 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14) forKey:@"simBundleId2"];
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    LODWORD(v19) = 1;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
    int v15 = sub_1000F3C48(a1 + 432, (int *)&v19, (uint64_t)&unk_101D0B290, &__p);
    [v3 setValue:sub_101021560(*((unsigned int *)v15 + 5)) forKey:@"operatorCountry2"];
    sub_1010215D4(a1, 1, 1, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v16 = &__p;
    }
    else {
      int v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    [v3 setValue:[NSString stringWithUTF8String:v16] forKey:@"operatorBundleId2"];
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  AnalyticsSendEvent();

  if ((sub_10016CCBC() & 1) != 0 || sub_10010145C() && sub_100737E78()) {
    sub_10187A1C8([objc_msgSend(*(id *)(a1 + 8), "silo") queue], @"Emergency", @"long_EEM", 1);
  }
}

void sub_10102152C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NSString *sub_101021560(uint64_t a1)
{
  if ((a1 - 1) > 0x3E6)
  {
    CFStringRef v3 = @"InvalidMCC:%d";
  }
  else
  {
    [+[NSNumber numberWithInt:a1] stringValue];
    uint64_t result = (NSString *)TUISOCountryCodeForMCC();
    if (result) {
      return result;
    }
    CFStringRef v3 = @"InvalidCountryCodeForMCC:%d";
  }
  return +[NSString stringWithFormat:](NSString, "stringWithFormat:", v3, a1);
}

void sub_1010215D4(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, std::string *a4@<X8>)
{
  int v10 = a2;
  memset(&v9, 0, sizeof(v9));
  if (a3 == 1)
  {
    *(void *)uint64_t buf = &v10;
    unsigned int v5 = (const std::string *)(sub_1008567B8(a1 + 160, &v10, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 167);
    goto LABEL_5;
  }
  if (!a3)
  {
    *(void *)uint64_t buf = &v10;
    unsigned int v5 = (const std::string *)(sub_1008567B8(a1 + 160, &v10, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 161);
LABEL_5:
    std::string::operator=(&v9, v5);
    goto LABEL_11;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  double v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#EmergCon,getBundleId,unexpected bundle type", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "std::string CLEmergencyController::getBundleId(SimInstance, BundleType)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
LABEL_11:
  std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v9.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    *a4 = v9;
  }
  else
  {
    sub_100134750(a4, "Unavailable");
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v9.__r_.__value_.__l.__data_);
    }
  }
}

void sub_10102182C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102184C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 1) == a2)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    CFStringRef v3 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 1)) {
        int v4 = "locked";
      }
      else {
        int v4 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136446210;
      uint64_t v14 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#EmergCon NILR already %{public}s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::sendObserversNilrLockoutStatus(BOOL)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 1) = a2;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 1)) {
        int v7 = "locked";
      }
      else {
        int v7 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136446210;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmergCon NILR %{public}s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      id v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::sendObserversNilrLockoutStatus(BOOL)", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
    int v8 = *(void **)(a1 + 16);
    if (v8 != (void *)(a1 + 24))
    {
      do
      {
        [(id)v8[4] shouldLockoutNilr:*(unsigned __int8 *)(a1 + 1)];
        std::string v9 = (void *)v8[1];
        if (v9)
        {
          do
          {
            int v10 = v9;
            std::string v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            int v10 = (void *)v8[2];
            BOOL v11 = *v10 == (void)v8;
            int v8 = v10;
          }
          while (!v11);
        }
        int v8 = v10;
      }
      while (v10 != (void *)(a1 + 24));
    }
  }
}

uint64_t sub_101021C14@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 255;
  *(_DWORD *)(a4 + 4) = 257;
  int v8 = (_OWORD *)(a4 + 1012);
  *(unsigned char *)(a4 + 8) = 0;
  *(_OWORD *)(a4 + 16) = xmmword_101D47C60;
  *(_DWORD *)(a4 + 32) = 1;
  *(void *)(a4 + 44) = 0;
  *(void *)(a4 + 36) = 0;
  *(void *)(a4 + 49) = 0;
  *(_OWORD *)(a4 + 6sub_100FB8FC8(&a9, 0) = xmmword_101D9D210;
  *(void *)(a4 + 76) = 0x100000001;
  *(void *)(a4 + 92) = 0;
  *(void *)(a4 + 84) = 0;
  *(void *)(a4 + 112) = 0x401C000000000000;
  *(void *)(a4 + 97) = 0;
  sub_10084DB0C(a4 + 120);
  *(_OWORD *)(a4 + 96sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a4 + 976) = 0u;
  *(_OWORD *)(a4 + 944) = 0u;
  *(_WORD *)(a4 + 992) = 7275;
  *(void *)(a4 + 996) = 0;
  *(_WORD *)(a4 + 1008) = 256;
  *int v8 = xmmword_101D47C90;
  *(void *)(a4 + 1028) = 0x93A80018B8200;
  *(_WORD *)(a4 + 1036) = 256;
  *(_OWORD *)(a4 + 104sub_100FB8FC8(&a9, 0) = xmmword_101D47C90;
  *(void *)(a4 + 1056) = 0x93A80018B8200;
  *(unsigned char *)(a4 + 1064) = 0;
  *(void *)(a4 + 1072) = 0;
  *(void *)(a4 + 1088) = 0;
  *(void *)(a4 + 108sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)((char *)v8 + 84) = xmmword_101D47CA0;
  *(void *)(a4 + 1112) = 0xE1000015180;
  *(_DWORD *)(a4 + 112sub_100FB8FC8(&a9, 0) = 5184000;
  *(void *)(a4 + 1168) = 0;
  *(void *)(a4 + 116sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a4 + 1176) = 0;
  *(void *)(a4 + 1144) = 0;
  *(void *)(a4 + 1128) = 0;
  *(void *)(a4 + 1136) = 0;
  *(unsigned char *)(a4 + 1152) = 0;
  *(_OWORD *)(a4 + 1184) = xmmword_101D47CA0;
  *(void *)(a4 + 120sub_100FB8FC8(&a9, 0) = 0xE1000015180;
  *(_DWORD *)(a4 + 1208) = 5184000;
  *(_OWORD *)(a4 + 1216) = 0u;
  *(_OWORD *)(a4 + 1232) = 0u;
  *(_OWORD *)(a4 + 1248) = 0u;
  *(_OWORD *)(a4 + 1264) = 0u;
  *(_OWORD *)(a4 + 128sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a4 + 1296) = 0u;
  *(_OWORD *)(a4 + 1312) = 0u;
  *(void *)(a4 + 1328) = 0;
  sub_1000E9354(v17);
  sub_1000C7F88(buf);
  BOOL v9 = sub_100012960(*(uint64_t *)buf, "CarrierBundleLocationSettings", v17);
  if (v19) {
    sub_1000DB0A0(v19);
  }
  if (v9)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v10 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#EmergCon #Warning overriding CB Location key settings", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v16 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "CLEmergencyController::LocationSettings CLEmergencyController::getLocationSettings(const BundleInfo &, const BundleInfo &)", "%s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
    BOOL v11 = v17;
    id v12 = v17;
    unsigned int v13 = v17;
  }
  else
  {
    BOOL v11 = (void *)(a2 + 72);
    id v12 = (void *)(a3 + 72);
    unsigned int v13 = (void *)(a2 + 120);
  }
  uint64_t v14 = sub_101022288(a1, (uint64_t)v11, (uint64_t)v12, (uint64_t)v13, a4);
  *(unsigned char *)(a4 + 7) = sub_101023AD4(v14, a2 + 96, a3 + 96, a4 + 944);
  std::string::operator=((std::string *)(a4 + 1240), (const std::string *)(a2 + 40));
  std::string::operator=((std::string *)(a4 + 1264), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a4 + 1288), (const std::string *)(a3 + 40));
  std::string::operator=((std::string *)(a4 + 1312), (const std::string *)(a3 + 8));
  return sub_10013F3C4(v17);
}

void sub_101021FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10013F3C4(va);
  sub_10084DD34(v5);
  _Unwind_Resume(a1);
}

void sub_101021FF8(uint64_t a1, uint64_t a2, int *a3)
{
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  double v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *a3;
    *(_DWORD *)uint64_t buf = 67109376;
    int v21 = v7;
    __int16 v22 = 1024;
    int v23 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "inst,%d,#EmergCon,#EmergSettings,#cb, sendObserversEmergencySettings,reason,%d", buf, 0xEu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v13 = *a3;
    int v16 = 67109376;
    int v17 = v13;
    __int16 v18 = 1024;
    int v19 = a2;
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::sendObserversEmergencySettings(SettingsChangedReason, LocationSettings)", "%s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
  sub_10147ABEC(*(void *)(a1 + 688), a3, a2);
  int v8 = *(void **)(a1 + 16);
  if (v8 != (void *)(a1 + 24))
  {
    do
    {
      BOOL v9 = (void *)v8[4];
      sub_10102ECD4((uint64_t)v15, (uint64_t *)a3);
      [v9 emergencySettingsChange:sub_10101B1A0(v15) withReason:a2];
      sub_10084DD34((uint64_t)v15);
      int v10 = (void *)v8[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v8[2];
          BOOL v12 = *v11 == (void)v8;
          int v8 = v11;
        }
        while (!v12);
      }
      int v8 = v11;
    }
    while (v11 != (void *)(a1 + 24));
  }
  sub_101025958(a1, a3);
}

void sub_10102226C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t sub_101022288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a3;
  if ((sub_10015F760() & 1) == 0)
  {
    *(unsigned char *)(a5 + 4) = 0;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v13 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings HELO not supported in this platform", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1)
    {
LABEL_215:
      *(_WORD *)__int16 v86 = 0;
      BOOL v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v12);
LABEL_216:
      if (v12 != buf) {
        free(v12);
      }
      goto LABEL_24;
    }
LABEL_222:
    dispatch_once(&qword_1024193E0, &stru_10230B640);
    goto LABEL_215;
  }
  sub_100103240();
  char v9 = sub_10016CCBC();
  int v10 = (BOOL *)(a5 + 4);
  if ((v9 & 1) == 0)
  {
    *int v10 = 1;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v14 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings HELO force enabled because this isn't an iPhone", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_215;
    }
    goto LABEL_222;
  }
  if ((sub_1000D2988(a4, "EnableCPIDuringEmergencyMode", v10) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    BOOL v11 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,No e911 CPI flags found, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      BOOL v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v12);
      uint64_t v7 = a3;
      goto LABEL_216;
    }
  }
LABEL_24:
  sub_100103240();
  int v15 = sub_10010145C();
  int v16 = (BOOL *)(a5 + 5);
  if (v15)
  {
    *int v16 = 1;
  }
  else if ((sub_1000D2988(a2, "EnableEarlyReturnDuringEmergencyMode", v16) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v17 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,No early return flag found, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      int v75 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v75);
      if (v75 != buf) {
        free(v75);
      }
    }
  }
  if ((sub_1000D2988(a2, "AllowOTDOADuringEmergencyMode", (BOOL *)(a5 + 6)) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    __int16 v18 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No OTDOA flags found. Assuming default: OTDOA not supported", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      __int16 v67 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v67);
      if (v67 != buf) {
        free(v67);
      }
    }
  }
  if ((sub_1000D2988(v7, "DelayEmergencyUntilCallConnects", (BOOL *)(a5 + 8)) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v19 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No emergency mode delay flag found. Assuming default: not enabled", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      int v68 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v68);
      if (v68 != buf) {
        free(v68);
      }
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  id v20 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *(unsigned __int8 *)(a5 + 4);
    int v22 = *(unsigned __int8 *)(a5 + 5);
    int v23 = *(unsigned __int8 *)(a5 + 6);
    int v24 = *(unsigned __int8 *)(a5 + 8);
    *(_DWORD *)uint64_t buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v21;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v22;
    __int16 v90 = 1024;
    int v91 = v23;
    __int16 v92 = 1024;
    int v93 = v24;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings enableE911CPI,%d,enableEarlyReturn,%d,allowOTDOADuringEmergencyMode,%d,delayEmergencyUntilCallConnect,%d", buf, 0x1Au);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v48 = *(unsigned __int8 *)(a5 + 4);
    int v49 = *(unsigned __int8 *)(a5 + 5);
    int v50 = *(unsigned __int8 *)(a5 + 6);
    int v51 = *(unsigned __int8 *)(a5 + 8);
    *(_DWORD *)__int16 v86 = 67109888;
    *(_DWORD *)&v86[4] = v48;
    *(_WORD *)&v86[8] = 1024;
    *(_DWORD *)&v86[10] = v49;
    LOWORD(v87) = 1024;
    *(_DWORD *)((char *)&v87 + 2) = v50;
    HIWORD(v87) = 1024;
    int v88 = v51;
    __int16 v52 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v52);
    if (v52 != buf) {
      free(v52);
    }
  }
  sub_1000E9354(v81);
  if (!sub_100012960(a2, "BAA", v81))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    char v25 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No BAA dict found in carrier bundle, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      __int16 v69 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v69);
      if (v69 != buf) {
        free(v69);
      }
    }
  }
  sub_1000E9354(v80);
  if (!sub_100012960(v7, "BAA", v80))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unsigned int v26 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No BAA dict found in operator bundle, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)__int16 v86 = 0;
      uint64_t v70 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v70);
      if (v70 != buf) {
        free(v70);
      }
    }
  }
  sub_100134750(buf, "carrier");
  sub_100A9243C((uint64_t *)buf, (uint64_t)v81, a5 + 1036);
  if (SBYTE1(v93) < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  char v27 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    sub_101026000();
    char v28 = (v93 & 0x8000) == 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)__int16 v86 = 136380675;
    *(void *)&v86[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings carrier BAA: %{private}s", v86, 0xCu);
    if (SBYTE1(v93) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_101026000();
    if ((v88 & 0x8000) == 0) {
      __int16 v53 = (uint64_t *)v86;
    }
    else {
      __int16 v53 = *(uint64_t **)v86;
    }
    int v82 = 136380675;
    int v83 = v53;
    int v54 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE1(v88) < 0) {
      operator delete(*(void **)v86);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v54);
    if (v54 != buf) {
      free(v54);
    }
  }
  sub_100134750(buf, "operator");
  sub_100A9243C((uint64_t *)buf, (uint64_t)v80, a5 + 1008);
  if (SBYTE1(v93) < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v29 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    sub_101026000();
    int v30 = (v93 & 0x8000) == 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)__int16 v86 = 136380675;
    *(void *)&v86[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings operator BAA: %{private}s", v86, 0xCu);
    if (SBYTE1(v93) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_101026000();
    if ((v88 & 0x8000) == 0) {
      double v55 = (uint64_t *)v86;
    }
    else {
      double v55 = *(uint64_t **)v86;
    }
    int v82 = 136380675;
    int v83 = v55;
    int v56 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE1(v88) < 0) {
      operator delete(*(void **)v86);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v56);
    if (v56 != buf) {
      free(v56);
    }
  }
  sub_1000E9354(v79);
  if (byte_10248BD87 >= 0) {
    __int16 v31 = (const char *)&qword_10248BD70;
  }
  else {
    __int16 v31 = (const char *)qword_10248BD70;
  }
  if (!sub_100012960(a2, v31, v79))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v32 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (byte_10248BD87 >= 0) {
        __int16 v33 = &qword_10248BD70;
      }
      else {
        __int16 v33 = (uint64_t *)qword_10248BD70;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No %{public}s dict found in carrier bundle, using default", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (byte_10248BD87 >= 0) {
        __int16 v71 = &qword_10248BD70;
      }
      else {
        __int16 v71 = (uint64_t *)qword_10248BD70;
      }
      *(_DWORD *)__int16 v86 = 136446210;
      *(void *)&v86[4] = v71;
      __int16 v72 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v72);
      if (v72 != buf) {
        free(v72);
      }
    }
  }
  sub_1000E9354(v78);
  if (byte_10248BD87 >= 0) {
    __int16 v34 = (const char *)&qword_10248BD70;
  }
  else {
    __int16 v34 = (const char *)qword_10248BD70;
  }
  if (!sub_100012960(v7, v34, v78))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    __int16 v35 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (byte_10248BD87 >= 0) {
        int v36 = &qword_10248BD70;
      }
      else {
        int v36 = (uint64_t *)qword_10248BD70;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&uint8_t buf[4] = v36;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No %{public}s dict found in operator bundle, using default", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (byte_10248BD87 >= 0) {
        __int16 v73 = &qword_10248BD70;
      }
      else {
        __int16 v73 = (uint64_t *)qword_10248BD70;
      }
      *(_DWORD *)__int16 v86 = 136446210;
      *(void *)&v86[4] = v73;
      unsigned int v74 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v74);
      if (v74 != buf) {
        free(v74);
      }
    }
  }
  sub_100134750(buf, "carrier");
  sub_100A93094((uint64_t *)buf, (uint64_t)v79, a5 + 1152);
  if (SBYTE1(v93) < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v37 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v38 = byte_10248BD87;
    uint64_t v39 = qword_10248BD70;
    sub_101026240(a5 + 1152);
    if (v38 >= 0) {
      unsigned int v40 = &qword_10248BD70;
    }
    else {
      unsigned int v40 = (uint64_t *)v39;
    }
    if ((v93 & 0x8000) == 0) {
      __int16 v41 = buf;
    }
    else {
      __int16 v41 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v86 = 136446467;
    *(void *)&v86[4] = v40;
    *(_WORD *)&v86[12] = 2081;
    double v87 = v41;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings carrier %{public}s: %{private}s", v86, 0x16u);
    if (SBYTE1(v93) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v7 = a3;
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v57 = byte_10248BD87;
    uint64_t v58 = qword_10248BD70;
    sub_101026240(a5 + 1152);
    if (v57 >= 0) {
      __int16 v59 = &qword_10248BD70;
    }
    else {
      __int16 v59 = (uint64_t *)v58;
    }
    if ((v88 & 0x8000) == 0) {
      uint64_t v60 = v86;
    }
    else {
      uint64_t v60 = *(unsigned char **)v86;
    }
    int v82 = 136446467;
    int v83 = v59;
    __int16 v84 = 2081;
    unsigned int v85 = v60;
    __int16 v61 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE1(v88) < 0) {
      operator delete(*(void **)v86);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v61);
    uint64_t v7 = a3;
    if (v61 != buf) {
      free(v61);
    }
  }
  sub_100134750(buf, "operator");
  sub_100A93094((uint64_t *)buf, (uint64_t)v78, a5 + 1064);
  if (SBYTE1(v93) < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v42 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v43 = byte_10248BD87;
    uint64_t v44 = qword_10248BD70;
    sub_101026240(a5 + 1064);
    if (v43 >= 0) {
      __int16 v45 = &qword_10248BD70;
    }
    else {
      __int16 v45 = (uint64_t *)v44;
    }
    if ((v93 & 0x8000) == 0) {
      uint64_t v46 = buf;
    }
    else {
      uint64_t v46 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v86 = 136446467;
    *(void *)&v86[4] = v45;
    *(_WORD *)&v86[12] = 2081;
    double v87 = v46;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings operator %{public}s: %{private}s", v86, 0x16u);
    if (SBYTE1(v93) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v7 = a3;
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v62 = byte_10248BD87;
    uint64_t v63 = qword_10248BD70;
    sub_101026240(a5 + 1064);
    if (v62 >= 0) {
      uint64_t v64 = &qword_10248BD70;
    }
    else {
      uint64_t v64 = (uint64_t *)v63;
    }
    if ((v88 & 0x8000) == 0) {
      __int16 v65 = v86;
    }
    else {
      __int16 v65 = *(unsigned char **)v86;
    }
    int v82 = 136446467;
    int v83 = v64;
    __int16 v84 = 2081;
    unsigned int v85 = v65;
    __int16 v66 = (char *)_os_log_send_and_compose_impl();
    if (SBYTE1(v88) < 0) {
      operator delete(*(void **)v86);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLocationKeys(const CLNameValuePair &, const CLNameValuePair &, const CLNameValuePair &, LocationSettings &) const", "%s\n", v66);
    uint64_t v7 = a3;
    if (v66 != buf) {
      free(v66);
    }
  }
  sub_101026688(a1, a2, v7, (int *)(a5 + 16));
  sub_10013F3C4(v78);
  sub_10013F3C4(v79);
  sub_10013F3C4(v80);
  return sub_10013F3C4(v81);
}

void sub_1010239F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

uint64_t sub_101023AD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000C7F88(buf);
  uint64_t v7 = (unsigned int *)(a4 + 56);
  int v8 = sub_1004D0870(*(uint64_t *)buf, "GpsSuplFlags", (_DWORD *)(a4 + 56));
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v8)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    char v9 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v10 = *v7;
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: overriding suplFlags with [0x%X]", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned int v11 = *v7;
      *(_DWORD *)std::string __str = 67109120;
      *(_DWORD *)&__str[4] = v11;
      BOOL v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v12);
LABEL_226:
      if (v12 != buf) {
        free(v12);
      }
    }
  }
  else if ((sub_1004D0870(a2, "SuplFlags", (_DWORD *)(a4 + 56)) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v13 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl SUPL: no supl flags found, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)std::string __str = 0;
      BOOL v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v12);
      goto LABEL_226;
    }
  }
  BOOL v85 = *(unsigned char *)v7 & 1;
  sub_1000C7F88(buf);
  sub_1000D2988(*(uint64_t *)buf, "GpsEnableNonEmergencySupl", &v85);
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  BOOL v14 = v85;
  *(unsigned char *)uint64_t v7 = *(unsigned char *)v7 & 0xFE | v85;
  if (v14)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v15 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: supl sessions will be allowed in non-emergency requests too", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)std::string __str = 0;
      __int16 v69 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v69);
      if (v69 != buf) {
        free(v69);
      }
    }
  }
  BOOL v85 = (*(unsigned char *)v7 & 2) != 0;
  sub_1000C7F88(buf);
  sub_1000D2988(*(uint64_t *)buf, "GpsAllowSuplWithoutEmergencyNotification", &v85);
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  BOOL v16 = v85;
  *(unsigned char *)uint64_t v7 = *(unsigned char *)v7 & 0xFD | (2 * v85);
  if (v16)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v17 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: non e-slp supl sessions will be allowed", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      *(_WORD *)std::string __str = 0;
      uint64_t v70 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v70);
      if (v70 != buf) {
        free(v70);
      }
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v18 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v19 = *v7;
    int v20 = *v7 & 1;
    int v21 = (*v7 >> 1) & 1;
    int v22 = (*v7 >> 2) & 1;
    *(_DWORD *)uint64_t buf = 67110400;
    *(_DWORD *)&uint8_t buf[4] = v19;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v20;
    *(_WORD *)&unsigned char buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = v21;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v22;
    __int16 v96 = 1024;
    int v97 = (v19 >> 3) & 1;
    __int16 v98 = 1024;
    int v99 = (v19 >> 4) & 1;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: suplFlags,0x%X,allowNonEmergencySupl,%d,allowSuplWithoutEmergencyNotification,%d,allowHslpMismatch,%d,allowHslpWildCard,%d,allowNonConformingEslpAddress,%d", buf, 0x26u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unsigned int v63 = *v7;
    int v64 = *v7 & 1;
    int v65 = (*v7 >> 1) & 1;
    int v66 = (*v7 >> 2) & 1;
    int v67 = (*v7 >> 3) & 1;
    *(_DWORD *)std::string __str = 67110400;
    *(_DWORD *)&__str[4] = v63;
    *(_WORD *)&__str[8] = 1024;
    *(_DWORD *)&__str[10] = v64;
    *(_WORD *)&__str[14] = 1024;
    *(_DWORD *)&char __str[16] = v65;
    *(_WORD *)&__str[20] = 1024;
    *(_DWORD *)&__str[22] = v66;
    __int16 v91 = 1024;
    int v92 = v67;
    __int16 v93 = 1024;
    int v94 = (v63 >> 4) & 1;
    int v68 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v68);
    if (v68 != buf) {
      free(v68);
    }
  }
  memset(__str, 0, 24);
  sub_1000C7F88(buf);
  if (sub_1004D1284(*(uint64_t *)buf, "GpsSuplHslpAddress", (std::string *)__str))
  {
    if (__str[23] >= 0) {
      uint64_t v23 = __str[23];
    }
    else {
      uint64_t v23 = *(void *)&__str[8];
    }
    if (*(void *)&buf[8]) {
      sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v23)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v24 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        char v25 = __str;
        if (__str[23] < 0) {
          char v25 = *(unsigned char **)__str;
        }
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: overriding carrier and operator HSLP address with [%s]", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        unsigned int v26 = __str;
        if (__str[23] < 0) {
          unsigned int v26 = *(unsigned char **)__str;
        }
LABEL_248:
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
        int v79 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v79);
        if (v79 != buf) {
          free(v79);
        }
        goto LABEL_99;
      }
      goto LABEL_99;
    }
  }
  else if (*(void *)&buf[8])
  {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!sub_1004D1284(a2, "SuplHSLPServerAddress", (std::string *)__str))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    __int16 v31 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: CB does not contain HSLP address. SUPL not supported", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_153;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_84;
    }
    goto LABEL_270;
  }
  uint64_t v27 = __str[23];
  if (__str[23] < 0) {
    uint64_t v27 = *(void *)&__str[8];
  }
  if (!v27)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    __int16 v33 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: carrier-hslp is empty. SUPL disabled", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_153;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 == -1) {
      goto LABEL_84;
    }
LABEL_270:
    dispatch_once(&qword_1024193E0, &stru_10230B640);
LABEL_84:
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    int v32 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v32);
    goto LABEL_234;
  }
  if ((*(unsigned char *)v7 & 4) == 0)
  {
    memset(&__p, 0, sizeof(__p));
    if (sub_1004D1284(a3, "SuplHSLPServerAddress", &__p))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      char v28 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        int v30 = __str;
        if (__str[23] < 0) {
          int v30 = *(unsigned char **)__str;
        }
        *(_DWORD *)uint64_t buf = 136315394;
        *(void *)&uint8_t buf[4] = p_p;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = v30;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: operator-hslp,[%s],carrier-hslp,[%s]", buf, 0x16u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v81 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v81 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        int v82 = __str;
        if (__str[23] < 0) {
          int v82 = *(unsigned char **)__str;
        }
        *(_DWORD *)__endptr = 136315394;
        *(void *)&__endptr[4] = v81;
        __int16 v87 = 2080;
        int v88 = v82;
        int v83 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v83);
        if (v83 != buf) {
          free(v83);
        }
      }
      if (sub_10102A614(&__p, __str, 0))
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_99;
      }
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v62 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: carrier and operator bundle HSLP address are different. SUPL disabled", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2))
      {
LABEL_202:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_153;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1)
      {
LABEL_268:
        *(_WORD *)__endptr = 0;
        __int16 v84 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v84);
        if (v84 != buf) {
          free(v84);
        }
        goto LABEL_202;
      }
    }
    else
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v61 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: OB does not contain HSLP address. SUPL not supported", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_202;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1) {
        goto LABEL_268;
      }
    }
    dispatch_once(&qword_1024193E0, &stru_10230B640);
    goto LABEL_268;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v34 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    __int16 v35 = __str;
    if (__str[23] < 0) {
      __int16 v35 = *(unsigned char **)__str;
    }
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: carrier-hslp,[%s]", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unsigned int v26 = __str;
    if (__str[23] < 0) {
      unsigned int v26 = *(unsigned char **)__str;
    }
    goto LABEL_248;
  }
LABEL_99:
  std::string::size_type v36 = std::string::find((const std::string *)__str, 58, 0);
  std::string::basic_string((std::string *)buf, (const std::string *)__str, 0, v36, (std::allocator<char> *)&__p);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = *(_OWORD *)buf;
  *(void *)(a4 + 16) = *(void *)&buf[16];
  if (v36 != -1)
  {
    unint64_t v37 = v36 + 1;
    if ((__str[23] & 0x80000000) != 0)
    {
      if (v37 >= *(void *)&__str[8]) {
        goto LABEL_115;
      }
      *(void *)__endptr = 0;
      int v38 = *(unsigned char **)__str;
    }
    else
    {
      if (v37 >= __str[23]) {
        goto LABEL_115;
      }
      *(void *)__endptr = 0;
      int v38 = __str;
    }
    uint64_t v39 = &v38[v36 + 1];
    *(_WORD *)(a4 + 48) = strtol(v39, (char **)__endptr, 10);
    if (*(void *)__endptr && **(unsigned char **)__endptr)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned int v40 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v39;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: invalid port specification [%s]. reverting to default", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
        __int16 v80 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v80);
        if (v80 != buf) {
          free(v80);
        }
      }
      *(_WORD *)(a4 + 48) = 7275;
    }
  }
LABEL_115:
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v41 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a4 + 23) >= 0) {
      uint64_t v42 = (void *)a4;
    }
    else {
      uint64_t v42 = *(void **)a4;
    }
    int v43 = *(unsigned __int16 *)(a4 + 48);
    *(_DWORD *)uint64_t buf = 136315394;
    *(void *)&uint8_t buf[4] = v42;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&unsigned char buf[14] = v43;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: using hslp,%s,port,%d", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    if (*(char *)(a4 + 23) >= 0) {
      __int16 v71 = (void *)a4;
    }
    else {
      __int16 v71 = *(void **)a4;
    }
    int v72 = *(unsigned __int16 *)(a4 + 48);
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v71;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v72;
    __int16 v73 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v73);
    if (v73 != buf) {
      free(v73);
    }
  }
  if ((sub_10102AD10((uint64_t *)a4, (*(unsigned __int8 *)(a4 + 56) >> 3) & 1, (*(unsigned char *)(a4 + 56) & 0x16) != 0) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v49 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_FAULT))
    {
      if (*(char *)(a4 + 23) >= 0) {
        int v50 = (void *)a4;
      }
      else {
        int v50 = *(void **)a4;
      }
      int v51 = *(unsigned __int16 *)(a4 + 48);
      *(_DWORD *)uint64_t buf = 136446466;
      *(void *)&uint8_t buf[4] = v50;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&unsigned char buf[14] = v51;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "#EmergCon,#EmergSettings,#supl SUPL: invalid HSLP specification [%{public}s], port [%{public}d]. SUPL disabled ", buf, 0x12u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_153;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    if (*(char *)(a4 + 23) >= 0) {
      unsigned int v74 = (void *)a4;
    }
    else {
      unsigned int v74 = *(void **)a4;
    }
    int v75 = *(unsigned __int16 *)(a4 + 48);
    LODWORD(__p.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v74;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v75;
    int v32 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v32);
LABEL_234:
    if (v32 != buf) {
      free(v32);
    }
LABEL_153:
    uint64_t v52 = 0;
    goto LABEL_187;
  }
  sub_1000C7F88(buf);
  if (sub_1004D1284(*(uint64_t *)buf, "GpsSuplHslpCert", (std::string *)(a4 + 24)))
  {
    if (*(char *)(a4 + 47) >= 0) {
      uint64_t v44 = *(unsigned __int8 *)(a4 + 47);
    }
    else {
      uint64_t v44 = *(void *)(a4 + 32);
    }
    if (*(void *)&buf[8]) {
      sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v44)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v45 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a4 + 47) >= 0) {
          uint64_t v46 = a4 + 24;
        }
        else {
          uint64_t v46 = *(void *)(a4 + 24);
        }
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: overriding carrier hslp cert with [%s]", buf, 0xCu);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_175;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a4 + 47) >= 0) {
        std::string::size_type v47 = a4 + 24;
      }
      else {
        std::string::size_type v47 = *(void *)(a4 + 24);
      }
      goto LABEL_144;
    }
  }
  else if (*(void *)&buf[8])
  {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!sub_1004D1284(a2, "SuplCARootCert", (std::string *)(a4 + 24)))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v55 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: carrier dictionary does not contain HSLP cert", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_175;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    int v48 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v48);
    goto LABEL_253;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  __int16 v53 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a4 + 47) >= 0) {
      uint64_t v54 = a4 + 24;
    }
    else {
      uint64_t v54 = *(void *)(a4 + 24);
    }
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v54;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: HSLPCARootCert,%s", buf, 0xCu);
  }
  if (!sub_10013D1A0(115, 2)) {
    goto LABEL_175;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  if (*(char *)(a4 + 47) >= 0) {
    std::string::size_type v47 = a4 + 24;
  }
  else {
    std::string::size_type v47 = *(void *)(a4 + 24);
  }
LABEL_144:
  LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v47;
  int v48 = (char *)_os_log_send_and_compose_impl();
  sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v48);
LABEL_253:
  if (v48 != buf) {
    free(v48);
  }
LABEL_175:
  int v56 = (int *)(a4 + 52);
  if ((sub_1004D0870(a2, "SuplUdpPortConfig", v56) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v57 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,,#supl,#Warning SUPL: no supl udp port config found, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      __int16 v78 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v78);
      if (v78 != buf) {
        free(v78);
      }
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v58 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    int v59 = *v56;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v59;
    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: udpPortConfig,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v76 = *v56;
    LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(__p.__r_.__value_.__r.__words[0]) = v76;
    int v77 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencyController::readSuplKeys(const CLNameValuePair &, const CLNameValuePair &, SuplSettings &) const", "%s\n", v77);
    if (v77 != buf) {
      free(v77);
    }
  }
  uint64_t v52 = 1;
LABEL_187:
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  return v52;
}

void sub_101025894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_101025958(uint64_t a1, int *a2)
{
  if (qword_102419600 != -1) {
    dispatch_once(&qword_102419600, &stru_10230B680);
  }
  int v4 = qword_102419608;
  if (os_log_type_enabled((os_log_t)qword_102419608, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a2;
    double v6 = a2 + 316;
    if (*((char *)a2 + 1287) < 0) {
      double v6 = (int *)*((void *)a2 + 158);
    }
    uint64_t v7 = a2 + 328;
    if (*((char *)a2 + 1335) < 0) {
      uint64_t v7 = (int *)*((void *)a2 + 164);
    }
    *(_DWORD *)uint64_t buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v5;
    *(_WORD *)__int16 v35 = 2080;
    *(void *)&v35[2] = v6;
    *(_WORD *)&v35[10] = 2080;
    *(void *)&v35[12] = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#ca,handleEmergencySettingsChange,simInstance,%d,carrierBundleID,%s,operatorBundleID,%s", buf, 0x1Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419600 != -1) {
      dispatch_once(&qword_102419600, &stru_10230B680);
    }
    int v17 = *a2;
    __int16 v18 = a2 + 316;
    if (*((char *)a2 + 1287) < 0) {
      __int16 v18 = (void *)*((void *)a2 + 158);
    }
    unsigned int v19 = a2 + 328;
    if (*((char *)a2 + 1335) < 0) {
      unsigned int v19 = (void *)*((void *)a2 + 164);
    }
    int v31 = 67109634;
    int v32 = v17;
    LOWORD(v33[0]) = 2080;
    *(void **)((char *)v33 + 2) = v18;
    WORD1(v33[1]) = 2080;
    *(void **)((char *)&v33[1] + 4) = v19;
    int v20 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::setSimRelatedMeasurementsInLoggerFramework(const LocationSettings &)", "%s\n", v20);
    if (v20 != (char *)buf) {
      free(v20);
    }
  }
  if (*a2 == 1)
  {
    int v31 = 17;
    if (*((char *)a2 + 1287) < 0)
    {
      sub_1000DC48C(v33, *((void **)a2 + 158), *((void *)a2 + 159));
      int v9 = v31;
    }
    else
    {
      *(_OWORD *)__int16 v33 = *((_OWORD *)a2 + 79);
      v33[2] = *((void **)a2 + 160);
      int v9 = 17;
    }
    *(_DWORD *)uint64_t buf = v9;
    *(_OWORD *)__int16 v35 = *(_OWORD *)v33;
    *(void **)&v35[16] = v33[2];
    memset(v33, 0, sizeof(v33));
    int v36 = 6;
    int v23 = 19;
    if (*((char *)a2 + 1335) < 0)
    {
      sub_1000DC48C(&__p, *((void **)a2 + 164), *((void *)a2 + 165));
      int v11 = v23;
    }
    else
    {
      long long __p = *((_OWORD *)a2 + 82);
      uint64_t v25 = *((void *)a2 + 166);
      int v11 = 19;
    }
    int v37 = v11;
    long long v38 = __p;
    uint64_t v39 = v25;
    long long __p = 0uLL;
    uint64_t v25 = 0;
    int v40 = 6;
    uint64_t v27 = 0;
    char v28 = 0;
    unsigned int v26 = 0;
    __int16 v29 = (void **)&v26;
    char v30 = 0;
    unsigned int v26 = (char *)operator new(0x50uLL);
    uint64_t v27 = v26;
    char v28 = v26 + 80;
    uint64_t v27 = (unsigned char *)sub_100682A48((uint64_t)&v28, (uint64_t)buf, (uint64_t)v41, (uint64_t)v26);
    for (uint64_t i = 48; i != -32; i -= 40)
      sub_100118010((uint64_t)&buf[i]);
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v33[2]) < 0) {
      operator delete(v33[0]);
    }
    BOOL v16 = *(void **)(a1 + 712);
    memset(v21, 0, sizeof(v21));
    sub_100682C20(v21, (uint64_t)v26, (uint64_t)v27, 0xCCCCCCCCCCCCCCCDLL * ((v27 - v26) >> 3));
    [v16 setMeasurements:sub_10067C03C(v21)];
    BOOL v14 = v21;
  }
  else
  {
    if (*a2) {
      return;
    }
    int v31 = 7;
    if (*((char *)a2 + 1287) < 0)
    {
      sub_1000DC48C(v33, *((void **)a2 + 158), *((void *)a2 + 159));
      int v8 = v31;
    }
    else
    {
      *(_OWORD *)__int16 v33 = *((_OWORD *)a2 + 79);
      v33[2] = *((void **)a2 + 160);
      int v8 = 7;
    }
    *(_DWORD *)uint64_t buf = v8;
    *(_OWORD *)__int16 v35 = *(_OWORD *)v33;
    *(void **)&v35[16] = v33[2];
    memset(v33, 0, sizeof(v33));
    int v36 = 6;
    int v23 = 11;
    if (*((char *)a2 + 1335) < 0)
    {
      sub_1000DC48C(&__p, *((void **)a2 + 164), *((void *)a2 + 165));
      int v10 = v23;
    }
    else
    {
      long long __p = *((_OWORD *)a2 + 82);
      uint64_t v25 = *((void *)a2 + 166);
      int v10 = 11;
    }
    int v37 = v10;
    long long v38 = __p;
    uint64_t v39 = v25;
    long long __p = 0uLL;
    uint64_t v25 = 0;
    int v40 = 6;
    uint64_t v27 = 0;
    char v28 = 0;
    unsigned int v26 = 0;
    __int16 v29 = (void **)&v26;
    char v30 = 0;
    unsigned int v26 = (char *)operator new(0x50uLL);
    uint64_t v27 = v26;
    char v28 = v26 + 80;
    uint64_t v27 = (unsigned char *)sub_100682A48((uint64_t)&v28, (uint64_t)buf, (uint64_t)v41, (uint64_t)v26);
    for (uint64_t j = 48; j != -32; j -= 40)
      sub_100118010((uint64_t)&buf[j]);
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v33[2]) < 0) {
      operator delete(v33[0]);
    }
    int v13 = *(void **)(a1 + 712);
    memset(v22, 0, sizeof(v22));
    sub_100682C20(v22, (uint64_t)v26, (uint64_t)v27, 0xCCCCCCCCCCCCCCCDLL * ((v27 - v26) >> 3));
    [v13 setMeasurements:sub_10067C03C(v22)];
    BOOL v14 = v22;
  }
  *(void *)uint64_t buf = v14;
  sub_100682B1C((void ***)buf);
  *(void *)uint64_t buf = &v26;
  sub_100682B1C((void ***)buf);
}

void sub_101025F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  sub_100118010((uint64_t)&a38);
  _Unwind_Resume(exception_object);
}

uint64_t sub_101026000()
{
  sub_10010F274((uint64_t)v9);
  sub_100132EFC(v10, (uint64_t)"#EED2,#BAA,Disabled,", 20);
  int v0 = (void *)std::ostream::operator<<();
  sub_100132EFC(v0, (uint64_t)",EEDEnabledOnly,", 16);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_100132EFC(v1, (uint64_t)",CertValidityPeriod,", 20);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_100132EFC(v2, (uint64_t)",NoCertRequestWindow,", 21);
  CFStringRef v3 = (void *)std::ostream::operator<<();
  sub_100132EFC(v3, (uint64_t)",NoCertRetryWindow,", 19);
  int v4 = (void *)std::ostream::operator<<();
  sub_100132EFC(v4, (uint64_t)",CertAvailableRequestWindowMin,", 31);
  int v5 = (void *)std::ostream::operator<<();
  sub_100132EFC(v5, (uint64_t)",CertAvailableRequestWindowMax,", 31);
  double v6 = (void *)std::ostream::operator<<();
  sub_100132EFC(v6, (uint64_t)",CertAvailableRetryWindow,", 26);
  std::ostream::operator<<();
  std::stringbuf::str();
  *(void *)((char *)v9
  v10[0] = v7;
  if (v11 < 0) {
    operator delete((void *)v10[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10102622C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101026240(uint64_t a1)
{
  sub_10010F274((uint64_t)v24);
  sub_100132EFC(v25, (uint64_t)"enabled,", 8);
  uint64_t v2 = (void *)std::ostream::operator<<();
  CFStringRef v3 = sub_100132EFC(v2, (uint64_t)",url,", 5);
  int v4 = *(char *)(a1 + 31);
  if (v4 >= 0) {
    uint64_t v5 = a1 + 8;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v6 = *(void *)(a1 + 16);
  }
  uint64_t v7 = sub_100132EFC(v3, v5, v6);
  sub_100132EFC(v7, (uint64_t)",debounceDelay,", 15);
  int v8 = (void *)std::ostream::operator<<();
  sub_100132EFC(v8, (uint64_t)",debounceGracePeriod,", 21);
  int v9 = (void *)std::ostream::operator<<();
  sub_100132EFC(v9, (uint64_t)",periodicDelay,", 15);
  int v10 = (void *)std::ostream::operator<<();
  sub_100132EFC(v10, (uint64_t)",periodicGracePeriod,", 21);
  char v11 = (void *)std::ostream::operator<<();
  sub_100132EFC(v11, (uint64_t)",backoffDelay,", 14);
  BOOL v12 = (void *)std::ostream::operator<<();
  sub_100132EFC(v12, (uint64_t)",backoffGracePeriod,", 20);
  int v13 = (void *)std::ostream::operator<<();
  sub_100132EFC(v13, (uint64_t)",validityInterval,", 18);
  BOOL v14 = (void *)std::ostream::operator<<();
  sub_100132EFC(v14, (uint64_t)",partnerInfoVec,[", 17);
  uint64_t v15 = *(void *)(a1 + 64);
  uint64_t v16 = *(void *)(a1 + 72);
  if (v15 != v16)
  {
    do
    {
      int v17 = sub_100132EFC(v25, (uint64_t)"{", 1);
      sub_10102FBE8(v15);
      if ((v28 & 0x80u) == 0) {
        __int16 v18 = v27;
      }
      else {
        __int16 v18 = (void **)v27[0];
      }
      if ((v28 & 0x80u) == 0) {
        uint64_t v19 = v28;
      }
      else {
        uint64_t v19 = (uint64_t)v27[1];
      }
      int v20 = sub_100132EFC(v17, (uint64_t)v18, v19);
      sub_100132EFC(v20, (uint64_t)"},", 2);
      if ((char)v28 < 0) {
        operator delete(v27[0]);
      }
      v15 += 48;
    }
    while (v15 != v16);
    if (*(void *)(a1 + 72) != *(void *)(a1 + 64))
    {
      std::ostream::sentry::sentry();
      int v21 = (char *)v25 + *(void *)(v25[0] - 24);
      if ((v21[32] & 5) == 0)
      {
        (*(void (**)(void **__return_ptr))(**((void **)v21 + 5) + 32))(v27);
        if (v29 == -1) {
          std::ios_base::clear((std::ios_base *)((char *)v25 + *(void *)(v25[0] - 24)), *(_DWORD *)((char *)&v25[4] + *(void *)(v25[0] - 24)) | 4);
        }
      }
      std::ostream::sentry::~sentry();
    }
  }
  sub_100132EFC(v25, (uint64_t)"]", 1);
  std::stringbuf::str();
  *(void *)((char *)v24
  v25[0] = v22;
  if (v26 < 0) {
    operator delete((void *)v25[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101026638(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostream::sentry::~sentry();
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101026688(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  sub_1000E9354(v42);
  sub_1000E9354(v41);
  sub_1000E9354(v40);
  sub_1000E9354(v39);
  if (sub_100012960(a2, "EmergencyLocation", v42))
  {
    if (!sub_100012960((uint64_t)v42, "ControlPlane", v41))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v8 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No ControlPlane dict found, using default", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        *(_WORD *)int v43 = 0;
        __int16 v35 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v35);
        if (v35 != (char *)buf) {
          free(v35);
        }
      }
    }
    if (!sub_100012960((uint64_t)v42, "UserPlane", v40))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v9 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No UserPlane dict found, using default", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        *(_WORD *)int v43 = 0;
        int v36 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v36);
        if (v36 != (char *)buf) {
          free(v36);
        }
      }
    }
    if (!sub_100012960((uint64_t)v42, "AugmentedEmergencyAction", v39))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      int v10 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No AugmentedEmergencyAction dict found in carrier bundle, using default", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 == -1)
        {
LABEL_121:
          *(_WORD *)int v43 = 0;
          __int16 v33 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v33);
          if (v33 != (char *)buf) {
            free(v33);
          }
          goto LABEL_27;
        }
LABEL_134:
        dispatch_once(&qword_1024193E0, &stru_10230B640);
        goto LABEL_121;
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    char v11 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No EmergencyLocation dict found in carrier bundle, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1) {
        goto LABEL_121;
      }
      goto LABEL_134;
    }
  }
LABEL_27:
  sub_1000E9354(v38);
  sub_1000E9354(v37);
  if (sub_100012960(a3, "EmergencyLocation", v38))
  {
    if (!sub_100012960((uint64_t)v38, "AugmentedEmergencyAction", v37))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v12 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No AugmentedEmergencyAction dict found in operator bundle, using default", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 == -1)
        {
LABEL_124:
          *(_WORD *)int v43 = 0;
          __int16 v34 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v34);
          if (v34 != (char *)buf) {
            free(v34);
          }
          goto LABEL_41;
        }
LABEL_135:
        dispatch_once(&qword_1024193E0, &stru_10230B640);
        goto LABEL_124;
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v13 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings No EmergencyLocation dict found in operator bundle, using default", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1) {
        goto LABEL_124;
      }
      goto LABEL_135;
    }
  }
LABEL_41:
  sub_100134750(buf, "Control Plane");
  sub_101027714(a1, (std::string::size_type)buf, (uint64_t)v41, a4);
  if (v48 < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  BOOL v14 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010283BC(a4);
    uint64_t v15 = v48 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)int v43 = 136315138;
    *(void *)&v43[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings ControlPlane: %s", v43, 0xCu);
    if (v48 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_1010283BC(a4);
    if (v44 >= 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = *(unsigned char **)v43;
    }
    int v45 = 136315138;
    uint64_t v46 = v25;
    char v26 = (char *)_os_log_send_and_compose_impl();
    if (v44 < 0) {
      operator delete(*(void **)v43);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v26);
    if (v26 != (char *)buf) {
      free(v26);
    }
  }
  uint64_t v16 = sub_100134750(buf, "Control Plane Cdma");
  sub_10102879C((uint64_t)v16, (std::string::size_type)buf, (uint64_t)v41, (uint64_t)(a4 + 10));
  if (v48 < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  int v17 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    sub_101029080((uint64_t)(a4 + 10));
    __int16 v18 = v48 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)int v43 = 136315138;
    *(void *)&v43[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings ControlPlaneCdma: %s", v43, 0xCu);
    if (v48 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_101029080((uint64_t)(a4 + 10));
    if (v44 >= 0) {
      uint64_t v27 = v43;
    }
    else {
      uint64_t v27 = *(unsigned char **)v43;
    }
    int v45 = 136315138;
    uint64_t v46 = v27;
    unsigned __int8 v28 = (char *)_os_log_send_and_compose_impl();
    if (v44 < 0) {
      operator delete(*(void **)v43);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v28);
    if (v28 != (char *)buf) {
      free(v28);
    }
  }
  sub_100134750(buf, "User Plane");
  sub_101027714(a1, (std::string::size_type)buf, (uint64_t)v40, a4 + 12);
  if (v48 < 0) {
    operator delete(*(void **)buf);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v19 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010283BC(a4 + 12);
    int v20 = v48 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)int v43 = 136315138;
    *(void *)&v43[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings UserPlane: %s", v43, 0xCu);
    if (v48 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_1010283BC(a4 + 12);
    if (v44 >= 0) {
      uint64_t v29 = v43;
    }
    else {
      uint64_t v29 = *(unsigned char **)v43;
    }
    int v45 = 136315138;
    uint64_t v46 = v29;
    char v30 = (char *)_os_log_send_and_compose_impl();
    if (v44 < 0) {
      operator delete(*(void **)v43);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v30);
    if (v30 != (char *)buf) {
      free(v30);
    }
  }
  uint64_t v21 = (uint64_t)(a4 + 26);
  sub_101479638((uint64_t)v39, (uint64_t)v37, v21);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v22 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    sub_101029288(v21);
    int v23 = v48 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)int v43 = 136380675;
    *(void *)&v43[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings AugmentedEmergencyAction: %{private}s", v43, 0xCu);
    if (v48 < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    sub_101029288(v21);
    if (v44 >= 0) {
      int v31 = v43;
    }
    else {
      int v31 = *(unsigned char **)v43;
    }
    int v45 = 136380675;
    uint64_t v46 = v31;
    int v32 = (char *)_os_log_send_and_compose_impl();
    if (v44 < 0) {
      operator delete(*(void **)v43);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readEmergencyLocationKeys(const CLNameValuePair &, const CLNameValuePair &, LocationSettings::Emergency &) const", "%s\n", v32);
    if (v32 != (char *)buf) {
      free(v32);
    }
  }
  sub_10013F3C4(v37);
  sub_10013F3C4(v38);
  sub_10013F3C4(v39);
  sub_10013F3C4(v40);
  sub_10013F3C4(v41);
  return sub_10013F3C4(v42);
}

void sub_101027630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

uint64_t sub_101027714(uint64_t a1, std::string::size_type a2, uint64_t a3, _DWORD *a4)
{
  sub_100103240();
  if ((sub_10010145C() & 1) != 0 || (sub_100103240(), (sub_10073C750() & 1) == 0))
  {
    *a4 = 0;
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v10 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v11 = a2;
      }
      else {
        std::string::size_type v11 = *(void *)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings %s: MSA not supported on platform", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v9 = a2;
      }
      else {
        std::string::size_type v9 = *(void *)a2;
      }
      goto LABEL_100;
    }
  }
  else if ((sub_1004D0870(a3, "EnableMSAssisted", a4) & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v7 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v8 = a2;
      }
      else {
        std::string::size_type v8 = *(void *)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings %s: No EnableMSAssisted flag found, using default", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v9 = a2;
      }
      else {
        std::string::size_type v9 = *(void *)a2;
      }
LABEL_100:
      int v39 = 136315138;
      std::string::size_type v40 = v9;
      int v31 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v31);
      if (v31 != buf) {
        free(v31);
      }
    }
  }
  sub_1000E9354(v38);
  if (sub_100012960(a3, "EnableAdditionalAssistedConstellations", v38))
  {
    memset(buf, 0, 24);
    if (sub_1004D1284((uint64_t)v38, "Glonass", buf)) {
      a4[1] = sub_101029558((const void **)&buf[0].__r_.__value_.__l.__data_);
    }
    if (sub_1004D1284((uint64_t)v38, "Beidou", buf)) {
      a4[5] = sub_101029558((const void **)&buf[0].__r_.__value_.__l.__data_);
    }
    if (sub_1004D1284((uint64_t)v38, "Galileo", buf)) {
      a4[2] = sub_101029558((const void **)&buf[0].__r_.__value_.__l.__data_);
    }
    if (sub_1004D1284((uint64_t)v38, "Qzss", buf)) {
      a4[3] = sub_101029558((const void **)&buf[0].__r_.__value_.__l.__data_);
    }
    if (sub_1004D1284((uint64_t)v38, "Sbas", buf)) {
      a4[4] = sub_101029558((const void **)&buf[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    BOOL v12 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v13 = a2;
      }
      else {
        std::string::size_type v13 = *(void *)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings %s: No EnableAdditionalAssistedConstellations dict found, using default", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v32 = a2;
      }
      else {
        std::string::size_type v32 = *(void *)a2;
      }
      int v39 = 136315138;
      std::string::size_type v40 = v32;
      __int16 v33 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v33);
      if (v33 != buf) {
        free(v33);
      }
    }
  }
  sub_100103240();
  if (sub_10073CAD0())
  {
    sub_1000E9354(v37);
    if (sub_100012960(a3, "LPPRel13WlanMeas", v37))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v14 = qword_1024193E8;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT);
      if (v15)
      {
        uint64_t v16 = sub_1000E9358((uint64_t)v37);
        buf[0].__r_.__value_.__r.__words[0] = 68289282;
        LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(buf[0].__r_.__value_.__r.__words[2]) = 2114;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 4) = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,#EmergSettings,#wlan,LPPRel13WlanMeas configured using CB\", \"LPPRel13WlanMeas:\":%{public, location:escape_only}@}", (uint8_t *)buf, 0x1Cu);
      }
      sub_1010297D8(v15, a2, (uint64_t)v37, a4);
    }
    else
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v19 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v20 = a2;
        }
        else {
          std::string::size_type v20 = *(void *)a2;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#wlan,%s,No LPPRel13WlanMeas dict found, using default", (uint8_t *)buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v34 = a2;
        }
        else {
          std::string::size_type v34 = *(void *)a2;
        }
        int v39 = 136315138;
        std::string::size_type v40 = v34;
        __int16 v35 = (std::string *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v35);
        if (v35 != buf) {
          free(v35);
        }
      }
    }
    uint64_t v21 = a4 + 9;
    if (sub_1004D0870(a3, "LPPRel13LocationSource", v21))
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v22 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v23 = a2;
        }
        else {
          std::string::size_type v23 = *(void *)a2;
        }
        int v24 = *v21;
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v23;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,LPPRel13LocationSource configured using CB:,%d", (uint8_t *)buf, 0x12u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_93;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v25 = a2;
      }
      else {
        std::string::size_type v25 = *(void *)a2;
      }
      int v26 = *v21;
      int v39 = 136315394;
      std::string::size_type v40 = v25;
      __int16 v41 = 1024;
      int v42 = v26;
      uint64_t v27 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v27);
    }
    else
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned __int8 v28 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v29 = a2;
        }
        else {
          std::string::size_type v29 = *(void *)a2;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,No LPPRel13LocationSource flag found, using default", (uint8_t *)buf, 0xCu);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_93;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v36 = a2;
      }
      else {
        std::string::size_type v36 = *(void *)a2;
      }
      int v39 = 136315138;
      std::string::size_type v40 = v36;
      uint64_t v27 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v27);
    }
    if (v27 != buf) {
      free(v27);
    }
LABEL_93:
    sub_10013F3C4(v37);
    return sub_10013F3C4(v38);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  int v17 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,LPPRel13,unsupported", (uint8_t *)buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    LOWORD(v39) = 0;
    __int16 v18 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readPlaneKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", (const char *)v18);
    if (v18 != buf) {
      free(v18);
    }
  }
  return sub_10013F3C4(v38);
}

void sub_10102835C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

uint64_t sub_1010283BC(int *a1)
{
  sub_10010F274((uint64_t)v35);
  sub_100132EFC(v36, (uint64_t)"enableMSAssisted,", 17);
  uint64_t v2 = (void *)std::ostream::operator<<();
  CFStringRef v3 = sub_100132EFC(v2, (uint64_t)",glonass,", 9);
  sub_10102FDC4(a1[1], v33);
  if ((v34 & 0x80u) == 0) {
    int v4 = v33;
  }
  else {
    int v4 = (void **)v33[0];
  }
  if ((v34 & 0x80u) == 0) {
    uint64_t v5 = v34;
  }
  else {
    uint64_t v5 = (uint64_t)v33[1];
  }
  uint64_t v6 = sub_100132EFC(v3, (uint64_t)v4, v5);
  uint64_t v7 = sub_100132EFC(v6, (uint64_t)",beidou,", 8);
  sub_10102FDC4(a1[5], v31);
  if ((v32 & 0x80u) == 0) {
    std::string::size_type v8 = v31;
  }
  else {
    std::string::size_type v8 = (void **)v31[0];
  }
  if ((v32 & 0x80u) == 0) {
    uint64_t v9 = v32;
  }
  else {
    uint64_t v9 = (uint64_t)v31[1];
  }
  int v10 = sub_100132EFC(v7, (uint64_t)v8, v9);
  std::string::size_type v11 = sub_100132EFC(v10, (uint64_t)",galileo,", 9);
  sub_10102FDC4(a1[2], v29);
  if ((v30 & 0x80u) == 0) {
    BOOL v12 = v29;
  }
  else {
    BOOL v12 = (void **)v29[0];
  }
  if ((v30 & 0x80u) == 0) {
    uint64_t v13 = v30;
  }
  else {
    uint64_t v13 = (uint64_t)v29[1];
  }
  BOOL v14 = sub_100132EFC(v11, (uint64_t)v12, v13);
  BOOL v15 = sub_100132EFC(v14, (uint64_t)",qzss,", 6);
  sub_10102FDC4(a1[3], v27);
  if ((v28 & 0x80u) == 0) {
    uint64_t v16 = v27;
  }
  else {
    uint64_t v16 = (void **)v27[0];
  }
  if ((v28 & 0x80u) == 0) {
    uint64_t v17 = v28;
  }
  else {
    uint64_t v17 = (uint64_t)v27[1];
  }
  __int16 v18 = sub_100132EFC(v15, (uint64_t)v16, v17);
  uint64_t v19 = sub_100132EFC(v18, (uint64_t)",lppRel13MeasSettings,", 22);
  sub_10103002C((uint64_t)(a1 + 6));
  if ((v26 & 0x80u) == 0) {
    std::string::size_type v20 = __p;
  }
  else {
    std::string::size_type v20 = (void **)__p[0];
  }
  if ((v26 & 0x80u) == 0) {
    uint64_t v21 = v26;
  }
  else {
    uint64_t v21 = (uint64_t)__p[1];
  }
  uint64_t v22 = sub_100132EFC(v19, (uint64_t)v20, v21);
  sub_100132EFC(v22, (uint64_t)",enableLocationSource,", 22);
  std::ostream::operator<<();
  if ((char)v26 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v28 < 0) {
    operator delete(v27[0]);
  }
  if ((char)v30 < 0) {
    operator delete(v29[0]);
  }
  if ((char)v32 < 0) {
    operator delete(v31[0]);
  }
  if ((char)v34 < 0) {
    operator delete(v33[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v35
  v36[0] = v23;
  if (v37 < 0) {
    operator delete((void *)v36[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1010286FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_101A129A8((uint64_t)&a39);
  _Unwind_Resume(a1);
}

uint64_t sub_10102879C(uint64_t a1, std::string::size_type a2, uint64_t a3, uint64_t a4)
{
  sub_1000E9354(v29);
  if (sub_100012960(a3, "CDMA", v29))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v7 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = sub_1000E9358((uint64_t)v29);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)std::string::size_type v36 = 0;
      *(_WORD *)&v36[4] = 2082;
      *(void *)&v36[6] = "";
      *(_WORD *)&v36[14] = 2114;
      *(void *)&v36[16] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,#EmergSettings,CDMA settings configured configured using CB\", \"CDMA:\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    if ((sub_1000D2988((uint64_t)v29, "ProvideHELOUnsolicited", (BOOL *)a4) & 1) == 0)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      uint64_t v9 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v10 = a2;
        }
        else {
          std::string::size_type v10 = *(void *)a2;
        }
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)std::string::size_type v36 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,%s,No CDMA.ProvideHELOUnsolicited field in CB, using default", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v26 = a2;
        }
        else {
          std::string::size_type v26 = *(void *)a2;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v26;
        uint64_t v27 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readCDMAKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::CDMASettings &) const", "%s\n", v27);
        if (v27 != (char *)buf) {
          free(v27);
        }
      }
    }
    if (sub_10073CB50())
    {
      memset(&__p, 0, sizeof(__p));
      if (sub_1004D1284((uint64_t)v29, "MeasurementTimeStampSource", &__p))
      {
        *(_DWORD *)(a4 + 4) = sub_10102A3D4((const void **)&__p.__r_.__value_.__l.__data_);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        std::string::size_type v11 = qword_1024193E8;
        if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            std::string::size_type v12 = a2;
          }
          else {
            std::string::size_type v12 = *(void *)a2;
          }
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)uint64_t buf = 136315394;
          *(void *)std::string::size_type v36 = v12;
          *(_WORD *)&v36[8] = 2080;
          *(void *)&v36[10] = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,%s,CDMA.MeasurementTimeStampSource,%s", buf, 0x16u);
        }
        if (!sub_10013D1A0(115, 2)) {
          goto LABEL_71;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v14 = a2;
        }
        else {
          std::string::size_type v14 = *(void *)a2;
        }
        BOOL v15 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          BOOL v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        int v30 = 136315394;
        std::string::size_type v31 = v14;
        __int16 v32 = 2080;
        __int16 v33 = v15;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readCDMAKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::CDMASettings &) const", "%s\n", v16);
      }
      else
      {
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        uint64_t v23 = qword_1024193E8;
        if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            std::string::size_type v24 = a2;
          }
          else {
            std::string::size_type v24 = *(void *)a2;
          }
          *(_DWORD *)uint64_t buf = 136315138;
          *(void *)std::string::size_type v36 = v24;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,%s,No CDMA.MeasurementTimeStampSource field found, using default", buf, 0xCu);
        }
        if (!sub_10013D1A0(115, 2)) {
          goto LABEL_71;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v28 = a2;
        }
        else {
          std::string::size_type v28 = *(void *)a2;
        }
        int v30 = 136315138;
        std::string::size_type v31 = v28;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readCDMAKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::CDMASettings &) const", "%s\n", v16);
      }
      if (v16 != (char *)buf) {
        free(v16);
      }
LABEL_71:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return sub_10013F3C4(v29);
    }
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    std::string::size_type v20 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v21 = a2;
      }
      else {
        std::string::size_type v21 = *(void *)a2;
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)std::string::size_type v36 = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,%s,TimestampSourceConfig not supported on this platform", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v19 = a2;
      }
      else {
        std::string::size_type v19 = *(void *)a2;
      }
LABEL_61:
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v19;
      uint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readCDMAKeys(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::CDMASettings &) const", "%s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v17 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v18 = a2;
      }
      else {
        std::string::size_type v18 = *(void *)a2;
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)std::string::size_type v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettingss,%s,No CDMA dict found, using default", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v19 = a2;
      }
      else {
        std::string::size_type v19 = *(void *)a2;
      }
      goto LABEL_61;
    }
  }
  return sub_10013F3C4(v29);
}

void sub_101029034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_10013F3C4(&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_101029080(uint64_t a1)
{
  sub_10010F274((uint64_t)v10);
  sub_100132EFC(v11, (uint64_t)"provideHELOUnsolicited,", 23);
  uint64_t v2 = (void *)std::ostream::operator<<();
  CFStringRef v3 = sub_100132EFC(v2, (uint64_t)",timeStampSource,", 17);
  sub_101030488(*(_DWORD *)(a1 + 4), __p);
  if ((v9 & 0x80u) == 0) {
    int v4 = __p;
  }
  else {
    int v4 = (void **)__p[0];
  }
  if ((v9 & 0x80u) == 0) {
    uint64_t v5 = v9;
  }
  else {
    uint64_t v5 = (uint64_t)__p[1];
  }
  sub_100132EFC(v3, (uint64_t)v4, v5);
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v10
  v11[0] = v6;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101029258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_101A129A8((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_101029288(uint64_t a1)
{
  sub_10010F274((uint64_t)v21);
  uint64_t v2 = sub_100132EFC(v22, (uint64_t)"#AML,", 5);
  sub_1010306C4(a1);
  if ((v20 & 0x80u) == 0) {
    CFStringRef v3 = v19;
  }
  else {
    CFStringRef v3 = (void **)v19[0];
  }
  if ((v20 & 0x80u) == 0) {
    uint64_t v4 = v20;
  }
  else {
    uint64_t v4 = (uint64_t)v19[1];
  }
  uint64_t v5 = sub_100132EFC(v2, (uint64_t)v3, v4);
  uint64_t v6 = sub_100132EFC(v5, (uint64_t)",#EED2,", 7);
  sub_101030B20(a1 + 152);
  if ((v18 & 0x80u) == 0) {
    uint64_t v7 = v17;
  }
  else {
    uint64_t v7 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    uint64_t v8 = v18;
  }
  else {
    uint64_t v8 = (uint64_t)v17[1];
  }
  unsigned __int8 v9 = sub_100132EFC(v6, (uint64_t)v7, v8);
  std::string::size_type v10 = sub_100132EFC(v9, (uint64_t)",#EED2-sim,", 11);
  sub_101030B20(a1 + 488);
  if ((v16 & 0x80u) == 0) {
    std::string::size_type v11 = __p;
  }
  else {
    std::string::size_type v11 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v12 = v16;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  sub_100132EFC(v10, (uint64_t)v11, v12);
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v18 < 0) {
    operator delete(v17[0]);
  }
  if ((char)v20 < 0) {
    operator delete(v19[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v21
  v22[0] = v13;
  if (v23 < 0) {
    operator delete((void *)v22[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1010294F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_101A129A8((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_101029558(const void **a1)
{
  uint64_t v2 = 0;
  *(void *)std::string::size_type v21 = &_mh_execute_header;
  *(_DWORD *)&v21[8] = 2;
  while (1)
  {
    uint64_t v3 = *(unsigned int *)&v21[v2];
    sub_10102FDC4(*(_DWORD *)&v21[v2], &buf);
    int v4 = *((char *)a1 + 23);
    int v5 = (char)v20;
    uint64_t v6 = (void *)buf;
    if ((v20 & 0x80u) == 0) {
      size_t v7 = v20;
    }
    else {
      size_t v7 = *((void *)&buf + 1);
    }
    if ((v20 & 0x80u) == 0) {
      p_long long buf = &buf;
    }
    else {
      p_long long buf = (long long *)buf;
    }
    if (v4 >= 0) {
      size_t v9 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      size_t v9 = (size_t)a1[1];
    }
    if (v4 >= 0) {
      std::string::size_type v10 = a1;
    }
    else {
      std::string::size_type v10 = *a1;
    }
    if (v9 >= v7) {
      size_t v11 = v7;
    }
    else {
      size_t v11 = v9;
    }
    BOOL v12 = memcmp(p_buf, v10, v11) == 0;
    BOOL v13 = v9 == v7 && v12;
    if (v5 < 0) {
      operator delete(v6);
    }
    if (v13) {
      break;
    }
    v2 += 4;
    if (v2 == 12)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      std::string::size_type v14 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_FAULT))
      {
        if (*((char *)a1 + 23) >= 0) {
          BOOL v15 = a1;
        }
        else {
          BOOL v15 = (void *)*a1;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "unknown constellationUsage %s\n", (uint8_t *)&buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        if (*((char *)a1 + 23) >= 0) {
          uint64_t v17 = a1;
        }
        else {
          uint64_t v17 = (void *)*a1;
        }
        *(_DWORD *)std::string::size_type v21 = 136315138;
        *(void *)&_DWORD v21[4] = v17;
        unsigned __int8 v18 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static ConstellationUsage CLEmergencyController::LocationSettings::Emergency::Settings::constellationUsagefromString(const std::string &)", "%s\n", v18);
        if (v18 != (char *)&buf) {
          free(v18);
        }
      }
      return 0;
    }
  }
  return v3;
}

void sub_1010297D8(uint64_t a1, std::string::size_type a2, uint64_t a3, _DWORD *a4)
{
  size_t v7 = a4 + 6;
  if (sub_1004D0870(a3, "Enabled", a4 + 6))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v9 = a2;
      }
      else {
        std::string::size_type v9 = *(void *)a2;
      }
      int v10 = *v7;
      *(_DWORD *)long long buf = 136315394;
      std::string::size_type v32 = v9;
      __int16 v33 = 1024;
      LODWORD(v34) = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,LPPRel13WlanMeas.Enable,%d,", buf, 0x12u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v11 = a2;
      }
      else {
        std::string::size_type v11 = *(void *)a2;
      }
      int v12 = *v7;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v11;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v12;
      BOOL v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLppRel13WlanSettings(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", v13);
LABEL_79:
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    std::string::size_type v14 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v15 = a2;
      }
      else {
        std::string::size_type v15 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      std::string::size_type v32 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,No LPPRel13WlanMeas.Enable field in CB, using default", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      if (*(char *)(a2 + 23) >= 0) {
        std::string::size_type v27 = a2;
      }
      else {
        std::string::size_type v27 = *(void *)a2;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v27;
      BOOL v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLppRel13WlanSettings(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", v13);
      goto LABEL_79;
    }
  }
  if (*v7)
  {
    memset(&__p, 0, sizeof(__p));
    if (sub_1004D1284(a3, "ScanResultConfig", &__p))
    {
      a4[7] = sub_10102A194((const void **)&__p.__r_.__value_.__l.__data_);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      unsigned __int8 v16 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v17 = a2;
        }
        else {
          std::string::size_type v17 = *(void *)a2;
        }
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136315394;
        std::string::size_type v32 = v17;
        __int16 v33 = 2080;
        unsigned __int8 v34 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,LPPRel13WlanMeas.ScanResultConfig,%s", buf, 0x16u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_61;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1)
      {
LABEL_82:
        std::string::size_type v28 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLppRel13WlanSettings(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", v28);
        if (v28 != (char *)buf) {
          free(v28);
        }
LABEL_61:
        if ((sub_1004D0870(a3, "EnableRssi", a4 + 8) & 1) == 0)
        {
          if (qword_1024193E0 != -1) {
            dispatch_once(&qword_1024193E0, &stru_10230B640);
          }
          std::string::size_type v25 = qword_1024193E8;
          if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a2 + 23) >= 0) {
              std::string::size_type v26 = a2;
            }
            else {
              std::string::size_type v26 = *(void *)a2;
            }
            *(_DWORD *)long long buf = 136315138;
            std::string::size_type v32 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,No LPPRel13WlanMeas.EnableRssi field in CB, using default", buf, 0xCu);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1024193E0 != -1) {
              dispatch_once(&qword_1024193E0, &stru_10230B640);
            }
            std::string::size_type v29 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLppRel13WlanSettings(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", v29);
            if (v29 != (char *)buf) {
              free(v29);
            }
          }
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        return;
      }
    }
    else
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      char v23 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          std::string::size_type v24 = a2;
        }
        else {
          std::string::size_type v24 = *(void *)a2;
        }
        *(_DWORD *)long long buf = 136315138;
        std::string::size_type v32 = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,No LPPRel13WlanMeas.ScanResultConfig field found, using default", buf, 0xCu);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_61;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 == -1) {
        goto LABEL_82;
      }
    }
    dispatch_once(&qword_1024193E0, &stru_10230B640);
    goto LABEL_82;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  std::string::size_type v19 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v20 = a2;
    }
    else {
      std::string::size_type v20 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    std::string::size_type v32 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#wlan,%s,LPPRel13WlanMeas feature is disabled", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v21 = a2;
    }
    else {
      std::string::size_type v21 = *(void *)a2;
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v21;
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::readLppRel13WlanSettings(const std::string &, const CLNameValuePair &, LocationSettings::Emergency::Settings &) const", "%s\n", v22);
    if (v22 != (char *)buf) {
      free(v22);
    }
  }
}

void sub_10102A164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10102A194(const void **a1)
{
  uint64_t v2 = 0;
  std::string::size_type v20 = &_mh_execute_header;
  while (1)
  {
    uint64_t v3 = *(unsigned int *)((char *)&v20 + v2);
    sub_10103024C(*(_DWORD *)((char *)&v20 + v2), buf);
    int v4 = *((char *)a1 + 23);
    int v5 = (char)v19;
    uint64_t v6 = *(uint8_t **)buf;
    if ((v19 & 0x80u) == 0) {
      size_t v7 = v19;
    }
    else {
      size_t v7 = v18;
    }
    if ((v19 & 0x80u) == 0) {
      uint64_t v8 = buf;
    }
    else {
      uint64_t v8 = *(uint8_t **)buf;
    }
    if (v4 >= 0) {
      size_t v9 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      size_t v9 = (size_t)a1[1];
    }
    if (v4 >= 0) {
      int v10 = a1;
    }
    else {
      int v10 = *a1;
    }
    if (v9 >= v7) {
      size_t v11 = v7;
    }
    else {
      size_t v11 = v9;
    }
    BOOL v12 = memcmp(v8, v10, v11) == 0;
    BOOL v13 = v9 == v7 && v12;
    if (v5 < 0) {
      operator delete(v6);
    }
    if (v13) {
      break;
    }
    v2 += 4;
    if (v2 == 8)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      std::string::size_type v14 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "#wlan,apConfigFromString,unexpected config", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        LOWORD(v2sub_100FB8FC8(&a9, 0) = 0;
        unsigned __int8 v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static AccessPointConfig CLEmergencyController::LocationSettings::Emergency::Settings::apConfigFromString(const std::string &)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t sub_10102A3D4(const void **a1)
{
  uint64_t v2 = 0;
  std::string::size_type v20 = &_mh_execute_header;
  while (1)
  {
    uint64_t v3 = *(unsigned int *)((char *)&v20 + v2);
    sub_101030488(*(_DWORD *)((char *)&v20 + v2), buf);
    int v4 = *((char *)a1 + 23);
    int v5 = (char)v19;
    uint64_t v6 = *(uint8_t **)buf;
    if ((v19 & 0x80u) == 0) {
      size_t v7 = v19;
    }
    else {
      size_t v7 = v18;
    }
    if ((v19 & 0x80u) == 0) {
      uint64_t v8 = buf;
    }
    else {
      uint64_t v8 = *(uint8_t **)buf;
    }
    if (v4 >= 0) {
      size_t v9 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      size_t v9 = (size_t)a1[1];
    }
    if (v4 >= 0) {
      int v10 = a1;
    }
    else {
      int v10 = *a1;
    }
    if (v9 >= v7) {
      size_t v11 = v7;
    }
    else {
      size_t v11 = v9;
    }
    BOOL v12 = memcmp(v8, v10, v11) == 0;
    BOOL v13 = v9 == v7 && v12;
    if (v5 < 0) {
      operator delete(v6);
    }
    if (v13) {
      break;
    }
    v2 += 4;
    if (v2 == 8)
    {
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      std::string::size_type v14 = qword_1024193E8;
      if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "measTimeStampSourceFromString,unexpected source", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        LOWORD(v2sub_100FB8FC8(&a9, 0) = 0;
        unsigned __int8 v16 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static MeasurementTimeStampSource CLEmergencyController::LocationSettings::Emergency::measTimeStampSourceFromString(const std::string &)", "%s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
      return 0;
    }
  }
  return v3;
}

size_t sub_10102A614(void *a1, void *a2, int a3)
{
  int v4 = a2;
  int v5 = a1;
  if (a3) {
    sub_101032120((std::locale *)v24, (uint64_t)a2, 0);
  }
  if (*((char *)a1 + 23) < 0)
  {
    size_t v6 = a1[1];
    if (!v6) {
      goto LABEL_19;
    }
    a1 = (void *)*a1;
  }
  else
  {
    size_t v6 = *((unsigned __int8 *)a1 + 23);
    if (!*((unsigned char *)a1 + 23)) {
      goto LABEL_19;
    }
  }
  int v7 = *((char *)a2 + 23);
  if (v7 >= 0) {
    size_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v8 = a2[1];
  }
  if (v7 < 0) {
    a2 = (void *)*a2;
  }
  if (v8 >= v6) {
    size_t v9 = v6;
  }
  else {
    size_t v9 = v8;
  }
  BOOL v10 = memcmp(a1, a2, v9) == 0;
  size_t v6 = v8 == v6 && v10;
LABEL_19:
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  size_t v11 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)v5 + 23) >= 0) {
      BOOL v12 = v5;
    }
    else {
      BOOL v12 = (void *)*v5;
    }
    if (*((char *)v4 + 23) >= 0) {
      BOOL v13 = v4;
    }
    else {
      BOOL v13 = (void *)*v4;
    }
    int __p = 136315906;
    __p_4 = v12;
    __int16 __p_12 = 2080;
    __p_14 = v13;
    __int16 v35 = 1024;
    int v36 = 0;
    __int16 v37 = 1024;
    int v38 = v6;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: haystack,%s,needle,%s,allowWildCard,%d,match,%d", (uint8_t *)&__p, 0x22u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    if (*((char *)v5 + 23) >= 0) {
      std::string::size_type v21 = v5;
    }
    else {
      std::string::size_type v21 = (void *)*v5;
    }
    if (*((char *)v4 + 23) >= 0) {
      uint64_t v22 = v4;
    }
    else {
      uint64_t v22 = (void *)*v4;
    }
    *(_DWORD *)std::string::size_type v24 = 136315906;
    *(void *)&void v24[4] = v21;
    __int16 v25 = 2080;
    std::string::size_type v26 = v22;
    __int16 v27 = 1024;
    int v28 = 0;
    __int16 v29 = 1024;
    int v30 = v6;
    char v23 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencySettingsUtilities::stringMatch(const std::string &, const std::string &, BOOL)", "%s\n", v23);
    if (v23 != (char *)&__p) {
      free(v23);
    }
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  std::string::size_type v14 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)v5 + 23) >= 0) {
      std::string::size_type v15 = v5;
    }
    else {
      std::string::size_type v15 = (void *)*v5;
    }
    if (*((char *)v4 + 23) >= 0) {
      unsigned __int8 v16 = v4;
    }
    else {
      unsigned __int8 v16 = (void *)*v4;
    }
    int __p = 136315906;
    __p_4 = v15;
    __int16 __p_12 = 2080;
    __p_14 = v16;
    __int16 v35 = 1024;
    int v36 = a3;
    __int16 v37 = 1024;
    int v38 = v6;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: haystack,%s,needle,%s,allowWildCard,%d,match,%d", (uint8_t *)&__p, 0x22u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    if (*((char *)v5 + 23) >= 0) {
      size_t v18 = v5;
    }
    else {
      size_t v18 = (void *)*v5;
    }
    if (*((char *)v4 + 23) >= 0) {
      unsigned __int8 v19 = v4;
    }
    else {
      unsigned __int8 v19 = (void *)*v4;
    }
    *(_DWORD *)std::string::size_type v24 = 136315906;
    *(void *)&void v24[4] = v18;
    __int16 v25 = 2080;
    std::string::size_type v26 = v19;
    __int16 v27 = 1024;
    int v28 = a3;
    __int16 v29 = 1024;
    int v30 = v6;
    std::string::size_type v20 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencySettingsUtilities::stringMatch(const std::string &, const std::string &, BOOL)", "%s\n", v20);
    if (v20 != (char *)&__p) {
      free(v20);
    }
  }
  return v6;
}

#error "10102ACB4: call analysis failed (funcsize=109)"

size_t sub_10102AD10(uint64_t *a1, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      sub_10102B020();
      int v4 = &qword_1024829C0;
    }
    else
    {
      sub_10102AF7C();
      int v4 = &qword_1024829A0;
    }
  }
  else if (a2)
  {
    sub_10102B0C4();
    int v4 = &qword_1024829E0;
  }
  else
  {
    sub_10102B168();
    int v4 = &qword_102482A00;
  }
  size_t v5 = sub_10102A614(a1, v4, 1);
  if ((v5 & 1) == 0)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    size_t v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a1 + 23) >= 0) {
        int v7 = a1;
      }
      else {
        int v7 = (uint64_t *)*a1;
      }
      uint64_t v8 = (uint64_t)v4;
      if (*((char *)v4 + 23) < 0) {
        uint64_t v8 = *v4;
      }
      *(_DWORD *)long long buf = 136315394;
      BOOL v12 = v7;
      __int16 v13 = 2080;
      uint64_t v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#EmergCon,#EmergSettings,#supl #Warning SUPL: [%s], failed to match [%s]", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencySettingsUtilities::validHslpAddressSpecification(const std::string &, BOOL, BOOL)", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return v5;
}

uint64_t *sub_10102AF7C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024829B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1024829B8))
  {
    sub_100134750(&qword_1024829A0, "^[-[:alnum:]_]+[-[:alnum:]_.]*[.][-[:alnum:]_]+$");
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1024829A0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1024829B8);
  }
  return &qword_1024829A0;
}

void sub_10102B008(_Unwind_Exception *a1)
{
}

uint64_t *sub_10102B020()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024829D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1024829D8))
  {
    sub_100134750(&qword_1024829C0, "^[-[:alnum:]_]+([-[:alnum:]_.*]+)?[.][-[:alnum:]_]+$");
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1024829C0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1024829D8);
  }
  return &qword_1024829C0;
}

void sub_10102B0AC(_Unwind_Exception *a1)
{
}

uint64_t *sub_10102B0C4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1024829F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1024829F8))
  {
    sub_100134750(&qword_1024829E0, "^e-slp[.]([-[:alnum:]_.*]+[.])?[-[:alnum:]_]+$");
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1024829E0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1024829F8);
  }
  return &qword_1024829E0;
}

void sub_10102B150(_Unwind_Exception *a1)
{
}

uint64_t *sub_10102B168()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102482A18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102482A18))
  {
    sub_100134750(&qword_102482A00, "^e-slp[.]([-[:alnum:]_.]+[.])?[-[:alnum:]_]+$");
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_102482A00, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102482A18);
  }
  return &qword_102482A00;
}

void sub_10102B1F4(_Unwind_Exception *a1)
{
}

uint64_t *sub_10102B20C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102482A38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102482A38))
  {
    sub_100134750(&qword_102482A20, "[^-[:alnum:]_.]|([^-[:alnum:]_][^-[:alnum:]_]+)");
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_102482A20, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102482A38);
  }
  return &qword_102482A20;
}

void sub_10102B298(_Unwind_Exception *a1)
{
}

BOOL sub_10102B2B0(uint64_t *a1, uint64_t a2, int a3)
{
  sub_10102B20C();
  if (sub_10102A614(a1, &qword_102482A20, 1))
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    size_t v6 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a1 + 23) >= 0) {
        int v7 = a1;
      }
      else {
        int v7 = (uint64_t *)*a1;
      }
      sub_10102B20C();
      if (byte_102482A37 >= 0) {
        uint64_t v8 = &qword_102482A20;
      }
      else {
        uint64_t v8 = (uint64_t *)qword_102482A20;
      }
      *(_DWORD *)long long buf = 136315394;
      std::string::size_type v15 = v7;
      __int16 v16 = 2080;
      std::string::size_type v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: [%s] matched invalidSpecification [%s]", buf, 0x16u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      sub_10102B20C();
      BOOL v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencySettingsUtilities::validHslpAddress(const std::string &, const std::string &, BOOL)", "%s\n", v10);
      if (v10 == (char *)buf) {
        return 0;
      }
      goto LABEL_16;
    }
  }
  else if (sub_10102A614(a1, (void *)a2, a3))
  {
    return 1;
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    size_t v11 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a1 + 23) >= 0) {
        BOOL v12 = a1;
      }
      else {
        BOOL v12 = (uint64_t *)*a1;
      }
      if (*(char *)(a2 + 23) >= 0) {
        __int16 v13 = (uint64_t *)a2;
      }
      else {
        __int16 v13 = *(uint64_t **)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      std::string::size_type v15 = v12;
      __int16 v16 = 2080;
      std::string::size_type v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#EmergCon,#EmergSettings,#supl SUPL: [%s], failed to match [%s]", buf, 0x16u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      BOOL v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLEmergencySettingsUtilities::validHslpAddress(const std::string &, const std::string &, BOOL)", "%s\n", v10);
      if (v10 == (char *)buf) {
        return 0;
      }
LABEL_16:
      free(v10);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10102B6A8(uint64_t a1, int a2, int a3, int a4)
{
  if (a2) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = a3 == 3;
  }
  int v5 = v4;
  if (v5 == 1 && a4 == 0) {
    return 1;
  }
  BOOL v7 = !a2 && a3 == 1;
  BOOL v8 = !v7;
  if (v7 && !a4) {
    return 1;
  }
  BOOL v9 = !a2 && a3 == 4;
  int v10 = v9;
  if (v9 && !a4) {
    return 1;
  }
  if (a2) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = a3 == 2;
  }
  int v13 = v12;
  if (v12 && !a4) {
    return 4;
  }
  BOOL v14 = !a2 && a3 == 5;
  BOOL v15 = !v14;
  if (v14 && !a4) {
    return 4;
  }
  BOOL v16 = a2 == 1 && a3 == 3;
  int v17 = v16;
  if (v16 && !a4) {
    return 6;
  }
  BOOL v18 = a2 == 1 && a3 == 1;
  BOOL v19 = !v18;
  if (v18 && !a4) {
    return 6;
  }
  BOOL v20 = a2 == 1 && a3 == 4;
  BOOL v21 = v20;
  if (v20 && !a4) {
    return 6;
  }
  BOOL v22 = a2 == 1 && a3 == 2;
  int v23 = !v22;
  if (v22 && !a4) {
    return 9;
  }
  BOOL v24 = a2 == 1 && a3 == 5;
  BOOL v25 = !v24;
  if (v24 && !a4) {
    return 9;
  }
  int v26 = a4 ^ 1;
  if (v10 == (v5 ^ v8) && !v26) {
    return 11;
  }
  if ((v13 ^ v15 | v26) != 1) {
    return 13;
  }
  if ((v21 ^ v17 ^ v19 | v26) != 1) {
    return 12;
  }
  uint64_t result = 14;
  if ((v26 | v23) == 1)
  {
    if (v26 | v25) {
      return 0;
    }
    else {
      return 14;
    }
  }
  return result;
}

uint64_t sub_10102B804(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = -1;
  uint64_t v4 = a1 + 8;
  if (byte_10248B14F < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 8), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  }
  else
  {
    long long v5 = xmmword_10248B138;
    *(void *)(a1 + 24) = unk_10248B148;
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(_WORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = -1;
  *(unsigned char *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  size_t v6 = (unsigned char *)(a1 + 48);
  if ((byte_10248B14F & 0x80000000) == 0)
  {
    *(_OWORD *)size_t v6 = xmmword_10248B138;
    *(void *)(a1 + 64) = unk_10248B148;
    uint64_t v7 = a1 + 72;
LABEL_7:
    *(_OWORD *)uint64_t v7 = xmmword_10248B138;
    *(void *)(v7 + 16) = unk_10248B148;
    uint64_t v8 = a1 + 96;
LABEL_8:
    *(_OWORD *)uint64_t v8 = xmmword_10248B138;
    *(void *)(v8 + 16) = unk_10248B148;
    uint64_t v9 = a1 + 120;
LABEL_9:
    *(_OWORD *)uint64_t v9 = xmmword_10248B138;
    *(void *)(v9 + 16) = unk_10248B148;
    *(_DWORD *)(a1 + 144) = 0;
    uint64_t v10 = a1 + 152;
LABEL_10:
    *(_OWORD *)uint64_t v10 = xmmword_10248B138;
    *(void *)(v10 + 16) = unk_10248B148;
    uint64_t v11 = a1 + 176;
LABEL_11:
    *(_OWORD *)uint64_t v11 = xmmword_10248B138;
    *(void *)(v11 + 16) = unk_10248B148;
    *(_DWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
    uint64_t v12 = a1 + 208;
LABEL_12:
    *(_OWORD *)uint64_t v12 = xmmword_10248B138;
    *(void *)(v12 + 16) = unk_10248B148;
    uint64_t v13 = a1 + 232;
LABEL_13:
    *(_OWORD *)uint64_t v13 = xmmword_10248B138;
    *(void *)(v13 + 16) = unk_10248B148;
    *(_DWORD *)(a1 + 256) = 0;
    uint64_t v14 = a1 + 264;
LABEL_14:
    *(_OWORD *)uint64_t v14 = xmmword_10248B138;
    *(void *)(v14 + 16) = unk_10248B148;
    uint64_t v15 = a1 + 288;
LABEL_15:
    *(_OWORD *)uint64_t v15 = xmmword_10248B138;
    *(void *)(v15 + 16) = unk_10248B148;
    *(_DWORD *)(a1 + 312) = 0;
    uint64_t v16 = a1 + 320;
LABEL_16:
    *(_OWORD *)uint64_t v16 = xmmword_10248B138;
    *(void *)(v16 + 16) = unk_10248B148;
    uint64_t v17 = a1 + 344;
LABEL_17:
    *(_OWORD *)uint64_t v17 = xmmword_10248B138;
    *(void *)(v17 + 16) = unk_10248B148;
    *(_DWORD *)(a1 + 368) = 0;
    uint64_t v18 = a1 + 376;
LABEL_18:
    *(_OWORD *)uint64_t v18 = xmmword_10248B138;
    *(void *)(v18 + 16) = unk_10248B148;
    uint64_t v19 = a1 + 400;
LABEL_19:
    *(_OWORD *)uint64_t v19 = xmmword_10248B138;
    *(void *)(v19 + 16) = unk_10248B148;
    *(void *)(a1 + 424) = 0xFFFFFFFF00000000;
    *(_WORD *)(a1 + 432) = 0;
    uint64_t v20 = a1 + 440;
LABEL_20:
    *(_OWORD *)uint64_t v20 = xmmword_10248B138;
    *(void *)(v20 + 16) = unk_10248B148;
    uint64_t v21 = a1 + 464;
LABEL_21:
    *(_OWORD *)uint64_t v21 = xmmword_10248B138;
    *(void *)(v21 + 16) = unk_10248B148;
    uint64_t v22 = a1 + 488;
LABEL_22:
    *(_OWORD *)uint64_t v22 = xmmword_10248B138;
    *(void *)(v22 + 16) = unk_10248B148;
    goto LABEL_23;
  }
  sub_1000DC48C(v6, (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v7 = a1 + 72;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_1000DC48C((unsigned char *)(a1 + 72), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v8 = a1 + 96;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_8;
  }
  sub_1000DC48C((unsigned char *)(a1 + 96), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v9 = a1 + 120;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_9;
  }
  sub_1000DC48C((unsigned char *)(a1 + 120), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v34 = byte_10248B14F;
  *(_DWORD *)(a1 + 144) = 0;
  uint64_t v10 = a1 + 152;
  if ((v34 & 0x80000000) == 0) {
    goto LABEL_10;
  }
  sub_1000DC48C((unsigned char *)(a1 + 152), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v11 = a1 + 176;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_11;
  }
  sub_1000DC48C((unsigned char *)(a1 + 176), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v35 = byte_10248B14F;
  *(_DWORD *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  if ((v35 & 0x80000000) == 0)
  {
    uint64_t v12 = a1 + 208;
    goto LABEL_12;
  }
  sub_1000DC48C((unsigned char *)(a1 + 208), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v13 = a1 + 232;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_13;
  }
  sub_1000DC48C((unsigned char *)v13, (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v36 = byte_10248B14F;
  *(_DWORD *)(a1 + 256) = 0;
  if ((v36 & 0x80000000) == 0)
  {
    uint64_t v14 = a1 + 264;
    goto LABEL_14;
  }
  sub_1000DC48C((unsigned char *)(a1 + 264), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  if ((byte_10248B14F & 0x80000000) == 0)
  {
    uint64_t v15 = a1 + 288;
    goto LABEL_15;
  }
  sub_1000DC48C((unsigned char *)(a1 + 288), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v38 = byte_10248B14F;
  *(_DWORD *)(a1 + 312) = 0;
  if ((v38 & 0x80000000) == 0)
  {
    uint64_t v16 = a1 + 320;
    goto LABEL_16;
  }
  sub_1000DC48C((unsigned char *)(a1 + 320), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  if ((byte_10248B14F & 0x80000000) == 0)
  {
    uint64_t v17 = a1 + 344;
    goto LABEL_17;
  }
  sub_1000DC48C((unsigned char *)(a1 + 344), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v39 = byte_10248B14F;
  *(_DWORD *)(a1 + 368) = 0;
  if ((v39 & 0x80000000) == 0)
  {
    uint64_t v18 = a1 + 376;
    goto LABEL_18;
  }
  sub_1000DC48C((unsigned char *)(a1 + 376), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v19 = a1 + 400;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_19;
  }
  sub_1000DC48C((unsigned char *)(a1 + 400), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  int v40 = byte_10248B14F;
  *(void *)(a1 + 424) = 0xFFFFFFFF00000000;
  *(_WORD *)(a1 + 432) = 0;
  uint64_t v20 = a1 + 440;
  if ((v40 & 0x80000000) == 0) {
    goto LABEL_20;
  }
  sub_1000DC48C((unsigned char *)(a1 + 440), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v21 = a1 + 464;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_21;
  }
  sub_1000DC48C((unsigned char *)(a1 + 464), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
  uint64_t v22 = a1 + 488;
  if ((byte_10248B14F & 0x80000000) == 0) {
    goto LABEL_22;
  }
  sub_1000DC48C((unsigned char *)(a1 + 488), (void *)xmmword_10248B138, *((unint64_t *)&xmmword_10248B138 + 1));
LABEL_23:
  *(_WORD *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 516) = -1;
  *(unsigned char *)(a1 + 52sub_100FB8FC8(&a9, 0) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_DWORD *)(a1 + 60sub_100FB8FC8(&a9, 0) = 1065353216;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_DWORD *)(a1 + 64sub_100FB8FC8(&a9, 0) = 1065353216;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_DWORD *)(a1 + 68sub_100FB8FC8(&a9, 0) = 1065353216;
  *(void *)(a1 + 688) = 0;
  *(unsigned char *)(a1 + 696) = 0;
  *(void *)(a1 + 528) = a2;
  if (a2)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 544) = Current;
    sub_1010201C0(*(int64x2_t **)(a1 + 528), Current);
    BOOL v24 = +[NSDate dateWithTimeIntervalSinceReferenceDate:*(double *)(a1 + 544)];
    id v25 = objc_alloc_init((Class)NSDateFormatter);
    [v25 setLocale:[objc_alloc((Class)NSLocale) initWithLocaleIdentifier:@"en_US_POSIX"]];
    [v25 setTimeZone:[+[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone")]];
    [v25 setDateFormat:@"HH"];
    *(_DWORD *)a1 = [objc_msgSend(v25, "stringFromDate:", v24) intValue];
    if (objc_opt_class())
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10102C34C;
      block[3] = &unk_1022A3020;
      block[4] = a1;
      dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
    }
    int v26 = sub_10101AE34(*(unsigned int *)(*(void *)(a1 + 528) + 244));
    sub_10101A768(v26, buf);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)v4);
    }
    *(_OWORD *)uint64_t v4 = *(_OWORD *)buf;
    *(void *)(v4 + 16) = v44;
    uint64_t v27 = *(void *)(a1 + 528);
    *(unsigned char *)(a1 + 32) = (*(_DWORD *)(v27 + 244) < 0x12u) & (0x20280u >> *(_DWORD *)(v27 + 244));
    *(unsigned char *)(a1 + 4sub_100FB8FC8(&a9, 0) = *(unsigned char *)(v27 + 640);
    *(_DWORD *)(a1 + 44) = *(void *)(v27 + 632);
    if (objc_opt_class() && sub_10016CCBC())
    {
      *(unsigned char *)(a1 + 52sub_100FB8FC8(&a9, 0) = +[SOSUtilities shouldPlayAudioDuringCountdown];
      *(unsigned char *)(a1 + 512) = +[SOSUtilities isCallWithVolumeLockHoldEnabled];
      *(unsigned char *)(a1 + 513) = +[SOSUtilities isCallWithSideButtonPressesEnabled];
      *(_DWORD *)(a1 + 516) = +[SOSUtilities SOSTriggerClickCount];
    }
    sub_10102C5A0(*(_DWORD *)(*(void *)(a1 + 528) + 536), buf);
    if (*(char *)(a1 + 463) < 0) {
      operator delete(*(void **)v20);
    }
    long long v28 = *(_OWORD *)buf;
    *(void *)(v20 + 16) = v44;
    *(_OWORD *)uint64_t v20 = v28;
    if (*(_DWORD *)(*(void *)(a1 + 528) + 540)) {
      __int16 v29 = "Mounted";
    }
    else {
      __int16 v29 = "NotMounted";
    }
    sub_100134750(buf, v29);
    if (*(char *)(v21 + 23) < 0) {
      operator delete(*(void **)v21);
    }
    long long v30 = *(_OWORD *)buf;
    *(void *)(v21 + 16) = v44;
    *(_OWORD *)uint64_t v21 = v30;
    sub_10102C5B4(*(_DWORD *)(*(void *)(a1 + 528) + 544), buf);
    if (*(char *)(a1 + 511) < 0) {
      operator delete(*(void **)v22);
    }
    long long v31 = *(_OWORD *)buf;
    *(void *)(v22 + 16) = v44;
    *(_OWORD *)uint64_t v22 = v31;
    if (sub_10016CCBC()) {
      *(unsigned char *)(a1 + 433) = *(unsigned char *)(*(void *)(a1 + 528) + 516);
    }
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    std::string::size_type v32 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "#EmergCon,EmergencyCallTriggerMetric,Emergency Controller pointer is null", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v42 = 0;
      __int16 v37 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "CLEmergencyController::EmergencyCallTriggerMetric::EmergencyCallTriggerMetric(CLEmergencyController *)", "%s\n", v37);
      if (v37 != (char *)buf) {
        free(v37);
      }
    }
  }
  return a1;
}

void sub_10102C0C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, void **a12, uint64_t a13, void **a14, void **a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19, uint64_t a20,uint64_t a21,void **a22,void **a23)
{
  if (*(char *)(v25 + 23) < 0) {
    operator delete(*(void **)v25);
  }
  if (v23[463] < 0) {
    operator delete(*v27);
  }
  if (*(char *)(v26 + 23) < 0) {
    operator delete(*(void **)v26);
  }
  if (v23[399] < 0) {
    operator delete(*a12);
  }
  if (*(char *)(a13 + 23) < 0) {
    operator delete(*(void **)a13);
  }
  if (v23[343] < 0) {
    operator delete(*a19);
  }
  if (*(char *)(a20 + 23) < 0) {
    operator delete(*(void **)a20);
  }
  if (v23[287] < 0) {
    operator delete(*a22);
  }
  if (*(char *)(a21 + 23) < 0) {
    operator delete(*(void **)a21);
  }
  if (v23[231] < 0) {
    operator delete(*a23);
  }
  if (*(char *)(a18 + 23) < 0) {
    operator delete(*(void **)a18);
  }
  if (v23[175] < 0) {
    operator delete(*a14);
  }
  if (*(char *)(a16 + 23) < 0) {
    operator delete(*(void **)a16);
  }
  if (v23[119] < 0) {
    operator delete(*a15);
  }
  if (*(char *)(a17 + 23) < 0) {
    operator delete(*(void **)a17);
  }
  if (v23[71] < 0) {
    operator delete(*a11);
  }
  if (v23[31] < 0) {
    operator delete(*v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102C34C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(void *)(v1 + 688) = [+[SOSManager sharedInstance] currentSOSInteractiveState];
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v2 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(v1 + 688);
    *(_DWORD *)long long buf = 67109120;
    int v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,currentSOSInteractiveState, at call start is %d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v5 = *(void *)(v1 + 688);
    int v8 = 67109120;
    int v9 = v5;
    size_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLEmergencyController::EmergencyCallTriggerMetric::EmergencyCallTriggerMetric(CLEmergencyController *)_block_invoke", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t v4 = [objc_msgSend(*(id *)(*(void *)(v1 + 528) + 8), "silo") queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10102C574;
  block[3] = &unk_1022A3020;
  block[4] = v1;
  dispatch_async(v4, block);
}

uint64_t sub_10102C574(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(_DWORD *)(*(void *)(v1 + 528) + 244) == 5 && !*(void *)(v1 + 688)) {
    *(unsigned char *)(v1 + 696) = 1;
  }
  return result;
}

void *sub_10102C5A0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_10230C080[a1]);
}

void *sub_10102C5B4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_10230C0C0[a1]);
}

uint64_t sub_10102C5C8(uint64_t a1)
{
  *(void *)(a1 + 536) = 0;
  sub_1000D7D80(a1 + 648);
  sub_1000D7D80(a1 + 608);
  sub_1000D7D80(a1 + 568);
  if (*(char *)(a1 + 511) < 0) {
    operator delete(*(void **)(a1 + 488));
  }
  if (*(char *)(a1 + 487) < 0) {
    operator delete(*(void **)(a1 + 464));
  }
  if (*(char *)(a1 + 463) < 0) {
    operator delete(*(void **)(a1 + 440));
  }
  if (*(char *)(a1 + 423) < 0) {
    operator delete(*(void **)(a1 + 400));
  }
  if (*(char *)(a1 + 399) < 0) {
    operator delete(*(void **)(a1 + 376));
  }
  if (*(char *)(a1 + 367) < 0) {
    operator delete(*(void **)(a1 + 344));
  }
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*(void **)(a1 + 288));
  }
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10102C734(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *(unsigned int **)(a1 + 48);
  if (a3)
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v5 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v15 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "#EmergCon,initiateCallTriggerMetric,error querying motion activity,%{public}@", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
LABEL_26:
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLEmergencyController::EmergencyCallTriggerMetric::initiateCallTriggerMetric()_block_invoke", "%s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
  }
  else if (a2 && [a2 count])
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v8 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349056;
      id v15 = [a2 count];
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#EmergCon,initiateCallTriggerMetric,received %{public}lu responses for motion activity", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      [a2 count];
      uint64_t v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::initiateCallTriggerMetric()_block_invoke", "%s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
    sub_10102CBC0((uint64_t)v3, a2);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v9 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
    {
      id v10 = [*(id *)(a1 + 32) UTF8String];
      id v11 = [*(id *)(a1 + 40) UTF8String];
      *(_DWORD *)long long buf = 136446466;
      id v15 = v10;
      __int16 v16 = 2082;
      id v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "#EmergCon,initiateCallTriggerMetric,no motion activity returned for duration %{public}s to %{public}s", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      [*(id *)(a1 + 32) UTF8String];
      [*(id *)(a1 + 40) UTF8String];
      goto LABEL_26;
    }
  }
  sub_10102D1F0(v3);
}

void sub_10102CBC0(uint64_t a1, void *a2)
{
  if (a2 && (uint64_t v2 = a2, [a2 count]))
  {
    uint64_t v44 = a1;
    double v4 = *(double *)(a1 + 544);
    id v5 = [v2 count];
    uint64_t v42 = v5;
    if (v5)
    {
      unint64_t v6 = 0;
      double v7 = v4 + -60.0;
      unint64_t v41 = (v5 - 1);
      double v8 = v4 + -1800.0;
      uint64_t v36 = a1 + 72;
      uint64_t v37 = a1 + 48;
      uint64_t v39 = a1 + 608;
      uint64_t v40 = a1 + 648;
      uint64_t v38 = a1 + 568;
      int v43 = v2;
      do
      {
        id v9 = [v2 objectAtIndexedSubscript:v6];
        [objc_msgSend(v9, "startDate") timeIntervalSinceReferenceDate];
        double v11 = v10;
        if (v6 >= v41)
        {
          double v13 = *(double *)(v44 + 560);
        }
        else
        {
          [objc_msgSend(objc_msgSend(objc_msgSend(v43, "objectAtIndexedSubscript:", v6 + 1), "startDate"), "timeIntervalSinceReferenceDate"]
          double v13 = v12;
        }
        id v14 = objc_alloc_init((Class)NSDateFormatter);
        [v14 setLocale:[objc_alloc((Class)NSLocale) initWithLocaleIdentifier:@"en_US_POSIX"]];
        [v14 setTimeZone:+[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone")];
        [v14 setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        id v15 = [v14 stringFromDate:[v9 startDate]];
        if (qword_1024193E0 != -1) {
          dispatch_once(&qword_1024193E0, &stru_10230B640);
        }
        __int16 v16 = qword_1024193E8;
        if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
        {
          id v17 = [v15 UTF8String];
          unsigned int v18 = [v9 stationary];
          unsigned int v19 = [v9 walking];
          unsigned int v20 = [v9 running];
          unsigned int v21 = [v9 automotive];
          unsigned int v22 = [v9 cycling];
          unsigned int v23 = [v9 unknown];
          unsigned int v24 = [v9 confidence];
          *(_DWORD *)long long buf = 68291074;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&unsigned char buf[18] = 2082;
          *(void *)&buf[20] = v17;
          __int16 v46 = 1026;
          unsigned int v47 = v18;
          __int16 v48 = 1026;
          unsigned int v49 = v19;
          __int16 v50 = 1026;
          unsigned int v51 = v20;
          __int16 v52 = 1026;
          unsigned int v53 = v21;
          __int16 v54 = 1026;
          unsigned int v55 = v22;
          __int16 v56 = 1026;
          unsigned int v57 = v23;
          __int16 v58 = 1026;
          unsigned int v59 = v24;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,handleMotionActivityResponse,\", \"Date\":%{public, location:escape_only}s, \"stationary\":%{public}hhd, \"walking\":%{public}hhd, \"running\":%{public}hhd, \"automotive\":%{public}hhd, \"cycling\":%{public}hhd, \"unknown\":%{public}hhd, \"confidence\":%{public}d}", buf, 0x46u);
        }
        if ([v9 automotive])
        {
          int v25 = 3;
        }
        else if ([v9 cycling])
        {
          int v25 = 4;
        }
        else if ([v9 running])
        {
          int v25 = 2;
        }
        else if ([v9 walking])
        {
          int v25 = 1;
        }
        else if ([v9 stationary])
        {
          int v25 = 0;
        }
        else
        {
          int v25 = 5;
        }
        double v26 = *(double *)(v44 + 544);
        double v27 = *(double *)(v44 + 560);
        id v28 = [v9 confidence];
        sub_10102DE00(v26, v27, v11, v13, (uint64_t)v28, v40, v25, (uint64_t)v28);
        double v29 = *(double *)(v44 + 544);
        if (v11 <= v29 && v13 >= v29)
        {
          sub_10102E1D0(v25, buf);
          if (*(char *)(v44 + 71) < 0) {
            operator delete(*(void **)v37);
          }
          *(_OWORD *)uint64_t v37 = *(_OWORD *)buf;
          *(void *)(v37 + 16) = *(void *)&buf[16];
          sub_10102E1FC([v9 confidence], buf);
          if (*(char *)(v44 + 95) < 0) {
            operator delete(*(void **)v36);
          }
          *(_OWORD *)uint64_t v36 = *(_OWORD *)buf;
          *(void *)(v36 + 16) = *(void *)&buf[16];
          double v29 = *(double *)(v44 + 544);
        }
        id v30 = [v9 confidence];
        sub_10102DE00(v7, v29, v11, v13, (uint64_t)v30, v39, v25, (uint64_t)v30);
        id v31 = [v9 confidence];
        sub_10102DE00(v8, v7, v11, v13, (uint64_t)v31, v38, v25, (uint64_t)v31);
        ++v6;
        uint64_t v2 = v43;
      }
      while (v42 != v6);
    }
    sub_10102E2A4((uint64_t)v5, v44 + 648, v44 + 320, (std::string *)(v44 + 344), (unsigned int *)(v44 + 368), v44 + 376, (std::string *)(v44 + 400), (unsigned int *)(v44 + 424));
    sub_10102E2A4(v34, v44 + 608, v44 + 208, (std::string *)(v44 + 232), (unsigned int *)(v44 + 256), v44 + 264, (std::string *)(v44 + 288), (unsigned int *)(v44 + 312));
    sub_10102E2A4(v35, v44 + 568, v44 + 96, (std::string *)(v44 + 120), (unsigned int *)(v44 + 144), v44 + 152, (std::string *)(v44 + 176), (unsigned int *)(v44 + 200));
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    std::string::size_type v32 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#EmergCon,handleMotionActivityResponse,No motion activities reported", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v33 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::handleMotionActivityResponse(NSArray<CMMotionActivity *> *)", "%s\n", v33);
      if (v33 != buf) {
        free(v33);
      }
    }
  }
}

void sub_10102D1F0(unsigned int *a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  [v2 setValue:[NSNumber numberWithInt:*a1] forKey:@"localHourOfDay"];
  uint64_t v3 = a1 + 2;
  if (*((char *)a1 + 31) < 0) {
    uint64_t v3 = (unsigned int *)*((void *)a1 + 1);
  }
  [v2 setValue:[+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3)] forKey:@"callTriggerType"];
  [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 32)] forKey:@"systemTriggered"];
  [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 33)] forKey:@"didCallConnect"];
  [v2 setValue:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a1[9])] forKey:@"callDurationFromConnect"];
  [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 40)] forKey:@"screenLocked"];
  [v2 setValue:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[11])] forKey:@"numRecentEmergencyCalls"];
  double v4 = a1 + 12;
  if (*((char *)a1 + 71) < 0) {
    double v4 = (unsigned int *)*((void *)a1 + 6);
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4) forKey:@"atDialMotionType"];
  id v5 = a1 + 18;
  if (*((char *)a1 + 95) < 0) {
    id v5 = (unsigned int *)*((void *)a1 + 9);
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5) forKey:@"atDialMotionConfidence"];
  unint64_t v6 = a1 + 24;
  if (*((char *)a1 + 119) < 0) {
    unint64_t v6 = (unsigned int *)*((void *)a1 + 12);
  }
  [v2 setValue:[+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6)] forKey:@"preCallPrimaryMotionType"];
  double v7 = a1 + 30;
  if (*((char *)a1 + 143) < 0) {
    double v7 = (unsigned int *)*((void *)a1 + 15);
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7) forKey:@"preCallPrimaryMotionConfidence"];
  [v2 setValue:[NSNumber numberWithUnsignedInt:a1[36]] forKey:@"preCallPrimaryMotionFrequency"];
  double v8 = a1 + 38;
  if (*((char *)a1 + 175) < 0) {
    double v8 = (unsigned int *)*((void *)a1 + 19);
  }
  [v2 setValue:[NSString stringWithUTF8String:v8] forKey:@"preCallSecondaryMotionType"];
  id v9 = a1 + 44;
  if (*((char *)a1 + 199) < 0) {
    id v9 = (unsigned int *)*((void *)a1 + 22);
  }
  int v62 = a1 + 44;
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9) forKey:@"preCallSecondaryMotionConfidence"];
  [v2 setValue:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[50])] forKey:@"preCallSecondaryMotionFrequency"];
  double v10 = a1 + 52;
  if (*((char *)a1 + 231) < 0) {
    double v10 = (unsigned int *)*((void *)a1 + 26);
  }
  __int16 v61 = a1 + 52;
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10) forKey:@"nearCallPrimaryMotionType"];
  double v11 = a1 + 58;
  if (*((char *)a1 + 255) < 0) {
    double v11 = (unsigned int *)*((void *)a1 + 29);
  }
  uint64_t v60 = a1 + 58;
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11) forKey:@"nearCallPrimaryMotionConfidence"];
  [v2 setValue:[NSNumber numberWithUnsignedInt:a1[64]] forKey:@"nearCallPrimaryMotionFrequency"];
  double v12 = a1 + 66;
  if (*((char *)a1 + 287) < 0) {
    double v12 = (unsigned int *)*((void *)a1 + 33);
  }
  __int16 v58 = a1 + 66;
  [v2 setValue:[+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12)] forKey:@"nearCallSecondaryMotionType"];
  double v13 = a1 + 72;
  if (*((char *)a1 + 311) < 0) {
    double v13 = (unsigned int *)*((void *)a1 + 36);
  }
  unsigned int v59 = a1 + 72;
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13) forKey:@"nearCallSecondaryMotionConfidence"];
  [v2 setValue:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[78])] forKey:@"nearCallSecondaryMotionFrequency"];
  id v14 = a1 + 80;
  id v15 = a1 + 80;
  if (*((char *)a1 + 343) < 0) {
    id v15 = *(unsigned int **)v14;
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15) forKey:@"duringCallPrimaryMotionType"];
  __int16 v16 = a1 + 86;
  id v17 = a1 + 86;
  if (*((char *)a1 + 367) < 0) {
    id v17 = *(unsigned int **)v16;
  }
  [v2 setValue:[NSString stringWithUTF8String:v17] forKey:@"duringCallPrimaryMotionConfidence"];
  [v2 setValue:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[92])] forKey:@"duringCallPrimaryMotionFrequency"];
  unsigned int v18 = a1 + 94;
  unsigned int v19 = a1 + 94;
  if (*((char *)a1 + 399) < 0) {
    unsigned int v19 = *(unsigned int **)v18;
  }
  [v2 setValue:[+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19)] forKey:@"duringCallSecondaryMotionType"];
  unsigned int v20 = a1 + 100;
  unsigned int v21 = a1 + 100;
  if (*((char *)a1 + 423) < 0) {
    unsigned int v21 = *(unsigned int **)v20;
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21) forKey:@"duringCallSecondaryMotionConfidence"];
  [v2 setValue:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[106])] forKey:@"duringCallSecondaryMotionFrequency"];
  if (sub_10016CCBC())
  {
    [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 520)] forKey:@"playAudioDuringCountdown"];
    [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 512)] forKey:@"clawAutoDialEnabled"];
    [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 513)] forKey:@"multipressAutoDialEnabled"];
    [v2 setValue:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a1[129])] forKey:@"numberOfSideButtonPresses"];
    if (*(_DWORD *)(*((void *)a1 + 66) + 244) == 5)
    {
      [v2 setValue:[NSNumber numberWithInt:a1[107]] forKey:@"clawHoldDuration"];
      [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 432)] forKey:@"clawHeldForCallDuration"];
    }
    [v2 setValue:[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 433)] forKey:@"watchConnected"];
  }
  unsigned int v22 = *(_DWORD *)(*((void *)a1 + 66) + 248);
  [v2 setValue:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v22)] forKey:@"callDisconnectedReason"];
  unsigned int v23 = a1 + 110;
  unsigned int v24 = a1 + 110;
  if (*((char *)a1 + 463) < 0) {
    unsigned int v24 = *(unsigned int **)v23;
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v24) forKey:@"deviceOrientation"];
  int v25 = a1 + 116;
  double v26 = a1 + 116;
  if (*((char *)a1 + 487) < 0) {
    double v26 = *(unsigned int **)v25;
  }
  [v2 setValue:[NSString stringWithUTF8String:v26] forKey:@"mountState"];
  double v27 = a1 + 122;
  id v28 = a1 + 122;
  if (*((char *)a1 + 511) < 0) {
    id v28 = *(unsigned int **)v27;
  }
  [v2 setValue:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v28) forKey:@"chargerType"];
  AnalyticsSendEvent();

  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  double v29 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a1 + 31) < 0) {
      id v30 = (unsigned int *)*((void *)a1 + 1);
    }
    else {
      id v30 = a1 + 2;
    }
    std::string::size_type v32 = a1 + 18;
    id v31 = a1 + 12;
    uint64_t v34 = a1 + 30;
    __int16 v33 = a1 + 24;
    uint64_t v35 = a1 + 38;
    if (*((char *)a1 + 71) < 0) {
      id v31 = (unsigned int *)*((void *)a1 + 6);
    }
    if (*((char *)a1 + 95) < 0) {
      std::string::size_type v32 = (unsigned int *)*((void *)a1 + 9);
    }
    if (*((char *)a1 + 119) < 0) {
      __int16 v33 = (unsigned int *)*((void *)a1 + 12);
    }
    if (*((char *)a1 + 143) < 0) {
      uint64_t v34 = (unsigned int *)*((void *)a1 + 15);
    }
    if (*((char *)a1 + 175) < 0) {
      uint64_t v35 = (unsigned int *)*((void *)a1 + 19);
    }
    if (*((char *)a1 + 199) < 0) {
      int v62 = (void *)*v62;
    }
    if (*((char *)a1 + 231) < 0) {
      __int16 v61 = (void *)*v61;
    }
    if (*((char *)a1 + 255) < 0) {
      uint64_t v60 = (void *)*v60;
    }
    if (*((char *)a1 + 287) < 0) {
      __int16 v58 = (void *)*v58;
    }
    if (*((char *)a1 + 311) < 0) {
      unsigned int v59 = (void *)*v59;
    }
    if (*((char *)a1 + 343) < 0) {
      id v14 = *(unsigned int **)v14;
    }
    if (*((char *)a1 + 367) < 0) {
      __int16 v16 = *(unsigned int **)v16;
    }
    if (*((char *)a1 + 399) < 0) {
      unsigned int v18 = *(unsigned int **)v18;
    }
    if (*((char *)a1 + 423) < 0) {
      unsigned int v20 = *(unsigned int **)v20;
    }
    if (*((char *)a1 + 463) < 0) {
      unsigned int v23 = *(unsigned int **)v23;
    }
    if (*((char *)a1 + 487) < 0) {
      int v25 = *(unsigned int **)v25;
    }
    unsigned int v36 = *a1;
    int v37 = *((unsigned __int8 *)a1 + 33);
    unsigned int v38 = a1[9];
    int v39 = *((unsigned __int8 *)a1 + 40);
    unsigned int v40 = a1[11];
    unsigned int v41 = a1[36];
    unsigned int v42 = a1[50];
    unsigned int v43 = a1[64];
    unsigned int v44 = a1[78];
    unsigned int v45 = a1[92];
    unsigned int v46 = a1[106];
    if (*((char *)a1 + 511) < 0) {
      double v27 = *(unsigned int **)v27;
    }
    int v83 = v34;
    __int16 v87 = v35;
    double v89 = v62;
    unsigned int v91 = v42;
    __int16 v93 = v61;
    uint64_t v95 = v60;
    int v99 = v58;
    unsigned int v103 = v44;
    int v107 = v16;
    long long v111 = v18;
    long long v113 = v20;
    unsigned int v115 = v46;
    uint64_t v117 = v23;
    long long v119 = v25;
    int v68 = "";
    unsigned int v70 = v36;
    *(void *)int v72 = v30;
    *(_DWORD *)__int16 v73 = v37;
    *(_DWORD *)unsigned int v74 = v38;
    *(_DWORD *)int v75 = v39;
    *(_DWORD *)int v76 = v40;
    int v77 = v31;
    int v79 = v32;
    uint64_t v81 = v33;
    unsigned int v85 = v41;
    unsigned int v97 = v43;
    uint64_t v101 = v59;
    float v105 = v14;
    unsigned int v109 = v45;
    __int16 v69 = 1026;
    *(_WORD *)&v72[8] = 1026;
    *(_WORD *)&v73[4] = 1026;
    *(_WORD *)&v74[4] = 1026;
    *(_WORD *)&v75[4] = 1026;
    __int16 v84 = 1026;
    __int16 v90 = 1026;
    __int16 v96 = 1026;
    __int16 v102 = 1026;
    __int16 v108 = 1026;
    __int16 v114 = 1026;
    __int16 v67 = 2082;
    __int16 v71 = 2082;
    *(_WORD *)&v76[4] = 2082;
    __int16 v78 = 2082;
    __int16 v80 = 2082;
    __int16 v82 = 2082;
    __int16 v86 = 2082;
    __int16 v88 = 2082;
    __int16 v92 = 2082;
    __int16 v94 = 2082;
    __int16 v98 = 2082;
    __int16 v100 = 2082;
    __int16 v104 = 2082;
    __int16 v106 = 2082;
    __int16 v110 = 2082;
    __int16 v112 = 2082;
    __int16 v116 = 2082;
    __int16 v118 = 2082;
    __int16 v120 = 2082;
    long long v121 = v27;
    *(_DWORD *)long long buf = 68296450;
    int v66 = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,submitCallTriggerMetric, Part 1\", \"localHourOfDay\":%{public}d, \"callTriggerType\":%{public, location:escape_only}s, \"didCallConnect\":%{public}hhd, \"callDurationFromConnect\":%{public}d, \"screenLocked\":%{public}hhd, \"numRecentEmergencyCalls\":%{public}u, \"atDialMotionType\":%{public, location:escape_only}s, \"atDialMotionConfidence\":%{public, location:escape_only}s, \"preCallPrimaryMotionType\":%{public, location:escape_only}s, \"preCallPrimaryMotionConfidence\":%{public, location:escape_only}s, \"preCallPrimaryMotionFrequency\":%{public}u, \"preCallSecondaryMotionType\":%{public, location:escape_only}s, \"preCallSecondaryMotionConfidence\":%{public, location:escape_only}s, \"preCallSecondaryMotionFrequency\":%{public}u, \"nearCallPrimaryMotionType\":%{public, location:escape_only}s, \"nearCallPrimaryMotionConfidence\":%{public, location:escape_only}s, \"nearCallPrimaryMotionFrequency\":%{public}u, \"nearCallSecondaryMotionType\":%{public, location:escape_only}s, \"nearCallSecondaryMotionConfidence\":%{public, location:escape_only}s, \"nearCallSecondaryMotionFrequency\":%{public}u, \"duringCallPrimaryMotionType\":%{public, location:escape_only}s, \"duringCallPrimaryMotionConfidence\":%{public, location:escape_only}s, \"duringCallPrimaryMotionFrequency\":%{public}u, \"duringCallSecondaryMotionType\":%{public, location:escape_only}s, \"duringCallSecondaryMotionConfidence\":%{public, location:escape_only}s, \"duringCallSecondaryMotionFrequency\":%{public}u, \"deviceOrientation\":%{public, location:escape_only}s, \"mountState\":%{public, location:escape_only}s, \"chargerType\":%{public, location:escape_only}s}", buf,
      0x108u);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
  }
  unsigned int v47 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v48 = *((unsigned __int8 *)a1 + 520);
    int v49 = *((unsigned __int8 *)a1 + 512);
    int v50 = *((unsigned __int8 *)a1 + 513);
    unsigned int v51 = a1[129];
    int v52 = *((unsigned __int8 *)a1 + 433);
    unsigned int v53 = a1[107];
    *(_DWORD *)long long buf = 68290818;
    int v66 = 0;
    __int16 v67 = 2082;
    int v68 = "";
    __int16 v69 = 1026;
    unsigned int v70 = v48;
    __int16 v71 = 1026;
    *(_DWORD *)int v72 = v49;
    *(_WORD *)&v72[4] = 1026;
    *(_DWORD *)&v72[6] = v50;
    *(_WORD *)__int16 v73 = 1026;
    *(_DWORD *)&v73[2] = v51;
    *(_WORD *)unsigned int v74 = 1026;
    *(_DWORD *)&v74[2] = v52;
    *(_WORD *)int v75 = 1026;
    *(_DWORD *)&_OWORD v75[2] = v53;
    *(_WORD *)int v76 = 1026;
    *(_DWORD *)&v76[2] = v22;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#EmergCon,submitCallTriggerMetric, Part 2\", \"playAudioDuringCountdown\":%{public}hhd, \"clawAutoDialEnabled\":%{public}hhd, \"multipressAutoDialEnabled\":%{public}hhd, \"numberOfSideButtonPresses\":%{public}d, \"watchConnected\":%{public}hhd, \"clawHoldDuration\":%{public}d, \"callDisconnectedReason\":%{public}u}", buf, 0x3Cu);
  }
  uint64_t v54 = *((void *)a1 + 66);
  if (v54)
  {
    unsigned int v55 = [objc_msgSend(*(id *)(v54 + 8), "silo") queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10102E580;
    block[3] = &unk_1022A3020;
    block[4] = a1;
    dispatch_async(v55, block);
  }
  else
  {
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    __int16 v56 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#EmergCon,submitCallTriggerMetric,Emergency Controller pointer is null", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
      __int16 v64 = 0;
      unsigned int v57 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::submitCallTriggerMetric()", "%s\n", v57);
      if (v57 != (char *)buf) {
        free(v57);
      }
    }
  }
}

void sub_10102DE00(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  int v22 = a7;
  if (a3 > a2 || a4 <= a1) {
    return;
  }
  if (a4 <= a2 && a3 <= a1 && a4 > a1)
  {
    double v13 = a4 - a1;
    goto LABEL_19;
  }
  if (a4 <= a2 && a3 > a1 && a3 < a2 && a4 > a1)
  {
    double v13 = a4 - a3;
    goto LABEL_19;
  }
  if (a3 > a1 && a3 <= a2 && a4 > a2)
  {
    double v13 = a2 - a3;
    goto LABEL_19;
  }
  if (a3 <= a1 && a4 >= a2)
  {
    double v13 = a2 - a1;
LABEL_19:
    unsigned int v14 = vcvtpd_s64_f64(v13);
    *(void *)long long buf = &v22;
    id v15 = sub_101038D2C(a6, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
    *((_DWORD *)v15 + 5) += v14;
    switch(a8)
    {
      case 2:
        *(void *)long long buf = &v22;
        id v17 = sub_101038D2C(a6, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *((_DWORD *)v17 + 8) += v14;
        return;
      case 1:
        *(void *)long long buf = &v22;
        unsigned int v18 = sub_101038D2C(a6, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *((_DWORD *)v18 + 7) += v14;
        return;
      case 0:
        *(void *)long long buf = &v22;
        __int16 v16 = sub_101038D2C(a6, &v22, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *((_DWORD *)v16 + 6) += v14;
        return;
    }
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    unsigned int v19 = qword_1024193E8;
    if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#EmergCon,checkAndAddActivityToMap,Unhandled confidence", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024193E0 != -1) {
        dispatch_once(&qword_1024193E0, &stru_10230B640);
      }
LABEL_46:
      unsigned int v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::checkAndAddActivityToMap(std::unordered_map<MotionType, MotionTypeData> &, CFAbsoluteTime, CFAbsoluteTime, CFAbsoluteTime, CFAbsoluteTime, MotionType, CMMotionActivityConfidence)", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
      return;
    }
    return;
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  unsigned int v20 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#EmergCon,checkAndAddActivityToMap,Unhandled scenario", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    goto LABEL_46;
  }
}

void *sub_10102E1D0@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 4) {
    id v2 = "Unknown";
  }
  else {
    id v2 = off_10230C0E8[a1];
  }
  return sub_100134750(a2, v2);
}

void *sub_10102E1FC@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (result == (void *)2)
  {
    if ((byte_10248295F & 0x80000000) == 0)
    {
      id v2 = &xmmword_102482948;
      goto LABEL_10;
    }
    uint64_t v3 = &xmmword_102482948;
  }
  else if (result == (void *)1)
  {
    if ((byte_102482947 & 0x80000000) == 0)
    {
      id v2 = &xmmword_102482930;
      goto LABEL_10;
    }
    uint64_t v3 = &xmmword_102482930;
  }
  else
  {
    if (result) {
      return sub_100134750(a2, "");
    }
    if ((byte_10248292F & 0x80000000) == 0)
    {
      id v2 = &xmmword_102482918;
LABEL_10:
      *(_OWORD *)a2 = *v2;
      a2[2] = *((void *)v2 + 2);
      return result;
    }
    uint64_t v3 = &xmmword_102482918;
  }
  return sub_1000DC48C(a2, *(void **)v3, *((void *)v3 + 1));
}

void sub_10102E2A4(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4, unsigned int *a5, uint64_t a6, std::string *a7, unsigned int *a8)
{
  if ((byte_102482960[23] & 0x80000000) == 0)
  {
    std::string __str = *(std::string *)byte_102482960;
LABEL_4:
    std::string __dst = *(std::string *)byte_102482960;
    goto LABEL_5;
  }
  sub_1000DC48C(&__str, *(void **)byte_102482960, *(unint64_t *)&byte_102482960[8]);
  if ((byte_102482960[23] & 0x80000000) == 0) {
    goto LABEL_4;
  }
  sub_1000DC48C(&__dst, *(void **)byte_102482960, *(unint64_t *)&byte_102482960[8]);
LABEL_5:
  uint64_t v37 = a3;
  unsigned int v38 = a4;
  uint64_t v39 = a6;
  uint64_t v35 = a8;
  unsigned int v36 = a7;
  uint64_t v34 = a5;
  id v15 = *(uint64_t **)(a2 + 16);
  if (v15)
  {
    int v16 = 0;
    int v17 = 0;
    int v18 = 0;
    unsigned int v19 = 5;
    unsigned int v20 = 5;
    do
    {
      int v22 = *((_DWORD *)v15 + 5);
      int v21 = *((_DWORD *)v15 + 6);
      int v24 = *((_DWORD *)v15 + 7);
      int v23 = *((_DWORD *)v15 + 8);
      if (v22 <= v16)
      {
        if (v18 < v22)
        {
          unsigned int v20 = *((_DWORD *)v15 + 4);
          double v29 = &xmmword_102482948;
          if (v24 > v23) {
            double v29 = &xmmword_102482930;
          }
          if (v21 <= v23 || v21 <= v24) {
            id v31 = (const std::string *)v29;
          }
          else {
            id v31 = (const std::string *)&xmmword_102482918;
          }
          std::string::operator=(&__dst, v31);
          int v18 = v22;
        }
      }
      else
      {
        std::string::operator=(&__dst, &__str);
        unsigned int v25 = *((_DWORD *)v15 + 4);
        double v26 = &xmmword_102482948;
        if (v24 > v23) {
          double v26 = &xmmword_102482930;
        }
        if (v21 <= v23 || v21 <= v24) {
          id v28 = (const std::string *)v26;
        }
        else {
          id v28 = (const std::string *)&xmmword_102482918;
        }
        std::string::operator=(&__str, v28);
        unsigned int v20 = v19;
        unsigned int v19 = v25;
        int v18 = v16;
        int v16 = v22;
      }
      v17 += v22;
      id v15 = (uint64_t *)*v15;
    }
    while (v15);
  }
  else
  {
    int v18 = 0;
    int v17 = 0;
    int v16 = 0;
    unsigned int v20 = 5;
    unsigned int v19 = 5;
  }
  sub_10102E1D0(v19, &v40);
  if (*(char *)(v37 + 23) < 0) {
    operator delete(*(void **)v37);
  }
  *(_OWORD *)uint64_t v37 = v40;
  *(void *)(v37 + 16) = v41;
  std::string::operator=(v38, &__str);
  sub_10102E1D0(v20, &v40);
  if (*(char *)(v39 + 23) < 0) {
    operator delete(*(void **)v39);
  }
  *(_OWORD *)uint64_t v39 = v40;
  *(void *)(v39 + 16) = v41;
  std::string::operator=(v36, &__dst);
  if (v17)
  {
    unsigned int v32 = vcvtps_u32_f32((float)((float)v16 / (float)v17) * 100.0);
    unsigned int v33 = vcvtps_u32_f32((float)((float)v18 / (float)v17) * 100.0);
  }
  else
  {
    unsigned int v32 = 0;
    unsigned int v33 = 0;
  }
  *uint64_t v34 = v32;
  *uint64_t v35 = v33;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_10102E540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102E580(uint64_t a1)
{
}

void sub_10102E58C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [+[SOSManager sharedInstance] currentSOSInteractiveState];
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v3 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    id v10 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#EmergCon,interactiveStateChanged,newInteractiveState %lu", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    int v7 = 134217984;
    id v8 = v2;
    id v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::interactiveStateChanged()_block_invoke", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  double v4 = [objc_msgSend(*(id *)(*(void *)(v1 + 528) + 8), "silo") queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10102E7AC;
  block[3] = &unk_1022B8660;
  block[4] = v1;
  void block[5] = v2;
  dispatch_async(v4, block);
}

void sub_10102E7AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  uint64_t v3 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(v2 + 688);
    uint64_t v5 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 134218240;
    uint64_t v14 = v4;
    __int16 v15 = 2048;
    uint64_t v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#EmergCon,interactiveStateChanged,currentInteractiveState from %lu to %lu", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    double v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLEmergencyController::EmergencyCallTriggerMetric::interactiveStateChanged()_block_invoke", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 688) != v6)
  {
    *(void *)(v2 + 688) = v6;
    if (!*(void *)(a1 + 40) && !*(unsigned char *)(v2 + 696))
    {
      double v7 = sub_10016C458();
      uint64_t v8 = *(void *)(v2 + 528);
      if (!v8 || ((v9 = *(double *)(v8 + 256), v9 != 0.0) ? (BOOL v10 = v7 <= v9) : (BOOL v10 = 1), v10)) {
        unsigned int v11 = -1;
      }
      else {
        unsigned int v11 = vcvtpd_s64_f64(sub_10016C458() - *(double *)(*(void *)(v2 + 528) + 256));
      }
      *(_DWORD *)(v2 + 428) = v11;
      *(unsigned char *)(v2 + 696) = 1;
    }
  }
}

void sub_10102E9EC(id a1)
{
  qword_1024193E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

void sub_10102EA1C(id a1)
{
  qword_102419588 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_10102EA4C(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  uint64_t v5 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v5);
  }
  long long v6 = a2[2];
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 55) = 0;
  *((unsigned char *)a2 + 32) = 0;
  long long v7 = *(long long *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 56) = *(long long *)((char *)a2 + 56);
  *(_OWORD *)(a1 + 72) = v7;
  uint64_t v8 = (void **)(a1 + 88);
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*v8);
  }
  long long v9 = *(long long *)((char *)a2 + 88);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(_OWORD *)uint64_t v8 = v9;
  *((unsigned char *)a2 + 111) = 0;
  *((unsigned char *)a2 + 88) = 0;
  *(unsigned char *)(a1 + 112) = *((unsigned char *)a2 + 112);
  sub_100314FE8((uint64_t *)(a1 + 120));
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = *(long long *)((char *)a2 + 120);
  *(void *)(a1 + 136) = *((void *)a2 + 17);
  *((void *)a2 + 15) = 0;
  *((void *)a2 + 16) = 0;
  *((void *)a2 + 17) = 0;
  *(_DWORD *)(a1 + 144) = *((_DWORD *)a2 + 36);
  sub_10102EB60(a1 + 152, (__int16 *)a2 + 76);
  sub_10102EB60(a1 + 488, (__int16 *)a2 + 244);
  return a1;
}

uint64_t sub_10102EB60(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(unsigned char *)(a1 + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)a1 = v4;
  uint64_t v5 = a1 + 8;
  long long v6 = (long long *)(a2 + 4);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v5);
  }
  long long v7 = *v6;
  *(void *)(v5 + 16) = *((void *)v6 + 2);
  *(_OWORD *)uint64_t v5 = v7;
  *((unsigned char *)a2 + 31) = 0;
  *((unsigned char *)a2 + 8) = 0;
  uint64_t v8 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v8);
  }
  long long v9 = *((_OWORD *)a2 + 2);
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_OWORD *)uint64_t v8 = v9;
  *((unsigned char *)a2 + 55) = 0;
  *((unsigned char *)a2 + 32) = 0;
  BOOL v10 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*v10);
  }
  long long v11 = *(_OWORD *)(a2 + 28);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)BOOL v10 = v11;
  *((unsigned char *)a2 + 79) = 0;
  *((unsigned char *)a2 + 56) = 0;
  uint64_t v12 = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = *((_OWORD *)a2 + 5);
  *(void *)(a1 + 96) = v12;
  double v13 = (void **)(a1 + 104);
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*v13);
  }
  long long v14 = *(_OWORD *)(a2 + 52);
  *(void *)(a1 + 12sub_100FB8FC8(&a9, 0) = *((void *)a2 + 15);
  *(_OWORD *)double v13 = v14;
  *((unsigned char *)a2 + 127) = 0;
  *((unsigned char *)a2 + 104) = 0;
  *(_WORD *)(a1 + 128) = a2[64];
  sub_10084E7D4((void **)(a1 + 136));
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 68);
  *(void *)(a1 + 152) = *((void *)a2 + 19);
  *((void *)a2 + 18) = 0;
  *((void *)a2 + 19) = 0;
  *((void *)a2 + 17) = 0;
  long long v15 = *((_OWORD *)a2 + 16);
  long long v17 = *((_OWORD *)a2 + 13);
  long long v16 = *((_OWORD *)a2 + 14);
  *(_OWORD *)(a1 + 24sub_100FB8FC8(&a9, 0) = *((_OWORD *)a2 + 15);
  *(_OWORD *)(a1 + 256) = v15;
  *(_OWORD *)(a1 + 208) = v17;
  *(_OWORD *)(a1 + 224) = v16;
  long long v19 = *((_OWORD *)a2 + 18);
  long long v18 = *((_OWORD *)a2 + 19);
  long long v20 = *((_OWORD *)a2 + 17);
  *(_OWORD *)(a1 + 316) = *(_OWORD *)(a2 + 158);
  *(_OWORD *)(a1 + 288) = v19;
  *(_OWORD *)(a1 + 304) = v18;
  *(_OWORD *)(a1 + 272) = v20;
  long long v21 = *((_OWORD *)a2 + 12);
  long long v22 = *((_OWORD *)a2 + 10);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)a2 + 11);
  *(_OWORD *)(a1 + 192) = v21;
  *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = v22;
  return a1;
}

uint64_t sub_10102ECD4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  long long v6 = *((_OWORD *)a2 + 5);
  long long v5 = *((_OWORD *)a2 + 6);
  long long v7 = *((_OWORD *)a2 + 4);
  *(void *)(a1 + 112) = a2[14];
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = v6;
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 64) = v7;
  long long v8 = *((_OWORD *)a2 + 1);
  long long v9 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + 48) = v9;
  *(_OWORD *)(a1 + 16) = v8;
  sub_10102F090((char *)(a1 + 120), (uint64_t)(a2 + 15));
  if (*((char *)a2 + 967) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 944), (void *)a2[118], a2[119]);
  }
  else
  {
    long long v10 = *((_OWORD *)a2 + 59);
    *(void *)(a1 + 96sub_100FB8FC8(&a9, 0) = a2[120];
    *(_OWORD *)(a1 + 944) = v10;
  }
  long long v11 = (unsigned char *)(a1 + 968);
  if (*((char *)a2 + 991) < 0)
  {
    sub_1000DC48C(v11, (void *)a2[121], a2[122]);
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 121);
    *(void *)(a1 + 984) = a2[123];
    *(_OWORD *)long long v11 = v12;
  }
  uint64_t v13 = a2[124];
  *(_DWORD *)(a1 + 100sub_100FB8FC8(&a9, 0) = *((_DWORD *)a2 + 250);
  *(void *)(a1 + 992) = v13;
  long long v14 = *((_OWORD *)a2 + 63);
  long long v15 = *((_OWORD *)a2 + 64);
  long long v16 = *((_OWORD *)a2 + 65);
  *(void *)(a1 + 1056) = a2[132];
  *(_OWORD *)(a1 + 104sub_100FB8FC8(&a9, 0) = v16;
  *(_OWORD *)(a1 + 1008) = v14;
  *(_OWORD *)(a1 + 1024) = v15;
  *(unsigned char *)(a1 + 1064) = *((unsigned char *)a2 + 1064);
  if (*((char *)a2 + 1095) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 1072), (void *)a2[134], a2[135]);
  }
  else
  {
    long long v17 = *((_OWORD *)a2 + 67);
    *(void *)(a1 + 1088) = a2[136];
    *(_OWORD *)(a1 + 1072) = v17;
  }
  long long v18 = *(_OWORD *)(a2 + 137);
  *(_OWORD *)(a1 + 1108) = *(_OWORD *)((char *)a2 + 1108);
  *(_OWORD *)(a1 + 1096) = v18;
  *(void *)(a1 + 1128) = 0;
  *(void *)(a1 + 1144) = 0;
  *(void *)(a1 + 1136) = 0;
  sub_10102F53C((void *)(a1 + 1128), (long long *)a2[141], (long long *)a2[142], 0xAAAAAAAAAAAAAAABLL * ((a2[142] - a2[141]) >> 4));
  *(unsigned char *)(a1 + 1152) = *((unsigned char *)a2 + 1152);
  if (*((char *)a2 + 1183) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 1160), (void *)a2[145], a2[146]);
  }
  else
  {
    long long v19 = *(_OWORD *)(a2 + 145);
    *(void *)(a1 + 1176) = a2[147];
    *(_OWORD *)(a1 + 116sub_100FB8FC8(&a9, 0) = v19;
  }
  long long v20 = *((_OWORD *)a2 + 74);
  *(_OWORD *)(a1 + 1196) = *(_OWORD *)((char *)a2 + 1196);
  *(_OWORD *)(a1 + 1184) = v20;
  *(void *)(a1 + 1216) = 0;
  *(void *)(a1 + 1232) = 0;
  *(void *)(a1 + 1224) = 0;
  sub_10102F53C((void *)(a1 + 1216), (long long *)a2[152], (long long *)a2[153], 0xAAAAAAAAAAAAAAABLL * ((a2[153] - a2[152]) >> 4));
  if (*((char *)a2 + 1263) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 1240), (void *)a2[155], a2[156]);
  }
  else
  {
    long long v21 = *(_OWORD *)(a2 + 155);
    *(void *)(a1 + 1256) = a2[157];
    *(_OWORD *)(a1 + 124sub_100FB8FC8(&a9, 0) = v21;
  }
  if (*((char *)a2 + 1287) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 1264), (void *)a2[158], a2[159]);
  }
  else
  {
    long long v22 = *((_OWORD *)a2 + 79);
    *(void *)(a1 + 128sub_100FB8FC8(&a9, 0) = a2[160];
    *(_OWORD *)(a1 + 1264) = v22;
  }
  if (*((char *)a2 + 1311) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 1288), (void *)a2[161], a2[162]);
  }
  else
  {
    long long v23 = *(_OWORD *)(a2 + 161);
    *(void *)(a1 + 1304) = a2[163];
    *(_OWORD *)(a1 + 1288) = v23;
  }
  int v24 = (unsigned char *)(a1 + 1312);
  if (*((char *)a2 + 1335) < 0)
  {
    sub_1000DC48C(v24, (void *)a2[164], a2[165]);
  }
  else
  {
    long long v25 = *((_OWORD *)a2 + 82);
    *(void *)(a1 + 1328) = a2[166];
    *(_OWORD *)int v24 = v25;
  }
  return a1;
}

void sub_10102EFBC(_Unwind_Exception *a1)
{
  if (v2[1311] < 0) {
    operator delete(*v6);
  }
  if (v2[1287] < 0) {
    operator delete(*v5);
  }
  if (v2[1263] < 0) {
    operator delete(*v4);
  }
  sub_100A7AD00((uint64_t)(v2 + 1152));
  sub_100A7AD00((uint64_t)(v2 + 1064));
  sub_100286A7C(v3);
  sub_10084DE08(v1);
  _Unwind_Resume(a1);
}

void sub_10102F078()
{
  if (*(char *)(v0 + 1095) < 0) {
    operator delete(*v1);
  }
  JUMPOUT(0x10102F060);
}

char *sub_10102F090(char *a1, uint64_t a2)
{
  uint64_t v4 = sub_10102F174(a1, (long long *)a2);
  sub_10102F2C8((uint64_t)(v4 + 152), (__int16 *)(a2 + 152));
  sub_10102F2C8((uint64_t)(a1 + 488), (__int16 *)(a2 + 488));
  return a1;
}

void sub_10102F0E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _Unwind_Exception *a9)
{
  a9 = (_Unwind_Exception *)(v9 + 288);
  sub_10084DF14((void ***)&a9);
  if (*(char *)(v9 + 279) < 0) {
    operator delete(*(void **)(v9 + 256));
  }
  sub_101A9D218(v9, a1, a2, (uint64_t)&a9);
  long long v12 = a9;
  a9 = (_Unwind_Exception *)(v9 + 120);
  sub_1000A7B4C((void ***)&a9);
  if (*(char *)(v9 + 111) < 0) {
    operator delete(*(void **)(v9 + 88));
  }
  if (*(char *)(v9 + 55) < 0) {
    operator delete(*(void **)(v9 + 32));
  }
  if (*(char *)(v9 + 23) < 0) {
    operator delete(*(void **)v9);
  }
  _Unwind_Resume(v12);
}

char *sub_10102F174(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((void *)__dst + 3) = *((void *)a2 + 3);
  if (*((char *)a2 + 55) < 0)
  {
    sub_1000DC48C(__dst + 32, *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v5 = a2[2];
    *((void *)__dst + 6) = *((void *)a2 + 6);
    *((_OWORD *)__dst + 2) = v5;
  }
  long long v6 = *(long long *)((char *)a2 + 56);
  *(_OWORD *)(__dst + 72) = *(long long *)((char *)a2 + 72);
  *(_OWORD *)(__dst + 56) = v6;
  if (*((char *)a2 + 111) < 0)
  {
    sub_1000DC48C(__dst + 88, *((void **)a2 + 11), *((void *)a2 + 12));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 88);
    *((void *)__dst + 13) = *((void *)a2 + 13);
    *(_OWORD *)(__dst + 88) = v7;
  }
  char v8 = *((unsigned char *)a2 + 112);
  *((void *)__dst + 15) = 0;
  __dst[112] = v8;
  *((void *)__dst + 16) = 0;
  *((void *)__dst + 17) = 0;
  sub_1001D857C(__dst + 120, *((long long **)a2 + 15), *((long long **)a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 16) - *((void *)a2 + 15)) >> 3));
  *((_DWORD *)__dst + 36) = *((_DWORD *)a2 + 36);
  return __dst;
}

void sub_10102F27C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10102F2C8(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(unsigned char *)(a1 + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)a1 = v4;
  if (*((char *)a2 + 31) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 8), *((void **)a2 + 1), *((void *)a2 + 2));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 4);
    *(void *)(a1 + 24) = *((void *)a2 + 3);
    *(_OWORD *)(a1 + 8) = v5;
  }
  if (*((char *)a2 + 55) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 32), *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 2);
    *(void *)(a1 + 48) = *((void *)a2 + 6);
    *(_OWORD *)(a1 + 32) = v6;
  }
  if (*((char *)a2 + 79) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 56), *((void **)a2 + 7), *((void *)a2 + 8));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 28);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *(_OWORD *)(a1 + 56) = v7;
  }
  long long v8 = *((_OWORD *)a2 + 5);
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = v8;
  if (*((char *)a2 + 127) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 104), *((void **)a2 + 13), *((void *)a2 + 14));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 52);
    *(void *)(a1 + 12sub_100FB8FC8(&a9, 0) = *((void *)a2 + 15);
    *(_OWORD *)(a1 + 104) = v9;
  }
  __int16 v10 = a2[64];
  *(void *)(a1 + 136) = 0;
  *(_WORD *)(a1 + 128) = v10;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  sub_10102F4B4((char *)(a1 + 136), *((long long **)a2 + 17), *((long long **)a2 + 18), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 18) - *((void *)a2 + 17)) >> 4));
  long long v11 = *((_OWORD *)a2 + 10);
  long long v12 = *((_OWORD *)a2 + 12);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)a2 + 11);
  *(_OWORD *)(a1 + 192) = v12;
  *(_OWORD *)(a1 + 16sub_100FB8FC8(&a9, 0) = v11;
  long long v13 = *((_OWORD *)a2 + 13);
  long long v14 = *((_OWORD *)a2 + 14);
  long long v15 = *((_OWORD *)a2 + 16);
  *(_OWORD *)(a1 + 24sub_100FB8FC8(&a9, 0) = *((_OWORD *)a2 + 15);
  *(_OWORD *)(a1 + 256) = v15;
  *(_OWORD *)(a1 + 208) = v13;
  *(_OWORD *)(a1 + 224) = v14;
  long long v16 = *((_OWORD *)a2 + 17);
  long long v17 = *((_OWORD *)a2 + 18);
  long long v18 = *((_OWORD *)a2 + 19);
  *(_OWORD *)(a1 + 316) = *(_OWORD *)(a2 + 158);
  *(_OWORD *)(a1 + 288) = v17;
  *(_OWORD *)(a1 + 304) = v18;
  *(_OWORD *)(a1 + 272) = v16;
  return a1;
}

void sub_10102F450(_Unwind_Exception *exception_object)
{
  if (v1[79] < 0) {
    operator delete(*v4);
  }
  if (v1[55] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10102F4B4(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_1002F3410(result, a4);
    uint64_t result = sub_10084E844((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }
  return result;
}

void sub_10102F51C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10084DF14(&a9);
  _Unwind_Resume(a1);
}

void *sub_10102F53C(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100018218(result, a4);
    uint64_t result = sub_10084EC70((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10102F5A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100340F40(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10102F5C4(int *a1)
{
  sub_10010F274((uint64_t)v27);
  uint64_t v2 = sub_100132EFC(v28, (uint64_t)"ControlPlane,", 13);
  sub_1010283BC(a1);
  if ((v26 & 0x80u) == 0) {
    uint64_t v3 = v25;
  }
  else {
    uint64_t v3 = (void **)v25[0];
  }
  if ((v26 & 0x80u) == 0) {
    uint64_t v4 = v26;
  }
  else {
    uint64_t v4 = (uint64_t)v25[1];
  }
  long long v5 = sub_100132EFC(v2, (uint64_t)v3, v4);
  long long v6 = sub_100132EFC(v5, (uint64_t)",ControlPlaneCdma,", 18);
  sub_101029080((uint64_t)(a1 + 10));
  if ((v24 & 0x80u) == 0) {
    long long v7 = v23;
  }
  else {
    long long v7 = (void **)v23[0];
  }
  if ((v24 & 0x80u) == 0) {
    uint64_t v8 = v24;
  }
  else {
    uint64_t v8 = (uint64_t)v23[1];
  }
  uint64_t v9 = sub_100132EFC(v6, (uint64_t)v7, v8);
  uint64_t v10 = sub_100132EFC(v9, (uint64_t)",UserPlane,", 11);
  sub_1010283BC(a1 + 12);
  if ((v22 & 0x80u) == 0) {
    long long v11 = v21;
  }
  else {
    long long v11 = (void **)v21[0];
  }
  if ((v22 & 0x80u) == 0) {
    uint64_t v12 = v22;
  }
  else {
    uint64_t v12 = (uint64_t)v21[1];
  }
  long long v13 = sub_100132EFC(v10, (uint64_t)v11, v12);
  long long v14 = sub_100132EFC(v13, (uint64_t)",Action,", 8);
  sub_101029288((uint64_t)(a1 + 26));
  if ((v20 & 0x80u) == 0) {
    long long v15 = __p;
  }
  else {
    long long v15 = (void **)__p[0];
  }
  if ((v20 & 0x80u) == 0) {
    uint64_t v16 = v20;
  }
  else {
    uint64_t v16 = (uint64_t)__p[1];
  }
  sub_100132EFC(v14, (uint64_t)v15, v16);
  if ((char)v20 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v22 < 0) {
    operator delete(v21[0]);
  }
  if ((char)v24 < 0) {
    operator delete(v23[0]);
  }
  if ((char)v26 < 0) {
    operator delete(v25[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v27
  v28[0] = v17;
  if (v29 < 0) {
    operator delete((void *)v28[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10102F880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_101A129A8((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_10102F904(uint64_t a1)
{
  sub_10010F274((uint64_t)v21);
  uint64_t v2 = sub_100132EFC(v22, (uint64_t)"HslpAddress,", 12);
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  long long v6 = sub_100132EFC(v2, v4, v5);
  long long v7 = sub_100132EFC(v6, (uint64_t)",HslpCARootCert,", 16);
  int v8 = *(char *)(a1 + 47);
  if (v8 >= 0) {
    uint64_t v9 = a1 + 24;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 24);
  }
  if (v8 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v10 = *(void *)(a1 + 32);
  }
  long long v11 = sub_100132EFC(v7, v9, v10);
  sub_100132EFC(v11, (uint64_t)",port,", 6);
  uint64_t v12 = (void *)std::ostream::operator<<();
  sub_100132EFC(v12, (uint64_t)",udpPortConfig,", 15);
  long long v13 = (void *)std::ostream::operator<<();
  sub_100132EFC(v13, (uint64_t)",suplFlags,", 11);
  long long v14 = (void *)std::ostream::operator<<();
  sub_100132EFC(v14, (uint64_t)",allowNonEmergencySupl,", 23);
  long long v15 = (void *)std::ostream::operator<<();
  sub_100132EFC(v15, (uint64_t)",allowSuplWithoutEmergencyNotification,", 39);
  uint64_t v16 = (void *)std::ostream::operator<<();
  sub_100132EFC(v16, (uint64_t)",allowHslpMismatch,", 19);
  uint64_t v17 = (void *)std::ostream::operator<<();
  sub_100132EFC(v17, (uint64_t)",allowHslpWildCard,", 19);
  long long v18 = (void *)std::ostream::operator<<();
  sub_100132EFC(v18, (uint64_t)",allowNonConformingEslpAddress,", 31);
  std::ostream::operator<<();
  std::stringbuf::str();
  *(void *)((char *)v21
  v22[0] = v19;
  if (v23 < 0) {
    operator delete((void *)v22[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10102FBA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10102FBB8(id a1)
{
  qword_102419608 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Utility");
}

uint64_t sub_10102FBE8(uint64_t a1)
{
  sub_10010F274((uint64_t)v16);
  uint64_t v2 = sub_100132EFC(v17, (uint64_t)"partnerId,", 10);
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  long long v6 = sub_100132EFC(v2, v4, v5);
  long long v7 = sub_100132EFC(v6, (uint64_t)",adrCert,", 9);
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v9 = a1 + 24;
  uint64_t v8 = v10;
  int v11 = *(char *)(v9 + 23);
  if (v11 >= 0) {
    uint64_t v12 = v9;
  }
  else {
    uint64_t v12 = v8;
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(v9 + 23);
  }
  else {
    uint64_t v13 = *(void *)(v9 + 8);
  }
  sub_100132EFC(v7, v12, v13);
  std::stringbuf::str();
  *(void *)((char *)v16
  v17[0] = v14;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10102FDB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_10102FDC4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case 2:
      uint64_t v4 = "network-assisted";
      goto LABEL_7;
    case 1:
      uint64_t v4 = "device-based";
      goto LABEL_7;
    case 0:
      uint64_t v4 = "disabled";
LABEL_7:
      return sub_100134750(a2, v4);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  long long v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v9 = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "undefined constellation usage %d\n", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    long long v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static std::string CLEmergencyController::LocationSettings::Emergency::Settings::toString(ConstellationUsage)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return sub_100134750(a2, "undefined");
}

uint64_t sub_10103002C(uint64_t a1)
{
  sub_10010F274((uint64_t)v11);
  sub_100132EFC(v12, (uint64_t)"enable,", 7);
  uint64_t v2 = (void *)std::ostream::operator<<();
  int v3 = sub_100132EFC(v2, (uint64_t)",apConfig,", 10);
  sub_10103024C(*(_DWORD *)(a1 + 4), __p);
  if ((v10 & 0x80u) == 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    uint64_t v5 = v10;
  }
  else {
    uint64_t v5 = (uint64_t)__p[1];
  }
  long long v6 = sub_100132EFC(v3, (uint64_t)v4, v5);
  sub_100132EFC(v6, (uint64_t)",enableRssi,", 12);
  std::ostream::operator<<();
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  *(void *)((char *)v11
  v12[0] = v7;
  if (v13 < 0) {
    operator delete((void *)v12[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10103021C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void *sub_10103024C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 1)
  {
    uint64_t v4 = "AllScannedAPs";
    goto LABEL_5;
  }
  if (!a1)
  {
    uint64_t v4 = "ServingApOnly";
LABEL_5:
    return sub_100134750(a2, v4);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  long long v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109120;
    int v9 = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#wlan,apConfigToString,undefined AccessPointConfig,%d\n", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static std::string CLEmergencyController::LocationSettings::Emergency::Settings::apConfigToString(AccessPointConfig)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return sub_100134750(a2, "undefined");
}

void *sub_101030488@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 1)
  {
    uint64_t v4 = "Cdma";
    goto LABEL_5;
  }
  if (!a1)
  {
    uint64_t v4 = "Gps";
LABEL_5:
    return sub_100134750(a2, v4);
  }
  if (qword_1024193E0 != -1) {
    dispatch_once(&qword_1024193E0, &stru_10230B640);
  }
  long long v6 = qword_1024193E8;
  if (os_log_type_enabled((os_log_t)qword_1024193E8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109120;
    int v9 = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "undefined MeasurementTimeStampSource,%d\n", buf, 8u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024193E0 != -1) {
      dispatch_once(&qword_1024193E0, &stru_10230B640);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static std::string CLEmergencyController::LocationSettings::Emergency::measTimeStampSourceToString(MeasurementTimeStampSource)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return sub_100134750(a2, "undefined");
}

uint64_t sub_1010306C4(uint64_t a1)
{
  sub_10010F274((uint64_t)v35);
  uint64_t v2 = sub_100132EFC(v36, (uint64_t)"smsAddress,", 11);
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  long long v6 = sub_100132EFC(v2, v4, v5);
  sub_100132EFC(v6, (uint64_t)",sendBinarySms,", 15);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_100132EFC(v7, (uint64_t)",smsDestinationPort,", 20);
  uint64_t v8 = (void *)std::ostream::operator<<();
  int v9 = sub_100132EFC(v8, (uint64_t)",httpsAddress,", 14);
  int v10 = *(char *)(a1 + 55);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 32;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 32);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 55);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 40);
  }
  char v13 = sub_100132EFC(v9, v11, v12);
  sub_100132EFC(v13, (uint64_t)",firstFixDelay,", 15);
  uint64_t v14 = (void *)std::ostream::operator<<();
  sub_100132EFC(v14, (uint64_t)",multipleSmsEnabled,", 20);
  long long v15 = (void *)std::ostream::operator<<();
  sub_100132EFC(v15, (uint64_t)",maxFixDelay,", 13);
  uint64_t v16 = (void *)std::ostream::operator<<();
  sub_100132EFC(v16, (uint64_t)",minFixDelay,", 13);
  uint64_t v17 = (void *)std::ostream::operator<<();
  char v18 = sub_100132EFC(v17, (uint64_t)",smsOverNasAddress,", 19);
  int v19 = *(char *)(a1 + 111);
  if (v19 >= 0) {
    uint64_t v20 = a1 + 88;
  }
  else {
    uint64_t v20 = *(void *)(a1 + 88);
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 111);
  }
  else {
    uint64_t v21 = *(void *)(a1 + 96);
  }
  unsigned __int8 v22 = sub_100132EFC(v18, v20, v21);
  sub_100132EFC(v22, (uint64_t)",AmlEnableForSatellitePLMNs,", 28);
  char v23 = (void *)std::ostream::operator<<();
  sub_100132EFC(v23, (uint64_t)",AmlOverNASEnableForMCCOrPLMNs,[", 32);
  uint64_t v24 = *(void *)(a1 + 120);
  uint64_t v25 = *(void *)(a1 + 128);
  if (v24 != v25)
  {
    do
    {
      unsigned __int8 v26 = sub_100132EFC(v36, (uint64_t)"{", 1);
      int v27 = *(char *)(v24 + 23);
      if (v27 >= 0) {
        uint64_t v28 = v24;
      }
      else {
        uint64_t v28 = *(void *)v24;
      }
      if (v27 >= 0) {
        uint64_t v29 = *(unsigned __int8 *)(v24 + 23);
      }
      else {
        uint64_t v29 = *(void *)(v24 + 8);
      }
      id v30 = sub_100132EFC(v26, v28, v29);
      sub_100132EFC(v30, (uint64_t)"},", 2);
      v24 += 24;
    }
    while (v24 != v25);
    if (*(void *)(a1 + 128) != *(void *)(a1 + 120))
    {
      std::ostream::sentry::sentry();
      id v31 = (char *)v36 + *(void *)(v36[0] - 24);
      if ((v31[32] & 5) == 0)
      {
        (*(void (**)(void *__return_ptr))(**((void **)v31 + 5) + 32))(v38);
        if (v38[16] == -1) {
          std::ios_base::clear((std::ios_base *)((char *)v36 + *(void *)(v36[0] - 24)), *(_DWORD *)((char *)&v36[4] + *(void *)(v36[0] - 24)) | 4);
        }
      }
      std::ostream::sentry::~sentry();
    }
  }
  unsigned int v32 = sub_100132EFC(v36, (uint64_t)"]", 1);
  sub_100132EFC(v32, (uint64_t)",maAmloverNASFirstFixDelay,", 27);
  std::ostream::operator<<();
  std::stringbuf::str();
  *(void *)((char *)v35
  v36[0] = v33;
  if (v37 < 0) {
    operator delete((void *)v36[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101030AEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostream::sentry::~sentry();
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101030B20(uint64_t a1)
{
  sub_10010F274((uint64_t)v49);
  sub_100132EFC(v50, (uint64_t)"enabled,", 8);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_100132EFC(v2, (uint64_t)",adrEnabled,", 12);
  int v3 = (void *)std::ostream::operator<<();
  sub_100132EFC(v3, (uint64_t)",requestsEnabled,", 17);
  uint64_t v4 = (void *)std::ostream::operator<<();
  uint64_t v5 = sub_100132EFC(v4, (uint64_t)",lisUrl,", 8);
  int v6 = *(char *)(a1 + 31);
  if (v6 >= 0) {
    uint64_t v7 = a1 + 8;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 16);
  }
  int v9 = sub_100132EFC(v5, v7, v8);
  int v10 = sub_100132EFC(v9, (uint64_t)",adrUrl,", 8);
  int v11 = *(char *)(a1 + 55);
  if (v11 >= 0) {
    uint64_t v12 = a1 + 32;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 32);
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 55);
  }
  else {
    uint64_t v13 = *(void *)(a1 + 40);
  }
  uint64_t v14 = sub_100132EFC(v10, v12, v13);
  long long v15 = sub_100132EFC(v14, (uint64_t)",controlUrl,", 12);
  int v16 = *(char *)(a1 + 79);
  if (v16 >= 0) {
    uint64_t v17 = a1 + 56;
  }
  else {
    uint64_t v17 = *(void *)(a1 + 56);
  }
  if (v16 >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a1 + 79);
  }
  else {
    uint64_t v18 = *(void *)(a1 + 64);
  }
  int v19 = sub_100132EFC(v15, v17, v18);
  sub_100132EFC(v19, (uint64_t)",firstLisPostDelay,", 19);
  uint64_t v20 = (void *)std::ostream::operator<<();
  sub_100132EFC(v20, (uint64_t)",periodicLisPostDelay,", 22);
  uint64_t v21 = (void *)std::ostream::operator<<();
  sub_100132EFC(v21, (uint64_t)",initialAdrPostTimeout,", 23);
  unsigned __int8 v22 = (void *)std::ostream::operator<<();
  char v23 = sub_100132EFC(v22, (uint64_t)",intermediateCert,", 18);
  int v24 = *(char *)(a1 + 127);
  if (v24 >= 0) {
    uint64_t v25 = a1 + 104;
  }
  else {
    uint64_t v25 = *(void *)(a1 + 104);
  }
  if (v24 >= 0) {
    uint64_t v26 = *(unsigned __int8 *)(a1 + 127);
  }
  else {
    uint64_t v26 = *(void *)(a1 + 112);
  }
  int v27 = sub_100132EFC(v23, v25, v26);
  sub_100132EFC(v27, (uint64_t)",dsaEnabled,", 12);
  uint64_t v28 = (void *)std::ostream::operator<<();
  sub_100132EFC(v28, (uint64_t)",unmaskCrashDetection,", 22);
  uint64_t v29 = (void *)std::ostream::operator<<();
  sub_100132EFC(v29, (uint64_t)",partnerInfoVec,[", 17);
  uint64_t v30 = *(void *)(a1 + 136);
  uint64_t v31 = *(void *)(a1 + 144);
  if (v30 != v31)
  {
    do
    {
      unsigned int v32 = sub_100132EFC(v50, (uint64_t)"{", 1);
      sub_1010310D0(v30);
      if ((v54 & 0x80u) == 0) {
        uint64_t v33 = (void **)&v52;
      }
      else {
        uint64_t v33 = v52;
      }
      if ((v54 & 0x80u) == 0) {
        uint64_t v34 = v54;
      }
      else {
        uint64_t v34 = v53;
      }
      uint64_t v35 = sub_100132EFC(v32, (uint64_t)v33, v34);
      sub_100132EFC(v35, (uint64_t)"},", 2);
      if ((char)v54 < 0) {
        operator delete(v52);
      }
      v30 += 80;
    }
    while (v30 != v31);
    if (*(void *)(a1 + 144) != *(void *)(a1 + 136))
    {
      std::ostream::sentry::sentry();
      unsigned int v36 = (char *)v50 + *(void *)(v50[0] - 24);
      if ((v36[32] & 5) == 0)
      {
        (*(void (**)(void ***__return_ptr))(**((void **)v36 + 5) + 32))(&v52);
        if (v55 == -1) {
          std::ios_base::clear((std::ios_base *)((char *)v50 + *(void *)(v50[0] - 24)), *(_DWORD *)((char *)&v50[4] + *(void *)(v50[0] - 24)) | 4);
        }
      }
      std::ostream::sentry::~sentry();
    }
  }
  char v37 = sub_100132EFC(v50, (uint64_t)"]", 1);
  unsigned int v38 = sub_100132EFC(v37, (uint64_t)",mitigationsConfig,", 19);
  sub_100922BF8();
  if ((v54 & 0x80u) == 0) {
    uint64_t v39 = (void **)&v52;
  }
  else {
    uint64_t v39 = v52;
  }
  if ((v54 & 0x80u) == 0) {
    uint64_t v40 = v54;
  }
  else {
    uint64_t v40 = v53;
  }
  uint64_t v41 = sub_100132EFC(v38, (uint64_t)v39, v40);
  unsigned int v42 = sub_100132EFC(v41, (uint64_t)",uploadConfig,", 14);
  sub_1010312F8();
  if ((v48 & 0x80u) == 0) {
    unsigned int v43 = __p;
  }
  else {
    unsigned int v43 = (void **)__p[0];
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v44 = v48;
  }
  else {
    uint64_t v44 = (uint64_t)__p[1];
  }
  sub_100132EFC(v42, (uint64_t)v43, v44);
  if ((char)v48 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v54 < 0) {
    operator delete(v52);
  }
  std::stringbuf::str();
  *(void *)((char *)v49
  v50[0] = v45;
  if (v51 < 0) {
    operator delete((void *)v50[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10103105C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1010310D0(uint64_t a1)
{
  sub_10010F274((uint64_t)v22);
  uint64_t v2 = sub_100132EFC(v23, (uint64_t)"partnerId,", 10);
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  int v6 = sub_100132EFC(v2, v4, v5);
  uint64_t v7 = sub_100132EFC(v6, (uint64_t)",adrCert,", 9);
  int v8 = *(char *)(a1 + 47);
  if (v8 >= 0) {
    uint64_t v9 = a1 + 24;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 24);
  }
  if (v8 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v10 = *(void *)(a1 + 32);
  }
  int v11 = sub_100132EFC(v7, v9, v10);
  sub_100132EFC(v11, (uint64_t)",requestsSupported,", 19);
  uint64_t v12 = (void *)std::ostream::operator<<();
  uint64_t v13 = sub_100132EFC(v12, (uint64_t)",baseURL,", 9);
  uint64_t v16 = *(void *)(a1 + 56);
  uint64_t v15 = a1 + 56;
  uint64_t v14 = v16;
  int v17 = *(char *)(v15 + 23);
  if (v17 >= 0) {
    uint64_t v18 = v15;
  }
  else {
    uint64_t v18 = v14;
  }
  if (v17 >= 0) {
    uint64_t v19 = *(unsigned __int8 *)(v15 + 23);
  }
  else {
    uint64_t v19 = *(void *)(v15 + 8);
  }
  sub_100132EFC(v13, v18, v19);
  std::stringbuf::str();
  *(void *)((char *)v22
  v23[0] = v20;
  if (v24 < 0) {
    operator delete((void *)v23[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1010312E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1010312F8()
{
  sub_10010F274((uint64_t)v4);
  sub_100132EFC(v5, (uint64_t)"numInFlightUploads,", 19);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_100132EFC(v0, (uint64_t)",maxUploadFileSizeMB,", 21);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_100132EFC(v1, (uint64_t)",maxUploadQuotaMB,", 18);
  std::ostream::operator<<();
  std::stringbuf::str();
  *(void *)((char *)v4
  v5[0] = v2;
  if (v6 < 0) {
    operator delete((void *)v5[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1010314AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101A129A8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1010314C4()
{
}

void *sub_1010314D8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_10230B6B0;
  result[1] = v3;
  return result;
}

uint64_t sub_101031520(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_10230B6B0;
  a2[1] = v2;
  return result;
}

void sub_10103154C(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_101031558(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101031598()
{
}

uint64_t sub_1010315A4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1014785D4();
    operator delete();
  }
  return result;
}

uint64_t sub_1010315F4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1011FAB68();
    operator delete();
  }
  return result;
}

uint64_t sub_101031644(uint64_t a1)
{
  sub_101031680(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_101031680(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_100562C84((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t sub_1010316C4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1008C2124(result);
    operator delete();
  }
  return result;
}

uint64_t *sub_101031714(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v4) {
            break;
          }
        }
      }
    }
  }
  sub_10103195C(a1, *a2, a4, (uint64_t)v21);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100100330(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
      else {
        unint64_t v4 = v6;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void **)(*(void *)a1 + 8 * v4);
  if (v18)
  {
    *(void *)v21[0] = *v18;
    *uint64_t v18 = v21[0];
  }
  else
  {
    *(void *)v21[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v21[0])
    {
      unint64_t v19 = *(void *)(*(void *)v21[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v19 >= v7) {
          v19 %= v7;
        }
      }
      else
      {
        v19 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v19) = v21[0];
    }
  }
  uint64_t i = (uint64_t *)v21[0];
  v21[0] = 0;
  ++*(void *)(a1 + 24);
  sub_101031AE0((uint64_t)v21, 0);
  return i;
}

void sub_101031944(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101031AE0((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10103195C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0xA8uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0;
  v8[1] = a2;
  *((_DWORD *)v8 + 4) = **a3;
  uint64_t result = sub_1010319D8((uint64_t)(v8 + 3));
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1010319C0(_Unwind_Exception *a1)
{
  sub_101031AE0(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1010319D8(uint64_t a1)
{
  *(_DWORD *)a1 = 255;
  sub_100134750((void *)(a1 + 8), (char *)[@"kBundleIDUnavailable" UTF8String]);
  *(unsigned char *)(a1 + 32) = 0;
  sub_100134750((void *)(a1 + 40), (char *)[@"kBundleVersionUnavailable" UTF8String]);
  *(unsigned char *)(a1 + 64) = 0;
  sub_1000E9354(a1 + 72);
  *(unsigned char *)(a1 + 88) = 0;
  sub_1000E9354(a1 + 96);
  *(unsigned char *)(a1 + 112) = 0;
  sub_1000E9354(a1 + 120);
  *(unsigned char *)(a1 + 136) = 0;
  return a1;
}

void sub_101031A88(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  sub_10013F3C4(v6);
  sub_10013F3C4(v5);
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(a1);
}

void sub_101031AE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100562C84((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }
}

void *sub_101031B38(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a1 = off_10234BF80;
  id v9 = a5;
  *a1 = off_10230B730;
  a1[1] = v9;
  a1[2] = a3;
  a1[3] = a4;
  id v10 = a2;
  a1[5] = 0;
  a1[4] = v10;
  a1[6] = 0;
  v14[0] = 0;
  v14[1] = v14;
  int v14[2] = 0x2020000000;
  char v15 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472;
  aBlock[2] = sub_101031CC0;
  aBlock[3] = &unk_1022B6BE8;
  aBlock[4] = v14;
  a1[5] = _Block_copy(aBlock);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  void v12[2] = sub_101031CD4;
  uint64_t v12[3] = &unk_1022B6C10;
  v12[4] = v14;
  a1[6] = _Block_copy(v12);
  _Block_object_dispose(v14, 8);
  return a1;
}

void sub_101031C98(_Unwind_Exception *a1)
{
  sub_1019D78CC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101031CC0(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

BOOL sub_101031CD4(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void sub_101031CF0(uint64_t a1)
{
  sub_101031FE4(a1);

  operator delete();
}

id sub_101031D28(void *a1, int a2, void *__src, unint64_t a4)
{
  if (a4 >= 0x10) {
    size_t v8 = 16;
  }
  else {
    size_t v8 = a4;
  }
  memcpy(&__dst, __src, v8);
  if (a4 >= 0x11)
  {
    if (qword_102418FD0 != -1) {
      dispatch_once(&qword_102418FD0, &stru_10230B770);
    }
    id v9 = qword_102418FD8;
    if (os_log_type_enabled((os_log_t)qword_102418FD8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136315906;
      unint64_t v29 = 0x8000000101D9D33DLL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v30 = 2048;
      uint64_t v31 = 16;
      __int16 v32 = 2048;
      unint64_t v33 = a4;
      __int16 v34 = 1024;
      int v35 = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d", buf, 0x26u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102418FD0 != -1) {
        dispatch_once(&qword_102418FD0, &stru_10230B770);
      }
      int v20 = 136315906;
      unint64_t v21 = 0x8000000101D9D33DLL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v22 = 2048;
      uint64_t v23 = 16;
      __int16 v24 = 2048;
      unint64_t v25 = a4;
      __int16 v26 = 1024;
      int v27 = a2;
      char v15 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMotionNotifier::SiloDispatcher<CLOrientationNotifier::Sample>::dispatchData(int, const void *, size_t) [T = CLOrientationNotifier::Sample]", "%s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
  }
  uint64_t v11 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v12 = a1[6];
  float v13 = (void *)a1[4];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  void v16[2] = sub_101032060;
  v16[3] = &unk_1022F1228;
  v16[4] = v12;
  v16[5] = v11;
  long long v17 = __dst;
  uint64_t v18 = v10;
  return [v13 async:v16];
}

uint64_t sub_101031FE4(uint64_t a1)
{
  *(void *)a1 = off_10230B730;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));

  return sub_1019D78CC(a1);
}

uint64_t sub_101032060(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1[4] + 16))();
  if (result)
  {
    uint64_t v3 = (uint64_t (*)(void *, uint64_t))a1[5];
    uint64_t v4 = a1[8];
    return v3(a1 + 6, v4);
  }
  return result;
}

void sub_1010320BC(id a1)
{
  qword_102418FD8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_1010320EC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10102ECD4(a2, (uint64_t *)(a1 + 32));
}

uint64_t sub_1010320F8(uint64_t a1, uint64_t a2)
{
  return sub_10102ECD4(a1 + 32, (uint64_t *)(a2 + 32));
}

uint64_t sub_101032104(uint64_t a1)
{
  return sub_10084DD34(a1 + 32);
}

__n128 sub_10103210C@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = a1[2];
  *a2 = result;
  a2[1].n128_u32[0] = a1[3].n128_u32[0];
  return result;
}

void sub_101032120(std::locale *a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_1016F8DD4(a1);
  LODWORD(v4[3].__locale_) = a3;
  *(_OWORD *)((char *)&v4[3].__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v4[5].__locale_ + 4) = 0u;
  HIDWORD(v4[7].__locale_) = 0;
  sub_1010321C0();
}

void sub_1010321A0(_Unwind_Exception *a1)
{
  locale = (std::__shared_weak_count *)v1[6].__locale_;
  if (locale) {
    sub_1000DB0A0(locale);
  }
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_1010321C0()
{
}

void sub_101032380(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1010323B4()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_parse);
}

void sub_1010323F8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_10103240C(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v6 = sub_101032A5C(a1, a2, a3);
  if (v6 == a2) {
    operator new();
  }
  if (v6 == (unsigned __int8 *)a3) {
    return (unsigned __int8 *)a3;
  }
  if (*v6 == 124)
  {
    if (v6 + 1 == sub_101032A5C(a1, v6 + 1, a3)) {
      operator new();
    }
    sub_1016F98B8();
  }
  return v6;
}

unsigned __int8 *sub_101032544(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v4 = a3;
  if (*a2 == 94) {
    sub_10103326C();
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = sub_1010376C4(a1, v3, v4);
    }
    while (v6 != v3);
    if (v6 != v4)
    {
      if (v6 + 1 == v4 && *v6 == 36) {
        sub_1016FA1C4();
      }
      sub_10103766C();
    }
  }
  return v4;
}

char *sub_1010325F4(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = sub_101037C0C(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
LABEL_8:
  }
    sub_10103766C();
  uint64_t v7 = v6;
  if (v6 == (unsigned __int8 *)a3) {
    return a3;
  }
  if (*v6 == 124)
  {
    if (v6 + 1 != sub_101037C0C(a1, (char *)v6 + 1, a3)) {
      sub_1016F98B8();
    }
    goto LABEL_8;
  }
  return (char *)v7;
}

unsigned __int8 *sub_101032698(uint64_t a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  uint64_t v6 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = a3;
  }
  if (v7 == __s) {
    operator new();
  }
  sub_101032544(a1, __s, v7);
  if (v7 == a3) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = v7 + 1;
  }
  if (v10 != a3)
  {
    size_t v8 = (unsigned __int8 *)memchr(v10, 10, a3 - v10);
    if (v8) {
      id v9 = v8;
    }
    else {
      id v9 = a3;
    }
    if (v9 != v10)
    {
      sub_101032544(a1, v10, v9);
      sub_1016F98B8();
    }
    operator new();
  }
  return a3;
}

char *sub_101032800(uint64_t a1, char *__s, char *a3)
{
  uint64_t v6 = (char *)memchr(__s, 10, a3 - __s);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = a3;
  }
  if (v7 == __s) {
    operator new();
  }
  sub_1010325F4(a1, __s, v7);
  if (v7 == a3) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = v7 + 1;
  }
  if (v10 != a3)
  {
    size_t v8 = (char *)memchr(v10, 10, a3 - v10);
    if (v8) {
      id v9 = v8;
    }
    else {
      id v9 = a3;
    }
    if (v9 != v10)
    {
      sub_1010325F4(a1, v10, v9);
      sub_1016F98B8();
    }
    operator new();
  }
  return a3;
}

void sub_101032968()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_grammar);
}

void sub_1010329AC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1010329C0(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

uint64_t sub_1010329D4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101032A04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101032A48(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + 8);
  return result;
}

unsigned __int8 *sub_101032A5C(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  do
  {
    uint64_t v5 = a2;
    a2 = sub_101032AA8(a1, (char *)a2, a3);
  }
  while (v5 != a2);
  return v5;
}

unsigned __int8 *sub_101032AA8(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)sub_101032B50(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    uint64_t v7 = sub_101032D68(a1, (unsigned __int8 *)a2, a3);
    uint64_t result = (unsigned __int8 *)a2;
    if (v7 != (unsigned __int8 *)a2)
    {
      return sub_101032F60(a1, v7, (unsigned __int8 *)a3);
    }
  }
  return result;
}

char *sub_101032B50(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v6 = *a2;
    if (v6 > 91)
    {
      if (v6 == 92)
      {
        if (a2 + 1 != a3)
        {
          int v9 = a2[1];
          if (v9 == 66 || v9 == 98) {
            sub_1016FA248();
          }
        }
      }
      else if (v6 == 94)
      {
        sub_10103326C();
      }
    }
    else
    {
      if (v6 == 36) {
        sub_1016FA1C4();
      }
      if (v6 == 40 && a2 + 1 != a3 && a2[1] == 63 && a2 + 2 != a3)
      {
        int v7 = a2[2];
        if (v7 == 33)
        {
          sub_1016F8DD4(v10);
          long long v11 = 0u;
          uint64_t v13 = 0;
          long long v12 = 0u;
          LODWORD(v11) = *(_DWORD *)(a1 + 24);
          sub_1010321C0(v10, a2 + 3, a3);
          sub_1016FA2DC();
        }
        if (v7 == 61)
        {
          sub_1016F8DD4(v10);
          long long v11 = 0u;
          uint64_t v13 = 0;
          long long v12 = 0u;
          LODWORD(v11) = *(_DWORD *)(a1 + 24);
          sub_1010321C0(v10, a2 + 3, a3);
          sub_1016FA2DC();
        }
      }
    }
  }
  return a2;
}

void sub_101032D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *sub_101032D68(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 != (unsigned __int8 *)a3)
  {
    int v6 = (char)*a2;
    if (v6 <= 62)
    {
      if (v6 != 40)
      {
        if (v6 == 46) {
          operator new();
        }
        if ((v6 - 42) >= 2) {
          return sub_1010341C8(a1, a2, a3);
        }
LABEL_28:
        sub_101034170();
      }
      size_t v8 = a2 + 1;
      if (a2 + 1 != (unsigned __int8 *)a3)
      {
        if (a2 + 2 != (unsigned __int8 *)a3 && *v8 == 63 && a2[2] == 58)
        {
          ++*(_DWORD *)(a1 + 36);
          int v9 = (char *)sub_10103240C(a1, a2 + 3, a3);
          if (v9 != a3 && *v9 == 41)
          {
            --*(_DWORD *)(a1 + 36);
            return (unsigned __int8 *)(v9 + 1);
          }
        }
        else
        {
          sub_1016FB0EC(a1);
          ++*(_DWORD *)(a1 + 36);
          uint64_t v10 = (char *)sub_10103240C(a1, v8, a3);
          if (v10 != a3)
          {
            long long v11 = v10;
            if (*v10 == 41)
            {
              sub_1016FB170(a1);
              --*(_DWORD *)(a1 + 36);
              return (unsigned __int8 *)(v11 + 1);
            }
          }
        }
      }
      sub_1010332F0();
    }
    if (v6 > 91)
    {
      if (v6 == 92) {
        return sub_101033FB8(a1, a2, (unsigned __int8 *)a3);
      }
      if (v6 == 123) {
        goto LABEL_28;
      }
    }
    else
    {
      if (v6 == 91) {
        return sub_10103405C(a1, a2, a3);
      }
      if (v6 == 63) {
        goto LABEL_28;
      }
    }
    return sub_1010341C8(a1, a2, a3);
  }
  return v3;
}

unsigned __int8 *sub_101032F60(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v5 = (char)*a2;
  if (v5 <= 62)
  {
    if (v5 == 42 || (int v6 = a2, v5 == 43)) {
LABEL_18:
    }
      sub_1016FD808();
    return v6;
  }
  if (v5 == 63) {
    goto LABEL_18;
  }
  int v6 = a2;
  if (v5 == 123)
  {
    int v7 = a2 + 1;
    size_t v8 = sub_101037250(a1, a2 + 1, a3, &v14);
    if (v7 == v8) {
      goto LABEL_24;
    }
    if (v8 != a3)
    {
      int v9 = (char)*v8;
      if (v9 != 44)
      {
        if (v9 == 125) {
          goto LABEL_18;
        }
LABEL_24:
        sub_1010372F0();
      }
      uint64_t v10 = v8 + 1;
      if (v8 + 1 == a3) {
        goto LABEL_24;
      }
      if (*v10 == 125) {
        goto LABEL_18;
      }
      int v13 = -1;
      long long v12 = sub_101037250(a1, v10, a3, &v13);
      if (v10 != v12 && v12 != a3 && *v12 == 125)
      {
        if (v13 >= v14) {
          goto LABEL_18;
        }
        goto LABEL_24;
      }
    }
    sub_101037348();
  }
  return v6;
}

void sub_10103326C()
{
}

void sub_1010332F0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_paren);
}

void sub_101033334(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101033348(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(unsigned char *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }
  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v4;
  return result;
}

uint64_t sub_1010333A8(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v5;
  return result;
}

uint64_t sub_1010333F8(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          int v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  int v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  int v11 = v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v12;
  return result;
}

uint64_t sub_10103350C(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  *(void *)a1 = off_10230BA40;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = *(_OWORD *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 8sub_100FB8FC8(&a9, 0) = a5;
  *(unsigned char *)(a1 + 84) = a3;
  return a1;
}

void sub_10103359C(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  char v25 = 0;
  long long v26 = 0uLL;
  char v27 = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  int __p = 0;
  unint64_t v19 = 0;
  unint64_t v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v20 = 0;
  *(void *)&long long v21 = v5;
  *((void *)&v21 + 1) = v5;
  char v22 = 0;
  sub_101033728((char **)&__p, v4, &v21);
  uint64_t v23 = v6;
  uint64_t v24 = v6;
  char v25 = 0;
  long long v26 = v21;
  char v27 = v22;
  uint64_t v29 = v6;
  char v28 = 1;
  uint64_t v7 = *(void *)(a2 + 16);
  if (*(unsigned char *)(a2 + 92)) {
    BOOL v8 = v7 == *(void *)(a2 + 8);
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  if (*(unsigned __int8 *)(a1 + 84) == sub_1016FA880(a1 + 16, v7, *(void *)(a2 + 24), (uint64_t *)&__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v9))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = 0;
    int v10 = (char *)__p;
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(a1 + 8);
  int v10 = (char *)__p;
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (unsigned char *)__p) >> 3);
  if (v11 < 2)
  {
LABEL_13:
    if (!v10) {
      return;
    }
    goto LABEL_14;
  }
  int v12 = 0;
  int v13 = *(_DWORD *)(a1 + 80);
  uint64_t v14 = *(void *)(a2 + 32);
  unint64_t v15 = 1;
  do
  {
    unint64_t v16 = &v10[24 * v15];
    uint64_t v17 = v14 + 24 * (v13 + v12);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
    *(unsigned char *)(v17 + 16) = v16[16];
    unint64_t v15 = (v12 + 2);
    ++v12;
  }
  while (v11 > v15);
LABEL_14:
  unint64_t v19 = v10;
  operator delete(v10);
}

void sub_101033708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_101033728(char **a1, unint64_t a2, long long *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) >= a2)
  {
    unint64_t v15 = a1[1];
    unint64_t v16 = (v15 - result) / 24;
    if (v16 >= a2) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = (v15 - result) / 24;
    }
    if (v17)
    {
      uint64_t v18 = result;
      do
      {
        *(_OWORD *)uint64_t v18 = *a3;
        v18[16] = *((unsigned char *)a3 + 16);
        v18 += 24;
        --v17;
      }
      while (v17);
    }
    if (a2 <= v16)
    {
      a1[1] = &result[24 * a2];
    }
    else
    {
      unint64_t v19 = &v15[24 * (a2 - v16)];
      uint64_t v20 = 24 * a2 - 24 * v16;
      do
      {
        long long v21 = *a3;
        *((void *)v15 + 2) = *((void *)a3 + 2);
        *(_OWORD *)unint64_t v15 = v21;
        v15 += 24;
        v20 -= 24;
      }
      while (v20);
      a1[1] = v19;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t result = sub_1000DA584(a1, v10);
    unint64_t v11 = a1[1];
    int v12 = &v11[24 * a2];
    uint64_t v13 = 24 * a2;
    do
    {
      long long v14 = *a3;
      *((void *)v11 + 2) = *((void *)a3 + 2);
      *(_OWORD *)unint64_t v11 = v14;
      v11 += 24;
      v13 -= 24;
    }
    while (v13);
    a1[1] = v12;
  }
  return result;
}

void sub_1010338A0(uint64_t a1, unint64_t a2, long long *a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v4 = a2 >= v3;
  unint64_t v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    sub_101033C78((void **)a1, v5, a3);
  }
  else if (!v4)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 24 * a2;
  }
}

void sub_1010338DC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    sub_101033E00((void **)a1, a2 - v2);
  }
}

void sub_10103390C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_complexity);
}

void sub_101033950(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_101033964()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_unknown);
}

void sub_1010339A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010339BC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_101033A34((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_101033A34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 80);
      *(_OWORD *)(v7 - 96) = *(_OWORD *)(a3 - 96);
      *(_OWORD *)(v7 - 8sub_100FB8FC8(&a9, 0) = v8;
      *(void *)(v7 - 56) = 0;
      *(void *)(v7 - 48) = 0;
      *(void *)(v7 - 64) = 0;
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(void *)(v7 - 48) = *(void *)(a3 - 48);
      *(void *)(a3 - 64) = 0;
      *(void *)(a3 - 56) = 0;
      *(void *)(a3 - 48) = 0;
      *(void *)(v7 - 4sub_100FB8FC8(&a9, 0) = 0;
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 4sub_100FB8FC8(&a9, 0) = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(void *)(a3 - 4sub_100FB8FC8(&a9, 0) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 24) = 0;
      uint64_t v9 = *(void *)(a3 - 16);
      *(void *)(v7 - 11) = *(void *)(a3 - 11);
      *(void *)(v7 - 16) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 96;
      *((void *)&v15 + 1) -= 96;
      a3 -= 96;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_101033B18((uint64_t)v12);
  return v10;
}

uint64_t sub_101033B18(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_101033B50((uint64_t *)a1);
  }
  return a1;
}

void sub_101033B50(uint64_t *a1)
{
  uint64_t v1 = *(void **)(a1[2] + 8);
  unint64_t v2 = *(void **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_101033BA4(v3, v1);
      v1 += 12;
    }
    while (v1 != v2);
  }
}

void sub_101033BA4(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[7];
  if (v3)
  {
    a2[8] = v3;
    operator delete(v3);
  }
  BOOL v4 = (void *)a2[4];
  if (v4)
  {
    a2[5] = v4;
    operator delete(v4);
  }
}

void **sub_101033BFC(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_101033C30(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 96;
    sub_101033BA4(v4, (void *)(i - 96));
  }
}

void sub_101033C78(void **a1, unint64_t a2, long long *a3)
{
  long long v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(void **)(v6 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (unsigned char *)v9) >> 3) >= a2)
  {
    if (a2)
    {
      long long v15 = &v9[3 * a2];
      uint64_t v16 = 24 * a2;
      do
      {
        long long v17 = *a3;
        void v9[2] = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v9 = v17;
        v9 += 3;
        v16 -= 24;
      }
      while (v16);
      uint64_t v9 = v15;
    }
    a1[1] = v9;
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (unsigned char *)*a1) >> 3);
    unint64_t v11 = v10 + a2;
    if (v10 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      long long v14 = (char *)sub_1000DA5D8(v6, v13);
    }
    else {
      long long v14 = 0;
    }
    uint64_t v18 = &v14[24 * v10];
    unint64_t v19 = &v18[24 * a2];
    uint64_t v20 = 24 * a2;
    long long v21 = v18;
    do
    {
      long long v22 = *a3;
      *((void *)v21 + 2) = *((void *)a3 + 2);
      *(_OWORD *)long long v21 = v22;
      v21 += 24;
      v20 -= 24;
    }
    while (v20);
    uint64_t v23 = &v14[24 * v13];
    char v25 = (char *)*a1;
    uint64_t v24 = (char *)a1[1];
    if (v24 != *a1)
    {
      do
      {
        long long v26 = *(_OWORD *)(v24 - 24);
        *((void *)v18 - 1) = *((void *)v24 - 1);
        *(_OWORD *)(v18 - 24) = v26;
        v18 -= 24;
        v24 -= 24;
      }
      while (v24 != v25);
      uint64_t v24 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v23;
    if (v24)
    {
      operator delete(v24);
    }
  }
}

void sub_101033E00(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)sub_1000C571C(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    long long v14 = &v13[16 * v10];
    long long v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    uint64_t v18 = (char *)*a1;
    long long v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      long long v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void sub_101033F20(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        sub_101033BA4((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *sub_101033FB8(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  uint64_t v5 = a2 + 1;
  if (a2 + 1 == a3) {
    sub_10103423C();
  }
  uint64_t result = sub_101034294(a1, a2 + 1, a3);
  if (v5 == result)
  {
    uint64_t result = (unsigned __int8 *)sub_10103434C(a1, (char *)a2 + 1, (char *)a3);
    if (v5 == result)
    {
      uint64_t result = sub_10103441C(a1, (char *)a2 + 1, (char *)a3, 0);
      if (v5 == result) {
        return a2;
      }
    }
  }
  return result;
}

unsigned char *sub_10103405C(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      sub_1016FBFE8();
    }
    sub_101035914();
  }
  return a2;
}

void sub_101034170()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badrepeat);
}

void sub_1010341B4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1010341C8(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3)
  {
    int v3 = (char)*a2;
    BOOL v4 = (v3 - 36) > 0x3A || ((1 << (*a2 - 36)) & 0x7800000080004F1) == 0;
    if (v4 && (v3 - 123) >= 3) {
      sub_1016FB6A8(a1);
    }
  }
  return a2;
}

void sub_10103423C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_escape);
}

void sub_101034280(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_101034294(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    unsigned int v5 = v4 - 48;
    if (v4 == 48) {
      sub_1016FB6A8(a1);
    }
    if ((v4 - 49) <= 8)
    {
      uint64_t v6 = a2 + 1;
      if (v6 == a3) {
        goto LABEL_10;
      }
      do
      {
        int v7 = *v6;
        if ((v7 - 48) > 9) {
          break;
        }
        if (v5 >= 0x19999999) {
          goto LABEL_13;
        }
        ++v6;
        unsigned int v5 = v7 + 10 * v5 - 48;
      }
      while (v6 != a3);
      if (v5)
      {
LABEL_10:
        if (v5 <= *(_DWORD *)(a1 + 28)) {
          sub_1016FB7E8(a1);
        }
      }
LABEL_13:
      sub_101034730();
    }
  }
  return a2;
}

char *sub_10103434C(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v3 = *a2;
  if (v3 > 99)
  {
    if (v3 == 119) {
      goto LABEL_12;
    }
    if (v3 == 115) {
LABEL_13:
    }
      sub_1016FBFE8();
    if (v3 != 100) {
      return a2;
    }
LABEL_10:
    sub_1016FBFE8();
  }
  switch(v3)
  {
    case 'D':
      goto LABEL_10;
    case 'S':
      goto LABEL_13;
    case 'W':
LABEL_12:
      sub_1016FBFE8();
  }
  return a2;
}

unsigned __int8 *sub_10103441C(uint64_t a1, char *a2, char *a3, std::string *this)
{
  int v4 = a2;
  if (a2 == a3) {
    return (unsigned __int8 *)v4;
  }
  int v5 = *a2;
  if (v5 > 109)
  {
    char v6 = 0;
    switch(*a2)
    {
      case 'n':
        if (!this) {
          goto LABEL_54;
        }
        int v7 = this;
        std::string::value_type v8 = 10;
        goto LABEL_52;
      case 'r':
        if (!this) {
          goto LABEL_54;
        }
        int v7 = this;
        std::string::value_type v8 = 13;
        goto LABEL_52;
      case 't':
        if (!this) {
          goto LABEL_54;
        }
        int v7 = this;
        std::string::value_type v8 = 9;
        goto LABEL_52;
      case 'u':
        if (a2 + 1 == a3) {
          goto LABEL_57;
        }
        int v9 = a2[1];
        if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38 && (v9 | 0x20u) - 97 >= 6) {
          goto LABEL_57;
        }
        int v4 = a2 + 2;
        if (a2 + 2 == a3) {
          goto LABEL_57;
        }
        int v10 = *v4;
        char v11 = -48;
        if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
          goto LABEL_24;
        }
        v10 |= 0x20u;
        if ((v10 - 97) >= 6) {
          goto LABEL_57;
        }
        char v11 = -87;
LABEL_24:
        char v6 = 16 * (v11 + v10);
LABEL_25:
        if (v4 + 1 == a3) {
          goto LABEL_57;
        }
        int v12 = v4[1];
        char v13 = -48;
        if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38) {
          goto LABEL_30;
        }
        v12 |= 0x20u;
        if ((v12 - 97) >= 6) {
          goto LABEL_57;
        }
        char v13 = -87;
LABEL_30:
        if (v4 + 2 == a3) {
          goto LABEL_57;
        }
        int v14 = v4[2];
        char v15 = -48;
        if ((v14 & 0xF8) == 0x30 || (v14 & 0xFE) == 0x38) {
          goto LABEL_35;
        }
        v14 |= 0x20u;
        if ((v14 - 97) >= 6) {
          goto LABEL_57;
        }
        char v15 = -87;
LABEL_35:
        if (!this) {
          sub_1016FB6A8(a1);
        }
        std::string::operator=(this, v15 + v14 + 16 * (v13 + v12 + v6));
        v4 += 3;
        break;
      case 'v':
        if (!this) {
          goto LABEL_54;
        }
        int v7 = this;
        std::string::value_type v8 = 11;
        goto LABEL_52;
      case 'x':
        goto LABEL_25;
      default:
        goto LABEL_47;
    }
    return (unsigned __int8 *)v4;
  }
  if (v5 == 48)
  {
    if (this)
    {
      int v7 = this;
      std::string::value_type v8 = 0;
      goto LABEL_52;
    }
LABEL_54:
    sub_1016FB6A8(a1);
  }
  if (v5 != 99)
  {
    if (v5 == 102)
    {
      if (this)
      {
        int v7 = this;
        std::string::value_type v8 = 12;
LABEL_52:
        std::string::operator=(v7, v8);
        return (unsigned __int8 *)++v4;
      }
      goto LABEL_54;
    }
LABEL_47:
    if (*a2 != 95
      && ((v5 & 0x80) != 0
       || (*(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16) + 4 * *a2) & 0x500) == 0))
    {
      std::string::value_type v8 = *a2;
      if (this)
      {
        int v7 = this;
        goto LABEL_52;
      }
      goto LABEL_54;
    }
LABEL_57:
    sub_10103423C();
  }
  if (a2 + 1 == a3) {
    goto LABEL_57;
  }
  if (a2[1] < 65) {
    goto LABEL_57;
  }
  unsigned int v16 = a2[1];
  if (v16 >= 0x5B && (v16 - 97) > 0x19u) {
    goto LABEL_57;
  }
  if (!this) {
    sub_1016FB6A8(a1);
  }
  std::string::operator=(this, v16 & 0x1F);
  v4 += 2;
  return (unsigned __int8 *)v4;
}

void sub_101034730()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_backref);
}

void sub_101034774(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101034788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = off_10230BAD0;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 4sub_100FB8FC8(&a9, 0) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 8) + 40))(*(void *)(a2 + 8), a3);
  return a1;
}

void sub_10103481C(_Unwind_Exception *a1)
{
  std::locale::~locale(v2);
  *uint64_t v1 = off_10230B938;
  uint64_t v4 = v1[1];
  if (v4) {
    sub_101A9D284(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10103485C(uint64_t result, uint64_t a2)
{
  int v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v5;
  return result;
}

uint64_t sub_1010348F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v3;
  return result;
}

uint64_t sub_101034938(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v3;
  return result;
}

uint64_t sub_101034980(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v6;
  return result;
}

uint64_t sub_101034A98(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(unsigned char *)(v3 + 24 * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }
      int v9 = *(unsigned __int8 **)(a2 + 16);
      uint64_t v10 = v6;
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v9++;
        if (v11 != v13) {
          break;
        }
        if (!--v10) {
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v8 = 0;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v8;
  return result;
}

unsigned int *sub_101034B28(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    sub_101034730();
  }
  unsigned int v5 = v2 - 1;
  if (*(unsigned char *)(v3 + 24 * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24 * v5,
        uint64_t result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (uint64_t result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }
  else
  {
    uint64_t v10 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v10;
  return result;
}

void sub_101034BE8(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(unsigned char **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 40);
      int64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          int v12 = operator new(v11);
        }
        else {
          int v12 = 0;
        }
        uint64_t v20 = &v8[(void)v12];
        long long v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          long long v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned int v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      sub_1001D7FD4();
    }
    goto LABEL_22;
  }
  uint64_t v6 = (unint64_t *)(a1 + 40);
  unsigned int v5 = *(unsigned char **)(a1 + 48);
  unint64_t v13 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      char v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v12 = operator new(v28);
        }
        else {
          int v12 = 0;
        }
        uint64_t v20 = &v25[(void)v12];
        long long v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          uint64_t v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    unsigned char *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  char v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    int v12 = operator new(v18);
  }
  else {
    int v12 = 0;
  }
  uint64_t v20 = &v15[(void)v12];
  long long v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  int v12 = v20;
LABEL_47:
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = v12;
  *(void *)(a1 + 48) = v19;
  *(void *)(a1 + 56) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 48) = v19;
}

uint64_t sub_101034E30(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = off_10230BC80;
  *(void *)(a1 + 8) = a3;
  size_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 4sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_100FB8FC8(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = a4;
  *(unsigned char *)(a1 + 169) = a5;
  *(unsigned char *)(a1 + 17sub_100FB8FC8(&a9, 0) = a6;
  std::locale::locale(&v14, v11);
  std::locale::name(&v15, &v14);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v12 = v15.__r_.__value_.__l.__size_ != 1 || *v15.__r_.__value_.__l.__data_ != 67;
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  else
  {
    BOOL v12 = SHIBYTE(v15.__r_.__value_.__r.__words[2]) != 1 || v15.__r_.__value_.__s.__data_[0] != 67;
  }
  std::locale::~locale(&v14);
  *(unsigned char *)(a1 + 171) = v12;
  return a1;
}

void sub_101034F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  std::locale::~locale((std::locale *)&a9);
  a10 = v10 + 17;
  sub_1000A7B4C((void ***)&a10);
  std::string v15 = (void *)v10[14];
  if (v15)
  {
    v10[15] = v15;
    operator delete(v15);
  }
  sub_100340F40((void ***)&a10);
  unint64_t v16 = (void *)v10[8];
  if (v16)
  {
    v10[9] = v16;
    operator delete(v16);
  }
  unint64_t v17 = *v13;
  if (*v13)
  {
    v10[6] = v17;
    operator delete(v17);
  }
  std::locale::~locale(v12);
  *unint64_t v10 = v11;
  uint64_t v18 = v10[1];
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(a1);
}

void sub_101035010(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(signed __int8 **)(a2 + 16);
  unsigned int v5 = *(signed __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v37 = 0;
    int v36 = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_221;
  }
  if (!*(unsigned char *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_58;
  }
  signed __int8 v6 = *v4;
  unsigned __int8 v125 = *v4;
  signed __int8 v7 = v4[1];
  unsigned __int8 v126 = v7;
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v125 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v6);
    unsigned __int8 v126 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v7);
  }
  uint64_t v8 = a1 + 16;
  sub_1016FC260(a1 + 16, (char *)&v125, (char *)&v127, (uint64_t)&__p);
  if ((v124 & 0x80000000) == 0)
  {
    if (v124) {
      goto LABEL_8;
    }
LABEL_58:
    int v36 = 0;
    uint64_t v37 = 1;
    goto LABEL_59;
  }
  size_t v38 = v123;
  operator delete(__p);
  if (!v38) {
    goto LABEL_58;
  }
LABEL_8:
  uint64_t v9 = *(void *)(a1 + 112);
  uint64_t v10 = *(void *)(a1 + 120) - v9;
  if (v10)
  {
    uint64_t v11 = v10 >> 1;
    if ((unint64_t)(v10 >> 1) <= 1) {
      uint64_t v11 = 1;
    }
    BOOL v12 = (unsigned char *)(v9 + 1);
    do
    {
      if (v125 == *(v12 - 1) && v126 == *v12) {
        goto LABEL_218;
      }
      v12 += 2;
      --v11;
    }
    while (v11);
  }
  if (!*(unsigned char *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v36 = 0;
  }
  else
  {
    sub_1016FC1A8(a1 + 16, (char *)&v125, (char *)&v127);
    uint64_t v14 = *(void *)(a1 + 88);
    char v15 = v124;
    uint64_t v16 = *(void *)(a1 + 96) - v14;
    if (v16)
    {
      uint64_t v17 = 0;
      unint64_t v18 = v16 / 48;
      char v113 = v124;
      if (v124 >= 0) {
        size_t v19 = v124;
      }
      else {
        size_t v19 = v123;
      }
      if (v124 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if (v18 <= 1) {
        uint64_t v21 = 1;
      }
      else {
        uint64_t v21 = v16 / 48;
      }
      BOOL v22 = 1;
      while (1)
      {
        int v23 = *(char *)(v14 + 23);
        if (v23 >= 0) {
          size_t v24 = *(unsigned __int8 *)(v14 + 23);
        }
        else {
          size_t v24 = *(void *)(v14 + 8);
        }
        if (v23 >= 0) {
          char v25 = (const void *)v14;
        }
        else {
          char v25 = *(const void **)v14;
        }
        if (v24 >= v19) {
          size_t v26 = v19;
        }
        else {
          size_t v26 = v24;
        }
        int v27 = memcmp(p_p, v25, v26);
        BOOL v28 = v19 >= v24;
        if (v27) {
          BOOL v28 = v27 >= 0;
        }
        if (v28)
        {
          int v29 = *(char *)(v14 + 47);
          if (v29 >= 0) {
            size_t v30 = *(unsigned __int8 *)(v14 + 47);
          }
          else {
            size_t v30 = *(void *)(v14 + 32);
          }
          if (v29 >= 0) {
            uint64_t v31 = (const void *)(v14 + 24);
          }
          else {
            uint64_t v31 = *(const void **)(v14 + 24);
          }
          if (v19 >= v30) {
            size_t v32 = v30;
          }
          else {
            size_t v32 = v19;
          }
          int v33 = memcmp(v31, p_p, v32);
          BOOL v34 = v30 >= v19;
          if (v33) {
            BOOL v34 = v33 >= 0;
          }
          if (v34) {
            break;
          }
        }
        BOOL v22 = ++v17 < v18;
        v14 += 48;
        if (v21 == v17)
        {
          int v35 = 0;
          int v36 = 0;
          goto LABEL_162;
        }
      }
      int v36 = 1;
      int v35 = 5;
LABEL_162:
      uint64_t v8 = a1 + 16;
      char v15 = v113;
    }
    else
    {
      BOOL v22 = 0;
      int v35 = 0;
      int v36 = 0;
    }
    if (v15 < 0) {
      operator delete(__p);
    }
    if (v22) {
      goto LABEL_195;
    }
  }
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_200;
  }
  sub_1016FC4B8(v8, (char *)&v125, (char *)&v127, (uint64_t)&__p);
  uint64_t v89 = *(void *)(a1 + 136);
  uint64_t v90 = v124;
  uint64_t v91 = *(void *)(a1 + 144) - v89;
  if (v91)
  {
    uint64_t v92 = 0;
    unint64_t v93 = v91 / 24;
    uint64_t v95 = __p;
    size_t v94 = v123;
    if (v124 >= 0) {
      size_t v96 = v124;
    }
    else {
      size_t v96 = v123;
    }
    if (v93 <= 1) {
      uint64_t v97 = 1;
    }
    else {
      uint64_t v97 = v91 / 24;
    }
    BOOL v98 = 1;
    while (1)
    {
      int v99 = (unsigned __int8 **)(v89 + 24 * v92);
      __int16 v100 = (unsigned __int8 *)*((unsigned __int8 *)v99 + 23);
      int v101 = (char)v100;
      if ((char)v100 < 0) {
        __int16 v100 = v99[1];
      }
      if ((unsigned __int8 *)v96 == v100)
      {
        if (v101 >= 0) {
          __int16 v102 = (unsigned __int8 *)(v89 + 24 * v92);
        }
        else {
          __int16 v102 = *v99;
        }
        if ((v90 & 0x80) == 0)
        {
          if (v90)
          {
            unsigned int v103 = &__p;
            uint64_t v104 = v90;
            do
            {
              if (*(unsigned __int8 *)v103 != *v102) {
                goto LABEL_188;
              }
              unsigned int v103 = (void **)((char *)v103 + 1);
              ++v102;
              --v104;
            }
            while (v104);
            int v36 = 1;
            int v35 = 5;
            goto LABEL_192;
          }
          int v36 = 1;
          if (v98) {
            goto LABEL_220;
          }
LABEL_200:
          if ((char)v125 < 0)
          {
            int v109 = *(_DWORD *)(a1 + 164);
            goto LABEL_213;
          }
          int v106 = *(_DWORD *)(a1 + 160);
          uint64_t v107 = *(void *)(*(void *)(a1 + 24) + 16);
          int v108 = *(_DWORD *)(v107 + 4 * v125);
          if ((v108 & v106) == 0 && (v125 != 95 || (v106 & 0x80) == 0)
            || (char)v126 < 0
            || (*(_DWORD *)(v107 + 4 * v126) & v106) == 0 && ((v106 & 0x80) == 0 || v126 != 95))
          {
            int v109 = *(_DWORD *)(a1 + 164);
            if ((v108 & v109) != 0 || v125 == 95 && (v109 & 0x80) != 0)
            {
LABEL_217:
              int v110 = v36;
              goto LABEL_219;
            }
LABEL_213:
            if (((char)v126 & 0x80000000) == 0)
            {
              if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v126) & v109) != 0) {
                goto LABEL_217;
              }
              int v110 = 1;
              if (v126 == 95 && (v109 & 0x80) != 0) {
                goto LABEL_217;
              }
LABEL_219:
              int v36 = v110;
LABEL_220:
              uint64_t v37 = 2;
              goto LABEL_221;
            }
          }
LABEL_218:
          int v110 = 1;
          goto LABEL_219;
        }
        unint64_t v118 = v93;
        uint64_t v121 = v90;
        int v105 = memcmp(v95, v102, v94);
        unint64_t v93 = v118;
        uint64_t v90 = v121;
        if (!v105) {
          break;
        }
      }
LABEL_188:
      BOOL v98 = ++v92 < v93;
      if (v92 == v97) {
        goto LABEL_191;
      }
    }
    int v35 = 5;
    int v36 = 1;
    goto LABEL_193;
  }
  BOOL v98 = 0;
LABEL_191:
  int v35 = 0;
LABEL_192:
  if ((v90 & 0x80) != 0) {
LABEL_193:
  }
    operator delete(__p);
  if (!v98) {
    goto LABEL_200;
  }
LABEL_195:
  if (v35) {
    goto LABEL_220;
  }
  uint64_t v37 = 2;
LABEL_59:
  unsigned __int8 v39 = **(unsigned char **)(a2 + 16);
  unsigned __int8 v125 = v39;
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v39 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v39);
    unsigned __int8 v125 = v39;
  }
  uint64_t v40 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v41 = *(void *)(a1 + 48) - (void)v40;
  if (v41)
  {
    if (v41 <= 1) {
      unint64_t v41 = 1;
    }
    while (1)
    {
      int v42 = *v40++;
      if (v42 == v39) {
        break;
      }
      if (!--v41) {
        goto LABEL_66;
      }
    }
LABEL_77:
    int v36 = 1;
    goto LABEL_221;
  }
LABEL_66:
  unsigned int v43 = *(_DWORD *)(a1 + 164);
  if (v43 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v39 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v39) & v43) == 0) {
      int v44 = (v39 == 95) & (v43 >> 7);
    }
    else {
      LOBYTE(v44) = 1;
    }
    uint64_t v45 = *(void **)(a1 + 72);
    unsigned int v46 = memchr(*(void **)(a1 + 64), (char)v39, (size_t)v45 - *(void *)(a1 + 64));
    unsigned int v47 = v46 ? v46 : v45;
    if ((v44 & 1) == 0 && v47 == v45) {
      goto LABEL_77;
    }
  }
  uint64_t v49 = *(void *)(a1 + 88);
  uint64_t v48 = *(void *)(a1 + 96);
  if (v49 != v48)
  {
    if (*(unsigned char *)(a1 + 170))
    {
      sub_1016FC1A8(a1 + 16, (char *)&v125, (char *)&v126);
      uint64_t v49 = *(void *)(a1 + 88);
      uint64_t v48 = *(void *)(a1 + 96);
    }
    else
    {
      char v124 = 1;
      LOWORD(__p) = v39;
    }
    uint64_t v50 = v48 - v49;
    if (v50)
    {
      uint64_t v119 = v37;
      int v116 = v36;
      uint64_t v51 = 0;
      unint64_t v52 = v50 / 48;
      char v114 = v124;
      if (v124 >= 0) {
        size_t v53 = v124;
      }
      else {
        size_t v53 = v123;
      }
      if (v124 >= 0) {
        unsigned __int8 v54 = &__p;
      }
      else {
        unsigned __int8 v54 = __p;
      }
      if (v52 <= 1) {
        uint64_t v55 = 1;
      }
      else {
        uint64_t v55 = v50 / 48;
      }
      BOOL v56 = 1;
      while (1)
      {
        int v57 = *(char *)(v49 + 23);
        if (v57 >= 0) {
          size_t v58 = *(unsigned __int8 *)(v49 + 23);
        }
        else {
          size_t v58 = *(void *)(v49 + 8);
        }
        if (v57 >= 0) {
          unsigned int v59 = (const void *)v49;
        }
        else {
          unsigned int v59 = *(const void **)v49;
        }
        if (v58 >= v53) {
          size_t v60 = v53;
        }
        else {
          size_t v60 = v58;
        }
        int v61 = memcmp(v54, v59, v60);
        BOOL v62 = v53 >= v58;
        if (v61) {
          BOOL v62 = v61 >= 0;
        }
        if (v62)
        {
          int v63 = *(char *)(v49 + 47);
          if (v63 >= 0) {
            size_t v64 = *(unsigned __int8 *)(v49 + 47);
          }
          else {
            size_t v64 = *(void *)(v49 + 32);
          }
          if (v63 >= 0) {
            int v65 = (const void *)(v49 + 24);
          }
          else {
            int v65 = *(const void **)(v49 + 24);
          }
          if (v53 >= v64) {
            size_t v66 = v64;
          }
          else {
            size_t v66 = v53;
          }
          int v67 = memcmp(v65, v54, v66);
          BOOL v68 = v64 >= v53;
          if (v67) {
            BOOL v68 = v67 >= 0;
          }
          if (v68) {
            break;
          }
        }
        BOOL v56 = ++v51 < v52;
        v49 += 48;
        if (v55 == v51)
        {
          int v36 = v116;
          goto LABEL_123;
        }
      }
      int v36 = 1;
LABEL_123:
      uint64_t v37 = v119;
      if ((v114 & 0x80) == 0) {
        goto LABEL_125;
      }
    }
    else
    {
      BOOL v56 = 0;
      if ((v124 & 0x80) == 0) {
        goto LABEL_125;
      }
    }
    operator delete(__p);
LABEL_125:
    if (v56) {
      goto LABEL_221;
    }
  }
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_154;
  }
  sub_1016FC4B8(a1 + 16, (char *)&v125, (char *)&v126, (uint64_t)&__p);
  uint64_t v69 = *(void *)(a1 + 136);
  uint64_t v70 = v124;
  uint64_t v71 = *(void *)(a1 + 144) - v69;
  if (v71)
  {
    uint64_t v120 = v37;
    uint64_t v72 = 0;
    unint64_t v73 = v71 / 24;
    unsigned int v74 = __p;
    size_t v75 = v123;
    if (v124 >= 0) {
      size_t v76 = v124;
    }
    else {
      size_t v76 = v123;
    }
    if (v73 <= 1) {
      uint64_t v77 = 1;
    }
    else {
      uint64_t v77 = v71 / 24;
    }
    BOOL v78 = 1;
    while (1)
    {
      int v79 = (unsigned __int8 **)(v69 + 24 * v72);
      __int16 v80 = (unsigned __int8 *)*((unsigned __int8 *)v79 + 23);
      int v81 = (char)v80;
      if ((char)v80 < 0) {
        __int16 v80 = v79[1];
      }
      if ((unsigned __int8 *)v76 == v80)
      {
        if (v81 >= 0) {
          __int16 v82 = (unsigned __int8 *)(v69 + 24 * v72);
        }
        else {
          __int16 v82 = *v79;
        }
        if ((v70 & 0x80) != 0)
        {
          int v117 = v36;
          unint64_t v85 = v73;
          uint64_t v115 = v77;
          int v86 = memcmp(v74, v82, v75);
          uint64_t v77 = v115;
          unint64_t v73 = v85;
          int v36 = v117;
          if (!v86)
          {
            int v36 = 1;
            uint64_t v37 = v120;
            goto LABEL_152;
          }
        }
        else
        {
          if (!v70)
          {
            int v36 = 1;
            uint64_t v37 = v120;
            if (!v78) {
              goto LABEL_154;
            }
            goto LABEL_221;
          }
          int v83 = &__p;
          uint64_t v84 = v70;
          while (*(unsigned __int8 *)v83 == *v82)
          {
            int v83 = (void **)((char *)v83 + 1);
            ++v82;
            if (!--v84)
            {
              int v36 = 1;
              goto LABEL_149;
            }
          }
        }
      }
      BOOL v78 = ++v72 < v73;
      if (v72 == v77)
      {
LABEL_149:
        uint64_t v37 = v120;
        if ((v70 & 0x80) == 0) {
          goto LABEL_153;
        }
        goto LABEL_152;
      }
    }
  }
  BOOL v78 = 0;
  if (v124 < 0) {
LABEL_152:
  }
    operator delete(__p);
LABEL_153:
  if (!v78)
  {
LABEL_154:
    if ((char)v125 < 0) {
      goto LABEL_221;
    }
    unsigned int v87 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v125) & v87) == 0)
    {
      int v88 = (v87 >> 7) & 1;
      if (v125 != 95) {
        int v88 = 0;
      }
      if (v88 != 1) {
        goto LABEL_221;
      }
    }
    goto LABEL_77;
  }
LABEL_221:
  if (v36 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v111 = 0;
    int v112 = -993;
  }
  else
  {
    *(void *)(a2 + 16) += v37;
    uint64_t v111 = *(void *)(a1 + 8);
    int v112 = -995;
  }
  *(_DWORD *)a2 = v112;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v111;
}

void sub_101035914()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brack);
}

void sub_101035958(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *sub_10103596C(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  unint64_t v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  memset(&v26, 0, sizeof(v26));
  if (a2 + 1 == a3 || v5 != 91)
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
    goto LABEL_10;
  }
  int v9 = a2[1];
  if (v9 != 46)
  {
    if (v9 == 58)
    {
      uint64_t v10 = sub_101035F14(a1, a2 + 2, a3, (uint64_t)a4);
      goto LABEL_38;
    }
    if (v9 == 61)
    {
      uint64_t v10 = sub_101035D34(a1, a2 + 2, a3, a4);
LABEL_38:
      uint64_t v6 = (uint64_t)v10;
      char v21 = 0;
      goto LABEL_42;
    }
    goto LABEL_9;
  }
  size_t v19 = sub_101035FC8(a1, a2 + 2, a3, (uint64_t)&v26);
  unint64_t v4 = v19;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v26.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = v19;
  if (!size)
  {
LABEL_10:
    if ((v11 | 0x40) == 0x40)
    {
      int v12 = *v4;
      if (v12 == 92)
      {
        unint64_t v13 = v4 + 1;
        if (v11)
        {
          uint64_t v14 = sub_1010361D8(a1, v13, a3, &v26);
        }
        else
        {
          uint64_t v14 = (char *)sub_1010360B0(a1, v13, a3, &v26, v6);
          int v11 = 0;
        }
        goto LABEL_16;
      }
    }
    else
    {
      LOBYTE(v12) = *v4;
    }
    std::string::operator=(&v26, v12);
    uint64_t v14 = v4 + 1;
  }
LABEL_16:
  if (v14 == a3
    || (int v15 = *v14, v15 == 93)
    || (uint64_t v17 = v14 + 1, v14 + 1 == a3)
    || v15 != 45
    || *v17 == 93)
  {
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v26.__r_.__value_.__l.__size_)
      {
        if (v26.__r_.__value_.__l.__size_ != 1)
        {
          uint64_t v16 = (std::string *)v26.__r_.__value_.__r.__words[0];
LABEL_40:
          sub_101036808(v6, v16->__r_.__value_.__s.__data_[0], v16->__r_.__value_.__s.__data_[1]);
          goto LABEL_41;
        }
        uint64_t v16 = (std::string *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_25;
      }
    }
    else if (*((unsigned char *)&v26.__r_.__value_.__s + 23))
    {
      uint64_t v16 = &v26;
      if (HIBYTE(v26.__r_.__value_.__r.__words[2]) != 1) {
        goto LABEL_40;
      }
LABEL_25:
      sub_101034BE8(v6, v16->__r_.__value_.__s.__data_[0]);
    }
LABEL_41:
    char v21 = 1;
    unint64_t v4 = v14;
    goto LABEL_42;
  }
  memset(&v25, 0, sizeof(v25));
  unint64_t v4 = v14 + 2;
  if (v14 + 2 != a3 && *v17 == 91 && *v4 == 46)
  {
    unint64_t v18 = sub_101035FC8(a1, v14 + 3, a3, (uint64_t)&v25);
LABEL_55:
    unint64_t v4 = v18;
    goto LABEL_56;
  }
  if ((v11 | 0x40) == 0x40)
  {
    LODWORD(v17) = *v17;
    if (v17 == 92)
    {
      if (v11) {
        unint64_t v18 = sub_1010361D8(a1, v14 + 2, a3, &v25);
      }
      else {
        unint64_t v18 = (char *)sub_1010360B0(a1, v14 + 2, a3, &v25, v6);
      }
      goto LABEL_55;
    }
  }
  else
  {
    LOBYTE(v17) = *v17;
  }
  std::string::operator=(&v25, (std::string::value_type)v17);
LABEL_56:
  std::string v24 = v26;
  memset(&v26, 0, sizeof(v26));
  std::string __p = v25;
  memset(&v25, 0, sizeof(v25));
  sub_1010363E0(v6, (char *)&v24, (char *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  char v21 = 1;
LABEL_42:
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (v21) {
    return v4;
  }
  return (char *)v6;
}

void sub_101035CBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 49) < 0) {
    operator delete(*(void **)(v28 - 72));
  }
  _Unwind_Resume(exception_object);
}

char *sub_101035D34(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  uint64_t v6 = a3 - 2;
  signed __int8 v7 = a2;
  uint64_t v8 = a2;
  for (i = a2; ; uint64_t v8 = i)
  {
    int v10 = *i++;
    if (v10 == 61 && *i == 93) {
      break;
    }
    if (a2 == v6) {
      goto LABEL_33;
    }
    ++v7;
    --v6;
  }
  if (v8 == a3) {
LABEL_33:
  }
    sub_101035914();
  sub_101036B00(a1, a2, v7, (uint64_t)&v20);
  if (((char)v22 & 0x80000000) == 0)
  {
    uint64_t v11 = v22;
    if (v22)
    {
      int v12 = (char *)&v20;
      goto LABEL_14;
    }
LABEL_34:
    sub_101036A64();
  }
  uint64_t v11 = v21;
  if (!v21) {
    goto LABEL_34;
  }
  int v12 = (char *)v20;
LABEL_14:
  sub_1016FD1F8(a1, v12, &v12[v11], (uint64_t)__p);
  unint64_t v13 = v19;
  if ((v19 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  if (v13)
  {
    sub_101036ABC(a4, (long long *)__p);
  }
  else
  {
    uint64_t v14 = v22;
    if ((v22 & 0x80u) != 0) {
      uint64_t v14 = v21;
    }
    if (v14 == 2)
    {
      uint64_t v16 = (char *)&v20;
      if ((v22 & 0x80u) != 0) {
        uint64_t v16 = (char *)v20;
      }
      sub_101036808((uint64_t)a4, *v16, v16[1]);
    }
    else
    {
      if (v14 != 1) {
        sub_101036A64();
      }
      int v15 = (char *)&v20;
      if ((v22 & 0x80u) != 0) {
        int v15 = (char *)v20;
      }
      sub_101034BE8((uint64_t)a4, *v15);
    }
  }
  if ((char)v19 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v22 < 0) {
    operator delete(v20);
  }
  return v7 + 2;
}

void sub_101035EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_101035F14(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  int v5 = a3 - 2;
  uint64_t v6 = a2;
  signed __int8 v7 = a2;
  for (i = a2; ; signed __int8 v7 = i)
  {
    int v9 = *i++;
    if (v9 == 58 && *i == 93) {
      break;
    }
    if (a2 == v5) {
      goto LABEL_11;
    }
    ++v6;
    --v5;
  }
  if (v7 == a3) {
LABEL_11:
  }
    sub_101035914();
  int v10 = sub_101036D08(a1, a2, v6, *(_DWORD *)(a1 + 24) & 1);
  if (!v10) {
    sub_101036CB0();
  }
  *(_DWORD *)(a4 + 160) |= v10;
  return v6 + 2;
}

char *sub_101035FC8(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  int v5 = a3 - 2;
  uint64_t v6 = a2;
  signed __int8 v7 = a2;
  for (i = a2; ; signed __int8 v7 = i)
  {
    int v9 = *i++;
    if (v9 == 46 && *i == 93) {
      break;
    }
    if (a2 == v5) {
      goto LABEL_15;
    }
    ++v6;
    --v5;
  }
  if (v7 == a3) {
LABEL_15:
  }
    sub_101035914();
  sub_101036B00(a1, a2, v6, (uint64_t)&v13);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v13;
  unint64_t v10 = v14;
  *(void *)(a4 + 16) = v14;
  unint64_t v11 = HIBYTE(v10);
  if ((v11 & 0x80u) != 0) {
    unint64_t v11 = *(void *)(a4 + 8);
  }
  if (v11 - 1 >= 2) {
    sub_101036A64();
  }
  return v6 + 2;
}

unsigned __int8 *sub_1010360B0(uint64_t a1, char *a2, char *a3, std::string *this, uint64_t a5)
{
  if (a2 == a3) {
    sub_10103423C();
  }
  int v6 = *a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          return sub_10103441C(a1, a2, a3, this);
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        sub_101034BE8(a5, 95);
        return (unsigned __int8 *)(a2 + 1);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v6 == 98)
      {
        unint64_t v10 = this;
        std::string::value_type v9 = 8;
LABEL_19:
        std::string::operator=(v10, v9);
        return (unsigned __int8 *)(a2 + 1);
      }
      if (v6 != 100) {
        return sub_10103441C(a1, a2, a3, this);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 16sub_100FB8FC8(&a9, 0) = v8;
    return (unsigned __int8 *)(a2 + 1);
  }
  if (v6 <= 82)
  {
    if (*a2)
    {
      if (v6 == 68)
      {
        int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_21:
        *(_DWORD *)(a5 + 164) = v7;
        return (unsigned __int8 *)(a2 + 1);
      }
      return sub_10103441C(a1, a2, a3, this);
    }
    std::string::value_type v9 = 0;
    unint64_t v10 = this;
    goto LABEL_19;
  }
  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_21;
  }
  if (v6 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    sub_101036DDC(a5, 95);
    return (unsigned __int8 *)(a2 + 1);
  }
  return sub_10103441C(a1, a2, a3, this);
}

char *sub_1010361D8(uint64_t a1, char *a2, char *a3, std::string *this)
{
  if (a2 == a3) {
LABEL_45:
  }
    sub_10103423C();
  int v5 = *a2;
  if (v5 > 97)
  {
    switch(v5)
    {
      case 'n':
        if (!this) {
          goto LABEL_43;
        }
        int v6 = this;
        LOBYTE(v5) = 10;
        goto LABEL_16;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_21;
      case 'r':
        if (!this) {
          goto LABEL_43;
        }
        int v6 = this;
        LOBYTE(v5) = 13;
        goto LABEL_16;
      case 't':
        if (!this) {
          goto LABEL_43;
        }
        int v6 = this;
        LOBYTE(v5) = 9;
        goto LABEL_16;
      case 'v':
        if (!this) {
          goto LABEL_43;
        }
        int v6 = this;
        LOBYTE(v5) = 11;
        goto LABEL_16;
      default:
        if (v5 == 98)
        {
          if (this)
          {
            int v6 = this;
            LOBYTE(v5) = 8;
            goto LABEL_16;
          }
        }
        else
        {
          if (v5 != 102) {
            goto LABEL_21;
          }
          if (this)
          {
            int v6 = this;
            LOBYTE(v5) = 12;
            goto LABEL_16;
          }
        }
        break;
    }
    goto LABEL_43;
  }
  if (v5 > 91)
  {
    if (v5 != 92)
    {
      if (v5 != 97) {
        goto LABEL_21;
      }
      if (this)
      {
        int v6 = this;
        LOBYTE(v5) = 7;
LABEL_16:
        std::string::operator=(v6, v5);
        return a2 + 1;
      }
LABEL_43:
      sub_1016FB6A8(a1);
    }
LABEL_14:
    if (this)
    {
      int v6 = this;
      goto LABEL_16;
    }
    goto LABEL_43;
  }
  if (v5 == 34 || v5 == 47) {
    goto LABEL_14;
  }
LABEL_21:
  if ((v5 & 0xFFFFFFF8) != 0x30) {
    goto LABEL_45;
  }
  std::string::value_type v7 = v5 - 48;
  unint64_t v11 = a2 + 1;
  if (a2 + 1 == a3)
  {
LABEL_38:
    unint64_t v11 = a3;
    goto LABEL_39;
  }
  if ((*v11 & 0xF8) == 0x30)
  {
    std::string::value_type v7 = *v11 + 8 * v7 - 48;
    if (a2 + 2 != a3)
    {
      char v8 = a2[2];
      int v9 = v8 & 0xF8;
      std::string::value_type v10 = v8 + 8 * v7 - 48;
      if (v9 == 48) {
        unint64_t v11 = a2 + 3;
      }
      else {
        unint64_t v11 = a2 + 2;
      }
      if (v9 == 48) {
        std::string::value_type v7 = v10;
      }
      goto LABEL_39;
    }
    goto LABEL_38;
  }
LABEL_39:
  if (!this) {
    sub_1016FB6A8(a1);
  }
  std::string::operator=(this, v7);
  return v11;
}

void sub_1010363E0(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a3;
  unint64_t v4 = a2;
  if (*(unsigned char *)(a1 + 170))
  {
    if (*(unsigned char *)(a1 + 169))
    {
      for (unint64_t i = 0; ; ++i)
      {
        unint64_t v7 = v4[23] < 0 ? *((void *)v4 + 1) : v4[23];
        if (i >= v7) {
          break;
        }
        char v8 = v4;
        if (v4[23] < 0) {
          char v8 = *(char **)v4;
        }
        char v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v8[i]);
        std::string::value_type v10 = v4;
        if (v4[23] < 0) {
          std::string::value_type v10 = *(char **)v4;
        }
        v10[i] = v9;
      }
      for (unint64_t j = 0; ; ++j)
      {
        unint64_t v12 = v3[23] < 0 ? *((void *)v3 + 1) : v3[23];
        if (j >= v12) {
          break;
        }
        long long v13 = v3;
        if (v3[23] < 0) {
          long long v13 = *(char **)v3;
        }
        char v14 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v13[j]);
        int v15 = v3;
        if (v3[23] < 0) {
          int v15 = *(char **)v3;
        }
        v15[j] = v14;
      }
    }
    else
    {
      for (unint64_t k = 0; ; ++k)
      {
        unint64_t v18 = a2[23] < 0 ? *((void *)a2 + 1) : a2[23];
        if (k >= v18) {
          break;
        }
        unsigned __int8 v19 = a2;
        if (a2[23] < 0) {
          unsigned __int8 v19 = *(char **)a2;
        }
        uint64_t v20 = a2;
        if (a2[23] < 0) {
          uint64_t v20 = *(char **)a2;
        }
        v20[k] = v19[k];
      }
      for (unint64_t m = 0; ; ++m)
      {
        unint64_t v22 = a3[23] < 0 ? *((void *)a3 + 1) : a3[23];
        if (m >= v22) {
          break;
        }
        int v23 = a3;
        if (a3[23] < 0) {
          int v23 = *(char **)a3;
        }
        std::string v24 = a3;
        if (a3[23] < 0) {
          std::string v24 = *(char **)a3;
        }
        v24[m] = v23[m];
      }
    }
    if (v4[23] < 0)
    {
      std::string v26 = v4;
      unint64_t v4 = *(char **)v4;
      uint64_t v25 = *((void *)v26 + 1);
    }
    else
    {
      uint64_t v25 = v4[23];
    }
    sub_1016FD560(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      uint64_t v28 = v3;
      uint64_t v3 = *(char **)v3;
      uint64_t v27 = *((void *)v28 + 1);
    }
    else
    {
      uint64_t v27 = v3[23];
    }
    sub_1016FD560(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)uint64_t v40 = v38;
    uint64_t v41 = v39;
    *(_OWORD *)std::string __p = *(_OWORD *)v36;
    uint64_t v43 = v37;
    sub_101037024((uint64_t *)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
  else
  {
    if (a2[23] < 0) {
      uint64_t v16 = *((void *)a2 + 1);
    }
    else {
      uint64_t v16 = a2[23];
    }
    if (v16 != 1 || (a3[23] < 0 ? (uint64_t v29 = *((void *)a3 + 1)) : (uint64_t v29 = a3[23]), v29 != 1)) {
      sub_101037190();
    }
    if (*(unsigned char *)(a1 + 169))
    {
      size_t v30 = a2;
      if (a2[23] < 0) {
        size_t v30 = *(char **)a2;
      }
      char v31 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v30);
      size_t v32 = v4;
      if (v4[23] < 0) {
        size_t v32 = *(unsigned char **)v4;
      }
      *size_t v32 = v31;
      int v33 = v3;
      if (v3[23] < 0) {
        int v33 = *(char **)v3;
      }
      char v34 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v33);
      int v35 = v3;
      if (v3[23] < 0) {
        int v35 = *(unsigned char **)v3;
      }
      *int v35 = v34;
    }
    *(_OWORD *)uint64_t v40 = *(_OWORD *)v4;
    uint64_t v41 = *((void *)v4 + 2);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)unint64_t v4 = 0;
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v43 = *((void *)v3 + 2);
    *(void *)uint64_t v3 = 0;
    *((void *)v3 + 1) = 0;
    *((void *)v3 + 2) = 0;
    sub_101037024((uint64_t *)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
}

void sub_1010367BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

void sub_101036808(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    uint64_t v18 = a1 + 128;
    unint64_t v19 = *(void *)(a1 + 128);
    std::string::value_type v10 = (char **)(a1 + 112);
    __int16 v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v9 = *(_WORD **)(a1 + 120);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        uint64_t v21 = v20 >> 1;
        unint64_t v22 = v19 - (void)*v10;
        if (v22 <= (v20 >> 1) + 1) {
          unint64_t v23 = v21 + 1;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v22 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)sub_100C3D5E0(v18, v24);
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v27 = &v25[2 * v21];
        uint64_t v28 = &v25[2 * v24];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        long long v38 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v38) {
          goto LABEL_46;
        }
        do
        {
          __int16 v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }
        while (v29 != v38);
        goto LABEL_45;
      }
    }
    else
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        uint64_t v33 = v32 >> 1;
        unint64_t v34 = v19 - (void)*v10;
        if (v34 <= (v32 >> 1) + 1) {
          unint64_t v35 = v33 + 1;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v36 = v35;
        }
        if (v36) {
          uint64_t v37 = (char *)sub_100C3D5E0(v18, v36);
        }
        else {
          uint64_t v37 = 0;
        }
        uint64_t v27 = &v37[2 * v33];
        uint64_t v28 = &v37[2 * v36];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        uint64_t v40 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v40) {
          goto LABEL_46;
        }
        do
        {
          __int16 v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }
        while (v29 != v40);
        goto LABEL_45;
      }
    }
LABEL_49:
    sub_1001D7FD4();
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3);
  unint64_t v7 = *(void *)(a1 + 128);
  __int16 v8 = v5 | (unsigned __int16)(v6 << 8);
  char v9 = *(_WORD **)(a1 + 120);
  if ((unint64_t)v9 < v7)
  {
LABEL_24:
    _WORD *v9 = v8;
    std::string v26 = v9 + 1;
    goto LABEL_48;
  }
  std::string::value_type v10 = (char **)(a1 + 112);
  uint64_t v11 = *(void *)(a1 + 112);
  uint64_t v12 = (uint64_t)v9 - v11;
  if ((uint64_t)v9 - v11 <= -3) {
    goto LABEL_49;
  }
  uint64_t v13 = v12 >> 1;
  unint64_t v14 = v7 - v11;
  if (v14 <= (v12 >> 1) + 1) {
    unint64_t v15 = v13 + 1;
  }
  else {
    unint64_t v15 = v14;
  }
  if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16) {
    uint64_t v17 = (char *)sub_100C3D5E0(a1 + 128, v16);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v27 = &v17[2 * v13];
  uint64_t v28 = &v17[2 * v16];
  *(_WORD *)uint64_t v27 = v8;
  std::string v26 = v27 + 2;
  size_t v30 = *(char **)(a1 + 112);
  uint64_t v29 = *(char **)(a1 + 120);
  if (v29 == v30) {
    goto LABEL_46;
  }
  do
  {
    __int16 v31 = *((_WORD *)v29 - 1);
    v29 -= 2;
    *((_WORD *)v27 - 1) = v31;
    v27 -= 2;
  }
  while (v29 != v30);
LABEL_45:
  uint64_t v29 = *v10;
LABEL_46:
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 12sub_100FB8FC8(&a9, 0) = v26;
  *(void *)(a1 + 128) = v28;
  if (v29) {
    operator delete(v29);
  }
LABEL_48:
  *(void *)(a1 + 12sub_100FB8FC8(&a9, 0) = v26;
}

void sub_101036A64()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_collate);
}

void sub_101036AA8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101036ABC(uint64_t *a1, long long *a2)
{
  uint64_t v3 = a1 + 17;
  unint64_t v4 = a1[18];
  if (v4 >= a1[19])
  {
    uint64_t result = sub_1016FD368(v3, a2);
  }
  else
  {
    sub_1016FD308(v3, a2);
    uint64_t result = v4 + 24;
  }
  a1[18] = result;
  return result;
}

void sub_101036B00(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  sub_1016FC410(&__s, a2, a3, a3 - a2);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v11);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v11;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a4 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a4 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_101036C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101036CB0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_ctype);
}

void sub_101036CF4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101036D08(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  sub_1016FC410(__p, a2, a3, a3 - a2);
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v7, (char *)v7 + v6);
  if ((v12 & 0x80u) == 0) {
    unint64_t v8 = __p;
  }
  else {
    unint64_t v8 = (void **)__p[0];
  }
  uint64_t classname = std::__get_classname((const char *)v8, a4);
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
  return classname;
}

void sub_101036DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101036DDC(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
    unint64_t v4 = *(void *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      unint64_t v6 = (unint64_t *)(a1 + 64);
      unint64_t v7 = *(void *)(a1 + 64);
      unint64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          unsigned __int8 v12 = operator new(v11);
        }
        else {
          unsigned __int8 v12 = 0;
        }
        uint64_t v20 = &v8[(void)v12];
        uint64_t v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          unint64_t v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned __int8 v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      sub_1001D7FD4();
    }
    goto LABEL_22;
  }
  unint64_t v6 = (unint64_t *)(a1 + 64);
  unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
  unint64_t v13 = *(void *)(a1 + 80);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          unsigned __int8 v12 = operator new(v28);
        }
        else {
          unsigned __int8 v12 = 0;
        }
        uint64_t v20 = &v25[(void)v12];
        uint64_t v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          __int16 v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    unsigned char *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  unint64_t v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    unsigned __int8 v12 = operator new(v18);
  }
  else {
    unsigned __int8 v12 = 0;
  }
  uint64_t v20 = &v15[(void)v12];
  uint64_t v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  unsigned __int8 v12 = v20;
LABEL_47:
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 72) = v19;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 72) = v19;
}

void **sub_101037024(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555) {
      sub_1001D7FD4();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555;
    }
    else {
      unint64_t v14 = v12;
    }
    std::bad_cast v19[4] = result;
    if (v14) {
      unint64_t v15 = (char *)sub_10014F86C((uint64_t)result, v14);
    }
    else {
      unint64_t v15 = 0;
    }
    unint64_t v16 = &v15[48 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[48 * v14];
    long long v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v16 = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v18 = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    double v19[2] = v16 + 48;
    sub_100340FD8(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_100341194(v19);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 4sub_100FB8FC8(&a9, 0) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }
  a1[1] = v10;
  return result;
}

void sub_10103717C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100341194((void **)va);
  _Unwind_Resume(a1);
}

void sub_101037190()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_range);
}

void sub_1010371D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010371E8(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + 8);
  return result;
}

uint64_t sub_101037218(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + 8);
  return result;
}

unsigned __int8 *sub_101037250(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      int v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }
      else
      {
        while (1)
        {
          int v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38) {
            break;
          }
          if (v5 >= 214748364) {
            sub_1010372F0();
          }
          int v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3) {
            return a3;
          }
        }
      }
    }
  }
  return a2;
}

void sub_1010372F0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badbrace);
}

void sub_101037334(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_101037348()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brace);
}

void sub_10103738C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned int *sub_1010373A0(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    unint64_t *v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }
    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return sub_101037574(result, a2);
    }
    goto LABEL_23;
  }
  unint64_t *v4 = 0;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }
LABEL_23:
    *(_DWORD *)a2 = -992;
    return result;
  }
  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((void *)result + 2);
  return result;
}

unsigned int *sub_101037454(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }
  else
  {
    a3[10] = *((void *)result + 1);
    return sub_101037574(result, a3);
  }
  return result;
}

void sub_101037488(void *a1)
{
  sub_1010374C0(a1);

  operator delete();
}

void *sub_1010374C0(void *a1)
{
  *a1 = off_10230BDB8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_10230B938;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

unsigned int *sub_101037574(unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16 * result[10] + 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    uint64_t v7 = a2[4] + 24 * v4 + 8;
    do
    {
      *(void *)(v7 - 8) = v5;
      *(void *)uint64_t v7 = v5;
      *(unsigned char *)(v7 + 8) = 0;
      v7 += 24;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_1010375C8(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + 8);
  return result;
}

void sub_1010375DC(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t sub_1010375E8(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + v3);
  return result;
}

uint64_t sub_10103760C(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = *(void *)(result + 8);
  return result;
}

uint64_t sub_101037620(uint64_t a1, uint64_t a2, uint64_t a3)
{
  do
  {
    uint64_t v5 = a2;
    a2 = sub_1010376C4(a1, a2, a3);
  }
  while (v5 != a2);
  return v5;
}

void sub_10103766C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_empty);
}

void sub_1010376B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_1010376C4(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = sub_101037760(a1, a2, a3);
  if (v6 == a2) {
    return a2;
  }

  return sub_101037874(a1, v6, a3);
}

unsigned char *sub_101037760(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v6 = sub_101037A18(a1, a2, a3);
  uint64_t v7 = v6;
  if (a2 == v6 && a2 != a3 && a2 + 1 != a3)
  {
    uint64_t v9 = (uint64_t)v6;
    if (*a2 == 92) {
      uint64_t v9 = (uint64_t)&a2[2 * (a2[1] == 40)];
    }
    if ((unsigned char *)v9 == a2)
    {
      if (*a2 == 92)
      {
        int v11 = sub_1016FDFC0(a1, a2[1]);
        uint64_t v12 = 2;
        if (!v11) {
          uint64_t v12 = 0;
        }
        return &a2[v12];
      }
    }
    else
    {
      sub_1016FB0EC(a1);
      uint64_t v10 = (unsigned char *)sub_101037620(a1, v9, (uint64_t)a3);
      if (v10 == a3 || v10 + 1 == a3 || *v10 != 92 || v10[1] != 41) {
        sub_1010332F0();
      }
      uint64_t v7 = v10 + 2;
      sub_1016FB170(a1);
    }
  }
  return v7;
}

unsigned __int8 *sub_101037874(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if (v4 == 42) {
      sub_1016FD808();
    }
    if (a2 + 1 != a3 && v4 == 92 && a2[1] == 123)
    {
      uint64_t v6 = a2 + 2;
      int v13 = 0;
      uint64_t v7 = sub_101037250(a1, a2 + 2, a3, &v13);
      if (v6 == v7) {
        goto LABEL_16;
      }
      if (v7 != a3)
      {
        BOOL v8 = v7 + 1;
        int v9 = *v7;
        if (v9 == 44)
        {
          int v12 = -1;
          uint64_t v10 = sub_101037250(a1, v8, a3, &v12);
          if (v10 != a3 && v10 + 1 != a3 && *v10 == 92 && v10[1] == 125)
          {
            if (v12 != -1 && v12 < v13) {
LABEL_16:
            }
              sub_1010372F0();
LABEL_20:
            sub_1016FD808();
          }
        }
        else if (v8 != a3 && v9 == 92 && *v8 == 125)
        {
          goto LABEL_20;
        }
      }
      sub_101037348();
    }
  }
  return a2;
}

unsigned char *sub_101037A18(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = sub_101037B50(a1, a2, a3);
    if (result != a2) {
      return result;
    }
    goto LABEL_12;
  }
  int v6 = *a2;
  if ((a2 + 1 != a3 || v6 != 36)
    && ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0))
  {
    sub_1016FB6A8(a1);
  }
  uint64_t result = sub_101037B50(a1, a2, a3);
  if (result == a2)
  {
    if (*a2 == 46) {
      operator new();
    }
LABEL_12:
    return sub_10103405C(a1, a2, a3);
  }
  return result;
}

unsigned char *sub_101037B50(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3
    && a2 + 1 != a3
    && *a2 == 92
    && ((char)a2[1] - 36) <= 0x3A
    && ((1 << (a2[1] - 36)) & 0x580000000000441) != 0)
  {
    sub_1016FB6A8(a1);
  }
  return a2;
}

uint64_t sub_101037BCC(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 8sub_100FB8FC8(&a9, 0) = v3;
  return result;
}

unsigned __int8 *sub_101037C0C(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_101037C6C(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
    sub_10103766C();
  }
  do
  {
    uint64_t v7 = v6;
    int v6 = sub_101037C6C(a1, (char *)v6, a3);
  }
  while (v7 != v6);
  return v7;
}

unsigned __int8 *sub_101037C6C(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_101037DB0(a1, a2, a3);
  uint64_t v7 = (unsigned __int8 *)v6;
  if (v6 == a2 && v6 != a3)
  {
    int v8 = *a2;
    if (v8 == 36) {
      sub_1016FA1C4();
    }
    if (v8 != 40)
    {
      if (v8 == 94) {
        sub_10103326C();
      }
      return (unsigned __int8 *)a2;
    }
    sub_1016FB0EC(a1);
    ++*(_DWORD *)(a1 + 36);
    int v9 = (char *)sub_1010325F4(a1, a2 + 1, a3);
    if (v9 == a3 || (uint64_t v10 = v9, *v9 != 41)) {
      sub_1010332F0();
    }
    sub_1016FB170(a1);
    --*(_DWORD *)(a1 + 36);
    uint64_t v7 = (unsigned __int8 *)(v10 + 1);
  }
  if (v7 == (unsigned __int8 *)a2) {
    return (unsigned __int8 *)a2;
  }

  return sub_101032F60(a1, v7, (unsigned __int8 *)a3);
}

char *sub_101037DB0(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = sub_101037E98(a1, a2, a3);
  if (result == a2)
  {
    uint64_t result = sub_101037F24(a1, a2, a3);
    if (result == a2)
    {
      if (a2 != a3 && *a2 == 46) {
        operator new();
      }
      return sub_10103405C(a1, a2, a3);
    }
  }
  return result;
}

char *sub_101037E98(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v3 = *a2;
    uint64_t v4 = (v3 - 36);
    if (v4 > 0x3A) {
      goto LABEL_8;
    }
    if (((1 << (v3 - 36)) & 0x5800000080004D1) != 0) {
      return a2;
    }
    if (v4 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        return a2;
      }
    }
    else
    {
LABEL_8:
      if ((v3 - 123) < 2) {
        return a2;
      }
    }
    sub_1016FB6A8(a1);
  }
  return a2;
}

char *sub_101037F24(uint64_t a1, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 != a3)
  {
    uint64_t v4 = a2 + 1;
    if (v3 + 1 != a3 && *v3 == 92)
    {
      int v5 = *v4;
      BOOL v6 = (v5 - 36) > 0x3A || ((1 << (*v4 - 36)) & 0x5800000080004F1) == 0;
      if (!v6 || (v5 - 123) < 3) {
        sub_1016FB6A8(a1);
      }
      if ((*(_DWORD *)(a1 + 24) & 0x1F0) == 0x40)
      {
        return sub_1010361D8(a1, v4, a3, 0);
      }
      else
      {
        int v8 = sub_1016FDFC0(a1, *v4);
        uint64_t v9 = 2;
        if (!v8) {
          uint64_t v9 = 0;
        }
        v3 += v9;
      }
    }
  }
  return v3;
}

uint64_t sub_101037FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  char v18 = 0;
  char v19 = 0;
  uint64_t v20 = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v12, 0, sizeof(v12));
  int v9 = sub_101700014(a4, a1, a2, (uint64_t)__p, a5 | 0x1040u);
  sub_1017001F0(a3, a1, a2, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (!v9) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 88)) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_1010380C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1010380E4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 42 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_101038370(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2A)) + 96 * (v7 % 0x2A);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(v8 + 48) = 0;
  *(void *)(v8 + 32) = 0;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(v8 + 56) = 0;
  *(void *)(v8 + 64) = 0;
  *(void *)(v8 + 72) = 0;
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v8 + 56) = result;
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(v8 + 85) = *(void *)(a2 + 85);
  *(void *)(v8 + 8sub_100FB8FC8(&a9, 0) = v11;
  ++a1[5];
  return result;
}

uint64_t sub_1010381E8(void *a1)
{
  unsigned int v2 = a1 + 5;
  unint64_t v3 = a1[5] + a1[4] - 1;
  sub_101033BA4((uint64_t)(a1 + 5), (void *)(*(void *)(a1[1] + 8 * (v3 / 0x2A)) + 96 * (v3 % 0x2A)));
  --*v2;

  return sub_101038688(a1, 1);
}

int64x2_t sub_10103827C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_101038700((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x2A));
  uint64_t v7 = *v6 + 96 * (v4 % 0x2A);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4032;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v7 - 96) = *(_OWORD *)a2;
  *(_OWORD *)(v7 - 8sub_100FB8FC8(&a9, 0) = v8;
  *(void *)(v7 - 56) = 0;
  *(void *)(v7 - 48) = 0;
  *(void *)(v7 - 64) = 0;
  *(_OWORD *)(v7 - 64) = *(_OWORD *)(a2 + 32);
  *(void *)(v7 - 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(v7 - 4sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(v7 - 32) = 0;
  *(void *)(v7 - 24) = 0;
  *(_OWORD *)(v7 - 4sub_100FB8FC8(&a9, 0) = *(_OWORD *)(a2 + 56);
  *(void *)(v7 - 24) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v7 - 11) = *(void *)(a2 + 85);
  *(void *)(v7 - 16) = v9;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_101D1F270);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void sub_101038370(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)long long v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      long long v38 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        long long v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        __int16 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int16 v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    char v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    long long v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFC0uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFC0uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        long long v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        long long v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  BOOL v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  size_t v53 = operator new(0xFC0uLL);
  sub_1000DA434(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_10103863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101038688(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 42 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2A) {
    a2 = 1;
  }
  if (v5 < 0x54) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void sub_101038700(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 42 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x2A)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    long long v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::string __p = sub_1000DA54C(v7, v11);
      uint64_t v43 = (char *)__p;
      int v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      __int16 v41 = operator new(0xFC0uLL);
      sub_1000DA434(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000DA54C((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                uint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)uint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              long long v31 = __p;
              std::string __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              int v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }
              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              uint64_t v43 = v22;
              int v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      uint64_t v43 = v33;
      long long v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      int v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 21;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        int v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0xFC0uLL);
        sub_10017F0B4(a1, &__p);
        unint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        std::string __p = operator new(0xFC0uLL);
      }
      sub_1002D02D8((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 21;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 42;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1002D02D8((uint64_t)a1, &__p);
  }
}

void sub_1010389D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101038A1C(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = (void **)a1[2];
  if (v4 == v3)
  {
    unint64_t v4 = (void **)a1[1];
  }
  else
  {
    unint64_t v5 = a1[4];
    uint64_t v6 = &v3[v5 / 0x2A];
    uint64_t v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    unint64_t v8 = (unint64_t)v3[(a1[5] + v5) / 0x2A] + 96 * ((a1[5] + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_101033BA4((uint64_t)v2, v7);
        v7 += 96;
        if (v7 - (unsigned char *)*v6 == 4032)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v3 = (void **)a1[1];
      unint64_t v4 = (void **)a1[2];
    }
  }
  void *v2 = 0;
  unint64_t v10 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      unint64_t v4 = (void **)a1[2];
      uint64_t v3 = (void **)(a1[1] + 8);
      a1[1] = v3;
      unint64_t v10 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 21;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 42;
  }
  a1[4] = v12;
LABEL_16:
  while (v3 != v4)
  {
    uint64_t v13 = *v3++;
    operator delete(v13);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

void sub_101038B74(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_101038BB0((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 24 * a2;
  }
}

void sub_101038BB0(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[3 * a2];
      uint64_t v14 = 24 * a2;
      do
      {
        void *v7 = 0;
        v7[1] = 0;
        *((unsigned char *)v7 + 16) = 0;
        v7 += 3;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      uint64_t v12 = (char *)sub_1000DA5D8(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    int64_t v15 = &v12[24 * v8];
    uint64_t v16 = &v15[24 * a2];
    uint64_t v17 = 24 * a2;
    uint64_t v18 = v15;
    do
    {
      *(void *)uint64_t v18 = 0;
      *((void *)v18 + 1) = 0;
      v18[16] = 0;
      v18 += 24;
      v17 -= 24;
    }
    while (v17);
    uint64_t v19 = &v12[24 * v11];
    int64_t v21 = (char *)*a1;
    int64_t v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        long long v22 = *(_OWORD *)(v20 - 24);
        *((void *)v15 - 1) = *((void *)v20 - 1);
        *(_OWORD *)(v15 - 24) = v22;
        v15 -= 24;
        v20 -= 24;
      }
      while (v20 != v21);
      int64_t v20 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v16;
    a1[2] = v19;
    if (v20)
    {
      operator delete(v20);
    }
  }
}

void *sub_101038D2C(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  unint64_t v11 = operator new(0x28uLL);
  *unint64_t v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *(void *)((char *)v11 + 2sub_100FB8FC8(&a9, 0) = 0;
  *(void *)((char *)v11 + 28) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100100330(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  int64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *unint64_t v11 = *v20;
LABEL_38:
    void *v20 = v11;
    goto LABEL_39;
  }
  *unint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    int64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_101038F40(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101038F54()
{
  sub_100134750(qword_102482900, "VO2MaxPowerBudgetEstimatorLastExtendedBudgetAllotmentReason");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_102482900, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_10248B138, "NotSet");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10248B138, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_102482918, "Low");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102482918, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_102482930, "Medium");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102482930, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_102482948, "High");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102482948, (void *)&_mh_execute_header);
  sub_100134750(byte_102482960, "Unknown");

  return __cxa_atexit((void (*)(void *))&std::string::~string, byte_102482960, (void *)&_mh_execute_header);
}

void sub_10103908C(uint64_t a1)
{
}

void *sub_101039104(_DWORD *a1)
{
  *(void *)a1 = off_10230C120;
  sub_101039168(a1);
  bzero(a1 + 18, 0x10uLL);

  return sub_100C6129C(a1);
}

uint64_t sub_101039168(_DWORD *a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  int v3 = a1[11];
  if (v3 != -1)
  {
    notify_cancel(v3);
    a1[11] = -1;
  }
  int v4 = a1[13];
  if (v4 != -1)
  {
    notify_cancel(v4);
    a1[13] = -1;
  }
  uint64_t result = a1[15];
  if (result != -1)
  {
    uint64_t result = notify_cancel(result);
    a1[15] = -1;
  }
  return result;
}

void sub_1010391E0(_DWORD *a1)
{
  sub_101039104(a1);

  operator delete();
}

uint64_t sub_101039218(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2 <= 1)
  {
    int v3 = (unsigned char *)result;
    *(void *)(result + 72 + 8 * a2) = a3;
    if (*(void *)(result + 72) || *(void *)(result + 80))
    {
      sub_1010392B0((int *)result);
      sub_1010397D0((uint64_t)v3);
      sub_101039B28((uint64_t)v3);
      return sub_101039E60(v3);
    }
    else
    {
      return sub_101039168((_DWORD *)result);
    }
  }
  return result;
}

void sub_1010392B0(int *a1)
{
  if (a1[11] < 0)
  {
    if (notify_register_check("com.apple.isp.focusing", a1 + 11))
    {
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      unint64_t v2 = qword_1024190A8;
      if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        unint64_t v12 = "com.apple.isp.focusing";
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024190A0 != -1) {
          dispatch_once(&qword_1024190A0, &stru_10230C180);
        }
        unint64_t v8 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "%s\n", v8);
        if (v8 != (char *)buf) {
          free(v8);
        }
      }
    }
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, a1, (CFNotificationCallback)sub_10103A590, @"com.apple.isp.focusing", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  if (a1[13] < 0)
  {
    if (notify_register_check("com.apple.isp.backcamerapower", a1 + 13))
    {
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v4 = qword_1024190A8;
      if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        unint64_t v12 = "com.apple.isp.backcamerapower";
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024190A0 != -1) {
          dispatch_once(&qword_1024190A0, &stru_10230C180);
        }
        uint8x8_t v9 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "%s\n", v9);
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
    }
    unint64_t v5 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v5, a1, (CFNotificationCallback)sub_10103A590, @"com.apple.isp.backcamerapower", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  if (a1[15] < 0)
  {
    if (notify_register_check("com.apple.isp.backcamerasensorconfig", a1 + 15))
    {
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      uint64_t v6 = qword_1024190A8;
      if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        unint64_t v12 = "com.apple.isp.backcamerasensorconfig";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1024190A0 != -1) {
          dispatch_once(&qword_1024190A0, &stru_10230C180);
        }
        unint64_t v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
      }
    }
    unint64_t v7 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v7, a1, (CFNotificationCallback)sub_10103A590, @"com.apple.isp.backcamerasensorconfig", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
}

void sub_1010397D0(uint64_t a1)
{
  uint64_t state64 = 0;
  if (notify_get_state(*(_DWORD *)(a1 + 52), &state64))
  {
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    unint64_t v2 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unint64_t v12 = "com.apple.isp.backcamerapower";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v9 = 136315138;
      unint64_t v10 = "com.apple.isp.backcamerapower";
      int v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 56) = state64 != 0;
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v4 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
    {
      int v5 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v12) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "camera os_activity_scope_state_s state = %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v6 = *(unsigned __int8 *)(a1 + 56);
      int v9 = 67109120;
      LODWORD(v1sub_100FB8FC8(&a9, 0) = v6;
      unint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  }
}

void sub_101039B28(uint64_t a1)
{
  uint64_t state64 = 0;
  if (notify_get_state(*(_DWORD *)(a1 + 44), &state64))
  {
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    unint64_t v2 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      float v13 = "com.apple.isp.focusing";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v10 = 136315138;
      unint64_t v11 = "com.apple.isp.focusing";
      int v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()", "%s\n");
LABEL_19:
      if (v3 != buf) {
        free(v3);
      }
    }
  }
  else
  {
    int v4 = state64;
    *(_DWORD *)(a1 + 48) = state64;
    BOOL v8 = v4 == 0xFFFF;
    sub_1000E01AC(a1, 1, (uint64_t)&v8, 1);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v5 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
    {
      int v6 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v13) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "focus position = %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v7 = *(_DWORD *)(a1 + 48);
      int v10 = 67109120;
      LODWORD(v11) = v7;
      int v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()", "%s\n");
      goto LABEL_19;
    }
  }
}

uint64_t sub_101039E60(unsigned char *a1)
{
  int v2 = *((_DWORD *)a1 + 12);
  if (v2 != 0xFFFF)
  {
    if (a1[56])
    {
      *((float32x2_t *)a1 + 4) = vmla_n_f32(*(float32x2_t *)(a1 + 100), *(float32x2_t *)(a1 + 88), (float)v2);
      *((float *)a1 + 1sub_100FB8FC8(&a9, 0) = *((float *)a1 + 27) + (float)(*((float *)a1 + 24) * (float)v2);
    }
    else
    {
      bzero(a1 + 32, 0xCuLL);
    }
  }
  (*(void (**)(unsigned char *))(*(void *)a1 + 64))(a1);

  return sub_1000E01AC((uint64_t)a1, 0, (uint64_t)(a1 + 32), 12);
}

void sub_101039F24(float32x2_t *a1, __int16 *a2)
{
  a1[11].f32[0] = (float)*a2 * 0.01;
  a1[11].f32[1] = (float)a2[1] * 0.01;
  a1[12].f32[0] = (float)a2[2] * 0.01;
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230C180);
  }
  int v4 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    double v5 = a1[11].f32[0];
    double v6 = a1[11].f32[1];
    double v7 = a1[12].f32[0];
    *(_DWORD *)long long buf = 134218496;
    double v15 = v5;
    __int16 v16 = 2048;
    double v17 = v6;
    __int16 v18 = 2048;
    double v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f", buf, 0x20u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    unint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)", "%s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  a1[11] = vdiv_f32(a1[11], (float32x2_t)vdup_n_s32(0x437F0000u));
  a1[12].f32[0] = a1[12].f32[0] / 255.0;
  a1[12].f32[1] = (float)a2[3] * 0.01;
  a1[13].f32[0] = (float)a2[4] * 0.01;
  a1[13].f32[1] = (float)a2[5] * 0.01;
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230C180);
  }
  BOOL v8 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    double v9 = a1[12].f32[1];
    double v10 = a1[13].f32[0];
    double v11 = a1[13].f32[1];
    *(_DWORD *)long long buf = 134218496;
    double v15 = v9;
    __int16 v16 = 2048;
    double v17 = v10;
    __int16 v18 = 2048;
    double v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f", buf, 0x20u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    float v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)", "%s\n", v13);
    if (v13 != (char *)buf) {
      free(v13);
    }
  }
}

BOOL sub_10103A350()
{
  sub_1000D3E78();
  if (sub_1009E90AC()) {
    return sub_10087E2DC((int)&v7);
  }
  sub_10103AF84("kCLConnectionMessageDeviceHasOriginalCamera", &v7);
  uint64_t v1 = objc_opt_class();
  int v2 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v1, objc_opt_class(), 0);
  uint64_t v5 = v7;
  double v6 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v3 = +[CMMotionUtils sendMessage:&v5 withReplyClassesSync:v2];
  if (v6) {
    sub_1000DB0A0(v6);
  }
  id v0 = [[objc_msgSend(v3, "objectForKeyedSubscript:", CMDeviceHasOriginalBackCamera) BOOLValue];
  if (v8) {
    sub_1000DB0A0(v8);
  }
  return (BOOL)v0;
}

void sub_10103A440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a13) {
    sub_1000DB0A0(a13);
  }
  if (a15) {
    sub_1000DB0A0(a15);
  }
  _Unwind_Resume(exception_object);
}

id sub_10103A470()
{
  sub_1000D3E78();
  if (sub_1009E90AC())
  {
    id v0 = sub_10087EE38((int)&v7);
  }
  else
  {
    sub_10103AFE0("kCLConnectionMessageCameraVcmActuatorId", &v7);
    uint64_t v1 = objc_opt_class();
    int v2 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v1, objc_opt_class(), 0);
    uint64_t v5 = v7;
    double v6 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v3 = +[CMMotionUtils sendMessage:&v5 withReplyClassesSync:v2];
    if (v6) {
      sub_1000DB0A0(v6);
    }
    id v0 = (NSNumber *)[v3 objectForKeyedSubscript:CMCameraVcmActuatorId];
    if (v8) {
      sub_1000DB0A0(v8);
    }
  }
  return (id)[(NSNumber *)v0 intValue];
}

void sub_10103A560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_1000DB0A0(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103A590(int a1, uint64_t a2, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"com.apple.isp.focusing", 0))
  {
    if (CFStringCompare(theString1, @"com.apple.isp.backcamerapower", 0))
    {
      if (CFStringCompare(theString1, @"com.apple.isp.backcamerasensorconfig", 0)) {
        return;
      }
      uint64_t v5 = sub_1000D3E78();
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472;
      _DWORD v7[2] = sub_10103AF4C;
      void v7[3] = &unk_1022A3020;
      v7[4] = a2;
      double v6 = v7;
    }
    else
    {
      uint64_t v5 = sub_1000D3E78();
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      _DWORD v8[2] = sub_10103AF44;
      v8[3] = &unk_1022A3020;
      v8[4] = a2;
      double v6 = v8;
    }
  }
  else
  {
    uint64_t v5 = sub_1000D3E78();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    void v9[2] = sub_10103AF3C;
    void v9[3] = &unk_1022A3020;
    v9[4] = a2;
    double v6 = v9;
  }
  sub_1009E8E94(v5, (uint64_t)v6);
}

void sub_10103A700(int *a1)
{
  uint64_t state64 = 0;
  if (notify_get_state(a1[15], &state64))
  {
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v2 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unint64_t v12 = "com.apple.isp.backcamerasensorconfig";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v9 = 136315138;
      double v10 = "com.apple.isp.backcamerasensorconfig";
      id v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
  else
  {
    a1[16] = state64;
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v4 = qword_1024190A8;
    if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
    {
      int v5 = a1[16];
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v12) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "camera mode = %d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1024190A0 != -1) {
        dispatch_once(&qword_1024190A0, &stru_10230C180);
      }
      int v6 = a1[16];
      int v9 = 67109120;
      LODWORD(v1sub_100FB8FC8(&a9, 0) = v6;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    (*(void (**)(int *))(*(void *)a1 + 56))(a1);
  }
}

uint64_t sub_10103AA50(unsigned char *a1)
{
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230C180);
  }
  int v2 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received focusing notification", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onFocusingNotification()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sub_101039B28((uint64_t)a1);
  return sub_101039E60(a1);
}

uint64_t sub_10103ABF4(unsigned char *a1)
{
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230C180);
  }
  int v2 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received camera state notification", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraStateNotification()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sub_1010397D0((uint64_t)a1);
  return sub_101039E60(a1);
}

uint64_t sub_10103AD98(int *a1)
{
  if (qword_1024190A0 != -1) {
    dispatch_once(&qword_1024190A0, &stru_10230C180);
  }
  int v2 = qword_1024190A8;
  if (os_log_type_enabled((os_log_t)qword_1024190A8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received camera mode notification", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024190A0 != -1) {
      dispatch_once(&qword_1024190A0, &stru_10230C180);
    }
    int v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraModeNotification()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sub_10103A700(a1);
  return sub_101039E60(a1);
}

uint64_t sub_10103AF3C(uint64_t a1)
{
  return sub_10103AA50(*(unsigned char **)(a1 + 32));
}

uint64_t sub_10103AF44(uint64_t a1)
{
  return sub_10103ABF4(*(unsigned char **)(a1 + 32));
}

uint64_t sub_10103AF4C(uint64_t a1)
{
  return sub_10103AD98(*(int **)(a1 + 32));
}

void sub_10103AF54(id a1)
{
  qword_1024190A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

void *sub_10103AF84@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x70uLL);
  uint64_t result = sub_100EC7FF4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10103AFCC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10103AFE0@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x70uLL);
  uint64_t result = sub_100EC7FF4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10103B028(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10103BA00(void *result, uint64_t a2)
{
  *uint64_t result = off_10230C1B0;
  result[1] = a2;
  return result;
}

void sub_10103BA24()
{
}

id sub_10103BA38(uint64_t a1, uint64_t a2)
{
  id v3 = [objc_msgSend(*(id *)(a1 + 8), "vendor") proxyForService:@"CLGnssProvider"];

  return _[v3 syncgetIonosphereParameters:a2];
}

void sub_10103BA80()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241AD20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241AD20))
  {
    qword_10241AD08 = 0;
    qword_10241AD10 = 0;
    qword_10241AD18 = 0;
    __cxa_atexit((void (*)(void *))sub_1003BE920, &qword_10241AD08, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241AD20);
  }
}

void sub_10103BB00()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241ADD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241ADD0))
  {
    std::__shared_mutex_base::__shared_mutex_base(&stru_10241AD28);
    __cxa_atexit((void (*)(void *))sub_1003BE954, &stru_10241AD28, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241ADD0);
  }
}

void sub_10103BB90(_Unwind_Exception *a1)
{
}

void sub_10103BBA8(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  int v5 = (void *)sub_100054C14(a1, a2, a3, a4, a5);
  void *v5 = off_10230C200;
  void v5[6] = 0;
  sub_1005AEEAC();
}

void sub_10103BC84(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + 48) = 0;
  if (v3) {
    sub_101A6A9C8(v3);
  }
  sub_100029A7C(v1);
  _Unwind_Resume(a1);
}

void sub_10103BCA8(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  CLProfilingIdentify();
  [objc_msgSend(*(id *)(a4 + 8), "silo") assertInside];
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230C288);
  }
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    BOOL v8 = _os_activity_create((void *)&_mh_execute_header, "CL: CLMotionActivitySubscription::onMotionActivityNotification", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230C288);
    }
    int v9 = qword_102419588;
    if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      double v15 = "";
      __int16 v16 = 2082;
      double v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMotionActivitySubscription::onMotionActivityNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}", buf, 0x26u);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_10103D0E0(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10103BE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103BE88(void *a1)
{
  *a1 = off_10230C200;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_100029A7C((uint64_t)a1);
}

void sub_10103BF0C(void *a1)
{
  sub_10103BE88(a1);

  operator delete();
}

void *sub_10103BF44@<X0>(uint64_t a1@<X8>)
{
  v7[0] = off_10230C2D8;
  v7[1] = sub_10103C204;
  _DWORD v7[2] = 0;
  void v7[3] = v7;
  sub_100134750(v8, "kCLConnectionMessageMotionActivityUpdate");
  sub_100BF57BC((uint64_t)&v9, (uint64_t)v7);
  v6[0] = off_10230C2D8;
  v6[1] = sub_10103C62C;
  _DWORD v6[2] = 0;
  void v6[3] = v6;
  sub_100134750(v10, "kCLConnectionMessageMotionActivityPeriodicUpdate");
  sub_100BF57BC((uint64_t)&v11, (uint64_t)v6);
  v5[0] = off_10230C388;
  v5[1] = sub_10103CA54;
  _DWORD v5[2] = 0;
  void v5[3] = v5;
  sub_100134750(v12, "kCLConnectionMessageMotionActivityQuery");
  sub_100BF57BC((uint64_t)&v13, (uint64_t)v5);
  v4[0] = off_10230C388;
  v4[1] = sub_10103CFB8;
  void v4[2] = 0;
  v4[3] = v4;
  sub_100134750(v14, "kCLConnectionMessageMotionActivityAvailable");
  sub_100BF57BC((uint64_t)v15, (uint64_t)v4);
  sub_10103DA6C(a1, (unsigned __int8 *)v8, 4);
  for (uint64_t i = 0; i != -28; i -= 7)
  {
    sub_100BF5CD8(&v15[i * 8]);
    if (SHIBYTE(v14[i + 2]) < 0) {
      operator delete((void *)v14[i]);
    }
  }
  sub_100BF5CD8(v4);
  sub_100BF5CD8(v5);
  sub_100BF5CD8(v6);
  return sub_100BF5CD8(v7);
}

void sub_10103C16C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v15 = va_arg(va3, void);
  uint64_t v17 = va_arg(va3, void);
  uint64_t v18 = va_arg(va3, void);
  uint64_t v19 = va_arg(va3, void);
  for (uint64_t i = 168; i != -56; i -= 56)
    sub_10103D0A4(v2 + i);
  sub_100BF5CD8((uint64_t *)va);
  sub_100BF5CD8((uint64_t *)va1);
  sub_100BF5CD8((uint64_t *)va2);
  sub_100BF5CD8(va3);
  _Unwind_Resume(a1);
}

void sub_10103C204(uint64_t a1, int a2)
{
  id v4 = objc_alloc_init((Class)NSAutoreleasePool);
  if (qword_102419010 != -1) {
    dispatch_once(&qword_102419010, &stru_10230C2A8);
  }
  uint64_t v5 = qword_102419018;
  if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Received MotionActivityUpdate request,client,%@,subscribe,%d", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    int v18 = 138412546;
    uint64_t v19 = v11;
    __int16 v20 = 1024;
    int v21 = a2;
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionActivitySubscription::handleRequestMotionActivityUpdate(BOOL, const CLNameValuePair &)", "%s\n", v12);
    if (v12 != buf) {
      free(v12);
    }
  }
  if (sub_1005AD80C())
  {
    if (sub_1010A4D14(a1))
    {
      sub_10009C834(a1);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(v7 + 8);
      uint64_t v8 = *(void **)(v7 + 16);
      if (a2) {
        [v8 register:v9 forNotification:1 registrationInfo:0];
      }
      else {
        [v8 unregister:v9 forNotification:1];
      }
    }
    else
    {
      uint64_t v14 = CMErrorMessage;
      uint64_t v15 = &off_102393938;
      *(void *)long long buf = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      sub_10103D304(a1);
    }
  }
  else
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v10 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Cannot subscribe to motion activity updates, motion activity is not available", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230C2A8);
      }
      LOWORD(v18) = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionActivitySubscription::handleRequestMotionActivityUpdate(BOOL, const CLNameValuePair &)", "%s\n", v13);
      if (v13 != buf) {
        free(v13);
      }
    }
    uint64_t v16 = CMErrorMessage;
    uint64_t v17 = &off_102393920;
    *(void *)long long buf = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
    sub_10103D304(a1);
  }
}

void sub_10103C5EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10103C62C(uint64_t a1, int a2)
{
  id v4 = objc_alloc_init((Class)NSAutoreleasePool);
  if (qword_102419010 != -1) {
    dispatch_once(&qword_102419010, &stru_10230C2A8);
  }
  uint64_t v5 = qword_102419018;
  if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Received MotionActivityPeriodicUpdate request,client,%@,subscribe,%d", buf, 0x12u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    int v18 = 138412546;
    uint64_t v19 = v11;
    __int16 v20 = 1024;
    int v21 = a2;
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionActivitySubscription::handleRequestMotionActivityPeriodicUpdate(BOOL, const CLNameValuePair &)", "%s\n", v12);
    if (v12 != buf) {
      free(v12);
    }
  }
  if (sub_1005AD80C())
  {
    if (sub_1010A4D14(a1))
    {
      sub_10009C834(a1);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(v7 + 8);
      uint64_t v8 = *(void **)(v7 + 16);
      if (a2) {
        [v8 register:v9 forNotification:10 registrationInfo:0];
      }
      else {
        [v8 unregister:v9 forNotification:10];
      }
    }
    else
    {
      uint64_t v14 = CMErrorMessage;
      uint64_t v15 = &off_102393938;
      *(void *)long long buf = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      sub_10103D398(a1);
    }
  }
  else
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v10 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Cannot subscribe to motion activity updates, motion activity is not available", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230C2A8);
      }
      LOWORD(v18) = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionActivitySubscription::handleRequestMotionActivityPeriodicUpdate(BOOL, const CLNameValuePair &)", "%s\n", v13);
      if (v13 != buf) {
        free(v13);
      }
    }
    uint64_t v16 = CMErrorMessage;
    uint64_t v17 = &off_102393920;
    *(void *)long long buf = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
    sub_10103D398(a1);
  }
}

void sub_10103CA14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10103CA54(uint64_t a1, uint64_t a2)
{
  id v4 = objc_alloc_init((Class)NSAutoreleasePool);
  if ((sub_1005AD80C() & 1) == 0)
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v11 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "query for motion activity was received but motion activity is not available", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230C2A8);
      }
      __int16 v24 = 0;
      __int16 v20 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMotionActivitySubscription::handleMessageMotionActivityQuery(std::shared_ptr<CLConnectionMessage>)", "%s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    uint64_t v29 = CMErrorMessage;
    uint64_t v30 = &off_102393920;
    +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
    goto LABEL_21;
  }
  if ((sub_1010A4D14(a1) & 1) == 0)
  {
    uint64_t v27 = CMErrorMessage;
    uint64_t v28 = &off_102393938;
    +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
LABEL_21:
    CLConnectionMessage::sendReply();
    goto LABEL_22;
  }
  Dictionary = (void *)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2);
  id v6 = [Dictionary objectForKeyedSubscript:CMMotionActivityStartTime];
  id v7 = [Dictionary objectForKeyedSubscript:CMMotionActivityStopTime];
  uint64_t v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (qword_102419010 != -1) {
      dispatch_once(&qword_102419010, &stru_10230C2A8);
    }
    uint64_t v10 = qword_102419018;
    if (os_log_type_enabled((os_log_t)qword_102419018, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Programmer error: Wrong parameters were passed!", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419010 != -1) {
        dispatch_once(&qword_102419010, &stru_10230C2A8);
      }
      __int16 v24 = 0;
      int v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMotionActivitySubscription::handleMessageMotionActivityQuery(std::shared_ptr<CLConnectionMessage>)", "%s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    uint64_t v25 = CMErrorMessage;
    uint64_t v26 = &off_102393950;
    +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
    CLConnectionMessage::sendReply();
  }
  else
  {
    [v6 doubleValue];
    double v13 = v12;
    [v8 doubleValue];
    double v15 = v14;
    uint64_t v16 = [[CLOSTransaction alloc] initWithDescription:"CLDaemonClient.MotionActivityQuery"];
    uint64_t v17 = *(void **)(*(void *)(a1 + 48) + 16);
    sub_100134750(buf, "com.apple.locationd.activity");
    uint64_t v18 = sub_1010A4BAC(a1);
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3321888768;
    void v22[2] = sub_10103D42C;
    uint64_t v22[3] = &unk_10230C228;
    uint64_t v19 = *(std::__shared_weak_count **)(a2 + 8);
    v22[5] = *(void *)a2;
    __int16 v23 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v22[4] = v16;
    [v17 queryMotionStatesWithStartTime:v18 endTime:v22 isFromInternalClient:v13 withReply:v15];
    if (v32 < 0) {
      operator delete(*(void **)buf);
    }
    if (v23) {
      sub_1000DB0A0(v23);
    }
  }
LABEL_22:
}

void sub_10103CF40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  _Unwind_Resume(a1);
}

void sub_10103CFB8()
{
  id v0 = objc_alloc_init((Class)NSAutoreleasePool);
  uint64_t v1 = CMAvailable;
  uint64_t v2 = +[NSNumber numberWithBool:sub_1005AD80C()];
  +[NSDictionary dictionaryWithObjects:&v2 forKeys:&v1 count:1];
  CLConnectionMessage::sendReply();
}

void sub_10103D07C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_1001C7F8C(exception_object);
}

uint64_t sub_10103D0A4(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10103D0E0(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 10 || *a3 == 1)
  {
    id v8 = objc_alloc((Class)CMMotionActivity);
    long long v9 = *(_OWORD *)(a4 + 112);
    v14[6] = *(_OWORD *)(a4 + 96);
    v14[7] = v9;
    uint64_t v15 = *(void *)(a4 + 128);
    long long v10 = *(_OWORD *)(a4 + 48);
    int v14[2] = *(_OWORD *)(a4 + 32);
    void v14[3] = v10;
    long long v11 = *(_OWORD *)(a4 + 80);
    std::bad_cast v14[4] = *(_OWORD *)(a4 + 64);
    void v14[5] = v11;
    long long v12 = *(_OWORD *)(a4 + 16);
    v14[0] = *(_OWORD *)a4;
    v14[1] = v12;
    id v13 = [v8 initWithMotionActivity:v14];
    uint64_t v16 = CMMotionActivityData;
    id v17 = v13;
    +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];

    if (*a3 == 10)
    {
      sub_10103D280(a1);
    }
    else if (*a3 == 1)
    {
      sub_10103D1FC(a1);
    }
  }
}

void sub_10103D1FC(uint64_t a1)
{
  sub_1000E9420(off_10230C3F8, &v2);
  sub_1000E956C(a1, &v2);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_10103D268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103D280(uint64_t a1)
{
  sub_1000E9420(&off_10230C400, &v2);
  sub_1000E956C(a1, &v2);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_10103D2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103D304(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_10048C758(off_10230C3F8, &v2);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v1 + 24))(v1, &v2, 0);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_10103D380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103D398(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_10048C758(&off_10230C400, &v2);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v1 + 24))(v1, &v2, 0);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_10103D414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103D42C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = CMMotionActivityDataArray;
  id v4 = +[NSArray arrayWithArray:a2];
  +[NSDictionary dictionaryWithObjects:&v4 forKeys:&v3 count:1];
  CLConnectionMessage::sendReply();
}

void sub_10103D4D0(id a1)
{
  qword_102419588 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_10103D500(id a1)
{
  qword_102419018 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Activity");
}

__n128 sub_10103D530(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_10230C2D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10103D57C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230C2D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10103D5AC(uint64_t a1, uint64_t a2, long long *a3)
{
}

uint64_t sub_10103D5B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10103D5F4()
{
}

void sub_10103D600(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  sub_10103D65C(a1, a2, (CLConnectionMessage **)&v3);
  if (*((void *)&v3 + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&v3 + 1));
  }
}

void sub_10103D644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103D65C(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  id v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  CFDictionaryRef DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_10013FA80((int)v15, DictionaryOfClasses);
  BOOL v14 = 0;
  if (sub_1000D2988((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14))
  {
    id v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    long long v10 = (void *)(a2 + (v9 >> 1));
    if (v9) {
      id v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }
  else
  {
    if (qword_102419520 != -1) {
      dispatch_once(&qword_102419520, &stru_10230C348);
    }
    long long v11 = qword_102419528;
    if (os_log_type_enabled((os_log_t)qword_102419528, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Couldn't get value for kCLConnectionMessageSubscribeKey key\"}", buf, 0x12u);
      if (qword_102419520 != -1) {
        dispatch_once(&qword_102419520, &stru_10230C348);
      }
    }
    long long v12 = qword_102419528;
    if (os_signpost_enabled((os_log_t)qword_102419528))
    {
      *(_DWORD *)long long buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Couldn't get value for kCLConnectionMessageSubscribeKey key", "{\"msg%{public}.0s\":\"Couldn't get value for kCLConnectionMessageSubscribeKey key\"}", buf, 0x12u);
    }
  }
  return sub_10013F3C4(v15);
}

void sub_10103D88C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10103D8A8(id a1)
{
  qword_102419528 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_10103D8D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_10230C388;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10103D924(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_10230C388;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10103D954(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_10103D95C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10103D99C()
{
}

void sub_10103D9A8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  id v4 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  uint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = (void *)(a2 + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v8 = v3;
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v5(v7, &v8);
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v4) {
    sub_1000DB0A0(v4);
  }
}

void sub_10103DA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1000DB0A0(a10);
  }
  if (v10) {
    sub_1000DB0A0(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103DA6C(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_10103DAE8(a1, a2, (long long *)a2);
      a2 += 56;
      v5 -= 56;
    }
    while (v5);
  }
  return a1;
}

void sub_10103DAD4(_Unwind_Exception *a1)
{
  sub_100BF5D5C(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_10103DAE8(uint64_t a1, unsigned __int8 *a2, long long *a3)
{
  id v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    id v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }
  sub_10103DD6C(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100100330(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  long long v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *long long v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  sub_10103DE5C((uint64_t)v25, 0);
  return i;
}

void sub_10103DD54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10103DE5C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_10103DD6C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  __n128 result = sub_10103DDE4(v8 + 2, a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_10103DDCC(_Unwind_Exception *a1)
{
  sub_10103DE5C(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_10103DDE4(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_100BF5514((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_10103DE40(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103DE5C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100BF5DDC((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void *sub_10103DEB4(void *a1)
{
  sub_10103DF64((uint64_t)v3);
  sub_10120E0E0((uint64_t)a1, (long long *)v3);
  if (v10 < 0) {
    operator delete(__p);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
  if (v4 < 0) {
    operator delete(v3[0]);
  }
  *a1 = &off_10230C418;
  return a1;
}

void sub_10103DF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10103DF64(uint64_t a1@<X8>)
{
  sub_10042885C(a1);
  sub_1000C7F88(buf);
  __str.__r_.__value_.__s.__data_[0] = 0;
  int v2 = sub_1000D2988(*(uint64_t *)&buf[0], "WriteLocationdLogsToCrashReporterFolder", (BOOL *)&__str);
  if (__str.__r_.__value_.__s.__data_[0]) {
    int v3 = v2;
  }
  else {
    int v3 = 0;
  }
  if (*((void *)&buf[0] + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&buf[0] + 1));
  }
  if (v3) {
    char v4 = "/var/mobile/Library/Logs/CrashReporter/com.apple.locationd";
  }
  else {
    char v4 = "/var/mobile/Library/Logs/locationd";
  }
  std::string::assign((std::string *)(a1 + 48), v4);
  sub_100134750(&__str, "locctl");
  std::string::operator=((std::string *)(a1 + 72), &__str);
  std::string::operator=((std::string *)a1, &__str);
  *(void *)(a1 + 96) = 0x410FA40000000000;
  *(unsigned char *)(a1 + 119) = 1;
  sub_1000C7F88(buf);
  LOBYTE(v12) = 0;
  int v5 = sub_1000D2988(*(uint64_t *)&buf[0], "EnableLargeLocationControllerRecorderLogs", (BOOL *)&v12);
  if ((_BYTE)v12) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  if (*((void *)&buf[0] + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&buf[0] + 1));
  }
  if (v6)
  {
    *(void *)(a1 + 104) *= 16;
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230C440);
    }
    uint64_t v7 = qword_102419388;
    if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = *(void *)(a1 + 104);
      LODWORD(buf[0]) = 134283521;
      *(void *)((char *)buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "#locctl,#rec,EnableLargeLogs is set,maxDirectorySizeBytes,%{private}lld", (uint8_t *)buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419380 != -1) {
        dispatch_once(&qword_102419380, &stru_10230C440);
      }
      uint64_t v9 = *(void *)(a1 + 104);
      int v12 = 134283521;
      uint64_t v13 = v9;
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static CLProtobufSerializer::Config CLLocationControllerSerializer::generateConfig()", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  *(unsigned char *)(a1 + 116) = 0;
  *(unsigned char *)(a1 + 117) = sub_10103E2CC();
  *(unsigned char *)(a1 + 118) = sub_10103E4D4();
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_10103E228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1004284E0(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_10103E294()
{
  if (sub_10103E2CC()) {
    return 1;
  }

  return sub_10103E4D4();
}

uint64_t sub_10103E2CC()
{
  sub_1000C7F88(buf);
  LOBYTE(v5[0]) = 0;
  unsigned int v0 = sub_1000D2988(*(uint64_t *)buf, "EnableLocationControllerProtoToOsLog", (BOOL *)v5);
  if (LOBYTE(v5[0])) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v7) {
    sub_1000DB0A0(v7);
  }
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230C440);
  }
  int v2 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#locctl,#rec,EnableLocationControllerProtoToOsLog,%{public}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230C440);
    }
    v5[0] = 67240192;
    v5[1] = v1;
    char v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static BOOL CLLocationControllerSerializer::isOsLogEnabled()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return v1;
}

void sub_10103E4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103E4D4()
{
  sub_100103240();
  uint64_t v0 = sub_10073E30C();
  if (qword_102419380 != -1) {
    dispatch_once(&qword_102419380, &stru_10230C440);
  }
  uint64_t v1 = qword_102419388;
  if (os_log_type_enabled((os_log_t)qword_102419388, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67174657;
    int v5 = v0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "#locctl,#rec,serializer,isInternalInstall,%{private}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419380 != -1) {
      dispatch_once(&qword_102419380, &stru_10230C440);
    }
    int v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "static BOOL CLLocationControllerSerializer::isDiskEnabled()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  return v0;
}

void sub_10103E690(id a1)
{
  qword_102419388 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void sub_10103E824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103E84C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  sub_101171D90(a1 + 8);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0xFFFF;
  *(void *)(a1 + 76) = 0;
  *(void *)(a1 + 68) = 0;
  *(_OWORD *)(a1 + 84) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 10sub_100FB8FC8(&a9, 0) = _Q0;
  *(_OWORD *)(a1 + 116) = _Q0;
  *(_OWORD *)(a1 + 132) = _Q0;
  *(_DWORD *)(a1 + 148) = 0;
  *(void *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 18sub_100FB8FC8(&a9, 0) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 188) = 0x7FFFFFFF;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  return a1;
}

void sub_10103E8D8(void *a1, uint64_t a2, double *a3)
{
}

double sub_10103E8E8(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0xFFFF;
  *(void *)(a1 + 76) = 0;
  *(void *)(a1 + 68) = 0;
  *(_OWORD *)(a1 + 84) = xmmword_101D1C320;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 10sub_100FB8FC8(&a9, 0) = _Q0;
  *(_OWORD *)(a1 + 116) = _Q0;
  *(_OWORD *)(a1 + 132) = _Q0;
  *(_DWORD *)(a1 + 148) = 0;
  *(void *)(a1 + 16sub_100FB8FC8(&a9, 0) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 18sub_100FB8FC8(&a9, 0) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 188) = 0x7FFFFFFF;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 20sub_100FB8FC8(&a9, 0) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0;
  return sub_1006156AC(a1 + 8);
}

uint64_t sub_10103E950(void *a1, int a2, void *a3)
{
  a1[6] = *a3;
  if (qword_102419630 != -1) {
    dispatch_once(&qword_102419630, &stru_10230C470);
  }
  int v5 = qword_102419638;
  if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67109120;
    int v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Requesting download of preload manifest, allowCell,%d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10230C470);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLTransitTilePreloader::requestDownloadManifest(const BOOL, const CFAbsoluteTime &)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  unint64_t v11 = 0xBFF0000000000000;
  CFAbsoluteTime v13 = Current;
  __int16 v14 = 1;
  buf[0] = a2;
  buf[1] = a2;
  _OWORD buf[2] = 0;
  int v12 = 0;
  return (*(uint64_t (**)(void, uint8_t *))(*(void *)*a1 + 24))(*a1, buf);
}

uint64_t sub_10103EB5C(void *a1, int a2, uint64_t a3, void *a4)
{
  a1[7] = *a4;
  long long v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)a1 + 4) = *(_OWORD *)a3;
  *((_OWORD *)a1 + 5) = v7;
  long long v8 = *(_OWORD *)(a3 + 32);
  long long v9 = *(_OWORD *)(a3 + 48);
  long long v10 = *(_OWORD *)(a3 + 80);
  *((_OWORD *)a1 + 8) = *(_OWORD *)(a3 + 64);
  *((_OWORD *)a1 + 9) = v10;
  *((_OWORD *)a1 + 6) = v8;
  *((_OWORD *)a1 + 7) = v9;
  long long v11 = *(_OWORD *)(a3 + 96);
  long long v12 = *(_OWORD *)(a3 + 112);
  long long v13 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)((char *)a1 + 204) = *(_OWORD *)(a3 + 140);
  *((_OWORD *)a1 + 11) = v12;
  *((_OWORD *)a1 + 12) = v13;
  *((_OWORD *)a1 + 1sub_100FB8FC8(&a9, 0) = v11;
  if (qword_102419630 != -1) {
    dispatch_once(&qword_102419630, &stru_10230C470);
  }
  __int16 v14 = qword_102419638;
  if (os_log_type_enabled((os_log_t)qword_102419638, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = *(void *)(a3 + 4);
    uint64_t v16 = *(void *)(a3 + 12);
    *(_DWORD *)long long buf = 134218496;
    *(void *)uint64_t v21 = v15;
    *(_WORD *)&v21[8] = 2048;
    *(void *)&v21[10] = v16;
    __int16 v22 = 1024;
    LODWORD(v23) = a2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Request tiles at lat,%.06lf,lon,%.06lf, allowCell,%d", buf, 0x1Cu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419630 != -1) {
      dispatch_once(&qword_102419630, &stru_10230C470);
    }
    unint64_t v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLTransitTilePreloader::requestDownloadWifiTile(const BOOL, const CLDaemonLocation &, const CFAbsoluteTime &)", "%s\n", v19);
    if (v19 != (char *)buf) {
      free(v19);
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(void *)&_DWORD v21[4] = 0xBFF0000000000000;
  CFAbsoluteTime v23 = Current;
  __int16 v24 = 1;
  buf[0] = a2;
  buf[1] = a2;
  _OWORD buf[2] = 0;
  *(_DWORD *)&v21[12] = 0;
  return (*(uint64_t (**)(void, uint8_t *, void, double, double))(*(void *)*a1 + 32))(*a1, buf, 0, *(double *)(a3 + 4), *(double *)(a3 + 12));
}

void sub_10103EDF0(id a1)
{
  qword_102419638 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_10103EE20()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241AD20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241AD20))
  {
    qword_10241AD08 = 0;
    qword_10241AD10 = 0;
    qword_10241AD18 = 0;
    __cxa_atexit((void (*)(void *))sub_1003BE920, &qword_10241AD08, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241AD20);
  }
}

void sub_10103EEA0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_10241ADD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_10241ADD0))
  {
    std::__shared_mutex_base::__shared_mutex_base(&stru_10241AD28);
    __cxa_atexit((void (*)(void *))sub_1003BE954, &stru_10241AD28, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10241ADD0);
  }
}

void sub_10103EF30(_Unwind_Exception *a1)
{
}

double sub_10103EF48(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0xBFF0000000000000;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  return result;
}

uint64_t sub_10103EF64(uint64_t result, double a2, double a3)
{
  uint64_t v4 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  if (v4 != v3)
  {
    int v5 = 0;
    double v6 = -1.79769313e308;
    while (1)
    {
      double v7 = *(double *)v4;
      if (*(double *)v4 >= a2 && v7 < a3)
      {
        if (v6 < *(float *)(v4 + 8)) {
          double v6 = *(float *)(v4 + 8);
        }
        ++v5;
      }
      if (v7 < a3) {
        break;
      }
      v4 += 16;
      if (v4 == v3) {
        return result;
      }
    }
    if (v4 != v3)
    {
      uint64_t v9 = v4 + 16;
      if (v4 + 16 != v3)
      {
        do
        {
          double v10 = *(double *)v9;
          if (*(double *)v9 >= a2 && v10 < a3)
          {
            if (v6 < *(float *)(v9 + 8)) {
              double v6 = *(float *)(v9 + 8);
            }
            ++v5;
          }
          if (v10 >= a3)
          {
            *(_OWORD *)uint64_t v4 = *(_OWORD *)v9;
            v4 += 16;
          }
          v9 += 16;
        }
        while (v9 != v3);
        uint64_t v3 = *(void *)(result + 56);
      }
      if (v4 != v3) {
        *(void *)(result + 56) = v4;
      }
    }
  }
  return result;
}

void sub_10103F080(uint64_t a1, double a2, double a3, double a4)
{
  double v7 = a4 / 60.0;
  sub_10103EF64(a1, a2, a3);
  double v9 = v8;
  if (qword_1024194F0 != -1) {
    dispatch_once(&qword_1024194F0, &stru_10230C490);
  }
  double v10 = round(v7);
  long long v11 = qword_1024194F8;
  if (os_log_type_enabled((os_log_t)qword_1024194F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67110144;
    BOOL v15 = v10 > 0.0;
    __int16 v16 = 2048;
    double v17 = a2;
    __int16 v18 = 2048;
    double v19 = a3;
    __int16 v20 = 2048;
    double v21 = v10;
    __int16 v22 = 2048;
    double v23 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Aggregated result, shouldWrite, %d, startTime, %f, endTime, %f, daylightMinutes, %f, maxLux, %f", buf, 0x30u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1024194F0 != -1) {
      dispatch_once(&qword_1024194F0, &stru_10230C490);
    }
    long long v13 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLTimeInDaylightHealthKitAggregator::writeToHK(CFAbsoluteTime, CFAbsoluteTime, double)", "%s\n", v13);
    if (v13 != (char *)buf) {
      free(v13);
    }
  }
  if (v10 > 0.0)
  {
    float v12 = v9;
    (*(void (**)(double, double, double, float))(**(void **)a1 + 16))(a2, a3, v10, v12);
  }
}

void sub_10103F2F8(uint64_t a1, double *a2)
{
  double v4 = *(double *)(a1 + 8);
  if (v4 == -1.0 || *(double *)(a1 + 16) == 0.0)
  {
    double v4 = *a2;
    *(double *)(a1 + 8) = *a2;
    double v5 = v4;
  }
  else
  {
    double v5 = *a2;
  }
  if (v5 - v4 > 300.0)
  {
    sub_10103F080(a1, v4, v4 + 300.0, *(double *)(a1 + 16));
    double v4 = *a2;
    *(double *)(a1 + 8) = *a2;
    *(void *)(a1 + 16) = 0;
  }
  double v6 = a2[1];
  if (v6 - v4 >= 300.0)
  {
    double v8 = *(double *)(a1 + 16);
    do
    {
      double v7 = v4 + 300.0;
      sub_10103F080(a1, v4, v4 + 300.0, v4 + 300.0 - v5 + v8);
      *(double *)(a1 + 8) = v7;
      *(void *)(a1 + 16) = 0;
      double v6 = a2[1];
      double v8 = 0.0;
      double v4 = v7;
      double v5 = v7;
    }
    while (v6 - v7 >= 300.0);
  }
  else
  {
    double v7 = v5;
  }
  if (v6 > v7) {
    *(double *)(a1 + 16) = v6 - v7 + *(double *)(a1 + 16);
  }
}

void sub_10103F3FC(id a1)
{
  qword_1024194F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Outdoor");
}

void sub_10103F4DC(id a1)
{
  qword_102482A40 = (uint64_t)[objc_alloc((Class)CLDispatchSilo) initWithIdentifier:@"CLAutopauseProviderSilo"];
}

uint64_t sub_10103F59C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10103F7BC;
  block[3] = &unk_10229FED8;
  block[4] = a1;
  if (qword_102482A50 != -1) {
    dispatch_once(&qword_102482A50, block);
  }
  return qword_10248B160;
}

void sub_10103F7BC()
{
  if (sub_10073DA3C()) {
    operator new();
  }
  operator new();
}

void sub_10103F83C()
{
}

void *sub_10103F874(uint64_t a1, void *a2)
{
  double result = (void *)sub_10103F8B4(a1, "CLAutopauseProvider", a2);
  *double result = off_10230C4E0;
  return result;
}

uint64_t sub_10103F8B4(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10230C668;
  sub_100134750((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100FB8FC8(&a9, 0) = [a3 silo];
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_100FB8FC8(&a9, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 108) = 0;
  return a1;
}

void sub_10103F944(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103F960(uint64_t a1)
{
  *(void *)a1 = off_10230C4E0;
  *(unsigned char *)(a1 + 108) = 1;
  return sub_10103F988(a1);
}

uint64_t sub_10103F988(uint64_t a1)
{
  *(void *)a1 = off_10230C668;
  [*(id *)(a1 + 48) invalidate];

  sub_1004459BC(a1 + 80, *(void **)(a1 + 88));
  sub_100445A1C(a1 + 56, *(void **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_10103FA14@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  snprintf(__str, 0x20uLL, "%d", *a1);
  return sub_100134750(a2, __str);
}

void sub_10103FA90()
{
}

void sub_10103FB4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t sub_10103FB88(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_10230C748;
  *(void *)(a1 + 8) = [[CLNotifierClientAdapter alloc] initWithClient:a1];
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  if (*((char *)a3 + 23) >= 0) {
    float v12 = a3;
  }
  else {
    float v12 = (uint64_t *)*a3;
  }
  id v13 = [[objc_msgSend(a4, "vendor") proxyForService:[NSString stringWithUTF8String:v12]];
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  [*(id *)(a1 + 16) registerDelegate:*(void *)(a1 + 8) inSilo:[a4 silo]];
  return a1;
}

void sub_10103FC6C(uint64_t a1, uint64_t a2)
{
  v14[0] = a2;
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        double v9 = (uint64_t *)v4;
      }
      else {
        double v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)long long buf = *(_DWORD *)(*(void *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112))(a1, a2, buf);
      }
      sub_10006DA64(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_102419580 != -1) {
        dispatch_once(&qword_102419580, &stru_10230C638);
      }
      double v10 = qword_102419588;
      if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
      {
        long long v11 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          long long v11 = (void *)*v11;
        }
        *(_DWORD *)long long buf = 136446466;
        double v19 = v11;
        __int16 v20 = 1026;
        int v21 = a2;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419580 != -1) {
          dispatch_once(&qword_102419580, &stru_10230C638);
        }
        float v12 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          float v12 = (void *)*v12;
        }
        v14[1] = 136446466;
        BOOL v15 = v12;
        __int16 v16 = 1026;
        int v17 = a2;
        id v13 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "%s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
    }
  }
}

uint64_t sub_10103FEFC(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_10005C4C4(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96))(a1, a2, &v10, v7);
  }
  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88))(a1, a2, &v9);
  }
}

uint64_t sub_10103FFB0(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 104))(a1, a2, &v4);
}

uint64_t sub_10103FFF8(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 112))(a1, a2, &v4);
}

uint64_t sub_101040040(uint64_t a1, int a2)
{
  int v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 120))(a1, &v3);
}

uint64_t sub_101040088(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96))(a1, a2, a3, &unk_102475AE0);
}

uint64_t sub_1010400B4(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(unsigned char *)(a1 + 108)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          __int16 v24 = (uint64_t *)v18;
        }
        else {
          __int16 v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }
      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          uint64_t v29 = (uint64_t *)v25;
        }
        else {
          uint64_t v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }
      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v35 = *(void *)(v26 + 56);
        char v36 = *a4;
        *(void *)long long buf = &v41;
        *((unsigned char *)sub_1000EB1B8((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 32) = v36;
        _OWORD buf[2] = 0;
        *(_WORD *)long long buf = 0;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, unsigned char *))(*(void *)a1 + 128))(a1, a3, buf))
        {
          sub_101041A8C();
        }
        if (v35) {
          goto LABEL_46;
        }
      }
      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_102475AE1;
        int v39 = v17;
        *(void *)long long buf = &v39;
        *((unsigned char *)sub_10044715C((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 8sub_100FB8FC8(&a9, 0) = v30;
        int v39 = *a3;
        *(void *)long long buf = &v39;
        long long v31 = sub_10044715C((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        char v32 = (std::__shared_weak_count *)v31[9];
        v31[8] = 0;
        v31[9] = 0;
        if (v32) {
          sub_1000DB0A0(v32);
        }
        char v33 = *a4;
        int v39 = *a3;
        *(void *)long long buf = &v39;
        unint64_t v34 = sub_10044715C((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_101D0B290, (_DWORD **)buf);
        *(void *)long long buf = &v41;
        *((unsigned char *)sub_1000EB1B8(v34 + 5, &v41, (uint64_t)&unk_101D0B290, (_DWORD **)buf) + 32) = v33;
      }
      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168))(a1, a3);
LABEL_46:
      if (v21 == v19)
      {
        *(_DWORD *)long long buf = *a3;
        sub_1000EDED4((uint64_t **)(*(void *)v42 + 40), (int *)buf, buf);
      }
      return 1;
    }
  }
  if (qword_102419580 != -1) {
    dispatch_once(&qword_102419580, &stru_10230C638);
  }
  id v14 = qword_102419588;
  if (os_log_type_enabled((os_log_t)qword_102419588, OS_LOG_TYPE_FAULT))
  {
    BOOL v15 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      BOOL v15 = (void *)*v15;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v46 = 1026;
    int v47 = a2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }
  BOOL v16 = sub_10013D1A0(115, 0);
  uint64_t result = 0;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419580 != -1) {
      dispatch_once(&qword_102419580, &stru_10230C638);
    }
    uint64_t v37 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v37 = (void *)*v37;
    }
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    long long v38 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "%s\n", v38);
    if (v38 != buf) {
      free(v38);
    }
    return 0;
  }
  return result;
}