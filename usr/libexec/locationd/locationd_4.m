void sub_100264EA4(uint64_t a1, void *lpsrc)
{
  uint64_t vars8;

  sub_10025F07C(a1, (uint64_t)lpsrc);
}

void sub_100264F2C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v22);
  }
  int v4 = *(_DWORD *)(a2 + 80);
  if (!(_BYTE)v4) {
    goto LABEL_17;
  }
  if (v4)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 24);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      sub_101A564E4();
    }
    *(_DWORD *)(a1 + 80) |= 1u;
    *(_DWORD *)(a1 + 24) = v5;
    int v4 = *(_DWORD *)(a2 + 80);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v12 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 80) |= 2u;
    *(void *)(a1 + 8) = v12;
    int v4 = *(_DWORD *)(a2 + 80);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_34;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  char v13 = *(unsigned char *)(a2 + 28);
  *(_DWORD *)(a1 + 80) |= 4u;
  *(unsigned char *)(a1 + 28) = v13;
  int v4 = *(_DWORD *)(a2 + 80);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_37;
  }
LABEL_34:
  v14 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 80) |= 8u;
  v15 = *(std::string **)(a1 + 16);
  if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v15, v14);
  int v4 = *(_DWORD *)(a2 + 80);
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_40:
    v18 = *(const std::string **)(a2 + 40);
    *(_DWORD *)(a1 + 80) |= 0x20u;
    v19 = *(std::string **)(a1 + 40);
    if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v19, v18);
    int v4 = *(_DWORD *)(a2 + 80);
    if ((v4 & 0x40) == 0)
    {
LABEL_15:
      if ((v4 & 0x80) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_43;
  }
LABEL_37:
  v16 = *(const std::string **)(a2 + 32);
  *(_DWORD *)(a1 + 80) |= 0x10u;
  v17 = *(std::string **)(a1 + 32);
  if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v17, v16);
  int v4 = *(_DWORD *)(a2 + 80);
  if ((v4 & 0x20) != 0) {
    goto LABEL_40;
  }
LABEL_14:
  if ((v4 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_43:
  v20 = *(const std::string **)(a2 + 48);
  *(_DWORD *)(a1 + 80) |= 0x40u;
  v21 = *(std::string **)(a1 + 48);
  if (v21 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v21, v20);
  int v4 = *(_DWORD *)(a2 + 80);
  if ((v4 & 0x80) != 0)
  {
LABEL_16:
    char v6 = *(unsigned char *)(a2 + 29);
    *(_DWORD *)(a1 + 80) |= 0x80u;
    *(unsigned char *)(a1 + 29) = v6;
    int v4 = *(_DWORD *)(a2 + 80);
  }
LABEL_17:
  if ((v4 & 0xFF00) != 0)
  {
    if ((v4 & 0x100) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 56);
      if (v7 >= 2) {
        sub_101A564B8();
      }
      *(_DWORD *)(a1 + 80) |= 0x100u;
      *(_DWORD *)(a1 + 56) = v7;
      int v4 = *(_DWORD *)(a2 + 80);
    }
    if ((v4 & 0x200) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 60);
      if (v8 >= 6) {
        sub_101A5648C();
      }
      *(_DWORD *)(a1 + 80) |= 0x200u;
      *(_DWORD *)(a1 + 60) = v8;
      int v4 = *(_DWORD *)(a2 + 80);
    }
    if ((v4 & 0x400) != 0)
    {
      unsigned int v9 = *(_DWORD *)(a2 + 72);
      if (v9 >= 6) {
        sub_101A56460();
      }
      *(_DWORD *)(a1 + 80) |= 0x400u;
      *(_DWORD *)(a1 + 72) = v9;
      int v4 = *(_DWORD *)(a2 + 80);
    }
    if ((v4 & 0x800) != 0)
    {
      v10 = *(const std::string **)(a2 + 64);
      *(_DWORD *)(a1 + 80) |= 0x800u;
      v11 = *(std::string **)(a1 + 64);
      if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v11, v10);
    }
  }
}

void sub_10026529C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002652B4(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        sub_101A5653C();
      }
      a1[5] |= 1u;
      a1[2] = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 12);
      if ((v6 - 1) >= 2 && v6 != 255) {
        sub_101A56510();
      }
      a1[5] |= 2u;
      a1[3] = v6;
    }
  }
}

void sub_1002653A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002653BC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        sub_101A56568();
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_DWORD *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = *(unsigned char *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(unsigned char *)(a1 + 12) = v6;
    }
  }
}

void sub_100265494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002654AC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if (!(_BYTE)v4) {
    return;
  }
  if (*(unsigned char *)(a2 + 24))
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      sub_101A56594();
    }
    *(_DWORD *)(a1 + 24) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
    int v4 = *(_DWORD *)(a2 + 24);
  }
  if ((v4 & 2) != 0)
  {
    char v7 = *(unsigned char *)(a2 + 12);
    *(_DWORD *)(a1 + 24) |= 2u;
    *(unsigned char *)(a1 + 12) = v7;
    int v4 = *(_DWORD *)(a2 + 24);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_19;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  char v8 = *(unsigned char *)(a2 + 13);
  *(_DWORD *)(a1 + 24) |= 4u;
  *(unsigned char *)(a1 + 13) = v8;
  int v4 = *(_DWORD *)(a2 + 24);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
LABEL_20:
    char v10 = *(unsigned char *)(a2 + 15);
    *(_DWORD *)(a1 + 24) |= 0x10u;
    *(unsigned char *)(a1 + 15) = v10;
    int v4 = *(_DWORD *)(a2 + 24);
    if ((v4 & 0x20) == 0)
    {
LABEL_14:
      if ((v4 & 0x40) == 0) {
        return;
      }
      goto LABEL_15;
    }
    goto LABEL_21;
  }
LABEL_19:
  char v9 = *(unsigned char *)(a2 + 14);
  *(_DWORD *)(a1 + 24) |= 8u;
  *(unsigned char *)(a1 + 14) = v9;
  int v4 = *(_DWORD *)(a2 + 24);
  if ((v4 & 0x10) != 0) {
    goto LABEL_20;
  }
LABEL_13:
  if ((v4 & 0x20) == 0) {
    goto LABEL_14;
  }
LABEL_21:
  char v11 = *(unsigned char *)(a2 + 16);
  *(_DWORD *)(a1 + 24) |= 0x20u;
  *(unsigned char *)(a1 + 16) = v11;
  if ((*(_DWORD *)(a2 + 24) & 0x40) != 0)
  {
LABEL_15:
    char v6 = *(unsigned char *)(a2 + 17);
    *(_DWORD *)(a1 + 24) |= 0x40u;
    *(unsigned char *)(a1 + 17) = v6;
  }
}

void sub_100265628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100265640(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 20);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 20))
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        sub_101A565C0();
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_DWORD *)(a1 + 8) = v5;
      int v4 = *(_DWORD *)(a2 + 20);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = *(unsigned char *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(unsigned char *)(a1 + 12) = v6;
    }
  }
}

void sub_100265718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100265730(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      sub_101A565EC();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v4;
  }
}

void sub_1002657E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_100265800(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      sub_101A56618();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v4;
  }
}

void sub_1002658B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002658D0()
{
  return 1;
}

void *sub_1002658D8@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.ReceivedEvent");
}

uint64_t sub_1002658E8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1022A1978;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 72) = 1;
  *(_WORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  sub_100265998(a1, a2);
  return a1;
}

void sub_100265964(_Unwind_Exception *a1)
{
  v3 = v2;
  if (*v3) {
    operator delete[]();
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_100265998(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v31);
  }
  int v4 = *(_DWORD *)(a2 + 112);
  if (v4)
  {
    sub_100221DFC(a1 + 104, *(_DWORD *)(a1 + 112) + v4);
    memcpy((void *)(*(void *)(a1 + 104) + 4 * *(int *)(a1 + 112)), *(const void **)(a2 + 104), 4 * *(int *)(a2 + 112));
    *(_DWORD *)(a1 + 112) += *(_DWORD *)(a2 + 112);
  }
  int v5 = *(_DWORD *)(a2 + 128);
  if (!(_BYTE)v5) {
    goto LABEL_50;
  }
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a2 + 72);
    if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0)) {
      sub_101A56644();
    }
    *(_DWORD *)(a1 + 128) |= 1u;
    *(_DWORD *)(a1 + 72) = v6;
    int v5 = *(_DWORD *)(a2 + 128);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 128) |= 2u;
    *(void *)(a1 + 8) = v7;
    int v5 = *(_DWORD *)(a2 + 128);
    if ((v5 & 4) == 0)
    {
LABEL_13:
      if ((v5 & 8) == 0) {
        goto LABEL_14;
      }
      goto LABEL_25;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_13;
  }
  *(_DWORD *)(a1 + 128) |= 4u;
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    operator new();
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_102489AC0 + 16);
  }
  sub_10024D738(v8, v9);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 8) == 0)
  {
LABEL_14:
    if ((v5 & 0x10) == 0) {
      goto LABEL_15;
    }
    goto LABEL_30;
  }
LABEL_25:
  *(_DWORD *)(a1 + 128) |= 8u;
  uint64_t v10 = *(void *)(a1 + 24);
  if (!v10) {
    operator new();
  }
  uint64_t v11 = *(void *)(a2 + 24);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_102489AC0 + 24);
  }
  sub_10024EE94(v10, v11);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x10) == 0)
  {
LABEL_15:
    if ((v5 & 0x20) == 0) {
      goto LABEL_16;
    }
LABEL_35:
    *(_DWORD *)(a1 + 128) |= 0x20u;
    uint64_t v14 = *(void *)(a1 + 40);
    if (!v14) {
      operator new();
    }
    uint64_t v15 = *(void *)(a2 + 40);
    if (!v15) {
      uint64_t v15 = *(void *)(qword_102489AC0 + 40);
    }
    sub_100250168(v14, v15);
    int v5 = *(_DWORD *)(a2 + 128);
    if ((v5 & 0x40) == 0)
    {
LABEL_17:
      if ((v5 & 0x80) == 0) {
        goto LABEL_50;
      }
      goto LABEL_45;
    }
    goto LABEL_40;
  }
LABEL_30:
  *(_DWORD *)(a1 + 128) |= 0x10u;
  uint64_t v12 = *(void *)(a1 + 32);
  if (!v12) {
    operator new();
  }
  uint64_t v13 = *(void *)(a2 + 32);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_102489AC0 + 32);
  }
  sub_10024FA74(v12, v13);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x20) != 0) {
    goto LABEL_35;
  }
LABEL_16:
  if ((v5 & 0x40) == 0) {
    goto LABEL_17;
  }
LABEL_40:
  *(_DWORD *)(a1 + 128) |= 0x40u;
  uint64_t v16 = *(void *)(a1 + 48);
  if (!v16) {
    operator new();
  }
  uint64_t v17 = *(void *)(a2 + 48);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_102489AC0 + 48);
  }
  sub_100251138(v16, v17);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x80) != 0)
  {
LABEL_45:
    *(_DWORD *)(a1 + 128) |= 0x80u;
    uint64_t v18 = *(void *)(a1 + 56);
    if (!v18) {
      operator new();
    }
    uint64_t v19 = *(void *)(a2 + 56);
    if (!v19) {
      uint64_t v19 = *(void *)(qword_102489AC0 + 56);
    }
    sub_1002515D8(v18, v19);
    int v5 = *(_DWORD *)(a2 + 128);
  }
LABEL_50:
  if ((v5 & 0xFF00) == 0) {
    return;
  }
  if ((v5 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 128) |= 0x100u;
    uint64_t v20 = *(void *)(a1 + 64);
    if (!v20) {
      operator new();
    }
    uint64_t v21 = *(void *)(a2 + 64);
    if (!v21) {
      uint64_t v21 = *(void *)(qword_102489AC0 + 64);
    }
    sub_1002532AC(v20, v21);
    int v5 = *(_DWORD *)(a2 + 128);
    if ((v5 & 0x200) == 0)
    {
LABEL_53:
      if ((v5 & 0x400) == 0) {
        goto LABEL_54;
      }
      goto LABEL_69;
    }
  }
  else if ((v5 & 0x200) == 0)
  {
    goto LABEL_53;
  }
  *(_DWORD *)(a1 + 128) |= 0x200u;
  uint64_t v22 = *(void *)(a1 + 80);
  if (!v22) {
    operator new();
  }
  uint64_t v23 = *(void *)(a2 + 80);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_102489AC0 + 80);
  }
  sub_100254FD4(v22, v23);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x400) == 0)
  {
LABEL_54:
    if ((v5 & 0x800) == 0) {
      goto LABEL_55;
    }
    goto LABEL_74;
  }
LABEL_69:
  *(_DWORD *)(a1 + 128) |= 0x400u;
  uint64_t v24 = *(void *)(a1 + 88);
  if (!v24) {
    operator new();
  }
  uint64_t v25 = *(void *)(a2 + 88);
  if (!v25) {
    uint64_t v25 = *(void *)(qword_102489AC0 + 88);
  }
  sub_10024E35C(v24, v25);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x800) == 0)
  {
LABEL_55:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_56;
    }
    goto LABEL_75;
  }
LABEL_74:
  char v26 = *(unsigned char *)(a2 + 76);
  *(_DWORD *)(a1 + 128) |= 0x800u;
  *(unsigned char *)(a1 + 76) = v26;
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x1000) == 0)
  {
LABEL_56:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_57;
    }
LABEL_80:
    char v29 = *(unsigned char *)(a2 + 77);
    *(_DWORD *)(a1 + 128) |= 0x2000u;
    *(unsigned char *)(a1 + 77) = v29;
    if ((*(_DWORD *)(a2 + 128) & 0x4000) == 0) {
      return;
    }
    goto LABEL_81;
  }
LABEL_75:
  *(_DWORD *)(a1 + 128) |= 0x1000u;
  uint64_t v27 = *(void *)(a1 + 96);
  if (!v27) {
    operator new();
  }
  uint64_t v28 = *(void *)(a2 + 96);
  if (!v28) {
    uint64_t v28 = *(void *)(qword_102489AC0 + 96);
  }
  sub_100250608(v27, v28);
  int v5 = *(_DWORD *)(a2 + 128);
  if ((v5 & 0x2000) != 0) {
    goto LABEL_80;
  }
LABEL_57:
  if ((v5 & 0x4000) == 0) {
    return;
  }
LABEL_81:
  unsigned int v30 = *(_DWORD *)(a2 + 120);
  if (v30 >= 4 && v30 != 15) {
    sub_101A544F8();
  }
  *(_DWORD *)(a1 + 128) |= 0x4000u;
  *(_DWORD *)(a1 + 120) = v30;
}

void sub_1002660B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002660CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1978;
  sub_10026613C(a1);
  if (*((void *)a1 + 13)) {
    operator delete[]();
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void *sub_10026613C(void *result)
{
  if ((void *)qword_102489AC0 != result)
  {
    v1 = result;
    uint64_t v2 = result[2];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[3];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[4];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[5];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[6];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[7];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[8];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[10];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v1[11];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    result = (void *)v1[12];
    if (result)
    {
      uint64_t v11 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v11();
    }
  }
  return result;
}

void sub_100266340(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1002660CC(a1);

  operator delete();
}

void sub_100266378()
{
}

uint64_t sub_1002663F0(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 128);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 72) = 1;
    *(void *)(result + 8) = 0;
    if ((v2 & 4) != 0)
    {
      result = *(void *)(result + 16);
      if (result)
      {
        result = sub_10024DB54(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 8) != 0)
    {
      result = *(void *)(v1 + 24);
      if (result)
      {
        result = sub_10024F2B8(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      result = *(void *)(v1 + 32);
      if (result)
      {
        result = sub_10024FCBC(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x20) != 0)
    {
      uint64_t v3 = *(void *)(v1 + 40);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 16)) {
          *(_DWORD *)(v3 + 8) = 5;
        }
        *(_DWORD *)(v3 + 16) = 0;
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x40) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 48);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 16)) {
          *(_DWORD *)(v4 + 8) = 7;
        }
        *(_DWORD *)(v4 + 16) = 0;
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x80) != 0)
    {
      result = *(void *)(v1 + 56);
      if (result)
      {
        result = sub_100251F6C(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      result = *(void *)(v1 + 64);
      if (result)
      {
        result = sub_1002539E8(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x200) != 0)
    {
      result = *(void *)(v1 + 80);
      if (result)
      {
        result = sub_100255500(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x400) != 0)
    {
      result = *(void *)(v1 + 88);
      if (result)
      {
        result = sub_10024E688(result);
        int v2 = *(_DWORD *)(v1 + 128);
      }
    }
    *(unsigned char *)(v1 + 76) = 0;
    if ((v2 & 0x1000) != 0)
    {
      result = *(void *)(v1 + 96);
      if (result) {
        result = sub_100250A0C(result);
      }
    }
    *(unsigned char *)(v1 + 77) = 0;
    *(_DWORD *)(v1 + 120) = 0;
  }
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 128) = 0;
  return result;
}

uint64_t sub_100266528(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = a1 + 104;
  while (2)
  {
    uint64_t v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v6;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        v126[0] = 0;
        uint64_t v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126);
          if (!result) {
            return result;
          }
          unsigned int v10 = v126[0];
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)this + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v21 = ((1 << v10) & 0x76B6) == 0) : (BOOL v21 = 1), !v21))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
            sub_101A56644();
          }
          *(_DWORD *)(a1 + 128) |= 1u;
          *(_DWORD *)(a1 + 72) = v10;
        }
        uint64_t v23 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v23 < *((void *)this + 2) && *v23 == 17)
        {
          *((void *)this + 1) = v23 + 1;
          goto LABEL_65;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_44;
        }
LABEL_65:
        *(void *)v126 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v126) & 1) == 0)return 0; {
        *(void *)(a1 + 8) = *(void *)v126;
        }
        int v13 = *(_DWORD *)(a1 + 128) | 2;
        *(_DWORD *)(a1 + 128) = v13;
        uint64_t v24 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v24 >= *((void *)this + 2) || *v24 != 26) {
          continue;
        }
        *((void *)this + 1) = v24 + 1;
LABEL_69:
        *(_DWORD *)(a1 + 128) = v13 | 4;
        uint64_t v25 = *(void *)(a1 + 16);
        if (!v25) {
          operator new();
        }
        v126[0] = 0;
        char v26 = (char *)*((void *)this + 1);
        if ((unint64_t)v26 >= *((void *)this + 2) || *v26 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v26;
          *((void *)this + 1) = v26 + 1;
        }
        int v27 = *((_DWORD *)this + 14);
        int v28 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v27 + 1;
        if (v27 >= v28) {
          return 0;
        }
        int v29 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10024DC0C(v25, this, v30) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v29);
        int v31 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v31, 1);
        int v33 = v31 - 1;
        if (v33 < 0 == v32) {
          *((_DWORD *)this + 14) = v33;
        }
        v34 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v34 >= *((void *)this + 2) || *v34 != 34) {
          continue;
        }
        *((void *)this + 1) = v34 + 1;
LABEL_83:
        *(_DWORD *)(a1 + 128) |= 8u;
        uint64_t v35 = *(void *)(a1 + 24);
        if (!v35) {
          operator new();
        }
        v126[0] = 0;
        v36 = (char *)*((void *)this + 1);
        if ((unint64_t)v36 >= *((void *)this + 2) || *v36 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v36;
          *((void *)this + 1) = v36 + 1;
        }
        int v37 = *((_DWORD *)this + 14);
        int v38 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v37 + 1;
        if (v37 >= v38) {
          return 0;
        }
        int v39 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10024F35C(v35, this, v40) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v39);
        int v41 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v41, 1);
        int v42 = v41 - 1;
        if (v42 < 0 == v32) {
          *((_DWORD *)this + 14) = v42;
        }
        v43 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v43 >= *((void *)this + 2) || *v43 != 50) {
          continue;
        }
        *((void *)this + 1) = v43 + 1;
LABEL_97:
        *(_DWORD *)(a1 + 128) |= 0x10u;
        uint64_t v44 = *(void *)(a1 + 32);
        if (!v44) {
          operator new();
        }
        v126[0] = 0;
        v45 = (char *)*((void *)this + 1);
        if ((unint64_t)v45 >= *((void *)this + 2) || *v45 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v45;
          *((void *)this + 1) = v45 + 1;
        }
        int v46 = *((_DWORD *)this + 14);
        int v47 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v46 + 1;
        if (v46 >= v47) {
          return 0;
        }
        int v48 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10024FD0C(v44, this, v49) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v48);
        int v50 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v50, 1);
        int v51 = v50 - 1;
        if (v51 < 0 == v32) {
          *((_DWORD *)this + 14) = v51;
        }
        v52 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v52 >= *((void *)this + 2) || *v52 != 58) {
          continue;
        }
        *((void *)this + 1) = v52 + 1;
LABEL_111:
        *(_DWORD *)(a1 + 128) |= 0x20u;
        uint64_t v53 = *(void *)(a1 + 40);
        if (!v53) {
          operator new();
        }
        v126[0] = 0;
        v54 = (char *)*((void *)this + 1);
        if ((unint64_t)v54 >= *((void *)this + 2) || *v54 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v54;
          *((void *)this + 1) = v54 + 1;
        }
        int v55 = *((_DWORD *)this + 14);
        int v56 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v55 + 1;
        if (v55 >= v56) {
          return 0;
        }
        int v57 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10025031C(v53, this, v58) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v57);
        int v59 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v59, 1);
        int v60 = v59 - 1;
        if (v60 < 0 == v32) {
          *((_DWORD *)this + 14) = v60;
        }
        v61 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v61 >= *((void *)this + 2) || *v61 != 74) {
          continue;
        }
        *((void *)this + 1) = v61 + 1;
LABEL_125:
        *(_DWORD *)(a1 + 128) |= 0x40u;
        uint64_t v62 = *(void *)(a1 + 48);
        if (!v62) {
          operator new();
        }
        v126[0] = 0;
        v63 = (char *)*((void *)this + 1);
        if ((unint64_t)v63 >= *((void *)this + 2) || *v63 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v63;
          *((void *)this + 1) = v63 + 1;
        }
        int v64 = *((_DWORD *)this + 14);
        int v65 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v64 + 1;
        if (v64 >= v65) {
          return 0;
        }
        int v66 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_1002512EC(v62, this, v67) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v66);
        int v68 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v68, 1);
        int v69 = v68 - 1;
        if (v69 < 0 == v32) {
          *((_DWORD *)this + 14) = v69;
        }
        v70 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v70 >= *((void *)this + 2) || *v70 != 90) {
          continue;
        }
        *((void *)this + 1) = v70 + 1;
LABEL_139:
        *(_DWORD *)(a1 + 128) |= 0x80u;
        uint64_t v71 = *(void *)(a1 + 56);
        if (!v71) {
          operator new();
        }
        v126[0] = 0;
        v72 = (char *)*((void *)this + 1);
        if ((unint64_t)v72 >= *((void *)this + 2) || *v72 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v72;
          *((void *)this + 1) = v72 + 1;
        }
        int v73 = *((_DWORD *)this + 14);
        int v74 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v73 + 1;
        if (v73 >= v74) {
          return 0;
        }
        int v75 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10025222C(v71, this, v76) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v75);
        int v77 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v77, 1);
        int v78 = v77 - 1;
        if (v78 < 0 == v32) {
          *((_DWORD *)this + 14) = v78;
        }
        v79 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v79 >= *((void *)this + 2) || *v79 != 98) {
          continue;
        }
        *((void *)this + 1) = v79 + 1;
LABEL_153:
        *(_DWORD *)(a1 + 128) |= 0x100u;
        uint64_t v80 = *(void *)(a1 + 64);
        if (!v80) {
          operator new();
        }
        v126[0] = 0;
        v81 = (char *)*((void *)this + 1);
        if ((unint64_t)v81 >= *((void *)this + 2) || *v81 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v81;
          *((void *)this + 1) = v81 + 1;
        }
        int v82 = *((_DWORD *)this + 14);
        int v83 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v82 + 1;
        if (v82 >= v83) {
          return 0;
        }
        int v84 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_100253BB8(v80, this, v85) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v84);
        int v86 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v86, 1);
        int v87 = v86 - 1;
        if (v87 < 0 == v32) {
          *((_DWORD *)this + 14) = v87;
        }
        v88 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v88 >= *((void *)this + 2) || *v88 != 114) {
          continue;
        }
        *((void *)this + 1) = v88 + 1;
LABEL_167:
        *(_DWORD *)(a1 + 128) |= 0x200u;
        uint64_t v89 = *(void *)(a1 + 80);
        if (!v89) {
          operator new();
        }
        v126[0] = 0;
        v90 = (char *)*((void *)this + 1);
        if ((unint64_t)v90 >= *((void *)this + 2) || *v90 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v90;
          *((void *)this + 1) = v90 + 1;
        }
        int v91 = *((_DWORD *)this + 14);
        int v92 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v91 + 1;
        if (v91 >= v92) {
          return 0;
        }
        int v93 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_1002555CC(v89, this, v94) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v93);
        int v95 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v95, 1);
        int v96 = v95 - 1;
        if (v96 < 0 == v32) {
          *((_DWORD *)this + 14) = v96;
        }
        v97 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v97 >= *((void *)this + 2) || *v97 != 122) {
          continue;
        }
        *((void *)this + 1) = v97 + 1;
LABEL_181:
        *(_DWORD *)(a1 + 128) |= 0x400u;
        uint64_t v98 = *(void *)(a1 + 88);
        if (!v98) {
          operator new();
        }
        v126[0] = 0;
        v99 = (char *)*((void *)this + 1);
        if ((unint64_t)v99 >= *((void *)this + 2) || *v99 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v99;
          *((void *)this + 1) = v99 + 1;
        }
        int v100 = *((_DWORD *)this + 14);
        int v101 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v100 + 1;
        if (v100 >= v101) {
          return 0;
        }
        int v102 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_10024E744(v98, this, v103) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v102);
        int v104 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v104, 1);
        int v105 = v104 - 1;
        if (v105 < 0 == v32) {
          *((_DWORD *)this + 14) = v105;
        }
        v106 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        if ((int)v14 - (int)v106 <= 1 || *v106 != 128 || v106[1] != 1) {
          continue;
        }
        uint64_t v15 = v106 + 2;
        *((void *)this + 1) = v15;
LABEL_196:
        v126[0] = 0;
        if ((unint64_t)v15 >= v14 || (char)*v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126);
          if (!result) {
            return result;
          }
          unsigned int v107 = v126[0];
          v108 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v14 = *((void *)this + 2);
        }
        else
        {
          unsigned int v107 = *v15;
          v108 = v15 + 1;
          *((void *)this + 1) = v108;
        }
        *(unsigned char *)(a1 + 76) = v107 != 0;
        int v16 = *(_DWORD *)(a1 + 128) | 0x800;
        *(_DWORD *)(a1 + 128) = v16;
        if ((int)v14 - (int)v108 < 2 || *v108 != 138 || v108[1] != 1) {
          continue;
        }
        *((void *)this + 1) = v108 + 2;
LABEL_205:
        *(_DWORD *)(a1 + 128) = v16 | 0x1000;
        uint64_t v109 = *(void *)(a1 + 96);
        if (!v109) {
          operator new();
        }
        v126[0] = 0;
        v110 = (char *)*((void *)this + 1);
        if ((unint64_t)v110 >= *((void *)this + 2) || *v110 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126))return 0; {
        }
          }
        else
        {
          v126[0] = *v110;
          *((void *)this + 1) = v110 + 1;
        }
        int v111 = *((_DWORD *)this + 14);
        int v112 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v111 + 1;
        if (v111 >= v112) {
          return 0;
        }
        int v113 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v126[0]);
        if (!sub_100250AC4(v109, this, v114) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v113);
        int v115 = *((_DWORD *)this + 14);
        BOOL v32 = __OFSUB__(v115, 1);
        int v116 = v115 - 1;
        if (v116 < 0 == v32) {
          *((_DWORD *)this + 14) = v116;
        }
        v117 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((int)v11 - (int)v117 > 1 && *v117 == 144 && v117[1] == 1)
        {
          uint64_t v12 = v117 + 2;
          *((void *)this + 1) = v12;
LABEL_220:
          v126[0] = 0;
          if ((unint64_t)v12 >= v11 || (char)*v12 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126);
            if (!result) {
              return result;
            }
            unsigned int v118 = v126[0];
            v119 = (unsigned __int8 *)*((void *)this + 1);
            unint64_t v11 = *((void *)this + 2);
          }
          else
          {
            unsigned int v118 = *v12;
            v119 = v12 + 1;
            *((void *)this + 1) = v119;
          }
          *(unsigned char *)(a1 + 77) = v118 != 0;
          *(_DWORD *)(a1 + 128) |= 0x2000u;
          if ((int)v11 - (int)v119 >= 2 && *v119 == 152 && v119[1] == 1)
          {
            uint64_t v17 = (char *)(v119 + 2);
            *((void *)this + 1) = v17;
LABEL_229:
            v126[0] = 0;
            if ((unint64_t)v17 >= v11 || *v17 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126);
              if (!result) {
                return result;
              }
              unsigned int v120 = v126[0];
            }
            else
            {
              unsigned int v120 = *v17;
              *((void *)this + 1) = v17 + 1;
            }
            if (v120 < 4 || v120 == 15)
            {
              *(_DWORD *)(a1 + 128) |= 0x4000u;
              *(_DWORD *)(a1 + 120) = v120;
            }
            v122 = (unsigned __int8 *)*((void *)this + 1);
            uint64_t v18 = (unsigned __int8 *)*((void *)this + 2);
            if ((int)v18 - (int)v122 >= 2 && *v122 == 160 && v122[1] == 1) {
              goto LABEL_243;
            }
          }
        }
        continue;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_44;
        }
        int v13 = *(_DWORD *)(a1 + 128);
        goto LABEL_69;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_83;
        }
        goto LABEL_44;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_97;
        }
        goto LABEL_44;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_111;
        }
        goto LABEL_44;
      case 9u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_125;
        }
        goto LABEL_44;
      case 0xBu:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_139;
        }
        goto LABEL_44;
      case 0xCu:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_153;
        }
        goto LABEL_44;
      case 0xEu:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_167;
        }
        goto LABEL_44;
      case 0xFu:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_181;
        }
        goto LABEL_44;
      case 0x10u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v15 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_196;
      case 0x11u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_44;
        }
        int v16 = *(_DWORD *)(a1 + 128);
        goto LABEL_205;
      case 0x12u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v12 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_220;
      case 0x13u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_44;
        }
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_229;
      case 0x14u:
        int v8 = TagFallback & 7;
        if (v8 == 2)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline();
          if (!result) {
            return result;
          }
          while (1)
          {
            v122 = (unsigned __int8 *)*((void *)this + 1);
            uint64_t v18 = (unsigned __int8 *)*((void *)this + 2);
            if ((int)v18 - (int)v122 < 2 || *v122 != 160 || v122[1] != 1) {
              break;
            }
LABEL_243:
            uint64_t v19 = (char *)(v122 + 2);
            *((void *)this + 1) = v19;
LABEL_244:
            v126[0] = 0;
            if (v19 >= (char *)v18 || *v19 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v126);
              if (!result) {
                return result;
              }
              unsigned int v123 = v126[0];
            }
            else
            {
              unsigned int v123 = *v19;
              *((void *)this + 1) = v19 + 1;
            }
            if (v123 <= 7)
            {
              int v124 = *(_DWORD *)(a1 + 112);
              if (v124 == *(_DWORD *)(a1 + 116))
              {
                sub_100221DFC(v5, v124 + 1);
                int v124 = *(_DWORD *)(a1 + 112);
              }
              uint64_t v125 = *(void *)(a1 + 104);
              *(_DWORD *)(a1 + 112) = v124 + 1;
              *(_DWORD *)(v125 + 4 * v124) = v123;
            }
          }
          if (v122 == v18 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)this + 36) = 1;
            return result;
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          uint64_t v19 = (char *)*((void *)this + 1);
          uint64_t v18 = (unsigned __int8 *)*((void *)this + 2);
          goto LABEL_244;
        }
LABEL_44:
        if (v8 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
      default:
        int v8 = TagFallback & 7;
        goto LABEL_44;
    }
  }
}

uint64_t sub_100267610(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 128);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 72), (int)a2, a4);
    int v6 = *(_DWORD *)(v5 + 128);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_23;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (int)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_26;
  }
LABEL_23:
  uint64_t v8 = *(void *)(v5 + 16);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_102489AC0 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v8, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_29;
  }
LABEL_26:
  uint64_t v9 = *(void *)(v5 + 24);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_102489AC0 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v9, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_32;
  }
LABEL_29:
  uint64_t v10 = *(void *)(v5 + 32);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_102489AC0 + 32);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v10, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_35;
  }
LABEL_32:
  uint64_t v11 = *(void *)(v5 + 40);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_102489AC0 + 40);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v11, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_38;
  }
LABEL_35:
  uint64_t v12 = *(void *)(v5 + 48);
  if (!v12) {
    uint64_t v12 = *(void *)(qword_102489AC0 + 48);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v12, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_41;
  }
LABEL_38:
  uint64_t v13 = *(void *)(v5 + 56);
  if (!v13) {
    uint64_t v13 = *(void *)(qword_102489AC0 + 56);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v13, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_44;
  }
LABEL_41:
  uint64_t v14 = *(void *)(v5 + 64);
  if (!v14) {
    uint64_t v14 = *(void *)(qword_102489AC0 + 64);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v14, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_47;
  }
LABEL_44:
  uint64_t v15 = *(void *)(v5 + 80);
  if (!v15) {
    uint64_t v15 = *(void *)(qword_102489AC0 + 80);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v15, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_50;
  }
LABEL_47:
  uint64_t v16 = *(void *)(v5 + 88);
  if (!v16) {
    uint64_t v16 = *(void *)(qword_102489AC0 + 88);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v16, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_51;
  }
LABEL_50:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, *(unsigned __int8 *)(v5 + 76), (BOOL)a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_54;
  }
LABEL_51:
  uint64_t v17 = *(void *)(v5 + 96);
  if (!v17) {
    uint64_t v17 = *(void *)(qword_102489AC0 + 96);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v17, a2, a4);
  int v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x2000) == 0)
  {
LABEL_15:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_54:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, *(unsigned __int8 *)(v5 + 77), (BOOL)a2, a4);
  if ((*(_DWORD *)(v5 + 128) & 0x4000) != 0) {
LABEL_16:
  }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, *(_DWORD *)(v5 + 120), (int)a2, a4);
LABEL_17:
  if (*(int *)(v5 + 112) >= 1)
  {
    uint64_t v7 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, *(_DWORD *)(*(void *)(v5 + 104) + 4 * v7++), (int)a2, a4);
    while (v7 < *(int *)(v5 + 112));
  }
  return result;
}

uint64_t sub_1002678B4(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 128);
  if (!(_BYTE)v3)
  {
    int v5 = 0;
    goto LABEL_57;
  }
  if (v3)
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 72);
    if ((v6 & 0x80000000) != 0)
    {
      int v7 = 10;
    }
    else if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
      int v3 = *(_DWORD *)(a1 + 128);
    }
    else
    {
      int v7 = 1;
    }
    int v4 = v7 + 1;
  }
  else
  {
    int v4 = 0;
  }
  if ((v3 & 2) != 0) {
    int v5 = v4 + 9;
  }
  else {
    int v5 = v4;
  }
  if ((v3 & 4) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_102489AC0 + 16);
    }
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10024E088(v8, a2);
    int v10 = (int)v9;
    if (v9 >= 0x80) {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
    }
    else {
      int v11 = 1;
    }
    v5 += v10 + v11 + 1;
    int v3 = *(_DWORD *)(a1 + 128);
    if ((v3 & 8) == 0)
    {
LABEL_16:
      if ((v3 & 0x10) == 0) {
        goto LABEL_17;
      }
      goto LABEL_33;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_16;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  if (!v12) {
    uint64_t v12 = *(void *)(qword_102489AC0 + 24);
  }
  uint64_t v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10024F7EC(v12, a2);
  int v14 = (int)v13;
  if (v13 >= 0x80) {
    int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
  }
  else {
    int v15 = 1;
  }
  v5 += v14 + v15 + 1;
  int v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x10) == 0)
  {
LABEL_17:
    if ((v3 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_39;
  }
LABEL_33:
  uint64_t v16 = *(void *)(a1 + 32);
  if (!v16) {
    uint64_t v16 = *(void *)(qword_102489AC0 + 32);
  }
  uint64_t v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10024FF84(v16, a2);
  int v18 = (int)v17;
  if (v17 >= 0x80) {
    int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
  }
  else {
    int v19 = 1;
  }
  v5 += v18 + v19 + 1;
  int v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x20) == 0)
  {
LABEL_18:
    if ((v3 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }
LABEL_39:
  uint64_t v20 = *(void *)(a1 + 40);
  if (!v20) {
    uint64_t v20 = *(void *)(qword_102489AC0 + 40);
  }
  BOOL v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002504A0(v20, a2);
  int v22 = (int)v21;
  if (v21 >= 0x80) {
    int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2);
  }
  else {
    int v23 = 1;
  }
  v5 += v22 + v23 + 1;
  int v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x40) == 0)
  {
LABEL_19:
    if ((v3 & 0x80) == 0) {
      goto LABEL_57;
    }
    goto LABEL_51;
  }
LABEL_45:
  uint64_t v24 = *(void *)(a1 + 48);
  if (!v24) {
    uint64_t v24 = *(void *)(qword_102489AC0 + 48);
  }
  uint64_t v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100251470(v24, a2);
  int v26 = (int)v25;
  if (v25 >= 0x80) {
    int v27 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2);
  }
  else {
    int v27 = 1;
  }
  v5 += v26 + v27 + 1;
  int v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x80) != 0)
  {
LABEL_51:
    uint64_t v28 = *(void *)(a1 + 56);
    if (!v28) {
      uint64_t v28 = *(void *)(qword_102489AC0 + 56);
    }
    int v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100252CC0(v28, a2);
    int v30 = (int)v29;
    if (v29 >= 0x80) {
      int v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v29, a2);
    }
    else {
      int v31 = 1;
    }
    v5 += v30 + v31 + 1;
    int v3 = *(_DWORD *)(a1 + 128);
  }
LABEL_57:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_98;
  }
  if ((v3 & 0x100) == 0)
  {
    if ((v3 & 0x200) == 0) {
      goto LABEL_60;
    }
LABEL_68:
    uint64_t v36 = *(void *)(a1 + 80);
    if (!v36) {
      uint64_t v36 = *(void *)(qword_102489AC0 + 80);
    }
    int v37 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100255CB0(v36, a2);
    int v38 = (int)v37;
    if (v37 >= 0x80) {
      int v39 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v37, a2);
    }
    else {
      int v39 = 1;
    }
    v5 += v38 + v39 + 1;
    int v3 = *(_DWORD *)(a1 + 128);
    if ((v3 & 0x400) == 0) {
      goto LABEL_80;
    }
    goto LABEL_74;
  }
  uint64_t v32 = *(void *)(a1 + 64);
  if (!v32) {
    uint64_t v32 = *(void *)(qword_102489AC0 + 64);
  }
  int v33 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002543DC(v32, a2);
  int v34 = (int)v33;
  if (v33 >= 0x80) {
    int v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v33, a2);
  }
  else {
    int v35 = 1;
  }
  v5 += v34 + v35 + 1;
  int v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x200) != 0) {
    goto LABEL_68;
  }
LABEL_60:
  if ((v3 & 0x400) != 0)
  {
LABEL_74:
    uint64_t v40 = *(void *)(a1 + 88);
    if (!v40) {
      uint64_t v40 = *(void *)(qword_102489AC0 + 88);
    }
    int v41 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10024EBC0(v40, a2);
    int v42 = (int)v41;
    if (v41 >= 0x80) {
      int v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v41, a2);
    }
    else {
      int v43 = 1;
    }
    v5 += v42 + v43 + 1;
    int v3 = *(_DWORD *)(a1 + 128);
  }
LABEL_80:
  if ((v3 & 0x800) != 0) {
    v5 += 3;
  }
  if ((v3 & 0x1000) != 0)
  {
    uint64_t v44 = *(void *)(a1 + 96);
    if (!v44) {
      uint64_t v44 = *(void *)(qword_102489AC0 + 96);
    }
    v45 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100250E9C(v44, a2);
    int v46 = (int)v45;
    if (v45 >= 0x80) {
      int v47 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v45, a2);
    }
    else {
      int v47 = 1;
    }
    v5 += v46 + v47 + 2;
    int v3 = *(_DWORD *)(a1 + 128);
  }
  if ((v3 & 0x2000) != 0) {
    v5 += 3;
  }
  if ((v3 & 0x4000) != 0)
  {
    int v48 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 120);
    if ((v48 & 0x80000000) != 0)
    {
      int v49 = 12;
    }
    else if (v48 >= 0x80)
    {
      int v49 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v48, a2) + 2;
    }
    else
    {
      int v49 = 3;
    }
    v5 += v49;
  }
LABEL_98:
  int v50 = *(_DWORD *)(a1 + 112);
  if (v50 < 1)
  {
    int v52 = 0;
  }
  else
  {
    uint64_t v51 = 0;
    int v52 = 0;
    do
    {
      uint64_t v53 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(void *)(a1 + 104)
                                                                                             + 4 * v51);
      if ((v53 & 0x80000000) != 0)
      {
        int v54 = 10;
      }
      else if (v53 >= 0x80)
      {
        int v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v53, a2);
        int v50 = *(_DWORD *)(a1 + 112);
      }
      else
      {
        int v54 = 1;
      }
      v52 += v54;
      ++v51;
    }
    while (v51 < v50);
  }
  uint64_t result = (v52 + v5 + 2 * v50);
  *(_DWORD *)(a1 + 124) = result;
  return result;
}

void sub_100267CDC(uint64_t a1, void *lpsrc)
{
  sub_100265998(a1, (uint64_t)lpsrc);
}

void sub_100267D64(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_100265998(a1, a2);
  }
}

uint64_t sub_100267DD0()
{
  return 1;
}

void *sub_100267DD8@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.RecordingEvent");
}

uint64_t sub_100267DE8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 24) = 48;
  *(void *)a1 = off_1022A19F0;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 28) = 0;
  *(void *)(a1 + 16) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 40) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 48) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 64) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_DWORD *)(a1 + 80) = 0;
  sub_100264F2C(a1, a2);
  return a1;
}

void sub_100267E60(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void *sub_100267E78(void *result)
{
  uint64_t v1 = result[2];
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  uint64_t v3 = result[4];
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }
  uint64_t v5 = result[5];
  if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    operator delete();
  }
  uint64_t v7 = result[6];
  if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    operator delete();
  }
  uint64_t v9 = result[8];
  if ((_UNKNOWN *)v9 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v9)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    operator delete();
  }
  return result;
}

void sub_100267FDC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A19F0;
  sub_100267E78(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100268030(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A19F0;
  sub_100267E78(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100268098()
{
}

uint64_t sub_100268114(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        v39[0] = 0;
        uint64_t v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 < *((void *)this + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)this + 1) = v8 + 1;
LABEL_39:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v21 = ((1 << v9) & 0x76B6) == 0) : (BOOL v21 = 1), !v21))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              sub_101A564E4();
            }
            *(_DWORD *)(a1 + 80) |= 1u;
            *(_DWORD *)(a1 + 24) = v9;
          }
          int v23 = (unsigned char *)*((void *)this + 1);
          if ((unint64_t)v23 < *((void *)this + 2) && *v23 == 17)
          {
            *((void *)this + 1) = v23 + 1;
            goto LABEL_53;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
        if (result)
        {
          unsigned int v9 = v39[0];
          goto LABEL_39;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_34;
        }
LABEL_53:
        *(void *)int v39 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v39) & 1) == 0)return 0; {
        *(void *)(a1 + 8) = *(void *)v39;
        }
        *(_DWORD *)(a1 + 80) |= 2u;
        uint64_t v24 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v24 >= v10 || *v24 != 24) {
          continue;
        }
        int v11 = v24 + 1;
        *((void *)this + 1) = v11;
LABEL_57:
        v39[0] = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v25 = v39[0];
          int v26 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v25 = *v11;
          int v26 = v11 + 1;
          *((void *)this + 1) = v26;
        }
        *(unsigned char *)(a1 + 28) = v25 != 0;
        int v12 = *(_DWORD *)(a1 + 80) | 4;
        *(_DWORD *)(a1 + 80) = v12;
        if ((unint64_t)v26 >= v10 || *v26 != 34) {
          continue;
        }
        *((void *)this + 1) = v26 + 1;
LABEL_65:
        *(_DWORD *)(a1 + 80) = v12 | 8;
        if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v27 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v27 >= *((void *)this + 2) || *v27 != 42) {
          continue;
        }
        *((void *)this + 1) = v27 + 1;
LABEL_71:
        *(_DWORD *)(a1 + 80) |= 0x10u;
        if (*(_UNKNOWN **)(a1 + 32) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v28 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v28 >= *((void *)this + 2) || *v28 != 50) {
          continue;
        }
        *((void *)this + 1) = v28 + 1;
LABEL_77:
        *(_DWORD *)(a1 + 80) |= 0x20u;
        if (*(_UNKNOWN **)(a1 + 40) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v29 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v29 >= *((void *)this + 2) || *v29 != 58) {
          continue;
        }
        *((void *)this + 1) = v29 + 1;
LABEL_83:
        *(_DWORD *)(a1 + 80) |= 0x40u;
        if (*(_UNKNOWN **)(a1 + 48) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v30 = (unsigned char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        if ((unint64_t)v30 >= v15 || *v30 != 64) {
          continue;
        }
        uint64_t v16 = v30 + 1;
        *((void *)this + 1) = v16;
LABEL_89:
        v39[0] = 0;
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v31 = v39[0];
          uint64_t v32 = (unsigned char *)*((void *)this + 1);
          unint64_t v15 = *((void *)this + 2);
        }
        else
        {
          unsigned int v31 = *v16;
          uint64_t v32 = v16 + 1;
          *((void *)this + 1) = v32;
        }
        *(unsigned char *)(a1 + 29) = v31 != 0;
        *(_DWORD *)(a1 + 80) |= 0x80u;
        if ((unint64_t)v32 >= v15 || *v32 != 72) {
          continue;
        }
        uint64_t v17 = v32 + 1;
        *((void *)this + 1) = v17;
LABEL_97:
        v39[0] = 0;
        if ((unint64_t)v17 >= v15 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v33 = v39[0];
        }
        else
        {
          unsigned int v33 = *v17;
          *((void *)this + 1) = v17 + 1;
        }
        if (v33 <= 1)
        {
          *(_DWORD *)(a1 + 80) |= 0x100u;
          *(_DWORD *)(a1 + 56) = v33;
        }
        int v34 = (unsigned char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        if ((unint64_t)v34 >= v13 || *v34 != 80) {
          continue;
        }
        int v14 = v34 + 1;
        *((void *)this + 1) = v14;
LABEL_107:
        v39[0] = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v35 = v39[0];
        }
        else
        {
          unsigned int v35 = *v14;
          *((void *)this + 1) = v14 + 1;
        }
        if (v35 <= 5)
        {
          *(_DWORD *)(a1 + 80) |= 0x200u;
          *(_DWORD *)(a1 + 60) = v35;
        }
        uint64_t v36 = (unsigned char *)*((void *)this + 1);
        unint64_t v18 = *((void *)this + 2);
        if ((unint64_t)v36 >= v18 || *v36 != 88) {
          continue;
        }
        int v19 = v36 + 1;
        *((void *)this + 1) = v19;
LABEL_117:
        v39[0] = 0;
        if ((unint64_t)v19 >= v18 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!result) {
            return result;
          }
          unsigned int v37 = v39[0];
        }
        else
        {
          unsigned int v37 = *v19;
          *((void *)this + 1) = v19 + 1;
        }
        if (v37 <= 5)
        {
          *(_DWORD *)(a1 + 80) |= 0x400u;
          *(_DWORD *)(a1 + 72) = v37;
        }
        int v38 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v38 >= *((void *)this + 2) || *v38 != 98) {
          continue;
        }
        *((void *)this + 1) = v38 + 1;
LABEL_127:
        *(_DWORD *)(a1 + 80) |= 0x800u;
        if (*(_UNKNOWN **)(a1 + 64) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_57;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_34;
        }
        int v12 = *(_DWORD *)(a1 + 80);
        goto LABEL_65;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_71;
        }
        goto LABEL_34;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_77;
        }
        goto LABEL_34;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_83;
        }
        goto LABEL_34;
      case 8u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_89;
      case 9u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_97;
      case 0xAu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        int v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_107;
      case 0xBu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_34;
        }
        int v19 = (char *)*((void *)this + 1);
        unint64_t v18 = *((void *)this + 2);
        goto LABEL_117;
      case 0xCu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_127;
        }
        goto LABEL_34;
      default:
        int v7 = TagFallback & 7;
LABEL_34:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100268834(uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 80);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 24), a2, a4);
    int v6 = *(_DWORD *)(v5 + 80);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_16:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 28), a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_17:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_19;
  }
LABEL_18:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
LABEL_19:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_22;
  }
LABEL_21:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(unsigned __int8 *)(v5 + 29), a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_23;
  }
LABEL_22:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(_DWORD *)(v5 + 56), a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
LABEL_24:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(_DWORD *)(v5 + 72), a2, a4);
    if ((*(_DWORD *)(v5 + 80) & 0x800) == 0) {
      return result;
    }
    goto LABEL_25;
  }
LABEL_23:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(_DWORD *)(v5 + 60), a2, a4);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x400) != 0) {
    goto LABEL_24;
  }
LABEL_12:
  if ((v6 & 0x800) == 0) {
    return result;
  }
LABEL_25:

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t sub_1002689BC(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 80);
  if (!(_BYTE)v3)
  {
    uint64_t v5 = 0;
    goto LABEL_60;
  }
  if (v3)
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if ((v6 & 0x80000000) != 0)
    {
      int v7 = 10;
    }
    else if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
      int v3 = *(_DWORD *)(a1 + 80);
    }
    else
    {
      int v7 = 1;
    }
    int v4 = v7 + 1;
  }
  else
  {
    int v4 = 0;
  }
  if ((v3 & 2) != 0) {
    v4 += 9;
  }
  if ((v3 & 4) != 0) {
    LODWORD(v5) = v4 + 2;
  }
  else {
    LODWORD(v5) = v4;
  }
  if ((v3 & 8) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    int v9 = *(unsigned __int8 *)(v8 + 23);
    char v10 = v9;
    uint64_t v11 = *(void *)(v8 + 8);
    if ((v9 & 0x80u) == 0) {
      unint64_t v12 = *(unsigned __int8 *)(v8 + 23);
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12 >= 0x80)
    {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12, a2);
      int v9 = *(unsigned __int8 *)(v8 + 23);
      uint64_t v11 = *(void *)(v8 + 8);
      int v3 = *(_DWORD *)(a1 + 80);
      char v10 = *(unsigned char *)(v8 + 23);
    }
    else
    {
      int v13 = 1;
    }
    if (v10 < 0) {
      int v9 = v11;
    }
    LODWORD(v5) = v5 + v13 + v9 + 1;
    if ((v3 & 0x10) == 0)
    {
LABEL_18:
      if ((v3 & 0x20) == 0) {
        goto LABEL_19;
      }
LABEL_39:
      uint64_t v20 = *(void *)(a1 + 40);
      int v21 = *(unsigned __int8 *)(v20 + 23);
      char v22 = v21;
      uint64_t v23 = *(void *)(v20 + 8);
      if ((v21 & 0x80u) == 0) {
        unint64_t v24 = *(unsigned __int8 *)(v20 + 23);
      }
      else {
        unint64_t v24 = v23;
      }
      if (v24 >= 0x80)
      {
        int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, a2);
        int v21 = *(unsigned __int8 *)(v20 + 23);
        uint64_t v23 = *(void *)(v20 + 8);
        int v3 = *(_DWORD *)(a1 + 80);
        char v22 = *(unsigned char *)(v20 + 23);
      }
      else
      {
        int v25 = 1;
      }
      if (v22 < 0) {
        int v21 = v23;
      }
      LODWORD(v5) = v5 + v25 + v21 + 1;
      if ((v3 & 0x40) == 0) {
        goto LABEL_57;
      }
      goto LABEL_48;
    }
  }
  else if ((v3 & 0x10) == 0)
  {
    goto LABEL_18;
  }
  uint64_t v14 = *(void *)(a1 + 32);
  int v15 = *(unsigned __int8 *)(v14 + 23);
  char v16 = v15;
  uint64_t v17 = *(void *)(v14 + 8);
  if ((v15 & 0x80u) == 0) {
    unint64_t v18 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    unint64_t v18 = v17;
  }
  if (v18 >= 0x80)
  {
    int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18, a2);
    int v15 = *(unsigned __int8 *)(v14 + 23);
    uint64_t v17 = *(void *)(v14 + 8);
    int v3 = *(_DWORD *)(a1 + 80);
    char v16 = *(unsigned char *)(v14 + 23);
  }
  else
  {
    int v19 = 1;
  }
  if (v16 < 0) {
    int v15 = v17;
  }
  LODWORD(v5) = v5 + v19 + v15 + 1;
  if ((v3 & 0x20) != 0) {
    goto LABEL_39;
  }
LABEL_19:
  if ((v3 & 0x40) != 0)
  {
LABEL_48:
    uint64_t v26 = *(void *)(a1 + 48);
    int v27 = *(unsigned __int8 *)(v26 + 23);
    char v28 = v27;
    uint64_t v29 = *(void *)(v26 + 8);
    if ((v27 & 0x80u) == 0) {
      unint64_t v30 = *(unsigned __int8 *)(v26 + 23);
    }
    else {
      unint64_t v30 = v29;
    }
    if (v30 >= 0x80)
    {
      int v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v30, a2);
      int v27 = *(unsigned __int8 *)(v26 + 23);
      uint64_t v29 = *(void *)(v26 + 8);
      int v3 = *(_DWORD *)(a1 + 80);
      char v28 = *(unsigned char *)(v26 + 23);
    }
    else
    {
      int v31 = 1;
    }
    if (v28 < 0) {
      int v27 = v29;
    }
    LODWORD(v5) = v5 + v31 + v27 + 1;
  }
LABEL_57:
  if ((v3 & 0x80) != 0) {
    uint64_t v5 = (v5 + 2);
  }
  else {
    uint64_t v5 = v5;
  }
LABEL_60:
  if ((v3 & 0xFF00) == 0) {
    goto LABEL_93;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v32 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 56);
    if ((v32 & 0x80000000) != 0)
    {
      int v33 = 11;
    }
    else if (v32 >= 0x80)
    {
      int v33 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v32, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 80);
    }
    else
    {
      int v33 = 2;
    }
    uint64_t v5 = (v33 + v5);
    if ((v3 & 0x200) == 0)
    {
LABEL_63:
      if ((v3 & 0x400) == 0) {
        goto LABEL_64;
      }
      goto LABEL_78;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_63;
  }
  int v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 60);
  if ((v34 & 0x80000000) != 0)
  {
    int v35 = 11;
  }
  else if (v34 >= 0x80)
  {
    int v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 80);
  }
  else
  {
    int v35 = 2;
  }
  uint64_t v5 = (v35 + v5);
  if ((v3 & 0x400) == 0)
  {
LABEL_64:
    if ((v3 & 0x800) == 0) {
      goto LABEL_93;
    }
    goto LABEL_84;
  }
LABEL_78:
  uint64_t v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 72);
  if ((v36 & 0x80000000) != 0)
  {
    int v37 = 11;
  }
  else if (v36 >= 0x80)
  {
    int v37 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 80);
  }
  else
  {
    int v37 = 2;
  }
  uint64_t v5 = (v37 + v5);
  if ((v3 & 0x800) != 0)
  {
LABEL_84:
    uint64_t v38 = *(void *)(a1 + 64);
    int v39 = *(unsigned __int8 *)(v38 + 23);
    char v40 = v39;
    uint64_t v41 = *(void *)(v38 + 8);
    if ((v39 & 0x80u) == 0) {
      unint64_t v42 = *(unsigned __int8 *)(v38 + 23);
    }
    else {
      unint64_t v42 = v41;
    }
    if (v42 >= 0x80)
    {
      int v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v42, a2);
      int v39 = *(unsigned __int8 *)(v38 + 23);
      uint64_t v41 = *(void *)(v38 + 8);
      char v40 = *(unsigned char *)(v38 + 23);
    }
    else
    {
      int v43 = 1;
    }
    if (v40 < 0) {
      int v39 = v41;
    }
    uint64_t v5 = (v5 + v43 + v39 + 1);
  }
LABEL_93:
  *(_DWORD *)(a1 + 76) = v5;
  return v5;
}

void sub_100268CD4(uint64_t a1, void *lpsrc)
{
  sub_100264F2C(a1, (uint64_t)lpsrc);
}

void sub_100268D5C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_100264F2C(a1, a2);
  }
}

uint64_t sub_100268DC8()
{
  return 1;
}

void *sub_100268DD0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.TriggerEvent");
}

void sub_100268DE0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1A68;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100268E00(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1A68;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100268E54()
{
}

uint64_t sub_100268EA8(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v18 = 0;
      char v10 = (char *)*((void *)this + 1);
      if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!result) {
          return result;
        }
        unsigned int v11 = v18;
      }
      else
      {
        unsigned int v11 = *v10;
        *((void *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (BOOL v12 = ((1 << v11) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0)) {
          sub_101A5653C();
        }
        a1[5] |= 1u;
        a1[2] = v11;
      }
      uint64_t v14 = (unsigned char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        int v9 = v14 + 1;
        *((void *)this + 1) = v9;
LABEL_34:
        unsigned int v17 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
          if (!result) {
            return result;
          }
          unsigned int v15 = v17;
        }
        else
        {
          unsigned int v15 = *v9;
          *((void *)this + 1) = v9 + 1;
        }
        if (v15 - 1 < 2 || v15 == 255)
        {
          a1[5] |= 2u;
          a1[3] = v15;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_1002690B4(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(_DWORD *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100269120(uint64_t a1, unsigned int a2)
{
  char v3 = *(unsigned char *)(a1 + 20);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v4 = 11;
        if ((v3 & 2) == 0) {
          goto LABEL_19;
        }
      }
      else if (v5 >= 0x80)
      {
        uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v4 = 2;
        if ((v3 & 2) == 0) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      uint64_t v4 = 0;
      if ((*(unsigned char *)(a1 + 20) & 2) == 0) {
        goto LABEL_19;
      }
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v6 & 0x80000000) != 0)
    {
      int v7 = 11;
    }
    else if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    }
    else
    {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }
  else
  {
    uint64_t v4 = 0;
  }
LABEL_19:
  *(_DWORD *)(a1 + 16) = v4;
  return v4;
}

void sub_1002691CC(_DWORD *a1, void *lpsrc)
{
  sub_1002652B4(a1, (uint64_t)lpsrc);
}

void sub_100269254(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 != a1)
  {
    (*(void (**)(_DWORD *))(*(void *)a1 + 32))(a1);
    sub_1002652B4(a1, a2);
  }
}

uint64_t sub_1002692C0()
{
  return 1;
}

void *sub_1002692C8@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.LegacyClientStatusUpdate");
}

void sub_1002692D8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1AE0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002692F8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1AE0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026934C()
{
}

uint64_t sub_1002693A4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v18 = 0;
      char v10 = (char *)*((void *)this + 1);
      if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!result) {
          return result;
        }
        unsigned int v11 = v18;
      }
      else
      {
        unsigned int v11 = *v10;
        *((void *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (BOOL v12 = ((1 << v11) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0)) {
          sub_101A56568();
        }
        *(_DWORD *)(a1 + 20) |= 1u;
        *(_DWORD *)(a1 + 8) = v11;
      }
      uint64_t v14 = (unsigned char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        int v9 = v14 + 1;
        *((void *)this + 1) = v9;
LABEL_34:
        unsigned int v19 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!result) {
            return result;
          }
          unsigned int v15 = v19;
          char v16 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v15 = *v9;
          char v16 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v16;
        }
        *(unsigned char *)(a1 + 12) = v15 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v16 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_1002695A4(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(unsigned __int8 *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_100269610(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        unsigned int v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 20);
      }
      else
      {
        unsigned int v4 = 2;
      }
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      uint64_t result = v4 + 2;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100269688(uint64_t a1, void *lpsrc)
{
  sub_1002653BC(a1, (uint64_t)lpsrc);
}

void sub_100269710(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_1002653BC(a1, a2);
  }
}

uint64_t sub_10026977C()
{
  return 1;
}

void *sub_100269784@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.SpectatingMotionUpdate");
}

void sub_100269794(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1B58;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002697B4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1B58;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_100269808()
{
}

uint64_t sub_10026985C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v33 = 0;
        unint64_t v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 < *((void *)this + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)this + 1) = v8 + 1;
LABEL_29:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v17 = ((1 << v9) & 0x76B6) == 0) : (BOOL v17 = 1), !v17))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              sub_101A56594();
            }
            *(_DWORD *)(a1 + 24) |= 1u;
            *(_DWORD *)(a1 + 8) = v9;
          }
          unsigned int v19 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v19 < v10 && *v19 == 16)
          {
            int v13 = v19 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_43;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
        if (result)
        {
          unsigned int v9 = v33;
          goto LABEL_29;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        int v13 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_43:
        unsigned int v33 = 0;
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v20 = v33;
          int v21 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v20 = *v13;
          int v21 = v13 + 1;
          *((void *)this + 1) = v21;
        }
        *(unsigned char *)(a1 + 12) = v20 != 0;
        *(_DWORD *)(a1 + 24) |= 2u;
        if ((unint64_t)v21 >= v10 || *v21 != 24) {
          continue;
        }
        unsigned int v11 = v21 + 1;
        *((void *)this + 1) = v11;
LABEL_51:
        unsigned int v33 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v22 = v33;
          uint64_t v23 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v22 = *v11;
          uint64_t v23 = v11 + 1;
          *((void *)this + 1) = v23;
        }
        *(unsigned char *)(a1 + 13) = v22 != 0;
        *(_DWORD *)(a1 + 24) |= 4u;
        if ((unint64_t)v23 >= v10 || *v23 != 32) {
          continue;
        }
        uint64_t v14 = v23 + 1;
        *((void *)this + 1) = v14;
LABEL_59:
        unsigned int v33 = 0;
        if ((unint64_t)v14 >= v10 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v24 = v33;
          int v25 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v24 = *v14;
          int v25 = v14 + 1;
          *((void *)this + 1) = v25;
        }
        *(unsigned char *)(a1 + 14) = v24 != 0;
        *(_DWORD *)(a1 + 24) |= 8u;
        if ((unint64_t)v25 >= v10 || *v25 != 40) {
          continue;
        }
        BOOL v12 = v25 + 1;
        *((void *)this + 1) = v12;
LABEL_67:
        unsigned int v33 = 0;
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v26 = v33;
          int v27 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v26 = *v12;
          int v27 = v12 + 1;
          *((void *)this + 1) = v27;
        }
        *(unsigned char *)(a1 + 15) = v26 != 0;
        *(_DWORD *)(a1 + 24) |= 0x10u;
        if ((unint64_t)v27 >= v10 || *v27 != 48) {
          continue;
        }
        unsigned int v15 = v27 + 1;
        *((void *)this + 1) = v15;
LABEL_75:
        unsigned int v33 = 0;
        if ((unint64_t)v15 >= v10 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v28 = v33;
          uint64_t v29 = (unsigned char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v28 = *v15;
          uint64_t v29 = v15 + 1;
          *((void *)this + 1) = v29;
        }
        *(unsigned char *)(a1 + 16) = v28 != 0;
        *(_DWORD *)(a1 + 24) |= 0x20u;
        if ((unint64_t)v29 >= v10 || *v29 != 56) {
          continue;
        }
        char v16 = v29 + 1;
        *((void *)this + 1) = v16;
LABEL_83:
        unsigned int v33 = 0;
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v33);
          if (!result) {
            return result;
          }
          unsigned int v30 = v33;
          int v31 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          unsigned int v30 = *v16;
          int v31 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v31;
        }
        *(unsigned char *)(a1 + 17) = v30 != 0;
        *(_DWORD *)(a1 + 24) |= 0x40u;
        if (v31 != (unsigned __int8 *)v10 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10)) {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_51;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_59;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        BOOL v12 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_67;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v15 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_75;
      case 7u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        char v16 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_83;
      default:
        int v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t sub_100269D18(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 12), a2, a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 13), a2, a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 14), a2, a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(unsigned __int8 *)(v5 + 16), a2, a4);
    if ((*(_DWORD *)(v5 + 24) & 0x40) == 0) {
      return result;
    }
    goto LABEL_15;
  }
LABEL_13:
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned __int8 *)(v5 + 15), a2, a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 0x20) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((v6 & 0x40) == 0) {
    return result;
  }
LABEL_15:
  int v7 = *(unsigned __int8 *)(v5 + 17);

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v7, a2, a4);
}

uint64_t sub_100269E14(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 24);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 24))
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        unsigned int v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        unsigned int v4 = 2;
      }
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      v4 += 2;
    }
    if ((v3 & 4) != 0) {
      v4 += 2;
    }
    if ((v3 & 8) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x10) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x20) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x40) != 0) {
      uint64_t result = v4 + 2;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

void sub_100269EC8(uint64_t a1, void *lpsrc)
{
  sub_1002654AC(a1, (uint64_t)lpsrc);
}

void sub_100269F50(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_1002654AC(a1, a2);
  }
}

uint64_t sub_100269FBC()
{
  return 1;
}

void *sub_100269FC4@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.EnabledStateUpdate");
}

void sub_100269FD4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1BD0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100269FF4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1BD0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026A048()
{
}

uint64_t sub_10026A0A0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v18 = 0;
      unint64_t v10 = (char *)*((void *)this + 1);
      if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!result) {
          return result;
        }
        unsigned int v11 = v18;
      }
      else
      {
        unsigned int v11 = *v10;
        *((void *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (BOOL v12 = ((1 << v11) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0)) {
          sub_101A565C0();
        }
        *(_DWORD *)(a1 + 20) |= 1u;
        *(_DWORD *)(a1 + 8) = v11;
      }
      uint64_t v14 = (unsigned char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        unsigned int v9 = v14 + 1;
        *((void *)this + 1) = v9;
LABEL_34:
        unsigned int v19 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!result) {
            return result;
          }
          unsigned int v15 = v19;
          char v16 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }
        else
        {
          unsigned int v15 = *v9;
          char v16 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v16;
        }
        *(unsigned char *)(a1 + 12) = v15 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v16 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_10026A2A0(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    int v7 = *(unsigned __int8 *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_10026A30C(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if (*(unsigned char *)(a1 + 20))
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        unsigned int v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 20);
      }
      else
      {
        unsigned int v4 = 2;
      }
    }
    else
    {
      unsigned int v4 = 0;
    }
    if ((v3 & 2) != 0) {
      uint64_t result = v4 + 2;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_10026A384(uint64_t a1, void *lpsrc)
{
  sub_100265640(a1, (uint64_t)lpsrc);
}

uint64_t sub_10026A40C()
{
  return 1;
}

void *sub_10026A414@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.ScreenStateUpdate");
}

void sub_10026A424(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1C48;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026A444(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1C48;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026A498()
{
}

uint64_t sub_10026A4F0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v12 = 0;
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!result) {
          return result;
        }
        unsigned int v8 = v12;
      }
      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }
      if (v8 - 31 < 0x19 || (v8 <= 0xE ? (BOOL v9 = ((1 << v8) & 0x76B6) == 0) : (BOOL v9 = 1), !v9))
      {
        if (v8 - 31 >= 0x19 && (v8 > 0xE || ((1 << v8) & 0x76B6) == 0)) {
          sub_101A565EC();
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_10026A658(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_10026A674(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    unsigned int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v4 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_10026A6D0(uint64_t a1, void *lpsrc)
{
  sub_100265730(a1, (uint64_t)lpsrc);
}

uint64_t sub_10026A758()
{
  return 1;
}

void *sub_10026A760@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.CloudBackupExport");
}

void sub_10026A770(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1CC0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026A790(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1CC0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026A7E4()
{
}

uint64_t sub_10026A83C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
      }
      else
      {
        unint64_t TagFallback = *v5;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v5 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v12 = 0;
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!result) {
          return result;
        }
        unsigned int v8 = v12;
      }
      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }
      if (v8 - 31 < 0x19 || (v8 <= 0xE ? (BOOL v9 = ((1 << v8) & 0x76B6) == 0) : (BOOL v9 = 1), !v9))
      {
        if (v8 - 31 >= 0x19 && (v8 > 0xE || ((1 << v8) & 0x76B6) == 0)) {
          sub_101A56618();
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t sub_10026A9A4(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(result + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  }
  return result;
}

uint64_t sub_10026A9C0(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    unsigned int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v4 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_10026AA1C(uint64_t a1, void *lpsrc)
{
  sub_100265800(a1, (uint64_t)lpsrc);
}

uint64_t sub_10026AAA4()
{
  return 1;
}

void *sub_10026AAAC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.CloudBackupImport");
}

uint64_t sub_10026AABC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_1022A1D38;
  *(_DWORD *)(a1 + 24) = 0;
  sub_10026AB1C(a1, a2);
  return a1;
}

void sub_10026AB08(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_10026AB1C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v5 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v5;
      int v4 = *(_DWORD *)(a2 + 24);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 2u;
      *(void *)(a1 + 8) = v6;
    }
  }
}

void sub_10026ABC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_10026ABE4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1D38;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026AC04(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1D38;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026AC58()
{
}

uint64_t sub_10026ACA8(uint64_t result)
{
  if (*(unsigned char *)(result + 24))
  {
    *(_DWORD *)(result + 16) = 0;
    *(void *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_10026ACC0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unsigned int *)(a1 + 16);
  uint64_t v6 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        unint64_t TagFallback = *v7;
        *((_DWORD *)this + 8) = TagFallback;
        *((void *)this + 1) = v7 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v12 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (!result) {
          return result;
        }
        int v13 = (unsigned char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }
      else
      {
        *int v5 = *v12;
        int v13 = v12 + 1;
        *((void *)this + 1) = v13;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        unsigned int v11 = v13 + 1;
        *((void *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
          if (!result) {
            return result;
          }
          uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }
        else
        {
          *uint64_t v6 = *v11;
          uint64_t v14 = (unsigned __int8 *)(v11 + 1);
          *((void *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 24) |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = TagFallback & 7;
    }
LABEL_16:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_10026AE60(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 8);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  }
  return result;
}

uint64_t sub_10026AECC(uint64_t a1, unint64_t a2)
{
  char v3 = *(unsigned char *)(a1 + 24);
  if (v3)
  {
    if ((*(unsigned char *)(a1 + 24) & 1) == 0)
    {
      uint64_t v4 = 0;
      if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v5 < 0x80)
    {
      uint64_t v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    if ((*(_DWORD *)(a1 + 24) & 2) != 0) {
LABEL_10:
    }
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
  }
  else
  {
    uint64_t v4 = 0;
  }
LABEL_11:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_10026AF4C(uint64_t a1, void *lpsrc)
{
  sub_10026AB1C(a1, (uint64_t)lpsrc);
}

uint64_t sub_10026AFD4()
{
  return 1;
}

void *sub_10026AFDC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.ChannelAndCount");
}

void sub_10026AFEC(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8 * v4);
      int v6 = a1[5];
      uint64_t v7 = (int)a1[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v6 + 1);
          int v6 = a1[5];
        }
        a1[5] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a1 + 1);
      a1[4] = v7 + 1;
      sub_10026AB1C(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 16));
  }
  if (*(unsigned char *)(a2 + 40))
  {
    unsigned int v9 = *(_DWORD *)(a2 + 32);
    if (v9 >= 3) {
      sub_101A56670();
    }
    a1[10] |= 1u;
    a1[8] = v9;
  }
}

void sub_10026B174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_10026B18C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1022A1DB0;
  sub_10016B2E8(a1 + 1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_10026B1E8(uint64_t *a1)
{
  sub_10026B18C(a1);

  operator delete();
}

void sub_10026B220()
{
}

uint64_t sub_10026B278(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    *(_DWORD *)(a1 + 32) = 0;
  }
  uint64_t result = sub_10026DEDC(a1 + 8);
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_10026B2B0(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v6 = (char *)*((void *)this + 1);
        if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v6;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v6 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_16;
        }
        unsigned int v26 = 0;
        unsigned int v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v26);
          if (!result) {
            return result;
          }
          unsigned int v10 = v26;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)this + 1) = v9 + 1;
        }
        if (v10 <= 2)
        {
          a1[10] |= 1u;
          a1[8] = v10;
        }
        unsigned int v12 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v12 < *((void *)this + 2) && *v12 == 18) {
          goto LABEL_25;
        }
      }
      if (TagFallback >> 3 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_16;
      }
      while (1)
      {
        int v13 = a1[5];
        uint64_t v14 = a1[4];
        if ((int)v14 >= v13)
        {
          if (v13 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v13 + 1);
            int v13 = a1[5];
          }
          a1[5] = v13 + 1;
          operator new();
        }
        uint64_t v15 = *((void *)a1 + 1);
        a1[4] = v14 + 1;
        uint64_t v16 = *(void *)(v15 + 8 * v14);
        unsigned int v27 = 0;
        BOOL v17 = (char *)*((void *)this + 1);
        if ((unint64_t)v17 >= *((void *)this + 2) || *v17 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v27))return 0; {
        }
          }
        else
        {
          unsigned int v27 = *v17;
          *((void *)this + 1) = v17 + 1;
        }
        int v18 = *((_DWORD *)this + 14);
        int v19 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v18 + 1;
        if (v18 >= v19) {
          return 0;
        }
        int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v27);
        if (!sub_10026ACC0(v16, this, v21) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
        int v22 = *((_DWORD *)this + 14);
        BOOL v23 = __OFSUB__(v22, 1);
        int v24 = v22 - 1;
        if (v24 < 0 == v23) {
          *((_DWORD *)this + 14) = v24;
        }
        unsigned int v12 = (unsigned char *)*((void *)this + 1);
        int v25 = (unsigned char *)*((void *)this + 2);
        if (v12 >= v25 || *v12 != 18) {
          break;
        }
LABEL_25:
        *((void *)this + 1) = v12 + 1;
      }
      if (v12 == v25 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
    int v8 = TagFallback & 7;
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
  }
    }
}

uint64_t sub_10026B570(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(unsigned char *)(result + 40)) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 32), (int)a2, a4);
  }
  if (*(int *)(v5 + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_10026B5E8(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
    if ((v4 & 0x80000000) != 0)
    {
      int v3 = 11;
    }
    else if (v4 >= 0x80)
    {
      int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2) + 1;
    }
    else
    {
      int v3 = 2;
    }
  }
  else
  {
    int v3 = 0;
  }
  int v5 = *(_DWORD *)(a1 + 16);
  uint64_t v6 = (v5 + v3);
  if (v5 >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10026AECC(*(void *)(*(void *)(a1 + 8) + 8 * v7), a2);
      int v9 = (int)v8;
      if (v8 >= 0x80) {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
      }
      else {
        int v10 = 1;
      }
      uint64_t v6 = (v9 + v6 + v10);
      ++v7;
    }
    while (v7 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 36) = v6;
  return v6;
}

void sub_10026B6A4(_DWORD *a1, void *lpsrc)
{
  sub_10026AFEC(a1, (uint64_t)lpsrc);
}

void sub_10026B72C(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 != a1)
  {
    (*(void (**)(_DWORD *))(*(void *)a1 + 32))(a1);
    sub_10026AFEC(a1, a2);
  }
}

uint64_t sub_10026B798()
{
  return 1;
}

void *sub_10026B7A0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.WifiHistogram");
}

void sub_10026B7B0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 24);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 24))
    {
      unsigned int v5 = *(_DWORD *)(a2 + 16);
      if (v5 >= 3) {
        sub_101A5669C();
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v5;
      int v4 = *(_DWORD *)(a2 + 24);
    }
    if ((v4 & 2) != 0)
    {
      *(_DWORD *)(a1 + 24) |= 2u;
      uint64_t v6 = *(_DWORD **)(a1 + 8);
      if (!v6) {
        operator new();
      }
      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_102489B10 + 8);
      }
      sub_100247DCC(v6, v7);
    }
  }
}

void sub_10026B8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_10026B8DC(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_1022A1E28;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_102489B10 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_10026B96C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_10026B8DC(a1);

  operator delete();
}

void sub_10026B9A4()
{
}

uint64_t sub_10026B9FC(uint64_t result)
{
  uint64_t v1 = result;
  char v2 = *(unsigned char *)(result + 24);
  if (v2)
  {
    *(_DWORD *)(result + 16) = 1;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        uint64_t result = sub_10026DEDC(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
      }
    }
  }
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t sub_10026BA48(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v5;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_15;
        }
        unsigned int v21 = 0;
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v21);
          if (!result) {
            return result;
          }
          unsigned int v9 = v21;
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)this + 1) = v8 + 1;
        }
        if (v9 <= 2)
        {
          *(_DWORD *)(a1 + 24) |= 1u;
          *(_DWORD *)(a1 + 16) = v9;
        }
        unsigned int v11 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v11 < *((void *)this + 2) && *v11 == 18)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_25;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_15;
      }
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        break;
      }
LABEL_15:
      if (v7 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
    }
      }
LABEL_25:
    *(_DWORD *)(a1 + 24) |= 2u;
    unsigned int v12 = *(int **)(a1 + 8);
    if (!v12) {
      operator new();
    }
    unsigned int v22 = 0;
    int v13 = (char *)*((void *)this + 1);
    if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22)) {
        return 0;
      }
    }
    else
    {
      unsigned int v22 = *v13;
      *((void *)this + 1) = v13 + 1;
    }
    int v14 = *((_DWORD *)this + 14);
    int v15 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v14 + 1;
    if (v14 >= v15) {
      return 0;
    }
    int v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v22);
    if (!sub_100248064(v12, this, v17) || !*((unsigned char *)this + 36)) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v16);
    int v18 = *((_DWORD *)this + 14);
    BOOL v19 = __OFSUB__(v18, 1);
    int v20 = v18 - 1;
    if (v20 < 0 == v19) {
      *((_DWORD *)this + 14) = v20;
    }
    if (*((void *)this + 1) == *((void *)this + 2)
      && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
    {
      *((_DWORD *)this + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)this + 36) = 1;
      return result;
    }
  }
}

uint64_t sub_10026BCA8(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), (int)a2, a4);
    if ((*(_DWORD *)(v5 + 24) & 2) == 0) {
      return result;
    }
  }
  else if ((v6 & 2) == 0)
  {
    return result;
  }
  uint64_t v7 = *(void *)(v5 + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_102489B10 + 8);
  }

  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
}

uint64_t sub_10026BD28(uint64_t a1, unsigned int a2)
{
  char v3 = *(unsigned char *)(a1 + 24);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v4 = 11;
        if ((v3 & 2) == 0) {
          goto LABEL_19;
        }
      }
      else if (v5 >= 0x80)
      {
        uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 24) & 2) == 0) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v4 = 2;
        if ((v3 & 2) == 0) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      uint64_t v4 = 0;
      if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
        goto LABEL_19;
      }
    }
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_102489B10 + 8);
    }
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002482FC(v6, a2);
    int v9 = (int)v7;
    if (v7 >= 0x80) {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, v8);
    }
    else {
      int v10 = 1;
    }
    uint64_t v4 = (v4 + v9 + v10 + 1);
  }
  else
  {
    uint64_t v4 = 0;
  }
LABEL_19:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_10026BDF0(uint64_t a1, void *lpsrc)
{
  sub_10026B7B0(a1, (uint64_t)lpsrc);
}

void sub_10026BE78(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_10026B7B0(a1, a2);
  }
}

uint64_t sub_10026BEE4()
{
  return 1;
}

void *sub_10026BEEC@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.AnchorAppearanceConfiguration");
}

void sub_10026BEFC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 32);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 32))
    {
      unsigned int v5 = *(_DWORD *)(a2 + 24);
      if (v5 >= 3) {
        sub_101A566C8();
      }
      *(_DWORD *)(a1 + 32) |= 1u;
      *(_DWORD *)(a1 + 24) = v5;
      int v4 = *(_DWORD *)(a2 + 32);
    }
    if ((v4 & 2) != 0)
    {
      *(_DWORD *)(a1 + 32) |= 2u;
      uint64_t v6 = *(_DWORD **)(a1 + 8);
      if (!v6) {
        operator new();
      }
      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_102489B18 + 8);
      }
      sub_1002492F4(v6, v7);
      int v4 = *(_DWORD *)(a2 + 32);
    }
    if ((v4 & 4) != 0)
    {
      unsigned int v8 = *(const std::string **)(a2 + 16);
      *(_DWORD *)(a1 + 32) |= 4u;
      int v9 = *(std::string **)(a1 + 16);
      if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_10026C068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void *sub_10026C080(void *result)
{
  uint64_t v1 = result[2];
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  if ((void *)qword_102489B18 != result)
  {
    uint64_t result = (void *)result[1];
    if (result)
    {
      char v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

void sub_10026C134(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1EA0;
  sub_10026C080(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026C188(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1EA0;
  sub_10026C080(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026C1F0()
{
}

uint64_t sub_10026C254(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(unsigned char *)(result + 32);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 24) = 2;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        uint64_t result = sub_10026DEDC(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
        int v2 = *(_DWORD *)(v1 + 32);
      }
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 16);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t sub_10026C2DC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v5;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_18;
        }
        unsigned int v23 = 0;
        int v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23);
          if (!result) {
            return result;
          }
          unsigned int v10 = v23;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)this + 1) = v9 + 1;
        }
        if (v10 <= 2)
        {
          *(_DWORD *)(a1 + 32) |= 1u;
          *(_DWORD *)(a1 + 24) = v10;
        }
        unsigned int v12 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v12 < *((void *)this + 2) && *v12 == 18)
        {
          *((void *)this + 1) = v12 + 1;
          goto LABEL_28;
        }
      }
      if (v7 == 2) {
        break;
      }
      if (v7 == 3)
      {
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_42;
        }
      }
      else
      {
        int v8 = TagFallback & 7;
      }
LABEL_18:
      if (v8 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
    }
      }
    int v8 = TagFallback & 7;
    if (v8 != 2) {
      goto LABEL_18;
    }
LABEL_28:
    *(_DWORD *)(a1 + 32) |= 2u;
    int v13 = *(int **)(a1 + 8);
    if (!v13) {
      operator new();
    }
    unsigned int v24 = 0;
    int v14 = (char *)*((void *)this + 1);
    if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24)) {
        return 0;
      }
    }
    else
    {
      unsigned int v24 = *v14;
      *((void *)this + 1) = v14 + 1;
    }
    int v15 = *((_DWORD *)this + 14);
    int v16 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v15 + 1;
    if (v15 >= v16) {
      return 0;
    }
    int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v24);
    if (!sub_10024958C(v13, this, v18) || !*((unsigned char *)this + 36)) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
    int v19 = *((_DWORD *)this + 14);
    BOOL v20 = __OFSUB__(v19, 1);
    int v21 = v19 - 1;
    if (v21 < 0 == v20) {
      *((_DWORD *)this + 14) = v21;
    }
    unsigned int v22 = (unsigned char *)*((void *)this + 1);
    if ((unint64_t)v22 < *((void *)this + 2) && *v22 == 26)
    {
      *((void *)this + 1) = v22 + 1;
LABEL_42:
      *(_DWORD *)(a1 + 32) |= 4u;
      if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)this + 36) = 1;
        return result;
      }
    }
  }
}

uint64_t sub_10026C5D0(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 24), (int)a2, a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t v7 = *(void *)(v5 + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_102489B18 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  if ((*(_DWORD *)(v5 + 32) & 4) != 0)
  {
LABEL_9:
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return result;
}

uint64_t sub_10026C66C(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_29;
  }
  if ((*(unsigned char *)(a1 + 32) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
      goto LABEL_19;
    }
LABEL_13:
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_102489B18 + 8);
    }
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100249824(v6, a2);
    int v8 = (int)v7;
    if (v7 >= 0x80) {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
    }
    else {
      int v9 = 1;
    }
    uint64_t v4 = (v4 + v8 + v9 + 1);
    int v3 = *(_DWORD *)(a1 + 32);
    goto LABEL_19;
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v4 = 11;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 32);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
      goto LABEL_13;
    }
    uint64_t v4 = 2;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_19:
  if ((v3 & 4) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(unsigned __int8 *)(v10 + 23);
    char v12 = v11;
    uint64_t v13 = *(void *)(v10 + 8);
    if ((v11 & 0x80u) == 0) {
      unint64_t v14 = *(unsigned __int8 *)(v10 + 23);
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14 >= 0x80)
    {
      int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14, a2);
      int v11 = *(unsigned __int8 *)(v10 + 23);
      uint64_t v13 = *(void *)(v10 + 8);
      char v12 = *(unsigned char *)(v10 + 23);
    }
    else
    {
      int v15 = 1;
    }
    if (v12 < 0) {
      int v11 = v13;
    }
    uint64_t v4 = (v4 + v15 + v11 + 1);
  }
LABEL_29:
  *(_DWORD *)(a1 + 28) = v4;
  return v4;
}

void sub_10026C78C(uint64_t a1, void *lpsrc)
{
  sub_10026BEFC(a1, (uint64_t)lpsrc);
}

void sub_10026C814(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_10026BEFC(a1, a2);
  }
}

uint64_t sub_10026C880()
{
  return 1;
}

void *sub_10026C888@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.AnchorValueStatisticsConfiguration");
}

uint64_t sub_10026C898(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1022A1F18;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  sub_10026C900(a1, a2);
  return a1;
}

void sub_10026C8EC(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_10026C900(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 48);
  if (!(_BYTE)v4) {
    return;
  }
  if (*(unsigned char *)(a2 + 48))
  {
    unsigned int v5 = *(_DWORD *)(a2 + 40);
    if (v5 >= 3) {
      sub_101A566F4();
    }
    *(_DWORD *)(a1 + 48) |= 1u;
    *(_DWORD *)(a1 + 40) = v5;
    int v4 = *(_DWORD *)(a2 + 48);
  }
  if ((v4 & 2) == 0)
  {
    if ((v4 & 4) == 0) {
      goto LABEL_9;
    }
LABEL_13:
    *(_DWORD *)(a1 + 48) |= 4u;
    uint64_t v7 = *(_DWORD **)(a1 + 16);
    if (!v7) {
      operator new();
    }
    uint64_t v8 = *(void *)(a2 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_102489B20 + 16);
    }
    sub_10026AFEC(v7, v8);
    int v4 = *(_DWORD *)(a2 + 48);
    if ((v4 & 8) == 0)
    {
LABEL_10:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_23;
    }
    goto LABEL_18;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 48) |= 2u;
  *(void *)(a1 + 8) = v6;
  int v4 = *(_DWORD *)(a2 + 48);
  if ((v4 & 4) != 0) {
    goto LABEL_13;
  }
LABEL_9:
  if ((v4 & 8) == 0) {
    goto LABEL_10;
  }
LABEL_18:
  *(_DWORD *)(a1 + 48) |= 8u;
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9) {
    operator new();
  }
  uint64_t v10 = *(void *)(a2 + 24);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_102489B20 + 24);
  }
  sub_10026B7B0(v9, v10);
  if ((*(_DWORD *)(a2 + 48) & 0x10) != 0)
  {
LABEL_23:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    uint64_t v11 = *(void *)(a1 + 32);
    if (!v11) {
      operator new();
    }
    uint64_t v12 = *(void *)(a2 + 32);
    if (!v12) {
      uint64_t v12 = *(void *)(qword_102489B20 + 32);
    }
    sub_10026BEFC(v11, v12);
  }
}

void sub_10026CB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void *sub_10026CB64(void *result)
{
  if ((void *)qword_102489B20 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[2];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[3];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t result = (void *)v1[4];
    if (result)
    {
      int v4 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v4();
    }
  }
  return result;
}

void sub_10026CC30(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1F18;
  sub_10026CB64(a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026CC84(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1F18;
  sub_10026CB64(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026CCEC()
{
}

uint64_t sub_10026CD44(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(unsigned char *)(result + 48);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 40) = 0;
    *(void *)(result + 8) = 0;
    if ((v2 & 4) != 0)
    {
      uint64_t v3 = *(void *)(result + 16);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 40)) {
          *(_DWORD *)(v3 + 32) = 0;
        }
        uint64_t result = sub_10026DEDC(v3 + 8);
        *(_DWORD *)(v3 + 40) = 0;
        int v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 8) != 0)
    {
      uint64_t result = *(void *)(v1 + 24);
      if (result)
      {
        uint64_t result = sub_10026B9FC(result);
        int v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      uint64_t result = *(void *)(v1 + 32);
      if (result) {
        uint64_t result = sub_10026C254(result);
      }
    }
  }
  *(_DWORD *)(v1 + 48) = 0;
  return result;
}

uint64_t sub_10026CDC4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    unsigned int v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 < *((void *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      unint64_t TagFallback = *v5;
      *((_DWORD *)this + 8) = TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_6;
    }
    unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        v41[0] = 0;
        uint64_t v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41);
          if (!result) {
            return result;
          }
          unsigned int v9 = v41[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)this + 1) = v8 + 1;
        }
        if (v9 <= 2)
        {
          *(_DWORD *)(a1 + 48) |= 1u;
          *(_DWORD *)(a1 + 40) = v9;
        }
        uint64_t v12 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v12 < *((void *)this + 2) && *v12 == 17)
        {
          *((void *)this + 1) = v12 + 1;
          goto LABEL_29;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_19;
        }
LABEL_29:
        *(void *)uint64_t v41 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v41) & 1) == 0)return 0; {
        *(void *)(a1 + 8) = *(void *)v41;
        }
        int v10 = *(_DWORD *)(a1 + 48) | 2;
        *(_DWORD *)(a1 + 48) = v10;
        uint64_t v13 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v13 >= *((void *)this + 2) || *v13 != 34) {
          continue;
        }
        *((void *)this + 1) = v13 + 1;
LABEL_33:
        *(_DWORD *)(a1 + 48) = v10 | 4;
        unint64_t v14 = *(int **)(a1 + 16);
        if (!v14) {
          operator new();
        }
        v41[0] = 0;
        int v15 = (char *)*((void *)this + 1);
        if ((unint64_t)v15 >= *((void *)this + 2) || *v15 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0; {
        }
          }
        else
        {
          v41[0] = *v15;
          *((void *)this + 1) = v15 + 1;
        }
        int v16 = *((_DWORD *)this + 14);
        int v17 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v16 + 1;
        if (v16 >= v17) {
          return 0;
        }
        int v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_10026B2B0(v14, this, v19) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v18);
        int v20 = *((_DWORD *)this + 14);
        BOOL v21 = __OFSUB__(v20, 1);
        int v22 = v20 - 1;
        if (v22 < 0 == v21) {
          *((_DWORD *)this + 14) = v22;
        }
        unsigned int v23 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v23 >= *((void *)this + 2) || *v23 != 42) {
          continue;
        }
        *((void *)this + 1) = v23 + 1;
LABEL_47:
        *(_DWORD *)(a1 + 48) |= 8u;
        uint64_t v24 = *(void *)(a1 + 24);
        if (!v24) {
          operator new();
        }
        v41[0] = 0;
        int v25 = (char *)*((void *)this + 1);
        if ((unint64_t)v25 >= *((void *)this + 2) || *v25 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0; {
        }
          }
        else
        {
          v41[0] = *v25;
          *((void *)this + 1) = v25 + 1;
        }
        int v26 = *((_DWORD *)this + 14);
        int v27 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v26 + 1;
        if (v26 >= v27) {
          return 0;
        }
        int v28 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_10026BA48(v24, this, v29) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v28);
        int v30 = *((_DWORD *)this + 14);
        BOOL v21 = __OFSUB__(v30, 1);
        int v31 = v30 - 1;
        if (v31 < 0 == v21) {
          *((_DWORD *)this + 14) = v31;
        }
        uint64_t v32 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v32 >= *((void *)this + 2) || *v32 != 50) {
          continue;
        }
        *((void *)this + 1) = v32 + 1;
LABEL_61:
        *(_DWORD *)(a1 + 48) |= 0x10u;
        uint64_t v33 = *(void *)(a1 + 32);
        if (!v33) {
          operator new();
        }
        v41[0] = 0;
        int v34 = (char *)*((void *)this + 1);
        if ((unint64_t)v34 >= *((void *)this + 2) || *v34 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0; {
        }
          }
        else
        {
          v41[0] = *v34;
          *((void *)this + 1) = v34 + 1;
        }
        int v35 = *((_DWORD *)this + 14);
        int v36 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v35 + 1;
        if (v35 >= v36) {
          return 0;
        }
        int v37 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_10026C2DC(v33, this, v38) || !*((unsigned char *)this + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v37);
        int v39 = *((_DWORD *)this + 14);
        BOOL v21 = __OFSUB__(v39, 1);
        int v40 = v39 - 1;
        if (v40 < 0 == v21) {
          *((_DWORD *)this + 14) = v40;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)this + 36) = 1;
          return result;
        }
        break;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
        int v10 = *(_DWORD *)(a1 + 48);
        goto LABEL_33;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_47;
        }
        goto LABEL_19;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
        goto LABEL_61;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t sub_10026D318(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 48);
  if (v6)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 40), (int)a2, a4);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (int)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v7 = *(void *)(v5 + 16);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_102489B20 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      return result;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v8 = *(void *)(v5 + 24);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_102489B20 + 24);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  if ((*(_DWORD *)(v5 + 48) & 0x10) != 0)
  {
LABEL_15:
    uint64_t v9 = *(void *)(v5 + 32);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_102489B20 + 32);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  }
  return result;
}

uint64_t sub_10026D40C(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    uint64_t v5 = 0;
    goto LABEL_35;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
    if ((v6 & 0x80000000) != 0)
    {
      unsigned int v4 = 11;
    }
    else if (v6 >= 0x80)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 48);
    }
    else
    {
      unsigned int v4 = 2;
    }
  }
  else
  {
    unsigned int v4 = 0;
  }
  if ((v3 & 2) != 0) {
    uint64_t v5 = v4 + 9;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((v3 & 4) != 0)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_102489B20 + 16);
    }
    uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10026B5E8(v7, a2);
    int v9 = (int)v8;
    if (v8 >= 0x80) {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
    }
    else {
      int v10 = 1;
    }
    uint64_t v5 = (v5 + v9 + v10 + 1);
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 8) == 0)
    {
LABEL_15:
      if ((v3 & 0x10) == 0) {
        goto LABEL_35;
      }
      goto LABEL_29;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_15;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (!v11) {
    uint64_t v11 = *(void *)(qword_102489B20 + 24);
  }
  uint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10026BD28(v11, a2);
  int v13 = (int)v12;
  if (v12 >= 0x80) {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2);
  }
  else {
    int v14 = 1;
  }
  uint64_t v5 = (v5 + v13 + v14 + 1);
  if ((*(_DWORD *)(a1 + 48) & 0x10) != 0)
  {
LABEL_29:
    uint64_t v15 = *(void *)(a1 + 32);
    if (!v15) {
      uint64_t v15 = *(void *)(qword_102489B20 + 32);
    }
    int v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10026C66C(v15, a2);
    int v18 = (int)v16;
    if (v16 >= 0x80) {
      int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, v17);
    }
    else {
      int v19 = 1;
    }
    uint64_t v5 = (v5 + v18 + v19 + 1);
  }
LABEL_35:
  *(_DWORD *)(a1 + 44) = v5;
  return v5;
}

void sub_10026D570(uint64_t a1, void *lpsrc)
{
  sub_10026C900(a1, (uint64_t)lpsrc);
}

void sub_10026D5F8(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_10026C900(a1, a2);
  }
}

uint64_t sub_10026D664()
{
  return 1;
}

void *sub_10026D66C@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.Configuration");
}

void *sub_10026D67C(void *a1, uint64_t a2)
{
  *a1 = off_1022A1F90;
  a1[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  a1[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  a1[3] = 0;
  sub_10026D6E0((uint64_t)a1, a2);
  return a1;
}

void sub_10026D6CC(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_10026D6E0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *(unsigned char *)(a2 + 28);
  if ((_BYTE)v4)
  {
    if (*(unsigned char *)(a2 + 28))
    {
      uint64_t v5 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 28) |= 1u;
      int v6 = *(std::string **)(a1 + 8);
      if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v6, v5);
      int v4 = *(_DWORD *)(a2 + 28);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v7 = *(const std::string **)(a2 + 16);
      *(_DWORD *)(a1 + 28) |= 2u;
      uint64_t v8 = *(std::string **)(a1 + 16);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v8, v7);
    }
  }
}

void sub_10026D804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_10026D820(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1F90;
  sub_100258038((uint64_t)a1);

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10026D874(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1022A1F90;
  sub_100258038((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);

  operator delete();
}

void sub_10026D8DC()
{
}

uint64_t sub_10026D930(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    if (*(unsigned char *)(result + 28))
    {
      uint64_t v1 = *(void *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(unsigned char **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v1 = 0;
          *(unsigned char *)(v1 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(result + 28) & 2) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_10026D9AC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          unint64_t TagFallback = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          unint64_t TagFallback = *v5;
          *((_DWORD *)this + 8) = TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_25;
        }
        *(_DWORD *)(a1 + 28) |= 1u;
        if (*(_UNKNOWN **)(a1 + 8) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v9 = (unsigned char *)*((void *)this + 1);
        if ((unint64_t)v9 < *((void *)this + 2) && *v9 == 18)
        {
          *((void *)this + 1) = v9 + 1;
          goto LABEL_17;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_25;
      }
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        break;
      }
LABEL_25:
      if (v7 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback, a3) & 1) == 0)return 0; {
    }
      }
LABEL_17:
    *(_DWORD *)(a1 + 28) |= 2u;
    if (*(_UNKNOWN **)(a1 + 16) == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
    if (!result) {
      return result;
    }
  }
  while (*((void *)this + 1) != *((void *)this + 2)
       || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10));
  *((_DWORD *)this + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)this + 36) = 1;
  return result;
}

uint64_t sub_10026DB64(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 28);
  if (v2)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    int v2 = *(_DWORD *)(v1 + 28);
  }
  if ((v2 & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return result;
}

uint64_t sub_10026DBD0(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(unsigned char *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0;
    goto LABEL_24;
  }
  if ((*(unsigned char *)(a1 + 28) & 1) == 0)
  {
    uint64_t v4 = 0;
    if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
      goto LABEL_24;
    }
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v10 = v11 + 1;
    int v3 = *(_DWORD *)(a1 + 28);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 2;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    char v14 = v13;
    uint64_t v15 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16 >= 0x80)
    {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16, a2);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      uint64_t v15 = *(void *)(v12 + 8);
      char v14 = *(unsigned char *)(v12 + 23);
    }
    else
    {
      int v17 = 1;
    }
    if (v14 < 0) {
      int v13 = v15;
    }
    uint64_t v4 = (v4 + v17 + v13 + 1);
  }
LABEL_24:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

void sub_10026DCC4(uint64_t a1, void *lpsrc)
{
  sub_10026D6E0(a1, (uint64_t)lpsrc);
}

void sub_10026DD4C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    sub_10026D6E0(a1, a2);
  }
}

uint64_t sub_10026DDB8()
{
  return 1;
}

void *sub_10026DDC0@<X0>(void *a1@<X8>)
{
  return sub_100134750(a1, "CLMicroLocationProto.RapportDevice");
}

uint64_t sub_10026DDD0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t sub_10026DDD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_10026DDE0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_10026DDE8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t sub_10026DDF0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 188);
}

uint64_t sub_10026DDF8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10026DE00(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t sub_10026DE08(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t sub_10026DE10(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t sub_10026DE18(uint64_t a1)
{
  return *(unsigned int *)(a1 + 288);
}

uint64_t sub_10026DE20(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t sub_10026DE28(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_10026DE30(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 12);
  if (v2 < a2)
  {
    int v3 = 2 * v2;
    if (v3 <= a2) {
      int v3 = a2;
    }
    if (v3 <= 4) {
      int v3 = 4;
    }
    *(_DWORD *)(result + 12) = v3;
    operator new[]();
  }
  return result;
}

uint64_t sub_10026DEDC(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 8 * v2) + 32))(*(void *)(*(void *)v1 + 8 * v2));
      ++v2;
    }
    while (v2 < *(int *)(v1 + 8));
  }
  *(_DWORD *)(v1 + 8) = 0;
  return result;
}

uint64_t sub_10026DF4C(uint64_t result)
{
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v1 = 0;
    do
    {
      uint64_t v2 = *(void *)(*(void *)result + 8 * v1);
      if (*(char *)(v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v2 = 0;
        *(void *)(v2 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v2 = 0;
        *(unsigned char *)(v2 + 23) = 0;
      }
      ++v1;
    }
    while (v1 < *(int *)(result + 8));
  }
  *(_DWORD *)(result + 8) = 0;
  return result;
}

void sub_10026DF9C(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, *(_DWORD *)(a2 + 8) + *((_DWORD *)a1 + 2));
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)a2 + 8 * v4);
      int v6 = *((_DWORD *)a1 + 3);
      uint64_t v7 = *((int *)a1 + 2);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)a1 + 4))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, v6 + 1);
          int v6 = *((_DWORD *)a1 + 3);
        }
        *((_DWORD *)a1 + 3) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      *((_DWORD *)a1 + 2) = v7 + 1;
      sub_100244A38(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

uint64_t sub_10026E0AC(int *a1)
{
  if (a1[3] >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::Delete();
      ++v2;
    }
    while (v2 < a1[3]);
  }
  uint64_t result = *(void *)a1;
  if (*(void *)a1)
  {
    operator delete[]();
  }
  return result;
}

void sub_10026E12C(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, *(_DWORD *)(a2 + 8) + *((_DWORD *)a1 + 2));
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)a2 + 8 * v4);
      int v6 = *((_DWORD *)a1 + 3);
      uint64_t v7 = *((int *)a1 + 2);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)a1 + 4))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, v6 + 1);
          int v6 = *((_DWORD *)a1 + 3);
        }
        *((_DWORD *)a1 + 3) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      *((_DWORD *)a1 + 2) = v7 + 1;
      sub_1002452E0(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

void sub_10026E25C(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, *(_DWORD *)(a2 + 8) + *((_DWORD *)a1 + 2));
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)a2 + 8 * v4);
      int v6 = *((_DWORD *)a1 + 3);
      uint64_t v7 = *((int *)a1 + 2);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)a1 + 4))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, v6 + 1);
          int v6 = *((_DWORD *)a1 + 3);
        }
        *((_DWORD *)a1 + 3) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      *((_DWORD *)a1 + 2) = v7 + 1;
      sub_100246B38(*(void *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

char *sub_10026E398@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[31] < 0) {
    return (char *)sub_1000DC48C((unsigned char *)a2, *((void **)result + 1), *((void *)result + 2));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 16) = *((void *)result + 3);
  return result;
}

uint64_t sub_10026E3C4(uint64_t a1, char a2)
{
  *(void *)a1 = off_1022A2638;
  sub_100134750((void *)(a1 + 8), "No Name Given");
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = a1 + 56;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 64) = 0;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    v6[0] = 68289026;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"StateBase\"}", (uint8_t *)v6, 0x12u);
  }
  *(unsigned char *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1000DB264(a1 + 48, *(char **)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 80) = 0;
  return a1;
}

uint64_t sub_10026E520(uint64_t a1)
{
  *(void *)a1 = off_1022A2638;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    v5[0] = 68289026;
    v5[1] = 0;
    __int16 v6 = 2082;
    __int16 v7 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"~StateBase\"}", (uint8_t *)v5, 0x12u);
  }
  int v3 = *(char **)(a1 + 56);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1000DB264(a1 + 48, v3);
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  sub_1000DB264(a1 + 48, 0);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10026E66C(uint64_t a1)
{
  sub_10026E520(a1);

  operator delete();
}

void *sub_10026E6A4(void *a1)
{
  *a1 = &off_1022A2658;
  a1[4] = 0;
  a1[3] = 0;
  uint64_t v2 = a1 + 3;
  a1[2] = a1 + 3;
  int v3 = a1 + 2;
  sub_10026FA0C((uint64_t)(a1 + 2), 0);
  a1[4] = 0;
  a1[5] = 0;
  void *v3 = v2;
  void *v2 = 0;
  a1[1] = 0;
  a1[6] = 0;
  return a1;
}

void *sub_10026E720(void *a1)
{
  *a1 = &off_1022A2658;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    v9[0] = 68289026;
    v9[1] = 0;
    __int16 v10 = 2082;
    int v11 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"~StateMachineBase\"}", (uint8_t *)v9, 0x12u);
  }
  int v3 = (void *)a1[2];
  if (v3 != a1 + 3)
  {
    do
    {
      uint64_t v4 = v3[7];
      v3[7] = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          __int16 v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          __int16 v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          int v3 = v6;
        }
        while (!v7);
      }
      int v3 = v6;
    }
    while (v6 != a1 + 3);
  }
  a1[1] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_10026FA0C((uint64_t)(a1 + 2), (void *)a1[3]);
  return a1;
}

uint64_t sub_10026E8B4(uint64_t a1, long long *a2, uint64_t *a3)
{
  BOOL v7 = a2;
  uint64_t v4 = sub_10026FAE0((uint64_t **)(a1 + 16), (const void **)a2, (uint64_t)&unk_101D0B290, &v7);
  uint64_t v5 = *a3;
  *a3 = 0;
  uint64_t result = v4[7];
  v4[7] = v5;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_10026E934(void *a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__p, (void *)*a2, a2[1]);
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    uint64_t v10 = a2[2];
  }
  uint64_t v4 = sub_10012FFE0((uint64_t)(a1 + 2), (const void **)__p);
  if (a1 + 3 == (void *)v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 56);
  }
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__p[0]);
    if (v5) {
      goto LABEL_9;
    }
  }
  else if (v5)
  {
LABEL_9:
    sub_10026EB74(a1, v5);
    return;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  __int16 v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    BOOL v7 = v2;
    if (*((char *)v2 + 23) < 0) {
      BOOL v7 = (uint64_t *)*v2;
    }
    *(_DWORD *)buf = 68289283;
    int v12 = 0;
    __int16 v13 = 2082;
    char v14 = "";
    __int16 v15 = 2081;
    unint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
  }
  uint64_t v8 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    if (*((char *)v2 + 23) < 0) {
      uint64_t v2 = (uint64_t *)*v2;
    }
    *(_DWORD *)buf = 68289283;
    int v12 = 0;
    __int16 v13 = 2082;
    char v14 = "";
    __int16 v15 = 2081;
    unint64_t v16 = v2;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "State Machine: Failed to initialize state because requested state doesn't exist in the state table", "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", buf, 0x1Cu);
  }
}

void sub_10026EB50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10026EB74(void *a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a2 + 8);
    if (*(char *)(a2 + 31) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v11 = 68289283;
    int v12 = 0;
    __int16 v13 = 2082;
    char v14 = "";
    __int16 v15 = 2081;
    unint64_t v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"State Machine: Entering new state\", \"New State\":%{private, location:escape_only}s}", (uint8_t *)&v11, 0x1Cu);
  }
  uint64_t v6 = a1[1];
  if (v6 && *(unsigned char *)(v6 + 32)) {
    a1[6] = v6;
  }
  a1[5] = v6;
  a1[1] = a2;
  BOOL v7 = *(void (****)(void, void *))(a2 + 40);
  if (v7)
  {
    (**v7)(v7, a1);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = a1[1];
      uint64_t v10 = (void *)(v9 + 8);
      if (*(char *)(v9 + 31) < 0) {
        uint64_t v10 = (void *)*v10;
      }
      int v11 = 68289283;
      int v12 = 0;
      __int16 v13 = 2082;
      char v14 = "";
      __int16 v15 = 2081;
      unint64_t v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"State Machine: State did not have an entry function\", \"State\":%{private, location:escape_only}s}", (uint8_t *)&v11, 0x1Cu);
    }
  }
}

uint64_t sub_10026ED70(void *a1, uint64_t a2)
{
  if (!a1[1])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 31) < 0)
      {
        sub_1000DC48C(__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
      }
      else
      {
        *(_OWORD *)__p = *(_OWORD *)(a2 + 8);
        *(void *)&__p[16] = *(void *)(a2 + 24);
      }
      int v20 = __p;
      if (__p[23] < 0) {
        int v20 = *(unsigned char **)__p;
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v20;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because current state is NULL\", \"Event\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2688);
      }
    }
    uint64_t v21 = qword_102419458;
    if (!os_signpost_enabled((os_log_t)qword_102419458)) {
      return 0;
    }
    if (*(char *)(a2 + 31) < 0)
    {
      sub_1000DC48C(__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)(a2 + 8);
      *(void *)&__p[16] = *(void *)(a2 + 24);
    }
    int v22 = __p;
    if (__p[23] < 0) {
      int v22 = *(unsigned char **)__p;
    }
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v22;
    unsigned int v23 = "State Machine: Failed to handle event because current state is NULL";
    uint64_t v24 = "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because current state is NULL\", \"Event\":%{priv"
          "ate, location:escape_only}s}";
    int v25 = v21;
    uint32_t v26 = 28;
    goto LABEL_111;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 31) < 0)
    {
      sub_1000DC48C(__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)(a2 + 8);
      *(void *)&__p[16] = *(void *)(a2 + 24);
    }
    uint64_t v6 = __p;
    if (__p[23] < 0) {
      uint64_t v6 = *(unsigned char **)__p;
    }
    uint64_t v7 = a1[1];
    uint64_t v8 = (void *)(v7 + 8);
    if (*(char *)(v7 + 31) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v6;
    __int16 v48 = 2081;
    int v49 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"State Machine: Handling Event\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}", buf, 0x26u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v9 = a1[1];
  uint64_t v10 = (_OWORD *)(a2 + 8);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1000DC48C(buf, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)buf = *v10;
    *(void *)&buf[16] = *(void *)(a2 + 24);
  }
  uint64_t v11 = sub_10012FFE0(v9 + 48, (const void **)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (a1[1] + 56 == v11)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
    char v14 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 31) < 0)
      {
        sub_1000DC48C(__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
      }
      else
      {
        *(_OWORD *)__p = *v10;
        *(void *)&__p[16] = *(void *)(a2 + 24);
      }
      int v36 = __p;
      if (__p[23] < 0) {
        int v36 = *(unsigned char **)__p;
      }
      uint64_t v37 = a1[1];
      unsigned int v38 = (void *)(v37 + 8);
      if (*(char *)(v37 + 31) < 0) {
        unsigned int v38 = (void *)*v38;
      }
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v36;
      __int16 v48 = 2081;
      int v49 = v38;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because it is not a valid event for the current state\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}", buf, 0x26u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2688);
      }
    }
    uint64_t v39 = qword_102419458;
    if (!os_signpost_enabled((os_log_t)qword_102419458)) {
      return 0;
    }
    if (*(char *)(a2 + 31) < 0)
    {
      sub_1000DC48C(__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      *(_OWORD *)__p = *v10;
      *(void *)&__p[16] = *(void *)(a2 + 24);
    }
    int v40 = __p;
    if (__p[23] < 0) {
      int v40 = *(unsigned char **)__p;
    }
    uint64_t v41 = a1[1];
    unint64_t v42 = (void *)(v41 + 8);
    if (*(char *)(v41 + 31) < 0) {
      unint64_t v42 = (void *)*v42;
    }
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v40;
    __int16 v48 = 2081;
    int v49 = v42;
    unsigned int v23 = "State Machine: Failed to handle event because it is not a valid event for the current state";
    uint64_t v24 = "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because it is not a valid event for the current s"
          "tate\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}";
    int v25 = v39;
    uint32_t v26 = 38;
LABEL_111:
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v23, v24, buf, v26);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    return 0;
  }
  (***(void (****)(unsigned char *__return_ptr))(v11 + 56))(buf);
  if (!buf[24])
  {
LABEL_69:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
    unsigned int v29 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = a1[1];
      int v31 = (void *)(v30 + 8);
      if (*(char *)(v30 + 31) < 0) {
        int v31 = (void *)*v31;
      }
      *(void *)__p = 68289283;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2081;
      *(void *)&__p[20] = v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"State Machine: \", \"New State\":%{private, location:escape_only}s}", __p, 0x1Cu);
    }
    uint64_t v18 = 1;
    goto LABEL_76;
  }
  uint64_t v12 = a1[1];
  if (*(char *)(v12 + 31) < 0)
  {
    sub_1000DC48C(__p, *(void **)(v12 + 8), *(void *)(v12 + 16));
  }
  else
  {
    long long v13 = *(_OWORD *)(v12 + 8);
    *(void *)&__p[16] = *(void *)(v12 + 24);
    *(_OWORD *)__p = v13;
  }
  BOOL v15 = sub_10026F754(buf, __p);
  BOOL v16 = v15;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (v16) {
      goto LABEL_36;
    }
    goto LABEL_44;
  }
  if (!v15)
  {
LABEL_44:
    if (!buf[24]) {
      sub_10020D700();
    }
    if ((buf[23] & 0x80000000) != 0)
    {
      sub_1000DC48C(v44, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)uint64_t v44 = *(_OWORD *)buf;
      uint64_t v45 = *(void *)&buf[16];
    }
    uint64_t v27 = sub_10012FFE0((uint64_t)(a1 + 2), (const void **)v44);
    if (a1 + 3 == (void *)v27) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = *(void *)(v27 + 56);
    }
    if (SHIBYTE(v45) < 0) {
      operator delete(v44[0]);
    }
    if (!v28)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2688);
      }
      uint64_t v32 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        if (!buf[24]) {
          sub_10020D700();
        }
        uint64_t v33 = buf;
        if (buf[23] < 0) {
          uint64_t v33 = *(unsigned char **)buf;
        }
        *(void *)__p = 68289283;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2081;
        *(void *)&__p[20] = v33;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"State Machine: Failed to switch to new state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", __p, 0x1Cu);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2688);
        }
      }
      int v34 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        if (!buf[24]) {
          sub_10020D700();
        }
        int v35 = buf;
        if (buf[23] < 0) {
          int v35 = *(unsigned char **)buf;
        }
        *(void *)__p = 68289283;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2081;
        *(void *)&__p[20] = v35;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v34, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "State Machine: Failed to switch to new state because requested state doesn't exist in the state table", "{\"msg%{public}.0s\":\"State Machine: Failed to switch to new state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", __p, 0x1Cu);
      }
      uint64_t v18 = 0;
      goto LABEL_76;
    }
    sub_10026F800((uint64_t)a1);
    sub_10026EB74(a1, v28);
    goto LABEL_69;
  }
LABEL_36:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  int v17 = qword_102419458;
  uint64_t v18 = 1;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    if (!buf[24]) {
      sub_10020D700();
    }
    int v19 = buf;
    if (buf[23] < 0) {
      int v19 = *(unsigned char **)buf;
    }
    *(void *)__p = 68289283;
    *(_WORD *)&__p[8] = 2082;
    *(void *)&__p[10] = "";
    *(_WORD *)&__p[18] = 2081;
    *(void *)&__p[20] = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"State Machine: No state change requested\", \"State\":%{private, location:escape_only}s}", __p, 0x1Cu);
  }
LABEL_76:
  if (buf[24] && (buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  return v18;
}

void sub_10026F6F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a26)
  {
    if (a25 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10026F754(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[24];
  if (a1[24])
  {
    uint64_t v3 = a1[23];
    if ((v3 & 0x80u) == 0) {
      uint64_t v4 = a1[23];
    }
    else {
      uint64_t v4 = *((void *)a1 + 1);
    }
    uint64_t v5 = a2[23];
    int v6 = (char)v5;
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *((void *)a2 + 1);
    }
    if (v4 == v5)
    {
      if (v6 < 0) {
        a2 = *(unsigned __int8 **)a2;
      }
      if ((v3 & 0x80) != 0)
      {
        return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
      }
      else if (a1[23])
      {
        uint64_t v7 = v3 - 1;
        do
        {
          int v9 = *a1++;
          int v8 = v9;
          int v11 = *a2++;
          int v10 = v11;
          BOOL v13 = v7-- != 0;
          BOOL v14 = v8 == v10;
          uint64_t v2 = v8 == v10;
        }
        while (v14 && v13);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_10026F800(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2688);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = (void *)(v3 + 8);
    if (*(char *)(v3 + 31) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    int v9 = 68289283;
    int v10 = 0;
    __int16 v11 = 2082;
    uint64_t v12 = "";
    __int16 v13 = 2081;
    BOOL v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"State Machine: Exiting State\", \"State\":%{private, location:escape_only}s}", (uint8_t *)&v9, 0x1Cu);
  }
  uint64_t v5 = *(void (****)(void, uint64_t))(*(void *)(a1 + 8) + 72);
  if (v5)
  {
    (**v5)(v5, a1);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2688);
    }
    int v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 8);
      int v8 = (void *)(v7 + 8);
      if (*(char *)(v7 + 31) < 0) {
        int v8 = (void *)*v8;
      }
      int v9 = 68289283;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2081;
      BOOL v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"State Machine: State did not have an exit function\", \"State\":%{private, location:escape_only}s}", (uint8_t *)&v9, 0x1Cu);
    }
  }
}

void sub_10026F9DC(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10026FA0C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10026FA0C(a1, *a2);
    sub_10026FA0C(a1, a2[1]);
    sub_10026FA68((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10026FA68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *sub_10026FAE0(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  int v6 = (uint64_t **)sub_1001070AC((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    sub_10026FB8C((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000EDF90(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_10026FC20((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_10026FB8C@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1000DC48C(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_10026FC08(_Unwind_Exception *a1)
{
  sub_10026FC20(v1, 0);
  _Unwind_Resume(a1);
}

void sub_10026FC20(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10026FA68((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void *sub_10026FC78@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, (&off_1022A2710)[a1]);
}

id sub_10026FC8C(int a1, void *a2, const std::string *a3)
{
  if (!a1) {
    return 0;
  }
  id v5 = +[NSMutableDictionary dictionary];
  sub_1002E8898(a2, (uint64_t)&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v5 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p) forKeyedSubscript:@"domain"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:@"cancelled"];
  [v5 setObject:&__kCFBooleanFalse forKeyedSubscript:@"valid"];
  if (a3[1].__r_.__value_.__s.__data_[0])
  {
    sub_100239A38(a3, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v7 = &__p;
    }
    else {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    [v5 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7) forKeyedSubscript:@"clientIdentifier"];
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  return v5;
}

void sub_10026FDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026FDE4(uint64_t result, void *a2, void *a3, char a4, double a5)
{
  double v57 = a5;
  if (result)
  {
    int v8 = (void *)result;
    long long v54 = 0u;
    long long v55 = 0u;
    int v56 = 1065353216;
    unint64_t v9 = sub_1002D3900((uint64_t)a2);
    if (a4) {
      v9 += sub_1002D3900((uint64_t)a3);
    }
    [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v9) forKeyedSubscript:@"numFingerprints"];
    if (5 * (v9 / 5) >= 0x1F4) {
      unint64_t v10 = 500;
    }
    else {
      unint64_t v10 = 5 * (v9 / 5);
    }
    [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v10) forKeyedSubscript:@"numFingerprintsBounded"];
    if (v9)
    {
      double v52 = 1.79769313e308;
      double v53 = -1.79769313e308;
      double v50 = 1.79769313e308;
      double v51 = -1.79769313e308;
      v48[1] = 0;
      double v49 = 0.0;
      int v47 = (uint64_t *)v48;
      v48[0] = 0;
      v46[0] = 0;
      v46[1] = 0;
      v44[1] = 0;
      uint64_t v45 = (uint64_t *)v46;
      int v43 = (uint64_t *)v44;
      v44[0] = 0;
      uint64_t v41 = -1;
      uint64_t v42 = 0;
      unint64_t v40 = 0;
      v39[0] = &v57;
      v39[1] = &v54;
      unsigned int v39[2] = &v53;
      v39[3] = &v52;
      v39[4] = &v51;
      v39[5] = &v50;
      v39[6] = &v49;
      v39[7] = &v47;
      v39[8] = &v45;
      v39[9] = &v43;
      v39[10] = &v42;
      v39[11] = &v41;
      v39[12] = &v40;
      sub_1002706A0((uint64_t)v39, a2);
      if (a4) {
        sub_1002706A0((uint64_t)v39, a3);
      }
      [v8 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v53) forKeyedSubscript:@"ageOfOldestFingerprint"];
      [v8 setObject:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (int)v53) forKeyedSubscript:@"ageOfOldestFingerprintBounded"];
      [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v52)] forKeyedSubscript:@"ageOfNewestFingerprint"];
      [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v51)] forKeyedSubscript:@"maxFingerprintDuration"];
      [v8 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v50) forKeyedSubscript:@"minFingerprintDuration"];
      double v11 = (double)v9;
      [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v49 / (double)v9)] forKeyedSubscript:@"avgFingerprintDuration"];
      [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v42) forKeyedSubscript:@"maxFingerprintSize"];
      [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v41) forKeyedSubscript:@"minFingerprintSize"];
      [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v40 / (double)v9)] forKeyedSubscript:@"avgFingerprintSize"];
      uint64_t v12 = v44[0];
      if (v44[0])
      {
        __int16 v13 = (int *)v44;
        BOOL v14 = (int *)v44[0];
        do
        {
          BOOL v15 = v14;
          BOOL v16 = v13;
          int v17 = v14[8];
          if (v17 >= 1) {
            __int16 v13 = v14;
          }
          else {
            v14 += 2;
          }
          BOOL v14 = *(int **)v14;
        }
        while (v14);
        if (v13 != (int *)v44)
        {
          if (v17 < 1) {
            BOOL v15 = v16;
          }
          if (v15[8] <= 1)
          {
            int v38 = 1;
            unsigned int v58 = &v38;
            [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v47, &v38, (uint64_t)&unk_101D0B290, &v58)[5])] forKeyedSubscript:@"maxWifiFingerprintSize"];
            int v38 = 1;
            unsigned int v58 = &v38;
            [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v45, &v38, (uint64_t)&unk_101D0B290, &v58)[5])] forKeyedSubscript:@"minWifiFingerprintSize"];
            int v38 = 1;
            unsigned int v58 = &v38;
            [v8 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_1000FEE0C(&v43, &v38, (uint64_t)&unk_101D0B290, &v58)[5] / v11) forKeyedSubscript:@"avgWifiFingerprintSize"];
            uint64_t v12 = v44[0];
          }
        }
        if (v12)
        {
          uint64_t v18 = (int *)v44;
          int v19 = (int *)v12;
          do
          {
            int v20 = v19;
            uint64_t v21 = v18;
            int v22 = v19[8];
            if (v22 >= 5) {
              uint64_t v18 = v19;
            }
            else {
              v19 += 2;
            }
            int v19 = *(int **)v19;
          }
          while (v19);
          if (v18 != (int *)v44)
          {
            if (v22 < 5) {
              int v20 = v21;
            }
            if (v20[8] <= 5)
            {
              int v38 = 5;
              unsigned int v58 = &v38;
              [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v47, &v38, (uint64_t)&unk_101D0B290, &v58)[5])] forKeyedSubscript:@"maxBleFingerprintSize"];
              int v38 = 5;
              unsigned int v58 = &v38;
              [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v45, &v38, (uint64_t)&unk_101D0B290, &v58)[5]) forKeyedSubscript:@"minBleFingerprintSize"];
              int v38 = 5;
              unsigned int v58 = &v38;
              [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_1000FEE0C(&v43, &v38, (uint64_t)&unk_101D0B290, &v58)[5] / v11) forKeyedSubscript:@"avgBleFingerprintSize"];
              uint64_t v12 = v44[0];
            }
          }
          if (v12)
          {
            unsigned int v23 = v44;
            do
            {
              uint64_t v24 = v12;
              int v25 = v23;
              int v26 = *((_DWORD *)v12 + 8);
              uint64_t v27 = v12 + 1;
              if (v26 >= 6)
              {
                uint64_t v27 = v24;
                unsigned int v23 = (void **)v24;
              }
              uint64_t v12 = (void *)*v27;
            }
            while (v12);
            if (v23 != v44)
            {
              uint64_t v28 = (int *)(v26 >= 6 ? v24 : v25);
              if (v28[8] <= 6)
              {
                int v38 = 6;
                unsigned int v58 = &v38;
                [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v47, &v38, (uint64_t)&unk_101D0B290, &v58)[5])] forKeyedSubscript:@"maxUwbFingerprintSize"];
                int v38 = 6;
                unsigned int v58 = &v38;
                [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1000FEE0C(&v45, &v38, (uint64_t)&unk_101D0B290, &v58)[5])] forKeyedSubscript:@"minUwbFingerprintSize"];
                int v38 = 6;
                unsigned int v58 = &v38;
                [v8 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_1000FEE0C(&v43, &v38, (uint64_t)&unk_101D0B290, &v58)[5] / v11) forKeyedSubscript:@"avgUwbFingerprintSize"];
              }
            }
          }
        }
      }
      unsigned int v29 = (uint64_t *)v55;
      if ((void)v55)
      {
        uint64_t v30 = 0;
        do
        {
          if (*((_DWORD *)v29 + 6) == 1) {
            ++v30;
          }
          unsigned int v29 = (uint64_t *)*v29;
        }
        while (v29);
      }
      else
      {
        uint64_t v30 = 0;
      }
      [v8 setObject:+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v30) forKeyedSubscript:@"numSourcesWifi"];
      if ((unint64_t)(5 * (v30 / 5)) >= 0x64) {
        uint64_t v31 = 100;
      }
      else {
        uint64_t v31 = 5 * (v30 / 5);
      }
      [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v31) forKeyedSubscript:@"numSourcesWifiBounded"];
      uint64_t v32 = (uint64_t *)v55;
      if ((void)v55)
      {
        uint64_t v33 = 0;
        do
        {
          if (*((_DWORD *)v32 + 6) == 5) {
            ++v33;
          }
          uint64_t v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        uint64_t v33 = 0;
      }
      [v8 setObject:+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v33) forKeyedSubscript:@"numSourcesBle"];
      if (v33 >= 15) {
        uint64_t v34 = 15;
      }
      else {
        uint64_t v34 = v33;
      }
      [v8 setObject:+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v34) forKeyedSubscript:@"numSourcesBleBounded"];
      int v35 = (uint64_t *)v55;
      if ((void)v55)
      {
        uint64_t v36 = 0;
        do
        {
          if (*((_DWORD *)v35 + 6) == 6) {
            ++v36;
          }
          int v35 = (uint64_t *)*v35;
        }
        while (v35);
      }
      else
      {
        uint64_t v36 = 0;
      }
      [v8 setObject:[+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v36)] forKeyedSubscript:@"numSourcesUwb"];
      if (v36 >= 15) {
        uint64_t v37 = 15;
      }
      else {
        uint64_t v37 = v36;
      }
      [v8 setObject:+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v37) forKeyedSubscript:@"numSourcesUwbBounded"];
      sub_1000F5BB0((uint64_t)&v43, v44[0]);
      sub_1000F5BB0((uint64_t)&v45, v46[0]);
      sub_1000F5BB0((uint64_t)&v47, v48[0]);
    }
    return sub_1001F00CC((uint64_t)&v54);
  }
  return result;
}

void sub_100270628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  sub_1000F5BB0((uint64_t)&a27, v33[1]);
  sub_1000F5BB0((uint64_t)&a30, v33[4]);
  sub_1000F5BB0((uint64_t)&a33, v33[7]);
  sub_1001F00CC(v34 - 160);
  _Unwind_Resume(a1);
}

BOOL sub_1002706A0(uint64_t a1, void *a2)
{
  v66[0] = sub_1002D396C((uint64_t)a2);
  v66[1] = v4;
  v65[0] = sub_1002D3978(a2);
  v65[1] = v5;
  for (BOOL result = sub_1002D37F4(v66, v65); result; BOOL result = sub_1002D37F4(v66, v65))
  {
    uint64_t v7 = sub_1002D3820(v66);
    int v8 = *(uint64_t **)(v7 + 16);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 8);
      do
      {
        sub_1001F043C(v9, (uint64_t)(v8 + 2), (_OWORD *)v8 + 1);
        int v8 = (uint64_t *)*v8;
      }
      while (v8);
    }
    unint64_t v10 = *(double **)(a1 + 16);
    double v11 = *(double **)a1;
    double v12 = **(double **)a1 - *(double *)(v7 + 144);
    if (*v10 >= v12) {
      double v12 = *v10;
    }
    double *v10 = v12;
    __int16 v13 = *(double **)(a1 + 24);
    double v14 = *v11 - *(double *)(v7 + 144);
    if (v14 >= *v13) {
      double v14 = *v13;
    }
    *__int16 v13 = v14;
    BOOL v15 = *(double **)(a1 + 32);
    LODWORD(v67) = 1;
    BOOL v16 = sub_1001EF6E0((void *)(v7 + 104), (unsigned int *)&v67);
    double v17 = 0.0;
    double v18 = 0.0;
    if (v16) {
      double v18 = *((double *)v16 + 4) - *((double *)v16 + 3);
    }
    if (*v15 >= v18) {
      double v18 = *v15;
    }
    **(double **)(a1 + 32) = v18;
    int v19 = *(double **)(a1 + 40);
    LODWORD(v67) = 1;
    int v20 = sub_1001EF6E0((void *)(v7 + 104), (unsigned int *)&v67);
    if (v20) {
      double v17 = *((double *)v20 + 4) - *((double *)v20 + 3);
    }
    double v21 = *v19;
    if (v17 < *v19) {
      double v21 = v17;
    }
    **(double **)(a1 + 40) = v21;
    LODWORD(v67) = 1;
    int v22 = sub_1001EF6E0((void *)(v7 + 104), (unsigned int *)&v67);
    if (v22) {
      double v23 = *((double *)v22 + 4) - *((double *)v22 + 3);
    }
    else {
      double v23 = 0.0;
    }
    **(double **)(a1 + 48) = v23 + **(double **)(a1 + 48);
    uint64_t v24 = *(unint64_t **)(a1 + 80);
    unint64_t v25 = *(void *)(v7 + 24);
    if (*v24 > v25) {
      unint64_t v25 = *v24;
    }
    *uint64_t v24 = v25;
    int v26 = *(unint64_t **)(a1 + 88);
    unint64_t v27 = *(void *)(v7 + 24);
    if (v27 >= *v26) {
      unint64_t v27 = *v26;
    }
    *int v26 = v27;
    **(void **)(a1 + 96) += *(void *)(v7 + 24);
    for (i = *(int **)(v7 + 80); i; i = *(int **)i)
    {
      unsigned int v29 = i + 4;
      uint64_t v30 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(v30 + 8);
      if (!v31) {
        goto LABEL_35;
      }
      int v32 = *v29;
      uint64_t v33 = v30 + 8;
      do
      {
        int v34 = *(_DWORD *)(v31 + 32);
        BOOL v35 = v34 < v32;
        if (v34 >= v32) {
          uint64_t v36 = (uint64_t *)v31;
        }
        else {
          uint64_t v36 = (uint64_t *)(v31 + 8);
        }
        if (!v35) {
          uint64_t v33 = v31;
        }
        uint64_t v31 = *v36;
      }
      while (*v36);
      if (v33 == v30 + 8 || v32 < *(_DWORD *)(v33 + 32))
      {
LABEL_35:
        unsigned int v67 = i + 4;
        sub_1000FEE0C((uint64_t **)v30, i + 4, (uint64_t)&unk_101D0B290, &v67)[5] = 0;
        uint64_t v30 = *(void *)(a1 + 56);
      }
      unsigned int v67 = i + 4;
      uint64_t v37 = sub_1000FEE0C((uint64_t **)v30, i + 4, (uint64_t)&unk_101D0B290, &v67);
      int v38 = *(uint64_t **)(v7 + 16);
      if (v38)
      {
        uint64_t v39 = 0;
        do
        {
          if (*((_DWORD *)v38 + 6) == *v29) {
            uint64_t v39 = (uint64_t *)((char *)v39 + 1);
          }
          int v38 = (uint64_t *)*v38;
        }
        while (v38);
      }
      else
      {
        uint64_t v39 = 0;
      }
      if (v37[5] <= v39) {
        unint64_t v40 = v39;
      }
      else {
        unint64_t v40 = v37[5];
      }
      uint64_t v41 = *(uint64_t ***)(a1 + 56);
      unsigned int v67 = i + 4;
      sub_1000FEE0C(v41, i + 4, (uint64_t)&unk_101D0B290, &v67)[5] = v40;
      uint64_t v42 = *(void *)(a1 + 64);
      uint64_t v43 = *(void *)(v42 + 8);
      if (!v43) {
        goto LABEL_56;
      }
      int v44 = *v29;
      uint64_t v45 = v42 + 8;
      do
      {
        int v46 = *(_DWORD *)(v43 + 32);
        BOOL v47 = v46 < v44;
        if (v46 >= v44) {
          __int16 v48 = (uint64_t *)v43;
        }
        else {
          __int16 v48 = (uint64_t *)(v43 + 8);
        }
        if (!v47) {
          uint64_t v45 = v43;
        }
        uint64_t v43 = *v48;
      }
      while (*v48);
      if (v45 == v42 + 8 || v44 < *(_DWORD *)(v45 + 32)) {
LABEL_56:
      }
        uint64_t v45 = v42 + 8;
      if (v45 == *(void *)(a1 + 56) + 8)
      {
        unsigned int v67 = i + 4;
        sub_1000FEE0C((uint64_t **)v42, i + 4, (uint64_t)&unk_101D0B290, &v67)[5] = (uint64_t *)-1;
        uint64_t v42 = *(void *)(a1 + 64);
      }
      unsigned int v67 = i + 4;
      double v49 = sub_1000FEE0C((uint64_t **)v42, i + 4, (uint64_t)&unk_101D0B290, &v67);
      double v50 = *(uint64_t **)(v7 + 16);
      if (v50)
      {
        double v51 = 0;
        do
        {
          if (*((_DWORD *)v50 + 6) == *v29) {
            double v51 = (uint64_t *)((char *)v51 + 1);
          }
          double v50 = (uint64_t *)*v50;
        }
        while (v50);
      }
      else
      {
        double v51 = 0;
      }
      if (v51 >= v49[5]) {
        double v52 = v49[5];
      }
      else {
        double v52 = v51;
      }
      double v53 = *(uint64_t ***)(a1 + 64);
      unsigned int v67 = i + 4;
      sub_1000FEE0C(v53, i + 4, (uint64_t)&unk_101D0B290, &v67)[5] = v52;
      uint64_t v54 = *(void *)(a1 + 72);
      uint64_t v55 = *(void *)(v54 + 8);
      if (!v55) {
        goto LABEL_79;
      }
      int v56 = *v29;
      uint64_t v57 = v54 + 8;
      do
      {
        int v58 = *(_DWORD *)(v55 + 32);
        BOOL v59 = v58 < v56;
        if (v58 >= v56) {
          int v60 = (uint64_t *)v55;
        }
        else {
          int v60 = (uint64_t *)(v55 + 8);
        }
        if (!v59) {
          uint64_t v57 = v55;
        }
        uint64_t v55 = *v60;
      }
      while (*v60);
      if (v57 == v54 + 8 || v56 < *(_DWORD *)(v57 + 32))
      {
LABEL_79:
        unsigned int v67 = i + 4;
        sub_1000FEE0C((uint64_t **)v54, i + 4, (uint64_t)&unk_101D0B290, &v67)[5] = 0;
        int v56 = *v29;
      }
      v61 = *(uint64_t **)(v7 + 16);
      if (v61)
      {
        uint64_t v62 = 0;
        do
        {
          if (*((_DWORD *)v61 + 6) == v56) {
            ++v62;
          }
          v61 = (uint64_t *)*v61;
        }
        while (v61);
      }
      else
      {
        uint64_t v62 = 0;
      }
      v63 = *(uint64_t ***)(a1 + 72);
      unsigned int v67 = i + 4;
      int v64 = sub_1000FEE0C(v63, i + 4, (uint64_t)&unk_101D0B290, &v67);
      v64[5] = (uint64_t *)((char *)v64[5] + v62);
    }
    sub_1002D384C((uint64_t)v66);
  }
  return result;
}

void sub_100270B2C(void *a1, uint64_t a2)
{
  sub_1000C7F88(buf);
  LOBYTE(v40[0]) = 0;
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAdaptiveSensorsEnable", 0x8000100u, kCFAllocatorNull);
  char v5 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v4, (BOOL *)v40);
  CFRelease(v4);
  int v6 = LOBYTE(v40[0]);
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v6) {
    char v7 = 1;
  }
  else {
    char v7 = v5 ^ 1;
  }
  v40[0] = &stru_10234F018;
  v40[1] = sub_100274A14(1, 1, 1);
  char v41 = v7;
  CFStringRef v42 = @"Wifi";
  uint64_t v43 = sub_100274A14(1, 0, 0);
  char v44 = v7;
  CFStringRef v45 = @"Ble";
  uint64_t v46 = sub_100274A14(0, 1, 0);
  char v47 = v7;
  CFStringRef v48 = @"Uwb";
  uint64_t v8 = 0;
  uint64_t v49 = sub_100274A14(0, 0, 1);
  char v50 = v7;
  do
  {
    uint64_t v9 = &v40[v8];
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    sub_10029D83C((uint64_t)&v40[v8], a2, (float *)&v24);
    LODWORD(v10) = v24;
    [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v10), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"minClusterRfSize", v40[v8]) forKeyedSubscript];
    LODWORD(v11) = HIDWORD(v24);
    [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v11), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"maxClusterRfSize", v40[v8]) forKeyedSubscript];
    LODWORD(v12) = v25;
    [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"avgClusterRfSize", v40[v8]) forKeyedSubscript];
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A26F0);
    }
    __int16 v13 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *v9;
      *(_DWORD *)buf = 138413058;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = *(float *)&v24;
      __int16 v36 = 2048;
      double v37 = *((float *)&v24 + 1);
      __int16 v38 = 2048;
      double v39 = *(float *)&v25;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Model cluster RF sizes %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A26F0);
      }
      uint64_t v20 = *v9;
      int v27 = 138413058;
      uint64_t v28 = v20;
      __int16 v29 = 2048;
      double v30 = *(float *)&v24;
      __int16 v31 = 2048;
      double v32 = *((float *)&v24 + 1);
      __int16 v33 = 2048;
      double v34 = *(float *)&v25;
      double v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(NSMutableDictionary *, const CLMicroLocationModel &)", "%s\n", v21);
      if (v21 != buf) {
        free(v21);
      }
    }
    if ((unint64_t)sub_1002765A8(a2) >= 2)
    {
      LODWORD(v15) = HIDWORD(v25);
      [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v15), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"minClusterRfDistance", *v9) forKeyedSubscript];
      LODWORD(v16) = v26;
      [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v16), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"maxClusterRfDistance", *v9) forKeyedSubscript];
      LODWORD(v17) = HIDWORD(v26);
      [a1 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v17), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@%@", @"avgClusterRfDistance", *v9) forKeyedSubscript];
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A26F0);
      }
      double v18 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = *v9;
        *(_DWORD *)buf = 138413058;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = *((float *)&v25 + 1);
        __int16 v36 = 2048;
        double v37 = *(float *)&v26;
        __int16 v38 = 2048;
        double v39 = *((float *)&v26 + 1);
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Model cluster RF distances %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A26F0);
        }
        uint64_t v22 = *v9;
        int v27 = 138413058;
        uint64_t v28 = v22;
        __int16 v29 = 2048;
        double v30 = *((float *)&v25 + 1);
        __int16 v31 = 2048;
        double v32 = *(float *)&v26;
        __int16 v33 = 2048;
        double v34 = *((float *)&v26 + 1);
        double v23 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(NSMutableDictionary *, const CLMicroLocationModel &)", "%s\n", v23);
        if (v23 != buf) {
          free(v23);
        }
      }
    }
    v8 += 3;
  }
  while (v8 != 12);
}

void sub_1002711C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    sub_1000DB0A0(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002711EC(void *a1, void *a2, uint64_t a3, double a4)
{
  if (a1)
  {
    [a1 setObject:&__kCFBooleanFalse forKeyedSubscript:@"cancelled"];
    if (sub_100278D98((uint64_t)a2)) {
      uint64_t v8 = &__kCFBooleanTrue;
    }
    else {
      uint64_t v8 = &__kCFBooleanFalse;
    }
    [a1 setObject:v8 forKeyedSubscript:@"valid"];
    [a1 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", j__CFAbsoluteTimeGetCurrent_5() - a4)] forKeyedSubscript:@"runTime"];
    uint64_t v9 = (uint64_t)[a1 objectForKeyedSubscript:@"learnCounter"].integerValue;
    if (v9)
    {
      if (v9 >= 100) {
        uint64_t v10 = 100;
      }
      else {
        uint64_t v10 = v9;
      }
      [a1 setObject:[+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v10)] forKeyedSubscript:@"learnCounter"];
    }
    if (sub_100278D98((uint64_t)a2))
    {
      if (sub_1002A9C24() == 1) {
        CFStringRef v11 = @"Configuration_Default";
      }
      else {
        CFStringRef v11 = @"Configuration_Candidate";
      }
      [a1 setObject:v11 forKeyedSubscript:@"configSelect"];
      [a1 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002765A8((uint64_t)a2))] forKeyedSubscript:@"numClusters"];
      sub_1002716BC(a1, (uint64_t)a2, a3);
      sub_100270B2C(a1, (uint64_t)a2);
      [a1 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", sub_10027A37C(a2)) forKeyedSubscript:@"representativeFPsRatio"];
      std::string __p = 0;
      char v41 = 0;
      unint64_t v42 = 0;
      double v12 = (void *)a2[34];
      if (v12)
      {
        __int16 v13 = 0;
        do
        {
          uint64_t v14 = (uint64_t)(v12[5] - v12[4]) >> 4;
          if ((unint64_t)v13 >= v42)
          {
            double v15 = (unint64_t *)__p;
            uint64_t v16 = ((char *)v13 - (unsigned char *)__p) >> 3;
            unint64_t v17 = v16 + 1;
            if ((unint64_t)(v16 + 1) >> 61) {
              sub_1001D7FD4();
            }
            uint64_t v18 = v42 - (void)__p;
            if ((uint64_t)(v42 - (void)__p) >> 2 > v17) {
              unint64_t v17 = v18 >> 2;
            }
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v19 = v17;
            }
            if (v19)
            {
              unint64_t v19 = (unint64_t)sub_1000DA54C((uint64_t)&v42, v19);
              uint64_t v21 = v20;
              double v15 = (unint64_t *)__p;
              __int16 v13 = v41;
            }
            else
            {
              uint64_t v21 = 0;
            }
            uint64_t v22 = (uint64_t *)(v19 + 8 * v16);
            *uint64_t v22 = v14;
            double v23 = (unint64_t *)(v22 + 1);
            while (v13 != v15)
            {
              uint64_t v24 = *--v13;
              *--uint64_t v22 = v24;
            }
            std::string __p = v22;
            char v41 = v23;
            unint64_t v42 = v19 + 8 * v21;
            if (v15) {
              operator delete(v15);
            }
            __int16 v13 = v23;
          }
          else
          {
            *v13++ = v14;
          }
          char v41 = v13;
          double v12 = (void *)*v12;
        }
        while (v12);
        uint64_t v25 = (unint64_t *)__p;
      }
      else
      {
        __int16 v13 = 0;
        uint64_t v25 = 0;
      }
      unint64_t v26 = 126 - 2 * __clz(v13 - v25);
      if (v13 == v25) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v26;
      }
      sub_100273188(v25, v13, (uint64_t)&v37, v27, 1);
      sub_1000C7F88(&v37);
      unsigned int v43 = 0;
      CFStringRef v28 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfClustersForLearningAnalytics", 0x8000100u, kCFAllocatorNull);
      int v29 = sub_1004D08E4((uint64_t)v37, (uint64_t)v28, &v43);
      CFRelease(v28);
      unint64_t v30 = v43;
      if (v38) {
        sub_1000DB0A0(v38);
      }
      if (v29) {
        unint64_t v31 = v30;
      }
      else {
        unint64_t v31 = 5;
      }
      __int16 v33 = __p;
      double v32 = v41;
      if (v41 != __p)
      {
        unint64_t v34 = 0;
        uint64_t v35 = 0;
        do
        {
          if (v34 >= v31)
          {
            v35 += v33[v34];
          }
          else
          {
            [a1 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v33[v34]), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"numFingerprintsInCluster%zu", v34) forKeyedSubscript];
            __int16 v33 = __p;
            double v32 = v41;
          }
          ++v34;
        }
        while (v34 < v32 - v33);
        if (v35)
        {
          [a1 setObject:[NSNumber numberWithUnsignedLong:v35] forKeyedSubscript:@"numFingerprintsInRemainingClusters"];
          double v32 = v41;
        }
      }
      [a1 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *(v32 - 1))] forKeyedSubscript:@"numFingerprintsInSmallestCluster"];
      sub_10026FC78(*(_DWORD *)a2, &v37);
      if (v39 >= 0) {
        __int16 v36 = &v37;
      }
      else {
        __int16 v36 = v37;
      }
      [a1 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v36) forKeyedSubscript:@"generationAlgorithm"];
      sub_1002718A8(a1, (uint64_t)a2);
      if (v39 < 0) {
        operator delete(v37);
      }
      if (__p)
      {
        char v41 = (unint64_t *)__p;
        operator delete(__p);
      }
    }
  }
}

void sub_10027165C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1002716BC(id result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    CFStringRef v4 = result;
    uint64_t v6 = *(void *)(a2 + 232);
    uint64_t v5 = *(void *)(a2 + 240);
    uint64_t v7 = (v5 - v6) >> 5;
    if (v5 == v6)
    {
      uint64_t v11 = 0;
      uint64_t v10 = 0;
      uint64_t v9 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        double v12 = *(uint64_t **)(*(void *)v6 + 16);
        if (v12)
        {
          uint64_t v13 = 0;
          uint64_t v14 = *(void *)(*(void *)v6 + 16);
          do
          {
            if (*(_DWORD *)(v14 + 24) == 1) {
              ++v13;
            }
            uint64_t v14 = *(void *)v14;
          }
          while (v14);
          uint64_t v15 = *(void *)(*(void *)v6 + 16);
          do
          {
            if (*(_DWORD *)(v15 + 24) == 5) {
              ++v14;
            }
            uint64_t v15 = *(void *)v15;
          }
          while (v15);
          v9 += v13;
          do
          {
            if (*((_DWORD *)v12 + 6) == 6) {
              ++v15;
            }
            double v12 = (uint64_t *)*v12;
          }
          while (v12);
          v10 += v14;
        }
        else
        {
          uint64_t v15 = 0;
        }
        v8 += *(void *)(*(void *)v6 + 24);
        v11 += v15;
        v6 += 32;
      }
      while (v6 != v5);
    }
    [result setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v7)] forKeyedSubscript:@"modelSizeNumFingerprints"];
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v8) forKeyedSubscript:@"modelSizeNumMeasurements"];
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v9) forKeyedSubscript:@"modelSizeNumWiFiMeasurements"];
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v10) forKeyedSubscript:@"modelSizeNumBleMeasurements"];
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v11) forKeyedSubscript:@"modelSizeNumUwbMeasurements"];
    uint64_t v16 = +[NSNumber numberWithInt:(*(uint64_t (**)(uint64_t))(*(void *)a3 + 72))(a3)];
    return [v4 setObject:v16 forKeyedSubscript:@"modelLoadedByteSize"];
  }
  return result;
}

void sub_1002718A8(void *a1, uint64_t a2)
{
  [a1 setObject:+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_100276834(a2)) forKeyedSubscript:@"modelQuality"];
  [a1 setObject:[+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_100276834(a2))] forKeyedSubscript:@"modelQualityBounded"];
  [a1 setObject:[NSNumber numberWithUnsignedInt:sub_10027683C(a2)] forKeyedSubscript:@"candidateModelQuality"];
  uint64_t v4 = sub_100276844(a2);
  double v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  sub_10010F834(&v11, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 2);
  unint64_t v5 = 126 - 2 * __clz((v12 - (unsigned char *)v11) >> 2);
  if (v12 == v11) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  sub_100273D84((uint64_t)v11, (int *)v12, (uint64_t)__p, v6, 1);
  memset(v10, 0, sizeof(v10));
  uint64_t v7 = (int *)v11;
  uint64_t v8 = v12;
  uint64_t v16 = v10;
  while (v7 != (int *)v8)
  {
    sub_1002E90C0(*v7, __p);
    sub_1002748CC(&v16, (long long *)__p);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    ++v7;
  }
  sub_1001D4530(" ", v10, (uint64_t)__p);
  if (v15 >= 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  [a1 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9) forKeyedSubscript:@"qualityReasons"];
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  __p[0] = v10;
  sub_1000A7B4C((void ***)__p);
  if (v11)
  {
    double v12 = (char *)v11;
    operator delete(v11);
  }
}

void sub_100271A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  *(void *)(v21 - 40) = &a10;
  sub_1000A7B4C((void ***)(v21 - 40));
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100271ACC(uint64_t result, void *a2, void *a3, uint64_t a4, char a5, double a6)
{
  if (result)
  {
    uint64_t v8 = (void *)result;
    if (a5) {
      [result setObject:[NSNumber numberWithDouble:a6 - *(double *)&a4] forKeyedSubscript:@"ageOfOldModel"];
    }
    BOOL result = sub_100278D98((uint64_t)a2);
    if (result)
    {
      [v8 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002765A8((uint64_t)a3)) forKeyedSubscript:@"numOldClusters"];
      int v9 = sub_1002765A8((uint64_t)a2);
      [v8 setObject:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v9 - sub_1002765A8((uint64_t)a3)) forKeyedSubscript:@"numClustersDiff"];
      sub_1002787CC(a2, (uint64_t)v14);
      sub_1002787CC(a3, (uint64_t)v13);
      uint64_t v10 = v15;
      if (v15)
      {
        unint64_t v11 = 0;
        do
        {
          if (sub_1001EFDE4(v13, v10 + 2)) {
            ++v11;
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        unint64_t v11 = 0;
      }
      [v8 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v11)] forKeyedSubscript:@"numMatchingClustersInt"];
      if (sub_1002765A8((uint64_t)a3))
      {
        *(float *)&double v12 = (float)v11 / (float)(unint64_t)sub_1002765A8((uint64_t)a3);
        [v8 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12) forKeyedSubscript:@"portionMatchingClusters"];
      }
      else
      {
        [v8 setObject:&off_102395510 forKeyedSubscript:@"portionMatchingClusters"];
      }
      sub_1000D7D80((uint64_t)v13);
      return sub_1000D7D80((uint64_t)v14);
    }
  }
  return result;
}

void sub_100271C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1000D7D80((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100271CAC(void *a1, uint64_t *a2, unsigned int a3)
{
  if (a1)
  {
    if (a3 && (unint64_t v5 = (a2[1] - *a2) >> 3, v5 >= a3))
    {
      unint64_t v10 = a3;
      if (v5 <= a3) {
        goto LABEL_19;
      }
      unint64_t v12 = a3 - 1;
      [a1 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *(void *)(*a2 + 8 * v12) - *(void *)(*a2 + 8 * a3)), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"numFingerprintsPrunedInIteration%u", v12) forKeyedSubscript];
      uint64_t v14 = *a2;
      unint64_t v15 = (a2[1] - *a2) >> 3;
      if (v15 <= v12) {
        goto LABEL_19;
      }
      unint64_t v16 = *(void *)(v14 + 8 * v12);
      if (!v16) {
        return;
      }
      if (v15 <= v10) {
LABEL_19:
      }
        sub_100273D6C();
      *(float *)&double v13 = 1.0 - (float)((float)*(unint64_t *)(v14 + 8 * v10) / (float)v16);
      unint64_t v17 = +[NSNumber numberWithFloat:v13];
      uint64_t v18 = +[NSString stringWithFormat:@"portionFingerprintsPrunedInIteration%u", v12];
      [a1 setObject:v17 forKeyedSubscript:v18];
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A26F0);
      }
      uint64_t v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = (a2[1] - *a2) >> 3;
        *(_DWORD *)buf = 68289538;
        int v20 = 0;
        __int16 v21 = 2082;
        uint64_t v22 = "";
        __int16 v23 = 2050;
        uint64_t v24 = a3;
        __int16 v25 = 2050;
        uint64_t v26 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A26F0);
        }
      }
      uint64_t v8 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t v9 = (a2[1] - *a2) >> 3;
        *(_DWORD *)buf = 68289538;
        int v20 = 0;
        __int16 v21 = 2082;
        uint64_t v22 = "";
        __int16 v23 = 2050;
        uint64_t v24 = a3;
        __int16 v25 = 2050;
        uint64_t v26 = v9;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "updateMagicalMomentsNumPrunedFingerprints called incorrectly", "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
      }
    }
  }
}

id sub_100271F9C(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  id result = [a1 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", a3 - sub_1002765A8(a2)), +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"numClustersPrunedIteration%u", a4) forKeyedSubscript];
  if (a3)
  {
    *(float *)&double v9 = 1.0 - (float)((float)(unint64_t)sub_1002765A8(a2) / (float)a3);
    unint64_t v10 = +[NSNumber numberWithFloat:v9];
    unint64_t v11 = +[NSString stringWithFormat:@"portionClustersPrunedIteration%u", a4];
    return [a1 setObject:v10 forKeyedSubscript:v11];
  }
  return result;
}

id sub_1002720AC(id result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v4 = result;
    unint64_t v5 = sub_1002D3900(a2);
    unint64_t v6 = sub_1002D3900(a3);
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5) forKeyedSubscript:@"numUnlabeledFingerprints"];
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v6) forKeyedSubscript:@"numLabeledFingerprints"];
    unint64_t v7 = 5 * (v6 / 5);
    if (5 * (v5 / 5) >= 0x1F4) {
      unint64_t v8 = 500;
    }
    else {
      unint64_t v8 = 5 * (v5 / 5);
    }
    [v4 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v8) forKeyedSubscript:@"numUnlabeledFingerprintsBounded"];
    if (v7 >= 0x1F4) {
      uint64_t v9 = 500;
    }
    else {
      uint64_t v9 = v7;
    }
    unint64_t v10 = +[NSNumber numberWithUnsignedLong:v9];
    return [v4 setObject:v10 forKeyedSubscript:@"numLabeledFingerprintsBounded"];
  }
  return result;
}

id sub_1002721BC(void *a1, uint64_t a2, unsigned char *a3)
{
  [a1 setObject:[NSNumber numberWithUnsignedInt:*((unsigned int *)(a2 + 12))] forKeyedSubscript:@"DaysWithRecordings"];
  [a1 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_100276834(a2) == 3) forKeyedSubscript:@"IsHighQualityModel"];
  [a1 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1002765B0(a2)) forKeyedSubscript:@"WasInHighQualityBefore"];
  if (a3[1])
  {
    if (sub_1002765B0(a2))
    {
      if (a3[1]) {
        BOOL v6 = *a3 == 0;
      }
      else {
        BOOL v6 = 0;
      }
      BOOL v7 = v6;
    }
    else
    {
      BOOL v7 = 0;
    }
  }
  else
  {
    BOOL v7 = sub_1002765B0(a2);
  }
  unint64_t v8 = +[NSNumber numberWithBool:v7];

  return [a1 setObject:v8 forKeyedSubscript:@"IsBecomingHighQualityModelForTheFirstTime"];
}

uint64_t sub_1002722E4()
{
  uint64_t result = sub_1002723AC();
  if (result) {
    return AnalyticsSendEventLazy();
  }
  return result;
}

uint64_t sub_1002723AC()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_100272440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

id sub_10027245C(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary];
  CFStringRef v3 = sub_1002E8FB0(*(void *)(a1 + 56));
  BOOL v4 = *(const void ***)(a1 + 48);
  if (*((char *)v4 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)v4 + 23);
  }
  else {
    size_t v5 = (size_t)v4[1];
  }
  BOOL v6 = __p;
  sub_1001110E4((uint64_t)__p, v5 + 12);
  if (SBYTE3(v38) < 0) {
    BOOL v6 = *(unsigned char **)__p;
  }
  if (v5)
  {
    if (*((char *)v4 + 23) >= 0) {
      BOOL v7 = v4;
    }
    else {
      BOOL v7 = *v4;
    }
    memmove(v6, v7, v5);
  }
  strcpy(&v6[v5], "TriggerEvent");
  if (SBYTE3(v38) >= 0) {
    unint64_t v8 = __p;
  }
  else {
    unint64_t v8 = *(unsigned char **)__p;
  }
  [v2 setObject:v3 forKeyedSubscript:[NSString stringWithUTF8String:v8]];
  if (SBYTE3(v38) < 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v9 = *(const void ***)(a1 + 48);
  if (*((char *)v9 + 23) >= 0) {
    size_t v10 = *((unsigned __int8 *)v9 + 23);
  }
  else {
    size_t v10 = (size_t)v9[1];
  }
  unint64_t v11 = __p;
  sub_1001110E4((uint64_t)__p, v10 + 17);
  if (SBYTE3(v38) < 0) {
    unint64_t v11 = *(unsigned char **)__p;
  }
  if (v10)
  {
    if (*((char *)v9 + 23) >= 0) {
      unint64_t v12 = v9;
    }
    else {
      unint64_t v12 = *v9;
    }
    memmove(v11, v12, v10);
  }
  strcpy(&v11[v10], "TriggerEventCount");
  if (SBYTE3(v38) >= 0) {
    double v13 = __p;
  }
  else {
    double v13 = *(unsigned char **)__p;
  }
  [v2 setObject:&off_102392480 forKeyedSubscript:[NSString stringWithUTF8String:v13]];
  if (SBYTE3(v38) < 0) {
    operator delete(*(void **)__p);
  }
  sub_100239A38(*(const std::string **)(a1 + 64), (std::string *)__p);
  if (SBYTE3(v38) >= 0) {
    uint64_t v14 = __p;
  }
  else {
    uint64_t v14 = *(unsigned char **)__p;
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14) forKeyedSubscript:@"clientId"];
  if (SBYTE3(v38) < 0) {
    operator delete(*(void **)__p);
  }
  unint64_t v15 = *(uint64_t **)(a1 + 72);
  if (*((char *)v15 + 23) < 0) {
    unint64_t v15 = (uint64_t *)*v15;
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15) forKeyedSubscript:@"requestStatus"];
  if (*(unsigned char *)(a1 + 80)) {
    unint64_t v16 = "On";
  }
  else {
    unint64_t v16 = "Off";
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16) forKeyedSubscript:@"displayState"];
  [v2 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 81)) forKeyedSubscript:@"lowLatencySession"];
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  unint64_t v17 = *(void **)(a1 + 32);
  id v18 = [v17 countByEnumeratingWithState:&v30 objects:v41 count:16];
  if (v18)
  {
    uint64_t v19 = *(void *)v31;
    do
    {
      int v20 = 0;
      do
      {
        if (*(void *)v31 != v19) {
          objc_enumerationMutation(v17);
        }
        __int16 v21 = *(void **)(*((void *)&v30 + 1) + 8 * (void)v20);
        id v22 = [*(id *)(a1 + 32) objectForKey:v21];
        if ([v2 objectForKey:v21])
        {
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A26F0);
          }
          __int16 v23 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
          {
            id v24 = [v21 UTF8String];
            *(_DWORD *)std::string __p = 136315138;
            *(void *)&__p[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Trigger event already have %s. Ignoring.", __p, 0xCu);
          }
          if (sub_10013D1A0(115, 0))
          {
            bzero(__p, 0x65CuLL);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A26F0);
            }
            id v25 = [v21 UTF8String];
            int v34 = 136315138;
            id v35 = v25;
            uint64_t v26 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 0, "static void CLMicroLocationCoreAnalyticsPublishHelper::sendCommonTriggerEvent(const CLMicroLocationProto::RecordingEvent &, const std::string &, const std::string &, const std::string &, const BOOL, const BOOL, NSMutableDictionary *)_block_invoke", "%s\n", v26);
            if (v26 != __p) {
              free(v26);
            }
          }
        }
        else
        {
          [v2 setObject:v22 forKeyedSubscript:v21];
        }
        int v20 = (char *)v20 + 1;
      }
      while (v18 != v20);
      id v18 = [v17 countByEnumeratingWithState:&v30 objects:v41 count:16];
    }
    while (v18);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A26F0);
  }
  uint64_t v27 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    id v28 = [*(id *)(a1 + 40) UTF8String];
    *(void *)std::string __p = 68289539;
    *(_WORD *)&__p[8] = 2082;
    *(void *)&__p[10] = "";
    __int16 v37 = 2081;
    id v38 = v28;
    __int16 v39 = 2113;
    id v40 = v2;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Sending CA event.\", \"name\":%{private, location:escape_only}s, \"event\":%{private, location:escape_only}@}", __p, 0x26u);
  }
  return v2;
}

void sub_1002729FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100272A28()
{
  if (sub_1002723AC())
  {
    std::operator+<char>();
    CFStringRef v0 = std::string::append(&v5, ".triggers");
    long long v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
    int64_t v7 = v0->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v1;
    v0->__r_.__value_.__l.__size_ = 0;
    v0->__r_.__value_.__r.__words[2] = 0;
    v0->__r_.__value_.__r.__words[0] = 0;
    if (v7 >= 0) {
      id v2 = __p;
    }
    else {
      id v2 = (void **)__p[0];
    }
    +[NSString stringWithUTF8String:v2];
    AnalyticsSendEventLazy();
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v5.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A26F0);
    }
    CFStringRef v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CLMicroLocationCoreAnalyticsPublishHelper, sendTriggerEvent, not sending event because sending to CoreAnalytics is disabled", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A26F0);
      }
      LOWORD(v5.__r_.__value_.__l.__data_) = 0;
      BOOL v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::sendTriggerEvent(const CLMicroLocationProto::RecordingEvent &, const std::string &, const std::string &, const std::string &, const std::string &, const BOOL)", "%s\n", v4);
      if (v4 != (char *)__p) {
        free(v4);
      }
    }
  }
}

void sub_100272D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100272DA4(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary];
  CFStringRef v3 = *(uint64_t **)(a1 + 32);
  if (*((char *)v3 + 23) < 0) {
    CFStringRef v3 = (uint64_t *)*v3;
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3) forKeyedSubscript:@"loiType"];
  CFStringRef v4 = sub_1002E8FB0(*(void *)(a1 + 48));
  std::string v5 = *(const void ***)(a1 + 40);
  if (*((char *)v5 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)v5 + 23);
  }
  else {
    size_t v6 = (size_t)v5[1];
  }
  sub_1001110E4((uint64_t)&__p, v6 + 12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    if (*((char *)v5 + 23) >= 0) {
      unint64_t v8 = v5;
    }
    else {
      unint64_t v8 = *v5;
    }
    memmove(p_p, v8, v6);
  }
  strcpy((char *)p_p + v6, "TriggerEvent");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v9 = &__p;
  }
  else {
    uint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v2 setObject:v4 forKeyedSubscript:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9)];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  size_t v10 = *(const void ***)(a1 + 40);
  if (*((char *)v10 + 23) >= 0) {
    size_t v11 = *((unsigned __int8 *)v10 + 23);
  }
  else {
    size_t v11 = (size_t)v10[1];
  }
  sub_1001110E4((uint64_t)&__p, v11 + 17);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v12 = &__p;
  }
  else {
    unint64_t v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v11)
  {
    if (*((char *)v10 + 23) >= 0) {
      double v13 = v10;
    }
    else {
      double v13 = *v10;
    }
    memmove(v12, v13, v11);
  }
  strcpy((char *)v12 + v11, "TriggerEventCount");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v14 = &__p;
  }
  else {
    uint64_t v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v2 setObject:&off_102392480 forKeyedSubscript:[NSString stringWithUTF8String:v14]];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unint64_t v15 = *(uint64_t **)(a1 + 56);
  if (*((char *)v15 + 23) < 0) {
    unint64_t v15 = (uint64_t *)*v15;
  }
  unint64_t v16 = +[NSString stringWithUTF8String:v15];
  unint64_t v17 = *(const void ***)(a1 + 40);
  if (*((char *)v17 + 23) >= 0) {
    size_t v18 = *((unsigned __int8 *)v17 + 23);
  }
  else {
    size_t v18 = (size_t)v17[1];
  }
  sub_1001110E4((uint64_t)&__p, v18 + 7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v19 = &__p;
  }
  else {
    uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v18)
  {
    if (*((char *)v17 + 23) >= 0) {
      int v20 = v17;
    }
    else {
      int v20 = *v17;
    }
    memmove(v19, v20, v18);
  }
  strcpy((char *)v19 + v18, "Verdict");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    __int16 v21 = &__p;
  }
  else {
    __int16 v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v2 setObject:v16 forKeyedSubscript:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21)];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_100239A38(*(const std::string **)(a1 + 64), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v22 = &__p;
  }
  else {
    id v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22) forKeyedSubscript:@"clientId"];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*(unsigned char *)(a1 + 72)) {
    __int16 v23 = "On";
  }
  else {
    __int16 v23 = "Off";
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v23) forKeyedSubscript:@"displayState"];
  [v2 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 73)) forKeyedSubscript:@"isForcedLocalizationApp"];
  return v2;
}

void sub_100273130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100273158(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

unint64_t *sub_100273188(unint64_t *result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  size_t v10 = result;
LABEL_2:
  size_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    size_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v22 = *(a2 - 1);
          unint64_t v23 = *v11;
          if (v22 > *v11)
          {
            unint64_t *v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          unint64_t v24 = v11[1];
          unint64_t v25 = *(a2 - 1);
          if (v24 <= v25) {
            unint64_t v26 = *(a2 - 1);
          }
          else {
            unint64_t v26 = v11[1];
          }
          if (v24 >= v25) {
            unint64_t v24 = *(a2 - 1);
          }
          *(a2 - 1) = v24;
          v11[1] = v26;
          unint64_t v27 = *(a2 - 1);
          if (v27 <= *v11) {
            unint64_t v28 = *v11;
          }
          else {
            unint64_t v28 = *(a2 - 1);
          }
          if (v27 >= *v11) {
            unint64_t v27 = *v11;
          }
          *(a2 - 1) = v27;
          unint64_t v30 = *v11;
          unint64_t v29 = v11[1];
          if (v28 <= v29) {
            unint64_t v30 = v11[1];
          }
          if (v28 < v29) {
            unint64_t v29 = v28;
          }
          unint64_t *v11 = v30;
          v11[1] = v29;
          break;
        case 4uLL:
          unint64_t v32 = v11[1];
          unint64_t v31 = v11[2];
          if (*v11 <= v31) {
            unint64_t v33 = v11[2];
          }
          else {
            unint64_t v33 = *v11;
          }
          if (*v11 < v31) {
            unint64_t v31 = *v11;
          }
          v11[2] = v31;
          unint64_t *v11 = v33;
          unint64_t v34 = *(a2 - 1);
          if (v32 <= v34) {
            unint64_t v35 = *(a2 - 1);
          }
          else {
            unint64_t v35 = v32;
          }
          if (v32 < v34) {
            unint64_t v34 = v32;
          }
          *(a2 - 1) = v34;
          unint64_t v36 = *v11;
          if (*v11 <= v35) {
            unint64_t v37 = v35;
          }
          else {
            unint64_t v37 = *v11;
          }
          if (*v11 >= v35) {
            unint64_t v36 = v35;
          }
          unint64_t *v11 = v37;
          v11[1] = v36;
          unint64_t v38 = v11[2];
          unint64_t v39 = *(a2 - 1);
          if (v38 <= v39) {
            unint64_t v40 = *(a2 - 1);
          }
          else {
            unint64_t v40 = v11[2];
          }
          if (v38 >= v39) {
            unint64_t v38 = *(a2 - 1);
          }
          *(a2 - 1) = v38;
          unint64_t v41 = v11[1];
          if (v41 <= v40) {
            unint64_t v42 = v40;
          }
          else {
            unint64_t v42 = v11[1];
          }
          if (v41 >= v40) {
            unint64_t v41 = v40;
          }
          v11[1] = v42;
          v11[2] = v41;
          break;
        case 5uLL:
          unint64_t v43 = *v11;
          unint64_t v44 = v11[1];
          if (*v11 <= v44) {
            unint64_t v45 = v11[1];
          }
          else {
            unint64_t v45 = *v11;
          }
          if (*v11 >= v44) {
            unint64_t v43 = v11[1];
          }
          unint64_t *v11 = v45;
          v11[1] = v43;
          unint64_t v46 = v11[3];
          unint64_t v47 = *(a2 - 1);
          if (v46 <= v47) {
            unint64_t v48 = *(a2 - 1);
          }
          else {
            unint64_t v48 = v11[3];
          }
          if (v46 >= v47) {
            unint64_t v46 = *(a2 - 1);
          }
          *(a2 - 1) = v46;
          v11[3] = v48;
          unint64_t v49 = *(a2 - 1);
          unint64_t v50 = v11[2];
          if (v49 <= v50) {
            unint64_t v51 = v11[2];
          }
          else {
            unint64_t v51 = *(a2 - 1);
          }
          if (v49 >= v50) {
            unint64_t v49 = v11[2];
          }
          *(a2 - 1) = v49;
          unint64_t v53 = v11[2];
          unint64_t v52 = v11[3];
          unint64_t v54 = v11[1];
          if (v51 <= v52) {
            unint64_t v53 = v11[3];
          }
          if (v51 < v52) {
            unint64_t v52 = v51;
          }
          v11[2] = v53;
          v11[3] = v52;
          unint64_t v55 = *(a2 - 1);
          if (v54 <= v55) {
            unint64_t v56 = *(a2 - 1);
          }
          else {
            unint64_t v56 = v54;
          }
          if (v54 < v55) {
            unint64_t v55 = v54;
          }
          *(a2 - 1) = v55;
          unint64_t v57 = *v11;
          unint64_t v59 = v11[2];
          unint64_t v58 = v11[3];
          if (v58 <= *v11) {
            unint64_t v60 = *v11;
          }
          else {
            unint64_t v60 = v11[3];
          }
          if (v58 >= *v11) {
            unint64_t v58 = *v11;
          }
          if (v60 <= v59) {
            unint64_t v57 = v11[2];
          }
          if (v60 < v59) {
            unint64_t v59 = v60;
          }
          if (v58 <= v56) {
            unint64_t v61 = v56;
          }
          else {
            unint64_t v61 = v58;
          }
          if (v58 >= v56) {
            unint64_t v58 = v56;
          }
          if (v61 <= v59) {
            unint64_t v56 = v59;
          }
          unint64_t *v11 = v57;
          v11[1] = v56;
          if (v61 >= v59) {
            unint64_t v62 = v59;
          }
          else {
            unint64_t v62 = v61;
          }
          v11[2] = v62;
          v11[3] = v58;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return sub_100273AC8(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_10027362C(v11, &v11[v15 >> 1], a2 - 1);
      sub_10027362C(v11 + 1, v17 - 1, a2 - 2);
      sub_10027362C(v11 + 2, &v11[v16 + 1], a2 - 3);
      sub_10027362C(v17 - 1, v17, &v11[v16 + 1]);
      unint64_t v18 = *v11;
      unint64_t *v11 = *v17;
      unint64_t *v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_10027362C(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) <= *v11)
    {
      uint64_t result = sub_1002736B4(v11, (uint64_t *)a2);
      size_t v11 = result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = sub_100273764(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_100273818(v11, v19);
    size_t v11 = v19 + 1;
    uint64_t result = (unint64_t *)sub_100273818(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = (unint64_t *)sub_100273188(v10, v19, a3, -v13, a5 & 1);
      size_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  v63 = v11 + 1;
  BOOL v65 = v11 == a2 || v63 == a2;
  if (a5)
  {
    if (!v65)
    {
      uint64_t v66 = 0;
      unsigned int v67 = v11;
      do
      {
        unint64_t v69 = *v67;
        unint64_t v68 = v67[1];
        unsigned int v67 = v63;
        if (v68 > v69)
        {
          uint64_t v70 = v66;
          while (1)
          {
            *(unint64_t *)((char *)v11 + v70 + 8) = v69;
            if (!v70) {
              break;
            }
            unint64_t v69 = *(unint64_t *)((char *)v11 + v70 - 8);
            v70 -= 8;
            if (v68 <= v69)
            {
              uint64_t v71 = (unint64_t *)((char *)v11 + v70 + 8);
              goto LABEL_125;
            }
          }
          uint64_t v71 = v11;
LABEL_125:
          *uint64_t v71 = v68;
        }
        v63 = v67 + 1;
        v66 += 8;
      }
      while (v67 + 1 != a2);
    }
  }
  else if (!v65)
  {
    do
    {
      unint64_t v73 = *v10;
      unint64_t v72 = v10[1];
      size_t v10 = v63;
      if (v72 > v73)
      {
        do
        {
          unint64_t *v63 = v73;
          unint64_t v73 = *(v63 - 2);
          --v63;
        }
        while (v72 > v73);
        unint64_t *v63 = v72;
      }
      v63 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t sub_10027362C(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a1;
  unint64_t v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    unint64_t v6 = *a1;
    if (*a2 <= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unint64_t *sub_1002736B4(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    unint64_t v5 = (uint64_t *)(a1 + 1);
    do
    {
      unint64_t v3 = (unint64_t *)v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    unint64_t v3 = a1;
    do
    {
      unint64_t v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
      unint64_t v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < (unint64_t *)a2)
  {
    unint64_t v7 = *v3;
    unint64_t v8 = *a2;
    do
    {
      unint64_t *v3 = v8;
      *a2 = v7;
      do
      {
        unint64_t v9 = v3[1];
        ++v3;
        unint64_t v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        unint64_t v10 = *--a2;
        unint64_t v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - 1) = v2;
  return v3;
}

unint64_t *sub_100273764(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  do
    unint64_t v4 = a1[++v2];
  while (v4 > v3);
  unint64_t v5 = &a1[v2];
  unint64_t v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      unint64_t v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      unint64_t v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    unint64_t v9 = *a2;
    unint64_t v10 = &a1[v2];
    size_t v11 = a2;
    do
    {
      unint64_t *v10 = v9;
      unint64_t *v11 = v4;
      do
      {
        unint64_t v12 = v10[1];
        ++v10;
        unint64_t v4 = v12;
      }
      while (v12 > v3);
      do
      {
        unint64_t v13 = *--v11;
        unint64_t v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v10 < v11);
    unint64_t v6 = v10 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  *unint64_t v6 = v3;
  return v6;
}

BOOL sub_100273818(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      unint64_t v3 = *(a2 - 1);
      unint64_t v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      unint64_t v20 = a1[1];
      unint64_t v21 = *(a2 - 1);
      if (v20 <= v21) {
        unint64_t v22 = *(a2 - 1);
      }
      else {
        unint64_t v22 = a1[1];
      }
      if (v20 >= v21) {
        unint64_t v20 = *(a2 - 1);
      }
      *(a2 - 1) = v20;
      a1[1] = v22;
      unint64_t v23 = *(a2 - 1);
      if (v23 <= *a1) {
        unint64_t v24 = *a1;
      }
      else {
        unint64_t v24 = *(a2 - 1);
      }
      if (v23 >= *a1) {
        unint64_t v23 = *a1;
      }
      *(a2 - 1) = v23;
      unint64_t v26 = *a1;
      unint64_t v25 = a1[1];
      if (v24 <= v25) {
        unint64_t v26 = a1[1];
      }
      if (v24 < v25) {
        unint64_t v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      unint64_t v48 = a1[1];
      unint64_t v47 = a1[2];
      if (*a1 <= v47) {
        unint64_t v49 = a1[2];
      }
      else {
        unint64_t v49 = *a1;
      }
      if (*a1 < v47) {
        unint64_t v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      unint64_t v50 = *(a2 - 1);
      if (v48 <= v50) {
        unint64_t v51 = *(a2 - 1);
      }
      else {
        unint64_t v51 = v48;
      }
      if (v48 < v50) {
        unint64_t v50 = v48;
      }
      *(a2 - 1) = v50;
      unint64_t v52 = *a1;
      if (*a1 <= v51) {
        unint64_t v53 = v51;
      }
      else {
        unint64_t v53 = *a1;
      }
      if (*a1 >= v51) {
        unint64_t v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      unint64_t v54 = a1[2];
      unint64_t v55 = *(a2 - 1);
      if (v54 <= v55) {
        unint64_t v56 = *(a2 - 1);
      }
      else {
        unint64_t v56 = a1[2];
      }
      if (v54 >= v55) {
        unint64_t v54 = *(a2 - 1);
      }
      *(a2 - 1) = v54;
      unint64_t v57 = a1[1];
      if (v57 <= v56) {
        unint64_t v58 = v56;
      }
      else {
        unint64_t v58 = a1[1];
      }
      if (v57 >= v56) {
        unint64_t v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      unint64_t v27 = *a1;
      unint64_t v28 = a1[1];
      if (*a1 <= v28) {
        unint64_t v29 = a1[1];
      }
      else {
        unint64_t v29 = *a1;
      }
      if (*a1 >= v28) {
        unint64_t v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      unint64_t v30 = a1[3];
      unint64_t v31 = *(a2 - 1);
      if (v30 <= v31) {
        unint64_t v32 = *(a2 - 1);
      }
      else {
        unint64_t v32 = a1[3];
      }
      if (v30 >= v31) {
        unint64_t v30 = *(a2 - 1);
      }
      *(a2 - 1) = v30;
      a1[3] = v32;
      unint64_t v33 = *(a2 - 1);
      unint64_t v34 = a1[2];
      if (v33 <= v34) {
        unint64_t v35 = a1[2];
      }
      else {
        unint64_t v35 = *(a2 - 1);
      }
      if (v33 >= v34) {
        unint64_t v33 = a1[2];
      }
      *(a2 - 1) = v33;
      unint64_t v37 = a1[2];
      unint64_t v36 = a1[3];
      unint64_t v38 = a1[1];
      if (v35 <= v36) {
        unint64_t v37 = a1[3];
      }
      if (v35 < v36) {
        unint64_t v36 = v35;
      }
      a1[2] = v37;
      a1[3] = v36;
      unint64_t v39 = *(a2 - 1);
      if (v38 <= v39) {
        unint64_t v40 = *(a2 - 1);
      }
      else {
        unint64_t v40 = v38;
      }
      if (v38 < v39) {
        unint64_t v39 = v38;
      }
      *(a2 - 1) = v39;
      unint64_t v41 = *a1;
      unint64_t v43 = a1[2];
      unint64_t v42 = a1[3];
      if (v42 <= *a1) {
        unint64_t v44 = *a1;
      }
      else {
        unint64_t v44 = a1[3];
      }
      if (v42 >= *a1) {
        unint64_t v42 = *a1;
      }
      if (v44 <= v43) {
        unint64_t v41 = a1[2];
      }
      if (v44 < v43) {
        unint64_t v43 = v44;
      }
      if (v42 <= v40) {
        unint64_t v45 = v40;
      }
      else {
        unint64_t v45 = v42;
      }
      if (v42 >= v40) {
        unint64_t v42 = v40;
      }
      if (v45 <= v43) {
        unint64_t v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43) {
        unint64_t v46 = v43;
      }
      else {
        unint64_t v46 = v45;
      }
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      unint64_t v6 = a1 + 2;
      unint64_t v5 = a1[2];
      unint64_t v8 = *a1;
      unint64_t v7 = a1[1];
      if (v7 <= v5) {
        unint64_t v9 = a1[2];
      }
      else {
        unint64_t v9 = a1[1];
      }
      if (v7 < v5) {
        unint64_t v5 = a1[1];
      }
      if (v5 <= v8) {
        unint64_t v10 = *a1;
      }
      else {
        unint64_t v10 = v5;
      }
      if (v5 >= v8) {
        unint64_t v5 = *a1;
      }
      *unint64_t v6 = v5;
      if (v10 <= v9) {
        unint64_t v11 = v9;
      }
      else {
        unint64_t v11 = v8;
      }
      if (v10 >= v9) {
        unint64_t v10 = v9;
      }
      *a1 = v11;
      a1[1] = v10;
      unint64_t v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v13 = 0;
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    unint64_t v15 = *v12;
    unint64_t v16 = *v6;
    if (*v12 > v16)
    {
      uint64_t v17 = v14;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v17) = v16;
        uint64_t v18 = v17 - 8;
        if (v17 == 8) {
          break;
        }
        unint64_t v16 = *(unint64_t *)((char *)a1 + v17 - 16);
        v17 -= 8;
        if (v15 <= v16)
        {
          uint64_t v19 = (unint64_t *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      uint64_t v19 = a1;
LABEL_27:
      unint64_t *v19 = v15;
      if (++v13 == 8) {
        return v12 + 1 == a2;
      }
    }
    unint64_t v6 = v12;
    v14 += 8;
    if (++v12 == a2) {
      return 1;
    }
  }
}

unint64_t *sub_100273AC8(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[v10];
      do
      {
        sub_100273CA8((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    int v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        unint64_t v15 = *v14;
        if (*v14 > *a1)
        {
          unint64_t *v14 = *a1;
          *a1 = v15;
          sub_100273CA8((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = *a1;
        uint64_t v19 = a1;
        do
        {
          unint64_t v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            unint64_t v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            unint64_t v22 = *v20;
            unint64_t v23 = v20[1];
            if (*v20 >= v23) {
              unint64_t v22 = v20[1];
            }
            if (*v20 <= v23) {
              uint64_t v17 = v21;
            }
            else {
              ++v20;
            }
          }
          unint64_t *v19 = v22;
          uint64_t v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          unint64_t *v20 = v18;
        }
        else
        {
          unint64_t *v20 = *v6;
          *unint64_t v6 = v18;
          uint64_t v24 = (char *)v20 - (char *)a1 + 8;
          if (v24 >= 9)
          {
            unint64_t v25 = (((unint64_t)v24 >> 3) - 2) >> 1;
            unint64_t v26 = &a1[v25];
            unint64_t v27 = *v26;
            unint64_t v28 = *v20;
            if (*v26 > *v20)
            {
              do
              {
                unint64_t *v20 = v27;
                unint64_t v20 = v26;
                if (!v25) {
                  break;
                }
                unint64_t v25 = (v25 - 1) >> 1;
                unint64_t v26 = &a1[v25];
                unint64_t v27 = *v26;
              }
              while (*v26 > v28);
              unint64_t *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_100273CA8(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (unint64_t *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        unint64_t v10 = *v8;
      }
      else
      {
        unint64_t v10 = *v8;
        unint64_t v11 = v8[1];
        if (*v8 >= v11) {
          unint64_t v10 = v8[1];
        }
        if (*v8 > v11)
        {
          ++v8;
          uint64_t v7 = v9;
        }
      }
      unint64_t v12 = *a4;
      if (v10 <= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = (2 * v7) | 1;
          uint64_t v8 = (unint64_t *)(result + 8 * v13);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            unint64_t v10 = *v8;
            uint64_t v7 = v13;
          }
          else
          {
            unint64_t v10 = *v8;
            unint64_t v14 = v8[1];
            if (*v8 >= v14) {
              unint64_t v10 = v8[1];
            }
            if (*v8 <= v14) {
              uint64_t v7 = v13;
            }
            else {
              ++v8;
            }
          }
        }
        while (v10 <= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

void sub_100273D6C()
{
}

uint64_t sub_100273D84(uint64_t result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v10 = (int *)result;
LABEL_2:
  unint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    unint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int v22 = *(a2 - 1);
          int v23 = *v11;
          if (v22 < *v11)
          {
            int *v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = sub_100274180(v11, v11 + 1, a2 - 1);
          break;
        case 4uLL:
          uint64_t result = sub_1002744FC(v11, v11 + 1, v11 + 2, a2 - 1);
          break;
        case 5uLL:
          uint64_t result = sub_100274580(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 95) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_100274628(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x201)
    {
      sub_100274180(v11, &v11[v15 >> 1], a2 - 1);
      sub_100274180(v11 + 1, v17 - 1, a2 - 2);
      sub_100274180(v11 + 2, &v11[v16 + 1], a2 - 3);
      sub_100274180(v17 - 1, v17, &v11[v16 + 1]);
      int v18 = *v11;
      int *v11 = *v17;
      int *v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_100274180(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) >= *v11)
    {
      uint64_t result = (uint64_t)sub_100274208(v11, a2);
      unint64_t v11 = (int *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = sub_1002742B8(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_10027436C(v11, v19);
    unint64_t v11 = v19 + 1;
    uint64_t result = sub_10027436C(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = sub_100273D84(v10, v19, a3, -v13, a5 & 1);
      unint64_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  uint64_t v24 = v11 + 1;
  BOOL v26 = v11 == a2 || v24 == a2;
  if (a5)
  {
    if (!v26)
    {
      uint64_t v27 = 0;
      unint64_t v28 = v11;
      do
      {
        int v30 = *v28;
        int v29 = v28[1];
        unint64_t v28 = v24;
        if (v29 < v30)
        {
          uint64_t v31 = v27;
          while (1)
          {
            *(int *)((char *)v11 + v31 + 4) = v30;
            if (!v31) {
              break;
            }
            int v30 = *(int *)((char *)v11 + v31 - 4);
            v31 -= 4;
            if (v29 >= v30)
            {
              unint64_t v32 = (int *)((char *)v11 + v31 + 4);
              goto LABEL_50;
            }
          }
          unint64_t v32 = v11;
LABEL_50:
          *unint64_t v32 = v29;
        }
        uint64_t v24 = v28 + 1;
        v27 += 4;
      }
      while (v28 + 1 != a2);
    }
  }
  else if (!v26)
  {
    do
    {
      int v34 = *v10;
      int v33 = v10[1];
      unint64_t v10 = v24;
      if (v33 < v34)
      {
        do
        {
          *uint64_t v24 = v34;
          int v34 = *(v24 - 2);
          --v24;
        }
        while (v33 < v34);
        *uint64_t v24 = v33;
      }
      uint64_t v24 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t sub_100274180(int *a1, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a1;
  int v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    int v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int *sub_100274208(int *a1, int *a2)
{
  int v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    int v5 = a1 + 1;
    do
    {
      int v3 = v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    int v3 = a1;
    do
    {
      int v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < a2)
  {
    do
      int v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < a2)
  {
    int v7 = *v3;
    int v8 = *a2;
    do
    {
      int *v3 = v8;
      *a2 = v7;
      do
      {
        int v9 = v3[1];
        ++v3;
        int v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        int v10 = *--a2;
        int v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - 1) = v2;
  return v3;
}

int *sub_1002742B8(int *a1, int *a2)
{
  uint64_t v2 = 0;
  int v3 = *a1;
  do
    int v4 = a1[++v2];
  while (v4 < v3);
  int v5 = &a1[v2];
  int v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      int v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      int v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    int v9 = *a2;
    int v10 = &a1[v2];
    unint64_t v11 = a2;
    do
    {
      int *v10 = v9;
      int *v11 = v4;
      do
      {
        int v12 = v10[1];
        ++v10;
        int v4 = v12;
      }
      while (v12 < v3);
      do
      {
        int v13 = *--v11;
        int v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    int v6 = v10 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  *int v6 = v3;
  return v6;
}

BOOL sub_10027436C(int *a1, int *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 1);
      int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_100274180(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1002744FC(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_100274580(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      int v8 = a1 + 2;
      sub_100274180(a1, a1 + 1, a1 + 2);
      int v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 12;
      break;
  }
  while (1)
  {
    int v12 = *v9;
    int v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(int *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 4;
        if (v14 == 4) {
          break;
        }
        int v13 = *(int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          unint64_t v16 = (int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      unint64_t v16 = a1;
LABEL_12:
      int *v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    int v8 = v9;
    v11 += 4;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1002744FC(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t result = sub_100274180(a1, a2, a3);
  int v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    int v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      int v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t sub_100274580(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  uint64_t result = sub_1002744FC(a1, a2, a3, a4);
  int v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    int v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      int v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        int v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

int *sub_100274628(int *a1, int *a2, int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    int v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = &a1[v10];
      do
      {
        sub_100274808((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    int v13 = v6;
    if (v6 != a3)
    {
      int v14 = v6;
      do
      {
        int v15 = *v14;
        if (*v14 < *a1)
        {
          int *v14 = *a1;
          *a1 = v15;
          sub_100274808((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 5)
    {
      uint64_t v16 = (unint64_t)v8 >> 2;
      do
      {
        uint64_t v17 = 0;
        int v18 = *a1;
        uint64_t v19 = a1;
        do
        {
          char v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            int v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            int v22 = *v20;
            int v23 = v20[1];
            if (*v20 <= v23) {
              int v22 = v20[1];
            }
            if (*v20 >= v23) {
              uint64_t v17 = v21;
            }
            else {
              ++v20;
            }
          }
          int *v19 = v22;
          uint64_t v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          int *v20 = v18;
        }
        else
        {
          int *v20 = *v6;
          *int v6 = v18;
          uint64_t v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            unint64_t v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            BOOL v26 = &a1[v25];
            int v27 = *v26;
            int v28 = *v20;
            if (*v26 < *v20)
            {
              do
              {
                int *v20 = v27;
                char v20 = v26;
                if (!v25) {
                  break;
                }
                unint64_t v25 = (v25 - 1) >> 1;
                BOOL v26 = &a1[v25];
                int v27 = *v26;
              }
              while (*v26 < v28);
              int *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_100274808(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      uint64_t v6 = v4 >> 1;
      uint64_t v7 = (v4 >> 1) + 1;
      uint64_t v8 = (int *)(result + 4 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        int v10 = *v8;
      }
      else
      {
        int v10 = *v8;
        int v11 = v8[1];
        if (*v8 <= v11) {
          int v10 = v8[1];
        }
        if (*v8 < v11)
        {
          ++v8;
          uint64_t v7 = v9;
        }
      }
      int v12 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = (2 * v7) | 1;
          uint64_t v8 = (int *)(result + 4 * v13);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            int v10 = *v8;
            uint64_t v7 = v13;
          }
          else
          {
            int v10 = *v8;
            int v14 = v8[1];
            if (*v8 <= v14) {
              int v10 = v8[1];
            }
            if (*v8 >= v14) {
              uint64_t v7 = v13;
            }
            else {
              ++v8;
            }
          }
        }
        while (v10 >= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

uint64_t **sub_1002748CC(uint64_t **a1, long long *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  uint64_t v6 = *a1;
  unint64_t v9 = v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if (v5 >= v9)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *v4) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *v4) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    v20[4] = v7;
    if (v15) {
      uint64_t v16 = (char *)sub_1000DA5D8(v7, v15);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v17 = &v16[24 * v12];
    v20[0] = v16;
    v20[1] = v17;
    v20[3] = &v16[24 * v15];
    long long v18 = *a2;
    *((void *)v17 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v17 = v18;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    v20[2] = v17 + 24;
    sub_1001D7FEC(v4, v20);
    uint64_t v11 = v4[1];
    sub_1001D8184((uint64_t)v20);
  }
  else
  {
    long long v10 = *a2;
    *(void *)(v5 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v5 = v10;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    uint64_t v11 = v5 + 24;
    v4[1] = v5 + 24;
  }
  v4[1] = v11;
  return a1;
}

void sub_100274A00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001D8184((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100274A14(int a1, int a2, int a3)
{
  uint64_t v3 = 2;
  if (!a1) {
    uint64_t v3 = 0;
  }
  if (a2) {
    v3 |= 0x20uLL;
  }
  if (a3) {
    return v3 | 0x40;
  }
  else {
    return v3;
  }
}

uint64_t sub_100274A3C(uint64_t a1, int a2, int a3, double a4)
{
  uint64_t v4 = 0;
  if ((a2 & 0x80000000) == 0 && (a3 & 0x80000000) == 0)
  {
    int v5 = *(_DWORD *)(a1 + 12);
    if (v5 > a2)
    {
      if (*(_DWORD *)(a1 + 16) <= a3)
      {
        return 0;
      }
      else
      {
        *(double *)(*(void *)a1 + 8 * (a2 + v5 * a3)) = a4;
        *(unsigned char *)(a1 + 8) = 0;
        return 1;
      }
    }
  }
  return v4;
}

void sub_100274A84(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  operator new[]();
}

void sub_100274B10(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0;
  if (v3) {
    operator delete[]();
  }
  _Unwind_Resume(exception_object);
}

void sub_100274B40(void *a1)
{
  *a1 = 0;
  operator new[]();
}

void sub_100274BDC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0;
  if (v3) {
    operator delete[]();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100274C0C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)a1 = v3;
  *(_WORD *)(a1 + 8) = *((_WORD *)a2 + 4);
  *(void *)(a1 + 12) = *(uint64_t *)((char *)a2 + 12);
  uint64_t v4 = *a2;
  *a2 = 0;
  if (v4) {
    operator delete[]();
  }
  *((_WORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  return a1;
}

uint64_t sub_100274C7C(uint64_t result, uint64_t a2)
{
  if (result != a2) {
    operator new[]();
  }
  return result;
}

uint64_t *sub_100274D1C(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *a1;
    *a1 = 0;
    if (v3) {
      operator delete[]();
    }
    uint64_t v4 = *a2;
    *a2 = 0;
    uint64_t v5 = *a1;
    *a1 = v4;
    if (v5) {
      operator delete[]();
    }
    *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
    *(uint64_t *)((char *)a1 + 12) = *(uint64_t *)((char *)a2 + 12);
    uint64_t v6 = *a2;
    *a2 = 0;
    if (v6) {
      operator delete[]();
    }
    *((_WORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 3) = 0;
    *((_DWORD *)a2 + 4) = 0;
  }
  return a1;
}

uint64_t sub_100274DCC@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, unsigned char *a3@<X8>)
{
  *a3 = 0;
  a3[24] = 0;
  unsigned int v3 = *(_DWORD *)(result + 16);
  if (v3 > a2) {
    sub_100274A84((uint64_t)v4, *(_DWORD *)(result + 12), v3 - a2);
  }
  return result;
}

void sub_100274E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    operator delete[]();
  }
  if (*((unsigned char *)v10 + 24))
  {
    uint64_t v12 = *v10;
    uint64_t *v10 = 0;
    if (v12) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100274ED4(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 24)) {
    return sub_100274D1C((uint64_t *)a1, a2);
  }
  uint64_t result = (uint64_t *)sub_100274C0C(a1, a2);
  *((unsigned char *)result + 24) = 1;
  return result;
}

uint64_t sub_100274F04(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2 < 0) {
    return 0;
  }
  uint64_t result = 0;
  if ((a3 & 0x80000000) == 0)
  {
    int v6 = *(_DWORD *)(a1 + 12);
    if (v6 > a2)
    {
      if (*(_DWORD *)(a1 + 16) > a3)
      {
        *a4 = *(void *)(*(void *)a1 + 8 * (a2 + v6 * a3));
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_100274F4C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (!v3) {
    goto LABEL_24;
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    if (v4 == 1)
    {
      if ((int)v3 >= 1)
      {
        uint64_t v5 = *(void **)a1;
        do
        {
          *v5++ = 0x3FF0000000000000;
          --v3;
        }
        while (v3);
      }
LABEL_24:
      uint64_t result = 1;
      *(unsigned char *)(a1 + 8) = 1;
      return result;
    }
    if ((int)v3 < 1) {
      goto LABEL_24;
    }
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    char v8 = 1;
    do
    {
      double v9 = cblas_dnrm2(*(_DWORD *)(a1 + 16), (const double *)(*(void *)a1 + v6), v3);
      if (v9 == 0.0)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2740);
        }
        long long v10 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 68289282;
          int v13 = 0;
          __int16 v14 = 2082;
          unint64_t v15 = "";
          __int16 v16 = 1026;
          int v17 = v7;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2740);
          }
        }
        uint64_t v11 = qword_102419458;
        if (os_signpost_enabled((os_log_t)qword_102419458))
        {
          *(_DWORD *)buf = 68289282;
          int v13 = 0;
          __int16 v14 = 2082;
          unint64_t v15 = "";
          __int16 v16 = 1026;
          int v17 = v7;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ProbabilityMatrix::normalizeRows, row with zero norm!", "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
        }
        char v8 = 0;
      }
      else
      {
        cblas_dscal(*(_DWORD *)(a1 + 16), 1.0 / v9, (double *)(*(void *)a1 + v6), *(_DWORD *)(a1 + 12));
      }
      ++v7;
      uint64_t v3 = *(int *)(a1 + 12);
      v6 += 8;
    }
    while (v7 < v3);
    if (v8) {
      goto LABEL_24;
    }
  }
  return 0;
}

uint64_t sub_1002751AC@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v4 = 12;
  if (!*(unsigned char *)(result + 9)) {
    uint64_t v4 = 16;
  }
  int v5 = *(_DWORD *)(result + v4);
  if (*(unsigned char *)(a2 + 9)) {
    int v6 = *(_DWORD *)(a2 + 16);
  }
  else {
    int v6 = *(_DWORD *)(a2 + 12);
  }
  if (v5 == v6)
  {
    int v7 = *(unsigned char *)(a2 + 9) ? *(_DWORD *)(a2 + 12) : *(_DWORD *)(a2 + 16);
    if (v5 == 1 || v7 == 1)
    {
      uint64_t v9 = 16;
      if (!*(unsigned char *)(result + 9)) {
        uint64_t v9 = 12;
      }
      int v10 = *(_DWORD *)(result + v9);
      if (v5) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11 && v7 != 0) {
        sub_100274A84((uint64_t)&v13, v10, v7);
      }
    }
  }
  *a3 = 0;
  a3[24] = 0;
  return result;
}

void sub_1002752D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    operator delete[]();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100275300(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_DWORD *)(a2 + 16) == *(_DWORD *)(a1 + 16))
  {
    unsigned int v6 = *(_DWORD *)(a2 + 12);
    if (a3 >= v6)
    {
      if (a3 != v6)
      {
        if (*(_DWORD *)(a1 + 12) + v6 <= a3) {
          int v19 = *(_DWORD *)(a1 + 12);
        }
        else {
          int v19 = a3 - v6;
        }
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2740);
        }
        char v20 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v21 = *(_DWORD *)(a1 + 12);
          int v22 = *(_DWORD *)(a2 + 16);
          *(_DWORD *)buf = 68289794;
          int v24 = 0;
          __int16 v25 = 2082;
          BOOL v26 = "";
          __int16 v27 = 1026;
          unsigned int v28 = v21;
          __int16 v29 = 1026;
          int v30 = v19;
          __int16 v31 = 1026;
          int v32 = v22;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appending rows\", \"NumOldRows\":%{public}d, \"NumOldRowsToKeep\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x24u);
        }
        operator new[]();
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2740);
      }
      int v17 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 68289538;
        int v24 = 0;
        __int16 v25 = 2082;
        BOOL v26 = "";
        __int16 v27 = 1026;
        unsigned int v28 = a3;
        __int16 v29 = 1026;
        int v30 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"rows to append are max length - copy\", \"MaxNumRows\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x1Eu);
      }
      sub_100274C7C(a1, a2);
      return 1;
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2740);
      }
      uint64_t v7 = qword_102419458;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v8)
      {
        int v10 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 68289538;
        int v24 = 0;
        __int16 v25 = 2082;
        BOOL v26 = "";
        __int16 v27 = 1026;
        unsigned int v28 = a3;
        __int16 v29 = 1026;
        int v30 = v10;
        BOOL v11 = "{\"msg%{public}.0s\":\"cannot append rows more rows than allowed\", \"MaxNumRows\":%{public}d, \"NumRowsTo"
              "Append\":%{public}d}";
        uint64_t v12 = v7;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, 0x1Eu);
        return 0;
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2740);
    }
    uint64_t v13 = qword_102419458;
    BOOL v14 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v14)
    {
      unsigned int v15 = *(_DWORD *)(a1 + 16);
      int v16 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)buf = 68289538;
      int v24 = 0;
      __int16 v25 = 2082;
      BOOL v26 = "";
      __int16 v27 = 1026;
      unsigned int v28 = v15;
      __int16 v29 = 1026;
      int v30 = v16;
      BOOL v11 = "{\"msg%{public}.0s\":\"cannot append rows with incompatible number of columns\", \"NumColumns\":%{public}d, "
            "\"OtherNumColumns\":%{public}d}";
      uint64_t v12 = v13;
      goto LABEL_11;
    }
  }
  return result;
}

void *sub_100275744@<X0>(char a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, (&off_1022A2760)[a1]);
}

__n128 sub_10027575C(uint64_t a1, char a2, char a3, char a4, uint64_t a5, __n128 *a6, double a7)
{
  *(double *)a1 = a7;
  *(unsigned char *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 9) = a3;
  *(unsigned char *)(a1 + 10) = a4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a5;
  *(void *)(a1 + 32) = *(void *)(a5 + 16);
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  __n128 result = *a6;
  *(__n128 *)(a1 + 40) = *a6;
  *(void *)(a1 + 56) = a6[1].n128_u64[0];
  a6->n128_u64[0] = 0;
  a6->n128_u64[1] = 0;
  a6[1].n128_u64[0] = 0;
  return result;
}

void *sub_1002757B0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, (&off_1022A2778)[a1]);
}

unint64_t sub_1002757C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  unint64_t result = 0;
  do
    result ^= (result << 6) + (result >> 2) + 2654435769u + *(unsigned __int8 *)(a2 + v2++);
  while (v2 != 16);
  return result;
}

uint64_t sub_1002757FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 == *(void *)a3 && *(void *)(a2 + 8) == *(void *)(a3 + 8)) {
    return sub_100275824((unsigned __int8 *)(a2 + 16), (unsigned __int8 *)(a3 + 16));
  }
  else {
    return 0;
  }
}

uint64_t sub_100275824(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1[24]) {
    BOOL v2 = a2[24] == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (a1[24] != 0) == (a2[24] != 0);
  }
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a1[23];
  }
  else {
    uint64_t v5 = *((void *)a1 + 1);
  }
  uint64_t v6 = a2[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 != v6) {
    return 0;
  }
  if (v7 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v4 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v8 = v4 - 1;
  do
  {
    int v10 = *a1++;
    int v9 = v10;
    int v12 = *a2++;
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    BOOL v2 = v9 == v11;
    BOOL v3 = v9 == v11;
  }
  while (v2 && v14);
  return v3;
}

unint64_t sub_1002758F8(int a1)
{
  if ((a1 - 1) > 3) {
    return 0;
  }
  else {
    return qword_101D07528[a1 - 1] | (unint64_t)&_mh_execute_header;
  }
}

BOOL sub_100275920(int a1)
{
  return a1 == 1;
}

void sub_10027592C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10027595C(uint64_t *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  if (*((unsigned char *)a1 + 16)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = *((unsigned char *)a1 + 9) == 0;
  }
  int v7 = !v6;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27B8);
  }
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *a1;
      int v10 = *((unsigned __int8 *)a1 + 8);
      int v11 = *((unsigned __int8 *)a1 + 9);
      int v12 = *((_DWORD *)a1 + 3);
      int v13 = *((unsigned __int8 *)a1 + 16);
      *(_DWORD *)buf = 68290563;
      int v18 = 0;
      __int16 v19 = 2082;
      char v20 = "";
      __int16 v21 = 2049;
      uint64_t v22 = v9;
      __int16 v23 = 1025;
      int v24 = v10;
      __int16 v25 = 1025;
      int v26 = v11;
      __int16 v27 = 1025;
      int v28 = v12;
      __int16 v29 = 1025;
      int v30 = v13;
      __int16 v31 = 1025;
      int v32 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"batterylevel\", \"level\":\"%{private}f\", \"charged\":%{private}d, \"connected\":%{private}d, \"chargerType\":%{private}d, \"wasConnected\":%{private}d, \"isNewlyConnected\":%{private}d}", buf, 0x3Au);
    }
  }
  double v14 = *a2;
  sub_10023D9B0((uint64_t)v15);
  sub_100275B74((uint64_t)v15, 0, 0, 3u, (uint64_t)v16, v14);
  buf[0] = v7;
  sub_1002660C8(&v19);
  *a3 = buf[0];
  sub_1002660C8(a3 + 8);
  sub_10026633C(&v19);
  sub_10026633C(v16);
  sub_100250238((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_100275B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  sub_10026633C(v12);
  sub_10026633C(&a12);
  sub_100250238((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

void sub_100275B74(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (!sub_10023E774(v12))
  {
    double v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    double v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E6414(a5, a1);
}

void sub_100275C5C(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_100275C70(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100275CA0(uint64_t a1)
{
  *(_DWORD *)(a1 + 12) = 0;
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  sub_1003335FC(a1 + 16);
  *(_OWORD *)(a1 + 232) = 0u;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 192) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 1065353216;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  sub_1000C7F88(&v7);
  memset(&v6, 0, sizeof(v6));
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsVersion", 0x8000100u, kCFAllocatorNull);
  BOOL v3 = sub_1000A7CF8(v7, (uint64_t)v2, &v6);
  CFRelease(v2);
  if (v3)
  {
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
      sub_1000DC48C(&__p, v6.__r_.__value_.__l.__data_, v6.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v6;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_1000DC48C((unsigned char *)(a1 + 328), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      *(std::string *)(a1 + 328) = __p;
    }
  }
  else
  {
    sub_100134750((void *)(a1 + 328), "2.0.9");
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  if (v8) {
    sub_1000DB0A0(v8);
  }
  return a1;
}

void sub_100275E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a22) {
    sub_1000DB0A0(a22);
  }
  int v26 = *(void **)(v22 + 304);
  if (v26)
  {
    *(void *)(v22 + 312) = v26;
    operator delete(v26);
  }
  sub_1001EF1F0(v22 + 256);
  sub_1001EF278((void ***)&a15);
  sub_1001EF318(v24);
  sub_1000D7D80(v23);
  _Unwind_Resume(a1);
}

std::string *sub_100275EA0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_10023D838(a2);
  uint64_t v4 = *(void *)(a1 + 232);
  for (uint64_t i = *(void *)(a1 + 240); v4 != i; v4 += 32)
  {
    int v6 = *(_DWORD *)(a2 + 20);
    uint64_t v7 = *(int *)(a2 + 16);
    if ((int)v7 >= v6)
    {
      if (v6 == *(_DWORD *)(a2 + 24))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8), v6 + 1);
        int v6 = *(_DWORD *)(a2 + 20);
      }
      *(_DWORD *)(a2 + 20) = v6 + 1;
      sub_10027C01C();
    }
    uint64_t v8 = *(void *)(a2 + 8);
    *(_DWORD *)(a2 + 16) = v7 + 1;
    uint64_t v9 = *(void *)(v8 + 8 * v7);
    uint64_t v10 = *(void *)v4;
    long long v52 = *(_OWORD *)(v4 + 16);
    char v53 = 1;
    sub_1003215C4(v10, (uint64_t)&v52, (uint64_t)&__str);
    sub_1002463A8(v9, (uint64_t)&__str);
    sub_100245708(&__str);
  }
  for (j = *(void **)(a1 + 272); j; j = (void *)*j)
  {
    int v12 = *(_DWORD *)(a2 + 68);
    uint64_t v13 = *(int *)(a2 + 64);
    if ((int)v13 >= v12)
    {
      if (v12 == *(_DWORD *)(a2 + 72))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 56), v12 + 1);
        int v12 = *(_DWORD *)(a2 + 68);
      }
      *(_DWORD *)(a2 + 68) = v12 + 1;
      sub_10027C080();
    }
    uint64_t v14 = *(void *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = v13 + 1;
    uint64_t v15 = *(void *)(v14 + 8 * v13);
    uint64_t v16 = 0;
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 16;
    do
    {
      __str.__r_.__value_.__s.__data_[v16] = *((unsigned char *)j + v16 + 16);
      ++v16;
    }
    while (v16 != 16);
    __str.__r_.__value_.__s.__data_[16] = 0;
    *(_DWORD *)(v15 + 44) |= 1u;
    int v17 = *(std::string **)(v15 + 8);
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    int v18 = std::string::operator=(v17, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    uint64_t v20 = j[4];
    for (uint64_t k = j[5]; v20 != k; v20 += 16)
    {
      uint64_t v21 = 0;
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v21] = *(unsigned char *)(v20 + v21);
        ++v21;
      }
      while (v21 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      int v22 = *(_DWORD *)(v15 + 28);
      uint64_t v23 = *(int *)(v15 + 24);
      if ((int)v23 >= v22)
      {
        if (v22 == *(_DWORD *)(v15 + 32))
        {
          int v18 = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v15 + 16), v22 + 1);
          int v22 = *(_DWORD *)(v15 + 28);
        }
        *(_DWORD *)(v15 + 28) = v22 + 1;
        __int16 v25 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)v18);
        uint64_t v26 = *(void *)(v15 + 16);
        uint64_t v27 = *(int *)(v15 + 24);
        *(_DWORD *)(v15 + 24) = v27 + 1;
        *(void *)(v26 + 8 * v27) = v25;
      }
      else
      {
        uint64_t v24 = *(void *)(v15 + 16);
        *(_DWORD *)(v15 + 24) = v23 + 1;
        __int16 v25 = *(std::string **)(v24 + 8 * v23);
      }
      int v18 = std::string::operator=(v25, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v28 = *(void *)(a1 + 280);
  *(_DWORD *)(a2 + 192) |= 2u;
  *(void *)(a2 + 32) = v28;
  unsigned int v29 = *(_DWORD *)a1;
  if (!sub_1001A4C58(*(_DWORD *)a1))
  {
    unint64_t v47 = "::CLMicroLocationProto::Model_GenerationAlgorithm_IsValid(value)";
    int v48 = 12260;
    unint64_t v49 = "set_generationalgorithm";
    goto LABEL_57;
  }
  *(_DWORD *)(a2 + 192) |= 8u;
  *(_DWORD *)(a2 + 48) = v29;
  unsigned int v30 = *(_DWORD *)(a1 + 4);
  if (!sub_100165F14(v30))
  {
    unint64_t v47 = "::CLMicroLocationProto::Model_ModelType_IsValid(value)";
    int v48 = 12283;
    unint64_t v49 = "set_modeltype";
LABEL_57:
    __assert_rtn(v49, "microlocation.pb.h", v48, v47);
  }
  *(_DWORD *)(a2 + 192) |= 0x10u;
  *(_DWORD *)(a2 + 52) = v30;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  __int16 v31 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    BOOL v32 = sub_1002765B0(a1);
    __str.__r_.__value_.__r.__words[0] = 68289282;
    LOWORD(__str.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(__str.__r_.__value_.__r.__words[2]) = 1026;
    HIDWORD(__str.__r_.__value_.__r.__words[2]) = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, toProtobuf\", \"isStableflag\":%{public}hhd}", (uint8_t *)&__str, 0x18u);
  }
  BOOL v33 = sub_1002765B0(a1);
  int v34 = *(_DWORD *)(a2 + 192);
  *(unsigned char *)(a2 + 104) = v33;
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 192) = v34 | 0x380;
  unint64_t v35 = *(_DWORD **)(a2 + 112);
  if (!v35) {
    operator new();
  }
  sub_10033389C(a1 + 16, (int *)&__str);
  sub_100248404(v35, (uint64_t)&__str);
  sub_100247FA8((uint64_t *)&__str);
  unsigned int v36 = *(_DWORD *)(a1 + 296);
  if (!sub_100165F14(v36))
  {
    int v50 = 12484;
    unint64_t v51 = "set_qualityindicator";
    goto LABEL_60;
  }
  *(_DWORD *)(a2 + 192) |= 0x800u;
  *(_DWORD *)(a2 + 128) = v36;
  unsigned int v37 = *(_DWORD *)(a1 + 300);
  if (!sub_100165F14(v37))
  {
    int v50 = 12507;
    unint64_t v51 = "set_candidatequalityindicator";
LABEL_60:
    __assert_rtn(v51, "microlocation.pb.h", v50, "::CLMicroLocationProto::Model_ModelQualityLevel_IsValid(value)");
  }
  *(_DWORD *)(a2 + 192) |= 0x1000u;
  *(_DWORD *)(a2 + 132) = v37;
  unint64_t v38 = *(unsigned int **)(a1 + 304);
  for (m = *(unsigned int **)(a1 + 312); v38 != m; ++v38)
  {
    unsigned int v40 = *v38;
    if (!sub_10023E768(*v38)) {
      __assert_rtn("add_candidatequalityreasons", "microlocation.pb.h", 12527, "::CLMicroLocationProto::ServiceQualityReasonEnum_IsValid(value)");
    }
    int v41 = *(_DWORD *)(a2 + 144);
    if (v41 == *(_DWORD *)(a2 + 148))
    {
      sub_100221DFC(a2 + 136, v41 + 1);
      int v41 = *(_DWORD *)(a2 + 144);
    }
    uint64_t v42 = *(void *)(a2 + 136);
    *(_DWORD *)(a2 + 144) = v41 + 1;
    *(_DWORD *)(v42 + 4 * v41) = v40;
  }
  if (*(_DWORD *)(a1 + 4) == 2 && *(unsigned char *)(a1 + 192))
  {
    *(_DWORD *)(a2 + 192) |= 0x400u;
    uint64_t v43 = *(void *)(a2 + 120);
    if (!v43) {
      operator new();
    }
    sub_10027684C((uint64_t *)(a1 + 72), (uint64_t)&__str);
    sub_10024AC18(v43, (uint64_t)&__str);
    sub_10024A4B0((uint64_t)&__str);
  }
  int v44 = *(_DWORD *)(a2 + 192);
  *(_OWORD *)(a2 + 152) = *(_OWORD *)(a1 + 200);
  *(void *)(a2 + 168) = *(void *)(a1 + 216);
  *(_DWORD *)(a2 + 184) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(a2 + 192) = v44 | 0x3FC000;
  unint64_t v45 = *(std::string **)(a2 + 176);
  if (v45 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  return std::string::operator=(v45, (const std::string *)(a1 + 328));
}

void sub_1002764E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_1002765A8(uint64_t a1)
{
  return *(void *)(a1 + 280);
}

BOOL sub_1002765B0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 2) {
    return *(unsigned char *)(a1 + 8) != 0;
  }
  BOOL v3 = *(void **)(a1 + 272);
  if (v3)
  {
    unint64_t v4 = 0;
    do
    {
      v4 += (uint64_t)(v3[5] - v3[4]) >> 4;
      BOOL v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    unint64_t v4 = 0;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  uint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(unsigned int *)(a1 + 12);
    int v7 = *(unsigned __int8 *)(a1 + 8);
    *(_DWORD *)buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)__int16 v19 = 2082;
    *(void *)&v19[2] = "";
    __int16 v20 = 2050;
    unint64_t v21 = v4;
    __int16 v22 = 2050;
    uint64_t v23 = v6;
    __int16 v24 = 1026;
    int v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, getter\", \"numRecordingsBeforePruning\":%{public}ld, \"numDaysWithRecordings\":%{public}ld, \"fIsStable\":%{public}hhd}", buf, 0x2Cu);
  }
  if (*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  sub_1000C7F88(buf);
  unsigned int v17 = 0;
  CFStringRef v8 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  int v9 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v8, &v17);
  CFRelease(v8);
  unint64_t v10 = v17;
  if (*(void *)v19) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v19);
  }
  unint64_t v11 = 200;
  if (v9) {
    unint64_t v11 = v10;
  }
  if (v4 >= v11) {
    return 1;
  }
  unint64_t v12 = *(unsigned int *)(a1 + 12);
  sub_1000C7F88(buf);
  unsigned int v17 = 0;
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  int v14 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v13, &v17);
  CFRelease(v13);
  unint64_t v15 = v17;
  if (*(void *)v19) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v19);
  }
  unint64_t v16 = 10;
  if (v14) {
    unint64_t v16 = v15;
  }
  return v16 <= v12;
}

void sub_100276808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100276834(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t sub_10027683C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t sub_100276844(uint64_t a1)
{
  return a1 + 304;
}

void sub_10027684C(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)sub_10023D800(a2);
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (*a1 != v6)
  {
    do
    {
      uint64_t v7 = 0;
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v7] = *(unsigned char *)(v5 + v7);
        ++v7;
      }
      while (v7 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      int v8 = *(_DWORD *)(a2 + 20);
      uint64_t v9 = *(int *)(a2 + 16);
      if ((int)v9 >= v8)
      {
        if (v8 == *(_DWORD *)(a2 + 24))
        {
          unint64_t v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8), v8 + 1);
          int v8 = *(_DWORD *)(a2 + 20);
        }
        *(_DWORD *)(a2 + 20) = v8 + 1;
        unint64_t v11 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        uint64_t v12 = *(void *)(a2 + 8);
        uint64_t v13 = *(int *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = v13 + 1;
        *(void *)(v12 + 8 * v13) = v11;
      }
      else
      {
        uint64_t v10 = *(void *)(a2 + 8);
        *(_DWORD *)(a2 + 16) = v9 + 1;
        unint64_t v11 = *(std::string **)(v10 + 8 * v9);
      }
      unint64_t v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v11, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      v5 += 16;
    }
    while (v5 != v6);
  }
  int v14 = (unsigned int *)a1[10];
  for (uint64_t i = (unsigned int *)a1[11]; v14 != i; ++v14)
  {
    unsigned int v16 = *v14;
    if ((sub_10023E744(*v14) & 1) == 0) {
      __assert_rtn("add_eventconfidences", "microlocation.pb.h", 12157, "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)");
    }
    int v17 = *(_DWORD *)(a2 + 64);
    if (v17 == *(_DWORD *)(a2 + 68))
    {
      sub_100221DFC(a2 + 56, v17 + 1);
      int v17 = *(_DWORD *)(a2 + 64);
    }
    uint64_t v18 = *(void *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = v17 + 1;
    *(_DWORD *)(v18 + 4 * v17) = v16;
  }
  uint64_t v19 = a1[3];
  if (a1[4] != v19)
  {
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    do
    {
      int v22 = *(_DWORD *)(a2 + 44);
      uint64_t v23 = *(int *)(a2 + 40);
      if ((int)v23 >= v22)
      {
        if (v22 == *(_DWORD *)(a2 + 48))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 32), v22 + 1);
          int v22 = *(_DWORD *)(a2 + 44);
        }
        *(_DWORD *)(a2 + 44) = v22 + 1;
        sub_10027C1A4();
      }
      uint64_t v24 = *(void *)(a2 + 32);
      *(_DWORD *)(a2 + 40) = v23 + 1;
      uint64_t v25 = *(void *)(v24 + 8 * v23);
      uint64_t v26 = 0;
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = 16;
      uint64_t v27 = v19 + v20;
      do
      {
        __str.__r_.__value_.__s.__data_[v26] = *(unsigned char *)(v27 + v26);
        ++v26;
      }
      while (v26 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      *(_DWORD *)(v25 + 36) |= 1u;
      uint64_t v28 = *(std::string **)(v25 + 8);
      if (v28 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v28, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      if (a1[1] != *a1)
      {
        unint64_t v29 = 0;
        do
        {
          __str.__r_.__value_.__r.__words[0] = 0;
          sub_100274F04((uint64_t)(a1 + 6), v21, v29, &__str);
          std::string::size_type v30 = __str.__r_.__value_.__r.__words[0];
          int v31 = *(_DWORD *)(v25 + 24);
          if (v31 == *(_DWORD *)(v25 + 28))
          {
            sub_10026DE30(v25 + 16, v31 + 1);
            int v31 = *(_DWORD *)(v25 + 24);
          }
          uint64_t v32 = *(void *)(v25 + 16);
          *(_DWORD *)(v25 + 24) = v31 + 1;
          *(void *)(v32 + 8 * v31) = v30;
          ++v29;
        }
        while (v29 < (a1[1] - *a1) >> 4);
      }
      ++v21;
      uint64_t v19 = a1[3];
      v20 += 16;
    }
    while (v21 < (a1[4] - v19) >> 4);
  }
}

void sub_100276B78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10024A4B0(v15);
  _Unwind_Resume(a1);
}

void sub_100276BB4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_100275CA0(a3);
  long long v82 = 0uLL;
  long long v81 = 0uLL;
  uint64_t v65 = a1;
  uint64_t v6 = *(int *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 8);
    uint64_t v8 = 8 * v6;
    while (1)
    {
      uint64_t v9 = *v7;
      int v10 = *(_DWORD *)(*v7 + 104);
      if ((v10 & 0x20) != 0) {
        break;
      }
      if ((v10 & 2) != 0)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A27D8);
        }
        int v14 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint is using a deprecated uint64 cluster label", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A27D8);
          }
          LOWORD(v68[0]) = 0;
          unsigned int v16 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v16);
          if (v16 != (char *)buf) {
            free(v16);
          }
        }
        *(void *)&long long v82 = *(void *)(v9 + 32);
        goto LABEL_24;
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
      unint64_t v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a cluster identifer", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 == -1)
        {
LABEL_39:
          LOWORD(v68[0]) = 0;
          int v17 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v17);
          if (v17 != (char *)buf) {
            free(v17);
          }
          goto LABEL_32;
        }
LABEL_41:
        dispatch_once(&qword_102419450, &stru_1022A27D8);
        goto LABEL_39;
      }
LABEL_32:
      ++v7;
      v8 -= 8;
      if (!v8) {
        goto LABEL_42;
      }
    }
    uint64_t v12 = *(uint64_t ***)(v9 + 64);
    int v13 = *((char *)v12 + 23);
    if (v13 < 0)
    {
      if (v12[1] == (uint64_t *)16)
      {
        uint64_t v12 = (uint64_t **)*v12;
LABEL_23:
        long long v82 = *(_OWORD *)v12;
LABEL_24:
        sub_10031FA74((uint64_t)buf, v9);
        sub_100277998(a3, (uint64_t)buf, &v82, a2);
        if (__p)
        {
          uint64_t v80 = __p;
          operator delete(__p);
        }
        sub_1000D7D80((uint64_t)v78);
        sub_1000D7D80((uint64_t)v74);
        sub_1001F00CC((uint64_t)buf);
        goto LABEL_32;
      }
    }
    else if (v13 == 16)
    {
      goto LABEL_23;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A27D8);
    }
    uint64_t v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a valid cluster label uuid", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_32;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_39;
    }
    goto LABEL_41;
  }
LABEL_42:
  uint64_t v18 = *(int *)(v65 + 64);
  if (v18)
  {
    uint64_t v19 = *(uint64_t **)(v65 + 56);
    uint64_t v20 = &v19[v18];
    while (1)
    {
      uint64_t v21 = *v19;
      int v22 = *(uint64_t ***)(*v19 + 8);
      int v23 = *((char *)v22 + 23);
      if (v23 < 0)
      {
        if (v22[1] != (uint64_t *)16)
        {
LABEL_68:
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A27D8);
          }
          int v31 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid cluster label uuid", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A27D8);
            }
            LOWORD(v68[0]) = 0;
            uint64_t v32 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v32);
            if (v32 != (char *)buf) {
              free(v32);
            }
          }
          goto LABEL_73;
        }
        int v22 = (uint64_t **)*v22;
      }
      else if (v23 != 16)
      {
        goto LABEL_68;
      }
      long long v82 = *(_OWORD *)v22;
      uint64_t v24 = *(int *)(v21 + 24);
      if (v24) {
        break;
      }
LABEL_73:
      if (++v19 == v20) {
        goto LABEL_79;
      }
    }
    uint64_t v25 = *(void *)(v21 + 16);
    uint64_t v26 = 8 * v24;
    while (1)
    {
      uint64_t v27 = *(void **)v25;
      int v28 = *(char *)(*(void *)v25 + 23);
      if (v28 < 0)
      {
        if (v27[1] != 16)
        {
LABEL_57:
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A27D8);
          }
          unint64_t v29 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid recording uuid", buf, 2u);
          }
          if (sub_10013D1A0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A27D8);
            }
            LOWORD(v68[0]) = 0;
            std::string::size_type v30 = (char *)_os_log_send_and_compose_impl();
            sub_1004BA5E4("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v30);
            if (v30 != (char *)buf) {
              free(v30);
            }
          }
          goto LABEL_62;
        }
        uint64_t v27 = (void *)*v27;
      }
      else if (v28 != 16)
      {
        goto LABEL_57;
      }
      long long v81 = *(_OWORD *)v27;
      sub_100277A74(a3, &v82, &v81);
LABEL_62:
      v25 += 8;
      v26 -= 8;
      if (!v26) {
        goto LABEL_73;
      }
    }
  }
LABEL_79:
  uint64_t v33 = v65;
  int v34 = *(_DWORD *)(v65 + 52) & ((int)(*(_DWORD *)(v65 + 192) << 27) >> 31);
  *(_DWORD *)a3 = *(_DWORD *)(v65 + 48);
  *(_DWORD *)(a3 + 4) = v34;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  unint64_t v35 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    int v36 = *(unsigned __int8 *)(v65 + 104);
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v36;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, fromProtobuf\", \"isStableFlag\":%{public}hhd}", buf, 0x18u);
  }
  *(unsigned char *)(a3 + 8) = *(unsigned char *)(v65 + 104);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v65 + 108);
  if (*(unsigned char *)(v65 + 193))
  {
    uint64_t v37 = *(void *)(v65 + 112);
    if (!v37) {
      uint64_t v37 = *(void *)(qword_1024899C0 + 112);
    }
    sub_100333654((uint64_t)buf, v37);
    if ((uint8_t *)(a3 + 16) != buf)
    {
      *(_DWORD *)(a3 + 48) = *(_DWORD *)&buf[32];
      sub_1001EEAA8((void *)(a3 + 16), *(uint64_t **)&buf[16], 0);
    }
    *(_OWORD *)(a3 + 56) = *(_OWORD *)&buf[40];
    sub_1000D7D80((uint64_t)buf);
  }
  int v38 = *(_DWORD *)(v65 + 128);
  *(_DWORD *)(a3 + 296) = v38;
  if (!v38)
  {
    unint64_t v39 = *(void **)(a3 + 272);
    if (v39)
    {
      unint64_t v40 = 0;
      do
      {
        v40 += (uint64_t)(v39[5] - v39[4]) >> 4;
        unint64_t v39 = (void *)*v39;
      }
      while (v39);
    }
    else
    {
      unint64_t v40 = 0;
    }
    sub_1000C7F88(buf);
    v68[0] = 0;
    CFStringRef v41 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsModelQualityNumFingerprintsWiFiOnlyThreshold", 0x8000100u, kCFAllocatorNull);
    int v42 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v41, v68);
    CFRelease(v41);
    unint64_t v43 = v68[0];
    if (*(void *)&buf[8]) {
      sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
    }
    unint64_t v44 = 200;
    if (v42) {
      unint64_t v44 = v43;
    }
    if (v40 <= v44) {
      int v45 = 1;
    }
    else {
      int v45 = 3;
    }
    *(_DWORD *)(a3 + 296) = v45;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A27D8);
    }
    uint64_t v33 = v65;
    unint64_t v46 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v47 = *(_DWORD *)(a3 + 296);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v47;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Loaded model doesn't have model quality, calculate on the fly\", \"QualityIndicator\":%{public}d}", buf, 0x18u);
    }
  }
  *(_DWORD *)(a3 + 300) = *(_DWORD *)(v33 + 132);
  __src = 0;
  uint64_t v71 = 0;
  unint64_t v72 = 0;
  uint64_t v48 = *(int *)(v33 + 144);
  if (v48)
  {
    unint64_t v49 = 0;
    int v50 = *(int **)(v33 + 136);
    unint64_t v51 = &v50[v48];
    do
    {
      int v52 = *v50;
      if (v49 >= v72)
      {
        unint64_t v54 = (char *)__src;
        uint64_t v55 = (v49 - (unsigned char *)__src) >> 2;
        unint64_t v56 = v55 + 1;
        if ((unint64_t)(v55 + 1) >> 62) {
          sub_1001D7FD4();
        }
        uint64_t v57 = v72 - (unsigned char *)__src;
        if ((v72 - (unsigned char *)__src) >> 1 > v56) {
          unint64_t v56 = v57 >> 1;
        }
        if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v58 = v56;
        }
        if (v58)
        {
          unint64_t v59 = (char *)sub_10017EA34((uint64_t)&v72, v58);
          unint64_t v54 = (char *)__src;
          unint64_t v49 = v71;
        }
        else
        {
          unint64_t v59 = 0;
        }
        unint64_t v60 = &v59[4 * v55];
        *(_DWORD *)unint64_t v60 = v52;
        uint64_t v53 = (uint64_t)(v60 + 4);
        while (v49 != v54)
        {
          int v61 = *((_DWORD *)v49 - 1);
          v49 -= 4;
          *((_DWORD *)v60 - 1) = v61;
          v60 -= 4;
        }
        __src = v60;
        uint64_t v71 = (char *)v53;
        unint64_t v72 = &v59[4 * v58];
        if (v54) {
          operator delete(v54);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v49 = v52;
        uint64_t v53 = (uint64_t)(v49 + 4);
      }
      uint64_t v71 = (char *)v53;
      ++v50;
      unint64_t v49 = (char *)v53;
    }
    while (v50 != v51);
  }
  else
  {
    uint64_t v53 = 0;
  }
  if ((void **)(a3 + 304) != &__src) {
    sub_1000FB43C((char *)(a3 + 304), (char *)__src, v53, (v53 - (uint64_t)__src) >> 2);
  }
  if ((*(unsigned char *)(v65 + 193) & 4) != 0)
  {
    uint64_t v64 = *(void *)(v65 + 120);
    if (!v64) {
      uint64_t v64 = *(void *)(qword_1024899C0 + 120);
    }
    sub_100277BEC(v64, (uint64_t)buf);
  }
  if (v34 == 2)
  {
    sub_1002787CC((void *)a3, (uint64_t)v68);
    memset(v67, 0, sizeof(v67));
    unint64_t v62 = 0;
    if (v69)
    {
      v63 = v69;
      do
      {
        ++v62;
        v63 = (uint64_t *)*v63;
      }
      while (v63);
    }
    sub_10027C33C((char *)v67, v69, 0, v62);
    v74[8] = 0;
    v78[8] = 0;
    memset(buf, 0, 49);
    uint64_t v76 = 0;
    uint64_t v77 = 0;
    int v75 = 0;
    v78[0] = 0;
    memset(v66, 0, sizeof(v66));
    sub_10027883C((uint64_t)buf, v67, v66);
  }
  *(_OWORD *)(a3 + 200) = *(_OWORD *)(v65 + 152);
  *(void *)(a3 + 216) = *(void *)(v65 + 168);
  *(_DWORD *)(a3 + 224) = *(_DWORD *)(v65 + 184);
  std::string::operator=((std::string *)(a3 + 328), *(const std::string **)(v65 + 176));
  if (__src)
  {
    uint64_t v71 = (char *)__src;
    operator delete(__src);
  }
}

void sub_1002778B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28)
{
  sub_1001EC93C(v28);
  _Unwind_Resume(a1);
}

void sub_100277998(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  sub_100238614(a4, (_OWORD *)(a2 + 40), a2, &v6);
  uint64_t v8 = v6;
  uint64_t v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v10 = *a3;
  sub_10027A4BC((uint64_t *)(a1 + 232), (uint64_t)&v8);
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v7) {
    sub_1000DB0A0(v7);
  }
}

void sub_100277A48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_1000DB0A0(a13);
  }
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100277A74(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t v18 = a2;
  unint64_t v4 = sub_10027D624(a1 + 256, a2, (uint64_t)&unk_101D0B290, &v18);
  uint64_t v5 = (_OWORD *)v4[5];
  unint64_t v6 = v4[6];
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v8 = v4[4];
    uint64_t v9 = ((uint64_t)v5 - v8) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v11 = v6 - v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      int v13 = (char *)sub_1000C571C((uint64_t)(v4 + 6), v12);
    }
    else {
      int v13 = 0;
    }
    int v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(_OWORD *)int v14 = *a3;
    uint64_t v7 = v14 + 16;
    int v17 = (char *)v4[4];
    unsigned int v16 = (char *)v4[5];
    if (v16 != v17)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      unsigned int v16 = (char *)v4[4];
    }
    v4[4] = v14;
    v4[5] = v7;
    v4[6] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v5 = *a3;
    uint64_t v7 = v5 + 1;
  }
  v4[5] = v7;
}

uint64_t sub_100277B8C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 296) = a2;
  return result;
}

uint64_t sub_100277B94(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 272);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    result += (uint64_t)(v1[5] - v1[4]) >> 4;
    uint64_t v1 = (void *)*v1;
  }
  while (v1);
  return result;
}

uint64_t sub_100277BC0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 300) = a2;
  return result;
}

char *sub_100277BC8(uint64_t a1, uint64_t a2)
{
  uint64_t result = (char *)(a1 + 304);
  if (result != (char *)a2) {
    return sub_1000FB43C(result, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  }
  return result;
}

void sub_100277BEC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v52 = 0;
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  uint64_t v3 = *(int *)(a1 + 16);
  if (!v3)
  {
LABEL_42:
    long long v59 = 0uLL;
    unint64_t v60 = 0;
    int v24 = *(_DWORD *)(a1 + 40);
    int v25 = *(_DWORD *)(a1 + 64);
    LODWORD(v26) = v24;
    if (v24 != v25)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
      uint64_t v27 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t buf = 68289026;
        __int16 v62 = 2082;
        v63 = "";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", (uint8_t *)&buf, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A27D8);
        }
      }
      uint64_t v28 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t buf = 68289026;
        __int16 v62 = 2082;
        v63 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", (uint8_t *)&buf, 0x12u);
      }
      LODWORD(v26) = *(_DWORD *)(a1 + 40);
    }
    if ((int)v26 >= 1)
    {
      uint64_t v29 = 0;
      do
      {
        if (v29 >= (int)v26)
        {
          wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
          wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
          wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
          wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)&buf);
        }
        sub_1002E594C(*(uint64_t ***)(*(void *)(*(void *)(a1 + 32) + 8 * v29) + 8), &v55);
        if (v56)
        {
          long long v57 = v55;
        }
        else
        {
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A27D8);
          }
          std::string::size_type v30 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
          {
            uint64_t buf = 68289026;
            __int16 v62 = 2082;
            v63 = "";
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A27D8);
            }
          }
          int v31 = qword_102419458;
          if (os_signpost_enabled((os_log_t)qword_102419458))
          {
            uint64_t buf = 68289026;
            __int16 v62 = 2082;
            v63 = "";
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
          }
          long long v57 = 0uLL;
        }
        if (v24 == v25)
        {
          if (v29 >= *(int *)(a1 + 64))
          {
            wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
            wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
            wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
            wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)&buf);
          }
          int v32 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * v29);
        }
        else
        {
          int v32 = 0;
        }
        int v58 = v32;
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A27D8);
        }
        uint64_t v33 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          int v34 = operator new(0x28uLL);
          std::string __p = v34;
          long long v51 = xmmword_101D048C0;
          _OWORD *v34 = 0u;
          v34[1] = 0u;
          *(void *)((char *)v34 + 29) = 0;
          sub_1001E0650((uint64_t)&v57, v34);
          p_p = &__p;
          if (v51 < 0) {
            p_p = __p;
          }
          uint64_t buf = 68289794;
          __int16 v62 = 2082;
          v63 = "";
          __int16 v64 = 1026;
          int v65 = v29;
          __int16 v66 = 2082;
          unsigned int v67 = p_p;
          __int16 v68 = 1026;
          int v69 = v58;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf\", \"listElementInx\":%{public}d, \"event label\":%{public, location:escape_only}s, \"confidence level\":%{public}d}", (uint8_t *)&buf, 0x28u);
          if (SHIBYTE(v51) < 0) {
            operator delete(__p);
          }
        }
        int v36 = (_OWORD *)*((void *)&v59 + 1);
        if (*((void *)&v59 + 1) >= (unint64_t)v60)
        {
          unint64_t v39 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v59 + 1) - v59) >> 2);
          unint64_t v40 = v39 + 1;
          if (v39 + 1 > 0xCCCCCCCCCCCCCCCLL) {
            sub_1001D7FD4();
          }
          if (0x999999999999999ALL * ((uint64_t)&v60[-v59] >> 2) > v40) {
            unint64_t v40 = 0x999999999999999ALL * ((uint64_t)&v60[-v59] >> 2);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v60[-v59] >> 2) >= 0x666666666666666) {
            unint64_t v41 = 0xCCCCCCCCCCCCCCCLL;
          }
          else {
            unint64_t v41 = v40;
          }
          if (v41) {
            int v42 = (char *)sub_10027E440((uint64_t)&v60, v41);
          }
          else {
            int v42 = 0;
          }
          unint64_t v43 = &v42[20 * v39];
          long long v44 = v57;
          *((_DWORD *)v43 + 4) = v58;
          *(_OWORD *)unint64_t v43 = v44;
          int v45 = (char *)*((void *)&v59 + 1);
          unint64_t v46 = (char *)v59;
          int v47 = v43;
          if (*((void *)&v59 + 1) != (void)v59)
          {
            do
            {
              long long v48 = *(_OWORD *)(v45 - 20);
              *((_DWORD *)v47 - 1) = *((_DWORD *)v45 - 1);
              *(_OWORD *)(v47 - 20) = v48;
              v47 -= 20;
              v45 -= 20;
            }
            while (v45 != v46);
            int v45 = (char *)v59;
          }
          int v38 = v43 + 20;
          *(void *)&long long v59 = v47;
          *((void *)&v59 + 1) = v43 + 20;
          unint64_t v60 = &v42[20 * v41];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          long long v37 = v57;
          *(_DWORD *)(*((void *)&v59 + 1) + 16) = v58;
          _OWORD *v36 = v37;
          int v38 = (char *)v36 + 20;
        }
        *((void *)&v59 + 1) = v38;
        ++v29;
        uint64_t v26 = *(int *)(a1 + 40);
      }
      while (v29 < v26);
    }
    *(unsigned char *)(a2 + 72) = 0;
    *(unsigned char *)(a2 + 112) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(unsigned char *)(a2 + 48) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 80) = 0;
    *(unsigned char *)(a2 + 104) = 0;
    sub_10027883C(a2, &v52, &v59);
  }
  unint64_t v4 = *(uint64_t ****)(a1 + 8);
  uint64_t v5 = &v4[v3];
  while (1)
  {
    sub_1002E594C(*v4, &v59);
    if ((_BYTE)v60)
    {
      unint64_t v6 = v53;
      if (v53 >= v54)
      {
        uint64_t v11 = (v53 - (unsigned char *)v52) >> 4;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60) {
          sub_1001D7FD4();
        }
        uint64_t v13 = v54 - (unsigned char *)v52;
        if ((v54 - (unsigned char *)v52) >> 3 > v12) {
          unint64_t v12 = v13 >> 3;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          uint64_t v15 = (char *)sub_1000C571C((uint64_t)&v54, v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v19 = &v15[16 * v11];
        *(_OWORD *)uint64_t v19 = v59;
        uint64_t v21 = (char *)v52;
        uint64_t v20 = v53;
        int v22 = v19;
        if (v53 != v52)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v20 - 1);
            v22 -= 16;
            v20 -= 16;
          }
          while (v20 != v21);
          goto LABEL_38;
        }
        goto LABEL_39;
      }
      *(_OWORD *)uint64_t v53 = v59;
      uint64_t v7 = v6 + 16;
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
      uint64_t v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t buf = 68289026;
        __int16 v62 = 2082;
        v63 = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A27D8);
        }
      }
      uint64_t v9 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t buf = 68289026;
        __int16 v62 = 2082;
        v63 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
      }
      unint64_t v10 = v53;
      if (v53 >= v54)
      {
        uint64_t v16 = (v53 - (unsigned char *)v52) >> 4;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 60) {
          sub_1001D7FD4();
        }
        uint64_t v18 = v54 - (unsigned char *)v52;
        if ((v54 - (unsigned char *)v52) >> 3 > v17) {
          unint64_t v17 = v18 >> 3;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v17;
        }
        if (v14) {
          uint64_t v15 = (char *)sub_1000C571C((uint64_t)&v54, v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v19 = &v15[16 * v16];
        *(void *)uint64_t v19 = 0;
        *((void *)v19 + 1) = 0;
        int v23 = (char *)v52;
        uint64_t v20 = v53;
        int v22 = v19;
        if (v53 != v52)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v20 - 1);
            v22 -= 16;
            v20 -= 16;
          }
          while (v20 != v23);
LABEL_38:
          uint64_t v20 = (char *)v52;
        }
LABEL_39:
        uint64_t v7 = v19 + 16;
        int v52 = v22;
        uint64_t v53 = v19 + 16;
        unint64_t v54 = &v15[16 * v14];
        if (v20) {
          operator delete(v20);
        }
        goto LABEL_41;
      }
      uint64_t v7 = v53 + 16;
      *(void *)uint64_t v53 = 0;
      *((void *)v10 + 1) = 0;
    }
LABEL_41:
    uint64_t v53 = v7;
    if (++v4 == v5) {
      goto LABEL_42;
    }
  }
}

void sub_100278600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  sub_100278750(v26);
  uint64_t v29 = *(void **)(v27 - 184);
  if (v29)
  {
    *(void *)(v27 - 176) = v29;
    operator delete(v29);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002786C8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 120))
  {
    sub_1000F4EBC(a1, (__n128 *)a2);
    sub_1000F4EBC(a1 + 24, (__n128 *)(a2 + 24));
    sub_10027C114((uint64_t *)(a1 + 48), a2 + 48);
    sub_1000F4EBC(a1 + 80, (__n128 *)(a2 + 80));
    uint64_t v4 = *(void *)(a2 + 104);
    *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
    *(void *)(a1 + 104) = v4;
  }
  else
  {
    sub_10027C208(a1, a2);
    *(unsigned char *)(a1 + 120) = 1;
  }
  return a1;
}

uint64_t sub_100278750(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 88) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v3 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = 0;
    if (v3) {
      operator delete[]();
    }
  }
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 32) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v5;
    operator delete(v5);
  }
  return a1;
}

void *sub_1002787CC@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  uint64_t v3 = result[29];
  uint64_t v4 = result[30];
  while (v3 != v4)
  {
    uint64_t result = sub_1001EFB90(a2, (void *)(v3 + 16), (_OWORD *)(v3 + 16));
    v3 += 32;
  }
  return result;
}

void sub_100278828(_Unwind_Exception *a1)
{
  sub_1000D7D80(v1);
  _Unwind_Resume(a1);
}

void sub_10027883C(uint64_t a1, void *a2, void *a3)
{
  sub_100274B3C((uint64_t)&v3, -858993459 * ((a3[1] - *a3) >> 2), (a2[1] - *a2) >> 4);
}

void sub_100278B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t sub_100278BEC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 120))
  {
    if (a1 == a2)
    {
      sub_10027C4C0(a1 + 48, a1 + 48);
    }
    else
    {
      sub_10027C3B4((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
      sub_10027C3B4((char *)(a1 + 24), *(char **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 4);
      sub_10027C4C0(a1 + 48, a2 + 48);
      sub_1000FB43C((char *)(a1 + 80), *(char **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
    }
    uint64_t v4 = *(void *)(a2 + 104);
    *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
    *(void *)(a1 + 104) = v4;
  }
  else
  {
    sub_10027C550(a1, a2);
    *(unsigned char *)(a1 + 120) = 1;
  }
  return a1;
}

void *sub_100278CA4@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3 = *((_DWORD *)result + 1);
  if (v3 < 2)
  {
    sub_1002787CC(result, (uint64_t)v7);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v4 = v8;
    for (i = (void **)a2; v4; uint64_t v4 = (uint64_t *)*v4)
      sub_10020D800(&i, (_OWORD *)v4 + 1);
    return (void *)sub_1000D7D80((uint64_t)v7);
  }
  else
  {
    if (v3 != 2)
    {
      if (v3 != 3) {
        sub_101A56890();
      }
      goto LABEL_12;
    }
    if (!*((unsigned char *)result + 192))
    {
LABEL_12:
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      return result;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v5 = (const void *)result[12];
    uint64_t v6 = result[13];
    return sub_10017C680((void *)a2, v5, v6, (v6 - (uint64_t)v5) >> 4);
  }
}

void sub_100278D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  sub_1000D7D80((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL sub_100278D98(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 232);
  uint64_t v2 = *(void *)(a1 + 240);
  BOOL v3 = v1 == v2 && *(_DWORD *)(a1 + 4) == 3;
  if (v1 != v2)
  {
    if (*(void *)(a1 + 280))
    {
      sub_1002787CC((void *)a1, (uint64_t)v8);
      if (v10 == *(void *)(a1 + 280))
      {
        uint64_t v5 = v9;
        if (v9)
        {
          uint64_t v6 = (void *)(a1 + 256);
          LOBYTE(v3) = 1;
          do
          {
            BOOL v3 = v3 && sub_100222004(v6, v5 + 2) != 0;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          BOOL v3 = 1;
        }
      }
      else
      {
        BOOL v3 = 0;
      }
      sub_1000D7D80((uint64_t)v8);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_100278E64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000D7D80((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100278E78(void *result, void *a2)
{
  BOOL v3 = result;
  for (uint64_t i = (void *)a2[2]; i; uint64_t i = (void *)*i)
  {
    if (i[2] != i[4] || i[3] != i[5])
    {
      uint64_t result = sub_1001EFDE4(v3 + 32, i + 2);
      if (result)
      {
        sub_10027C6B4((uint64_t)(v3 + 32), i + 4, (_OWORD *)i + 2, (long long *)result + 2);
        if ((v6 & 1) == 0) {
          sub_101A56A78();
        }
        uint64_t result = sub_10027C9AC(v3 + 32, i + 2);
      }
    }
  }
  uint64_t v7 = (void *)v3[29];
  uint64_t v8 = (void *)v3[30];
  if (v7 != v8)
  {
    uint64_t v9 = v7 + 2;
    do
    {
      uint64_t result = sub_100222004(a2, v9);
      if (result) {
        *(_OWORD *)uint64_t v9 = *((_OWORD *)result + 2);
      }
      uint64_t v10 = v9 + 2;
      v9 += 4;
    }
    while (v10 != v8);
  }
  return result;
}

uint64_t sub_100278F54@<X0>(unint64_t a1@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  int v21 = 0;
  sub_1001EE1F4(&v21);
  if (a1)
  {
    do
    {
      uint64_t v4 = sub_1001EC8C4((ssize_t)&v21);
      uint64_t v6 = v4;
      uint64_t v7 = v5;
      uint64_t v9 = (uint64_t *)a2[1];
      unint64_t v8 = (unint64_t)a2[2];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = ((char *)v9 - (unsigned char *)*a2) >> 4;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60) {
          sub_1001D7FD4();
        }
        uint64_t v13 = v8 - (void)*a2;
        if (v13 >> 3 > v12) {
          unint64_t v12 = v13 >> 3;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          uint64_t v15 = (char *)sub_1000C571C((uint64_t)(a2 + 2), v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = (uint64_t *)&v15[16 * v11];
        uint64_t *v16 = v6;
        v16[1] = v7;
        uint64_t v18 = (char *)*a2;
        unint64_t v17 = (char *)a2[1];
        uint64_t v19 = v16;
        if (v17 != *a2)
        {
          do
          {
            *((_OWORD *)v19 - 1) = *((_OWORD *)v17 - 1);
            v19 -= 2;
            v17 -= 16;
          }
          while (v17 != v18);
          unint64_t v17 = (char *)*a2;
        }
        uint64_t v10 = v16 + 2;
        *a2 = v19;
        a2[1] = v16 + 2;
        a2[2] = &v15[16 * v14];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *uint64_t v9 = v4;
        v9[1] = v5;
        uint64_t v10 = v9 + 2;
      }
      a2[1] = v10;
    }
    while (a1 > ((char *)v10 - (unsigned char *)*a2) >> 4);
  }
  return sub_1001EF3E8((unsigned int *)&v21);
}

void sub_1002790A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11)
{
  sub_1001EF3E8(&a11);
  uint64_t v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002790CC(uint64_t a1, void *a2, void *a3)
{
  sub_1002787CC((void *)a1, (uint64_t)v62);
  sub_1002787CC(a2, (uint64_t)v59);
  if (v64 == *(void *)(a1 + 280) && v61 == a2[35])
  {
    for (uint64_t i = v60; v60; uint64_t i = v60)
    {
      while (!sub_1001EFDE4(v62, i + 2))
      {
        uint64_t i = (void *)*i;
        if (!i) {
          goto LABEL_16;
        }
      }
      sub_100278F54(v64, __p);
      long long v68 = 0u;
      long long v69 = 0u;
      int v70 = 1065353216;
      uint64_t v6 = v63;
      if (v63)
      {
        uint64_t v7 = (long long *)__p[0];
        do
        {
          long long v73 = *((_OWORD *)v6 + 1);
          long long v74 = *v7;
          sub_10027CA30((uint64_t)&v68, &v73, &v73);
          uint64_t v6 = (uint64_t *)*v6;
          ++v7;
        }
        while (v6);
      }
      sub_100278E78((void *)a1, &v68);
      sub_1000E2F40(v62);
      uint64_t v9 = __p[0];
      unint64_t v8 = __p[1];
      while (v9 != v8)
      {
        sub_1001EFB90((uint64_t)v62, v9, v9);
        v9 += 2;
      }
      sub_1000D7D80((uint64_t)&v68);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
LABEL_16:
    long long v57 = 0;
    uint64_t v58 = 0;
    char v56 = (uint64_t *)&v57;
    sub_1000C7F88(&v68);
    LODWORD(v73) = 0;
    CFStringRef v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDistanceFunctionType", 0x8000100u, kCFAllocatorNull);
    int v11 = sub_1004D08E4(v68, (uint64_t)v10, &v73);
    CFRelease(v10);
    int v12 = v73;
    if (*((void *)&v68 + 1)) {
      sub_1000DB0A0(*((std::__shared_weak_count **)&v68 + 1));
    }
    if (v11) {
      int v13 = v12;
    }
    else {
      int v13 = 4;
    }
    sub_1002A9DA0(v13, v55);
    sub_1001EF40C((uint64_t)&v68, a1 + 16);
    long long v71 = *(_OWORD *)(a1 + 56);
    char v72 = 1;
    sub_100217F3C(v13, (uint64_t)v55, (uint64_t)&v68, (uint64_t)&v73);
    if (v72) {
      sub_1000D7D80((uint64_t)&v68);
    }
    sub_1000C7F88(&v68);
    __p[0] = 0;
    CFStringRef v14 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterPersistenceDistanceThreshold", 0x8000100u, kCFAllocatorNull);
    int v15 = sub_1000A6A10(v68, (uint64_t)v14, __p);
    CFRelease(v14);
    uint64_t v16 = __p[0];
    if (*((void *)&v68 + 1)) {
      sub_1000DB0A0(*((std::__shared_weak_count **)&v68 + 1));
    }
    if (v15) {
      double v17 = *(double *)&v16;
    }
    else {
      double v17 = 0.35;
    }
    uint64_t v18 = v63;
    if (v63)
    {
      double v19 = 0.0;
      double v20 = 1.79769313e308;
      while (1)
      {
        int v21 = v60;
        int v50 = (uint64_t **)v18;
        if (v60) {
          break;
        }
        double v33 = v19;
LABEL_61:
        uint64_t v18 = *v50;
        double v19 = v33;
        if (!*v50) {
          goto LABEL_62;
        }
      }
      int v22 = v18 + 2;
      while (1)
      {
        int v23 = v21 + 2;
        int v25 = *(void **)(a1 + 232);
        int v24 = *(void **)(a1 + 240);
        if (v25 == v24)
        {
          unint64_t v26 = 0;
          double v27 = 0.0;
        }
        else
        {
          unint64_t v26 = 0;
          double v27 = 0.0;
          do
          {
            uint64_t v29 = (void *)a2[29];
            uint64_t v28 = (void *)a2[30];
            while (v29 != v28)
            {
              BOOL v30 = v25[2] == *v22 && v25[3] == v22[1];
              if (v30 && v29[2] == *v23 && v29[3] == v21[3])
              {
                if (!*((void *)&v74 + 1)) {
                  sub_10015E48C();
                }
                ++v26;
                double v27 = v27
                    + (*(double (**)(void, void, void))(**((void **)&v74 + 1) + 48))(*((void *)&v74 + 1), *v25, *v29);
              }
              v29 += 4;
            }
            v25 += 4;
          }
          while (v25 != v24);
        }
        double v32 = v27 / (double)v26;
        __p[0] = *(void **)&v32;
        if (v32 >= v17)
        {
          if (v32 >= v20)
          {
LABEL_57:
            double v33 = v19;
            goto LABEL_58;
          }
          [a3 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v32) forKeyedSubscript:@"minDistanceAbovePersistenceThreshold"];
          double v20 = v32;
          double v33 = v19;
        }
        else
        {
          long long v68 = *(_OWORD *)v22;
          long long v69 = *(_OWORD *)v23;
          sub_10027CC84(&v56, (double *)__p, &v68);
          double v33 = *(double *)__p;
          if (*(double *)__p <= v19) {
            goto LABEL_57;
          }
          [a3 setObject:[NSNumber numberWithDouble:*__p] forKeyedSubscript:@"maxDistanceBelowPersistenceThreshold"];
        }
LABEL_58:
        int v21 = (void *)*v21;
        double v19 = v33;
        if (!v21) {
          goto LABEL_61;
        }
      }
    }
LABEL_62:
    long long v68 = 0u;
    long long v69 = 0u;
    int v70 = 1065353216;
    while (v58)
    {
      long long v34 = *(_OWORD *)(v56 + 7);
      *(_OWORD *)std::string __p = *(_OWORD *)(v56 + 5);
      long long v67 = v34;
      sub_10027CA30((uint64_t)&v68, __p, __p);
      uint64_t v53 = 0;
      uint64_t v54 = 0;
      int v52 = (uint64_t *)&v53;
      unint64_t v35 = v56;
      v65[0] = &v52;
      v65[1] = &v53;
      if (v56 == (uint64_t *)&v57)
      {
        uint64_t v43 = 0;
        unint64_t v41 = 0;
        int v42 = (uint64_t *)&v53;
        unint64_t v40 = (uint64_t *)&v57;
      }
      else
      {
        do
        {
          if (((void *)v35[5] != __p[0] || (void *)v35[6] != __p[1])
            && (v35[7] != (void)v67 || v35[8] != *((void *)&v67 + 1)))
          {
            sub_10027CD24((uint64_t)v65, (uint64_t)(v35 + 4));
          }
          int v38 = (uint64_t *)v35[1];
          if (v38)
          {
            do
            {
              unint64_t v39 = v38;
              int v38 = (uint64_t *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              unint64_t v39 = (uint64_t *)v35[2];
              BOOL v30 = *v39 == (void)v35;
              unint64_t v35 = v39;
            }
            while (!v30);
          }
          unint64_t v35 = v39;
        }
        while (v39 != (uint64_t *)&v57);
        unint64_t v40 = v56;
        int v42 = v52;
        unint64_t v41 = v53;
        uint64_t v43 = v54;
      }
      long long v44 = v57;
      uint64_t v45 = v58;
      char v56 = v42;
      long long v57 = v41;
      int v52 = v40;
      uint64_t v53 = v44;
      uint64_t v58 = v43;
      uint64_t v54 = v45;
      unint64_t v46 = (uint64_t **)(v41 + 2);
      if (v43) {
        int v47 = v46;
      }
      else {
        int v47 = &v56;
      }
      *int v47 = (uint64_t *)&v57;
      long long v48 = (uint64_t **)(v44 + 2);
      if (!v45) {
        long long v48 = &v52;
      }
      *long long v48 = (uint64_t *)&v53;
      sub_1000F5BB0((uint64_t)&v52, v44);
    }
    sub_100278E78((void *)a1, &v68);
    sub_1000D7D80((uint64_t)&v68);
    sub_1001F2DB8(&v73);
    sub_10013F374(v55);
    sub_1000F5BB0((uint64_t)&v56, v57);
  }
  sub_1000D7D80((uint64_t)v59);
  return sub_1000D7D80((uint64_t)v62);
}

void sub_1002796C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  sub_1000D7D80((uint64_t)&a37);
  sub_1001F2DB8((void *)(v44 - 160));
  sub_10013F374(&a16);
  sub_1000F5BB0((uint64_t)&a18, a19);
  sub_1000D7D80((uint64_t)&a21);
  sub_1000D7D80((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void sub_1002797D0(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = a1 + 29;
  uint64_t v5 = *(void **)(a2 + 16);
  uint64_t v25 = a1[30];
  uint64_t v26 = a1[29];
  if (v5)
  {
    uint64_t v7 = a1 + 32;
    uint64_t v8 = a1[30];
    do
    {
      uint64_t v9 = v8;
      CFStringRef v10 = v5 + 2;
      int v11 = sub_1001EFDE4(v7, v5 + 2);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
      int v12 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = operator new(0x28uLL);
        std::string __p = v13;
        long long v28 = xmmword_101D048C0;
        *int v13 = 0u;
        v13[1] = 0u;
        *(void *)((char *)v13 + 29) = 0;
        sub_1001E0650((uint64_t)(v5 + 2), v13);
        p_p = &__p;
        if (v28 < 0) {
          p_p = __p;
        }
        uint64_t v15 = (v11[5] - v11[4]) >> 4;
        *(_DWORD *)uint64_t buf = 68289794;
        int v30 = 0;
        __int16 v31 = 2082;
        double v32 = "";
        __int16 v33 = 2082;
        unint64_t v34 = (unint64_t)p_p;
        __int16 v35 = 2050;
        uint64_t v36 = v15;
        __int16 v37 = 2050;
        unint64_t v38 = a3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"cluster ID\":%{public, location:escape_only}s, \"cluster size\":%{public}lu, \"threshold\":%{public}lu}", buf, 0x30u);
        if (SHIBYTE(v28) < 0) {
          operator delete(__p);
        }
      }
      if (a3 <= (v11[5] - v11[4]) >> 4 || (sub_10027C9E4(v7, v11), uint64_t v8 = *v4, *v4 == v9))
      {
        uint64_t v8 = v9;
        uint64_t v16 = a1;
      }
      else
      {
        uint64_t v16 = a1;
        while (1)
        {
          BOOL v17 = *(void *)(v8 + 16) == *v10 && *(void *)(v8 + 24) == v5[3];
          uint64_t v18 = v8 + 32;
          if (v17) {
            break;
          }
          v8 += 32;
          if (v18 == v9)
          {
            uint64_t v8 = v9;
            goto LABEL_30;
          }
        }
        while (v18 != v9)
        {
          if (*(void *)(v18 + 16) != *v10 || *(void *)(v18 + 24) != v5[3])
          {
            long long v20 = *(_OWORD *)v18;
            *(void *)uint64_t v18 = 0;
            *(void *)(v18 + 8) = 0;
            int v21 = *(std::__shared_weak_count **)(v8 + 8);
            *(_OWORD *)uint64_t v8 = v20;
            if (v21)
            {
              sub_1000DB0A0(v21);
              uint64_t v16 = a1;
            }
            *(_OWORD *)(v8 + 16) = *(_OWORD *)(v18 + 16);
            v8 += 32;
          }
          v18 += 32;
        }
      }
LABEL_30:
      uint64_t v5 = (void *)*v5;
    }
    while (v5);
    int v22 = (long long *)v16[30];
  }
  else
  {
    uint64_t v8 = a1[30];
    int v22 = (long long *)v8;
  }
  sub_100279B44((uint64_t)v4, v8, v22);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  int v23 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = (a1[30] - a1[29]) >> 5;
    *(_DWORD *)uint64_t buf = 68289794;
    int v30 = 0;
    __int16 v31 = 2082;
    double v32 = "";
    __int16 v33 = 2050;
    unint64_t v34 = a3;
    __int16 v35 = 2050;
    uint64_t v36 = (v25 - v26) >> 5;
    __int16 v37 = 2050;
    unint64_t v38 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"clusterSizeThreshold\":%{public}lu, \"numFingerprintsPrePruning\":%{public}lu, \"numFingerprintsPostPruning\":%{public}lu}", buf, 0x30u);
  }
}

void sub_100279B28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100279B44(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    sub_10027CF08((uint64_t)&v10, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        uint64_t v8 = *(std::__shared_weak_count **)(v7 - 24);
        if (v8) {
          sub_1000DB0A0(v8);
        }
        v7 -= 32;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_100279BC8(uint64_t *a1)
{
  sub_1000C7F88(&v7);
  unsigned int v9 = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterSizeThreshold", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1004D08E4(v7, (uint64_t)v2, &v9);
  CFRelease(v2);
  unint64_t v4 = v9;
  if (v8) {
    sub_1000DB0A0(v8);
  }
  if (v3) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = 5;
  }
  sub_1002787CC(a1, (uint64_t)&v7);
  sub_1002797D0(a1, (uint64_t)&v7, v5);
  return sub_1000D7D80((uint64_t)&v7);
}

void sub_100279C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100279CB8(uint64_t *a1, uint64_t a2, int a3, void *a4)
{
  if (sub_100278D98((uint64_t)a1))
  {
    sub_1000C7F88(buf);
    v22[0] = 0;
    CFStringRef v8 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterSizeRatio", 0x8000100u, kCFAllocatorNull);
    int v9 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v8, v22);
    CFRelease(v8);
    double v10 = *(double *)v22;
    if (v24) {
      sub_1000DB0A0(v24);
    }
    if (!v9) {
      double v10 = 0.2;
    }
    int v11 = (void *)a1[34];
    int v12 = (void *)*v11;
    if (*v11)
    {
      do
      {
        if (v11[5] - v11[4] < v12[5] - v12[4]) {
          int v11 = v12;
        }
        int v12 = (void *)*v12;
      }
      while (v12);
    }
    uint64_t v14 = v11[4];
    uint64_t v13 = v11[5];
    sub_100279BC8(a1);
    if (sub_100278D98((uint64_t)a1))
    {
      sub_1002787CC(a1, (uint64_t)buf);
      double v15 = v10 * (double)(unint64_t)((v13 - v14) >> 4);
      unint64_t v16 = (unint64_t)v15;
      if (a3) {
        sub_1002797D0(a1, (uint64_t)buf, (unint64_t)v15);
      }
      if (*(unsigned char *)(a2 + 8))
      {
        BOOL v17 = *(void **)a2;
        if (sub_100278D98((uint64_t)v17))
        {
          sub_1002790CC((uint64_t)a1, v17, a4);
          sub_1002787CC(a1, (uint64_t)v22);
          uint64_t v18 = v25;
          if (v25)
          {
            do
            {
              uint64_t v19 = *v18;
              if (!sub_1001EFDE4(v22, v18 + 2)) {
                sub_10017FB70(buf, v18);
              }
              uint64_t v18 = (uint64_t *)v19;
            }
            while (v19);
          }
          sub_1000D7D80((uint64_t)v22);
        }
      }
      if ((a3 & 1) == 0) {
        sub_1002797D0(a1, (uint64_t)buf, v16);
      }
      sub_1000D7D80((uint64_t)buf);
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
      long long v20 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Model has become invalid after pruning clusters with absolute size threshold", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A27D8);
        }
        LOWORD(v22[0]) = 0;
        int v21 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters(const std::optional<std::reference_wrapper<CLMicroLocationModel>> &, const BOOL, NSMutableDictionary *)", "%s\n", v21);
        if (v21 != (char *)buf) {
          free(v21);
        }
      }
    }
  }
}

void sub_100279FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1000D7D80((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10027A034@<X0>(void *a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  uint64_t v6 = (char *)a1[35];
  sub_1002787CC(a1, (uint64_t)v37);
  v36[0] = 0;
  v36[1] = 0;
  uint64_t v34 = 0;
  __int16 v35 = (uint64_t *)v36;
  for (uint64_t i = v38; i; uint64_t i = (uint64_t *)*i)
  {
    *(_OWORD *)std::string __p = *((_OWORD *)i + 1);
    sub_10027CF7C(&v35, (unint64_t *)__p, __p, &v34);
    ++v34;
  }
  a3[1] = 0;
  CFStringRef v8 = (uint64_t *)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  __p[1] = 0;
  unint64_t v41 = 0;
  uint64_t v42 = 0;
  *a3 = v6;
  unint64_t v39 = 0;
  sub_10027D0DC((uint64_t)(a3 + 1), (unint64_t)&v6[(void)v6 * (void)v6] >> 1, &v39);
  __p[0] = v6;
  LODWORD(v39) = 0;
  sub_10027D230((uint64_t)&__p[1], (unint64_t)&v6[(void)v6 * (void)v6] >> 1, &v39);
  uint64_t v10 = a1[29];
  uint64_t v9 = a1[30];
  if (v9 != v10)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    do
    {
      if (v12 >= (v9 - v10) >> 5)
      {
        unint64_t v21 = (v9 - v10) >> 5;
      }
      else
      {
        uint64_t v33 = v11;
        unint64_t v13 = v12;
        do
        {
          uint64_t v14 = *(void *)(a2 + 24);
          if (!v14) {
            sub_10015E48C();
          }
          double v15 = (*(double (**)(uint64_t, void, void))(*(void *)v14 + 48))(v14, *(void *)(v10 + 32 * v12), *(void *)(v10 + v11));
          unint64_t v39 = (unint64_t *)(v10 + 32 * v12 + 16);
          unint64_t v16 = *((void *)sub_10027D384(&v35, v39, (uint64_t)&unk_101D0B290, (_OWORD **)&v39) + 6);
          unint64_t v39 = (unint64_t *)(v10 + v11 + 16);
          BOOL v17 = sub_10027D384(&v35, v39, (uint64_t)&unk_101D0B290, (_OWORD **)&v39);
          unint64_t v18 = *((void *)v17 + 6);
          if (v16 <= v18) {
            unint64_t v19 = *((void *)v17 + 6);
          }
          else {
            unint64_t v19 = v16;
          }
          if (v16 < v18) {
            unint64_t v18 = v16;
          }
          unint64_t v20 = v18 + ((v19 + v19 * v19) >> 1);
          *(double *)(*v8 + 8 * v20) = v15 + *(double *)(*v8 + 8 * v20);
          ++*((_DWORD *)__p[1] + v20);
          ++v13;
          uint64_t v10 = a1[29];
          uint64_t v9 = a1[30];
          v11 += 32;
        }
        while (v13 < (v9 - v10) >> 5);
        unint64_t v21 = (v9 - v10) >> 5;
        uint64_t v11 = v33;
      }
      ++v12;
      v11 += 32;
    }
    while (v12 < v21);
  }
  int v22 = __p[1];
  if (v6)
  {
    int v23 = 0;
    uint64_t v24 = *v8;
    do
    {
      uint64_t v25 = *v8;
      uint64_t v26 = v23;
      do
      {
        if (v23 <= v26) {
          double v27 = v26;
        }
        else {
          double v27 = v23;
        }
        if (v23 >= v26) {
          long long v28 = v26;
        }
        else {
          long long v28 = v23;
        }
        uint64_t v29 = &v28[(unint64_t)&v27[(void)v27 * (void)v27] >> 1];
        int v30 = v22[(void)v29];
        if (v30) {
          double v31 = *(double *)(v25 + 8 * (void)v29) / (double)v30;
        }
        else {
          double v31 = 0.0;
        }
        *(double *)(v24 + 8 * (void)v29) = v31;
        ++v26;
      }
      while (v6 != v26);
      ++v23;
    }
    while (v23 != v6);
    int v22 = __p[1];
  }
  if (v22)
  {
    unint64_t v41 = v22;
    operator delete(v22);
  }
  sub_1000F5BB0((uint64_t)&v35, v36[0]);
  return sub_1000D7D80((uint64_t)v37);
}

void sub_10027A314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
}

double sub_10027A37C(void *a1)
{
  CFStringRef v2 = (void *)a1[34];
  if (!v2) {
    goto LABEL_6;
  }
  unint64_t v3 = 0;
  do
  {
    v3 += (uint64_t)(v2[5] - v2[4]) >> 4;
    CFStringRef v2 = (void *)*v2;
  }
  while (v2);
  if (v3) {
    return (double)(unint64_t)((uint64_t)(a1[30] - a1[29]) >> 5) / (double)v3;
  }
LABEL_6:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  unint64_t v5 = qword_102419458;
  double v4 = 1.0;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 68289282;
    v7[1] = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 1026;
    BOOL v11 = sub_100278D98((uint64_t)a1);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"representativeFPsRatio, called with empty model\", \"isValid\":%{public}hhd}", (uint8_t *)v7, 0x18u);
  }
  return v4;
}

_OWORD *sub_10027A4BC(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  double v4 = a1 + 2;
  unint64_t v5 = v6;
  uint64_t v7 = (_OWORD *)*(v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((uint64_t)v7 - *a1) >> 5;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59) {
      sub_1001D7FD4();
    }
    uint64_t v11 = v5 - *a1;
    if (v11 >> 4 > v10) {
      unint64_t v10 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = v4;
    if (v12) {
      unint64_t v13 = (char *)sub_1001D9EDC((uint64_t)v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    uint64_t v14 = &v13[32 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[32 * v12];
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *((_OWORD *)v14 + 1) = *(_OWORD *)(a2 + 16);
    v16[2] = v14 + 32;
    sub_10027D410(a1, v16);
    __int16 v8 = (_OWORD *)a1[1];
    sub_10027D59C(v16);
  }
  else
  {
    *uint64_t v7 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    v7[1] = *(_OWORD *)(a2 + 16);
    __int16 v8 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v8;
  return v8 - 2;
}

void sub_10027A5C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10027D59C((void **)va);
  _Unwind_Resume(a1);
}

void sub_10027A5D4(uint64_t *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  sub_1002E8898(0, (uint64_t)v26);
  sub_1001E1728((uint64_t)v23, (unsigned __int8 *)v26);
  v22[0] = sub_1002D396C((uint64_t)a3);
  v22[1] = v7;
  v21[0] = sub_1002D3978(a3);
  v21[1] = v8;
  if (sub_1002D37F4(v22, v21))
  {
    uint64_t v9 = sub_1002D3820(v22);
    unint64_t v10 = sub_100222004(a4, (void *)(v9 + 40));
    if (v10)
    {
      sub_10027DDDC(a5, v10 + 4);
      sub_1002AECA8((uint64_t)&v28, a2);
    }
    sub_10000EDDC("unordered_map::at: key not found");
  }
  if ((sub_100274F4C((uint64_t)(a1 + 6)) & 1) == 0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A27D8);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t v29 = 68289026;
      v30[0] = 2082;
      *(void *)&v30[1] = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v29, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A27D8);
      }
    }
    unint64_t v12 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(void *)uint64_t v29 = 68289026;
      v30[0] = 2082;
      *(void *)&v30[1] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, error normalizing probability matrix", "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v29, 0x12u);
    }
  }
  if (*(_OWORD *)*a1 == 0)
  {
    sub_100274DCC((uint64_t)(a1 + 6), 1u, v29);
    sub_10027C114(a1 + 6, (uint64_t)v29);
    if (v31)
    {
      uint64_t v13 = *(void *)v29;
      *(void *)uint64_t v29 = 0;
      if (v13) {
        operator delete[]();
      }
    }
    double v15 = (char *)*a1;
    uint64_t v14 = (unsigned char *)a1[1];
    unint64_t v16 = (unsigned char *)(*a1 + 16);
    int64_t v17 = v14 - v16;
    if (v14 != v16) {
      memmove((void *)*a1, v16, v14 - v16);
    }
    a1[1] = (uint64_t)&v15[v17];
  }
  sub_10013F374(v25);
  sub_1000F5BB0((uint64_t)v23, v24);
  if (v27 < 0) {
    operator delete(v26[0]);
  }
}

void sub_10027ADA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (*(unsigned char *)(v40 - 168))
  {
    uint64_t v42 = *(void *)(v40 - 192);
    *(void *)(v40 - 192) = 0;
    if (v42) {
      operator delete[]();
    }
  }
  sub_10013F374(&a32);
  sub_1000F5BB0((uint64_t)&a29, a30);
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10027AEA8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v7 = sub_10027BF0C();
  sub_1002E8898(0, (uint64_t)v20);
  sub_1001E1728((uint64_t)v17, (unsigned __int8 *)v20);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
  if (v8 == (uint64_t)(a4[1] - *a4) >> 4)
  {
    if (v7 >= (int)v8) {
      int v7 = -1431655765 * ((uint64_t)(a3[1] - *a3) >> 6);
    }
    uint64_t v9 = 60;
    if (!*(unsigned char *)(a1 + 57)) {
      uint64_t v9 = 64;
    }
    sub_100274B3C((uint64_t)&v16, v7, *(_DWORD *)(a1 + v9) + 1);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A27D8);
  }
  unint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    uint64_t v12 = (uint64_t)(a4[1] - *a4) >> 4;
    *(void *)int v22 = 68289538;
    v23[0] = 2082;
    *(void *)&v23[1] = "";
    __int16 v24 = 2050;
    unint64_t v25 = v11;
    __int16 v26 = 2050;
    uint64_t v27 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v22, 0x26u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A27D8);
    }
  }
  uint64_t v13 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    uint64_t v15 = (uint64_t)(a4[1] - *a4) >> 4;
    *(void *)int v22 = 68289538;
    v23[0] = 2082;
    *(void *)&v23[1] = "";
    __int16 v24 = 2050;
    unint64_t v25 = v14;
    __int16 v26 = 2050;
    uint64_t v27 = v15;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!", "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v22, 0x26u);
  }
  sub_10013F374(v19);
  sub_1000F5BB0((uint64_t)v17, v18);
  if (v21 < 0) {
    operator delete(v20[0]);
  }
}

void sub_10027BE20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (__p) {
    operator delete(__p);
  }
  if (a37)
  {
    uint64_t v38 = a34;
    a34 = 0;
    if (v38) {
      operator delete[]();
    }
  }
  if (a18) {
    operator delete[]();
  }
  sub_1001E05E8((uint64_t)&a21);
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10027BF0C()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_10013E418(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 1000;
  }
}

void sub_10027BFA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027BFBC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    sub_10027DF1C((char **)a1, a2 - v2);
  }
}

void sub_10027BFEC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    sub_10027E320((void **)a1, a2 - v2);
  }
}

void sub_10027C01C()
{
}

void sub_10027C05C()
{
}

void sub_10027C080()
{
}

void sub_10027C0C0()
{
}

void sub_10027C0E4(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t *sub_10027C114(uint64_t *result, uint64_t a2)
{
  unint64_t v2 = result;
  if (*((unsigned __int8 *)result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*((unsigned char *)result + 24))
    {
      return sub_100274D1C(result, (uint64_t *)a2);
    }
  }
  else if (*((unsigned char *)result + 24))
  {
    uint64_t result = (uint64_t *)*result;
    uint64_t *v2 = 0;
    if (result) {
      operator delete[]();
    }
    *((unsigned char *)v2 + 24) = 0;
  }
  else
  {
    uint64_t result = (uint64_t *)sub_100274C78(result);
    *((unsigned char *)v2 + 24) = 1;
  }
  return result;
}

void sub_10027C1A4()
{
}

void sub_10027C1E4()
{
}

uint64_t sub_10027C208(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  sub_10027C2DC((unsigned char *)(a1 + 48), a2 + 48);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_10027C2B0(_Unwind_Exception *exception_object)
{
  unsigned int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_10027C2DC(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_100274C78(a1);
    a1[24] = 1;
  }
  return a1;
}

void sub_10027C320(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    sub_101A56D74((uint64_t *)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10027C33C(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_10022F168(result, a4);
    int v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      *v7++ = *((_OWORD *)a2 + 1);
      a2 = (uint64_t *)*a2;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_10027C398(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10027C3B4(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *int v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_10022F168(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t sub_10027C4C0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (*(unsigned __int8 *)(result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*(unsigned char *)(result + 24))
    {
      return sub_100274C7C(result, a2);
    }
  }
  else if (*(unsigned char *)(result + 24))
  {
    uint64_t result = *(void *)result;
    *(void *)uint64_t v2 = 0;
    if (result) {
      operator delete[]();
    }
    *(unsigned char *)(v2 + 24) = 0;
  }
  else
  {
    uint64_t result = sub_100274C08(result);
    *(unsigned char *)(v2 + 24) = 1;
  }
  return result;
}

uint64_t sub_10027C550(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_10017C680((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10017C680((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 4);
  sub_10027C654((unsigned char *)(a1 + 48), a2 + 48);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  sub_10010F834((void *)(a1 + 80), *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_10027C5F0(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 72))
  {
    uint64_t v5 = *v3;
    uint64_t *v3 = 0;
    if (v5) {
      operator delete[]();
    }
  }
  unint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v6;
    operator delete(v6);
  }
  int v7 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_10027C654(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_100274C08(a1);
    a1[24] = 1;
  }
  return a1;
}

void sub_10027C698(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    sub_101A56D74((uint64_t *)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10027C6B4(uint64_t a1, void *a2, _OWORD *a3, long long *a4)
{
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  do
    v9 ^= (v9 << 6) + (v9 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v8++);
  while (v8 != 16);
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2 && v13[3] == a2[1]) {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v16 = (void *)(a1 + 16);
  uint64_t v13 = operator new(0x38uLL);
  *uint64_t v13 = 0;
  v13[1] = v9;
  long long v17 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v17;
  v13[6] = *((void *)a4 + 2);
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_100100330(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v24 = *(void *)a1;
  unint64_t v25 = *(void **)(*(void *)a1 + 8 * v4);
  if (v25)
  {
    *uint64_t v13 = *v25;
LABEL_44:
    *unint64_t v25 = v13;
    goto LABEL_45;
  }
  *uint64_t v13 = *v16;
  void *v16 = v13;
  *(void *)(v24 + 8 * v4) = v16;
  if (*v13)
  {
    unint64_t v26 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10) {
        v26 %= v10;
      }
    }
    else
    {
      v26 &= v10 - 1;
    }
    unint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_10027C930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_10027C94C(v11, v10);
  _Unwind_Resume(a1);
}

void sub_10027C94C(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *sub_10027C9AC(void *a1, void *a2)
{
  uint64_t result = sub_1001EFDE4(a1, a2);
  if (result)
  {
    sub_10027C9E4(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t sub_10027C9E4(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10017FA3C(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    sub_10027C94C((uint64_t)&v6, v3);
  }
  return v2;
}

void *sub_10027CA30(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = operator new(0x30uLL);
  void *v11 = 0;
  v11[1] = v7;
  long long v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100100330(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
      else {
        unint64_t v3 = v7;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
  }
  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    void *v11 = *v22;
LABEL_44:
    *unint64_t v22 = v11;
    goto LABEL_45;
  }
  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v23 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }
    else
    {
      v23 &= v8 - 1;
    }
    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_10027CC70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_10027CC84(uint64_t **a1, double *a2, _OWORD *a3)
{
  uint64_t v6 = (char *)operator new(0x48uLL);
  double v7 = *a2;
  *((double *)v6 + 4) = *a2;
  long long v8 = a3[1];
  *(_OWORD *)(v6 + 40) = *a3;
  *(_OWORD *)(v6 + 56) = v8;
  uint8x8_t v9 = a1 + 1;
  unint64_t v10 = a1[1];
  if (v10)
  {
    do
    {
      while (1)
      {
        uint8x8_t v9 = (uint64_t **)v10;
        if (v7 >= *((double *)v10 + 4)) {
          break;
        }
        unint64_t v10 = (uint64_t *)*v10;
        uint64_t v11 = v9;
        if (!*v9) {
          goto LABEL_8;
        }
      }
      unint64_t v10 = (uint64_t *)v10[1];
    }
    while (v10);
    uint64_t v11 = v9 + 1;
  }
  else
  {
    uint64_t v11 = a1 + 1;
  }
LABEL_8:
  sub_1000EDF90(a1, (uint64_t)v9, v11, (uint64_t *)v6);
  return v6;
}

uint64_t sub_10027CD24(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = sub_10027CD8C(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(void *)(a1 + 8) = v3;
  unint64_t v4 = (void *)v3[1];
  if (v4)
  {
    do
    {
      uint64_t v5 = v4;
      unint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      uint64_t v5 = (void *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      unint64_t v3 = v5;
    }
    while (!v6);
  }
  *(void *)(a1 + 8) = v5;
  return a1;
}

void *sub_10027CD8C(uint64_t **a1, double *a2, uint64_t a3)
{
  BOOL v6 = operator new(0x48uLL);
  long long v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  *((_OWORD *)v6 + 3) = v7;
  *((void *)v6 + 8) = *(void *)(a3 + 32);
  long long v8 = sub_10027CE20(a1, a2, &v10, (double *)v6 + 4);
  sub_1000EDF90(a1, (uint64_t)v10, (uint64_t **)v8, (uint64_t *)v6);
  return v6;
}

void sub_10027CE0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

double *sub_10027CE20(void *a1, double *a2, double **a3, double *a4)
{
  unint64_t v4 = (double *)(a1 + 1);
  if (a1 + 1 != (void *)a2 && a2[4] < *a4)
  {
    while (1)
    {
      uint64_t v5 = *(void *)v4;
      a2 = v4;
      if (!*(void *)v4) {
        break;
      }
      while (1)
      {
        unint64_t v4 = (double *)v5;
        if (*(double *)(v5 + 32) >= *a4) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          goto LABEL_19;
        }
      }
    }
LABEL_20:
    *a3 = v4;
    return a2;
  }
  double v6 = *a2;
  if ((double *)*a1 == a2)
  {
    long long v8 = a2;
  }
  else
  {
    if (v6 == 0.0)
    {
      uint8x8_t v9 = a2;
      do
      {
        long long v8 = (double *)*((void *)v9 + 2);
        BOOL v10 = *(void *)v8 == (void)v9;
        uint8x8_t v9 = v8;
      }
      while (v10);
    }
    else
    {
      double v7 = *a2;
      do
      {
        long long v8 = *(double **)&v7;
        double v7 = *(double *)(*(void *)&v7 + 8);
      }
      while (v7 != 0.0);
    }
    if (*a4 < v8[4])
    {
      while (1)
      {
        uint64_t v11 = *(void *)v4;
        a2 = v4;
        if (!*(void *)v4) {
          goto LABEL_20;
        }
        while (1)
        {
          unint64_t v4 = (double *)v11;
          if (*a4 < *(double *)(v11 + 32)) {
            break;
          }
          uint64_t v11 = *(void *)(v11 + 8);
          if (!v11)
          {
LABEL_19:
            a2 = v4 + 1;
            goto LABEL_20;
          }
        }
      }
    }
  }
  if (v6 == 0.0)
  {
    *a3 = a2;
  }
  else
  {
    *a3 = v8;
    return v8 + 1;
  }
  return a2;
}

long long *sub_10027CF08(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      long long v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        sub_1000DB0A0(v8);
      }
      *(_OWORD *)(a4 + 16) = v5[1];
      a4 += 32;
      v5 += 2;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

_OWORD *sub_10027CF7C(uint64_t **a1, unint64_t *a2, _OWORD *a3, void *a4)
{
  long long v7 = (void **)sub_10027D014((uint64_t)a1, &v11, a2);
  long long v8 = *v7;
  if (!*v7)
  {
    uint8x8_t v9 = (uint64_t **)v7;
    long long v8 = operator new(0x38uLL);
    v8[2] = *a3;
    *((void *)v8 + 6) = *a4;
    sub_1000EDF90(a1, v11, v9, (uint64_t *)v8);
  }
  return v8;
}

void *sub_10027D014(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        double v6 = v4;
        unint64_t v7 = bswap64(*a3);
        unint64_t v8 = bswap64(v6[4]);
        if (v7 == v8)
        {
          unint64_t v7 = bswap64(a3[1]);
          unint64_t v8 = bswap64(v6[5]);
          if (v7 == v8) {
            break;
          }
        }
        int v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0) {
          break;
        }
        unint64_t v4 = (void *)*v6;
        uint64_t result = v6;
        if (!*v6) {
          goto LABEL_20;
        }
      }
      unint64_t v10 = bswap64(v6[4]);
      unint64_t v11 = bswap64(*a3);
      if (v10 == v11)
      {
        unint64_t v10 = bswap64(v6[5]);
        unint64_t v11 = bswap64(a3[1]);
        if (v10 == v11) {
          break;
        }
      }
      int v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0) {
        break;
      }
      uint64_t result = v6 + 1;
      unint64_t v4 = (void *)v6[1];
    }
    while (v4);
  }
  else
  {
    double v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

void sub_10027D0DC(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_10027D10C((void **)a1, a2 - v3, a3);
  }
}

void sub_10027D10C(void **a1, unint64_t a2, void *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  int v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      BOOL v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      int v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      sub_1001D7FD4();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      float v15 = (char *)sub_1000DA54C(v6, v14);
    }
    else {
      float v15 = 0;
    }
    unint64_t v18 = &v15[8 * v12];
    unint64_t v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    uint64_t v21 = v18;
    do
    {
      *(void *)uint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    unint64_t v22 = &v15[8 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 8)
    {
      uint64_t v25 = *((void *)i - 1);
      *((void *)v18 - 1) = v25;
      v18 -= 8;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void sub_10027D230(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    sub_10027D260((void **)a1, a2 - v3, a3);
  }
}

void sub_10027D260(void **a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  int v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 2)
  {
    if (a2)
    {
      uint64_t v16 = 4 * a2;
      BOOL v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      int v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 2);
    if (v11 >> 62) {
      sub_1001D7FD4();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      float v15 = (char *)sub_10017EA34(v6, v14);
    }
    else {
      float v15 = 0;
    }
    unint64_t v18 = &v15[4 * v12];
    unint64_t v19 = &v18[4 * a2];
    uint64_t v20 = 4 * a2;
    uint64_t v21 = v18;
    do
    {
      *(_DWORD *)uint64_t v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    unint64_t v22 = &v15[4 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 4)
    {
      int v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

_OWORD *sub_10027D384(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_10027D014((uint64_t)a1, &v10, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    unint64_t v7 = operator new(0x38uLL);
    _DWORD v7[2] = **a4;
    *((void *)v7 + 6) = 0;
    sub_1000EDF90(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t sub_10027D410(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10027D488((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10027D488(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 32);
      a3 -= 32;
      *(_OWORD *)(v7 - 32) = v8;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(a3 + 16);
      uint64_t v7 = *((void *)&v14 + 1) - 32;
      *((void *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_10027D520((uint64_t)v11);
  return v9;
}

uint64_t sub_10027D520(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10027D558(a1);
  }
  return a1;
}

void sub_10027D558(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_1000DB0A0(v3);
    }
    v1 += 32;
  }
}

void **sub_10027D59C(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10027D5D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 32;
    unint64_t v4 = *(std::__shared_weak_count **)(v1 - 24);
    if (v4)
    {
      sub_1000DB0A0(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 32;
    }
  }
}

void *sub_10027D624(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v9) {
        unint64_t v4 = v8 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1]) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  float v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x38uLL);
  void *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[5] = 0;
  i[6] = 0;
  i[4] = 0;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100100330(a1, v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    void *i = *v23;
LABEL_44:
    *unint64_t v23 = i;
    goto LABEL_45;
  }
  void *i = *v15;
  void *v15 = i;
  *(void *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v24 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9) {
        v24 %= v9;
      }
    }
    else
    {
      v24 &= v9 - 1;
    }
    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_10027D894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_10027C94C(v11, v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10027D8B0(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  unint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10027D934((uint64_t **)a1, v4, v6, v6);
      v6 += 2;
    }
    while (v6 != a3);
  }
  return a1;
}

void sub_10027D91C(_Unwind_Exception *a1)
{
  sub_1000F5BB0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_10027D934(uint64_t **a1, void *a2, unint64_t *a3, _OWORD *a4)
{
  uint64_t v6 = (void **)sub_10027D9BC(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    sub_1000EDF90(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void *sub_10027D9BC(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  if (a1 + 1 == a2
    || ((unint64_t v5 = bswap64(*a5), v6 = bswap64(*(void *)((char *)a2 + 25)), v5 != v6)
     || (unint64_t v5 = bswap64(a5[1]), v6 = bswap64(*(void *)((char *)a2 + 33)), v5 != v6))
    && (v5 < v6 ? (int v10 = -1) : (int v10 = 1), v10 < 0))
  {
    uint64_t v7 = *a2;
    if ((void *)*a1 == a2)
    {
      unint64_t v9 = a2;
    }
    else
    {
      if (v7)
      {
        unint64_t v8 = (void *)*a2;
        do
        {
          unint64_t v9 = v8;
          unint64_t v8 = (void *)v8[1];
        }
        while (v8);
      }
      else
      {
        float v16 = a2;
        do
        {
          unint64_t v9 = (void *)v16[2];
          BOOL v17 = *v9 == (void)v16;
          float v16 = v9;
        }
        while (v17);
      }
      unint64_t v18 = bswap64(*(void *)((char *)v9 + 25));
      unint64_t v19 = bswap64(*a5);
      if (v18 == v19)
      {
        unint64_t v18 = bswap64(*(void *)((char *)v9 + 33));
        unint64_t v19 = bswap64(a5[1]);
        if (v18 == v19) {
          return sub_10027DBC4((uint64_t)a1, a3, a5);
        }
      }
      int v20 = v18 < v19 ? -1 : 1;
      if ((v20 & 0x80000000) == 0) {
        return sub_10027DBC4((uint64_t)a1, a3, a5);
      }
    }
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  unint64_t v11 = bswap64(*(void *)((char *)a2 + 25));
  unint64_t v12 = bswap64(*a5);
  if (v11 != v12 || (v11 = bswap64(*(void *)((char *)a2 + 33)), unint64_t v12 = bswap64(a5[1]), v11 != v12))
  {
    int v15 = v11 < v12 ? -1 : 1;
    if (v15 < 0)
    {
      uint64_t v13 = a2[1];
      if (v13)
      {
        long long v14 = (void *)a2[1];
        do
        {
          a4 = v14;
          long long v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        size_t v21 = a2;
        do
        {
          a4 = (void *)v21[2];
          BOOL v17 = *a4 == (void)v21;
          size_t v21 = a4;
        }
        while (!v17);
      }
      if (a4 == a1 + 1
        || ((unint64_t v22 = bswap64(*a5), v23 = bswap64(*(void *)((char *)a4 + 25)), v22 != v23)
         || (unint64_t v22 = bswap64(a5[1]), v23 = bswap64(*(void *)((char *)a4 + 33)), v22 != v23)
          ? (v22 < v23
           ? (int v24 = -1)
           : (int v24 = 1))
          : (int v24 = 0),
            v24 < 0))
      {
        if (v13)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
      return sub_10027DBC4((uint64_t)a1, a3, a5);
    }
  }
  *a3 = a2;
  *a4 = a2;
  return a4;
}

void *sub_10027DBC4(uint64_t a1, void *a2, unint64_t *a3)
{
  unint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        unint64_t v6 = v4;
        unint64_t v7 = bswap64(*a3);
        unint64_t v8 = bswap64(*(void *)((char *)v6 + 25));
        if (v7 == v8)
        {
          unint64_t v7 = bswap64(a3[1]);
          unint64_t v8 = bswap64(*(void *)((char *)v6 + 33));
          if (v7 == v8) {
            break;
          }
        }
        int v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0) {
          break;
        }
        unint64_t v4 = (void *)*v6;
        uint64_t result = v6;
        if (!*v6) {
          goto LABEL_20;
        }
      }
      unint64_t v10 = bswap64(*(void *)((char *)v6 + 25));
      unint64_t v11 = bswap64(*a3);
      if (v10 == v11)
      {
        unint64_t v10 = bswap64(*(void *)((char *)v6 + 33));
        unint64_t v11 = bswap64(a3[1]);
        if (v10 == v11) {
          break;
        }
      }
      int v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0) {
        break;
      }
      uint64_t result = v6 + 1;
      unint64_t v4 = (void *)v6[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

void *sub_10027DC8C(void *a1, void *a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2;
    do
    {
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unint64_t v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      unint64_t v5 = v7;
    }
    while (v7 != a3);
  }
  sub_10027DD14(a1, a2, a3, v4);
  return a1;
}

void *sub_10027DD14(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = (uint64_t)result;
    sub_10022F168(result, a4);
    return (void *)sub_10027DD84(v6, a2, a3);
  }
  return result;
}

void sub_10027DD68(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027DD84(uint64_t result, void *a2, void *a3)
{
  unint64_t v3 = *(_OWORD **)(result + 8);
  if (a2 != a3)
  {
    do
    {
      _OWORD *v3 = *(_OWORD *)((char *)a2 + 25);
      unint64_t v4 = (void *)a2[1];
      if (v4)
      {
        do
        {
          unint64_t v5 = v4;
          unint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          unint64_t v5 = (void *)a2[2];
          BOOL v6 = *v5 == (void)a2;
          a2 = v5;
        }
        while (!v6);
      }
      ++v3;
      a2 = v5;
    }
    while (v5 != a3);
  }
  *(void *)(result + 8) = v3;
  return result;
}

void *sub_10027DDDC(void *a1, void *a2)
{
  uint64_t result = sub_100222004(a1, a2);
  if (result)
  {
    unint64_t v4 = result;
    do
    {
      unint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

uint64_t *sub_10027DE2C(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = *(_DWORD **)(*a1 + 8);
  BOOL v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    BOOL v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      sub_1001D7FD4();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)sub_10017EA34((uint64_t)v6, v12);
      BOOL v8 = *(_DWORD **)v4;
      unint64_t v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    long long v14 = &v13[4 * v9];
    int v15 = &v13[4 * v12];
    *(_DWORD *)long long v14 = *a2;
    unint64_t v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *unint64_t v5 = *a2;
    unint64_t v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void sub_10027DF1C(char **a1, unint64_t a2)
{
  BOOL v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    BOOL v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      sub_1001D7FD4();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      long long v14 = (char *)sub_10017EA34(v4, v13);
      BOOL v8 = *a1;
      unint64_t v7 = a1[1];
    }
    else
    {
      long long v14 = 0;
    }
    int v15 = &v14[4 * v11];
    int v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    BOOL v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

char *sub_10027E038(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  unint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    unint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      int v18 = (char *)sub_1000C571C(v9, v17);
    }
    else {
      int v18 = 0;
    }
    char v28 = &v18[16 * v15];
    std::string __p = v18;
    uint64_t v34 = v28;
    uint64_t v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    int v30 = &v28[16 * a5];
    do
    {
      long long v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)char v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    __int16 v35 = v30;
    unint64_t v5 = (char *)sub_10027E248((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    size_t v21 = &__src[16 * a5];
    unint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[16 * a5];
    int v25 = &v23[-16 * a5];
    unint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      unint64_t v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)unint64_t v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  size_t v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  unint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_10027E210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10027E248(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(void **)(a2 + 8);
  BOOL v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    BOOL v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      unint64_t v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  unint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void sub_10027E320(void **a1, unint64_t a2)
{
  BOOL v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)sub_1000C571C(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[16 * v10];
    uint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    int v18 = (char *)*a1;
    unint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      unint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *sub_10027E440(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL) {
    sub_1001D7FA0();
  }
  return operator new(20 * a2);
}

void sub_10027E488()
{
}

void sub_10027E4B0(void *a1@<X1>, unsigned char *a2@<X2>, double *a3@<X3>, unsigned char *a4@<X8>)
{
  if (objc_msgSend(objc_msgSend(a1, "bundleId"), "isEqualToString:", &stru_10234F018))
  {
    double v8 = *a3;
    sub_10023D93C((uint64_t)v15);
    sub_10027E828((uint64_t)v15, 0, 0, 3u, (uint64_t)v19, v8);
    buf[0] = 0;
    sub_1002660C8(v22);
    *a4 = buf[0];
    sub_1002660C8(a4 + 8);
  }
  else
  {
    unint64_t v9 = (const std::string::value_type *)[objc_msgSend(objc_msgSend(a1, "launchReason", sub_10023D93C((uint64_t)v15)), "UTF8String");
    v18 |= 8u;
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v17, v9);
    v18 |= 4u;
    if (!v16) {
      operator new();
    }
    sub_10024D6B4(v16, a2);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A27F8);
    }
    uint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = v17;
      if (SHIBYTE(v17->__r_.__value_.__r.__words[2]) < 0) {
        uint64_t v11 = (std::string *)v17->__r_.__value_.__r.__words[0];
      }
      int v12 = v18 | 4;
      v18 |= 4u;
      if (!v16) {
        operator new();
      }
      int v13 = *(unsigned __int8 *)(v16 + 8);
      int v18 = v12;
      int v14 = *(unsigned __int8 *)(v16 + 9);
      *(_DWORD *)uint64_t buf = 68289794;
      int v21 = 0;
      v22[0] = 34;
      v22[1] = 8;
      unint64_t v23 = "";
      __int16 v24 = 2082;
      int v25 = v11;
      __int16 v26 = 1026;
      int v27 = v13;
      __int16 v28 = 1026;
      int v29 = v14;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appLaunch\", \"launchReason\":%{public, location:escape_only}s, \"islongformvideo\":%{public}hhd, \"is MR allowed app\":%{public}hhd}", buf, 0x28u);
    }
    sub_10027E828((uint64_t)v15, 0, 0, 3u, (uint64_t)v19, *a3);
    buf[0] = 1;
    sub_1002660C8(v22);
    *a4 = buf[0];
    sub_1002660C8(a4 + 8);
  }
  sub_10026633C(v22);
  sub_10026633C(v19);
  sub_10024F198((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_10027E7B4()
{
}

void sub_10027E828(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 32);
  if (!sub_10023E774(v12))
  {
    int v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    uint64_t v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    int v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    uint64_t v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E6374(a5, a1);
}

void sub_10027E910(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_10027E924(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_10027E954(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  v7[0] = off_1022A2890;
  v7[1] = a1;
  v7[3] = v7;
  v8[0] = off_1022A2910;
  v8[1] = a1;
  v8[3] = v8;
  v9[0] = off_1022A2990;
  v9[1] = a1;
  v9[3] = v9;
  v10[0] = off_1022A2A10;
  v10[1] = a1;
  uint64_t v10[3] = v10;
  v11[0] = off_1022A2A90;
  v11[1] = a1;
  void v11[3] = v11;
  v12[0] = off_1022A2B10;
  v12[1] = a1;
  v12[3] = v12;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  uint64_t v4 = (char *)operator new(0xC0uLL);
  a1[4] = v4 + 192;
  a1[2] = v4;
  a1[3] = v4;
  a1[3] = sub_10022EFC8((uint64_t)(a1 + 4), (uint64_t)v7, (uint64_t)&v13, (uint64_t)v4);
  for (uint64_t i = 20; i != -4; i -= 4)
    sub_10022E964(&v7[i]);
  return a1;
}

void sub_10027EAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 24) = v14;
  sub_10022F0E4(&a10);
  for (uint64_t i = 160; i != -32; i -= 32)
    sub_10022E964(&a12 + i);
  _Unwind_Resume(a1);
}

uint64_t sub_10027EB34()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearningLabeledRecordingTriggersLimit", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 250;
  }
}

void sub_10027EBC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027EBE4@<X0>(uint64_t a1@<X0>, long long *a2@<X2>, uint64_t a3@<X8>)
{
  sub_1003335FC(a3);
  uint64_t result = sub_10027ED70();
  if (result)
  {
    sub_100201854(*(void *)(a1 + 8), a2, v15);
    if (v17
      || *a2 != 0
      && (uint64_t v9 = *(void *)(a1 + 8),
          long long v10 = 0uLL,
          sub_100201854(v9, &v10, v11),
          sub_100288A94((uint64_t)v15, (uint64_t)v11),
          sub_100288C48((uint64_t)v11),
          v17))
    {
      uint64_t v7 = v16;
      if (!v16) {
        uint64_t v7 = *(void *)(qword_102489B20 + 24);
      }
      uint64_t v8 = *(void *)(v7 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_102489B10 + 8);
      }
      sub_100333654((uint64_t)v11, v8);
      if (v11 != (unsigned char *)a3)
      {
        *(_DWORD *)(a3 + 32) = v13;
        sub_1001EEAA8((void *)a3, v12, 0);
      }
      *(_OWORD *)(a3 + 40) = v14;
      sub_1000D7D80((uint64_t)v11);
    }
    return sub_100288C48((uint64_t)v15);
  }
  return result;
}

void sub_10027ED24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_100288C48((uint64_t)&a12);
  sub_100288C48((uint64_t)&a27);
  sub_1000D7D80(v27);
  _Unwind_Resume(a1);
}

uint64_t sub_10027ED70()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAdaptiveAnchorsEnable", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_10027EE04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027EE20(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  v31[0] = a5;
  v31[1] = a6;
  if (a3[1] != *a3)
  {
    sub_101A56EFC();
    goto LABEL_31;
  }
  if (*(void *)(a4 + 8) != *(void *)a4)
  {
    sub_101A56D8C();
LABEL_31:
    __break(1u);
  }
  char v10 = a5;
  uint64_t v14 = a2 + 24;
  sub_1001FC998(*(void *)(a1 + 8), a2 + 24, a5, a6, a8, __p, 0.0);
  sub_10028A9B0(a3);
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = v27;
  __p[1] = 0;
  uint64_t v27 = 0;
  __p[0] = 0;
  *(void *)&long long v29 = __p;
  sub_1001E7FBC((void ***)&v29);
  uint64_t v15 = a3[1] - *a3;
  if (a8 > (unint64_t)(v15 >> 6))
  {
    if (v10)
    {
LABEL_5:
      sub_1001FC998(*(void *)(a1 + 8), v14, 0, 0, a8 - ((unint64_t)v15 >> 6), __p, 0.0);
      sub_10028A9EC(a3, a3[1], (uint64_t)__p[0], (long long *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(void *)&long long v29 = __p;
      sub_1001E7FBC((void ***)&v29);
    }
    else
    {
      uint64_t v24 = 1;
      while (v24 != 16)
      {
        if (*((unsigned __int8 *)v31 + v24++))
        {
          if ((unint64_t)(v24 - 2) <= 0xE) {
            goto LABEL_5;
          }
          break;
        }
      }
    }
  }
  int v16 = *(char *)(a2 + 23);
  if (v16 < 0)
  {
    if (*(void *)(a2 + 8) != 10) {
      goto LABEL_18;
    }
    uint64_t v17 = *(void *)a2;
  }
  else
  {
    uint64_t v17 = a2;
    if (v16 != 10) {
      goto LABEL_18;
    }
  }
  uint64_t v18 = *(void *)v17;
  int v19 = *(unsigned __int16 *)(v17 + 8);
  if (v18 == 0x6F6D2D7375636F66 && v19 == 25956)
  {
    uint64_t v21 = a3[1] - *a3;
    if (a8 > (unint64_t)(v21 >> 6))
    {
      sub_1001FC998(*(void *)(a1 + 8), a2, 0, 0, a8 - ((unint64_t)v21 >> 6), __p, 0.0);
      sub_10028A9EC(a3, a3[1], (uint64_t)__p[0], (long long *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(void *)&long long v29 = __p;
      sub_1001E7FBC((void ***)&v29);
    }
  }
LABEL_18:
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v23 = (long long *)*a3;
  int64_t v22 = (long long *)a3[1];
  uint64_t v27 = 0;
  __int16 v28 = __p;
  while (v23 != v22)
  {
    long long v29 = *v23;
    sub_10020D800(&v28, &v29);
    v23 += 4;
  }
  sub_1001FD8C4(*(void *)(a1 + 8), (uint64_t)__p, &v29);
  sub_10028B08C((void **)a4);
  *(_OWORD *)a4 = v29;
  *(void *)(a4 + 16) = v30;
  uint64_t v30 = 0;
  __int16 v28 = (void **)&v29;
  long long v29 = 0uLL;
  sub_1001EF794(&v28);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_10027F0E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void **p_p)
{
  p_p = &__p;
  sub_1001E7FBC(&p_p);
  _Unwind_Resume(a1);
}

void sub_10027F124(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v138 = a3;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)v163 = 2082;
    *(void *)&v163[2] = "";
    *(_WORD *)&v163[10] = 2050;
    *(void *)&v163[12] = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"start learn model\", \"model-type\":%{public}lu}", buf, 0x1Cu);
  }
  sub_1000C7F88(buf);
  LOBYTE(__p) = 0;
  CFAllocatorRef v6 = kCFAllocatorNull;
  CFStringRef v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableLearning", 0x8000100u, kCFAllocatorNull);
  int v8 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v7, (BOOL *)&__p);
  CFRelease(v7);
  int v9 = __p;
  if (*(void *)v163) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v163);
  }
  if (v9) {
    int v10 = 0;
  }
  else {
    int v10 = v8;
  }
  if (v10 == 1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#Warning Tried to run learning, but learning is disabled", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      LOWORD(__p) = 0;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v12);
LABEL_55:
      if (v12 != (char *)buf) {
        free(v12);
      }
      return;
    }
    return;
  }
  sub_1000C7F88(&__p);
  *(void *)v145 = 0;
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnabledModelTypes", 0x8000100u, kCFAllocatorNull);
  BOOL v14 = sub_1004D1D1C((uint64_t)__p, v13, (CFTypeRef *)v145);
  CFRelease(v13);
  if (v14)
  {
    sub_100288C8C(*(const __CFArray **)v145, (uint64_t)buf);
  }
  else
  {
    *(void *)v163 = 0;
    *(void *)uint64_t buf = 0;
    *(void *)&v163[8] = 0;
    *(void *)uint64_t buf = operator new(8uLL);
    *(_OWORD *)v163 = xmmword_101D07560;
    sub_100289148(buf, byte_101D08FC0, &byte_101D08FC0[3], 3);
  }
  if (v159) {
    sub_1000DB0A0(v159);
  }
  int v104 = a1;
  if (*(void *)v163 <= (unint64_t)v138) {
    sub_100273D6C();
  }
  unint64_t v15 = *(void *)(*(void *)buf + (((unint64_t)v138 >> 3) & 0x1FFFFFF8));
  operator delete(*(void **)buf);
  if (((v15 >> v138) & 1) == 0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    int v25 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67174657;
      *(_DWORD *)&uint8_t buf[4] = v138;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "Model Type %{private}d disabled in settings", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      LODWORD(__p) = 67174657;
      HIDWORD(__p) = v138;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v12);
      goto LABEL_55;
    }
    return;
  }
  sub_100206EC0(v104[1]);
  if (sub_1002083F4(v104[1]))
  {
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_100103240();
    if (!sub_10073E30C()) {
      goto LABEL_34;
    }
    sub_1000C7F88(buf);
    LOBYTE(__p) = 0;
    CFStringRef v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableSamplingForLearningAnalyticsOnInternal", 0x8000100u, kCFAllocatorNull);
    int v18 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v17, (BOOL *)&__p);
    CFRelease(v17);
    int v19 = __p;
    if (*(void *)v163) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v163);
    }
    int v20 = v19 ? v18 : 0;
    if (v20 != 1)
    {
      BOOL v24 = 1;
    }
    else
    {
LABEL_34:
      sub_1000C7F88(buf);
      std::string __p = 0;
      CFStringRef v21 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSamplingRateForLearningAnalytics", 0x8000100u, kCFAllocatorNull);
      int v22 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v21, &__p);
      CFRelease(v21);
      double v23 = *(double *)&__p;
      if (*(void *)v163) {
        sub_1000DB0A0(*(std::__shared_weak_count **)v163);
      }
      if (!v22) {
        double v23 = 0.1;
      }
      BOOL v24 = (double)arc4random_uniform(0xF4241u) / 1000000.0 <= v23;
    }
    char v137 = 0;
    sub_1000C7F88(buf);
    LOBYTE(__p) = 0;
    CFStringRef v27 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
    int v28 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v27, (BOOL *)&__p);
    CFRelease(v27);
    int v29 = __p;
    if (*(void *)v163) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v163);
    }
    int v30 = v28 ^ 1;
    if (v29) {
      int v30 = 1;
    }
    char v137 = v30;
    int v31 = v24 & v30;
    unsigned __int8 v136 = v24 & v30;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v32 = (uint64_t)v104;
    uint64_t v33 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      sub_1002E8898((void *)v138, (uint64_t)&__p);
      uint64_t v34 = v160 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)v163 = 2082;
      *(void *)&v163[2] = "";
      *(_WORD *)&v163[10] = 2082;
      *(void *)&v163[12] = v34;
      *(_WORD *)&v163[20] = 1026;
      *(_DWORD *)&v163[22] = v31;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Analytics events for learning\", \"model type\":%{public, location:escape_only}s, \"enabled\":%{public}hhd}", buf, 0x22u);
      if (v160 < 0) {
        operator delete(__p);
      }
    }
    sub_1002A9A64(v138, (char **)&v134);
    if (v134 == v135)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v40 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v138;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#Warning No recording events for model type %{public}d", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        LODWORD(__p) = 67240192;
        HIDWORD(__p) = v138;
        unint64_t v41 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v41);
        if (v41 != (char *)buf) {
          free(v41);
        }
      }
      goto LABEL_235;
    }
    LOBYTE(__p) = 0;
    char v161 = 0;
    v157[0] = 0;
    v157[112] = 0;
    LOBYTE(v132) = 0;
    char v133 = 0;
    memset(v130, 0, sizeof(v130));
    int v131 = 1065353216;
    v129[0] = v104;
    v129[1] = &v138;
    v129[2] = &v137;
    v129[3] = &__p;
    v129[4] = v157;
    v129[5] = &v132;
    if (v138 == 2)
    {
      sub_1002822D4((uint64_t)v104, 4u, 0, (uint64_t *)&v127);
      if (v127 == v128)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        int v95 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)uint64_t buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)v163 = 2082;
          *(void *)&v163[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning, no such clients\"}", buf, 0x12u);
        }
      }
      else
      {
        sub_1001FF120(v104[1], &v122);
        buf[0] = 0;
        v163[16] = 0;
        id v99 = sub_10026FC8C(v31, (void *)v138, (const std::string *)buf);
        if (v163[16] && (v163[15] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v44 = v122;
        uint64_t v43 = v123;
        if (v122 != v123)
        {
          uint64_t v98 = v123;
          do
          {
            int v100 = (uint64_t *)(v44 + 40);
            unint64_t v103 = sub_1002CA5F4((uint64_t *)(v44 + 40));
            if (v45)
            {
              v119 = 0;
              uint64_t v120 = 0;
              unsigned int v118 = 0;
              sub_10010F834(&v118, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
              sub_100281244((uint64_t)v104, (uint64_t)&v118, *(void *)(v44 + 24), *(void *)(v44 + 32), (uint64_t)v121);
              if (v118)
              {
                v119 = v118;
                operator delete(v118);
              }
              sub_10027EBE4((uint64_t)v104, (long long *)(v44 + 24), (uint64_t)v117);
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A2818);
              }
              unint64_t v46 = qword_102419458;
              if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
              {
                int v47 = (char *)operator new(0x28uLL);
                *(void *)v145 = v47;
                *(_OWORD *)v146 = xmmword_101D048C0;
                *(_OWORD *)int v47 = 0u;
                *((_OWORD *)v47 + 1) = 0u;
                *(void *)(v47 + 29) = 0;
                sub_1001E0650(v44 + 24, v47);
                long long v48 = v146[15] >= 0 ? v145 : *(uint8_t **)v145;
                *(_DWORD *)uint64_t buf = 68289282;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v163 = 2082;
                *(void *)&v163[2] = "";
                *(_WORD *)&v163[10] = 2082;
                *(void *)&v163[12] = v48;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning internal model for LOI\", \"loiGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
                if ((v146[15] & 0x80000000) != 0) {
                  operator delete(*(void **)v145);
                }
              }
              v145[0] = 0;
              char v156 = 0;
              sub_100282AAC((uint64_t)v104, v99, (uint64_t)v121, a2, (uint64_t)v130, v44 + 24, (uint64_t)v145, (uint64_t)buf, Current_5, v138);
              sub_1001EF39C((uint64_t)v145);
              if (v169 && sub_100278D98((uint64_t)buf))
              {
                if (!v169) {
                  sub_10020D700();
                }
                LOBYTE(v113) = 0;
                char v116 = 0;
                sub_1000C7F88(v145);
                LOBYTE(v141) = 0;
                CFStringRef v49 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterAnchorValueStatisticsEnabled", 0x8000100u, v6);
                char v50 = sub_1000D29FC(*(uint64_t *)v145, (uint64_t)v49, (BOOL *)&v141);
                CFRelease(v49);
                int v51 = v141;
                if (*(void *)v146) {
                  sub_1000DB0A0(*(std::__shared_weak_count **)v146);
                }
                if (v51) {
                  char v52 = 0;
                }
                else {
                  char v52 = v50;
                }
                if ((v52 & 1) == 0) {
                  sub_100284878((uint64_t)&v113);
                }
                int v102 = v128;
                id v53 = v99;
                if (v127 != v128)
                {
                  uint64_t v54 = v127 + 3;
                  do
                  {
                    unint64_t v55 = sub_1002D4B0C((unint64_t)v54[3]);
                    if (v103 >= 0x20) {
                      sub_10000EDDC("bitset test argument out of range");
                    }
                    if ((v55 & (1 << v103)) != 0)
                    {
                      if (qword_102419450 != -1) {
                        dispatch_once(&qword_102419450, &stru_1022A2818);
                      }
                      char v56 = v54 - 3;
                      long long v57 = qword_102419458;
                      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v58 = v54 - 3;
                        if (*((char *)v54 - 1) < 0) {
                          uint64_t v58 = (void **)*v56;
                        }
                        long long v59 = v54;
                        if (*((char *)v54 + 23) < 0) {
                          long long v59 = *v54;
                        }
                        unint64_t v60 = operator new(0x28uLL);
                        v141 = v60;
                        long long v142 = xmmword_101D048C0;
                        *unint64_t v60 = 0u;
                        v60[1] = 0u;
                        *(void *)((char *)v60 + 29) = 0;
                        sub_1001E0650(v44 + 24, v60);
                        uint64_t v61 = &v141;
                        if (v142 < 0) {
                          uint64_t v61 = v141;
                        }
                        id v53 = v99;
                        uint64_t v62 = v44 + 40;
                        if (*(char *)(v44 + 63) < 0) {
                          uint64_t v62 = *v100;
                        }
                        *(_DWORD *)v145 = 68290050;
                        *(_DWORD *)&v145[4] = 0;
                        *(_WORD *)v146 = 2082;
                        *(void *)&v146[2] = "";
                        *(_WORD *)&v146[10] = 2082;
                        *(void *)&v146[12] = v58;
                        __int16 v147 = 2082;
                        v148 = v59;
                        __int16 v149 = 2082;
                        v150 = v61;
                        __int16 v151 = 2082;
                        uint64_t v152 = v62;
                        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning a Location Similarity List model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", v145, 0x3Au);
                        if (SHIBYTE(v142) < 0) {
                          operator delete(v141);
                        }
                        uint64_t v32 = (uint64_t)v104;
                      }
                      if (v53)
                      {
                        v63 = +[NSMutableDictionary dictionaryWithDictionary:v53];
                        unint64_t v64 = v54 - 3;
                        if (*((char *)v54 - 1) < 0) {
                          unint64_t v64 = (void **)*v56;
                        }
                        [(NSMutableDictionary *)v63 setObject:+[NSString stringWithUTF8String:v64] forKeyedSubscript:@"clientIdentifier"];
                      }
                      else
                      {
                        v63 = 0;
                      }
                      uint64_t v65 = *(void *)(v32 + 8);
                      if (*((char *)v54 + 23) < 0)
                      {
                        sub_1000DC48C(__dst, *v54, (unint64_t)v54[1]);
                      }
                      else
                      {
                        long long v66 = *(_OWORD *)v54;
                        int v111 = v54[2];
                        *(_OWORD *)__dst = v66;
                      }
                      char v112 = 1;
                      long long v143 = *(_OWORD *)(v44 + 24);
                      char v144 = 1;
                      sub_1001FED60(v65, 2u, (long long *)__dst, &v143, v145);
                      if (v112 && SHIBYTE(v111) < 0) {
                        operator delete(__dst[0]);
                      }
                      LOBYTE(v107) = 0;
                      char v109 = 0;
                      if (v156)
                      {
                        unint64_t v107 = v154 | ((unint64_t)v153 << 32);
                        uint64_t v108 = *(void *)&v146[8];
                        char v109 = 1;
                      }
                      sub_1001F2564((uint64_t)v145);
                      memset(v106, 0, sizeof(v106));
                      sub_10010F834(v106, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
                      sub_1002848C0(v32, Current_5, (uint64_t)v63, a2, (uint64_t)(v54 - 3), (uint64_t)buf, (uint64_t *)(v44 + 24), (uint64_t)v106);
                    }
                    long long v67 = v54 + 4;
                    v54 += 7;
                  }
                  while (v67 != v102);
                }
                if (v116) {
                  sub_100289AB8((uint64_t)&v113);
                }
                uint64_t v43 = v98;
                CFAllocatorRef v6 = kCFAllocatorNull;
              }
              else
              {
                if (qword_102419450 != -1) {
                  dispatch_once(&qword_102419450, &stru_1022A2818);
                }
                long long v68 = qword_102419458;
                if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v145 = 68289026;
                  *(_DWORD *)&v145[4] = 0;
                  *(_WORD *)v146 = 2082;
                  *(void *)&v146[2] = "";
                  _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, unsupervised model not created or is invalid so learning is skipped\"}", v145, 0x12u);
                }
              }
              sub_100289B38((uint64_t)buf);
              sub_1000D7D80((uint64_t)v117);
              *(void *)uint64_t buf = v121;
              sub_1001EF794((void ***)buf);
            }
            else
            {
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A2818);
              }
              long long v69 = qword_102419458;
              if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
              {
                int v70 = (char *)operator new(0x28uLL);
                *(void *)v145 = v70;
                *(_OWORD *)v146 = xmmword_101D048C0;
                *(_OWORD *)int v70 = 0u;
                *((_OWORD *)v70 + 1) = 0u;
                *(void *)(v70 + 29) = 0;
                sub_1001E0650(v44 + 24, v70);
                if (v146[15] >= 0) {
                  CFArrayRef v71 = (const __CFArray *)v145;
                }
                else {
                  CFArrayRef v71 = *(const __CFArray **)v145;
                }
                uint64_t v72 = v44 + 40;
                if (*(char *)(v44 + 63) < 0) {
                  uint64_t v72 = *v100;
                }
                *(_DWORD *)uint64_t buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v163 = 2082;
                *(void *)&v163[2] = "";
                *(_WORD *)&v163[10] = 2082;
                *(void *)&v163[12] = v71;
                *(_WORD *)&v163[20] = 2082;
                *(void *)&v163[22] = v72;
                _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                if ((v146[15] & 0x80000000) != 0) {
                  operator delete(*(void **)v145);
                }
              }
            }
            v44 += 64;
          }
          while (v44 != v43);
        }
        *(void *)uint64_t buf = &v122;
        sub_10020D8FC((void ***)buf);
      }
      uint64_t v42 = (uint8_t *)&v127;
    }
    else
    {
      if (v138 != 1)
      {
        if (v138)
        {
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2818);
          }
          long long v73 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v163 = 2082;
            *(void *)&v163[2] = "";
            *(_WORD *)&v163[10] = 2050;
            *(void *)&v163[12] = v138;
            _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A2818);
            }
          }
          long long v74 = qword_102419458;
          if (os_signpost_enabled((os_log_t)qword_102419458))
          {
            *(_DWORD *)uint64_t buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v163 = 2082;
            *(void *)&v163[2] = "";
            *(_WORD *)&v163[10] = 2050;
            *(void *)&v163[12] = v138;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v74, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid model type", "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
          }
        }
        else
        {
          sub_1001FF120(v104[1], (uint64_t *)v139);
          sub_10020420C(v104[1], 1u, v117);
          __int16 v35 = (uint64_t *)&v114;
          unsigned int v114 = 0;
          uint64_t v115 = 0;
          int v113 = (uint64_t *)&v114;
          uint64_t v37 = (void **)v117[0];
          uint64_t v36 = (void **)v117[1];
          while (v37 != v36)
          {
            unint64_t v39 = *v37;
            uint64_t v38 = (uint64_t)(v37 + 4);
            sub_1002D4C7C(v39, v38, buf);
            sub_10010702C(&v113, (const void **)buf, (uint64_t)buf);
            if ((v163[15] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v37 = (void **)(v38 + 56);
          }
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2818);
          }
          int v75 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v163 = 2082;
            *(void *)&v163[2] = "";
            *(_WORD *)&v163[10] = 2050;
            *(void *)&v163[12] = v115;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for clients\", \"Num Clients\":%{public}lu}", buf, 0x1Cu);
          }
          uint64_t v76 = *(void *)v139;
          uint64_t v77 = v140;
          if (*(void **)v139 != v140)
          {
            int v101 = v140;
            do
            {
              int v78 = (void ***)(v76 + 40);
              uint64_t v79 = sub_1002CA5F4((uint64_t *)(v76 + 40));
              if (v80) {
                BOOL v81 = v79 == 0;
              }
              else {
                BOOL v81 = 0;
              }
              if (v81)
              {
                uint64_t v125 = 0;
                uint64_t v126 = 0;
                int v124 = 0;
                sub_10010F834(&v124, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
                sub_100281244((uint64_t)v104, (uint64_t)&v124, *(void *)(v76 + 24), *(void *)(v76 + 32), (uint64_t)&v127);
                if (v124)
                {
                  uint64_t v125 = v124;
                  operator delete(v124);
                }
                sub_10027EBE4((uint64_t)v104, (long long *)(v76 + 24), (uint64_t)&v141);
                unsigned int v85 = v113;
                if (v113 != v35)
                {
                  do
                  {
                    buf[0] = 0;
                    v163[16] = 0;
                    id v86 = sub_10026FC8C(v136, (void *)v138, (const std::string *)buf);
                    if (v163[16] && (v163[15] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                    if (qword_102419450 != -1) {
                      dispatch_once(&qword_102419450, &stru_1022A2818);
                    }
                    int v87 = qword_102419458;
                    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
                    {
                      v88 = v35;
                      uint64_t v89 = v85 + 4;
                      if (*((char *)v85 + 55) < 0) {
                        uint64_t v89 = (uint64_t *)v85[4];
                      }
                      v90 = (char *)operator new(0x28uLL);
                      *(void *)v145 = v90;
                      *(_OWORD *)v146 = xmmword_101D048C0;
                      *(_OWORD *)v90 = 0u;
                      *((_OWORD *)v90 + 1) = 0u;
                      *(void *)(v90 + 29) = 0;
                      sub_1001E0650(v76 + 24, v90);
                      CFArrayRef v91 = (const __CFArray *)v145;
                      if (v146[15] < 0) {
                        CFArrayRef v91 = *(const __CFArray **)v145;
                      }
                      int v92 = (void **)(v76 + 40);
                      if (*(char *)(v76 + 63) < 0) {
                        int v92 = *v78;
                      }
                      *(_DWORD *)uint64_t buf = 68289794;
                      *(_DWORD *)&uint8_t buf[4] = 0;
                      *(_WORD *)v163 = 2082;
                      *(void *)&v163[2] = "";
                      *(_WORD *)&v163[10] = 2082;
                      *(void *)&v163[12] = v89;
                      *(_WORD *)&v163[20] = 2082;
                      *(void *)&v163[22] = v91;
                      *(_WORD *)&v163[30] = 2082;
                      v164 = v92;
                      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for client\", \"Client ID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x30u);
                      if ((v146[15] & 0x80000000) != 0) {
                        operator delete(*(void **)v145);
                      }
                      __int16 v35 = v88;
                    }
                    sub_100281364((uint64_t)v104, (uint64_t)(v85 + 4), *(void *)(v76 + 24), *(void *)(v76 + 32), (uint64_t)buf);
                    sub_100281498((uint64_t)v104, v86, (uint64_t)&v127, a2, (uint64_t)v130, (uint64_t)(v85 + 4), v76 + 24, v145, (uint64_t)buf);
                    if (v156)
                    {
                      long long v155 = *(_OWORD *)(v76 + 24);
                      sub_100281970((uint64_t)&__p, (uint64_t)v145);
                      sub_1001F2564((uint64_t)v145);
                    }
                    if (v86)
                    {
                      id v132 = v86;
                      char v133 = 1;
                    }
                    sub_1002819B8((uint64_t)v129);
                    sub_1001EF39C((uint64_t)v145);
                    sub_1001EF39C((uint64_t)buf);
                    int v93 = (uint64_t *)v85[1];
                    if (v93)
                    {
                      do
                      {
                        unsigned int v94 = v93;
                        int v93 = (uint64_t *)*v93;
                      }
                      while (v93);
                    }
                    else
                    {
                      do
                      {
                        unsigned int v94 = (uint64_t *)v85[2];
                        BOOL v81 = *v94 == (void)v85;
                        unsigned int v85 = v94;
                      }
                      while (!v81);
                    }
                    unsigned int v85 = v94;
                  }
                  while (v94 != v35);
                }
                sub_1000D7D80((uint64_t)&v141);
                *(void *)uint64_t buf = &v127;
                sub_1001EF794((void ***)buf);
                uint64_t v77 = v101;
              }
              else
              {
                if (qword_102419450 != -1) {
                  dispatch_once(&qword_102419450, &stru_1022A2818);
                }
                long long v82 = qword_102419458;
                if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
                {
                  int v83 = (char *)operator new(0x28uLL);
                  *(void *)v145 = v83;
                  *(_OWORD *)v146 = xmmword_101D048C0;
                  *(_OWORD *)int v83 = 0u;
                  *((_OWORD *)v83 + 1) = 0u;
                  *(void *)(v83 + 29) = 0;
                  sub_1001E0650(v76 + 24, v83);
                  CFArrayRef v84 = (const __CFArray *)v145;
                  if (v146[15] < 0) {
                    CFArrayRef v84 = *(const __CFArray **)v145;
                  }
                  if (*(char *)(v76 + 63) < 0) {
                    int v78 = (void ***)*v78;
                  }
                  *(_DWORD *)uint64_t buf = 68289538;
                  *(_DWORD *)&uint8_t buf[4] = 0;
                  *(_WORD *)v163 = 2082;
                  *(void *)&v163[2] = "";
                  *(_WORD *)&v163[10] = 2082;
                  *(void *)&v163[12] = v84;
                  *(_WORD *)&v163[20] = 2082;
                  *(void *)&v163[22] = v78;
                  _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Unsupervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                  if ((v146[15] & 0x80000000) != 0) {
                    operator delete(*(void **)v145);
                  }
                }
              }
              v76 += 64;
            }
            while ((void *)v76 != v77);
          }
          sub_1000DB264((uint64_t)&v113, v114);
          *(void *)uint64_t buf = v117;
          sub_10028B5B0((void ***)buf);
          *(void *)uint64_t buf = v139;
          sub_10020D8FC((void ***)buf);
        }
        goto LABEL_234;
      }
      sub_1002822D4((uint64_t)v104, 3u, 1, (uint64_t *)v145);
      sub_1002822D4((uint64_t)v104, 2u, 1, (uint64_t *)&v141);
      sub_1001FF120(v104[1], (uint64_t *)v139);
      *(void *)uint64_t buf = v104;
      *(void *)v163 = v129;
      *(void *)&v163[8] = &v138;
      *(void *)&v163[16] = &v136;
      *(void *)&v163[24] = &v132;
      v164 = &v134;
      uint64_t v165 = a2;
      v166 = v130;
      p_p = &__p;
      v168 = v139;
      sub_1002825FC((uint64_t)buf, (uint64_t *)v145, 3u);
      sub_1002825FC((uint64_t)buf, (uint64_t *)&v141, 4u);
      *(void *)uint64_t buf = v139;
      sub_10020D8FC((void ***)buf);
      *(void *)uint64_t buf = &v141;
      sub_10028B6A0((void ***)buf);
      uint64_t v42 = v145;
    }
    *(void *)uint64_t buf = v42;
    sub_10028B6A0((void ***)buf);
LABEL_234:
    (*(void (**)(uint64_t, void))(*(void *)*v104 + 32))(*v104, v138);
    sub_100289BB4((uint64_t)v130);
    sub_100288C48((uint64_t)v157);
    sub_1001EF39C((uint64_t)&__p);
LABEL_235:
    double v96 = j__CFAbsoluteTimeGetCurrent_5();
    if (qword_102419460 != -1) {
      dispatch_once(&qword_102419460, &stru_1022A2838);
    }
    v97 = qword_102419468;
    if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)v163 = 2082;
      *(void *)&v163[2] = "";
      *(_WORD *)&v163[10] = 2050;
      *(void *)&v163[12] = v138;
      *(_WORD *)&v163[20] = 2050;
      *(double *)&v163[22] = v96 - Current_5;
      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Learning, completed\", \"model-type\":%{public}lu, \"Total Time (sec)\":\"%{public}.4f\"}", buf, 0x26u);
    }
    if (v134)
    {
      v135 = v134;
      operator delete(v134);
    }
    return;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  __int16 v26 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#Warning Tried to run learning, but database is not valid", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    LOWORD(__p) = 0;
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v12);
    goto LABEL_55;
  }
}

void sub_100280E4C(_Unwind_Exception *a1)
{
  BOOL v2 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v2;
    operator delete(v2);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_1002811D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  BOOL v4 = (char *)operator new(0x28uLL);
  *(void *)a2 = v4;
  *(_OWORD *)(a2 + 8) = xmmword_101D048C0;
  *(_OWORD *)BOOL v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(void *)(v4 + 29) = 0;
  return sub_1001E0650(a1, v4);
}

void sub_100281228(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100281244(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  *(void *)&long long v17 = a3;
  *((void *)&v17 + 1) = a4;
  uint64_t v8 = *(void *)(a1 + 8);
  long long v15 = v17;
  char v16 = 1;
  sub_1002887CC(v8, a2, &v15, (void *)a5);
  if (v17 != 0)
  {
    uint64_t v9 = *(void *)(a1 + 8);
    long long v13 = 0uLL;
    char v14 = 1;
    sub_1002887CC(v9, a2, &v13, &v10);
    sub_1002914D4((uint64_t *)a5, *(long long **)(a5 + 8), v10, v11, 0xEEEEEEEEEEEEEEEFLL * (v11 - v10));
    uint64_t v12 = &v10;
    sub_1001EF794((void ***)&v12);
  }
}

void sub_10028132C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_1001EF794((void ***)&a13);
  sub_1001EF794(&a10);
  _Unwind_Resume(a1);
}

void sub_100281364(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  sub_1001FEA10(*(void *)(a1 + 8), a2, a3, a4, (unsigned char *)a5);
  if (!*(unsigned char *)(a5 + 280))
  {
    sub_1001FEA10(*(void *)(a1 + 8), a2, 0, 0, v10);
    sub_100289C68(a5, (uint64_t)v10);
    sub_1001EF39C((uint64_t)v10);
    if (*(unsigned char *)(a5 + 280))
    {
      *(void *)(a5 + 264) = a3;
      *(void *)(a5 + 272) = a4;
    }
    else
    {
      sub_1001FE6C0(*(void *)(a1 + 8), 0, a3, a4, v10);
      sub_100289C68(a5, (uint64_t)v10);
      sub_1001EF39C((uint64_t)v10);
      if (*(unsigned char *)(a5 + 280))
      {
        if (*(unsigned char *)(a5 + 256)) {
          sub_1001F2564(a5);
        }
      }
    }
  }
}

void sub_10028146C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001EF39C((uint64_t)va);
  sub_1001EF39C(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100281498@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, unsigned char *a8@<X8>, uint64_t a9)
{
  *a8 = 0;
  a8[280] = 0;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100282AAC(a1, a2, a3, a4, a5, a7, a9, (uint64_t)v33, Current_5, 0);
  if (v45 && sub_100278D98((uint64_t)v33))
  {
    if (qword_102419460 != -1) {
      dispatch_once(&qword_102419460, &stru_1022A2838);
    }
    int v18 = qword_102419468;
    if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = sub_100277B94((uint64_t)v33);
      uint64_t v21 = v43;
      uint64_t v20 = v44;
      uint64_t v22 = sub_1002765A8((uint64_t)v33);
      *(_DWORD *)uint64_t buf = 68292098;
      int v47 = 0;
      __int16 v48 = 2082;
      CFStringRef v49 = "";
      __int16 v50 = 2050;
      uint64_t v51 = v19;
      __int16 v52 = 2050;
      uint64_t v53 = (v20 - v21) >> 5;
      __int16 v54 = 2050;
      uint64_t v55 = v22;
      __int16 v56 = 1026;
      int v57 = v34;
      __int16 v58 = 2050;
      uint64_t v59 = v35;
      __int16 v60 = 1026;
      int v61 = v36;
      __int16 v62 = 1026;
      int v63 = v37;
      __int16 v64 = 1026;
      int v65 = v39;
      __int16 v66 = 1026;
      int v67 = v38;
      __int16 v68 = 1026;
      int v69 = v40;
      __int16 v70 = 1026;
      int v71 = v41;
      __int16 v72 = 1026;
      int v73 = v42;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Microlocation model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}", buf, 0x6Au);
    }
    int v32 = 0;
    sub_1001EE1F4(&v32);
    uint64_t v23 = sub_1001EC8C4((ssize_t)&v32);
    uint64_t v25 = v24;
    sub_100275EA0((uint64_t)v33, (uint64_t)v77);
    if (*(char *)(a6 + 23) < 0)
    {
      sub_1000DC48C(__dst, *(void **)a6, *(void *)(a6 + 8));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)a6;
      uint64_t v30 = *(void *)(a6 + 16);
    }
    char v31 = 1;
    sub_100338C7C((uint64_t)buf, v23, v25, (uint64_t)v77, (uint64_t)__dst, 0, 0, Current_5);
    sub_100281970((uint64_t)a8, (uint64_t)buf);
    if (v76 && v75 < 0) {
      operator delete(__p);
    }
    sub_10024B47C((char *)&v53 + 2);
    if (v31 && SHIBYTE(v30) < 0) {
      operator delete(__dst[0]);
    }
    sub_10024B47C(v77);
    sub_1001EF3E8((unsigned int *)&v32);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    __int16 v26 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v47 = v34;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "No models were generated for model type %{public}d", buf, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      v77[0] = 67240192;
      v77[1] = v34;
      CFStringRef v27 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationLearner::learnMagicalMomentsModel(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, const std::string &, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &)", "%s\n", v27);
      if (v27 != (char *)buf) {
        free(v27);
      }
    }
  }
  return sub_100289B38((uint64_t)v33);
}

void sub_1002818E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *__p, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100289B38((uint64_t)va);
  sub_1001EF39C(v8);
  _Unwind_Resume(a1);
}

uint64_t sub_100281970(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 280))
  {
    sub_100338D60(a1, a2);
  }
  else
  {
    sub_100338D5C(a1, a2);
    *(unsigned char *)(a1 + 280) = 1;
  }
  return a1;
}

void sub_1002819B8(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v3 + 280))
  {
    uint64_t v4 = v2[1];
    sub_1002896EC(buf, (long long *)v3);
    long long v41 = 0uLL;
    v42[0] = 0;
    *(void *)uint64_t v43 = &v41;
    v43[8] = 0;
    *(void *)&long long v41 = operator new(0x118uLL);
    *((void *)&v41 + 1) = v41;
    v42[0] = v41 + 280;
    *((void *)&v41 + 1) = sub_10028976C((uint64_t)v42, (long long *)buf, v40, (_OWORD *)v41);
    char v5 = sub_1002891E4(v4);
    *(void *)uint64_t v43 = &v41;
    sub_1002898E8((void ***)v43);
    if (v39 && v38 < 0) {
      operator delete(__p);
    }
    sub_10024B47C(&v33[24]);
    if (v5)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      CFAllocatorRef v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = **(_DWORD **)(a1 + 8);
        *(_DWORD *)uint64_t buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Model generated successfully for type %{public}d", buf, 8u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        int v30 = **(_DWORD **)(a1 + 8);
        LODWORD(v41) = 67240192;
        DWORD1(v41) = v30;
        char v31 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v31);
        if (v31 != (char *)buf) {
          free(v31);
        }
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 24);
        if (!*(unsigned char *)(v9 + 280)) {
          sub_10020D700();
        }
        int v10 = (char *)operator new(0x28uLL);
        *(void *)uint64_t buf = v10;
        *(_OWORD *)uint64_t v33 = xmmword_101D048C0;
        *(_OWORD *)int v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        *(void *)(v10 + 29) = 0;
        sub_1001E0650(v9, v10);
        uint64_t v11 = buf;
        if (v33[15] < 0) {
          uint64_t v11 = *(uint8_t **)buf;
        }
        LODWORD(v41) = 136380675;
        *(void *)((char *)&v41 + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "MicroLocation learned model: %{private}s", (uint8_t *)&v41, 0xCu);
        if ((v33[15] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_35;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v12 = *(void *)(a1 + 24);
      if (!*(unsigned char *)(v12 + 280)) {
        sub_10020D700();
      }
      sub_1002811D4(v12, (uint64_t)&v41);
      if (v42[0] >= 0) {
        long long v13 = &v41;
      }
      else {
        long long v13 = (long long *)v41;
      }
      *(_DWORD *)uint64_t v43 = 136380675;
      *(void *)&v43[4] = v13;
      char v14 = (char *)_os_log_send_and_compose_impl();
      if (SHIBYTE(v42[0]) < 0) {
        operator delete((void *)v41);
      }
      sub_1004BA5E4("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v14);
      if (v14 == (char *)buf) {
        goto LABEL_35;
      }
LABEL_61:
      free(v14);
      goto LABEL_35;
    }
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  long long v15 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#Warning Model was not generated properly. Inserted: %{public,BOOL}d", buf, 8u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    *(void *)&long long v41 = 67240192;
    char v14 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v14);
    if (v14 != (char *)buf) {
      goto LABEL_61;
    }
  }
LABEL_35:
  uint64_t v16 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v16 + 112)) {
    goto LABEL_45;
  }
  uint64_t v17 = v2[1];
  *(void *)uint64_t buf = *(void *)v16;
  if (*(char *)(v16 + 31) < 0)
  {
    sub_1000DC48C(v33, *(void **)(v16 + 8), *(void *)(v16 + 16));
  }
  else
  {
    long long v18 = *(_OWORD *)(v16 + 8);
    *(void *)&v33[16] = *(void *)(v16 + 24);
    *(_OWORD *)uint64_t v33 = v18;
  }
  long long v19 = *(_OWORD *)(v16 + 32);
  int v34 = *(_DWORD *)(v16 + 48);
  *(_OWORD *)&v33[24] = v19;
  sub_10026CB60(v35, v16 + 56);
  long long v41 = 0uLL;
  v42[0] = 0;
  *(void *)uint64_t v43 = &v41;
  v43[8] = 0;
  *(void *)&long long v41 = operator new(0x70uLL);
  *((void *)&v41 + 1) = v41;
  v42[0] = v41 + 112;
  *((void *)&v41 + 1) = sub_100289980((uint64_t)v42, (uint64_t)buf, (uint64_t)&v36, v41);
  int v20 = sub_100287C70(v17);
  *(void *)uint64_t v43 = &v41;
  sub_1002283E4((void ***)v43);
  sub_10026CC30((wireless_diagnostics::google::protobuf::MessageLite *)v35);
  if ((v33[23] & 0x80000000) != 0) {
    operator delete(*(void **)v33);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v21 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = **(unsigned int **)(a1 + 8);
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v33 = 2082;
    *(void *)&v33[2] = "";
    *(_WORD *)&v33[10] = 2050;
    *(void *)&v33[12] = v22;
    *(_WORD *)&v33[20] = 1026;
    *(_DWORD *)&v33[22] = v20;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Configuration generated\", \"ModelType\":%{public}lu, \"Inserted\":%{public}hhd}", buf, 0x22u);
LABEL_45:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
  }
  uint64_t v23 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = **(unsigned __int8 **)(a1 + 16);
    uint64_t v25 = **(unsigned int **)(a1 + 8);
    uint64_t v26 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 8);
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v33 = 2082;
    *(void *)&v33[2] = "";
    *(_WORD *)&v33[10] = 1026;
    *(_DWORD *)&v33[12] = v24;
    *(_WORD *)&v33[16] = 2050;
    *(void *)&v33[18] = v25;
    *(_WORD *)&v33[26] = 2050;
    *(void *)&v33[28] = v26;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.ModelLearning\", \"sending enabled\":%{public}hhd, \"model type\":%{public}lu, \"has_value\":%{public}lu}", buf, 0x2Cu);
  }
  if (**(unsigned char **)(a1 + 16) && *(unsigned char *)(*(void *)(a1 + 40) + 8)) {
    AnalyticsSendEvent();
  }
  CFStringRef v27 = *(uint64_t **)(a1 + 40);
  if (*((unsigned char *)v27 + 8)) {
    uint64_t v28 = *v27;
  }
  else {
    uint64_t v28 = 0;
  }
  (*(void (**)(void, void, void, uint64_t))(*(void *)*v2 + 24))(*v2, **(unsigned int **)(a1 + 8), *(void *)(a1 + 24), v28);
  sub_1001F2564(*(void *)(a1 + 24));
  sub_100288B7C(*(void *)(a1 + 32));
  uint64_t v29 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v29 + 8)) {
    *(unsigned char *)(v29 + 8) = 0;
  }
}

void sub_10028223C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_1002822D4(uint64_t a1@<X0>, unsigned int a2@<W1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  sub_1001FE390(*(void *)(a1 + 8), &v32);
  sub_10020420C(*(void *)(a1 + 8), a2, &v30);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v8 = v31;
  if (v30 != v31)
  {
    uint64_t v9 = v30 + 16;
    do
    {
      sub_100239700((const void **)v9, (uint64_t)(v9 - 12), &v29);
      uint64_t v10 = sub_1000A7C40(v32, v33, (unsigned __int8 **)&v29);
      uint64_t v11 = v33;
      int v12 = *((char *)v9 + 23);
      if (v12 < 0)
      {
        if (*((void *)v9 + 1) != 10) {
          goto LABEL_12;
        }
        long long v13 = *(unsigned __int16 **)v9;
      }
      else
      {
        long long v13 = v9;
        if (v12 != 10) {
          goto LABEL_12;
        }
      }
      uint64_t v14 = *(void *)v13;
      int v15 = v13[4];
      if (v14 == 0x6F6D2D7375636F66 && v15 == 25956)
      {
        uint64_t v20 = sub_1000A7C40(v32, v33, (unsigned __int8 **)v9);
        BOOL v17 = v20 != v33;
        goto LABEL_13;
      }
LABEL_12:
      BOOL v17 = 0;
LABEL_13:
      if (v10 == v11) {
        char v18 = a3 ^ 1;
      }
      else {
        char v18 = 1;
      }
      if ((v18 & 1) != 0 || v17)
      {
        if (*((char *)v9 + 23) < 0)
        {
          sub_1000DC48C(__dst, *(void **)v9, *((void *)v9 + 1));
        }
        else
        {
          long long v19 = *(_OWORD *)v9;
          uint64_t v27 = *((void *)v9 + 2);
          *(_OWORD *)__dst = v19;
        }
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
          sub_1000DC48C(&v28, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
        }
        else {
          std::string v28 = v29;
        }
        if (SHIBYTE(v27) < 0)
        {
          sub_1000DC48C(v22, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)uint64_t v22 = *(_OWORD *)__dst;
          uint64_t v23 = v27;
        }
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
          sub_1000DC48C(&__p, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v28;
        }
        uint64_t v25 = *((void *)v9 + 3);
        sub_100286AC0(a4, (long long *)v22);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v23) < 0) {
          operator delete(v22[0]);
        }
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v28.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v27) < 0) {
          operator delete(__dst[0]);
        }
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      uint64_t v21 = v9 + 28;
      v9 += 44;
    }
    while (v21 != v8);
  }
  v22[0] = &v30;
  sub_10028B5B0((void ***)v22);
  v22[0] = &v32;
  sub_1000A7B4C((void ***)v22);
}

void sub_100282554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  std::string __p = (void *)(v35 - 112);
  sub_1000A7B4C((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1002825FC(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  uint64_t v4 = *v3;
  uint64_t v31 = v3[1];
  if (*v3 != v31)
  {
    uint64_t v34 = *(void *)a1;
    do
    {
      uint64_t v32 = (void *)(v4 + 40);
      uint64_t v33 = v4;
      uint64_t v6 = sub_1002CA5F4((uint64_t *)(v4 + 40));
      uint64_t v7 = v33 + 24;
      if (v8)
      {
        uint64_t v10 = *a2;
        uint64_t v9 = a2[1];
        if (*a2 != v9)
        {
          unint64_t v11 = v6;
          uint64_t v12 = 1 << v6;
          do
          {
            unint64_t v13 = sub_1002D4B0C(*(void *)(v10 + 48));
            if (v11 > 0x1F) {
              sub_10000EDDC("bitset test argument out of range");
            }
            if ((v13 & v12) != 0)
            {
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A2818);
              }
              uint64_t v14 = qword_102419458;
              if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
              {
                int v15 = (void *)v10;
                if (*(char *)(v10 + 23) < 0) {
                  int v15 = *(void **)v10;
                }
                uint64_t v16 = (void *)(v10 + 24);
                if (*(char *)(v10 + 47) < 0) {
                  uint64_t v16 = (void *)*v16;
                }
                BOOL v17 = operator new(0x28uLL);
                std::string __p = v17;
                long long v37 = xmmword_101D048C0;
                _OWORD *v17 = 0u;
                v17[1] = 0u;
                *(void *)((char *)v17 + 29) = 0;
                sub_1001E0650(v7, v17);
                p_p = &__p;
                if (v37 < 0) {
                  p_p = __p;
                }
                long long v19 = v32;
                if (*(char *)(v33 + 63) < 0) {
                  long long v19 = (void *)*v32;
                }
                *(_DWORD *)uint64_t buf = 68290050;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&buf[18] = 2082;
                *(void *)&buf[20] = v15;
                __int16 v40 = 2082;
                long long v41 = v16;
                __int16 v42 = 2082;
                uint64_t v43 = p_p;
                __int16 v44 = 2082;
                char v45 = v19;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning a semi-supervised model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x3Au);
                if (SHIBYTE(v37) < 0) {
                  operator delete(__p);
                }
              }
              int v20 = **(unsigned __int8 **)(a1 + 24);
              uint64_t v21 = (void *)**(unsigned int **)(a1 + 16);
              if (*(char *)(v10 + 23) < 0)
              {
                sub_1000DC48C(buf, *(void **)v10, *(void *)(v10 + 8));
              }
              else
              {
                long long v22 = *(_OWORD *)v10;
                *(void *)&buf[16] = *(void *)(v10 + 16);
                *(_OWORD *)uint64_t buf = v22;
              }
              buf[24] = 1;
              id v23 = sub_10026FC8C(v20 != 0, v21, (const std::string *)buf);
              if (buf[24] && (buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v24 = *(void *)(a1 + 40);
              sub_1001EF9DC((uint64_t)v38, *(void *)(a1 + 48));
              sub_1002862B4(v34, v10, v24, a3, (uint64_t)v38, *(void *)(a1 + 56), buf, v7);
              sub_1001EFA74(v38);
              if (v46) {
                sub_100281970(*(void *)(a1 + 64), (uint64_t)buf);
              }
              if (v23)
              {
                uint64_t v25 = *(void *)(a1 + 32);
                *(void *)uint64_t v25 = v23;
                *(unsigned char *)(v25 + 8) = 1;
              }
              sub_1002819B8(*(void *)(a1 + 8));
              sub_1001EF39C((uint64_t)buf);
            }
            v10 += 56;
          }
          while (v10 != v9);
        }
      }
      else
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        uint64_t v26 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = operator new(0x28uLL);
          std::string __p = v27;
          long long v37 = xmmword_101D048C0;
          *uint64_t v27 = 0u;
          v27[1] = 0u;
          *(void *)((char *)v27 + 29) = 0;
          sub_1001E0650(v7, v27);
          std::string v28 = &__p;
          if (v37 < 0) {
            std::string v28 = __p;
          }
          std::string v29 = v32;
          if (*(char *)(v33 + 63) < 0) {
            std::string v29 = (void *)*v32;
          }
          *(_DWORD *)uint64_t buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v28;
          __int16 v40 = 2082;
          long long v41 = v29;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location semi-supervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
          if (SHIBYTE(v37) < 0) {
            operator delete(__p);
          }
        }
      }
      uint64_t v4 = v33 + 64;
    }
    while (v33 + 64 != v31);
  }
}

void sub_100282A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  operator delete(v37);
  _Unwind_Resume(a1);
}

uint64_t sub_100282AAC@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>, double a9@<D0>, int a10)
{
  double v102 = a9;
  sub_1000C7F88(buf);
  LODWORD(v85) = 0;
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  int v14 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v13, &v85);
  CFRelease(v13);
  unsigned int v15 = v85;
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v14) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  sub_100217718(v16);
  uint64_t v59 = a6;
  sub_1000C7F88(buf);
  LODWORD(v85) = 0;
  CFStringRef v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberOfModelIterations", 0x8000100u, kCFAllocatorNull);
  int v18 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v17, &v85);
  CFRelease(v17);
  unsigned int v19 = v85;
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v18) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 3;
  }
  unint64_t v65 = v20;
  long long v22 = *(unint64_t **)a3;
  uint64_t v21 = *(void *)(a3 + 8);
  sub_1000C7F88(buf);
  LODWORD(v85) = 0;
  CFStringRef v23 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  int v24 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v23, &v85);
  CFRelease(v23);
  uint64_t v25 = v85;
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v26 = 200;
  if (v24) {
    uint64_t v26 = v25;
  }
  unint64_t v61 = v26;
  id v99 = 0;
  uint64_t v98 = 0;
  uint64_t v100 = 0;
  sub_100288630(&v98, v65);
  if (qword_102419460 != -1) {
    dispatch_once(&qword_102419460, &stru_1022A2838);
  }
  uint64_t v27 = qword_102419468;
  if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v28 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
    *(_DWORD *)uint64_t buf = 68290050;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = a10;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v16;
    *(_WORD *)&buf[30] = 1026;
    *(_DWORD *)v110 = v65;
    *(_WORD *)&v110[4] = 2050;
    *(void *)&v110[6] = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning started\", \"modelType\":%{public}d, \"algorithmType\":%{public}d, \"numModelIters\":%{public}d, \"numRecordingTriggers\":%{public}lu}", buf, 0x2Eu);
  }
  sub_100275E9C(&v85);
  unint64_t v60 = 0xEEEEEEEEEEEEEEEFLL * ((v21 - (uint64_t)v22) >> 4);
  v122[0] = 0;
  char v124 = 0;
  if (*(unsigned char *)(a7 + 280))
  {
    sub_100276BB4(a7 + 32, a5, (uint64_t)buf);
    long long v85 = *(_OWORD *)buf;
    int v87 = v111;
    sub_1001EEAA8(v86, *(uint64_t **)v110, 0);
    long long v88 = v112;
    sub_100289CD0((uint64_t)v89, (uint64_t)v113);
    v90[0] = v114[0];
    *(_OWORD *)((char *)v90 + 12) = *(_OWORD *)((char *)v114 + 12);
    sub_100289E08((uint64_t *)&v91);
    long long v91 = v115;
    uint64_t v92 = v116;
    uint64_t v116 = 0;
    long long v115 = 0uLL;
    sub_100289E44((uint64_t)v93, v117);
    v93[5] = v117[5];
    if ((void)__p)
    {
      *((void *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
    long long __p = v118;
    uint64_t v95 = v119;
    uint64_t v119 = 0;
    long long v118 = 0uLL;
    if (SHIBYTE(v97) < 0)
    {
      operator delete((void *)v96);
      long long v96 = v120;
      uint64_t v97 = v121;
      HIBYTE(v121) = 0;
      LOBYTE(v120) = 0;
      if ((void)v118)
      {
        *((void *)&v118 + 1) = v118;
        operator delete((void *)v118);
      }
    }
    else
    {
      uint64_t v97 = v121;
      long long v96 = v120;
      HIBYTE(v121) = 0;
      LOBYTE(v120) = 0;
    }
    sub_1001EF1F0((uint64_t)v117);
    int v71 = (void **)&v115;
    sub_1001EF278(&v71);
    sub_1001EF318((uint64_t)v113);
    sub_1000D7D80((uint64_t)&buf[16]);
    if (!sub_1002765B0((uint64_t)&v85))
    {
      if (v60 >= v61 || (unint64_t v29 = HIDWORD(v85), sub_1002886D8() - 1 <= v29))
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        int v30 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "got sufficient recording triggers, will ignore prior cluster number in learning", buf, 2u);
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2818);
          }
          LOWORD(v71) = 0;
          __int16 v56 = (char *)_os_log_send_and_compose_impl();
          sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMicroLocationProto::Model::ModelType)", "%s\n", v56);
          if (v56 != (char *)buf) {
            free(v56);
          }
        }
      }
    }
  }
  v108[0] = off_10229EA20;
  v108[1] = sub_10031DCB8;
  v108[3] = v108;
  sub_100275E9C(&v71);
  uint64_t v31 = *(unint64_t **)(a3 + 8);
  unint64_t v58 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v31 - *(void *)a3) >> 4);
  unint64_t v32 = 126 - 2 * __clz(v58);
  if (v31 == *(unint64_t **)a3) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v32;
  }
  sub_10028E460(*(unint64_t **)a3, v31, v33, 1);
  if (v65)
  {
    if (sub_100278D98((uint64_t)&v71))
    {
      memset(buf, 0, sizeof(buf));
      *(_DWORD *)v110 = 1065353216;
      for (uint64_t i = v80; i; uint64_t i = (void *)*i)
      {
        uint64_t v36 = (void *)i[4];
        uint64_t v35 = (void *)i[5];
        while (v36 != v35)
        {
          sub_1001EFB90((uint64_t)buf, v36, v36);
          v36 += 2;
        }
      }
      char v38 = *(unint64_t **)a3;
      long long v37 = *(unint64_t **)(a3 + 8);
      if (*(unint64_t **)a3 != v37)
      {
        while (sub_1001EFDE4(buf, v38))
        {
          v38 += 30;
          if (v38 == v37)
          {
            char v38 = v37;
            goto LABEL_57;
          }
        }
        if (v38 != v37)
        {
          for (j = v38 + 30; j != v37; j += 30)
          {
            if (sub_1001EFDE4(buf, j))
            {
              long long v40 = *(_OWORD *)j;
              v38[2] = j[2];
              *(_OWORD *)char v38 = v40;
              long long v41 = (void **)(v38 + 3);
              if (*((char *)v38 + 47) < 0) {
                operator delete(*v41);
              }
              long long v42 = *(_OWORD *)(j + 3);
              v38[5] = j[5];
              *(_OWORD *)long long v41 = v42;
              *((unsigned char *)j + 47) = 0;
              *((unsigned char *)j + 24) = 0;
              long long v43 = *((_OWORD *)j + 3);
              *(_OWORD *)((char *)v38 + 60) = *(_OWORD *)((char *)j + 60);
              *((_OWORD *)v38 + 3) = v43;
              sub_100267D64((uint64_t)(v38 + 10), (uint64_t)(j + 10));
              long long v44 = *(_OWORD *)(j + 27);
              *((unsigned char *)v38 + 232) = *((unsigned char *)j + 232);
              *(_OWORD *)(v38 + 27) = v44;
              v38 += 30;
            }
          }
        }
      }
LABEL_57:
      sub_1001EBD5C(a3, (uint64_t)v38, *(long long **)(a3 + 8));
      sub_1000D7D80((uint64_t)buf);
    }
    sub_1000C7F88(buf);
    LODWORD(v103) = 0;
    CFStringRef v45 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDataSource", 0x8000100u, kCFAllocatorNull);
    int v46 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v45, &v103);
    CFRelease(v45);
    unsigned int v47 = v103;
    if (*(void *)&buf[8]) {
      sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v46) {
      unsigned int v48 = v47;
    }
    else {
      unsigned int v48 = 1;
    }
    sub_1001EF9DC((uint64_t)v107, a4);
    sub_1001EFAF8((uint64_t)v106, (uint64_t)v108);
    sub_1002C5CB4(v48);
  }
  LOBYTE(v69[0]) = 0;
  LOBYTE(v70) = 0;
  CFStringRef v49 = a2;
  if (*(unsigned char *)(a7 + 280))
  {
    __int16 v50 = *(void **)(a7 + 16);
    v69[0] = (void *)(*(unsigned int *)(a7 + 140) | ((unint64_t)*(unsigned __int8 *)(a7 + 136) << 32));
    v69[1] = v50;
    LOBYTE(v70) = 1;
  }
  sub_100288310(a1, (uint64_t)&v71, &v102, (uint64_t)v69, v59);
  if (a10 != 2)
  {
    if (v60 >= v61 || (unint64_t v51 = v73, sub_1002886D8() <= v51))
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      __int16 v52 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "set model to stable", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2818);
        }
        LOWORD(v103) = 0;
        int v57 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMicroLocationProto::Model::ModelType)", "%s\n", v57);
        if (v57 != (char *)buf) {
          free(v57);
        }
        CFStringRef v49 = a2;
      }
      char v72 = 1;
    }
  }
  sub_100277B8C((uint64_t)&v71, 0);
  sub_1002FB9A8((uint64_t)&v71, (uint64_t)&v103);
  sub_100277BC0((uint64_t)&v71, (int)v103);
  sub_100277BC8((uint64_t)&v71, (uint64_t)v104);
  char v76 = v104[3];
  int v77 = v105;
  sub_100275EA0((uint64_t)&v71, (uint64_t)buf);
  double v53 = v102;
  sub_1002711EC(v49, &v71, (uint64_t)buf, v102);
  if (*(unsigned char *)(a7 + 280))
  {
    if (v124) {
      uint64_t v54 = v123;
    }
    else {
      uint64_t v54 = 0;
    }
    sub_100271ACC((uint64_t)v49, &v71, &v85, v54, v124, v53);
  }
  v68[0] = sub_1002765B0((uint64_t)&v85);
  v68[1] = 1;
  sub_1002721BC(v49, (uint64_t)&v71, v68);
  v75[32] = v58;
  v75[33] = 0;
  v75[34] = 0;
  v75[35] = 0;
  sub_100289F40(a8, (uint64_t)&v71);
  sub_10024B47C(buf);
  if (v104[0])
  {
    v104[1] = v104[0];
    operator delete(v104[0]);
  }
  if (v84 < 0) {
    operator delete(v83);
  }
  if (v81)
  {
    long long v82 = v81;
    operator delete(v81);
  }
  sub_1001EF1F0((uint64_t)&v79);
  *(void *)uint64_t buf = &v78;
  sub_1001EF278((void ***)buf);
  sub_1001EF318((uint64_t)v75);
  sub_1000D7D80((uint64_t)&v74);
  sub_1001EF958(v108);
  sub_1001EF39C((uint64_t)v122);
  if (SHIBYTE(v97) < 0) {
    operator delete((void *)v96);
  }
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  sub_1001EF1F0((uint64_t)v93);
  *(void *)uint64_t buf = &v91;
  sub_1001EF278((void ***)buf);
  sub_1001EF318((uint64_t)v89);
  sub_1000D7D80((uint64_t)v86);
  if (v98)
  {
    id v99 = v98;
    operator delete(v98);
  }
  uint64_t result = v101;
  uint64_t v101 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002843D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  if (a62) {
    (*(void (**)(uint64_t))(*(void *)a62 + 8))(a62);
  }
  sub_1001EC93C((uint64_t)&a63);
  sub_1001EF958(&STACK[0x520]);
  sub_1001EF39C((uint64_t)&STACK[0xBA8]);
  sub_1001EC93C((uint64_t)&STACK[0x310]);
  __int16 v64 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v64;
    operator delete(v64);
  }
  unint64_t v65 = STACK[0x488];
  STACK[0x488] = 0;
  if (v65) {
    (*(void (**)(unint64_t))(*(void *)v65 + 8))(v65);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100284878(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    *(unsigned char *)(sub_100289AB8(a1) + 40) = 0;
  }
  uint64_t result = sub_100335AC8();
  *(unsigned char *)(result + 40) = 1;
  return result;
}

void sub_1002848C0(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  double v70 = a2;
  __int16 v68 = 0;
  int v67 = 0;
  uint64_t v69 = 0;
  uint64_t v65 = 0;
  uint64_t v64 = 0;
  uint64_t v66 = 0;
  sub_1000C7F88(buf);
  LODWORD(v76) = 0;
  CFStringRef v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
  int v11 = sub_10013E418(*(uint64_t *)buf, (uint64_t)v10, &v76);
  CFRelease(v10);
  unsigned int v12 = v76;
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v13 = *a7;
  uint64_t v14 = a7[1];
  uint64_t v63 = 0;
  long long __p = 0;
  __int16 v62 = 0;
  sub_10010F834(&__p, *(const void **)a8, *(void *)(a8 + 8), (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 2);
  if (v11) {
    unsigned int v16 = v12;
  }
  else {
    unsigned int v16 = 1000;
  }
  sub_10027EE20(a1, a5, (uint64_t *)&v67, (uint64_t)&v64, v13, v14, v15, v16);
  if (__p)
  {
    __int16 v62 = __p;
    operator delete(__p);
  }
  memset(v59, 0, sizeof(v59));
  int v60 = 1065353216;
  uint64_t v17 = v64;
  for (uint64_t i = v65; v17 != i; v17 += 240)
  {
    if (!*(unsigned char *)(v17 + 232))
    {
      unint64_t v29 = &qword_102419000;
      if (qword_102419450 != -1) {
        goto LABEL_72;
      }
      while (1)
      {
        int v30 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
        {
          uint64_t v31 = a5;
          uint64_t v32 = a5 + 24;
          uint64_t v33 = *(void *)(a5 + 24);
          int v34 = *(char *)(v32 + 23);
          sub_1002811D4(v17, (uint64_t)&v76);
          if (v34 >= 0) {
            uint64_t v35 = v32;
          }
          else {
            uint64_t v35 = v33;
          }
          if (v77 >= 0) {
            uint64_t v36 = &v76;
          }
          else {
            uint64_t v36 = v76;
          }
          *(_DWORD *)uint64_t buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v35;
          *(_WORD *)&unsigned char buf[28] = 2082;
          *(void *)&buf[30] = v36;
          __int16 v72 = 2082;
          unint64_t v73 = (unint64_t)"assert";
          __int16 v74 = 2081;
          char v75 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (v77 < 0) {
            operator delete(v76);
          }
          a5 = v31;
          if (v29[138] != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2818);
          }
        }
        long long v37 = qword_102419458;
        if (os_signpost_enabled((os_log_t)qword_102419458))
        {
          uint64_t v38 = a5;
          uint64_t v39 = a5 + 24;
          uint64_t v40 = *(void *)(a5 + 24);
          int v41 = *(char *)(v39 + 23);
          sub_1002811D4(v17, (uint64_t)&v76);
          if (v41 >= 0) {
            uint64_t v42 = v39;
          }
          else {
            uint64_t v42 = v40;
          }
          if (v77 >= 0) {
            long long v43 = &v76;
          }
          else {
            long long v43 = v76;
          }
          *(_DWORD *)uint64_t buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v42;
          *(_WORD *)&unsigned char buf[28] = 2082;
          *(void *)&buf[30] = v43;
          __int16 v72 = 2082;
          unint64_t v73 = (unint64_t)"assert";
          __int16 v74 = 2081;
          char v75 = "recordingEntry.fTriggerUUID.has_value()";
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v37, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, labeled recording entry without trigger UUID", "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (v77 < 0) {
            operator delete(v76);
          }
          a5 = v38;
          if (v29[138] != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2818);
          }
        }
        long long v44 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          CFStringRef v45 = *(uint64_t **)(a5 + 24);
          a5 += 24;
          unint64_t v29 = v45;
          int v46 = *(char *)(a5 + 23);
          sub_1002811D4(v17, (uint64_t)&v76);
          unsigned int v47 = v46 >= 0 ? (uint64_t *)a5 : v29;
          unsigned int v48 = v77 >= 0 ? &v76 : (void **)v76;
          *(_DWORD *)uint64_t buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v47;
          *(_WORD *)&unsigned char buf[28] = 2082;
          *(void *)&buf[30] = v48;
          __int16 v72 = 2082;
          unint64_t v73 = (unint64_t)"assert";
          __int16 v74 = 2081;
          char v75 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (v77 < 0) {
            operator delete(v76);
          }
        }
        abort_report_np();
        __break(1u);
LABEL_72:
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
    }
    *(_OWORD *)uint64_t buf = *(_OWORD *)v17;
    *(_OWORD *)&buf[16] = *(_OWORD *)(v17 + 216);
    sub_10027CA30((uint64_t)v59, buf, buf);
  }
  memset(v57, 0, sizeof(v57));
  int v58 = 1065353216;
  unsigned int v19 = v67;
  for (j = v68; v19 != j; v19 += 4)
  {
    *(_OWORD *)uint64_t buf = *v19;
    *(_OWORD *)&buf[16] = *(_OWORD *)((char *)v19 + 40);
    sub_10029011C(v57, buf);
  }
  if (v64 == v65)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v21 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = a5 + 24;
      if (*(char *)(a5 + 47) < 0) {
        uint64_t v22 = *(void *)(a5 + 24);
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, no labeled recording triggers\", \"Client ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
  }
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v23 = v64;
  uint64_t v24 = v65;
  *(void *)uint64_t buf = &v54;
  if (v64 == v65) {
    goto LABEL_29;
  }
  do
  {
    if (*(_DWORD *)(v23 + 72) == 13) {
      sub_1001F28EC((uint64_t **)buf, (long long *)v23);
    }
    v23 += 240;
  }
  while (v23 != v24);
  uint64_t v25 = v64;
  uint64_t v23 = v65;
  *(void *)uint64_t buf = &v51;
  if (v64 == v65)
  {
LABEL_29:
    uint64_t v26 = v23;
  }
  else
  {
    do
    {
      if (*(_DWORD *)(v25 + 72) == 1) {
        sub_1001F28EC((uint64_t **)buf, (long long *)v25);
      }
      v25 += 240;
    }
    while (v25 != v23);
    uint64_t v26 = v65;
    uint64_t v23 = v64;
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((v26 - v23) >> 4) != 0xEEEEEEEEEEEEEEEFLL * ((v55 - v54) >> 4)
                                                  - 0x1111111111111111 * ((v52 - v51) >> 4))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v27 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(void *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v65 - v64) >> 4);
      *(_WORD *)&unsigned char buf[28] = 2050;
      *(void *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v55 - v54) >> 4);
      __int16 v72 = 2050;
      unint64_t v73 = 0xEEEEEEEEEEEEEEEFLL * ((v52 - v51) >> 4);
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
    }
    unint64_t v28 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(void *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v65 - v64) >> 4);
      *(_WORD *)&unsigned char buf[28] = 2050;
      *(void *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v55 - v54) >> 4);
      __int16 v72 = 2050;
      unint64_t v73 = 0xEEEEEEEEEEEEEEEFLL * ((v52 - v51) >> 4);
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization", "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
    }
  }
  operator new();
}

void sub_100285ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  uint64_t v68 = a60;
  a60 = 0;
  if (v68) {
    (*(void (**)(uint64_t))(*(void *)v68 + 8))(v68);
  }
  (*(void (**)(uint64_t))(*(void *)a20 + 8))(a20);
  a31 = (uint64_t)&a61;
  sub_1001EF794((void ***)&a31);
  a31 = (uint64_t)&a64;
  sub_1001EF794((void ***)&a31);
  sub_1000D7D80((uint64_t)&a67);
  sub_1000D7D80((uint64_t)&STACK[0x200]);
  a31 = (uint64_t)&STACK[0x248];
  sub_1001EF794((void ***)&a31);
  a31 = (uint64_t)&STACK[0x260];
  sub_1001E7FBC((void ***)&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_1002861D8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 112))
  {
    *(void *)a1 = *(void *)a2;
    uint64_t v4 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v4);
    }
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
    *(unsigned char *)(a2 + 31) = 0;
    *(unsigned char *)(a2 + 8) = 0;
    long long v6 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
    sub_10026D5F8(a1 + 56, a2 + 56);
  }
  else
  {
    sub_100288BC0(a1, a2);
    *(unsigned char *)(a1 + 112) = 1;
  }
  return a1;
}

uint64_t sub_100286278(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1002862B4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X5>, uint64_t a6@<X6>, unsigned char *a7@<X8>, uint64_t a8)
{
  sub_10027EBE4(a1, (long long *)a8, (uint64_t)v56);
  memset(v55, 0, sizeof(v55));
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  unsigned int v14 = sub_10027EB34();
  uint64_t v15 = *(void *)a8;
  uint64_t v16 = *(void *)(a8 + 8);
  __int16 v50 = 0;
  uint64_t v51 = 0;
  long long __p = 0;
  sub_10010F834(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  sub_10027EE20(a1, a2, v55, (uint64_t)&v52, v15, v16, v17, v14);
  if (__p)
  {
    __int16 v50 = __p;
    operator delete(__p);
  }
  memset(v47, 0, sizeof(v47));
  int v48 = 1065353216;
  int v18 = v52;
  unsigned int v19 = v53;
  while (v18 != v19)
  {
    *(_OWORD *)uint64_t buf = *v18;
    sub_1001EFB90((uint64_t)v47, buf, buf);
    v18 += 15;
  }
  sub_100286930(a1, a3, *(void *)a8, *(void *)(a8 + 8), (uint64_t)&v45);
  uint64_t v21 = v45;
  uint64_t v20 = v46;
  if (v45 != v46)
  {
    while (!sub_1001EFDE4(v47, v21))
    {
      v21 += 15;
      if (v21 == v20)
      {
        uint64_t v21 = v20;
        goto LABEL_18;
      }
    }
    if (v21 != v20)
    {
      for (uint64_t i = v21 + 15; i != v20; i += 15)
      {
        if (!sub_1001EFDE4(v47, i))
        {
          long long v23 = *i;
          *((void *)v21 + 2) = *((void *)i + 2);
          long long *v21 = v23;
          uint64_t v24 = (void **)v21 + 3;
          if (*((char *)v21 + 47) < 0) {
            operator delete(*v24);
          }
          long long v25 = *(long long *)((char *)i + 24);
          *((void *)v21 + 5) = *((void *)i + 5);
          *(_OWORD *)uint64_t v24 = v25;
          *((unsigned char *)i + 47) = 0;
          *((unsigned char *)i + 24) = 0;
          long long v26 = i[3];
          *(long long *)((char *)v21 + 60) = *(long long *)((char *)i + 60);
          v21[3] = v26;
          sub_100267D64((uint64_t)(v21 + 5), (uint64_t)(i + 5));
          long long v27 = *(long long *)((char *)i + 216);
          *((unsigned char *)v21 + 232) = *((unsigned char *)i + 232);
          *(long long *)((char *)v21 + 216) = v27;
          v21 += 15;
        }
      }
    }
  }
LABEL_18:
  sub_1001EBD5C((uint64_t)&v45, (uint64_t)v21, v46);
  sub_1000C7F88(buf);
  unsigned int v57 = 0;
  CFStringRef v28 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearningRecordingLimit", 0x8000100u, kCFAllocatorNull);
  int v29 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v28, &v57);
  CFRelease(v28);
  unint64_t v30 = v57;
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  unint64_t v31 = 500;
  if (v29) {
    unint64_t v31 = v30;
  }
  unint64_t v32 = 0xEEEEEEEEEEEEEEEFLL * (v53 - v52);
  BOOL v33 = v31 >= v32;
  unint64_t v34 = v31 - v32;
  if (v33) {
    unint64_t v35 = v34;
  }
  else {
    unint64_t v35 = 0;
  }
  long long v37 = (unint64_t *)v45;
  uint64_t v36 = (unint64_t *)v46;
  unint64_t v38 = 0xEEEEEEEEEEEEEEEFLL * (v46 - v45);
  if (v38 > v35)
  {
    sub_1001EBD5C((uint64_t)&v45, (uint64_t)v45, &v46[-15 * v35]);
    long long v37 = (unint64_t *)v45;
    uint64_t v36 = (unint64_t *)v46;
    unint64_t v38 = 0xEEEEEEEEEEEEEEEFLL * (v46 - v45);
  }
  unint64_t v39 = 126 - 2 * __clz(v38);
  if (v36 == v37) {
    uint64_t v40 = 0;
  }
  else {
    uint64_t v40 = v39;
  }
  sub_10028B790(v37, v36, v40, 1);
  *a7 = 0;
  a7[280] = 0;
  if (a4 == 4)
  {
    sub_1001EF9DC((uint64_t)v58, a5);
    sub_1001EC9B0((uint64_t)v58, v55, (uint64_t *)&v52, &v45, buf, (uint64_t *)(a2 + 24), a6, *(void *)a8, *(void *)(a8 + 8));
  }
  if (a4 == 3)
  {
    sub_1001EF9DC((uint64_t)v59, a5);
    sub_1001E9D88((uint64_t)v59, &v52, &v45, buf, (uint64_t *)(a2 + 24), a6, *(void *)a8, *(void *)(a8 + 8));
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  int v41 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v61 = 2050;
    uint64_t v62 = a4;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
  }
  uint64_t v42 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v61 = 2050;
    uint64_t v62 = a4;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v42, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid generation algorithm", "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
  }
  *(void *)uint64_t buf = &v45;
  sub_1001EF794((void ***)buf);
  sub_1000D7D80((uint64_t)v47);
  *(void *)uint64_t buf = &v52;
  sub_1001EF794((void ***)buf);
  *(void *)uint64_t buf = v55;
  sub_1001E7FBC((void ***)buf);
  return sub_1000D7D80((uint64_t)v56);
}

void sub_10028683C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50)
{
  sub_1001EF39C((uint64_t)&a49);
  sub_1001EFA74(&a41);
  sub_1001EF39C(v50);
  a40 = &a16;
  sub_1001EF794((void ***)&a40);
  sub_1000D7D80((uint64_t)&a19);
  a19 = &a27;
  sub_1001EF794((void ***)&a19);
  a19 = &a30;
  sub_1001E7FBC((void ***)&a19);
  sub_1000D7D80((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_100286930(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v5 = a3;
  *(void *)&long long v20 = a3;
  *((void *)&v20 + 1) = a4;
  uint64_t v9 = *(void *)(a1 + 8);
  long long v18 = v20;
  char v19 = 1;
  sub_1002888A0(v9, a2, &v18, (void *)a5);
  if (v5)
  {
LABEL_2:
    uint64_t v10 = *(void *)(a1 + 8);
    long long v16 = 0uLL;
    char v17 = 1;
    sub_1002888A0(v10, a2, &v16, &v13);
    sub_1002914D4((uint64_t *)a5, *(long long **)(a5 + 8), v13, v14, 0xEEEEEEEEEEEEEEEFLL * (v14 - v13));
    uint64_t v15 = &v13;
    sub_1001EF794((void ***)&v15);
  }
  else
  {
    uint64_t v11 = 1;
    while (v11 != 16)
    {
      if (*((unsigned __int8 *)&v20 + v11++))
      {
        if ((unint64_t)(v11 - 2) <= 0xE) {
          goto LABEL_2;
        }
        return;
      }
    }
  }
}

void sub_100286A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_1001EF794((void ***)&a13);
  sub_1001EF794(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100286A7C(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100286AC0(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = a1 + 2;
  unint64_t v5 = v6;
  unint64_t v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    uint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) > 0x492492492492492) {
      sub_1001D7FD4();
    }
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x249249249249249) {
      unint64_t v14 = 0x492492492492492;
    }
    else {
      unint64_t v14 = v12;
    }
    v21[4] = v4;
    uint64_t v15 = (char *)sub_10017EA6C((uint64_t)v4, v14);
    long long v16 = &v15[56 * v11];
    v21[0] = v15;
    v21[1] = v16;
    v21[3] = &v15[56 * v17];
    uint64_t v18 = *((void *)a2 + 2);
    *(_OWORD *)long long v16 = *a2;
    *((void *)v16 + 2) = v18;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    uint64_t v19 = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = v19;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)v16 + 6) = *((void *)a2 + 6);
    void v21[2] = v16 + 56;
    sub_10028D90C(a1, v21);
    uint64_t v10 = a1[1];
    sub_10028DAD8(v21);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    *(void *)(v7 + 48) = *((void *)a2 + 6);
    uint64_t v10 = v7 + 56;
    a1[1] = v7 + 56;
  }
  a1[1] = v10;
  return v10 - 56;
}

void sub_100286C38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10028DAD8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100286C4C(uint64_t a1, uint64_t a2, long long **a3, uint64_t a4, double a5)
{
  long long v26 = 0u;
  long long v27 = 0u;
  int v28 = 1065353216;
  uint64_t v10 = *(void **)a4;
  uint64_t v11 = *(void **)(a4 + 8);
  while (v10 != v11)
  {
    sub_1001EFB90((uint64_t)&v26, v10, v10);
    v10 += 10;
  }
  unint64_t v12 = *a3;
  unint64_t v13 = a3[1];
  if (*a3 == v13)
  {
    long long v16 = *a3;
  }
  else
  {
    do
    {
      uint64_t v14 = *(void *)(a1 + 8);
      long long v40 = *v12;
      uint64_t v15 = operator new(0x10uLL);
      uint64_t v24 = v15 + 1;
      long long v25 = v15 + 1;
      _OWORD *v15 = v40;
      long long __p = v15;
      sub_1001FFE00(v14, (uint64_t)&__p, &buf);
      if (__p)
      {
        uint64_t v24 = __p;
        operator delete(__p);
      }
      sub_1003342EC(&v26, &buf);
      long long __p = &buf;
      sub_100216394((void ***)&__p);
      v12 += 15;
    }
    while (v12 != v13);
    unint64_t v12 = *a3;
    long long v16 = a3[1];
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100333C24(a2, &v26, v16 != v12, a5, Current_5);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v18 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4);
    unint64_t v20 = 0xEEEEEEEEEEEEEEEFLL * (a3[1] - *a3);
    uint64_t v21 = *(void *)(a2 + 24);
    uint64_t buf = 68290050;
    __int16 v30 = 2082;
    unint64_t v31 = "";
    __int16 v32 = 2050;
    unint64_t v33 = v19;
    __int16 v34 = 2050;
    uint64_t v35 = *((void *)&v27 + 1);
    __int16 v36 = 2050;
    unint64_t v37 = v20;
    __int16 v38 = 2050;
    uint64_t v39 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Updating Anchor ID Set\", \"Num. Rapport Anchor Devices\":%{public}lu, \"Num Rapport and Measured Anchor Devices\":%{public}lu, \"Number of recordings since last model\":%{public}lu, \"Anchor Appearance Map size\":%{public}lu}", (uint8_t *)&buf, 0x3Au);
  }
  return sub_1000D7D80((uint64_t)&v26);
}

void sub_100286EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

uint64_t sub_100286EF0@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  long long v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    long long v9 = (char *)operator new(0x28uLL);
    *(void *)long long __p = v9;
    *(_OWORD *)&__p[8] = xmmword_101D048C0;
    *(_OWORD *)long long v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(void *)(v9 + 29) = 0;
    sub_1001E0650((uint64_t)a3, v9);
    uint64_t v10 = __p;
    if (__p[23] < 0) {
      uint64_t v10 = *(unsigned char **)__p;
    }
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = (uint64_t *)*a2;
    }
    *(void *)uint64_t buf = 68289538;
    __int16 v49 = 2082;
    uint64_t v50 = "";
    __int16 v51 = 2082;
    uint64_t v52 = v10;
    __int16 v53 = 2082;
    uint64_t v54 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"generating anchor appearance map for LOI\", \"LOI Id\":%{public, location:escape_only}s, \"LOI Type\":%{public, location:escape_only}s}", buf, 0x26u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  sub_1003335FC((uint64_t)v38);
  memset(v36, 0, sizeof(v36));
  int v37 = 1065353216;
  sub_100201854(a1[1], a3, buf);
  if (v56) {
    goto LABEL_12;
  }
  uint64_t v18 = a1[1];
  int v41 = 0;
  *(void *)&long long v42 = 0;
  sub_100201854(v18, (long long *)&v41, __p);
  sub_100288A94((uint64_t)buf, (uint64_t)__p);
  sub_100288C48((uint64_t)__p);
  double v14 = 0.0;
  if (v56)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    unint64_t v19 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v20 = operator new(0x28uLL);
      int v41 = v20;
      long long v42 = xmmword_101D048C0;
      _OWORD *v20 = 0u;
      v20[1] = 0u;
      *(void *)((char *)v20 + 29) = 0;
      sub_1001E0650((uint64_t)a3, v20);
      uint64_t v21 = &v41;
      if (v42 < 0) {
        uint64_t v21 = v41;
      }
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v22 = a2;
      }
      else {
        uint64_t v22 = (uint64_t *)*a2;
      }
      *(void *)long long __p = 68289539;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&unsigned char __p[18] = 2082;
      *(void *)&__p[20] = v21;
      __int16 v45 = 2081;
      int v46 = v22;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Previous anchor appearance not found for LOI ID. Using anchor appearance map for null uuid and loi type\", \"loi id\":%{public, location:escape_only}s, \"loi type\":%{private, location:escape_only}s}", __p, 0x26u);
      if (SHIBYTE(v42) < 0) {
        operator delete(v41);
      }
    }
    if (v56)
    {
LABEL_12:
      uint64_t v12 = v55;
      if (!v55) {
        uint64_t v12 = *(void *)(qword_102489B20 + 24);
      }
      uint64_t v13 = *(void *)(v12 + 8);
      if (!v13) {
        uint64_t v13 = *(void *)(qword_102489B10 + 8);
      }
      sub_100333654((uint64_t)__p, v13);
      int v39 = *(_DWORD *)((char *)&v46 + 2);
      sub_1001EEAA8(v38, *(uint64_t **)&__p[16], 0);
      long long v40 = v47;
      sub_1000D7D80((uint64_t)__p);
      double v14 = *(double *)buf;
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v15 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        long long v16 = operator new(0x28uLL);
        int v41 = v16;
        long long v42 = xmmword_101D048C0;
        _OWORD *v16 = 0u;
        v16[1] = 0u;
        *(void *)((char *)v16 + 29) = 0;
        sub_1001E0650((uint64_t)a3, v16);
        uint64_t v17 = &v41;
        if (v42 < 0) {
          uint64_t v17 = v41;
        }
        *(void *)long long __p = 68289538;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&__p[10] = "";
        *(_WORD *)&unsigned char __p[18] = 2082;
        *(void *)&__p[20] = v17;
        __int16 v45 = 1026;
        LODWORD(v46) = (int)v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Relying on previous anchor appearance map from configuration table\", \"loiGroupId\":%{public, location:escape_only}s, \"timestamp\":%{public}d}", __p, 0x22u);
        if (SHIBYTE(v42) < 0) {
          operator delete(v41);
        }
      }
    }
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  std::to_string(&v35, v14);
  std::to_string(&v34, Current_5);
  sub_1002008A8(a1[1], (uint64_t)&v35, (uint64_t)&v34, (uint64_t)a3, v33);
  if (*a3 != 0)
  {
    uint64_t v24 = a1[1];
    int v41 = 0;
    *(void *)&long long v42 = 0;
    sub_1002008A8(v24, (uint64_t)&v35, (uint64_t)&v34, (uint64_t)&v41, __p);
    sub_10028DB54((uint64_t *)v33, v33[1], *(long long **)__p, *(long long **)&__p[8], 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4));
    int v41 = __p;
    sub_1001EF794((void ***)&v41);
  }
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  sub_1000C7F88(__p);
  LOBYTE(v41) = 0;
  CFStringRef v25 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRapportUsageEnabled", 0x8000100u, kCFAllocatorNull);
  int v26 = sub_1000D29FC(*(uint64_t *)__p, (uint64_t)v25, (BOOL *)&v41);
  CFRelease(v25);
  int v27 = v41;
  if (*(void *)&__p[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&__p[8]);
  }
  if (v27) {
    int v28 = 0;
  }
  else {
    int v28 = v26;
  }
  if (v28 != 1)
  {
    (*(void (**)(unsigned char *__return_ptr, double))(*(void *)*a1 + 40))(__p, v14);
    sub_10028E210((void **)&v31);
    long long v31 = *(_OWORD *)__p;
    uint64_t v32 = *(void *)&__p[16];
    memset(__p, 0, 24);
    int v41 = __p;
    sub_10028E178((void ***)&v41);
  }
  sub_100286C4C((uint64_t)a1, (uint64_t)v38, v33, (uint64_t)&v31, v14);
  sub_10023E144((uint64_t)&v41);
  v43 |= 2u;
  int v29 = (_DWORD *)v42;
  if (!(void)v42) {
    operator new();
  }
  sub_10033389C((uint64_t)v38, (int *)__p);
  sub_100248404(v29, (uint64_t)__p);
  sub_100247FA8((uint64_t *)__p);
  sub_100287700((uint64_t)&v41, a4, Current_5);
  sub_10026B968((wireless_diagnostics::google::protobuf::MessageLite *)&v41);
  *(void *)long long __p = &v31;
  sub_10028E178((void ***)__p);
  *(void *)long long __p = v33;
  sub_1001EF794((void ***)__p);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  sub_100288C48((uint64_t)buf);
  sub_100289BB4((uint64_t)v36);
  return sub_1000D7D80((uint64_t)v38);
}

void sub_10028759C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46)
{
  operator delete(v46);
  sub_100288C48(v47 - 224);
  sub_100289BB4((uint64_t)&a27);
  sub_1000D7D80((uint64_t)&a32);
  _Unwind_Resume(a1);
}

void sub_100287700(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  sub_10023E1B0(a2);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (!sub_10016E644(v6)) {
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  }
  int v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_1002E67D4(a2, a1);
}

void sub_100287794(_Unwind_Exception *a1)
{
  sub_10026CC30(v1);
  _Unwind_Resume(a1);
}

void sub_1002877A8(uint64_t *a1, uint64_t a2)
{
  if (sub_10027ED70())
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    unint64_t v17 = 0;
    sub_1001FF120(a1[1], &v13);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v19 = 2082;
      unint64_t v20 = "";
      __int16 v21 = 2050;
      uint64_t v22 = (v14 - v13) >> 6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Generating anchor appearance maps\", \"LOI count\":%{public}ld}", buf, 0x1Cu);
    }
    uint64_t v5 = v13;
    uint64_t v6 = v14;
    if (v13 == v14)
    {
LABEL_13:
      if (sub_100287C70(a1[1])) {
        goto LABEL_26;
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Warning failed to insert Anchor Appearances Map to MicroLocation DB", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_26;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419450 == -1)
      {
LABEL_29:
        uint64_t v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
LABEL_26:
        *(void *)uint64_t buf = &v13;
        sub_10020D8FC((void ***)buf);
        *(void *)uint64_t buf = &v15;
        sub_1002283E4((void ***)buf);
        return;
      }
    }
    else
    {
      while (1)
      {
        uint64_t v7 = *(void *)(a2 + 24);
        if (!v7) {
          sub_10015E48C();
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48))(v7)) {
          break;
        }
        sub_100286EF0(a1, (uint64_t *)(v5 + 40), (long long *)(v5 + 24), (uint64_t)buf);
        unint64_t v8 = v16;
        if (v16 >= v17)
        {
          uint64_t v9 = sub_10028E280(&v15, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
        }
        else
        {
          sub_10028E3C0((uint64_t)&v17, v16, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
          uint64_t v9 = v8 + 112;
        }
        unint64_t v16 = v9;
        sub_10026CC30((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v5 += 64;
        if (v5 == v6) {
          goto LABEL_13;
        }
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Cancelled, skipping generation of anchor appearance maps", buf, 2u);
      }
      if (!sub_10013D1A0(115, 2)) {
        goto LABEL_26;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419450 == -1) {
        goto LABEL_29;
      }
    }
    dispatch_once(&qword_102419450, &stru_1022A2818);
    goto LABEL_29;
  }
}

void sub_100287C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a13;
  sub_10020D8FC(&a19);
  a19 = (void **)&a16;
  sub_1002283E4(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100287C70(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 208);
    if (!v2) {
      operator new();
    }
    uint64_t v3 = sub_100224A6C(v2);
    sub_10028B308(a1);
    return v3;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationConfigurationTable::Entry]", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    return 0;
  }
}

void sub_100287EA4()
{
}

void sub_100287ED0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningBegin event", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::onLearningBegin(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    uint64_t v5 = *(void (**)(void))(**(void **)a1 + 16);
    v5();
  }
}

void sub_1002880F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningCompleted event", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::onLearningCompleted(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    uint64_t v5 = *(void (**)(void))(**(void **)a1 + 48);
    v5();
  }
}

void sub_100288310(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)(a4 + 16))
  {
    std::to_string(&v17, *(double *)(a4 + 8));
    std::to_string(&v18, *a3);
    sub_1002008A8(*(void *)(a1 + 8), (uint64_t)&v17, (uint64_t)&v18, a5, v15);
    if (v15[1] == v15[0]) {
      int v10 = *(_DWORD *)a4;
    }
    else {
      int v10 = *(_DWORD *)a4 + 1;
    }
    *(_DWORD *)(a2 + 12) = v10;
    unint64_t v16 = (void **)v15;
    sub_1001EF794(&v16);
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      v17.__r_.__value_.__r.__words[0] = 0x104000100;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Learning model without old model. Setting number of days with recordings to %d", (uint8_t *)&v17, 8u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(&v17, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      v18.__r_.__value_.__r.__words[0] = 0x104000100;
      uint64_t v14 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLearner::updateModelDaysWithRecordings(CLMicroLocationModel &, const cl::chrono::CFAbsoluteTimeClock::time_point &, const std::optional<struct ModelStabilityParameters> &, const boost::uuids::uuid &)", "%s\n", (const char *)v14);
      if (v14 != &v17) {
        free(v14);
      }
    }
    *(_DWORD *)(a2 + 12) = 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v12 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    int v13 = *(_DWORD *)(a2 + 12);
    v17.__r_.__value_.__r.__words[0] = 68289283;
    LOWORD(v17.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v17.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(v17.__r_.__value_.__r.__words[2]) = 1025;
    HIDWORD(v17.__r_.__value_.__r.__words[2]) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Setting model number of days with recordings\", \"numDaysWithRecordings\":%{private}u}", (uint8_t *)&v17, 0x18u);
  }
}

void sub_1002885F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v20 - 73) < 0) {
    operator delete(*(void **)(v20 - 96));
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100288630(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_1001D7FD4();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)sub_1000DA54C(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    int v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t sub_1002886D8()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 10;
  }
}

void sub_10028876C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100288788(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 256) && *(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  sub_10024B47C(a1 + 32);
  return a1;
}

void sub_1002887CC(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, void *a4@<X8>)
{
  sub_100134750(__p, "RecordingUUID");
  long long v10 = *a3;
  char v11 = *((unsigned char *)a3 + 16);
  sub_100200490(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10028887C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002888A0(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, void *a4@<X8>)
{
  sub_100134750(__p, "RecordingTimestamp");
  long long v10 = *a3;
  char v11 = *((unsigned char *)a3 + 16);
  sub_100200490(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100288950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100288974(void *result)
{
  uint64_t v1 = result[2];
  for (uint64_t i = result[3]; v1 != i; v1 += 32)
  {
    v4[0] = off_1022A2B90;
    void v4[3] = v4;
    uint64_t v3 = *(void *)(v1 + 24);
    if (!v3) {
      sub_10015E48C();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v4);
    uint64_t result = sub_1001EFA74(v4);
  }
  return result;
}

void sub_100288A4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100288A64(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100288A94(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 112) == *(unsigned __int8 *)(a2 + 112))
  {
    if (*(unsigned char *)(a1 + 112))
    {
      *(void *)a1 = *(void *)a2;
      unsigned int v4 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*v4);
      }
      long long v5 = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)unsigned int v4 = v5;
      *(unsigned char *)(a2 + 31) = 0;
      *(unsigned char *)(a2 + 8) = 0;
      long long v6 = *(_OWORD *)(a2 + 32);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = v6;
      sub_10026D5F8(a1 + 56, a2 + 56);
    }
  }
  else if (*(unsigned char *)(a1 + 112))
  {
    sub_100288B7C(a1);
  }
  else
  {
    sub_100288BC0(a1, a2);
    *(unsigned char *)(a1 + 112) = 1;
  }
}

void sub_100288B7C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    sub_10026CC30((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
}

uint64_t sub_100288BC0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v3 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  sub_10026CB60(a1 + 56, a2 + 56);
  return a1;
}

void sub_100288C2C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100288C48(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    sub_10026CC30((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

double sub_100288C8C@<D0>(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t context = 0;
  long long v6 = 0uLL;
  v7.length = CFArrayGetCount(a1);
  v7.location = 0;
  CFArrayApplyFunction(a1, v7, (CFArrayApplierFunction)sub_100288D10, &context);
  *(void *)a2 = context;
  double result = *(double *)&v6;
  *(_OWORD *)(a2 + 8) = v6;
  return result;
}

void sub_100288CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100288D10(const void *a1, uint64_t a2)
{
  char v3 = sub_100288D4C(a1);
  sub_100288D94(a2, &v3);
}

uint64_t sub_100288D4C(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID()) {
    return CFBooleanGetValue((CFBooleanRef)a1) != 0;
  }
  uint64_t v4 = sub_101A5706C();
  return sub_100288D94(v4);
}

void sub_100288D94(uint64_t a1, unsigned char *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0) {
      sub_1001D7FD4();
    }
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    sub_100288E3C((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4 + 1;
  uint64_t v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1 << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

void sub_100288E3C(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      sub_1001D7FD4();
    }
    uint64_t v10 = 0;
    long long v11 = 0uLL;
    sub_100288EFC(&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    uint64_t v8 = *a1;
    int v9 = 0;
    unint64_t v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    sub_100288F44(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    unint64_t v4 = *a1;
    *a1 = v10;
    uint64_t v10 = v4;
    long long v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    long long v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_100288EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100288EFC(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_1001D7FD4();
  }
  double result = sub_1000DA54C((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void sub_100288F44(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*a1 + 8 * v6) = 0;
  }
  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  sub_100288FE8(&v16, &v14, &v12, (uint64_t)&v11);
}

void sub_100288FE8(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  sub_100289078((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_100289078(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *int v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

void *sub_100289148(void *result, unsigned char *a2, unsigned char *a3, uint64_t a4)
{
  unint64_t v4 = result[1];
  unint64_t v5 = v4 + a4;
  result[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*result + 8 * v6) = 0;
  }
  if (a2 != a3)
  {
    int v7 = v4 & 0x3F;
    int v8 = (uint64_t *)(*result + 8 * (v4 >> 6));
    do
    {
      uint64_t v9 = 1 << v7;
      if (*a2) {
        uint64_t v10 = *v8 | v9;
      }
      else {
        uint64_t v10 = *v8 & ~v9;
      }
      *int v8 = v10;
      ++a2;
      v8 += v7 == 63;
      if (v7 == 63) {
        int v7 = 0;
      }
      else {
        ++v7;
      }
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t sub_1002891E4(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 224);
    if (!v2) {
      operator new();
    }
    uint64_t v3 = sub_100339274(v2);
    sub_100289444(a1);
    return v3;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    unint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2818);
      }
      unint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationModelTable::Entry]", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    return 0;
  }
}

void sub_100289418()
{
}

uint64_t sub_100289444(uint64_t a1)
{
  unsigned int v2 = sub_10020EB4C(a1);
  if (sub_10028963C() > v2) {
    return 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    int v8 = "MicroLocationModels";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationModelTable]", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t result = sub_10020777C(a1);
  if (result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0) {
      uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_10003CC68(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_10028963C()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsModelTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 100;
  }
}

void sub_1002896D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_1002896EC(_OWORD *a1, long long *a2)
{
  long long v4 = *a2;
  *(_OWORD *)((char *)a1 + 12) = *(long long *)((char *)a2 + 12);
  *a1 = v4;
  sub_10024B304((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  sub_1000E3A78((uint64_t)a1 + 232, (long long *)((char *)a2 + 232));
  *(_OWORD *)((char *)a1 + 264) = *(long long *)((char *)a2 + 264);
  return a1;
}

void sub_100289758(_Unwind_Exception *a1)
{
  sub_10024B47C(v1);
  _Unwind_Resume(a1);
}

_OWORD *sub_10028976C(uint64_t a1, long long *a2, long long *a3, _OWORD *a4)
{
  long long v4 = a4;
  uint64_t v10 = a4;
  int v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    do
    {
      sub_1002896EC(v4, v6);
      unint64_t v6 = (long long *)((char *)v6 + 280);
      long long v4 = (_OWORD *)((char *)v11 + 280);
      int v11 = (_OWORD *)((char *)v11 + 280);
    }
    while (v6 != a3);
  }
  char v9 = 1;
  sub_100289810((uint64_t)v8);
  return v4;
}

void sub_1002897FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100289810(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100289848((uint64_t *)a1);
  }
  return a1;
}

uint64_t *sub_100289848(uint64_t *result)
{
  unsigned int v2 = (uint64_t *)result[1];
  uint64_t v1 = (uint64_t *)result[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *result;
    do
    {
      v3 -= 280;
      uint64_t result = (uint64_t *)sub_10028989C(v5, v3);
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t sub_10028989C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 256) && *(char *)(a2 + 255) < 0) {
    operator delete(*(void **)(a2 + 232));
  }

  return sub_10024B47C(a2 + 32);
}

void sub_1002898E8(void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 280;
        sub_10028989C((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100289980(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_100227D74(a1, v4, v6);
      v6 += 112;
      uint64_t v4 = v12 + 112;
      v12 += 112;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_100289A2C((uint64_t)v9);
  return v4;
}

void sub_100289A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100289A2C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100289A64((uint64_t *)a1);
  }
  return a1;
}

void sub_100289A64(uint64_t *a1)
{
  unsigned int v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 112;
      sub_100227E9C(v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t sub_100289AB8(uint64_t a1)
{
  sub_100289AF4(a1, *(void **)(a1 + 16));
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100289AF4(uint64_t a1, void *a2)
{
  if (a2)
  {
    unsigned int v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_1002220F0((uint64_t)(v2 + 4));
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
}

uint64_t sub_100289B38(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 352))
  {
    if (*(char *)(a1 + 351) < 0) {
      operator delete(*(void **)(a1 + 328));
    }
    unsigned int v2 = *(void **)(a1 + 304);
    if (v2)
    {
      *(void *)(a1 + 312) = v2;
      operator delete(v2);
    }
    sub_1001EF1F0(a1 + 256);
    uint64_t v4 = (void **)(a1 + 232);
    sub_1001EF278(&v4);
    sub_1001EF318(a1 + 72);
    sub_1000D7D80(a1 + 16);
  }
  return a1;
}

uint64_t sub_100289BB4(uint64_t a1)
{
  sub_100289BF0(a1, *(void **)(a1 + 16));
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100289BF0(int a1, void *__p)
{
  if (__p)
  {
    unsigned int v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[5];
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
}

void sub_100289C38(id a1)
{
  qword_102419468 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

uint64_t sub_100289C68(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 280) == *(unsigned __int8 *)(a2 + 280))
  {
    if (*(unsigned char *)(result + 280))
    {
      return sub_100338D60(result, a2);
    }
  }
  else if (*(unsigned char *)(result + 280))
  {
    return sub_1001F2564(result);
  }
  else
  {
    uint64_t result = sub_100338D5C(result, a2);
    *(unsigned char *)(result + 280) = 1;
  }
  return result;
}

void sub_100289CD0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120))
  {
    if (*(unsigned char *)(a1 + 120))
    {
      sub_1000F4EBC(a1, (__n128 *)a2);
      sub_1000F4EBC(a1 + 24, (__n128 *)(a2 + 24));
      sub_10027C114((uint64_t *)(a1 + 48), a2 + 48);
      sub_1000F4EBC(a1 + 80, (__n128 *)(a2 + 80));
      uint64_t v4 = *(void *)(a2 + 104);
      *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
      *(void *)(a1 + 104) = v4;
    }
  }
  else if (*(unsigned char *)(a1 + 120))
  {
    sub_100289D84(a1);
  }
  else
  {
    sub_10027C208(a1, a2);
    *(unsigned char *)(a1 + 120) = 1;
  }
}

void sub_100289D84(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120))
  {
    unsigned int v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(void *)(a1 + 88) = v2;
      operator delete(v2);
    }
    if (*(unsigned char *)(a1 + 72))
    {
      uint64_t v3 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = 0;
      if (v3) {
        operator delete[]();
      }
    }
    uint64_t v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(void *)(a1 + 32) = v4;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v5;
      operator delete(v5);
    }
    *(unsigned char *)(a1 + 120) = 0;
  }
}

void sub_100289E08(uint64_t *a1)
{
  if (*a1)
  {
    sub_1001EF2CC(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100289E44(uint64_t a1, uint64_t *a2)
{
  sub_100289EE8(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  int v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *int v7 = 0;
    v7[1] = 0;
  }
}

void sub_100289EE8(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1001EF22C(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t sub_100289F40(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1001EF40C(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_10028A034((unsigned char *)(a1 + 72), a2 + 72);
  long long v4 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 212) = *(_OWORD *)(a2 + 212);
  *(_OWORD *)(a1 + 200) = v4;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)(a2 + 232);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a2 + 232) = 0;
  *(void *)(a2 + 240) = 0;
  *(void *)(a2 + 248) = 0;
  sub_1000E2908(a1 + 256, (uint64_t *)(a2 + 256));
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  *(void *)(a2 + 304) = 0;
  *(void *)(a2 + 312) = 0;
  *(void *)(a2 + 320) = 0;
  long long v5 = *(_OWORD *)(a2 + 328);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(_OWORD *)(a1 + 328) = v5;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 344) = 0;
  *(void *)(a2 + 328) = 0;
  *(unsigned char *)(a1 + 352) = 1;
  return a1;
}

void sub_10028A020(_Unwind_Exception *a1)
{
  sub_1000D7D80(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_10028A034(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(unsigned char *)(a2 + 120))
  {
    sub_10027C208((uint64_t)a1, a2);
    a1[120] = 1;
  }
  return a1;
}

void sub_10028A078(_Unwind_Exception *a1)
{
  sub_1001EF318(v1);
  _Unwind_Resume(a1);
}

void sub_10028A090()
{
}

void *sub_10028A0A4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2890;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A0EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2890;
  a2[1] = v2;
  return result;
}

void *sub_10028A118(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_100287ED0(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A1A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A1C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A204()
{
}

void sub_10028A214()
{
}

void *sub_10028A228(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2910;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A270(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2910;
  a2[1] = v2;
  return result;
}

void *sub_10028A29C(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_1002877A8(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A348(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A388()
{
}

void sub_10028A398()
{
}

void *sub_10028A3AC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2990;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A3F4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2990;
  a2[1] = v2;
  return result;
}

void *sub_10028A420(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_10027F124(v3, (uint64_t)v6, 0);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A4AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A4D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A510()
{
}

void sub_10028A520()
{
}

void *sub_10028A534(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2A10;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A57C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2A10;
  a2[1] = v2;
  return result;
}

void *sub_10028A5A8(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_10027F124(v3, (uint64_t)v6, 1u);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A634(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A658(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A698()
{
}

void sub_10028A6A8()
{
}

void *sub_10028A6BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2A90;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A704(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2A90;
  a2[1] = v2;
  return result;
}

void *sub_10028A730(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_10027F124(v3, (uint64_t)v6, 2u);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A7BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A7E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A820()
{
}

void sub_10028A830()
{
}

void *sub_10028A844(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A2B10;
  result[1] = v3;
  return result;
}

uint64_t sub_10028A88C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2B10;
  a2[1] = v2;
  return result;
}

void *sub_10028A8B8(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_1002880F0(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10028A940(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A964(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10028A9A4()
{
}

void sub_10028A9B0(uint64_t *a1)
{
  if (*a1)
  {
    sub_1001E8010(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_10028A9EC(uint64_t *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 6)
    {
      uint64_t v19 = v12 - a2;
      uint64_t v20 = (uint64_t)(v12 - a2) >> 6;
      if (v20 >= a5)
      {
        int v21 = (long long *)(a3 + (a5 << 6));
      }
      else
      {
        int v21 = (long long *)(a3 + (v20 << 6));
        a1[1] = sub_10028AD58(v9, v21, a4, *(void *)(v9 - 8));
        if (v19 < 1) {
          return v5;
        }
      }
      sub_10028AB6C((uint64_t)a1, v5, v12, v5 + (a5 << 6));
      sub_10028AF70(a3, (uint64_t)v21, v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *a1) >> 6);
      if (v14 >> 58) {
        sub_1001D7FD4();
      }
      uint64_t v15 = (a2 - v13) >> 6;
      uint64_t v16 = v10 - v13;
      if (v16 >> 5 > v14) {
        unint64_t v14 = v16 >> 5;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v17 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v27 = v9;
      if (v17) {
        uint64_t v18 = (char *)sub_10017EAF0(v9, v17);
      }
      else {
        uint64_t v18 = 0;
      }
      long long v23 = v18;
      uint64_t v24 = &v18[64 * v15];
      CFStringRef v25 = v24;
      int v26 = &v18[64 * v17];
      sub_10028ABFC(&v23, a3, a5);
      uint64_t v5 = sub_10028ACA4(a1, &v23, v5);
      sub_1001E7F2C((uint64_t)&v23);
    }
  }
  return v5;
}

void sub_10028AB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028AB6C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v9;
      long long v10 = *(_OWORD *)(v9 + 16);
      *(void *)(v8 + 32) = *(void *)(v9 + 32);
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 16) = 0;
      long long v11 = *(_OWORD *)(v9 + 40);
      *(void *)(v8 + 56) = *(void *)(v9 + 56);
      *(_OWORD *)(v8 + 40) = v11;
      v8 += 64;
      v9 += 64;
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return sub_10028AEBC((uint64_t)&v13, a2, v7, v6);
}

void *sub_10028ABFC(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[2];
  if (a3)
  {
    uint64_t v5 = (long long *)(a2 + 16);
    uint64_t v6 = a3 << 6;
    uint64_t v7 = v4 + (a3 << 6);
    do
    {
      *(_OWORD *)uint64_t v4 = *(v5 - 1);
      uint64_t result = (void *)(v4 + 16);
      if (*((char *)v5 + 23) < 0)
      {
        uint64_t result = sub_1000DC48C(result, *(void **)v5, *((void *)v5 + 1));
      }
      else
      {
        long long v8 = *v5;
        *(void *)(v4 + 32) = *((void *)v5 + 2);
        *(_OWORD *)uint64_t result = v8;
      }
      long long v9 = *(long long *)((char *)v5 + 24);
      *(void *)(v4 + 56) = *((void *)v5 + 5);
      *(_OWORD *)(v4 + 40) = v9;
      v4 += 64;
      v5 += 4;
      v6 -= 64;
    }
    while (v6);
    uint64_t v4 = v7;
  }
  v3[2] = v4;
  return result;
}

void sub_10028AC9C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10028ACA4(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  sub_1001E7DF0((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_10028AFEC(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_10028AD58(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v15 = a4;
  uint64_t v16 = a4;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2 + 1;
    do
    {
      *(_OWORD *)uint64_t v4 = *(v6 - 1);
      uint64_t v7 = (unsigned char *)(v4 + 16);
      if (*((char *)v6 + 23) < 0)
      {
        sub_1000DC48C(v7, *(void **)v6, *((void *)v6 + 1));
        uint64_t v9 = v16;
      }
      else
      {
        long long v8 = *v6;
        *(void *)(v4 + 32) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v7 = v8;
        uint64_t v9 = v4;
      }
      uint64_t v10 = v6 - 1;
      long long v11 = *(long long *)((char *)v6 + 24);
      *(void *)(v4 + 56) = *((void *)v6 + 5);
      *(_OWORD *)(v4 + 40) = v11;
      uint64_t v4 = v9 + 64;
      uint64_t v16 = v9 + 64;
      v6 += 4;
    }
    while (v10 + 4 != a3);
  }
  char v14 = 1;
  sub_10028AE3C((uint64_t)v13);
  return v4;
}

void sub_10028AE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10028AE3C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10028AE74(a1);
  }
  return a1;
}

void sub_10028AE74(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 25) < 0) {
      operator delete(*(void **)(v1 - 48));
    }
    v1 -= 64;
  }
}

uint64_t sub_10028AEBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      *(_OWORD *)(a4 + v7 - 64) = *(_OWORD *)(a3 + v7 - 64);
      uint64_t v10 = (void **)(a4 + v7 - 48);
      if (*(char *)(a4 + v7 - 25) < 0) {
        operator delete(*v10);
      }
      long long v11 = *(_OWORD *)(v8 - 48);
      *(void *)(a4 + v7 - 32) = *(void *)(v8 - 32);
      *(_OWORD *)uint64_t v10 = v11;
      *(unsigned char *)(v8 - 25) = 0;
      *(unsigned char *)(v8 - 48) = 0;
      long long v12 = *(_OWORD *)(v8 - 24);
      *(void *)(v9 - 8) = *(void *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v12;
      v7 -= 64;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t sub_10028AF70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    *(_OWORD *)a3 = *(_OWORD *)v4;
    std::string::operator=((std::string *)(a3 + 16), (const std::string *)(v4 + 16));
    uint64_t v6 = *(void *)(v4 + 56);
    *(_OWORD *)(a3 + 40) = *(_OWORD *)(v4 + 40);
    *(void *)(a3 + 56) = v6;
    a3 += 64;
    v4 += 64;
  }
  while (v4 != v5);
  return v5;
}

uint64_t sub_10028AFEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v10 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  if (a2 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
      long long v5 = *(_OWORD *)(a2 + 16);
      *(void *)(v4 + 32) = *(void *)(a2 + 32);
      *(_OWORD *)(v4 + 16) = v5;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 16) = 0;
      long long v6 = *(_OWORD *)(a2 + 40);
      *(void *)(v4 + 56) = *(void *)(a2 + 56);
      *(_OWORD *)(v4 + 40) = v6;
      v4 += 64;
      a2 += 64;
    }
    while (a2 != a3);
    uint64_t v11 = v4;
  }
  char v9 = 1;
  sub_10028AE3C((uint64_t)v8);
  return v4;
}

void sub_10028B08C(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 240;
        sub_1001EF82C((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_10028B0FC(long long *a1, long long *a2)
{
  long long v11 = *a1;
  uint64_t v12 = *((void *)a1 + 2);
  *(_OWORD *)long long __p = *(long long *)((char *)a1 + 24);
  uint64_t v14 = *((void *)a1 + 5);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  *(_OWORD *)uint64_t v15 = a1[3];
  *(_OWORD *)&v15[12] = *(long long *)((char *)a1 + 60);
  uint64_t v4 = (uint64_t)(a1 + 5);
  sub_1002660C8(v16);
  long long v5 = (void **)a1 + 3;
  long long v17 = *(long long *)((char *)a1 + 216);
  char v18 = *((unsigned char *)a1 + 232);
  uint64_t v6 = *((void *)a2 + 2);
  *a1 = *a2;
  *((void *)a1 + 2) = v6;
  if (*((char *)a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v7 = *(long long *)((char *)a2 + 24);
  *((void *)a1 + 5) = *((void *)a2 + 5);
  *(_OWORD *)long long v5 = v7;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  long long v8 = a2[3];
  *(long long *)((char *)a1 + 60) = *(long long *)((char *)a2 + 60);
  a1[3] = v8;
  sub_100267D64(v4, (uint64_t)(a2 + 5));
  char v9 = (void **)a2 + 3;
  long long v10 = *(long long *)((char *)a2 + 216);
  *((unsigned char *)a1 + 232) = *((unsigned char *)a2 + 232);
  *(long long *)((char *)a1 + 216) = v10;
  *a2 = v11;
  *((void *)a2 + 2) = v12;
  if (*((char *)a2 + 47) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)char v9 = *(_OWORD *)__p;
  *((void *)a2 + 5) = v14;
  a2[3] = *(_OWORD *)v15;
  *(long long *)((char *)a2 + 60) = *(_OWORD *)&v15[12];
  sub_100267D64((uint64_t)(a2 + 5), (uint64_t)v16);
  *(long long *)((char *)a2 + 216) = v17;
  *((unsigned char *)a2 + 232) = v18;
  sub_10026633C(v16);
}

void sub_10028B2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028B308(uint64_t a1)
{
  unsigned int v2 = sub_10020ED78(a1);
  if (sub_10028B500() > v2) {
    return 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2818);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    long long v8 = "MicroLocationConfiguration";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2818);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationConfigurationTable]", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t result = sub_100207944(a1);
  if (result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0) {
      uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_10003CC68(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_10028B500()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsConfigurationTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 6666;
  }
}

void sub_10028B594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028B5B0(void ***a1)
{
  int v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        sub_10028B648((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10028B648(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 87) < 0) {
    operator delete(*(void **)(a2 + 64));
  }
  if (*(char *)(a2 + 55) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 32);
    operator delete(v3);
  }
}

void sub_10028B6A0(void ***a1)
{
  int v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        sub_10028B738((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10028B738(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_10028B790(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
void sub_10028CF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10028D000(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  sub_10028D7B4(a1, a2, a3, a4);
  unint64_t v10 = bswap64(*a5);
  unint64_t v11 = bswap64(*a4);
  if (v10 != v11 || (unint64_t v10 = bswap64(a5[1]), v11 = bswap64(a4[1]), v10 != v11))
  {
    int v12 = v10 < v11 ? -1 : 1;
    if (v12 < 0)
    {
      sub_10028B0FC((long long *)a4, (long long *)a5);
      unint64_t v13 = bswap64(*a4);
      unint64_t v14 = bswap64(*a3);
      if (v13 != v14 || (unint64_t v13 = bswap64(a4[1]), v14 = bswap64(a3[1]), v13 != v14))
      {
        int v15 = v13 < v14 ? -1 : 1;
        if (v15 < 0)
        {
          sub_10028B0FC((long long *)a3, (long long *)a4);
          unint64_t v16 = bswap64(*a3);
          unint64_t v17 = bswap64(*a2);
          if (v16 != v17 || (unint64_t v16 = bswap64(a3[1]), v17 = bswap64(a2[1]), v16 != v17))
          {
            int v18 = v16 < v17 ? -1 : 1;
            if (v18 < 0)
            {
              sub_10028B0FC((long long *)a2, (long long *)a3);
              unint64_t v19 = bswap64(*a2);
              unint64_t v20 = bswap64(*a1);
              if (v19 == v20 && (unint64_t v19 = bswap64(a2[1]), v20 = bswap64(a1[1]), v19 == v20))
              {
                int v21 = 0;
              }
              else if (v19 < v20)
              {
                int v21 = -1;
              }
              else
              {
                int v21 = 1;
              }
              if (v21 < 0)
              {
                sub_10028B0FC((long long *)a1, (long long *)a2);
              }
            }
          }
        }
      }
    }
  }
}

void sub_10028D1C0(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  char v5 = a1;
  unint64_t v6 = bswap64(*a2);
  unint64_t v7 = bswap64(*a1);
  if (v6 == v7 && (unint64_t v6 = bswap64(a2[1]), v7 = bswap64(a1[1]), v6 == v7))
  {
    int v8 = 0;
  }
  else if (v6 < v7)
  {
    int v8 = -1;
  }
  else
  {
    int v8 = 1;
  }
  unint64_t v9 = bswap64(*a3);
  unint64_t v10 = bswap64(*a2);
  if (v9 != v10 || (unint64_t v9 = bswap64(a3[1]), v10 = bswap64(a2[1]), v9 != v10))
  {
    if (v9 < v10) {
      int v11 = -1;
    }
    else {
      int v11 = 1;
    }
    if (v8 < 0) {
      goto LABEL_10;
    }
LABEL_18:
    if (v11 < 0)
    {
      sub_10028B0FC((long long *)a2, (long long *)a3);
      unint64_t v14 = bswap64(*a2);
      unint64_t v15 = bswap64(*v5);
      if (v14 != v15 || (unint64_t v14 = bswap64(a2[1]), v15 = bswap64(v5[1]), v14 != v15))
      {
        int v18 = v14 < v15 ? -1 : 1;
        if (v18 < 0)
        {
          a1 = v5;
          unint64_t v17 = (long long *)a2;
          goto LABEL_34;
        }
      }
    }
    return;
  }
  int v11 = 0;
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_18;
  }
LABEL_10:
  if (v11 < 0)
  {
LABEL_27:
    unint64_t v17 = (long long *)a3;
LABEL_34:
    sub_10028B0FC((long long *)a1, v17);
    return;
  }
  sub_10028B0FC((long long *)a1, (long long *)a2);
  unint64_t v12 = bswap64(*a3);
  unint64_t v13 = bswap64(*a2);
  if (v12 != v13 || (unint64_t v12 = bswap64(a3[1]), v13 = bswap64(a2[1]), v12 != v13))
  {
    int v16 = v12 < v13 ? -1 : 1;
    if (v16 < 0)
    {
      a1 = a2;
      goto LABEL_27;
    }
  }
}

BOOL sub_10028D368(unint64_t *a1, unint64_t *a2)
{
  unsigned int v2 = a2;
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(0xEEEEEEEEEEEEEEEFLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 30));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (unint64_t v6 = bswap64(*(a2 - 29)), v7 = bswap64(a1[1]), v6 != v7))
      {
        int v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_10028B0FC((long long *)a1, (long long *)a2 - 15);
          return 1;
        }
      }
      return result;
    case 3uLL:
      sub_10028D1C0(a1, a1 + 30, a2 - 30);
      return 1;
    case 4uLL:
      sub_10028D7B4(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1;
    case 5uLL:
      sub_10028D000(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1;
    default:
      int v8 = a1 + 60;
      sub_10028D1C0(a1, a1 + 30, a1 + 60);
      unint64_t v9 = a1 + 90;
      if (a1 + 90 == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      p_p = &__p;
      unint64_t v13 = &v37;
      unint64_t v32 = v2;
      break;
  }
  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (unint64_t v14 = bswap64(v9[1]), v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        long long v33 = *(_OWORD *)v9;
        unint64_t v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        unint64_t v17 = p_p;
        p_p[2] = (void *)v9[5];
        void v9[3] = 0;
        void v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)unint64_t v13 = *((_OWORD *)v9 + 3);
        int v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1002660C8(v38);
        long long v39 = *(_OWORD *)(v9 + 27);
        char v40 = *((unsigned char *)v9 + 232);
        uint64_t v19 = v10;
        while (1)
        {
          unint64_t v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((void *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          int v21 = (void **)((char *)a1 + v19 + 744);
          if (*((char *)a1 + v19 + 767) < 0) {
            operator delete(*v21);
          }
          *(unint64_t *)((char *)a1 + v19 + 760) = *((void *)v20 + 65);
          *(_OWORD *)int v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_100267D64((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          unint64_t v22 = (char *)a1 + v19;
          uint64_t v23 = (uint64_t)a1 + v19 + 696;
          *((unsigned char *)a1 + v19 + 952) = *((unsigned char *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480) {
            break;
          }
          unint64_t v24 = bswap64(v33);
          unint64_t v25 = bswap64(*((void *)v22 + 30));
          if (v24 == v25
            && (unint64_t v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((void *)v22 + 31)), v24 == v25))
          {
            int v26 = 0;
          }
          else if (v24 < v25)
          {
            int v26 = -1;
          }
          else
          {
            int v26 = 1;
          }
          v19 -= 240;
          if ((v26 & 0x80000000) == 0)
          {
            uint64_t v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }
        uint64_t v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v27 = v33;
        *(void *)(v27 + 16) = v34;
        uint64_t v28 = v22 + 504;
        if (*(char *)(v27 + 47) < 0) {
          operator delete(*(void **)v28);
        }
        int v29 = v22 + 528;
        uint64_t v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)uint64_t v28 = *(_OWORD *)v17;
        *((void *)v28 + 2) = v17[2];
        char v36 = 0;
        LOBYTE(__p) = 0;
        unint64_t v13 = v18;
        *int v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_100267D64(v30, (uint64_t)v38);
        *(_OWORD *)uint64_t v23 = v39;
        *(unsigned char *)(v23 + 16) = v40;
        sub_10026633C(v38);
        unsigned int v2 = v32;
        if (v36 < 0) {
          operator delete(__p);
        }
        if (++v11 == 8) {
          return v9 + 30 == v32;
        }
      }
    }
    int v8 = v9;
    v10 += 240;
    v9 += 30;
    if (v9 == v2) {
      return 1;
    }
  }
}

void sub_10028D76C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_10028D7B4(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  sub_10028D1C0(a1, a2, a3);
  unint64_t v8 = bswap64(*a4);
  unint64_t v9 = bswap64(*a3);
  if (v8 != v9 || (unint64_t v8 = bswap64(a4[1]), v9 = bswap64(a3[1]), v8 != v9))
  {
    int v10 = v8 < v9 ? -1 : 1;
    if (v10 < 0)
    {
      sub_10028B0FC((long long *)a3, (long long *)a4);
      unint64_t v11 = bswap64(*a3);
      unint64_t v12 = bswap64(*a2);
      if (v11 != v12 || (v11 = bswap64(a3[1]), unint64_t v12 = bswap64(a2[1]), v11 != v12))
      {
        int v13 = v11 < v12 ? -1 : 1;
        if (v13 < 0)
        {
          sub_10028B0FC((long long *)a2, (long long *)a3);
          unint64_t v14 = bswap64(*a2);
          unint64_t v15 = bswap64(*a1);
          if (v14 != v15 || (unint64_t v14 = bswap64(a2[1]), v15 = bswap64(a1[1]), v14 != v15))
          {
            int v16 = v14 < v15 ? -1 : 1;
            if (v16 < 0)
            {
              sub_10028B0FC((long long *)a1, (long long *)a2);
            }
          }
        }
      }
    }
  }
}

uint64_t sub_10028D90C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10028D984((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10028D984(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      *(void *)(a3 - 48) = 0;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 56) = 0;
      long long v10 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(v8 - 8) = *(void *)(a3 - 8);
      v8 -= 56;
      v7 -= 56;
      a3 -= 56;
    }
    while (a3 != a5);
    *((void *)&v16 + 1) = v8;
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_10028DA4C((uint64_t)v13);
  return v11;
}

uint64_t sub_10028DA4C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10028DA84((uint64_t *)a1);
  }
  return a1;
}

void sub_10028DA84(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10028B738(v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **sub_10028DAD8(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10028DB0C(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 56;
    sub_10028B738(v4, i - 56);
  }
}

long long *sub_10028DB54(uint64_t *a1, long long *a2, long long *a3, long long *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (void)a2) >> 4)) >= a5)
      {
        int v21 = &a3[15 * a5];
      }
      else
      {
        int v21 = &a3[(uint64_t)(v12 - (void)a2) >> 4];
        a1[1] = sub_10028DEA8(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }
      sub_10028DD48((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_1001EFED0((uint64_t)v26, v7, v21, (uint64_t)v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111) {
        sub_1001D7FD4();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x88888888888888) {
        unint64_t v18 = 0x111111111111111;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v29 = v9;
      if (v18) {
        uint64_t v19 = (char *)sub_1001F2B9C(v9, v18);
      }
      else {
        uint64_t v19 = 0;
      }
      unint64_t v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      uint64_t v27 = v22;
      uint64_t v28 = &v19[240 * v18];
      uint64_t v23 = 240 * a5;
      unint64_t v24 = &v22[240 * a5];
      do
      {
        sub_10028DF54(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240;
      }
      while (v23);
      uint64_t v27 = v24;
      uint64_t v5 = (long long *)sub_10028DDF4((uint64_t)a1, v26, v5);
      sub_1001F2D3C(v26);
    }
  }
  return v5;
}

void sub_10028DD1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028DD48(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    uint64_t v10 = (long long *)(a2 + v6 - a4);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      sub_10028DF54(a1 + 16, v8, v10);
      v10 += 15;
      v8 += 240;
    }
    while ((unint64_t)v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return sub_10028DFF4((uint64_t)&v12, a2, v7, v6);
}

void sub_10028DDEC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10028DDF4(uint64_t a1, void *a2, long long *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a1 + 16;
  sub_1001F2BE4(a1 + 16, (uint64_t)a3, a3, *(void *)a1, *(long long **)a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_10028E0CC(v7, a3, *(long long **)(a1 + 8), a2[2]);
  uint64_t v9 = *(void *)a1;
  *(void *)a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[2];
  a2[2] = v10;
  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_10028DEA8(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10028DF54(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_10023AD48((uint64_t)v9);
  return v4;
}

void sub_10028DF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 sub_10028DF54(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  long long v6 = *(long long *)((char *)a3 + 24);
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *(_OWORD *)(a2 + 24) = v6;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  *((void *)a3 + 3) = 0;
  long long v7 = a3[3];
  *(_OWORD *)(a2 + 60) = *(long long *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v7;
  sub_1002660C8(a2 + 80);
  __n128 result = *(__n128 *)((char *)a3 + 216);
  *(unsigned char *)(a2 + 232) = *((unsigned char *)a3 + 232);
  *(__n128 *)(a2 + 216) = result;
  return result;
}

void sub_10028DFD8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028DFF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      long long v10 = *(_OWORD *)(a3 + v7 - 240);
      *(void *)(v9 - 224) = *(void *)(a3 + v7 - 224);
      *(_OWORD *)(v9 - 240) = v10;
      uint64_t v11 = (void **)(a4 + v7 - 216);
      if (*(char *)(a4 + v7 - 193) < 0) {
        operator delete(*v11);
      }
      long long v12 = *(_OWORD *)(v8 - 216);
      *(void *)(a4 + v7 - 200) = *(void *)(v8 - 200);
      *(_OWORD *)uint64_t v11 = v12;
      *(unsigned char *)(v8 - 193) = 0;
      *(unsigned char *)(v8 - 216) = 0;
      long long v13 = *(_OWORD *)(v8 - 192);
      *(_OWORD *)(v9 - 180) = *(_OWORD *)(v8 - 180);
      *(_OWORD *)(v9 - 192) = v13;
      sub_100267D64(v9 - 160, v8 - 160);
      long long v14 = *(_OWORD *)(v8 - 24);
      *(unsigned char *)(v9 - 8) = *(unsigned char *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v7 -= 240;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t sub_10028E0CC(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    long long v6 = a2;
    do
    {
      sub_1001F2A70(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_10023AD48((uint64_t)v9);
  return v4;
}

void sub_10028E164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028E178(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        sub_10021D65C((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10028E210(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80;
        sub_10021D65C((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_10028E280(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x249249249249249) {
    sub_1001D7FD4();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v6) {
    unint64_t v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 4)) >= 0x124924924924924) {
    unint64_t v10 = 0x249249249249249;
  }
  else {
    unint64_t v10 = v6;
  }
  unint64_t v18 = a1 + 2;
  if (v10) {
    uint64_t v11 = (char *)sub_100227C5C((uint64_t)(a1 + 2), v10);
  }
  else {
    uint64_t v11 = 0;
  }
  long long v14 = v11;
  unint64_t v15 = &v11[112 * v5];
  uint64_t v17 = &v11[112 * v10];
  sub_10028E3C0((uint64_t)(a1 + 2), (uint64_t)v15, a2, a3, a4);
  unint64_t v16 = v15 + 112;
  sub_100227BE4(a1, &v14);
  uint64_t v12 = a1[1];
  sub_100227EEC(&v14);
  return v12;
}

void sub_10028E3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100227EEC((void **)va);
  _Unwind_Resume(a1);
}

void sub_10028E3C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1000DC48C(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  sub_1002245D8(a2, (long long *)__p, a4, *a5, a5[1]);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10028E444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028E460(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
void sub_10028FBE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10028FCD0(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(0xEEEEEEEEEEEEEEEFLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 30));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (unint64_t v6 = bswap64(*(a2 - 29)), v7 = bswap64(a1[1]), v6 != v7))
      {
        int v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_10028B0FC((long long *)a1, (long long *)a2 - 15);
          return 1;
        }
      }
      return result;
    case 3uLL:
      sub_10028D1C0(a1, a1 + 30, a2 - 30);
      return 1;
    case 4uLL:
      sub_10028D7B4(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1;
    case 5uLL:
      sub_10028D000(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1;
    default:
      uint64_t v8 = a1 + 60;
      sub_10028D1C0(a1, a1 + 30, a1 + 60);
      uint64_t v9 = a1 + 90;
      if (a1 + 90 == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      p_p = &__p;
      unint64_t v13 = &v37;
      unint64_t v32 = v2;
      break;
  }
  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (unint64_t v14 = bswap64(v9[1]), v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        long long v33 = *(_OWORD *)v9;
        unint64_t v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        long long v17 = p_p;
        p_p[2] = (void *)v9[5];
        void v9[3] = 0;
        void v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)unint64_t v13 = *((_OWORD *)v9 + 3);
        unint64_t v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1002660C8(v38);
        long long v39 = *(_OWORD *)(v9 + 27);
        char v40 = *((unsigned char *)v9 + 232);
        uint64_t v19 = v10;
        while (1)
        {
          long long v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((void *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          unint64_t v21 = (void **)((char *)a1 + v19 + 744);
          if (*((char *)a1 + v19 + 767) < 0) {
            operator delete(*v21);
          }
          *(unint64_t *)((char *)a1 + v19 + 760) = *((void *)v20 + 65);
          *(_OWORD *)unint64_t v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_100267D64((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          unint64_t v22 = (char *)a1 + v19;
          uint64_t v23 = (uint64_t)a1 + v19 + 696;
          *((unsigned char *)a1 + v19 + 952) = *((unsigned char *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480) {
            break;
          }
          unint64_t v24 = bswap64(v33);
          unint64_t v25 = bswap64(*((void *)v22 + 30));
          if (v24 == v25
            && (unint64_t v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((void *)v22 + 31)), v24 == v25))
          {
            int v26 = 0;
          }
          else if (v24 < v25)
          {
            int v26 = -1;
          }
          else
          {
            int v26 = 1;
          }
          v19 -= 240;
          if ((v26 & 0x80000000) == 0)
          {
            uint64_t v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }
        uint64_t v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v27 = v33;
        *(void *)(v27 + 16) = v34;
        uint64_t v28 = v22 + 504;
        if (*(char *)(v27 + 47) < 0) {
          operator delete(*(void **)v28);
        }
        uint64_t v29 = v22 + 528;
        uint64_t v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)uint64_t v28 = *(_OWORD *)v17;
        *((void *)v28 + 2) = v17[2];
        char v36 = 0;
        LOBYTE(__p) = 0;
        unint64_t v13 = v18;
        *uint64_t v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_100267D64(v30, (uint64_t)v38);
        *(_OWORD *)uint64_t v23 = v39;
        *(unsigned char *)(v23 + 16) = v40;
        sub_10026633C(v38);
        uint64_t v2 = v32;
        if (v36 < 0) {
          operator delete(__p);
        }
        if (++v11 == 8) {
          return v9 + 30 == v32;
        }
      }
    }
    uint64_t v8 = v9;
    v10 += 240;
    v9 += 30;
    if (v9 == v2) {
      return 1;
    }
  }
}

void sub_1002900D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void *sub_10029011C(void *a1, _OWORD *a2)
{
  sub_100290174((uint64_t)a1, a2, (uint64_t)&v4);
  return sub_1001EEBB0(a1, v4);
}

void sub_100290158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_100290174@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 16;
  BOOL result = operator new(0x30uLL);
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *(void *)BOOL result = 0;
  long long v9 = a2[1];
  result[1] = *a2;
  result[2] = v9;
  *(unsigned char *)(a3 + 16) = 1;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)result + v7++ + 16);
  while (v7 != 16);
  *((void *)result + 1) = v8;
  return result;
}

char *sub_100290200(uint64_t a1, char *__src, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = __src;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v9 = a1 + 16;
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      unint64_t v19 = a5 + 1;
      long long v20 = a3;
      do
      {
        long long v20 = (void *)*v20;
        --v19;
      }
      while (v19 > 1);
      uint64_t v21 = (uint64_t)(v12 - (void)__src) >> 4;
      if (v21 >= a5)
      {
        uint64_t v23 = *(char **)(v9 - 8);
        uint64_t v21 = a5;
      }
      else
      {
        if ((uint64_t)(v12 - (void)__src) < 1)
        {
          long long v20 = a3;
        }
        else
        {
          unint64_t v22 = v21 + 1;
          long long v20 = a3;
          do
          {
            long long v20 = (void *)*v20;
            --v22;
          }
          while (v22 > 1);
        }
        uint64_t v23 = *(char **)(v9 - 8);
        if (v20 != a4)
        {
          uint64_t v27 = v20;
          uint64_t v28 = *(_OWORD **)(v9 - 8);
          do
          {
            *v28++ = *((_OWORD *)v27 + 1);
            uint64_t v27 = (void *)*v27;
            v23 += 16;
          }
          while (v27 != a4);
        }
        *(void *)(a1 + 8) = v23;
      }
      if (v21 >= 1)
      {
        uint64_t v29 = &__src[16 * a5];
        uint64_t v30 = &v23[-16 * a5];
        int v31 = v23;
        if ((unint64_t)v30 < v12)
        {
          int v31 = v23;
          do
          {
            long long v32 = *(_OWORD *)v30;
            v30 += 16;
            *(_OWORD *)int v31 = v32;
            v31 += 16;
          }
          while ((unint64_t)v30 < v12);
        }
        *(void *)(a1 + 8) = v31;
        if (v23 != v29) {
          memmove(&v23[-16 * ((v23 - v29) >> 4)], __src, v23 - v29);
        }
        if (v20 != v7)
        {
          long long v33 = v5;
          do
          {
            *(_OWORD *)long long v33 = *((_OWORD *)v7 + 1);
            v33 += 16;
            uint64_t v7 = (void *)*v7;
          }
          while (v7 != v20);
        }
      }
    }
    else
    {
      unint64_t v13 = *(unsigned char **)a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
      if (v14 >> 60) {
        sub_1001D7FD4();
      }
      uint64_t v15 = (__src - v13) >> 4;
      uint64_t v16 = v10 - (void)v13;
      if (v16 >> 3 > v14) {
        unint64_t v14 = v16 >> 3;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v39 = v9;
      if (v17) {
        unint64_t v18 = (char *)sub_1000C571C(v9, v17);
      }
      else {
        unint64_t v18 = 0;
      }
      unint64_t v24 = &v18[16 * v15];
      long long __p = v18;
      char v36 = v24;
      unint64_t v38 = &v18[16 * v17];
      uint64_t v25 = 16 * a5;
      int v26 = &v24[16 * a5];
      do
      {
        *(_OWORD *)unint64_t v24 = *((_OWORD *)v7 + 1);
        v24 += 16;
        uint64_t v7 = (void *)*v7;
        v25 -= 16;
      }
      while (v25);
      uint64_t v37 = v26;
      uint64_t v5 = (char *)sub_10027E248((void **)a1, (uint64_t)&__p, v5);
      if (v37 != v36) {
        v37 += (v36 - v37 + 15) & 0xFFFFFFFFFFFFFFF0;
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v5;
}

void sub_10029042C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100290464(void *a1, void *a2)
{
  BOOL result = sub_1001EFDE4(a1, a2);
  if (result)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

void sub_1002904B4(unint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(v10 + 24) < a2[-1].n128_f64[1])
                {
                  __n128 v107 = *(__n128 *)v10;
                  __n128 v116 = *(__n128 *)(v10 + 16);
                  __n128 v44 = a2[-1];
                  *(__n128 *)unint64_t v10 = a2[-2];
                  *(__n128 *)(v10 + 16) = v44;
                  a2[-2] = v107;
                  a2[-1] = v116;
                }
                break;
              case 3uLL:
                sub_100290D24((double *)v10, (double *)(v10 + 32), a2[-2].n128_f64);
                break;
              case 4uLL:
                sub_100291078((__n128 *)v10, (__n128 *)(v10 + 32), (__n128 *)(v10 + 64), a2 - 2);
                break;
              case 5uLL:
                __int16 v45 = (__n128 *)(v10 + 32);
                unint64_t v46 = (__n128 *)(v10 + 64);
                unint64_t v47 = (__n128 *)(v10 + 96);
                sub_100291078((__n128 *)v10, (__n128 *)(v10 + 32), (__n128 *)(v10 + 64), (__n128 *)(v10 + 96));
                if (*(double *)(v10 + 120) < a2[-1].n128_f64[1])
                {
                  __n128 v48 = *v47;
                  __n128 v117 = *(__n128 *)(v10 + 112);
                  __n128 v49 = a2[-1];
                  *unint64_t v47 = a2[-2];
                  *(__n128 *)(v10 + 112) = v49;
                  a2[-2] = v48;
                  a2[-1] = v117;
                  if (*(double *)(v10 + 88) < *(double *)(v10 + 120))
                  {
                    __n128 v51 = *v46;
                    long long v50 = *(_OWORD *)(v10 + 80);
                    long long v52 = *(_OWORD *)(v10 + 112);
                    *unint64_t v46 = *v47;
                    *(_OWORD *)(v10 + 80) = v52;
                    *unint64_t v47 = v51;
                    *(_OWORD *)(v10 + 112) = v50;
                    if (*(double *)(v10 + 56) < *(double *)(v10 + 88))
                    {
                      __n128 v54 = *v45;
                      long long v53 = *(_OWORD *)(v10 + 48);
                      long long v55 = *(_OWORD *)(v10 + 80);
                      __n128 *v45 = *v46;
                      *(_OWORD *)(v10 + 48) = v55;
                      *unint64_t v46 = v54;
                      *(_OWORD *)(v10 + 80) = v53;
                      if (*(double *)(v10 + 24) < *(double *)(v10 + 56))
                      {
                        __n128 v108 = *(__n128 *)v10;
                        long long v118 = *(_OWORD *)(v10 + 16);
                        long long v56 = *(_OWORD *)(v10 + 48);
                        *(__n128 *)unint64_t v10 = *v45;
                        *(_OWORD *)(v10 + 16) = v56;
                        __n128 *v45 = v108;
                        *(_OWORD *)(v10 + 48) = v118;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            long long v57 = (__n128 *)(v10 + 32);
            BOOL v59 = (__n128 *)v10 == a2 || v57 == a2;
            if (a4)
            {
              if (!v59)
              {
                uint64_t v60 = 0;
                unint64_t v61 = v10;
                do
                {
                  double v62 = *(double *)(v61 + 24);
                  double v63 = *(double *)(v61 + 56);
                  unint64_t v61 = (unint64_t)v57;
                  if (v62 < v63)
                  {
                    uint64_t v119 = v57[1].n128_i64[0];
                    __n128 v109 = *v57;
                    uint64_t v64 = v60;
                    while (1)
                    {
                      uint64_t v65 = v10 + v64;
                      long long v66 = *(_OWORD *)(v10 + v64 + 16);
                      *(_OWORD *)(v65 + 32) = *(_OWORD *)(v10 + v64);
                      *(_OWORD *)(v65 + 48) = v66;
                      if (!v64) {
                        break;
                      }
                      v64 -= 32;
                      if (*(double *)(v65 - 8) >= v63)
                      {
                        uint64_t v67 = v10 + v64 + 32;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v67 = v10;
LABEL_83:
                    *(void *)(v67 + 16) = v119;
                    *(__n128 *)uint64_t v67 = v109;
                    *(double *)(v67 + 24) = v63;
                  }
                  long long v57 = (__n128 *)(v61 + 32);
                  v60 += 32;
                }
                while ((__n128 *)(v61 + 32) != a2);
              }
            }
            else if (!v59)
            {
              do
              {
                double v93 = *(double *)(a1 + 24);
                double v94 = *(double *)(a1 + 56);
                a1 = (unint64_t)v57;
                if (v93 < v94)
                {
                  uint64_t v122 = v57[1].n128_i64[0];
                  __n128 v112 = *v57;
                  long long v95 = v57;
                  do
                  {
                    __n128 v96 = v95[-1];
                    *long long v95 = v95[-2];
                    v95[1] = v96;
                    double v97 = v95[-3].n128_f64[1];
                    v95 -= 2;
                  }
                  while (v97 < v94);
                  v95[1].n128_u64[0] = v122;
                  *long long v95 = v112;
                  v95[1].n128_f64[1] = v94;
                }
                v57 += 2;
              }
              while ((__n128 *)(a1 + 32) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v10 != a2)
            {
              int64_t v68 = (v12 - 2) >> 1;
              int64_t v69 = v68;
              do
              {
                int64_t v70 = v69;
                if (v68 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  unint64_t v72 = v10 + 32 * v71;
                  if (2 * v70 + 2 < (uint64_t)v12 && *(double *)(v72 + 56) < *(double *)(v72 + 24))
                  {
                    v72 += 32;
                    uint64_t v71 = 2 * v70 + 2;
                  }
                  double v73 = *(double *)(v10 + 32 * v70 + 24);
                  if (v73 >= *(double *)(v72 + 24))
                  {
                    unint64_t v74 = v10 + 32 * v70;
                    uint64_t v120 = *(void *)(v74 + 16);
                    long long v110 = *(_OWORD *)v74;
                    do
                    {
                      char v75 = (_OWORD *)v74;
                      unint64_t v74 = v72;
                      long long v76 = *(_OWORD *)(v72 + 16);
                      *char v75 = *(_OWORD *)v72;
                      v75[1] = v76;
                      if (v68 < v71) {
                        break;
                      }
                      uint64_t v77 = 2 * v71;
                      uint64_t v71 = (2 * v71) | 1;
                      unint64_t v72 = v10 + 32 * v71;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v72 + 56) < *(double *)(v72 + 24))
                      {
                        v72 += 32;
                        uint64_t v71 = v78;
                      }
                    }
                    while (v73 >= *(double *)(v72 + 24));
                    *(void *)(v74 + 16) = v120;
                    *(_OWORD *)unint64_t v74 = v110;
                    *(double *)(v74 + 24) = v73;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              uint64_t v79 = (unint64_t)v11 >> 5;
              do
              {
                uint64_t v80 = 0;
                __n128 v111 = *(__n128 *)v10;
                __n128 v121 = *(__n128 *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = (_OWORD *)v81;
                  v81 += 32 * (v80 + 1);
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  uint64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 56) < *(double *)(v81 + 24))
                  {
                    v81 += 32;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)(v81 + 16);
                  *unint64_t v82 = *(_OWORD *)v81;
                  v82[1] = v85;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 2;
                if ((__n128 *)v81 == a2)
                {
                  *(__n128 *)unint64_t v81 = v111;
                  *(__n128 *)(v81 + 16) = v121;
                }
                else
                {
                  __n128 v86 = a2[1];
                  *(__n128 *)unint64_t v81 = *a2;
                  *(__n128 *)(v81 + 16) = v86;
                  *a2 = v111;
                  a2[1] = v121;
                  uint64_t v87 = v81 - v10 + 32;
                  if (v87 >= 33)
                  {
                    unint64_t v88 = (((unint64_t)v87 >> 5) - 2) >> 1;
                    double v89 = *(double *)(v81 + 24);
                    if (v89 < *(double *)(v10 + 32 * v88 + 24))
                    {
                      uint64_t v103 = *(void *)(v81 + 16);
                      long long v100 = *(_OWORD *)v81;
                      do
                      {
                        int v90 = (_OWORD *)v81;
                        unint64_t v81 = v10 + 32 * v88;
                        long long v91 = *(_OWORD *)(v81 + 16);
                        _OWORD *v90 = *(_OWORD *)v81;
                        v90[1] = v91;
                        if (!v88) {
                          break;
                        }
                        unint64_t v88 = (v88 - 1) >> 1;
                      }
                      while (v89 < *(double *)(v10 + 32 * v88 + 24));
                      *(void *)(v81 + 16) = v103;
                      *(_OWORD *)unint64_t v81 = v100;
                      *(double *)(v81 + 24) = v89;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 32 * (v12 >> 1);
          if ((unint64_t)v11 > 0x1000)
          {
            sub_100290D24((double *)a1, (double *)(a1 + 32 * (v12 >> 1)), a2[-2].n128_f64);
            sub_100290D24((double *)(a1 + 32), (double *)(v14 - 32), a2[-4].n128_f64);
            sub_100290D24((double *)(a1 + 64), (double *)(a1 + 32 + 32 * v13), a2[-6].n128_f64);
            sub_100290D24((double *)(v14 - 32), (double *)v14, (double *)(a1 + 32 + 32 * v13));
            long long v104 = *(_OWORD *)a1;
            long long v113 = *(_OWORD *)(a1 + 16);
            long long v15 = *(_OWORD *)(v14 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)(a1 + 16) = v15;
            *(_OWORD *)unint64_t v14 = v104;
            *(_OWORD *)(v14 + 16) = v113;
          }
          else
          {
            sub_100290D24((double *)(a1 + 32 * (v12 >> 1)), (double *)a1, a2[-2].n128_f64);
          }
          --a3;
          if (a4) {
            break;
          }
          double v16 = *(double *)(a1 + 24);
          if (v16 < *(double *)(a1 - 8)) {
            goto LABEL_12;
          }
          uint64_t v102 = *(void *)(a1 + 16);
          long long v99 = *(_OWORD *)a1;
          if (a2[-1].n128_f64[1] >= v16)
          {
            unint64_t v34 = a1 + 32;
            do
            {
              unint64_t v10 = v34;
              if (v34 >= (unint64_t)a2) {
                break;
              }
              double v35 = *(double *)(v34 + 24);
              v34 += 32;
            }
            while (v35 >= v16);
          }
          else
          {
            unint64_t v32 = a1;
            do
            {
              unint64_t v10 = v32 + 32;
              double v33 = *(double *)(v32 + 56);
              v32 += 32;
            }
            while (v33 >= v16);
          }
          char v36 = a2;
          if (v10 < (unint64_t)a2)
          {
            uint64_t v37 = a2;
            do
            {
              char v36 = v37 - 2;
              double v38 = v37[-1].n128_f64[1];
              v37 -= 2;
            }
            while (v38 < v16);
          }
          while (v10 < (unint64_t)v36)
          {
            __n128 v106 = *(__n128 *)v10;
            __n128 v115 = *(__n128 *)(v10 + 16);
            __n128 v39 = v36[1];
            *(__n128 *)unint64_t v10 = *v36;
            *(__n128 *)(v10 + 16) = v39;
            __n128 *v36 = v106;
            v36[1] = v115;
            do
            {
              double v40 = *(double *)(v10 + 56);
              v10 += 32;
            }
            while (v40 >= v16);
            do
            {
              double v41 = v36[-1].n128_f64[1];
              v36 -= 2;
            }
            while (v41 < v16);
          }
          unint64_t v42 = (_OWORD *)(v10 - 32);
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            long long v43 = *(_OWORD *)(v10 - 16);
            *(_OWORD *)a1 = *v42;
            *(_OWORD *)(a1 + 16) = v43;
          }
          a4 = 0;
          *(void *)(v10 - 16) = v102;
          *unint64_t v42 = v99;
          *(double *)(v10 - 8) = v16;
        }
        double v16 = *(double *)(a1 + 24);
LABEL_12:
        uint64_t v17 = 0;
        uint64_t v101 = *(void *)(a1 + 16);
        long long v98 = *(_OWORD *)a1;
        do
        {
          double v18 = *(double *)(a1 + v17 + 56);
          v17 += 32;
        }
        while (v16 < v18);
        unint64_t v19 = a1 + v17;
        long long v20 = a2;
        if (v17 == 32)
        {
          uint64_t v23 = a2;
          while (v19 < (unint64_t)v23)
          {
            uint64_t v21 = v23 - 2;
            double v24 = v23[-1].n128_f64[1];
            v23 -= 2;
            if (v16 < v24) {
              goto LABEL_22;
            }
          }
          uint64_t v21 = v23;
        }
        else
        {
          do
          {
            uint64_t v21 = v20 - 2;
            double v22 = v20[-1].n128_f64[1];
            v20 -= 2;
          }
          while (v16 >= v22);
        }
LABEL_22:
        unint64_t v10 = v19;
        if (v19 < (unint64_t)v21)
        {
          uint64_t v25 = v21;
          do
          {
            __n128 v105 = *(__n128 *)v10;
            __n128 v114 = *(__n128 *)(v10 + 16);
            __n128 v26 = v25[1];
            *(__n128 *)unint64_t v10 = *v25;
            *(__n128 *)(v10 + 16) = v26;
            *uint64_t v25 = v105;
            v25[1] = v114;
            do
            {
              double v27 = *(double *)(v10 + 56);
              v10 += 32;
            }
            while (v16 < v27);
            do
            {
              double v28 = v25[-1].n128_f64[1];
              v25 -= 2;
            }
            while (v16 >= v28);
          }
          while (v10 < (unint64_t)v25);
        }
        uint64_t v29 = (_OWORD *)(v10 - 32);
        if (v10 - 32 != a1)
        {
          long long v30 = *(_OWORD *)(v10 - 16);
          *(_OWORD *)a1 = *v29;
          *(_OWORD *)(a1 + 16) = v30;
        }
        *(void *)(v10 - 16) = v101;
        *uint64_t v29 = v98;
        *(double *)(v10 - 8) = v16;
        if (v19 >= (unint64_t)v21) {
          break;
        }
LABEL_33:
        sub_1002904B4(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v31 = sub_100290E04(a1, v10 - 32);
      if (sub_100290E04(v10, (uint64_t)a2)) {
        break;
      }
      if (!v31) {
        goto LABEL_33;
      }
    }
    a2 = (__n128 *)(v10 - 32);
    if (!v31) {
      continue;
    }
    break;
  }
}

double *sub_100290D24(double *result, double *a2, double *a3)
{
  double v3 = a2[3];
  double v4 = a3[3];
  if (result[3] >= v3)
  {
    if (v3 < v4)
    {
      long long v9 = *(_OWORD *)a2;
      long long v8 = *((_OWORD *)a2 + 1);
      long long v10 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v10;
      *(_OWORD *)a3 = v9;
      *((_OWORD *)a3 + 1) = v8;
      if (result[3] < a2[3])
      {
        long long v12 = *(_OWORD *)result;
        long long v11 = *((_OWORD *)result + 1);
        long long v13 = *((_OWORD *)a2 + 1);
        *(_OWORD *)BOOL result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v13;
        *(_OWORD *)a2 = v12;
        *((_OWORD *)a2 + 1) = v11;
      }
    }
  }
  else
  {
    if (v3 >= v4)
    {
      long long v15 = *(_OWORD *)result;
      long long v14 = *((_OWORD *)result + 1);
      long long v16 = *((_OWORD *)a2 + 1);
      *(_OWORD *)BOOL result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v16;
      *(_OWORD *)a2 = v15;
      *((_OWORD *)a2 + 1) = v14;
      if (a2[3] >= a3[3]) {
        return result;
      }
      long long v6 = *(_OWORD *)a2;
      long long v5 = *((_OWORD *)a2 + 1);
      long long v17 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v17;
    }
    else
    {
      long long v6 = *(_OWORD *)result;
      long long v5 = *((_OWORD *)result + 1);
      long long v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)BOOL result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v7;
    }
    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v5;
  }
  return result;
}

BOOL sub_100290E04(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(double *)(a1 + 24) < *(double *)(a2 - 8))
      {
        __n128 v7 = *(__n128 *)a1;
        long long v6 = *(_OWORD *)(a1 + 16);
        long long v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(__n128 *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      sub_100290D24((double *)a1, (double *)(a1 + 32), (double *)(a2 - 32));
      return 1;
    case 4:
      sub_100291078((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1;
    case 5:
      double v18 = (__n128 *)(a1 + 32);
      unint64_t v19 = (__n128 *)(a1 + 64);
      long long v20 = (__n128 *)(a1 + 96);
      sub_100291078((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96));
      if (*(double *)(a1 + 120) < *(double *)(a2 - 8))
      {
        __n128 v22 = *v20;
        long long v21 = *(_OWORD *)(a1 + 112);
        long long v23 = *(_OWORD *)(a2 - 16);
        __n128 *v20 = *(__n128 *)(a2 - 32);
        *(_OWORD *)(a1 + 112) = v23;
        *(__n128 *)(a2 - 32) = v22;
        *(_OWORD *)(a2 - 16) = v21;
        if (*(double *)(a1 + 88) < *(double *)(a1 + 120))
        {
          __n128 v25 = *v19;
          long long v24 = *(_OWORD *)(a1 + 80);
          long long v26 = *(_OWORD *)(a1 + 112);
          __n128 *v19 = *v20;
          *(_OWORD *)(a1 + 80) = v26;
          __n128 *v20 = v25;
          *(_OWORD *)(a1 + 112) = v24;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 88))
          {
            __n128 v28 = *v18;
            long long v27 = *(_OWORD *)(a1 + 48);
            long long v29 = *(_OWORD *)(a1 + 80);
            __n128 *v18 = *v19;
            *(_OWORD *)(a1 + 48) = v29;
            __n128 *v19 = v28;
            *(_OWORD *)(a1 + 80) = v27;
            if (*(double *)(a1 + 24) < *(double *)(a1 + 56))
            {
              __n128 v31 = *(__n128 *)a1;
              long long v30 = *(_OWORD *)(a1 + 16);
              long long v32 = *(_OWORD *)(a1 + 48);
              *(__n128 *)a1 = *v18;
              *(_OWORD *)(a1 + 16) = v32;
              __n128 *v18 = v31;
              *(_OWORD *)(a1 + 48) = v30;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 64;
      sub_100290D24((double *)a1, (double *)(a1 + 32), (double *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 24);
    if (*(double *)(v9 + 24) < v13)
    {
      long long v33 = *(_OWORD *)v10;
      uint64_t v34 = *(void *)(v10 + 16);
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        long long v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64) {
          break;
        }
        v14 -= 32;
        if (*(double *)(v15 + 56) >= v13)
        {
          uint64_t v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v33;
      *(void *)(v17 + 16) = v34;
      *(double *)(v17 + 24) = v13;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2) {
      return 1;
    }
  }
}

__n128 sub_100291078(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  sub_100290D24(a1->n128_f64, a2->n128_f64, a3->n128_f64);
  result.n128_u64[0] = a3[1].n128_u64[1];
  if (result.n128_f64[0] < a4[1].n128_f64[1])
  {
    __n128 v9 = *a3;
    __n128 result = a3[1];
    __n128 v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u64[0] = a2[1].n128_u64[1];
    if (result.n128_f64[0] < a3[1].n128_f64[1])
    {
      __n128 v11 = *a2;
      __n128 result = a2[1];
      __n128 v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u64[0] = a1[1].n128_u64[1];
      if (result.n128_f64[0] < a2[1].n128_f64[1])
      {
        __n128 v13 = *a1;
        __n128 result = a1[1];
        __n128 v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }
  return result;
}

void ***sub_100291144(void ***a1, long long *a2)
{
  uint64_t v4 = *a1;
  long long v5 = (char *)(*a1)[1];
  long long v6 = *a1;
  __n128 v9 = (char *)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  long long v8 = v9;
  if (v5 >= v9)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*v4) >> 2);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      sub_1001D7FD4();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (unsigned char *)*v4) >> 2);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x666666666666666) {
      unint64_t v15 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      long long v16 = (char *)sub_10027E440(v7, v15);
    }
    else {
      long long v16 = 0;
    }
    uint64_t v17 = &v16[20 * v12];
    double v18 = &v16[20 * v15];
    long long v19 = *a2;
    *((_DWORD *)v17 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v17 = v19;
    __n128 v11 = v17 + 20;
    long long v21 = (char *)*v4;
    long long v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        long long v22 = *(_OWORD *)(v20 - 20);
        *((_DWORD *)v17 - 1) = *((_DWORD *)v20 - 1);
        *(_OWORD *)(v17 - 20) = v22;
        v17 -= 20;
        v20 -= 20;
      }
      while (v20 != v21);
      long long v20 = (char *)*v4;
    }
    *uint64_t v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v10 = *a2;
    *((_DWORD *)v5 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)long long v5 = v10;
    __n128 v11 = v5 + 20;
  }
  v4[1] = v11;
  return a1;
}

void *sub_100291278(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
    long long v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      __n128 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3) {
              break;
            }
          }
          __n128 v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  __n128 v11 = operator new(0x28uLL);
  void *v11 = 0;
  v11[1] = v7;
  *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
  *((_DWORD *)v11 + 8) = *(_DWORD *)(a3 + 16);
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_100100330(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
      else {
        unint64_t v3 = v7;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  long long v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    void *v11 = *v21;
LABEL_44:
    void *v21 = v11;
    goto LABEL_45;
  }
  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    long long v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1002914C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

long long *sub_1002914D4(uint64_t *a1, long long *a2, long long *a3, long long *a4, uint64_t a5)
{
  long long v5 = a2;
  if (a5 >= 1)
  {
    unint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (void)a2) >> 4)) >= a5)
      {
        long long v21 = &a3[15 * a5];
      }
      else
      {
        long long v21 = &a3[(uint64_t)(v12 - (void)a2) >> 4];
        a1[1] = sub_1002916C8(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }
      sub_10028DD48((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_100291774((uint64_t)v26, v7, v21, (uint64_t)v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111) {
        sub_1001D7FD4();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x88888888888888) {
        unint64_t v18 = 0x111111111111111;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v29 = v9;
      if (v18) {
        size_t v19 = (char *)sub_1001F2B9C(v9, v18);
      }
      else {
        size_t v19 = 0;
      }
      unint64_t v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      long long v27 = v22;
      __n128 v28 = &v19[240 * v18];
      uint64_t v23 = 240 * a5;
      long long v24 = &v22[240 * a5];
      do
      {
        sub_1001F2A70(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240;
      }
      while (v23);
      long long v27 = v24;
      long long v5 = (long long *)sub_10028DDF4((uint64_t)a1, v26, v5);
      sub_1001F2D3C(v26);
    }
  }
  return v5;
}

void sub_10029169C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002916C8(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_1001F2A70(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_10023AD48((uint64_t)v9);
  return v4;
}

void sub_100291760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

long long *sub_100291774(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  long long v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    long long v7 = *v5;
    *(void *)(a4 + 16) = *((void *)v5 + 2);
    *(_OWORD *)a4 = v7;
    std::string::operator=((std::string *)(a4 + 24), (const std::string *)v5 + 1);
    long long v8 = *(long long *)((char *)v5 + 60);
    *(_OWORD *)(a4 + 48) = v5[3];
    *(_OWORD *)(a4 + 60) = v8;
    sub_100267D64(a4 + 80, (uint64_t)(v5 + 5));
    long long v9 = *(long long *)((char *)v5 + 216);
    *(unsigned char *)(a4 + 232) = *((unsigned char *)v5 + 232);
    *(_OWORD *)(a4 + 216) = v9;
    a4 += 240;
    v5 += 15;
  }
  while (v5 != v6);
  return v6;
}

void sub_100291818()
{
}

void *sub_10029182C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_1022A2B90;
  return result;
}

void sub_100291864(uint64_t a1, void *a2)
{
  *a2 = off_1022A2B90;
}

uint64_t sub_10029188C()
{
  return 0;
}

uint64_t sub_100291894(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002918D4()
{
}

void *sub_1002918E0(void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

uint64_t sub_1002918E8(uint64_t *a1)
{
  sub_100291AF4((uint64_t)a1, (uint64_t)__p);
  if (v14)
  {
    uint64_t v2 = __p;
    if (v13 < 0) {
      uint64_t v2 = (void **)__p[0];
    }
    unsigned int v3 = [+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v2] isDirectory:0];
  }
  else
  {
    unsigned int v3 = 0;
  }
  int v4 = sub_10020E920(*a1);
  int v5 = sub_10020E638(*a1);
  int v6 = sub_100291BF4(*a1);
  int v7 = v6;
  if (v4) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = v3;
  }
  if (v5) {
    unsigned int v8 = 0;
  }
  if (v6) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v8;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C00);
  }
  char v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68290306;
    int v16 = 0;
    __int16 v17 = 2082;
    unint64_t v18 = "";
    __int16 v19 = 1026;
    int v20 = v9;
    __int16 v21 = 1026;
    int v22 = v4;
    __int16 v23 = 1026;
    int v24 = v5;
    __int16 v25 = 1026;
    int v26 = v7;
    __int16 v27 = 1026;
    unsigned int v28 = v3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Checking if should migrate from backup\", \"result\":%{public}hhd, \"numMainDBRecordingEvents\":%{public}d, \"numMainDBMeasurements\":%{public}d, \"numMainDBServices\":%{public}d, \"restoreDbExists\":%{public}hhd}", buf, 0x30u);
  }
  if (v14 && v13 < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

void sub_100291ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100291AF4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_1002930FC(a1, (uint64_t)__p);
  if (v8)
  {
    if (v7 >= 0) {
      unsigned int v3 = __p;
    }
    else {
      unsigned int v3 = (void **)__p[0];
    }
    sub_100134750(&v4, (char *)[[+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%s", v3) stringByAppendingPathComponent:+[NSString stringWithUTF8String:"milo_restore.db"]] UTF8String]);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    *(unsigned char *)(a2 + 24) = 1;
    if (v8)
    {
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
}

void sub_100291BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100291BF4(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    return sub_1001FA654(a1, "MiLoServices");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    unsigned int v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C00);
      }
      long long v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoServiceTable]", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    return 0;
  }
}

uint64_t sub_100291DDC(uint64_t a1, uint64_t a2)
{
  double v4 = sub_10016C458();
  sub_100291AF4(a1, (uint64_t)__p);
  if (!v30) {
    goto LABEL_17;
  }
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (!v5)
  {
LABEL_17:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    unint64_t v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get paths for exporting iCloud Restore db", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_43;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_64;
    }
    goto LABEL_75;
  }
  int v6 = __p;
  if (v29 < 0) {
    int v6 = (void **)__p[0];
  }
  if (![+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v6] isDirectory:0])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    int v16 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      if (!v30) {
        sub_10020D700();
      }
      __int16 v17 = __p;
      if (v29 < 0) {
        __int16 v17 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 136380675;
      *(void *)uint64_t v34 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "iCloud restore db file does not exist at %{private}s", buf, 0xCu);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_43;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    if (!v30) {
      sub_10020D700();
    }
    unint64_t v18 = __p;
    if (v29 < 0) {
      unint64_t v18 = (void **)__p[0];
    }
    int v31 = 136380675;
    long long v32 = v18;
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v19);
    goto LABEL_65;
  }
  if (!+[CLMicroLocationKeychain retrieveSymmetricKey:@"com.apple.milo.security.database.backup"])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    int v20 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get key for backup decryption", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_43;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_64;
    }
LABEL_75:
    dispatch_once(&qword_102419450, &stru_1022A2C00);
LABEL_64:
    LOWORD(v31) = 0;
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v19);
LABEL_65:
    if (v19 != (char *)buf) {
      free(v19);
    }
LABEL_43:
    uint64_t v14 = 0;
    goto LABEL_44;
  }
  char v7 = [[CLOSTransaction alloc] initWithDescription:"com.apple.locationd.microlocation.migrate-cloud-backup"];
  if (!v30) {
    sub_10020D700();
  }
  char v8 = v7;
  if (v29 >= 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  char v10 = sub_1004BC384((const char *)v9);
  if (!v30) {
    sub_10020D700();
  }
  uint64_t v11 = v10;
  id v12 = sub_100292618((uint64_t)v10, (uint64_t *)__p, (uint64_t *)a2, @"com.apple.milo.security.database.backup");
  if (!v12)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    int v22 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to decrypt backup file", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C00);
      }
      LOWORD(v31) = 0;
      LODWORD(v27) = 2;
      int v26 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v26);
      if (v26 != (char *)buf) {
        free(v26);
      }
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v23 = a2;
    }
    else {
      uint64_t v23 = *(void *)a2;
    }
    uint64_t v13 = [+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v23, v27] isDirectory:0];
    if (!v13) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }
  sub_1002926E0((uint64_t)v12, a2);
  uint64_t v13 = sub_10020D664(a2, 2, 0);
  if (!v13)
  {
LABEL_57:
    sub_100292D80(v13, a2);
LABEL_58:
    uint64_t v14 = 0;
    goto LABEL_59;
  }
  sub_100292BE0(a1, a2, 2);
  uint64_t v14 = 1;
LABEL_59:

  double v24 = sub_10016C458();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C00);
  }
  __int16 v25 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289795;
    *(_DWORD *)uint64_t v34 = 0;
    *(_WORD *)&v34[4] = 2082;
    *(void *)&v34[6] = "";
    __int16 v35 = 1025;
    int v36 = v14;
    __int16 v37 = 2049;
    double v38 = v24 - v4;
    __int16 v39 = 2049;
    double v40 = v11;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Microlocation export restored backup for migration\", \"result\":%{private}hhd, \"duration [s]\":\"%{private}f\", \"restore file size [B]\":%{private}ld}", buf, 0x2Cu);
  }
LABEL_44:
  if (v30 && v29 < 0) {
    operator delete(__p[0]);
  }
  return v14;
}

void sub_1002925C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

id sub_100292618(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (*((char *)a2 + 23) >= 0) {
    int v6 = a2;
  }
  else {
    int v6 = (uint64_t *)*a2;
  }
  char v7 = +[NSString stringWithFormat:@"%s", v6];
  if (*((char *)a3 + 23) >= 0) {
    char v8 = a3;
  }
  else {
    char v8 = (uint64_t *)*a3;
  }
  uint64_t v9 = +[NSString stringWithFormat:@"%s", v8];
  uint64_t v10 = objc_opt_class();

  return (id)+[CLMicroLocationEncryption decryptFile:v7 destinationPath:v9 keyLabel:a4 keychainClass:v10];
}

uint64_t sub_1002926E0(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1000DC48C(buf, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(unsigned char *)(a2 + 23);
  }
  else
  {
    *(_OWORD *)uint64_t buf = *(_OWORD *)a2;
    *(void *)&buf[16] = *(void *)(a2 + 16);
  }
  double v4 = &buf[24];
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)&buf[24], v5 + 4);
  if (v32 < 0) {
    double v4 = *(unsigned char **)&buf[24];
  }
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v6 = (const void *)a2;
    }
    else {
      int v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }
  strcpy(&v4[v5], "-wal");
  char v7 = v33;
  if (*(char *)(a2 + 23) >= 0) {
    size_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)v33, v8 + 4);
  if (v34[0] < 0) {
    char v7 = (void *)v33[0];
  }
  if (v8)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = (const void *)a2;
    }
    else {
      uint64_t v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }
  strcpy((char *)v7 + v8, "-shm");
  double v24 = 0;
  __int16 v25 = 0;
  int v26 = 0;
  uint64_t v27 = &v24;
  char v28 = 0;
  double v24 = (char *)operator new(0x48uLL);
  __int16 v25 = v24;
  int v26 = v24 + 72;
  uint64_t v10 = 0;
  __int16 v25 = sub_100293A90((uint64_t)&v26, (long long *)buf, &v35, v24);
  do
  {
    if ((char)v34[v10 * 8] < 0) {
      operator delete((void *)v33[v10]);
    }
    v10 -= 3;
  }
  while (v10 != -9);
  uint64_t v11 = v24;
  id v12 = v25;
  if (v24 == v25)
  {
    char v13 = 1;
  }
  else
  {
    char v13 = 1;
    do
    {
      if (v11[23] >= 0) {
        uint64_t v14 = v11;
      }
      else {
        uint64_t v14 = *(char **)v11;
      }
      if ([+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v14] isDirectory:0])
      {
        uint64_t v27 = 0;
        unint64_t v15 = +[NSFileManager defaultManager];
        NSFileAttributeKey v29 = NSFileProtectionKey;
        NSFileProtectionType v30 = NSFileProtectionCompleteUnlessOpen;
        int v16 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
        __int16 v17 = v11;
        if (v11[23] < 0) {
          __int16 v17 = *(char **)v11;
        }
        unsigned __int8 v18 = [(NSFileManager *)v15 setAttributes:v16 ofItemAtPath:+[NSString stringWithFormat:@"%s", v17] error:&v27];
        if ((v18 & 1) == 0)
        {
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2C00);
          }
          __int16 v19 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
          {
            int v20 = v11;
            if (v11[23] < 0) {
              int v20 = *(char **)v11;
            }
            *(_DWORD *)uint64_t buf = 68289539;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&unsigned char buf[18] = 2081;
            *(void *)&buf[20] = v20;
            *(_WORD *)&unsigned char buf[28] = 2113;
            *(void *)&buf[30] = v27;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A2C00);
            }
          }
          __int16 v21 = qword_102419458;
          if (os_signpost_enabled((os_log_t)qword_102419458))
          {
            int v22 = v11;
            if (v11[23] < 0) {
              int v22 = *(char **)v11;
            }
            *(_DWORD *)uint64_t buf = 68289539;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&unsigned char buf[18] = 2081;
            *(void *)&buf[20] = v22;
            *(_WORD *)&unsigned char buf[28] = 2113;
            *(void *)&buf[30] = v27;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to set attributes for file", "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
          }
        }
        v13 &= v18;
      }
      v11 += 24;
    }
    while (v11 != v12);
  }
  *(void *)uint64_t buf = &v24;
  sub_1000A7B4C((void ***)buf);
  return v13 & 1;
}

void sub_100292B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

uint64_t sub_100292BE0(uint64_t a1, uint64_t a2, int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1000DC48C(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  uint64_t v4 = sub_1001F9ADC((uint64_t)v10, (long long *)__p, a3);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_1002930A8(v4, (uint64_t)v10, v7);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C00);
  }
  size_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t buf = 68290051;
    __int16 v12 = 2082;
    char v13 = "";
    __int16 v14 = 1025;
    int v15 = v7[0];
    __int16 v16 = 1025;
    int v17 = v7[1];
    __int16 v18 = 1025;
    int v19 = v7[2];
    __int16 v20 = 1025;
    int v21 = v7[3];
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Restored iCloud Backup database tables contents\", \"numRecordingEventsEntries\":%{private}d, \"numMeasurementsEntries\":%{private}d, \"numConfigurationEntries\":%{private}d, \"numLoiEntries\":%{private}d}", (uint8_t *)&buf, 0x2Au);
  }
  return sub_1001F9CAC((uint64_t)v10);
}

void sub_100292D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

void sub_100292D80(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1000DC48C(&__dst, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(unsigned char *)(a2 + 23);
  }
  else
  {
    long long __dst = *(_OWORD *)a2;
    uint64_t v20 = *(void *)(a2 + 16);
  }
  uint64_t v4 = v21;
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)v21, v5 + 4);
  if (v22 < 0) {
    uint64_t v4 = (void *)v21[0];
  }
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v6 = (const void *)a2;
    }
    else {
      int v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }
  strcpy((char *)v4 + v5, "-wal");
  char v7 = v23;
  if (*(char *)(a2 + 23) >= 0) {
    size_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1001110E4((uint64_t)v23, v8 + 4);
  if (v24 < 0) {
    char v7 = (void *)v23[0];
  }
  if (v8)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = (const void *)a2;
    }
    else {
      uint64_t v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }
  strcpy((char *)v7 + v8, "-shm");
  int v15 = 0;
  __int16 v16 = 0;
  v17[0] = 0;
  v17[1] = &v15;
  char v18 = 0;
  int v15 = (char *)operator new(0x48uLL);
  __int16 v16 = v15;
  v17[0] = v15 + 72;
  uint64_t v10 = 0;
  __int16 v16 = sub_1000DC3CC((uint64_t)v17, &__dst, &v25, v15);
  do
  {
    if (*(&v24 + v10 * 8) < 0) {
      operator delete((void *)v23[v10]);
    }
    v10 -= 3;
  }
  while (v10 != -9);
  uint64_t v11 = v15;
  for (uint64_t i = v16; v11 != i; v11 += 24)
  {
    if (v11[23] >= 0) {
      char v13 = v11;
    }
    else {
      char v13 = *(char **)v11;
    }
    if ([+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v13] isDirectory:0])
    {
      __int16 v14 = v11;
      if (v11[23] < 0) {
        __int16 v14 = *(char **)v11;
      }
      [+[NSFileManager defaultManager](NSFileManager, "defaultManager") removeItemAtURL:+[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", +[NSString stringWithUTF8String:v14]) error:0];
    }
  }
  *(void *)&long long __dst = &v15;
  sub_1000A7B4C((void ***)&__dst);
}

void sub_100293018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15)
{
}

uint64_t sub_1002930A8(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = sub_10020E920(a2);
  a3[1] = sub_10020E638(a2);
  a3[2] = sub_10020ED78(a2);
  uint64_t result = sub_10029387C(a2);
  a3[3] = result;
  return result;
}

void sub_1002930FC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_1005F7C38((char *)(*(void *)a1 + 72), (uint64_t)__p);
  if (v11 >= 0) {
    int v3 = __p;
  }
  else {
    int v3 = (void **)__p[0];
  }
  uint64_t v4 = [+[NSString stringWithFormat:@"%s", v3] stringByDeletingLastPathComponent];
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  char v9 = 0;
  unsigned int v5 = [+[NSFileManager defaultManager] fileExistsAtPath:v4 isDirectory:&v9];
  if (v9) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if (v6 == 1)
  {
    sub_100134750(__p, (char *)[(NSString *)v4 UTF8String]);
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *(void *)(a2 + 16) = v11;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    char v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get locationDb directory", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C00);
      }
      size_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::optional<std::string> CLMicroLocationBackupAndRestore::getLocationDbDirPath()", "%s\n", v8);
      if (v8 != (char *)__p) {
        free(v8);
      }
    }
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
}

void sub_100293350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100293374(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_1002930FC(a1, (uint64_t)__p);
  if (v9
    && (v8 >= 0 ? (int v3 = __p) : (int v3 = (void **)__p[0]),
        uint64_t v4 = [+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%s", v3) stringByAppendingPathComponent:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "milo_cache")], [+[NSFileManager defaultManager] fileExistsAtPath:v4 isDirectory:0]))
  {
    sub_100134750(&v5, (char *)[(NSString *)v4 UTF8String]);
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  if (v9)
  {
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100293470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100293498(uint64_t a1)
{
  sub_100291AF4(a1, (uint64_t)v16);
  if (v18)
  {
    uint64_t v2 = v16;
    if (v17 < 0) {
      uint64_t v2 = (void **)v16[0];
    }
    if ([+[NSFileManager defaultManager](NSFileManager, "defaultManager") fileExistsAtPath:+[NSString stringWithFormat:@"%s", v2] isDirectory:0])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C00);
      }
      int v3 = qword_102419458;
      BOOL v4 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT);
      if (v4)
      {
        if (!v18) {
          sub_10020D700();
        }
        long long v5 = v16;
        if (v17 < 0) {
          long long v5 = (void **)v16[0];
        }
        *(_DWORD *)uint64_t buf = 68289283;
        int v20 = 0;
        __int16 v21 = 2082;
        char v22 = "";
        __int16 v23 = 2081;
        char v24 = (const char *)v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"deleting restore database file\", \"filename\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      if (!v18) {
        sub_10020D700();
      }
      sub_100292D80(v4, (uint64_t)v16);
    }
  }
  sub_100293374(a1, (uint64_t)__p);
  if (v15)
  {
    uint64_t v6 = __p;
    if (v14 < 0) {
      uint64_t v6 = (void **)__p[0];
    }
    char v7 = +[NSString stringWithFormat:@"%s", v6];
    if ([+[NSFileManager defaultManager] fileExistsAtPath:v7 isDirectory:0])
    {
      uint64_t v12 = 0;
      if (![+[NSFileManager defaultManager] removeItemAtPath:v7 error:&v12])
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C00);
        }
        char v8 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
        {
          char v9 = [(NSString *)v7 UTF8String];
          *(_DWORD *)uint64_t buf = 68289538;
          int v20 = 0;
          __int16 v21 = 2082;
          char v22 = "";
          __int16 v23 = 2082;
          char v24 = v9;
          __int16 v25 = 2114;
          uint64_t v26 = v12;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to remove existing directory\", \"directory\":%{public, location:escape_only}s, \"error\":%{public, location:escape_only}@}", buf, 0x26u);
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2C00);
          }
        }
        uint64_t v10 = qword_102419458;
        if (os_signpost_enabled((os_log_t)qword_102419458))
        {
          uint64_t v11 = [(NSString *)v7 UTF8String];
          *(_DWORD *)uint64_t buf = 68289538;
          int v20 = 0;
          __int16 v21 = 2082;
          char v22 = "";
          __int16 v23 = 2082;
          char v24 = v11;
          __int16 v25 = 2114;
          uint64_t v26 = v12;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to remove existing directory", "{\"msg%{public}.0s\":\"failed to remove existing directory\", \"directory\":%{public, location:escape_only}s, \"error\":%{public, location:escape_only}@}", buf, 0x26u);
        }
      }
    }
    if (v15 && v14 < 0) {
      operator delete(__p[0]);
    }
  }
  if (v18)
  {
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }
}

void sub_10029381C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a17 && a16 < 0) {
    operator delete(__p);
  }
  if (a24)
  {
    if (a23 < 0) {
      operator delete(a18);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029387C(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    return sub_1001FA654(a1, "MiLoLoiTable");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C00);
    }
    int v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C00);
      }
      BOOL v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoLoiTable]", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    return 0;
  }
}

void sub_100293A60(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

char *sub_100293A90(uint64_t a1, long long *a2, long long *a3, char *__dst)
{
  BOOL v4 = __dst;
  uint64_t v11 = __dst;
  uint64_t v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_1000DC48C(v4, *(void **)v6, *((void *)v6 + 1));
        BOOL v4 = v12;
      }
      else
      {
        long long v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)BOOL v4 = v7;
      }
      uint64_t v6 = (long long *)((char *)v6 + 24);
      v4 += 24;
      uint64_t v12 = v4;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_100293B50((uint64_t)v9);
  return v4;
}

void sub_100293B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100293B50(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1001D86C4(a1);
  }
  return a1;
}

void *sub_100293B88(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  v7[0] = off_1022A2C80;
  v7[1] = a1;
  v7[3] = v7;
  v8[0] = off_1022A2D00;
  v8[1] = a1;
  void v8[3] = v8;
  v9[0] = off_1022A2D80;
  v9[1] = a1;
  void v9[3] = v9;
  v10[0] = off_1022A2E00;
  v10[1] = a1;
  uint64_t v10[3] = v10;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  BOOL v4 = (char *)operator new(0x80uLL);
  a1[4] = v4 + 128;
  a1[2] = v4;
  a1[3] = v4;
  a1[3] = sub_10022EFC8((uint64_t)(a1 + 4), (uint64_t)v7, (uint64_t)&v11, (uint64_t)v4);
  for (uint64_t i = 12; i != -4; i -= 4)
    sub_10022E964(&v7[i]);
  return a1;
}

void sub_100293CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 24) = v14;
  sub_10022F0E4(&a10);
  for (uint64_t i = 96; i != -32; i -= 32)
    sub_10022E964(&a12 + i);
  _Unwind_Resume(a1);
}

void *sub_100293D20(void *result)
{
  uint64_t v1 = result[2];
  for (uint64_t i = result[3]; v1 != i; v1 += 32)
  {
    v4[0] = off_1022A2E80;
    void v4[3] = v4;
    uint64_t v3 = *(void *)(v1 + 24);
    if (!v3) {
      sub_10015E48C();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v4);
    uint64_t result = sub_1001EFA74(v4);
  }
  return result;
}

void sub_100293DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_100293E10(uint64_t a1, void *a2, void *a3, __int32 **a4, uint64_t *a5)
{
  [a2 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002D34F4(a5, a4)) forKeyedSubscript:objc_msgSend(a3, "stringByAppendingString:", @"Count")];
  unint64_t result = sub_1002D3700((uint64_t)a5, a4);
  if ((result & 0xFF00000000) != 0)
  {
    LODWORD(v10) = result;
    uint64_t v11 = +[NSNumber numberWithFloat:v10];
    id v12 = [a3 stringByAppendingString:@"Utilization"];
    return (unint64_t)[a2 setObject:v11 forKeyedSubscript:v12];
  }
  return result;
}

void sub_100293EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_1002943F8())
  {
    long long v5 = operator new(0x68uLL);
    *long long v5 = xmmword_101D07BB0;
    v5[1] = xmmword_101D07BC0;
    _DWORD v5[2] = xmmword_101D07BD0;
    v5[3] = xmmword_101D07BE0;
    void v5[4] = xmmword_101D07BF0;
    v5[5] = xmmword_101D07C00;
    *((void *)v5 + 12) = 13;
    sub_10029B910(&v31, 0xDuLL);
    uint64_t v6 = 0;
    *(void *)uint64_t buf = &v31;
    do
    {
      LODWORD(v29) = *(_DWORD *)((char *)v5 + v6);
      sub_10027DE2C((uint64_t *)buf, &v29);
      v6 += 8;
    }
    while (v6 != 24);
    sub_1002D33D8(buf, a2);
    uint64_t v7 = sub_100170408((uint64_t)buf);
    sub_1002D33DC((uint64_t *)buf, 3uLL, &v29);
    sub_1002D33DC((uint64_t *)buf, 4uLL, &v27);
    sub_1002D33DC((uint64_t *)buf, 5uLL, &v25);
    double v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    sub_10010F834(&v10, v29, (uint64_t)v30, (v30 - (unsigned char *)v29) >> 2);
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    sub_10010F834(&v13, v27, (uint64_t)v28, (v28 - (unsigned char *)v27) >> 2);
    __int16 v16 = 0;
    char v17 = 0;
    uint64_t v18 = 0;
    sub_10010F834(&v16, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 2);
    long long __p = 0;
    int v20 = 0;
    uint64_t v21 = 0;
    sub_10010F834(&__p, v31, (uint64_t)v32, (v32 - (unsigned char *)v31) >> 2);
    uint64_t v22 = a3;
    uint64_t v23 = v7;
    uint64_t v24 = a2;
    AnalyticsSendEventLazy();
    if (__p)
    {
      int v20 = __p;
      operator delete(__p);
    }
    if (v16)
    {
      char v17 = v16;
      operator delete(v16);
    }
    if (v13)
    {
      uint64_t v14 = v13;
      operator delete(v13);
    }
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }
    if (v25)
    {
      uint64_t v26 = v25;
      operator delete(v25);
    }
    if (v27)
    {
      char v28 = v27;
      operator delete(v27);
    }
    if (v29)
    {
      NSFileProtectionType v30 = v29;
      operator delete(v29);
    }
    if (v35)
    {
      int v36 = v35;
      operator delete(v35);
    }
    if (*(void *)buf)
    {
      uint64_t v34 = *(void **)buf;
      operator delete(*(void **)buf);
    }
    if (v31)
    {
      char v32 = v31;
      operator delete(v31);
    }
    operator delete(v5);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    char v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      LOWORD(v31) = 0;
      char v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationAnalytics::sendCoreAnalyticsEvent(const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::string &) const", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_100294304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

uint64_t sub_1002943F8()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_10029448C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

id sub_1002944A8(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary];
  [v2 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100170408(*(void *)(a1 + 40))) forKeyedSubscript:@"histogramTotalChannelCount"];
  uint64_t v3 = *(uint64_t **)(a1 + 48);
  if (*((char *)v3 + 23) < 0) {
    uint64_t v3 = (uint64_t *)*v3;
  }
  [v2 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3) forKeyedSubscript:@"loiType"];
  long long v159 = 0;
  long long v160 = 0;
  uint64_t v161 = 0;
  sub_10010F834(&v159, *(const void **)(a1 + 56), *(void *)(a1 + 64), (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 2);
  uint64_t v4 = *(void *)(a1 + 40);
  int v153 = 0;
  uint64_t v154 = 0;
  unint64_t v152 = 0;
  sub_1001DD364(&v152, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 3);
  int v155 = *(_DWORD *)(v4 + 24);
  v157 = 0;
  uint64_t v158 = 0;
  int v156 = 0;
  uint64_t v5 = sub_10010F834(&v156, *(const void **)(v4 + 32), *(void *)(v4 + 40), (uint64_t)(*(void *)(v4 + 40) - *(void *)(v4 + 32)) >> 2);
  sub_100293E10((uint64_t)v5, v2, @"localizationTopThreeChannels", &v159, (uint64_t *)&v152);
  if (v156)
  {
    v157 = v156;
    operator delete(v156);
  }
  if (v152)
  {
    int v153 = v152;
    operator delete(v152);
  }
  if (v159)
  {
    long long v160 = v159;
    operator delete(v159);
  }
  long long v149 = 0;
  long long v150 = 0;
  uint64_t v151 = 0;
  sub_10010F834(&v149, *(const void **)(a1 + 80), *(void *)(a1 + 88), (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2);
  uint64_t v6 = *(void *)(a1 + 40);
  long long v143 = 0;
  uint64_t v144 = 0;
  long long v142 = 0;
  sub_1001DD364(&v142, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
  int v145 = *(_DWORD *)(v6 + 24);
  __int16 v147 = 0;
  uint64_t v148 = 0;
  long long v146 = 0;
  uint64_t v7 = sub_10010F834(&v146, *(const void **)(v6 + 32), *(void *)(v6 + 40), (uint64_t)(*(void *)(v6 + 40) - *(void *)(v6 + 32)) >> 2);
  sub_100293E10((uint64_t)v7, v2, @"localizationTopFourChannels", &v149, (uint64_t *)&v142);
  if (v146)
  {
    __int16 v147 = v146;
    operator delete(v146);
  }
  if (v142)
  {
    long long v143 = v142;
    operator delete(v142);
  }
  if (v149)
  {
    long long v150 = v149;
    operator delete(v149);
  }
  v140 = 0;
  long long v139 = 0;
  uint64_t v141 = 0;
  sub_10010F834(&v139, *(const void **)(a1 + 104), *(void *)(a1 + 112), (uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v134 = 0;
  unint64_t v132 = 0;
  unint64_t v133 = 0;
  sub_1001DD364(&v132, *(const void **)v8, *(void *)(v8 + 8), (uint64_t)(*(void *)(v8 + 8) - *(void *)v8) >> 3);
  int v135 = *(_DWORD *)(v8 + 24);
  uint64_t v138 = 0;
  long long __p = 0;
  unint64_t v137 = 0;
  char v9 = sub_10010F834(&__p, *(const void **)(v8 + 32), *(void *)(v8 + 40), (uint64_t)(*(void *)(v8 + 40) - *(void *)(v8 + 32)) >> 2);
  sub_100293E10((uint64_t)v9, v2, @"localizationTopFiveChannels", (__int32 **)&v139, (uint64_t *)&v132);
  if (__p)
  {
    unint64_t v137 = __p;
    operator delete(__p);
  }
  if (v132)
  {
    unint64_t v133 = v132;
    operator delete(v132);
  }
  if (v139)
  {
    v140 = v139;
    operator delete(v139);
  }
  double v10 = *(const void **)(a1 + 128);
  uint64_t v11 = *(void *)(a1 + 136);
  uint64_t v130 = 0;
  int64_t v129 = 0;
  uint64_t v131 = 0;
  sub_10010F834(&v129, v10, v11, (v11 - (uint64_t)v10) >> 2);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v124 = 0;
  uint64_t v122 = 0;
  uint64_t v123 = 0;
  sub_1001DD364(&v122, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 3);
  int v125 = *(_DWORD *)(v12 + 24);
  uint64_t v128 = 0;
  long long v126 = 0;
  int64_t v127 = 0;
  uint64_t v13 = sub_10010F834(&v126, *(const void **)(v12 + 32), *(void *)(v12 + 40), (uint64_t)(*(void *)(v12 + 40) - *(void *)(v12 + 32)) >> 2);
  sub_100293E10((uint64_t)v13, v2, @"localizationPopularThreeChannels", (__int32 **)&v129, (uint64_t *)&v122);
  if (v126)
  {
    int64_t v127 = v126;
    operator delete(v126);
  }
  if (v122)
  {
    uint64_t v123 = v122;
    operator delete(v122);
  }
  if (v129)
  {
    uint64_t v130 = v129;
    operator delete(v129);
  }
  unint64_t v14 = sub_1002D3470(*(__int32 ***)(a1 + 40), (__int32 **)(a1 + 128));
  if ((v14 & 0xFF00000000) != 0)
  {
    int v15 = v14;
    __n128 v107 = 0;
    __n128 v108 = 0;
    unint64_t v109 = 0;
    sub_10010F834(&v107, *(const void **)(a1 + 128), *(void *)(a1 + 136), (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 2);
    __int16 v16 = v108;
    if ((unint64_t)v108 >= v109)
    {
      uint64_t v18 = (char *)v107;
      uint64_t v19 = (v108 - (unsigned char *)v107) >> 2;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 62) {
        sub_1001D7FD4();
      }
      uint64_t v21 = v109 - (void)v107;
      if ((uint64_t)(v109 - (void)v107) >> 1 > v20) {
        unint64_t v20 = v21 >> 1;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        uint64_t v23 = (char *)sub_10017EA34((uint64_t)&v109, v22);
        uint64_t v18 = (char *)v107;
        __int16 v16 = v108;
      }
      else
      {
        uint64_t v23 = 0;
      }
      uint64_t v24 = &v23[4 * v19];
      __int16 v25 = &v23[4 * v22];
      *(_DWORD *)uint64_t v24 = v15;
      uint64_t v17 = (uint64_t)(v24 + 4);
      while (v16 != v18)
      {
        int v26 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v24 - 1) = v26;
        v24 -= 4;
      }
      __n128 v107 = v24;
      __n128 v108 = (char *)v17;
      unint64_t v109 = (unint64_t)v25;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *(_DWORD *)__n128 v108 = v15;
      uint64_t v17 = (uint64_t)(v16 + 4);
    }
    __n128 v108 = (char *)v17;
    uint64_t v121 = 0;
    uint64_t v119 = 0;
    uint64_t v120 = 0;
    sub_10010F834(&v119, v107, v17, (v17 - (uint64_t)v107) >> 2);
    uint64_t v27 = *(void *)(a1 + 40);
    uint64_t v114 = 0;
    __n128 v112 = 0;
    long long v113 = 0;
    sub_1001DD364(&v112, *(const void **)v27, *(void *)(v27 + 8), (uint64_t)(*(void *)(v27 + 8) - *(void *)v27) >> 3);
    int v115 = *(_DWORD *)(v27 + 24);
    uint64_t v118 = 0;
    __n128 v116 = 0;
    __n128 v117 = 0;
    char v28 = sub_10010F834(&v116, *(const void **)(v27 + 32), *(void *)(v27 + 40), (uint64_t)(*(void *)(v27 + 40) - *(void *)(v27 + 32)) >> 2);
    sub_100293E10((uint64_t)v28, v2, @"localizationPopularThreeAndTopOneChannels", (__int32 **)&v119, (uint64_t *)&v112);
    if (v116)
    {
      __n128 v117 = v116;
      operator delete(v116);
    }
    if (v112)
    {
      long long v113 = v112;
      operator delete(v112);
    }
    if (v119)
    {
      uint64_t v120 = v119;
      operator delete(v119);
    }
    if (v107)
    {
      __n128 v108 = (char *)v107;
      operator delete(v107);
    }
  }
  sub_1002D33D8(&v107, *(void *)(a1 + 152));
  uint64_t v29 = sub_100170408((uint64_t)&v107);
  [v2 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v29) forKeyedSubscript:@"prevHistogramTotalChannelCount"];
  uint64_t v30 = *(void *)(a1 + 160) - v29;
  [v2 setObject:+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v30) forKeyedSubscript:@"histogramDiffCount"];
  if (v29)
  {
    *(float *)&double v31 = (float)v30 / (float)(unint64_t)v29;
    [v2 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v31) forKeyedSubscript:@"histogramDiffCountPercentage"];
  }
  sub_1002D33DC((uint64_t *)&v107, 3uLL, v106);
  uint64_t v32 = *(void *)(a1 + 40);
  long long v100 = 0;
  uint64_t v101 = 0;
  long long v99 = 0;
  sub_1001DD364(&v99, *(const void **)v32, *(void *)(v32 + 8), (uint64_t)(*(void *)(v32 + 8) - *(void *)v32) >> 3);
  int v102 = *(_DWORD *)(v32 + 24);
  long long v104 = 0;
  uint64_t v105 = 0;
  uint64_t v103 = 0;
  long long v33 = sub_10010F834(&v103, *(const void **)(v32 + 32), *(void *)(v32 + 40), (uint64_t)(*(void *)(v32 + 40) - *(void *)(v32 + 32)) >> 2);
  sub_100293E10((uint64_t)v33, v2, @"localizationPrevTopThreeChannels", (__int32 **)v106, (uint64_t *)&v99);
  if (v103)
  {
    long long v104 = v103;
    operator delete(v103);
  }
  if (v99)
  {
    long long v100 = v99;
    operator delete(v99);
  }
  if (v106[0])
  {
    v106[1] = v106[0];
    operator delete(v106[0]);
  }
  sub_1002D33DC((uint64_t *)&v107, 4uLL, v98);
  uint64_t v34 = *(void *)(a1 + 40);
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  long long v91 = 0;
  sub_1001DD364(&v91, *(const void **)v34, *(void *)(v34 + 8), (uint64_t)(*(void *)(v34 + 8) - *(void *)v34) >> 3);
  int v94 = *(_DWORD *)(v34 + 24);
  __n128 v96 = 0;
  uint64_t v97 = 0;
  long long v95 = 0;
  long long v35 = sub_10010F834(&v95, *(const void **)(v34 + 32), *(void *)(v34 + 40), (uint64_t)(*(void *)(v34 + 40) - *(void *)(v34 + 32)) >> 2);
  sub_100293E10((uint64_t)v35, v2, @"localizationPrevTopFourChannels", (__int32 **)v98, (uint64_t *)&v91);
  if (v95)
  {
    __n128 v96 = v95;
    operator delete(v95);
  }
  if (v91)
  {
    uint64_t v92 = v91;
    operator delete(v91);
  }
  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }
  sub_1002D33DC((uint64_t *)&v107, 5uLL, v90);
  uint64_t v36 = *(void *)(a1 + 40);
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v83 = 0;
  sub_1001DD364(&v83, *(const void **)v36, *(void *)(v36 + 8), (uint64_t)(*(void *)(v36 + 8) - *(void *)v36) >> 3);
  int v86 = *(_DWORD *)(v36 + 24);
  unint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v87 = 0;
  __int16 v37 = sub_10010F834(&v87, *(const void **)(v36 + 32), *(void *)(v36 + 40), (uint64_t)(*(void *)(v36 + 40) - *(void *)(v36 + 32)) >> 2);
  sub_100293E10((uint64_t)v37, v2, @"localizationPrevTopFiveChannels", (__int32 **)v90, (uint64_t *)&v83);
  if (v87)
  {
    unint64_t v88 = v87;
    operator delete(v87);
  }
  if (v83)
  {
    uint64_t v84 = v83;
    operator delete(v83);
  }
  if (v90[0])
  {
    v90[1] = v90[0];
    operator delete(v90[0]);
  }
  unint64_t v38 = sub_1002D3470(*(__int32 ***)(a1 + 40), (__int32 **)(a1 + 128));
  int v39 = v38;
  if ((v38 & 0xFF00000000) != 0)
  {
    uint64_t v80 = 0;
    unint64_t v81 = 0;
    unint64_t v82 = 0;
    sub_10010F834(&v80, *(const void **)(a1 + 128), *(void *)(a1 + 136), (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 2);
    double v40 = v81;
    if ((unint64_t)v81 >= v82)
    {
      unint64_t v42 = (char *)v80;
      uint64_t v43 = (v81 - (unsigned char *)v80) >> 2;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 62) {
        sub_1001D7FD4();
      }
      uint64_t v45 = v82 - (void)v80;
      if ((uint64_t)(v82 - (void)v80) >> 1 > v44) {
        unint64_t v44 = v45 >> 1;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v46 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46)
      {
        unint64_t v47 = (char *)sub_10017EA34((uint64_t)&v82, v46);
        unint64_t v42 = (char *)v80;
        double v40 = v81;
      }
      else
      {
        unint64_t v47 = 0;
      }
      __n128 v48 = &v47[4 * v43];
      __n128 v49 = &v47[4 * v46];
      *(_DWORD *)__n128 v48 = v39;
      uint64_t v41 = (uint64_t)(v48 + 4);
      while (v40 != v42)
      {
        int v50 = *((_DWORD *)v40 - 1);
        v40 -= 4;
        *((_DWORD *)v48 - 1) = v50;
        v48 -= 4;
      }
      uint64_t v80 = v48;
      unint64_t v81 = (char *)v41;
      unint64_t v82 = (unint64_t)v49;
      if (v42) {
        operator delete(v42);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v81 = v39;
      uint64_t v41 = (uint64_t)(v40 + 4);
    }
    unint64_t v81 = (char *)v41;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    uint64_t v77 = 0;
    sub_10010F834(&v77, v80, v41, (v41 - (uint64_t)v80) >> 2);
    uint64_t v51 = *(void *)(a1 + 40);
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    int64_t v70 = 0;
    sub_1001DD364(&v70, *(const void **)v51, *(void *)(v51 + 8), (uint64_t)(*(void *)(v51 + 8) - *(void *)v51) >> 3);
    int v73 = *(_DWORD *)(v51 + 24);
    char v75 = 0;
    uint64_t v76 = 0;
    unint64_t v74 = 0;
    long long v52 = sub_10010F834(&v74, *(const void **)(v51 + 32), *(void *)(v51 + 40), (uint64_t)(*(void *)(v51 + 40) - *(void *)(v51 + 32)) >> 2);
    sub_100293E10((uint64_t)v52, v2, @"localizationPopularThreeAndPrevOneTopChannels", (__int32 **)&v77, (uint64_t *)&v70);
    if (v74)
    {
      char v75 = v74;
      operator delete(v74);
    }
    if (v70)
    {
      uint64_t v71 = v70;
      operator delete(v70);
    }
    if (v77)
    {
      uint64_t v78 = v77;
      operator delete(v77);
    }
    for (unint64_t i = 3; i != 6; ++i)
    {
      sub_1002D3580(*(int ***)(a1 + 168), *(int ***)(a1 + 152), i, &v68);
      __n128 v54 = +[NSString stringWithFormat:@"localizationTop%dCommonChannels", i];
      uint64_t v65 = 0;
      long long v66 = 0;
      uint64_t v67 = 0;
      sub_10010F834(&v65, v68, (uint64_t)v69, (v69 - (unsigned char *)v68) >> 2);
      uint64_t v55 = *(void *)(a1 + 40);
      BOOL v59 = 0;
      uint64_t v60 = 0;
      long long v58 = 0;
      sub_1001DD364(&v58, *(const void **)v55, *(void *)(v55 + 8), (uint64_t)(*(void *)(v55 + 8) - *(void *)v55) >> 3);
      int v61 = *(_DWORD *)(v55 + 24);
      double v63 = 0;
      uint64_t v64 = 0;
      double v62 = 0;
      long long v56 = sub_10010F834(&v62, *(const void **)(v55 + 32), *(void *)(v55 + 40), (uint64_t)(*(void *)(v55 + 40) - *(void *)(v55 + 32)) >> 2);
      sub_100293E10((uint64_t)v56, v2, v54, (__int32 **)&v65, (uint64_t *)&v58);
      if (v62)
      {
        double v63 = v62;
        operator delete(v62);
      }
      if (v58)
      {
        BOOL v59 = v58;
        operator delete(v58);
      }
      if (v65)
      {
        long long v66 = v65;
        operator delete(v65);
      }
      if (v68)
      {
        int64_t v69 = v68;
        operator delete(v68);
      }
    }
    if (v80)
    {
      unint64_t v81 = (char *)v80;
      operator delete(v80);
    }
  }
  if (v110)
  {
    __n128 v111 = v110;
    operator delete(v110);
  }
  if (v107)
  {
    __n128 v108 = (char *)v107;
    operator delete(v107);
  }
  return v2;
}

void sub_100294F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1002951E0((uint64_t)&a23);
  if (__p)
  {
    a31 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  sub_1002951E0((uint64_t)&a66);
  _Unwind_Resume(a1);
}

uint64_t sub_1002951E0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void *sub_100295224(void *a1, uint64_t a2)
{
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  sub_10010F834(a1 + 7, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 2);
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  sub_10010F834(a1 + 10, *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  sub_10010F834(a1 + 13, *(const void **)(a2 + 104), *(void *)(a2 + 112), (uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 2);
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  return sub_10010F834(a1 + 16, *(const void **)(a2 + 128), *(void *)(a2 + 136), (uint64_t)(*(void *)(a2 + 136) - *(void *)(a2 + 128)) >> 2);
}

void sub_1002952D8(_Unwind_Exception *exception_object)
{
  uint64_t v6 = *v4;
  if (*v4)
  {
    v1[14] = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v3;
  if (*v3)
  {
    v1[11] = v7;
    operator delete(v7);
  }
  uint64_t v8 = *v2;
  if (*v2)
  {
    v1[8] = v8;
    operator delete(v8);
  }
  _Unwind_Resume(exception_object);
}

void sub_100295324(void *a1)
{
  id v2 = (void *)a1[16];
  if (v2)
  {
    a1[17] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[13];
  if (v3)
  {
    a1[14] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[10];
  if (v4)
  {
    a1[11] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[7];
  if (v5)
  {
    a1[8] = v5;
    operator delete(v5);
  }
}

void sub_10029539C(uint64_t *a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)double v63 = 2082;
    *(void *)&v63[2] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"analyzing WiFi channels\"}", buf, 0x12u);
  }
  sub_1001FF120(a1[1], &v58);
  if (v58 == v59)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    unint64_t v38 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)double v63 = 2082;
      *(void *)&v63[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"no LOI ids found\"}", buf, 0x12u);
    }
  }
  else
  {
    sub_1000C7F88(buf);
    LODWORD(v48.__r_.__value_.__l.__data_) = 0;
    CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberDaysToAnalyzeWiFiChannels", 0x8000100u, kCFAllocatorNull);
    int v6 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v5, &v48);
    CFRelease(v5);
    uint64_t data_low = LODWORD(v48.__r_.__value_.__l.__data_);
    if (*(void *)v63) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v63);
    }
    if (v6) {
      uint64_t v8 = data_low;
    }
    else {
      uint64_t v8 = 2;
    }
    char v9 = +[NSDate date];
    uint64_t v55 = 0;
    unint64_t v56 = 0;
    unint64_t v57 = 0;
    uint64_t v10 = v58;
    uint64_t v46 = v59;
    if (v58 == v59)
    {
LABEL_78:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v41 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)double v63 = 2082;
        *(void *)&v63[2] = "";
        unint64_t v42 = "{\"msg%{public}.0s\":\"Wifi Channel Histogram was not generated\"}";
        uint64_t v43 = v41;
        uint32_t v44 = 18;
LABEL_82:
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v42, buf, v44);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)v9;
      do
      {
        uint64_t v47 = v10;
        uint64_t v12 = (uint64_t *)(v10 + 24);
        memset(v53, 0, sizeof(v53));
        int v54 = 1065353216;
        if (v8)
        {
          uint64_t v13 = 0;
          while (1)
          {
            uint64_t v14 = *(void *)(a2 + 24);
            if (!v14) {
              sub_10015E48C();
            }
            if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 48))(v14)) {
              break;
            }
            double v15 = sub_100342BCC(v11, ~v13);
            std::to_string(&v48, v15);
            double v16 = sub_100342BCC(v11, -(int)v13);
            std::to_string(&v49, v16);
            sub_1001FC4A8(a1[1], (uint64_t)v12, (uint64_t)&v48, (uint64_t)&v49, &v51);
            if (*(_OWORD *)v12 != 0)
            {
              uint64_t v17 = a1[1];
              *(_OWORD *)&v67.__r_.__value_.__l.__data_ = 0uLL;
              sub_1001FC4A8(v17, (uint64_t)&v67, (uint64_t)&v48, (uint64_t)&v49, buf);
              sub_10029B988((uint64_t *)&v51, (uint64_t)v52, *(uint64_t *)buf, *(uint64_t *)v63, 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)v63 - *(void *)buf) >> 3));
              v67.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
              sub_100216394((void ***)&v67);
            }
            uint64_t v18 = v51;
            uint64_t v19 = v52;
            if (v51 != v52)
            {
              memset(&v67, 0, sizeof(v67));
              do
              {
                if (*((_DWORD *)v18 + 24) == 1)
                {
                  uint64_t v20 = v18[6];
                  if (!v20) {
                    uint64_t v20 = *(void *)(qword_102489958 + 16);
                  }
                  sub_10023F7D0(buf, v20);
                  std::string::size_type size = v67.__r_.__value_.__l.__size_;
                  if (v67.__r_.__value_.__l.__size_ >= v67.__r_.__value_.__r.__words[2])
                  {
                    std::string::size_type v22 = sub_10029C108((uint64_t *)&v67, (uint64_t)buf);
                  }
                  else
                  {
                    sub_10023F7D0(v67.__r_.__value_.__l.__size_, buf);
                    std::string::size_type v22 = size + 48;
                  }
                  v67.__r_.__value_.__l.__size_ = v22;
                  sub_10023F7D4((wireless_diagnostics::google::protobuf::MessageLite *)buf);
                }
                v18 += 15;
              }
              while (v18 != v19);
              sub_1002D0ED0(v53, (uint64_t *)&v67);
              *(void *)uint64_t buf = &v67;
              sub_10029C048((void ***)buf);
            }
            *(void *)uint64_t buf = &v51;
            sub_100216394((void ***)buf);
            if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v49.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v48.__r_.__value_.__l.__data_);
            }
            if (++v13 == v8) {
              goto LABEL_35;
            }
          }
          if (qword_102419450 != -1) {
            dispatch_once(&qword_102419450, &stru_1022A2C50);
          }
          int v39 = qword_102419458;
          if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)double v63 = 2082;
            *(void *)&v63[2] = "";
            __int16 v64 = 2082;
            uint64_t v65 = "MicroLocationAnalytics";
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"wifi channels analyitcs operation cancelled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
          }
          sub_1000D7D80((uint64_t)v53);
          goto LABEL_83;
        }
LABEL_35:
        if (sub_1002D0F8C((uint64_t)v53))
        {
          sub_1000D7D80((uint64_t)v53);
          uint64_t v23 = v47;
        }
        else
        {
          sub_1002D0F9C((uint64_t)v53, (uint64_t *)&v51);
          sub_10023E114((uint64_t)&v49);
          uint64_t v24 = (int *)v51;
          __int16 v25 = (int *)v52;
          if (v51 != v52)
          {
            int v26 = v49.__r_.__value_.__r.__words[2];
            do
            {
              int v27 = HIDWORD(v49.__r_.__value_.__r.__words[2]);
              if (v26 >= SHIDWORD(v49.__r_.__value_.__r.__words[2]))
              {
                if (HIDWORD(v49.__r_.__value_.__r.__words[2]) == v50)
                {
                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)&v49.__r_.__value_.__r.__words[1], HIDWORD(v49.__r_.__value_.__r.__words[2]) + 1);
                  int v27 = HIDWORD(v49.__r_.__value_.__r.__words[2]);
                }
                HIDWORD(v49.__r_.__value_.__r.__words[2]) = v27 + 1;
                sub_10029A7F0();
              }
              LODWORD(v49.__r_.__value_.__r.__words[2]) = v26 + 1;
              uint64_t v28 = *(void *)(v49.__r_.__value_.__l.__size_ + 8 * v26++);
              int v29 = *v24;
              int v30 = *(_DWORD *)(v28 + 24);
              *(_DWORD *)(v28 + 24) = v30 | 1;
              *(_DWORD *)(v28 + 16) = v29;
              uint64_t v31 = v24[1];
              *(_DWORD *)(v28 + 24) = v30 | 3;
              *(void *)(v28 + 8) = v31;
              v24 += 2;
            }
            while (v24 != v25);
          }
          double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
          sub_100295E8C((uint64_t)&v49, (uint64_t)&v48, Current_5);
          unint64_t v33 = v56;
          if (v56 >= v57)
          {
            uint64_t v34 = sub_10028E280(&v55, v47 + 40, (uint64_t)&v48, v12);
          }
          else
          {
            sub_10028E3C0((uint64_t)&v57, v56, v47 + 40, (uint64_t)&v48, v12);
            uint64_t v34 = v33 + 112;
          }
          uint64_t v23 = v47;
          unint64_t v56 = v34;
          double v35 = sub_100342BCC(v11, -(int)v8);
          std::to_string(&v67, v35);
          uint64_t v36 = a1[1];
          LODWORD(__p) = 0;
          sub_100201BE4(v36, (long long *)v12, (unsigned int *)&__p, (uint64_t)&v67, buf);
          if (v66[56])
          {
            sub_1002D11FC((uint64_t)v66, &__p);
            sub_100293EF4((uint64_t)a1, (uint64_t)&v51, (uint64_t)&__p);
            if (__p)
            {
              v61[0] = __p;
              operator delete(__p);
            }
          }
          else
          {
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A2C50);
            }
            __int16 v37 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
            {
              long long __p = (void *)68289026;
              LOWORD(v61[0]) = 2082;
              *(void *)((char *)v61 + 2) = "";
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi Channel Histogram analytics was not sent since not enough time elapsed\"}", (uint8_t *)&__p, 0x12u);
            }
          }
          sub_100288C48((uint64_t)buf);
          if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v67.__r_.__value_.__l.__data_);
          }
          sub_10026CC30((wireless_diagnostics::google::protobuf::MessageLite *)&v48);
          sub_10026B1E4((uint64_t *)&v49);
          if (v51)
          {
            long long v52 = v51;
            operator delete(v51);
          }
          sub_1000D7D80((uint64_t)v53);
        }
        uint64_t v10 = v23 + 64;
      }
      while (v10 != v46);
      if (v55 == v56) {
        goto LABEL_78;
      }
      if (sub_100287C70(a1[1]))
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C50);
        }
        double v40 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)uint64_t buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)double v63 = 2082;
          *(void *)&v63[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi Channel Histogram generated successfully\"}", buf, 0x12u);
        }
        (*(void (**)(void))(*(void *)*a1 + 16))();
      }
      else
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C50);
        }
        uint64_t v45 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)double v63 = 2082;
          *(void *)&v63[2] = "";
          __int16 v64 = 1026;
          LODWORD(v65) = 0;
          unint64_t v42 = "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly\", \"Inserted\":%{public}hhd}";
          uint64_t v43 = v45;
          uint32_t v44 = 24;
          goto LABEL_82;
        }
      }
    }
LABEL_83:
    *(void *)uint64_t buf = &v55;
    sub_1002283E4((void ***)buf);
  }
  *(void *)uint64_t buf = &v58;
  sub_10020D8FC((void ***)buf);
}

void sub_100295CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  a17 = &a45;
  sub_1002283E4((void ***)&a17);
  a17 = &a48;
  sub_10020D8FC((void ***)&a17);
  _Unwind_Resume(a1);
}

void sub_100295E8C(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  sub_10023E1B0(a2);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  if (!sub_10016E644(v6)) {
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  }
  int v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_1002E6734(a2, a1);
}

void sub_100295F20(_Unwind_Exception *a1)
{
  sub_10026CC30(v1);
  _Unwind_Resume(a1);
}

void sub_100295F34(uint64_t a1, uint64_t a2)
{
  if (sub_1002943F8())
  {
    sub_1001EF9DC((uint64_t)v18, a2);
    sub_100296160(a1, (uint64_t)v18, &v10);
    sub_1001EFA74(v18);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v4 = qword_102419458;
    BOOL v5 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT);
    unsigned int v6 = v10;
    int v7 = v11;
    if (v5)
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      double v15 = "";
      __int16 v16 = 2050;
      uint64_t v17 = (v11 - v10) >> 3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.AssociatedState\", \"num events\":%{public}lu}", buf, 0x1Cu);
    }
    if (v6 != v7)
    {
      char v9 = v6;
      do
      {
        AnalyticsSendEvent();
        v9 += 8;
      }
      while (v9 != v7);
    }
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v13 = 0;
      __int16 v14 = 2082;
      double v15 = "";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"not analyzing associated state, since sending to core-analytics is disabled\"}", buf, 0x12u);
    }
  }
}

void sub_100296130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100296160(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  unsigned int v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t buf = 68289026;
    *(_WORD *)unint64_t v82 = 2082;
    *(void *)&v82[2] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing associated state\"}", buf, 0x12u);
  }
  sub_1002057AC(*(void *)(a1 + 8), &v77);
  if (v77 == v78)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    unint64_t v57 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t buf = 68289026;
      *(_WORD *)unint64_t v82 = 2082;
      *(void *)&v82[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzeAssociationState, no LOI IDs found\"}", buf, 0x12u);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    sub_1000C7F88(buf);
    LODWORD(v62.__r_.__value_.__l.__data_) = 0;
    CFStringRef v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberDaysToAnalyzeAssociationState", 0x8000100u, kCFAllocatorNull);
    int v8 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v7, &v62);
    CFRelease(v7);
    uint64_t data_low = LODWORD(v62.__r_.__value_.__l.__data_);
    if (*(void *)v82) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v82);
    }
    if (v8) {
      uint64_t v10 = data_low;
    }
    else {
      uint64_t v10 = 7;
    }
    uint64_t v11 = +[NSDate date];
    uint64_t v76 = 0;
    long long v12 = 0uLL;
    *(_OWORD *)char v75 = 0u;
    int v13 = (char *)v77;
    int v61 = v78;
    if (v77 == v78)
    {
      uint64_t v59 = 0;
LABEL_133:
      *(_OWORD *)a3 = v12;
      a3[2] = v59;
    }
    else
    {
      uint64_t v14 = (uint64_t)v11;
      uint64_t v60 = a3;
      while (1)
      {
        uint64_t v72 = 0;
        int v73 = 0;
        uint64_t v74 = 0;
        int64_t v69 = 0;
        int64_t v70 = 0;
        uint64_t v71 = 0;
        if (v10) {
          break;
        }
        uint64_t v80 = (void **)v13;
LABEL_52:
        if (v70 != v69)
        {
          sub_100296DD4((uint64_t)&v80, &v69, (uint64_t)&v62);
          if (v66)
          {
            id v29 = objc_alloc_init((Class)NSMutableDictionary);
            [v29 setObject:&off_1023924B0 forKeyedSubscript:@"Band"];
            if (!v66
              || ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? (int v30 = &v62)
                : (int v30 = (std::string *)v62.__r_.__value_.__r.__words[0]),
                  (objc_msgSend(v29, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v30), @"rtLoiType"), !v66)|| (objc_msgSend(v29, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v63), @"NumberOfMacAddresses"), !v66)|| (objc_msgSend(v29, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v64), @"NumberOfChannels"), !v66)))
            {
              sub_10020D700();
            }
            [v29 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v65) forKeyedSubscript:@"NumberOfMacAddressAppearingOnMultipleChannels"];
            uint64_t v31 = (char *)v75[1];
            if (v75[1] >= v76)
            {
              int64_t v33 = ((char *)v75[1] - (char *)v75[0]) >> 3;
              if ((unint64_t)(v33 + 1) >> 61) {
                sub_1001D7FD4();
              }
              unint64_t v34 = (v76 - (char *)v75[0]) >> 2;
              if (v34 <= v33 + 1) {
                unint64_t v34 = v33 + 1;
              }
              if ((unint64_t)(v76 - (char *)v75[0]) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v35 = v34;
              }
              if (v35) {
                uint64_t v36 = (char *)sub_1000DA54C((uint64_t)&v76, v35);
              }
              else {
                uint64_t v36 = 0;
              }
              uint64_t v41 = &v36[8 * v33];
              *(void *)uint64_t v41 = v29;
              uint64_t v32 = v41 + 8;
              uint64_t v43 = (char *)v75[0];
              unint64_t v42 = (char *)v75[1];
              if (v75[1] != v75[0])
              {
                do
                {
                  uint64_t v44 = *((void *)v42 - 1);
                  v42 -= 8;
                  *((void *)v41 - 1) = v44;
                  v41 -= 8;
                }
                while (v42 != v43);
                unint64_t v42 = (char *)v75[0];
              }
              v75[0] = v41;
              v75[1] = v32;
              uint64_t v76 = &v36[8 * v35];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              *(void *)v75[1] = v29;
              uint64_t v32 = v31 + 8;
            }
            v75[1] = v32;
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A2C50);
            }
            uint64_t v45 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v46 = operator new(0x28uLL);
              long long __p = v46;
              long long v68 = xmmword_101D048C0;
              *uint64_t v46 = 0u;
              v46[1] = 0u;
              *(void *)((char *)v46 + 29) = 0;
              sub_1001E0650((uint64_t)v13, v46);
              if (!v66) {
                sub_10020D700();
              }
              if (v68 >= 0) {
                p_p = (const char *)&__p;
              }
              else {
                p_p = (const char *)__p;
              }
              std::string v48 = &v62;
              if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string v48 = (std::string *)v62.__r_.__value_.__r.__words[0];
              }
              *(void *)uint64_t buf = 68290563;
              *(_WORD *)unint64_t v82 = 2082;
              *(void *)&v82[2] = "";
              __int16 v83 = 2081;
              uint64_t v84 = p_p;
              __int16 v85 = 2082;
              int v86 = v48;
              __int16 v87 = 1026;
              int v88 = 5;
              __int16 v89 = 2050;
              uint64_t v90 = v63;
              __int16 v91 = 2050;
              uint64_t v92 = v64;
              __int16 v93 = 2050;
              uint64_t v94 = v65;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationAnalytics, analyzeAssociationState\", \"rtGroupLoiId\":%{private, location:escape_only}s, \"rtLoiType\":%{public, location:escape_only}s, \"Band\":%{public}d, \"numberOfMacAddresses\":%{public}llu, \"NumberOfChannels\":%{public}llu, \"NumberOfMacAddressAppearingOnMultipleChannels\":%{public}llu}", buf, 0x4Au);
              if (SHIBYTE(v68) < 0) {
                operator delete(__p);
              }
            }
            if (v66 && SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v62.__r_.__value_.__l.__data_);
            }
          }
        }
        *(void *)uint64_t buf = &v69;
        sub_10029C380((void ***)buf);
        *(void *)uint64_t buf = &v72;
        sub_10029C380((void ***)buf);
        v13 += 16;
        if (v13 == v61)
        {
          long long v12 = *(_OWORD *)v75;
          uint64_t v59 = v76;
          a3 = v60;
          goto LABEL_133;
        }
      }
      uint64_t v15 = 0;
      while (1)
      {
        uint64_t v16 = *(void *)(a2 + 24);
        if (!v16) {
          sub_10015E48C();
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 48))(v16)) {
          break;
        }
        double v17 = sub_100342BCC(v14, ~v15);
        std::to_string((std::string *)buf, v17);
        double v18 = sub_100342BCC(v14, -(int)v15);
        std::to_string(&v62, v18);
        sub_100205ADC(*(void *)(a1 + 8), (uint64_t)buf, (uint64_t)&v62, *(void *)v13, *((void *)v13 + 1), &__p);
        uint64_t v20 = __p;
        uint64_t v19 = (_DWORD *)v68;
        if (__p != (void *)v68)
        {
          uint64_t v79 = &v72;
          do
          {
            if (*((unsigned char *)v20 + 48)) {
              BOOL v21 = v20[16] == 2;
            }
            else {
              BOOL v21 = 0;
            }
            if (v21) {
              sub_10029C424((uint64_t **)&v79, (long long *)v20);
            }
            v20 += 18;
          }
          while (v20 != v19);
          uint64_t v23 = __p;
          std::string::size_type v22 = (_DWORD *)v68;
          uint64_t v79 = &v69;
          while (v23 != v22)
          {
            if (*((unsigned char *)v23 + 48)) {
              BOOL v24 = v23[16] == 5;
            }
            else {
              BOOL v24 = 0;
            }
            if (v24) {
              sub_10029C424((uint64_t **)&v79, (long long *)v23);
            }
            v23 += 18;
          }
        }
        uint64_t v80 = &__p;
        sub_10029C380(&v80);
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v62.__r_.__value_.__l.__data_);
        }
        if (SBYTE3(v84) < 0) {
          operator delete(*(void **)buf);
        }
        if (++v15 == v10)
        {
          uint64_t v80 = (void **)v13;
          if (v73 != v72)
          {
            sub_100296DD4((uint64_t)&v80, &v72, (uint64_t)&v62);
            if (v66)
            {
              id v25 = objc_alloc_init((Class)NSMutableDictionary);
              [v25 setObject:&off_102392498 forKeyedSubscript:@"Band"];
              if (!v66
                || ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? (int v26 = &v62)
                  : (int v26 = (std::string *)v62.__r_.__value_.__r.__words[0]),
                    (objc_msgSend(v25, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v26), @"rtLoiType"), !v66)|| (objc_msgSend(v25, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v63), @"NumberOfMacAddresses"), !v66)|| (objc_msgSend(v25, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v64), @"NumberOfChannels"), !v66)))
              {
                sub_10020D700();
              }
              [v25 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v65) forKeyedSubscript:@"NumberOfMacAddressAppearingOnMultipleChannels"];
              int v27 = (char *)v75[1];
              if (v75[1] >= v76)
              {
                int64_t v37 = ((char *)v75[1] - (char *)v75[0]) >> 3;
                if ((unint64_t)(v37 + 1) >> 61) {
                  sub_1001D7FD4();
                }
                unint64_t v38 = (v76 - (char *)v75[0]) >> 2;
                if (v38 <= v37 + 1) {
                  unint64_t v38 = v37 + 1;
                }
                if ((unint64_t)(v76 - (char *)v75[0]) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v39 = v38;
                }
                if (v39) {
                  double v40 = (char *)sub_1000DA54C((uint64_t)&v76, v39);
                }
                else {
                  double v40 = 0;
                }
                std::string v49 = &v40[8 * v37];
                *(void *)std::string v49 = v25;
                uint64_t v28 = v49 + 8;
                uint64_t v51 = (char *)v75[0];
                int v50 = (char *)v75[1];
                if (v75[1] != v75[0])
                {
                  do
                  {
                    uint64_t v52 = *((void *)v50 - 1);
                    v50 -= 8;
                    *((void *)v49 - 1) = v52;
                    v49 -= 8;
                  }
                  while (v50 != v51);
                  int v50 = (char *)v75[0];
                }
                v75[0] = v49;
                v75[1] = v28;
                uint64_t v76 = &v40[8 * v39];
                if (v50) {
                  operator delete(v50);
                }
              }
              else
              {
                *(void *)v75[1] = v25;
                uint64_t v28 = v27 + 8;
              }
              v75[1] = v28;
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A2C50);
              }
              long long v53 = qword_102419458;
              if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
              {
                int v54 = operator new(0x28uLL);
                long long __p = v54;
                long long v68 = xmmword_101D048C0;
                _OWORD *v54 = 0u;
                v54[1] = 0u;
                *(void *)((char *)v54 + 29) = 0;
                sub_1001E0650((uint64_t)v13, v54);
                if (!v66) {
                  sub_10020D700();
                }
                if (v68 >= 0) {
                  uint64_t v55 = (const char *)&__p;
                }
                else {
                  uint64_t v55 = (const char *)__p;
                }
                unint64_t v56 = &v62;
                if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  unint64_t v56 = (std::string *)v62.__r_.__value_.__r.__words[0];
                }
                *(void *)uint64_t buf = 68290563;
                *(_WORD *)unint64_t v82 = 2082;
                *(void *)&v82[2] = "";
                __int16 v83 = 2081;
                uint64_t v84 = v55;
                __int16 v85 = 2082;
                int v86 = v56;
                __int16 v87 = 1026;
                int v88 = 2;
                __int16 v89 = 2050;
                uint64_t v90 = v63;
                __int16 v91 = 2050;
                uint64_t v92 = v64;
                __int16 v93 = 2050;
                uint64_t v94 = v65;
                _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationAnalytics, analyzeAssociationState\", \"rtGroupLoiId\":%{private, location:escape_only}s, \"rtLoiType\":%{public, location:escape_only}s, \"Band\":%{public}d, \"numberOfMacAddresses\":%{public}llu, \"NumberOfChannels\":%{public}llu, \"NumberOfMacAddressAppearingOnMultipleChannels\":%{public}llu}", buf, 0x4Au);
                if (SHIBYTE(v68) < 0) {
                  operator delete(__p);
                }
              }
              if (v66 && SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v62.__r_.__value_.__l.__data_);
              }
            }
          }
          goto LABEL_52;
        }
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v58 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t buf = 68289282;
        *(_WORD *)unint64_t v82 = 2082;
        *(void *)&v82[2] = "";
        __int16 v83 = 2082;
        uint64_t v84 = "MicroLocationAnalytics";
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzeAssociationState cancelled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      *uint64_t v60 = 0;
      v60[1] = 0;
      v60[2] = 0;
      *(void *)uint64_t buf = &v69;
      sub_10029C380((void ***)buf);
      *(void *)uint64_t buf = &v72;
      sub_10029C380((void ***)buf);
      if (v75[0])
      {
        v75[1] = v75[0];
        operator delete(v75[0]);
      }
    }
  }
  if (v77)
  {
    uint64_t v78 = (char *)v77;
    operator delete(v77);
  }
}

void sub_100296CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a26 && a22 < 0) {
    operator delete(a17);
  }
  *(void *)(v43 - 192) = &a33;
  sub_10029C380((void ***)(v43 - 192));
  *(void *)(v43 - 192) = &a36;
  sub_10029C380((void ***)(v43 - 192));
  if (a39)
  {
    a40 = (uint64_t)a39;
    operator delete(a39);
  }
  if (a42)
  {
    a43 = (uint64_t)a42;
    operator delete(a42);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100296DD4@<X0>(uint64_t result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *a2;
  BOOL v5 = a2[1];
  if (v5 == *a2)
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 48) = 0;
  }
  else
  {
    unsigned int v6 = (uint64_t *)result;
    long long v29 = 0u;
    long long v30 = 0u;
    int v31 = 1065353216;
    long long v26 = 0u;
    long long v27 = 0u;
    int v28 = 1065353216;
    long long v23 = 0u;
    long long v24 = 0u;
    int v25 = 1065353216;
    do
    {
      sub_10029A978((uint64_t)&v29, v4, (uint64_t)v4);
      CFStringRef v7 = (int *)(v4 + 56);
      __p[0] = (void *)sub_1000D8908((uint64_t)v7);
      *(void *)uint64_t buf = __p;
      int v8 = (uint64_t **)sub_10029AC9C((uint64_t)&v23, (unint64_t *)__p, (uint64_t)&unk_101D0B290, (uint64_t **)buf);
      v7 += 3;
      sub_1000EDED4(v8 + 3, v7, v7);
      sub_10029AF50((uint64_t)&v26, v7, v7);
      uint64_t v4 = (unsigned __int8 *)(v7 + 1);
    }
    while (v4 != v5);
    if (*((void *)&v30 + 1) <= 1uLL)
    {
      if (*(char *)(v30 + 39) < 0)
      {
        sub_1000DC48C(__p, *(void **)(v30 + 16), *(void *)(v30 + 24));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(v30 + 16);
        uint64_t v22 = *(void *)(v30 + 32);
      }
      double v17 = (void *)v24;
      if ((void)v24)
      {
        uint64_t v18 = 0;
        do
        {
          if (v17[5] > 1uLL) {
            ++v18;
          }
          double v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        uint64_t v18 = 0;
      }
      uint64_t v19 = *((void *)&v24 + 1);
      uint64_t v20 = *((void *)&v27 + 1);
      if (SHIBYTE(v22) < 0)
      {
        sub_1000DC48C(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)__p;
        *(void *)&buf[16] = v22;
      }
      *(void *)&buf[24] = v19;
      *(void *)&uint8_t buf[32] = v20;
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(void *)(a3 + 16) = *(void *)&buf[16];
      *(void *)(a3 + 40) = v18;
      *(_OWORD *)(a3 + 24) = *(_OWORD *)&buf[24];
      *(unsigned char *)(a3 + 48) = 1;
      if (SHIBYTE(v22) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      char v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *v6;
        uint64_t v11 = (char *)operator new(0x28uLL);
        *(void *)(v11 + 29) = 0;
        *(_OWORD *)uint64_t v11 = 0u;
        *((_OWORD *)v11 + 1) = 0u;
        sub_1001E0650(v10, v11);
        sub_10029A854((uint64_t)&v29, ",", (uint64_t)__p);
        if (v22 >= 0) {
          long long v12 = __p;
        }
        else {
          long long v12 = (void **)__p[0];
        }
        *(void *)uint64_t buf = 68289538;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v11;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"analyzeAssociationState, loiGroupId without unique rtLoiType\", \"LoiGroupId\":%{public, location:escape_only}s, \"LoiTypes\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v22) < 0) {
          operator delete(__p[0]);
        }
        operator delete(v11);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C50);
        }
      }
      int v13 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t v14 = *v6;
        uint64_t v15 = (char *)operator new(0x28uLL);
        *(void *)(v15 + 29) = 0;
        *(_OWORD *)uint64_t v15 = 0u;
        *((_OWORD *)v15 + 1) = 0u;
        sub_1001E0650(v14, v15);
        sub_10029A854((uint64_t)&v29, ",", (uint64_t)__p);
        if (v22 >= 0) {
          uint64_t v16 = __p;
        }
        else {
          uint64_t v16 = (void **)__p[0];
        }
        *(void *)uint64_t buf = 68289538;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v15;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = v16;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "analyzeAssociationState, loiGroupId without unique rtLoiType", "{\"msg%{public}.0s\":\"analyzeAssociationState, loiGroupId without unique rtLoiType\", \"LoiGroupId\":%{public, location:escape_only}s, \"LoiTypes\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v22) < 0) {
          operator delete(__p[0]);
        }
        operator delete(v15);
      }
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 48) = 0;
    }
    sub_10029B16C((uint64_t)&v23);
    sub_1000D7D80((uint64_t)&v26);
    return sub_1002220F0((uint64_t)&v29);
  }
  return result;
}

void sub_1002971F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10029B16C((uint64_t)&a16);
  sub_1000D7D80((uint64_t)&a22);
  sub_1002220F0((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_100297264(uint64_t a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v39 = 2082;
    double v40 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing LOI usage\"}", buf, 0x12u);
  }
  if (sub_1002943F8())
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (!v5) {
      sub_10015E48C();
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 48))(v5))
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v39 = 2082;
        double v40 = "";
        __int16 v41 = 2082;
        unint64_t v42 = "MicroLocationAnalytics";
        CFStringRef v7 = "{\"msg%{public}.0s\":\"LOI usage analytics canceled\", \"Activity\":%{public, location:escape_only}s}";
        int v8 = v6;
        uint32_t v9 = 28;
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
        return;
      }
      return;
    }
    if (sub_100297894(a1))
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        long long v12 = (const char *)[@"com.apple.MicroLocation.Visit" UTF8String];
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v39 = 2082;
        double v40 = "";
        __int16 v41 = 2082;
        unint64_t v42 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics event.\", \"Event name\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      AnalyticsSendEvent();
    }
    unint64_t v35 = 0;
    uint64_t v36 = 0;
    int64_t v37 = 0;
    sub_1001FF120(*(void *)(a1 + 8), &v33);
    uint64_t v13 = v33;
    uint64_t v14 = v34;
    if (v33 == v34)
    {
LABEL_45:
      *(void *)uint64_t buf = &v33;
      sub_10020D8FC((void ***)buf);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      int v28 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        long long v29 = (const char *)[@"com.apple.MicroLocation.Location" UTF8String];
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v39 = 2082;
        double v40 = "";
        __int16 v41 = 2082;
        unint64_t v42 = v29;
        __int16 v43 = 2050;
        uint64_t v44 = (v36 - v35) >> 3;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics events.\", \"Event name\":%{public, location:escape_only}s, \"Number of events\":%{public}lu}", buf, 0x26u);
      }
      long long v30 = v35;
      int v31 = v36;
      if (v35 == v36) {
        goto LABEL_58;
      }
      do
      {
        AnalyticsSendEvent();
        v30 += 8;
      }
      while (v30 != v31);
    }
    else
    {
      while (1)
      {
        uint64_t v15 = *(void *)(a2 + 24);
        if (!v15) {
          sub_10015E48C();
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 48))(v15)) {
          break;
        }
        id v16 = sub_100297D6C(a1, (uint64_t *)(v13 + 24));
        id v17 = v16;
        if (v16)
        {
          uint64_t v18 = v36;
          if (v36 >= v37)
          {
            uint64_t v20 = (v36 - v35) >> 3;
            if ((unint64_t)(v20 + 1) >> 61) {
              sub_1001D7FD4();
            }
            unint64_t v21 = (v37 - v35) >> 2;
            if (v21 <= v20 + 1) {
              unint64_t v21 = v20 + 1;
            }
            if ((unint64_t)(v37 - v35) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v21;
            }
            if (v22) {
              long long v23 = (char *)sub_1000DA54C((uint64_t)&v37, v22);
            }
            else {
              long long v23 = 0;
            }
            long long v24 = &v23[8 * v20];
            *(void *)long long v24 = v17;
            uint64_t v19 = v24 + 8;
            long long v26 = v35;
            int v25 = v36;
            if (v36 != v35)
            {
              do
              {
                uint64_t v27 = *((void *)v25 - 1);
                v25 -= 8;
                *((void *)v24 - 1) = v27;
                v24 -= 8;
              }
              while (v25 != v26);
              int v25 = v35;
            }
            unint64_t v35 = v24;
            uint64_t v36 = v19;
            int64_t v37 = &v23[8 * v22];
            if (v25) {
              operator delete(v25);
            }
          }
          else
          {
            *(void *)uint64_t v36 = v16;
            uint64_t v19 = v18 + 8;
          }
          uint64_t v36 = v19;
        }
        v13 += 64;
        if (v13 == v14) {
          goto LABEL_45;
        }
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v32 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v39 = 2082;
        double v40 = "";
        __int16 v41 = 2082;
        unint64_t v42 = "MicroLocationAnalytics";
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI usage analytics canceled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      *(void *)uint64_t buf = &v33;
      sub_10020D8FC((void ***)buf);
    }
    long long v30 = v35;
LABEL_58:
    if (v30)
    {
      uint64_t v36 = v30;
      operator delete(v30);
    }
    return;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v39 = 2082;
    double v40 = "";
    CFStringRef v7 = "{\"msg%{public}.0s\":\"not analyzing Locations of Interest usage, since sending to core-analytics is disabled\"}";
    int v8 = v10;
    uint32_t v9 = 18;
    goto LABEL_16;
  }
}

void sub_100297840(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100297894(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  id v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2082;
    *(void *)&buf[20] = [@"com.apple.MicroLocation.Visit" UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  sub_1001FF120(*(void *)(a1 + 8), (uint64_t *)&v28);
  uint64_t v3 = v28;
  uint64_t v4 = v29;
  if (v28 == v29)
  {
    BOOL v6 = 0;
    uint64_t v8 = (uint64_t)v28;
  }
  else
  {
    uint64_t v5 = v28 + 4;
    do
    {
      BOOL v6 = *(long long *)((char *)v5 - 40) == 0;
      BOOL v7 = *(long long *)((char *)v5 - 40) == 0 || v5 == v29;
      v5 += 4;
    }
    while (!v7);
    uint64_t v8 = (uint64_t)v28;
    while (*(_OWORD *)(v8 + 24) != 0)
    {
      v8 += 64;
      if ((long long *)v8 == v29)
      {
        uint64_t v3 = v29;
        uint64_t v8 = (uint64_t)v29;
        goto LABEL_26;
      }
    }
    if ((long long *)v8 == v29 || (uint64_t v9 = v8 + 64, (long long *)(v8 + 64) == v29))
    {
      uint64_t v3 = v29;
    }
    else
    {
      do
      {
        *(void *)uint64_t buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        if (*(_OWORD *)(v9 + 24) != 0)
        {
          long long v10 = *(_OWORD *)v9;
          long long v11 = *(_OWORD *)(v9 + 16);
          *(void *)(v8 + 32) = *(void *)(v9 + 32);
          *(_OWORD *)uint64_t v8 = v10;
          *(_OWORD *)(v8 + 16) = v11;
          long long v12 = (void **)(v8 + 40);
          if (*(char *)(v8 + 63) < 0) {
            operator delete(*v12);
          }
          long long v13 = *(_OWORD *)(v9 + 40);
          *(void *)(v8 + 56) = *(void *)(v9 + 56);
          *(_OWORD *)long long v12 = v13;
          *(unsigned char *)(v9 + 63) = 0;
          *(unsigned char *)(v9 + 40) = 0;
          v8 += 64;
        }
        v9 += 64;
      }
      while ((long long *)v9 != v4);
      uint64_t v3 = v29;
    }
  }
LABEL_26:
  sub_10029861C((uint64_t)&v28, v8, v3);
  memset(buf, 0, sizeof(buf));
  int v32 = 1065353216;
  uint64_t v15 = (uint64_t)v28;
  uint64_t v14 = v29;
  if (v28 == v29)
  {
    uint64_t v17 = (uint64_t)v28;
  }
  else
  {
    do
    {
      __p[0] = (void *)(v15 + 40);
      id v16 = sub_10029C88C((uint64_t)buf, (unsigned __int8 *)(v15 + 40), (uint64_t)&unk_101D0B290, (long long **)__p);
      ++*((void *)v16 + 5);
      v15 += 64;
    }
    while ((long long *)v15 != v14);
    uint64_t v15 = (uint64_t)v28;
    uint64_t v17 = (uint64_t)v29;
  }
  sub_100134750(__p, "home");
  long long v30 = __p;
  uint64_t v18 = *((void *)sub_10029CBD0((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101D0B290, (long long **)&v30) + 5);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  sub_100134750(__p, "work");
  long long v30 = __p;
  uint64_t v19 = *((void *)sub_10029CBD0((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101D0B290, (long long **)&v30) + 5);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  sub_100134750(__p, "airplay");
  long long v30 = __p;
  uint64_t v20 = *((void *)sub_10029CBD0((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101D0B290, (long long **)&v30) + 5);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  int v21 = sub_1002986A4(*(void *)(a1 + 8));
  int v22 = sub_1002028FC(*(void *)(a1 + 8));
  id v23 = +[NSMutableDictionary dictionary];
  uint64_t v24 = (v17 - v15) >> 6;
  [v23 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v24) forKeyedSubscript:@"loiCount"];
  [v23 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v18) forKeyedSubscript:@"loiHomeCount"];
  [v23 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v19) forKeyedSubscript:@"loiWorkCount"];
  [v23 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v20)] forKeyedSubscript:@"loiAirplayCount"];
  [v23 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v24 - v18) forKeyedSubscript:@"loiNotHomeCount"];
  [v23 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v6) forKeyedSubscript:@"hasLegacy"];
  [v23 setObject:+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", (v21 - v22)) forKeyedSubscript:@"deduplicatedLoiCount"];
  sub_1002220F0((uint64_t)buf);
  *(void *)uint64_t buf = &v28;
  sub_10020D8FC((void ***)buf);
  return v23;
}

void sub_100297D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1002220F0((uint64_t)&a20);
  a20 = &a15;
  sub_10020D8FC((void ***)&a20);
  _Unwind_Resume(a1);
}

id sub_100297D6C(uint64_t a1, uint64_t *a2)
{
  memset(&v40, 0, sizeof(v40));
  if ((sub_1001E86C0((uint64_t)a2, &v40) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)uint64_t buf = &off_10229E8C8;
    sub_1001E91E8((uint64_t)buf);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [@"com.apple.MicroLocation.Location" UTF8String];
    BOOL v6 = &v40;
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      BOOL v6 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v44 = 2082;
    *(void *)&v44[2] = "";
    *(_WORD *)&v44[10] = 2082;
    *(void *)&v44[12] = v5;
    __int16 v45 = 2082;
    uint64_t v46 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s, \"LOI Group ID\":%{public, location:escape_only}s}", buf, 0x26u);
  }
  sub_100202BCC(*(void *)(a1 + 8), (uint64_t)a2, &v38);
  uint64_t v8 = v38;
  BOOL v7 = v39;
  if (v39 == v38)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v24 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_1001E86C0((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
        sub_1001E91E8((uint64_t)__p);
      }
      int v25 = &v37;
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v25 = (std::string *)v37.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"No LOI entries for specified LOI Group ID\", \"LOIGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
    }
    long long v26 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_1001E86C0((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
        sub_1001E91E8((uint64_t)__p);
      }
      char v27 = &v37;
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        char v27 = (std::string *)v37.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v27;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v26, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No LOI entries for specified LOI Group ID", "{\"msg%{public}.0s\":\"No LOI entries for specified LOI Group ID\", \"LOIGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
    }
    id v28 = 0;
  }
  else
  {
    memset(&v37, 0, sizeof(v37));
    uint64_t v34 = &v37;
    do
    {
      memset(__p, 0, 24);
      if ((sub_1001E86C0((uint64_t)(v8 + 1), __p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)uint64_t buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      sub_1002748CC((uint64_t **)&v34, (long long *)__p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      v8 += 8;
    }
    while (v8 != v7);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      int v10 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v40.__r_.__value_.__r.__words[0];
      sub_1001D4530(",", (uint64_t *)&v37, (uint64_t)__p);
      long long v12 = &v40;
      if (v10 < 0) {
        long long v12 = (std::string *)v11;
      }
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v13 = __p;
      }
      else {
        long long v13 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v12;
      __int16 v45 = 2082;
      uint64_t v46 = v13;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"LOIs for LOI Group Id\", \"LOI Group ID\":%{public, location:escape_only}s, \"LOI IDs\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    sub_100202F14(*(void *)(a1 + 8), (uint64_t)a2, __p);
    if (v50) {
      double v14 = *(double *)&__p[0].__r_.__value_.__r.__words[2];
    }
    else {
      double v14 = -1.79769313e308;
    }
    uint64_t v34 = 0;
    unint64_t v35 = 0;
    uint64_t v36 = 0;
    uint64_t v15 = v38;
    id v16 = v39;
    unint64_t v42 = &v34;
    if (v38 == v39)
    {
      uint64_t v17 = 0;
    }
    else
    {
      do
      {
        uint64_t v41 = *v15;
        sub_10029CE5C((uint64_t *)&v42, &v41);
        v15 += 8;
      }
      while (v15 != v16);
      uint64_t v17 = (double *)v34;
      uint64_t v18 = (double *)((char *)v34 + 8);
      if (v34 != v35 && v18 != (double *)v35)
      {
        double v20 = *(double *)v34;
        int v21 = (double *)((char *)v34 + 8);
        do
        {
          double v22 = *v21++;
          double v23 = v22;
          if (v20 < v22)
          {
            double v20 = v23;
            uint64_t v17 = v18;
          }
          uint64_t v18 = v21;
        }
        while (v21 != (double *)v35);
      }
    }
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_1001FE6C0(*(void *)(a1 + 8), 0, *a2, a2[1], buf);
    id v28 = +[NSMutableDictionary dictionary];
    if (*(unsigned char *)a2)
    {
      BOOL v30 = 0;
    }
    else
    {
      unint64_t v31 = 0;
      do
      {
        unint64_t v32 = v31;
        if (v31 == 15) {
          break;
        }
        ++v31;
      }
      while (!*((unsigned char *)a2 + v32 + 1));
      BOOL v30 = v32 > 0xE;
    }
    [v28 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v30, v34) forKeyedSubscript:@"isLoiLegacy"];
    [v28 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (((char *)v39 - (char *)v38) >> 6) - 1) forKeyedSubscript:@"deduplicatedLoiCount"];
    if (v17 != (double *)v35) {
      [v28 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current_5 - *v17) forKeyedSubscript:@"lastSeenAge"];
    }
    [v28 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v50) forKeyedSubscript:@"hasRecordings"];
    if (v50) {
      [v28 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current_5 - v14) forKeyedSubscript:@"lastRecordingAge"];
    }
    [v28 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v48) forKeyedSubscript:@"isModelExists"];
    if (v48) {
      [v28 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v47) forKeyedSubscript:@"isModelStable"];
    }
    sub_1001EF39C((uint64_t)buf);
    if (v34)
    {
      unint64_t v35 = (char *)v34;
      operator delete(v34);
    }
    sub_10029B1F0((uint64_t)__p);
    *(void *)uint64_t buf = &v37;
    sub_1000A7B4C((void ***)buf);
  }
  *(void *)uint64_t buf = &v38;
  sub_10020D8FC((void ***)buf);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  return v28;
}

void sub_100298528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,std::bad_cast a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::bad_cast::~bad_cast(&a65);
  if (a17 < 0) {
    operator delete(__p);
  }
  a29.__vftable = (std::bad_cast_vtbl *)&a18;
  sub_10020D8FC((void ***)&a29);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10029861C(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    sub_10020DDA4((uint64_t)&v9, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0) {
          operator delete(*(void **)(v7 - 24));
        }
        v7 -= 64;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_1002986A4(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    return sub_1001FA340(a1, "MiLoLoiTable");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntries() [Table = CLMiLoLoiTable]", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    return 0;
  }
}

void sub_100298888(void *a1, uint64_t a2)
{
  if (sub_1002943F8())
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing daily trigger usage\"}", (uint8_t *)&v11, 0x12u);
    }
    sub_1001EF9DC((uint64_t)v19, a2);
    id v5 = sub_100298C00(a1, (uint64_t)v19);
    sub_1001EFA74(v19);
    if (v5)
    {
      uint64_t v6 = *(void *)(a2 + 24);
      if (!v6) {
        sub_10015E48C();
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 48))(v6))
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C50);
        }
        uint64_t v7 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 68289026;
          int v12 = 0;
          __int16 v13 = 2082;
          double v14 = "";
          uint64_t v8 = "{\"msg%{public}.0s\":\"Trigger types analytics canceled\"}";
LABEL_21:
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v11, 0x12u);
        }
      }
      else
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A2C50);
        }
        char v9 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          id v10 = [@"com.apple.microlocation.triggers.daily" UTF8String];
          int v11 = 68289539;
          int v12 = 0;
          __int16 v13 = 2082;
          double v14 = "";
          __int16 v15 = 2082;
          id v16 = v10;
          __int16 v17 = 2113;
          id v18 = v5;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics event\", \"Event name\":%{public, location:escape_only}s, \"event\":%{private, location:escape_only}@}", (uint8_t *)&v11, 0x26u);
        }
        AnalyticsSendEvent();
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      uint64_t v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        double v14 = "";
        uint64_t v8 = "{\"msg%{public}.0s\":\"daily trigger analytics event was not created.\"}";
        goto LABEL_21;
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      uint64_t v8 = "{\"msg%{public}.0s\":\"not analyzing trigger types, since sending to core-analytics is disabled\"}";
      goto LABEL_21;
    }
  }
}

void sub_100298BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

id sub_100298C00(void *a1, uint64_t a2)
{
  uint64_t v4 = +[NSDate date];
  double v5 = sub_100342BCC((uint64_t)v4, -1);
  double v6 = sub_100342BCC((uint64_t)v4, 0);
  (*(void (**)(void))(*(void *)*a1 + 24))();
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    sub_10015E48C();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48))(v7))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      buf.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Trigger types analytics canceled\"}", (uint8_t *)&buf, 0x12u);
    }
    return 0;
  }
  else
  {
    uint64_t v10 = a1[1];
    std::to_string(&buf, v5);
    std::to_string(&v33, v6);
    int v11 = operator new(4uLL);
    long long __p = v11;
    _DWORD *v11 = 48;
    unint64_t v28 = (unint64_t)(v11 + 1);
    long long v29 = v11 + 1;
    sub_1002011D8(v10, (uint64_t)&buf, (uint64_t)&v33, (uint64_t)&__p, &v30);
    if (__p)
    {
      unint64_t v28 = (unint64_t)__p;
      operator delete(__p);
    }
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    long long __p = 0;
    unint64_t v28 = 0;
    long long v29 = 0;
    uint64_t v13 = v30;
    uint64_t v12 = v31;
    if (v30 != v31)
    {
      unint64_t v14 = 0;
      do
      {
        if (*(_DWORD *)(v13 + 24) == 48 && (*(unsigned char *)(v13 + 327) & 8) != 0)
        {
          uint64_t v15 = *(void *)(v13 + 256);
          if (!v15) {
            uint64_t v15 = *(void *)(qword_102489AB8 + 224);
          }
          if (v14 >= (unint64_t)v29)
          {
            unint64_t v14 = sub_10029D5AC((uint64_t *)&__p, v15);
          }
          else
          {
            sub_100267E74(v14, v15);
            v14 += 88;
          }
          unint64_t v28 = v14;
          uint64_t v12 = v31;
        }
        v13 += 336;
      }
      while (v13 != v12);
    }
    sub_100341800(&buf, &__p);
    unint64_t v16 = sub_100341AF0((uint64_t)&buf);
    unint64_t v17 = sub_100341D70((uint64_t)&buf);
    unint64_t v18 = sub_100341CD0((uint64_t)&buf);
    unint64_t v19 = sub_100341EB4((uint64_t)&buf, 1u, 1);
    unint64_t v20 = sub_100341EB4((uint64_t)&buf, 0, 1);
    id v9 = objc_alloc_init((Class)NSMutableDictionary);
    [v9 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341860((uint64_t)&buf)) forKeyedSubscript:@"TotalRecordings"];
    [v9 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341A50((uint64_t)&buf)) forKeyedSubscript:@"TotalLocalizations"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v16)] forKeyedSubscript:@"TotalLegacyLocalizations"];
    [v9 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341B90((uint64_t)&buf)) forKeyedSubscript:@"TotalCachedLegacyLocalizations"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341C30((uint64_t)&buf))] forKeyedSubscript:@"TotalNonCachedLegacyLocalizations"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v17)] forKeyedSubscript:@"TotalMotionLocalizations"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v20)] forKeyedSubscript:@"TotalMotionLocalizationsWhileDisplayOn"];
    [v9 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v19) forKeyedSubscript:@"TotalMotionLocalizationsWhenDisplayTurnedOn"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341EB4((uint64_t)&buf, 2u, 1))] forKeyedSubscript:@"TotalMotionLocalizationsWhenRescheduled"];
    [v9 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v18) forKeyedSubscript:@"TotalNewLocalizations"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341E10((uint64_t)&buf, 1u))] forKeyedSubscript:@"TotalLocalizationsWhenDisplayTurnedOn"];
    [v9 setObject:[+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100341E10((uint64_t)&buf, 2u))] forKeyedSubscript:@"TotalLocalizationsWhenRescheduled"];
    sub_10029A148((uint64_t)a1, v9, v5, v6);
    sub_10029A4C0((uint64_t)a1, v9, v5, v6);
    sub_1000C7F88(&v33);
    int v32 = 0;
    unint64_t v22 = (unint64_t)CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsTriggerCountThreshold", 0x8000100u, kCFAllocatorNull);
    int v21 = sub_1004D08E4((uint64_t)v33.__r_.__value_.__l.__data_, v22, &v32);
    CFRelease((CFTypeRef)v22);
    LODWORD(v22) = v32;
    if (v33.__r_.__value_.__l.__size_) {
      sub_1000DB0A0((std::__shared_weak_count *)v33.__r_.__value_.__l.__size_);
    }
    if (v21) {
      unint64_t v22 = v22;
    }
    else {
      unint64_t v22 = 5;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    double v23 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      v33.__r_.__value_.__r.__words[0] = 68290050;
      LOWORD(v33.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v33.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      WORD1(v33.__r_.__value_.__r.__words[2]) = 1026;
      HIDWORD(v33.__r_.__value_.__r.__words[2]) = v22;
      __int16 v34 = 2050;
      unint64_t v35 = v16;
      __int16 v36 = 2050;
      unint64_t v37 = v17;
      __int16 v38 = 2050;
      unint64_t v39 = v18;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Adding ratios to trigger analytics if appropriate\", \"TriggerThreshold\":%{public}d, \"TotalLegacyLocalizations\":%{public}lu, \"TotalMotionLocalizations\":%{public}lu, \"TotalNewLocalizations\":%{public}lu}", (uint8_t *)&v33, 0x36u);
    }
    if (v16)
    {
      if (v17 >= v22 && v16 >= v22)
      {
        *(float *)&double v24 = (float)v17 / (float)v16;
        [v9 setObject:[+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v24)] forKeyedSubscript:@"MotionLocalizationAndLegacyLocalizationsRatio"];
      }
      if (v18 >= v22 && v16 >= v22)
      {
        *(float *)&double v24 = (float)v18 / (float)v16;
        [v9 setObject:+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v24) forKeyedSubscript:@"NewLocalizationAndLegacyLocalizationsRatio"];
      }
    }
    if (v19 && v20 >= v22 && v19 >= v22)
    {
      *(float *)&double v24 = (float)v20 / (float)v19;
      [v9 setObject:[+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v24)] forKeyedSubscript:@"MotionWhileDisplayOnAndWhenDisplayTurnedOnRatio"];
    }
    *(double *)&v33.__r_.__value_.__l.__data_ = v6;
    int v25 = sub_100299C50((uint64_t)a1, (double *)&v33);
    if (v25 != 255) {
      [v9 setObject:+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v25 == 1) forKeyedSubscript:@"isLowObservationLegacyClient"];
    }
    sub_1001EF3E8(v42);
    v33.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
    sub_10029D4EC((void ***)&v33);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
    sub_10029D4EC((void ***)&buf);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
    sub_10021A7F0((void ***)&buf);
  }
  return v9;
}

void sub_100299370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char *p_p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  p_p = (char *)&__p;
  sub_10029D4EC((void ***)&p_p);
  p_p = &a13;
  sub_10021A7F0((void ***)&p_p);
  _Unwind_Resume(a1);
}

uint64_t sub_100299444(uint64_t a1, double *a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (*a3 >= *a2)
  {
    std::to_string(&v26, *a2);
    std::to_string(&v25, *a3);
    sub_100201554(*(void *)(a1 + 8), (uint64_t)&v26, a4, buf);
    if (v30)
    {
      uint64_t v12 = *(void *)(a5 + 24);
      if (!v12) {
        sub_10015E48C();
      }
      int v13 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v12 + 48))(v12, buf);
      char v14 = v13;
      if (v13) {
        double v15 = *a2;
      }
      else {
        double v15 = 0.0;
      }
    }
    else
    {
      char v14 = 0;
      double v15 = 0.0;
    }
    sub_1002011D8(*(void *)(a1 + 8), (uint64_t)&v26, (uint64_t)&v25, a4, v24);
    uint64_t v16 = v24[0];
    uint64_t v17 = v24[1];
    double v18 = 0.0;
    while (v16 != v17)
    {
      uint64_t v19 = *(void *)(a5 + 24);
      if (!v19) {
        sub_10015E48C();
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, v16))
      {
        if (!v14)
        {
          double v15 = *(double *)(v16 + 16);
          char v14 = 1;
        }
      }
      else if (v14)
      {
        char v14 = 0;
        double v18 = v18 + *(double *)(v16 + 16) - v15;
      }
      else
      {
        char v14 = 0;
      }
      v16 += 336;
    }
    if (v14) {
      double v20 = *a3 - v15;
    }
    else {
      double v20 = -0.0;
    }
    char v27 = (void **)v24;
    sub_10021A7F0(&v27);
    if (v30) {
      sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v29);
    }
    double v21 = v18 + v20;
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    uint64_t v6 = (uint64_t)v21;
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    double v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "got start time bigger than end time while calculating milo spectating duration", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      LOWORD(v26.__r_.__value_.__l.__data_) = 0;
      double v23 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "cl::chrono::seconds CLMicroLocationAnalytics::getMiLoSpectatingDuration(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const std::vector<CLMicroLocationProto::EventType> &, const std::function<BOOL (const CLMicroLocationLoggedEventsTable::Entry &)> &) const", "%s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
    return 0;
  }
  return v6;
}

void sub_1002997A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a69) {
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&a31);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void sub_100299818(uint64_t a1, void *a2, void *a3, uint64_t a4, double *a5)
{
  if (*a5 <= 0.0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    std::string v26 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Tried to add count per hour fields with duration equals 0.", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      LOWORD(v32) = 0;
      char v27 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const", "%s\n", v27);
      if (v27 != (char *)buf) {
        free(v27);
      }
    }
  }
  else
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v9 = [a3 countByEnumeratingWithState:&v28 objects:v40 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v29;
      do
      {
        uint64_t v12 = 0;
        do
        {
          if (*(void *)v29 != v11) {
            objc_enumerationMutation(a3);
          }
          int v13 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v12);
          id v14 = [a2 objectForKey:v13];
          if (v14)
          {
            [v14 doubleValue];
            double v16 = v15 / *a5;
            id v17 = [v13 stringByAppendingString:a4];
            *(float *)&double v18 = v16;
            [a2 setObject:[+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v18)] forKeyedSubscript:v17];
          }
          else
          {
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A2C50);
            }
            uint64_t v19 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
            {
              id v20 = [v13 UTF8String];
              id v21 = [@"com.apple.microlocation.triggers.daily" UTF8String];
              *(_DWORD *)std::string buf = 136315394;
              id v37 = v20;
              __int16 v38 = 2080;
              id v39 = v21;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "no value found for key %s in %s CA event. Skipping it.", buf, 0x16u);
            }
            if (sub_10013D1A0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A2C50);
              }
              id v22 = [v13 UTF8String];
              id v23 = [@"com.apple.microlocation.triggers.daily" UTF8String];
              int v32 = 136315394;
              id v33 = v22;
              __int16 v34 = 2080;
              id v35 = v23;
              double v24 = (char *)_os_log_send_and_compose_impl();
              sub_1004BA5E4("Generic", 1, 0, 0, "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const", "%s\n", v24);
              if (v24 != (char *)buf) {
                free(v24);
              }
            }
          }
          uint64_t v12 = (char *)v12 + 1;
        }
        while (v10 != v12);
        id v25 = [a3 countByEnumeratingWithState:&v28 objects:v40 count:16];
        id v10 = v25;
      }
      while (v25);
    }
  }
}

uint64_t sub_100299C50(uint64_t a1, double *a2)
{
  double v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  std::to_string(&v19, *a2 + -172800.0);
  std::to_string(&v20, v2);
  uint64_t v4 = operator new(4uLL);
  long long __p = v4;
  *uint64_t v4 = 49;
  double v15 = v4 + 1;
  double v16 = v4 + 1;
  sub_1002011D8(v3, (uint64_t)&v19, (uint64_t)&v20, (uint64_t)&__p, &v17);
  if (__p)
  {
    double v15 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  double v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v19.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v19.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v18 - v17) >> 4);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Selected %lu Legacy status updates", (uint8_t *)&v19, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v19, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    LODWORD(v20.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v20.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v18 - v17) >> 4);
    uint64_t v12 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsState(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const", "%s\n", (const char *)v12);
    if (v12 != &v19) {
      free(v12);
    }
  }
  uint64_t v6 = v18;
  while (v6 != v17)
  {
    uint64_t v7 = *(void *)(v6 - 72);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_102489AB8 + 232);
    }
    uint64_t v8 = *(unsigned int *)(v7 + 12);
    v6 -= 336;
    if (v8 != 255)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A2C50);
      }
      id v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        v19.__r_.__value_.__r.__words[0] = 68289282;
        LOWORD(v19.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&v19.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(v19.__r_.__value_.__r.__words[2]) = 1026;
        HIDWORD(v19.__r_.__value_.__r.__words[2]) = v8 != 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"legacy client low number of observation status found\", \"number of observation status\":%{public}hhd}", (uint8_t *)&v19, 0x18u);
      }
      goto LABEL_27;
    }
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  id v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Could not determine legacy client low number of observation status.", (uint8_t *)&v19, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v19, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
    LOWORD(v20.__r_.__value_.__l.__data_) = 0;
    int v13 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsState(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const", "%s\n", (const char *)v13);
    if (v13 != &v19) {
      free(v13);
    }
  }
  uint64_t v8 = 255;
LABEL_27:
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v17;
  sub_10021A7F0((void ***)&v19);
  return v8;
}

void sub_10029A0D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  a17 = &a14;
  sub_10021A7F0((void ***)&a17);
  _Unwind_Resume(a1);
}

void *sub_10029A148(uint64_t a1, void *a2, double a3, double a4)
{
  v33[0] = off_1022A2F00;
  v33[3] = v33;
  *(double *)&v26.__r_.__value_.__l.__data_ = a3;
  *(double *)&v25.__r_.__value_.__l.__data_ = a4;
  uint64_t v8 = operator new(0xCuLL);
  *(void *)long long v28 = v8 + 3;
  *(void *)&v28[8] = v8 + 3;
  *(void *)uint64_t v8 = 0x220000002CLL;
  v8[2] = 35;
  long long __p = v8;
  uint64_t v9 = sub_100299444(a1, (double *)&v26, (double *)&v25, (uint64_t)&__p, (uint64_t)v33);
  if (__p)
  {
    *(void *)long long v28 = __p;
    operator delete(__p);
  }
  sub_1000C7F88(&__p);
  LODWORD(v26.__r_.__value_.__l.__data_) = 0;
  CFStringRef v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsTriggerMinimumSpectatingDuration", 0x8000100u, kCFAllocatorNull);
  int v11 = sub_1004D08E4((uint64_t)__p, (uint64_t)v10, &v26);
  CFRelease(v10);
  double v12 = (double)v9 / 3600.0;
  unsigned int data = v26.__r_.__value_.__l.__data_;
  if (*(void *)v28) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v28);
  }
  double v14 = (double)data;
  if (!v11) {
    double v14 = 1.0;
  }
  if (v12 >= v14)
  {
    id v15 = [a2 allKeys];
    long long __p = *(void **)&v12;
    sub_100299818((uint64_t)v15, a2, v15, @"PerHour", (double *)&__p);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  double v16 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v26, a3);
    int v18 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
    std::string::size_type v19 = v26.__r_.__value_.__r.__words[0];
    std::to_string(&v25, a4);
    std::string v20 = &v26;
    if (v18 < 0) {
      std::string v20 = (std::string *)v19;
    }
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      id v21 = &v25;
    }
    else {
      id v21 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
    float v22 = v12;
    long long __p = (void *)68289795;
    *(_WORD *)long long v28 = 2082;
    *(void *)&v28[2] = "";
    *(_WORD *)&v28[10] = 2082;
    *(void *)&v28[12] = v20;
    __int16 v29 = 2082;
    long long v30 = v21;
    __int16 v31 = 2049;
    double v32 = v22;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Calculated microLocation spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}", (uint8_t *)&__p, 0x30u);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    float v22 = v12;
  }
  *(float *)&double v17 = v22;
  [a2 setObject:[NSNumber numberWithFloat:v17] forKeyedSubscript:@"Duration"];
  LODWORD(v23) = vcvtmd_s64_f64(v12);
  [a2 setObject:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v23) forKeyedSubscript:@"DurationBounded"];
  return sub_10029D1CC(v33);
}

void sub_10029A458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10029D1CC(&a25);
  _Unwind_Resume(a1);
}

void *sub_10029A4C0(uint64_t a1, void *a2, double a3, double a4)
{
  v29[0] = off_1022A2F90;
  v29[3] = v29;
  *(double *)&v22.__r_.__value_.__l.__data_ = a3;
  *(double *)&v21.__r_.__value_.__l.__data_ = a4;
  uint64_t v8 = operator new(8uLL);
  long long __p = v8;
  *uint64_t v8 = 0x320000002CLL;
  *(void *)double v24 = v8 + 1;
  *(void *)&v24[8] = v8 + 1;
  uint64_t v9 = sub_100299444(a1, (double *)&v22, (double *)&v21, (uint64_t)&__p, (uint64_t)v29);
  if (__p)
  {
    *(void *)double v24 = __p;
    operator delete(__p);
  }
  double v10 = (double)v9;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  int v11 = qword_102419458;
  double v12 = v10 / 3600.0;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v22, a3);
    int v14 = SHIBYTE(v22.__r_.__value_.__r.__words[2]);
    std::string::size_type v15 = v22.__r_.__value_.__r.__words[0];
    std::to_string(&v21, a4);
    double v16 = &v22;
    if (v14 < 0) {
      double v16 = (std::string *)v15;
    }
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      double v17 = &v21;
    }
    else {
      double v17 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    float v18 = v12;
    long long __p = (void *)68289795;
    *(_WORD *)double v24 = 2082;
    *(void *)&v24[2] = "";
    *(_WORD *)&v24[10] = 2082;
    *(void *)&v24[12] = v16;
    __int16 v25 = 2082;
    std::string v26 = v17;
    __int16 v27 = 2049;
    double v28 = v18;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Calculated microLocation motion spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}", (uint8_t *)&__p, 0x30u);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    float v18 = v12;
  }
  *(float *)&double v13 = v18;
  [a2 setObject:[+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v13, v21.__r_.__value_.__r.__words[0])] forKeyedSubscript:@"MotionDuration"];
  LODWORD(v19) = vcvtmd_s64_f64(v12);
  [a2 setObject:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v19)] forKeyedSubscript:@"MotionDurationBounded"];
  return sub_10029D1CC(v29);
}

void sub_10029A724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10029D1CC(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_10029A76C(uint64_t a1)
{
  sub_1001EF3E8((unsigned int *)(a1 + 48));
  uint64_t v4 = (void **)(a1 + 24);
  sub_10029D4EC(&v4);
  double v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_10029A7C0(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10029A7F0()
{
}

void sub_10029A830()
{
}

uint64_t sub_10029A854@<X0>(uint64_t result@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(uint64_t ***)(result + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  if (v3)
  {
    int v6 = *((char *)v3 + 39);
    uint64_t v7 = v6 >= 0 ? (std::string::value_type *)(v3 + 2) : (std::string::value_type *)v3[2];
    std::string::size_type v8 = v6 >= 0 ? *((unsigned __int8 *)v3 + 39) : (std::string::size_type)v3[3];
    unint64_t result = sub_1001D8214((std::string *)a3, a3, v7, &v7[v8], v8);
    for (unint64_t i = *v3; i; unint64_t i = (uint64_t *)*i)
    {
      uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = a3;
      }
      else {
        uint64_t v11 = *(void *)a3;
      }
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(a3 + 8);
      }
      uint64_t v12 = v11 + v10;
      std::string::size_type v13 = strlen(a2);
      sub_1001D8214((std::string *)a3, v12, a2, &a2[v13], v13);
      uint64_t v14 = *(unsigned __int8 *)(a3 + 23);
      if ((v14 & 0x80u) == 0) {
        uint64_t v15 = a3;
      }
      else {
        uint64_t v15 = *(void *)a3;
      }
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(a3 + 8);
      }
      int v16 = *((char *)i + 39);
      if (v16 >= 0) {
        double v17 = (std::string::value_type *)(i + 2);
      }
      else {
        double v17 = (std::string::value_type *)i[2];
      }
      if (v16 >= 0) {
        std::string::size_type v18 = *((unsigned __int8 *)i + 39);
      }
      else {
        std::string::size_type v18 = i[3];
      }
      unint64_t result = sub_1001D8214((std::string *)a3, v15 + v14, v17, &v17[v18], v18);
    }
  }
  return result;
}

void sub_10029A954(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_10029A978(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    std::string::size_type v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (unint64_t i = *v13; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }
  sub_10029ABF8(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100100330(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  std::string v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *std::string v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  unint64_t i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_10029ABD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_10022251C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10029ABF8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x28uLL);
  *(void *)(a4 + 8) = v7;
  *(void *)a4 = v8;
  *(unsigned char *)(a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  unint64_t result = v8 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    unint64_t result = sub_1000DC48C(result, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t result = *(_OWORD *)a3;
    result[2] = *(void *)(a3 + 16);
  }
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_10029AC80(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10022251C(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_10029AC9C(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (unint64_t i = *v10; i; unint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  std::string::size_type v13 = (void *)(a1 + 16);
  unint64_t i = operator new(0x30uLL);
  void *i = 0;
  i[1] = v7;
  uint64_t v14 = **a4;
  i[5] = 0;
  i[4] = 0;
  i[2] = v14;
  i[3] = i + 4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100100330(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v21 = *(void *)a1;
  std::string v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    void *i = *v22;
LABEL_38:
    *std::string v22 = i;
    goto LABEL_39;
  }
  void *i = *v13;
  *std::string::size_type v13 = i;
  *(void *)(v21 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }
    else
    {
      v23 &= v8 - 1;
    }
    std::string v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_10029AED8(_Unwind_Exception *a1)
{
  sub_10029AEF4(v2, v1);
  _Unwind_Resume(a1);
}

void sub_10029AEF4(uint64_t a1, void **a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    sub_1000F5BB0((uint64_t)(a2 + 3), a2[4]);
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void *sub_10029AF50(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100100330(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_10029B158(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B16C(uint64_t a1)
{
  sub_10029B1A8(a1, *(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10029B1A8(uint64_t a1, void **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = *v2;
      sub_1000F5BB0((uint64_t)(v2 + 3), v2[4]);
      operator delete(v2);
      uint64_t v2 = (void **)v3;
    }
    while (v3);
  }
}

uint64_t sub_10029B1F0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240))
  {
    sub_10026633C(a1 + 80);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
  return a1;
}

void sub_10029B238()
{
}

void *sub_10029B24C(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t result = off_1022A2C80;
  result[1] = v3;
  return result;
}

uint64_t sub_10029B294(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2C80;
  a2[1] = v2;
  return result;
}

void *sub_10029B2C0(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_10029539C(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10029B348(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B36C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029B3AC()
{
}

void sub_10029B3BC()
{
}

void *sub_10029B3D0(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t result = off_1022A2D00;
  result[1] = v3;
  return result;
}

uint64_t sub_10029B418(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2D00;
  a2[1] = v2;
  return result;
}

void *sub_10029B444(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_100295F34(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10029B4CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B4F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029B530()
{
}

void sub_10029B540()
{
}

void *sub_10029B554(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t result = off_1022A2D80;
  result[1] = v3;
  return result;
}

uint64_t sub_10029B59C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2D80;
  a2[1] = v2;
  return result;
}

void *sub_10029B5C8(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_100297264(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10029B650(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B674(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029B6B4()
{
}

void sub_10029B6C4()
{
}

void *sub_10029B6D8(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t result = off_1022A2E00;
  result[1] = v3;
  return result;
}

uint64_t sub_10029B720(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A2E00;
  a2[1] = v2;
  return result;
}

void *sub_10029B74C(uint64_t a1, uint64_t a2)
{
  sub_10022EB40((uint64_t)v5, a2);
  uint64_t v3 = *(void **)(a1 + 8);
  sub_1001EF9DC((uint64_t)v6, (uint64_t)v5);
  sub_100298888(v3, (uint64_t)v6);
  sub_1001EFA74(v6);
  return sub_1001EFA74(v5);
}

void sub_10029B7D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1001EFA74((uint64_t *)va1);
  sub_1001EFA74((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B7F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029B838()
{
}

void sub_10029B848()
{
}

void *sub_10029B85C()
{
  unint64_t result = operator new(0x10uLL);
  *unint64_t result = off_1022A2E80;
  return result;
}

void sub_10029B894(uint64_t a1, void *a2)
{
  *a2 = off_1022A2E80;
}

uint64_t sub_10029B8BC()
{
  return 0;
}

uint64_t sub_10029B8C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10029B904()
{
}

void *sub_10029B910(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_10017C6FC(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_10029B96C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029B988(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      uint64_t v20 = v12 - a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - a2) >> 3)) >= a5)
      {
        uint64_t v21 = a3 + 120 * a5;
      }
      else
      {
        uint64_t v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        a1[1] = sub_10029BD1C(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }
      sub_10029BB94((uint64_t)a1, v5, v12, v5 + 120 * a5);
      sub_100216558(a3, v21, v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x222222222222222) {
        sub_1001D7FD4();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - v13) >> 3);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 3);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 3);
      }
      if (v16 >= 0x111111111111111) {
        unint64_t v18 = 0x222222222222222;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v32 = v9;
      if (v18) {
        unint64_t v19 = (char *)sub_10029BE4C(v9, v18);
      }
      else {
        unint64_t v19 = 0;
      }
      uint64_t v22 = 0;
      unint64_t v23 = &v19[120 * v15];
      v29[0] = v19;
      v29[1] = v23;
      long long v30 = v23;
      __int16 v31 = &v19[120 * v18];
      uint64_t v24 = 120 * a5;
      __int16 v25 = &v23[120 * a5];
      do
      {
        std::string v26 = &v23[v22];
        long long v27 = *(_OWORD *)(a3 + v22 + 16);
        *(_OWORD *)std::string v26 = *(_OWORD *)(a3 + v22);
        *((_OWORD *)v26 + 1) = v27;
        sub_100243254(&v23[v22 + 32], a3 + v22 + 32);
        *((_DWORD *)v26 + 28) = *(_DWORD *)(a3 + v22 + 112);
        v22 += 120;
      }
      while (v24 != v22);
      long long v30 = v25;
      uint64_t v5 = sub_10029BC68(a1, v29, v5);
      sub_10029BFF4((uint64_t)v29);
    }
  }
  return v5;
}

void sub_10029BB68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029BB94(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    uint64_t v10 = a2 + 8 * ((v6 - a4) >> 3) + 32;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      long long v11 = *(_OWORD *)(v10 - 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(v10 - 32);
      *(_OWORD *)(v8 + 16) = v11;
      sub_100243254(v8 + 32, v10);
      uint64_t v12 = v10 - 32;
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(v10 + 80);
      v8 += 120;
      v10 += 120;
    }
    while (v12 + 120 < a3);
  }
  *(void *)(a1 + 8) = v8;

  return sub_10029BDC0(a2, v7, v6);
}

void sub_10029BC60(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10029BC68(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  sub_10029BE94((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_10029BF50(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_10029BD1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a4 + v7;
      uint64_t v9 = a2 + v7;
      long long v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_100243254(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120;
    }
    while (v9 + 120 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10029BD9C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029BDC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      long long v8 = *(_OWORD *)(a2 + v6 - 120);
      *(_OWORD *)(v7 - 104) = *(_OWORD *)(a2 + v6 - 104);
      *(_OWORD *)(v7 - 120) = v8;
      sub_1002442C8(a3 + v6 - 88, a2 + v6 - 88);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(a2 + v6 - 8);
      v6 -= 120;
    }
    while (a2 + v6 != a1);
  }
  return a2;
}

void *sub_10029BE4C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    sub_1001D7FA0();
  }
  return operator new(120 * a2);
}

uint64_t sub_10029BE94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = a7 + v11;
      long long v13 = *(_OWORD *)(a3 + v11 - 120);
      *(_OWORD *)(v12 - 104) = *(_OWORD *)(a3 + v11 - 104);
      *(_OWORD *)(v12 - 120) = v13;
      sub_100243254(a7 + v11 - 88, a3 + v11 - 88);
      *(_DWORD *)(v12 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 120;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_10029BF2C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 + 32;
    do
    {
      sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 += 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029BF50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a4 + v7;
      uint64_t v9 = a2 + v7;
      long long v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_100243254(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120;
    }
    while (v9 + 120 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10029BFD0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029BFF4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)(i - 88));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10029C048(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 48;
      uint64_t v7 = v4 - 48;
      uint64_t v8 = v4 - 48;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 48;
        (*v9)(v7);
        v6 -= 48;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10029C108(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_10014F86C(v7, v9);
  }
  else {
    BOOL v10 = 0;
  }
  long long v13 = v10;
  unint64_t v14 = &v10[48 * v4];
  unint64_t v16 = &v10[48 * v9];
  sub_10023F7D0(v14, a2);
  unint64_t v15 = v14 + 48;
  sub_10029C210(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10029C314((uint64_t)&v13);
  return v11;
}

void sub_10029C1FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10029C314((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029C210(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10029C288((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10029C288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0; a3 + i != a5; sub_10023F7D0(i + a7, i + a3))
    i -= 48;
  return a6;
}

uint64_t sub_10029C314(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 48);
    *(void *)(a1 + 16) = i - 48;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10029C380(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10029C3D4((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_10029C3D4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 49) < 0) {
      operator delete(*(void **)(i - 72));
    }
  }
  a1[1] = v2;
}

uint64_t **sub_10029C424(uint64_t **a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v5 = (*a1)[1];
  unint64_t v4 = (*a1)[2];
  uint64_t v6 = *a1;
  if (v5 >= v4)
  {
    uint64_t v7 = sub_10029C4F8(v6, a2);
  }
  else
  {
    sub_10029C478((uint64_t)v6, a2);
    uint64_t v7 = v5 + 72;
  }
  v3[1] = v7;
  return a1;
}

__n128 sub_10029C478(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(*(unsigned char **)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  __n128 result = *(__n128 *)((char *)a2 + 24);
  long long v7 = *(long long *)((char *)a2 + 40);
  *(_OWORD *)(v4 + 56) = *(long long *)((char *)a2 + 56);
  *(_OWORD *)(v4 + 40) = v7;
  *(__n128 *)(v4 + 24) = result;
  *(void *)(a1 + 8) = v4 + 72;
  return result;
}

void sub_10029C4F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10029C4F8(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1C71C71C71C71C7) {
    unint64_t v9 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v21 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_10021D4B8(v7, v9);
  }
  else {
    BOOL v10 = 0;
  }
  uint64_t v11 = &v10[72 * v4];
  v18[0] = v10;
  v18[1] = v11;
  unint64_t v19 = v11;
  uint64_t v20 = &v10[72 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v19;
  }
  else
  {
    long long v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  long long v13 = &v10[72 * v4];
  long long v14 = *(long long *)((char *)a2 + 56);
  long long v15 = *(long long *)((char *)a2 + 24);
  *(_OWORD *)(v13 + 40) = *(long long *)((char *)a2 + 40);
  *(_OWORD *)(v13 + 24) = v15;
  *(_OWORD *)(v13 + 56) = v14;
  unint64_t v19 = v11 + 72;
  sub_10029C654(a1, v18);
  uint64_t v16 = a1[1];
  sub_10029C7FC((uint64_t)v18);
  return v16;
}

void sub_10029C640(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10029C7FC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029C654(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10029C6CC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10029C6CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 72);
      *(void *)(v9 - 56) = *(void *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(void *)(a3 - 64) = 0;
      *(void *)(a3 - 56) = 0;
      *(void *)(a3 - 72) = 0;
      long long v11 = *(_OWORD *)(a3 - 48);
      long long v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72;
      v7 -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    *((void *)&v17 + 1) = v9;
  }
  char v15 = 1;
  sub_10029C77C((uint64_t)v14);
  return a6;
}

uint64_t sub_10029C77C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10029C7B4(a1);
  }
  return a1;
}

void sub_10029C7B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 72;
  }
}

uint64_t sub_10029C7FC(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10029C834(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 9;
      *(void *)(a1 + 16) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

unsigned __int8 *sub_10029C88C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    long long v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (sub_100103744(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  sub_10029CB24(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100100330(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *unint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_10029CB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    sub_10022251C((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_10029CB24@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint64_t v8 = 0;
  v8[1] = a2;
  uint64_t result = v8 + 2;
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    uint64_t result = sub_1000DC48C(result, *(void **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    void v8[4] = *((void *)v10 + 2);
    *(_OWORD *)uint64_t result = v11;
  }
  v8[5] = 0;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_10029CBB4(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10022251C(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_10029CBD0(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100103388(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    long long v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(void **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (sub_100103744(a1 + 32, (unsigned __int8 *)i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  float v17 = (void *)(a1 + 16);
  uint64_t i = operator new(0x30uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v10;
  float v18 = *a4;
  long long v19 = **a4;
  *((void *)i + 4) = *((void *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *(void *)float v18 = 0;
  *((void *)i + 5) = 0;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100100330(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v26 = *(void *)a1;
  long long v27 = *(void **)(*(void *)a1 + 8 * v4);
  if (v27)
  {
    *(void *)uint64_t i = *v27;
LABEL_38:
    *long long v27 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v17;
  void *v17 = i;
  *(void *)(v26 + 8 * v4) = v17;
  if (*(void *)i)
  {
    unint64_t v28 = *(void *)(*(void *)i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11) {
        v28 %= v11;
      }
    }
    else
    {
      v28 &= v11 - 1;
    }
    long long v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_38;
  }
LABEL_39:
  ++*v8;
  return i;
}

void sub_10029CE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_10022251C(v11, v10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10029CE5C(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(void **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_1001D7FD4();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      unint64_t v13 = (char *)sub_1000DA54C((uint64_t)v6, v12);
      uint64_t v8 = *(void **)v4;
      uint64_t v5 = *(void **)(v4 + 8);
    }
    else
    {
      unint64_t v13 = 0;
    }
    long long v14 = &v13[8 * v9];
    char v15 = &v13[8 * v12];
    *(void *)long long v14 = *a2;
    uint64_t v7 = v14 + 8;
    while (v5 != v8)
    {
      uint64_t v16 = *--v5;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *uint64_t v5 = *a2;
    uint64_t v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void sub_10029CF50()
{
}

void *sub_10029CF64()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1022A2F00;
  return result;
}

void sub_10029CF9C(uint64_t a1, void *a2)
{
  *a2 = off_1022A2F00;
}

BOOL sub_10029CFC4(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 34) {
    return 1;
  }
  if (v2 == 44 || v2 == 35) {
    return 0;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = *(unsigned int *)(a2 + 24);
    int v9 = 68289282;
    int v10 = 0;
    __int16 v11 = 2082;
    unint64_t v12 = "";
    __int16 v13 = 2050;
    uint64_t v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop spectating\", \"event type\":%{public}lu}", (uint8_t *)&v9, 0x1Cu);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
  }
  uint64_t v6 = qword_102419458;
  BOOL result = os_signpost_enabled((os_log_t)qword_102419458);
  if (result)
  {
    uint64_t v8 = *(unsigned int *)(a2 + 24);
    int v9 = 68289282;
    int v10 = 0;
    __int16 v11 = 2082;
    unint64_t v12 = "";
    __int16 v13 = 2050;
    uint64_t v14 = v8;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "got unexpected event type to indicate start/stop spectating", "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop spectating\", \"event type\":%{public}lu}", (uint8_t *)&v9, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t sub_10029D180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029D1C0()
{
}

void *sub_10029D1CC(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10029D254()
{
}

void *sub_10029D268()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = off_1022A2F90;
  return result;
}

void sub_10029D2A0(uint64_t a1, void *a2)
{
  *a2 = off_1022A2F90;
}

BOOL sub_10029D2C8(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 44) {
    return 0;
  }
  if (v2 == 50)
  {
    if ((*(unsigned char *)(a2 + 327) & 0x20) != 0)
    {
      uint64_t v4 = *(void *)(a2 + 272);
      if (!v4) {
        uint64_t v4 = *(void *)(qword_102489AB8 + 240);
      }
      if (*(unsigned char *)(v4 + 12)) {
        return 1;
      }
    }
    return 0;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A2C50);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = *(unsigned int *)(a2 + 24);
    int v10 = 68289282;
    int v11 = 0;
    __int16 v12 = 2082;
    __int16 v13 = "";
    __int16 v14 = 2050;
    uint64_t v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop motion spectating\", \"event type\":%{public}lu}", (uint8_t *)&v10, 0x1Cu);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A2C50);
    }
  }
  uint64_t v8 = qword_102419458;
  BOOL result = os_signpost_enabled((os_log_t)qword_102419458);
  if (result)
  {
    uint64_t v9 = *(unsigned int *)(a2 + 24);
    int v10 = 68289282;
    int v11 = 0;
    __int16 v12 = 2082;
    __int16 v13 = "";
    __int16 v14 = 2050;
    uint64_t v15 = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "got unexpected event type to indicate start/stop motion spectating", "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop motion spectating\", \"event type\":%{public}lu}", (uint8_t *)&v10, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t sub_10029D4A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029D4E0()
{
}

void sub_10029D4EC(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 88;
      uint64_t v7 = v4 - 88;
      uint64_t v8 = v4 - 88;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 88;
        (*v9)(v7);
        v6 -= 88;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10029D5AC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  float v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_1000DA8B4(v7, v9);
  }
  else {
    BOOL v10 = 0;
  }
  __int16 v13 = v10;
  __int16 v14 = &v10[88 * v4];
  uint64_t v16 = &v10[88 * v9];
  sub_100267E74(v14, a2);
  uint64_t v15 = v14 + 88;
  sub_10029D6CC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10029D7D0((uint64_t)&v13);
  return v11;
}

void sub_10029D6B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10029D7D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029D6CC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10029D744((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10029D744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0; a3 + i != a5; sub_100267E74(i + a7, i + a3))
    i -= 88;
  return a6;
}

uint64_t sub_10029D7D0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 88);
    *(void *)(a1 + 16) = i - 88;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_10029D83C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  sub_1000C7F88(&v30);
  LODWORD(v37[0]) = 0;
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDistanceFunctionType", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1004D08E4(v30, (uint64_t)v6, v37);
  CFRelease(v6);
  int v8 = v37[0];
  if (v31) {
    sub_1000DB0A0(v31);
  }
  if (v7) {
    int v9 = v8;
  }
  else {
    int v9 = 4;
  }
  sub_1002A9DA0(v9, v35);
  sub_1001EF40C((uint64_t)&v30, a2 + 16);
  long long v33 = *(_OWORD *)(a2 + 56);
  char v34 = 1;
  sub_100217F48(v9, (uint64_t)v35, a1 + 8, (uint64_t)&v30, v10, v11, v12, (uint64_t)v37);
  if (v34) {
    sub_1000D7D80((uint64_t)&v30);
  }
  sub_1001F37F0((uint64_t)v36, (uint64_t)v37);
  sub_10027A034((void *)a2, (uint64_t)v36, (char **)&v30);
  sub_1001F2DB8(v36);
  __int16 v13 = v31;
  if (v30)
  {
    unint64_t v14 = 0;
    float v15 = 0.0;
    float v16 = 3.4028e38;
    float v17 = 1.1755e-38;
    float v18 = 1.1755e-38;
    float v19 = 0.0;
    float v20 = 3.4028e38;
    do
    {
      float v21 = (char *)(v14 + 1);
      double v22 = *((double *)&v31->__vftable + v14 + (((v14 + 1) * v14) >> 1));
      if (v22 > v17) {
        float v17 = v22;
      }
      if (v22 < v20) {
        float v20 = v22;
      }
      unint64_t v23 = (char *)(v14 + 1);
      if ((unint64_t)v21 < v30)
      {
        do
        {
          if (v14 <= (unint64_t)v23) {
            unint64_t v24 = (unint64_t)v23;
          }
          else {
            unint64_t v24 = v14;
          }
          if (v14 >= (unint64_t)v23) {
            size_t v25 = v23;
          }
          else {
            size_t v25 = (char *)v14;
          }
          double v26 = *((double *)&v31->__vftable + (void)&v25[(v24 + v24 * v24) >> 1]);
          float v15 = v26 + v15;
          if (v26 > v18) {
            float v18 = v26;
          }
          if (v26 < v16) {
            float v16 = v26;
          }
          ++v23;
        }
        while ((char *)v30 != v23);
      }
      float v27 = v22 + v19;
      float v19 = v27 / (float)(unint64_t)v30;
      ++v14;
    }
    while (v21 != (char *)v30);
  }
  else
  {
    float v19 = 0.0;
    float v18 = 1.1755e-38;
    float v20 = 3.4028e38;
    float v16 = 3.4028e38;
    float v15 = 0.0;
    float v17 = 1.1755e-38;
  }
  float v28 = (float)((unint64_t)((v30 - 1) * v30) >> 1);
  *a3 = v20;
  a3[1] = v17;
  a3[2] = v19;
  a3[3] = v16;
  a3[4] = v18;
  a3[5] = v15 / v28;
  if (v13)
  {
    uint64_t v32 = v13;
    operator delete(v13);
  }
  sub_1001F2DB8(v37);
  return sub_10013F374(v35);
}

void sub_10029DABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_1001F2DB8((uint64_t *)va1);
  sub_1001F2DB8((void *)(v10 - 88));
  sub_10013F374((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029DB28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v6 = sub_10026E6A4((void *)a1);
  *CFStringRef v6 = off_1022A3010;
  v6[7] = &off_1022A3068;
  v6[8] = &off_1022A30E0;
  v6[9] = &off_1022A3138;
  v6[10] = &off_1022A3190;
  v6[11] = &off_1022A31E8;
  v6[12] = &off_1022A3240;
  v6[13] = &off_1022A3298;
  v6[14] = &off_1022A32F0;
  v6[15] = &off_1022A3348;
  v6[16] = &off_1022A3398;
  v6[17] = &off_1022A33D8;
  v6[19] = a2;
  v6[20] = a3;
  if (a3)
  {
    *(_WORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    sub_10029E1B4();
  }
  sub_101A5729C();
  uint64_t result = abort_report_np();
  __break(1u);
  return result;
}

void sub_10029DD9C(_Unwind_Exception *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  nullsub_41(v25, a2);
  nullsub_41(v24, v31);
  nullsub_41(v30, v32);
  nullsub_41(v29, v33);
  nullsub_41(v28, v34);
  nullsub_41(v27, v35);
  nullsub_41(v26, v36);
  nullsub_41(a14, v37);
  nullsub_41(a15, v38);
  nullsub_41(a16, v39);
  nullsub_41(a17, v40);
  sub_10026E720(v23);
  _Unwind_Resume(a1);
}

void *sub_10029DE24@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(void))(**(void **)(a1 + 152) + 8))(*(void *)(a1 + 152));
  sub_10029EBD4(a1);
  if (*(unsigned char *)(a1 + 144) && !*(unsigned char *)(a1 + 145)) {
    uint64_t v4 = "RecordingState";
  }
  else {
    uint64_t v4 = "RecordingPendingState";
  }
  uint64_t result = sub_100134750((void *)a2, v4);
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

void sub_10029DEAC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(v4 + 31) < 0)
  {
    sub_1000DC48C(v13, *(void **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(v4 + 8);
    *(void *)&v13[16] = *(void *)(v4 + 24);
    *(_OWORD *)__int16 v13 = v5;
  }
  if ((v13[23] & 0x80000000) == 0)
  {
    if (v13[23] != 21) {
      goto LABEL_28;
    }
    BOOL v6 = *(void *)v13 == 0x6E6964726F636552 && *(void *)&v13[8] == 0x676E69646E655067;
    if (!v6 || *(void *)&v13[13] != 0x6574617453676E69) {
      goto LABEL_28;
    }
LABEL_26:
    sub_100134750((void *)a2, "RecordingState");
    goto LABEL_32;
  }
  if (*(void *)&v13[8] == 21)
  {
    BOOL v10 = **(void **)v13 != 0x6E6964726F636552
       || *(void *)(*(void *)v13 + 8) != 0x676E69646E655067
       || *(void *)(*(void *)v13 + 13) != 0x6574617453676E69;
    operator delete(*(void **)v13);
    if (v10) {
      goto LABEL_28;
    }
    goto LABEL_26;
  }
  operator delete(*(void **)v13);
LABEL_28:
  uint64_t v11 = *(void *)(a1 + 8);
  if (*(char *)(v11 + 31) < 0)
  {
    sub_1000DC48C(v13, *(void **)(v11 + 8), *(void *)(v11 + 16));
  }
  else
  {
    long long v12 = *(_OWORD *)(v11 + 8);
    *(void *)&v13[16] = *(void *)(v11 + 24);
    *(_OWORD *)__int16 v13 = v12;
  }
  *(_OWORD *)a2 = *(_OWORD *)v13;
  *(void *)(a2 + 16) = *(void *)&v13[16];
LABEL_32:
  *(unsigned char *)(a2 + 24) = 1;
}

double sub_10029E020@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(char *)(v3 + 31) < 0)
  {
    sub_1000DC48C(&v6, *(void **)(v3 + 8), *(void *)(v3 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 8);
    uint64_t v7 = *(void *)(v3 + 24);
    long long v6 = v4;
  }
  double result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v7;
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

void *sub_10029E08C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = *(_DWORD *)(a1 + 148) + 1;
  *(_DWORD *)(a1 + 148) = v4;
  sub_1000C7F88(&v12);
  unsigned int v11 = 0;
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiMaxRecordings", 0x8000100u, kCFAllocatorNull);
  int v6 = sub_1004D08E4(v12, (uint64_t)v5, &v11);
  CFRelease(v5);
  unsigned int v7 = v11;
  if (v13) {
    sub_1000DB0A0(v13);
  }
  if (v6) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 10;
  }
  if (v4 >= v8)
  {
    (*(void (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
    int v9 = "IdleState";
  }
  else
  {
    int v9 = "RecordingThrottledState";
  }
  double result = sub_100134750((void *)a2, v9);
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

void sub_10029E198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029E1B4()
{
}

void sub_10029E2D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029E334()
{
}

void sub_10029E538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029E5A4()
{
}

void sub_10029E7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029E814()
{
}

void sub_10029EA10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10029EA84(void *a1)
{
  *a1 = off_1022A3010;
  sub_10029EB34((uint64_t)a1);
  nullsub_41(a1 + 17, v2);
  nullsub_41(a1 + 16, v3);
  nullsub_41(a1 + 15, v4);
  nullsub_41(a1 + 14, v5);
  nullsub_41(a1 + 13, v6);
  nullsub_41(a1 + 12, v7);
  nullsub_41(a1 + 11, v8);
  nullsub_41(a1 + 10, v9);
  nullsub_41(a1 + 9, v10);
  nullsub_41(a1 + 8, v11);
  nullsub_41(a1 + 7, v12);

  return sub_10026E720(a1);
}

uint64_t sub_10029EB34(uint64_t a1)
{
  *(_DWORD *)(a1 + 148) = 0;
  sub_10029EF8C(a1);
  sub_10029ED10(a1);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 152) + 16);

  return v2();
}

void sub_10029EB9C(void *a1)
{
  sub_10029EA84(a1);

  operator delete();
}

void sub_10029EBD4(uint64_t a1)
{
  sub_10029ED10(a1);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10029ED48;
  v7[3] = &unk_1022A3020;
  void v7[4] = a1;
  *(void *)(a1 + 168) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v7);
  sub_1000C7F88(&v9);
  unsigned int v8 = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiMaxRecordingWindow", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1004D08E4(v9, (uint64_t)v2, &v8);
  CFRelease(v2);
  unsigned int v4 = v8;
  if (v10) {
    sub_1000DB0A0(v10);
  }
  if (v3) {
    int64_t v5 = 1000000000 * v4;
  }
  else {
    int64_t v5 = 3600000000000;
  }
  dispatch_time_t v6 = dispatch_time(0, v5);
  dispatch_after(v6, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 168));
}

void sub_10029ECF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_1000DB0A0(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029ED10(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 168));
    *(void *)(a1 + 168) = 0;
  }
}

void sub_10029ED48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1002A181C(v2);
  sub_10026ED70((void *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 168));
  *(void *)(v1 + 168) = 0;
  v2[0] = off_1022A3438;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_10029EDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029EDFC(uint64_t a1)
{
  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10029EE4C(uint64_t a1)
{
  sub_10029EF8C(a1);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10029EFC4;
  v7[3] = &unk_1022A3020;
  void v7[4] = a1;
  *(void *)(a1 + 176) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v7);
  sub_1000C7F88(&v9);
  unsigned int v8 = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiWaitBetweenRecordings", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1004D08E4(v9, (uint64_t)v2, &v8);
  CFRelease(v2);
  unsigned int v4 = v8;
  if (v10) {
    sub_1000DB0A0(v10);
  }
  if (v3) {
    int64_t v5 = 1000000000 * v4;
  }
  else {
    int64_t v5 = 30000000000;
  }
  dispatch_time_t v6 = dispatch_time(0, v5);
  dispatch_after(v6, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 176));
}

void sub_10029EF70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_1000DB0A0(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029EF8C(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 176);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 176));
    *(void *)(a1 + 176) = 0;
  }
}

void sub_10029EFC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1002A18C4(v2);
  sub_10026ED70((void *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 176));
  *(void *)(v1 + 176) = 0;
  v2[0] = off_1022A3438;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_10029F040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10029F078@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_51;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        uint64_t v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v13;
        __int16 v38 = 2081;
        uint64_t v39 = v14;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        float v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v20;
        __int16 v38 = 2081;
        uint64_t v39 = v21;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        unint64_t v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v26;
        __int16 v38 = 2081;
        uint64_t v39 = v27;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_51:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }

  return sub_10029DE24((uint64_t)a2, a3);
}

void sub_10029F50C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029F538(uint64_t a1, uint64_t a2)
{
  nullsub_41(a1, a2);

  operator delete();
}

void *sub_10029F570@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        uint64_t v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v13;
        __int16 v38 = 2081;
        uint64_t v39 = v14;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        float v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v20;
        __int16 v38 = 2081;
        uint64_t v39 = v21;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        unint64_t v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        uint64_t v35 = "";
        __int16 v36 = 2081;
        uint64_t v37 = v26;
        __int16 v38 = 2081;
        uint64_t v39 = v27;
        __int16 v40 = 2082;
        uint64_t v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }
  (*(void (**)(void *))(*(void *)a2[19] + 24))(a2[19]);
  double result = sub_100134750((void *)a3, "IdleState");
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_10029FA2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029FA58(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    dispatch_time_t v6 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_51;
    }
    while (1)
    {
      uint64_t v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        unsigned int v8 = (char *)a2[1];
        if (v8[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v8 + 1), *((void *)v8 + 2));
        }
        else
        {
          long long v9 = *(_OWORD *)(v8 + 8);
          uint64_t v30 = *((void *)v8 + 3);
          *(_OWORD *)long long __dst = v9;
        }
        int v10 = SHIBYTE(v30);
        int v11 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v12 = __dst;
        if (v10 < 0) {
          uint64_t v12 = v11;
        }
        if (v28 >= 0) {
          __int16 v13 = __p;
        }
        else {
          __int16 v13 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v12;
        __int16 v37 = 2081;
        __int16 v38 = v13;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
        if (v6[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      uint64_t v14 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        float v15 = (char *)a2[1];
        if (v15[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v15 + 1), *((void *)v15 + 2));
        }
        else
        {
          long long v16 = *(_OWORD *)(v15 + 8);
          uint64_t v30 = *((void *)v15 + 3);
          *(_OWORD *)long long __dst = v16;
        }
        int v17 = SHIBYTE(v30);
        int v18 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v19 = __dst;
        if (v17 < 0) {
          float v19 = v18;
        }
        if (v28 >= 0) {
          float v20 = __p;
        }
        else {
          float v20 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v19;
        __int16 v37 = 2081;
        __int16 v38 = v20;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
        if (v6[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v21 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        double v22 = (char *)a2[1];
        if (v22[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v22 + 1), *((void *)v22 + 2));
        }
        else
        {
          long long v23 = *(_OWORD *)(v22 + 8);
          uint64_t v30 = *((void *)v22 + 3);
          *(_OWORD *)long long __dst = v23;
        }
        int v24 = SHIBYTE(v30);
        dispatch_time_t v6 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v25 = __dst;
        if (v24 < 0) {
          int v25 = (void **)v6;
        }
        if (v28 >= 0) {
          uint64_t v26 = __p;
        }
        else {
          uint64_t v26 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v25;
        __int16 v37 = 2081;
        __int16 v38 = v26;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_51:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }

  sub_10029DEAC((uint64_t)a2, a3);
}

void sub_10029FEEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_10029FF18@<D0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_51;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_51:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }

  return sub_10029E020((uint64_t)a2, a3);
}

void sub_1002A03AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A03D8@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }
  (*(void (**)(void *))(*(void *)a2[19] + 24))(a2[19]);
  double result = sub_100134750((void *)a3, "IdleState");
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002A0894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A08C0@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    unsigned int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_53;
    }
    while (1)
    {
      long long v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)a2[1];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)long long __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        __int16 v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v14 = __dst;
        if (v12 < 0) {
          uint64_t v14 = v13;
        }
        if (v30 >= 0) {
          float v15 = __p;
        }
        else {
          float v15 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        uint64_t v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      long long v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)a2[1];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)long long __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        float v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v21 = __dst;
        if (v19 < 0) {
          float v21 = v20;
        }
        if (v30 >= 0) {
          double v22 = __p;
        }
        else {
          double v22 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        uint64_t v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      long long v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)a2[1];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)long long __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        unsigned int v8 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v27 = __dst;
        if (v26 < 0) {
          uint64_t v27 = (void **)v8;
        }
        if (v30 >= 0) {
          char v28 = __p;
        }
        else {
          char v28 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        uint64_t v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_53:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }
  if (*((unsigned char *)a2 + 144) && !*((unsigned char *)a2 + 145)) {
    dispatch_time_t v6 = "RecordingState";
  }
  else {
    dispatch_time_t v6 = "RecordingPendingState";
  }
  double result = sub_100134750((void *)a3, v6);
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002A0D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A0D9C@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }
  (*(void (**)(void *))(*(void *)a2[19] + 24))(a2[19]);
  double result = sub_100134750((void *)a3, "IdleState");
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002A1258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A1284@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    uint64_t v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_51;
    }
    while (1)
    {
      unsigned int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)long long __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v13 = __dst;
        if (v11 < 0) {
          __int16 v13 = v12;
        }
        if (v29 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      float v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)long long __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3408);
        }
      }
      double v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)long long __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        uint64_t v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = (void **)v7;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_51:
      dispatch_once(&qword_102419450, &stru_1022A3408);
    }
  }

  return sub_10029E08C((uint64_t)a2, a3);
}

void sub_1002A1718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A1744(uint64_t a1, uint64_t a2)
{
  return sub_10029EB34(a2);
}

uint64_t sub_1002A174C(uint64_t a1, uint64_t a2)
{
  return (***(uint64_t (****)(void))(a2 + 152))(*(void *)(a2 + 152));
}

void sub_1002A1774(uint64_t a1, uint64_t a2)
{
}

void sub_1002A177C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002A17AC(uint64_t a1)
{
  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_1002A181C(void *a1)
{
  *a1 = off_1022A3438;
  CFStringRef v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A3458;
  std::string::assign(v2, "MaxRecordingTimerFiredEvent");
  return a1;
}

void sub_1002A18A4(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A18C4(void *a1)
{
  *a1 = off_1022A3438;
  CFStringRef v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A3478;
  std::string::assign(v2, "ThrottleTimerFiredEvent");
  return a1;
}

void sub_1002A194C(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_1002A196C(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  dispatch_time_t v6 = (void **)sub_1001070AC((uint64_t)a1, &v12, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x40uLL);
    long long v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    _DWORD v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    _DWORD v9[2] = 0;
    *long long v9 = 0;
    *((void *)v7 + 7) = 0;
    sub_1000EDF90(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t sub_1002A1A08(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)double result = off_1022A3498;
  *(unsigned char *)(result + 8) = 0;
  *(unsigned char *)(result + 80) = 0;
  *(unsigned char *)(result + 90) = 0;
  *(unsigned char *)(result + 96) = 0;
  *(unsigned char *)(result + 104) = 0;
  *(unsigned char *)(result + 112) = 0;
  *(unsigned char *)(result + 120) = 0;
  *(void *)(result + 128) = a2;
  *(void *)(result + 136) = a3;
  *(_WORD *)(result + 184) = 0;
  *(_WORD *)(result + 201) = 0;
  *(void *)(result + 152) = 0;
  *(void *)(result + 160) = 0;
  *(void *)(result + 144) = a4;
  *(unsigned char *)(result + 168) = 0;
  *(_DWORD *)(result + 204) = 255;
  return result;
}

uint64_t sub_1002A1A64(uint64_t a1, void *a2, unsigned char *a3, double *a4)
{
  sub_1001F72CC(a1 + 8, a2, a3, a4, v11);
  if (v11[0])
  {
    dispatch_time_t v6 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_1001EE1F4(&v10);
    *(void *)&long long v14 = sub_1001EC8C4((ssize_t)&v10);
    *((void *)&v14 + 1) = v7;
    uint64_t v8 = v13;
    if (!v13) {
      uint64_t v8 = *(void *)(qword_102489AC0 + 80);
    }
    sub_1002A1BA4(&v14, v8, (uint64_t)v15, *a4);
    sub_100219EBC(v6, v15);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1001EF3E8((unsigned int *)&v10);
    sub_1002A1C30(a1, (uint64_t)v12);
  }
  return sub_10026633C(v12);
}

void sub_1002A1B64(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A1BA4(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6F54((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A1C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A1C30(uint64_t a1, uint64_t a2)
{
  int v4 = sub_1002A39CC(a1, a2);
  unsigned int v5 = sub_1002A4154(a1, a2);
  if ((*(unsigned char *)(a2 + 128) & 4) == 0) {
    goto LABEL_5;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (!v6) {
    uint64_t v6 = *(void *)(qword_102489AC0 + 16);
  }
  if ((*(unsigned char *)(v6 + 44) & 4) != 0)
  {
    uint64_t v12 = *(long long **)(v6 + 16);
    if (*((char *)v12 + 23) < 0)
    {
      sub_1000DC48C(&__dst, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v13 = *v12;
      __dst.__r_.__value_.__r.__words[2] = *((void *)v12 + 2);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v13;
    }
  }
  else
  {
LABEL_5:
    sub_100134750(&__dst, "");
  }
  sub_100134750(&__str, "localization");
  sub_100134750(v18, "home");
  if (v4) {
    uint64_t v7 = "success";
  }
  else {
    uint64_t v7 = "fail";
  }
  sub_100134750(__p, v7);
  uint64_t v8 = (unsigned __int8 *)(a1 + 90);
  sub_1002F71BC(v8);
  sub_100272A28();
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (v19 < 0) {
    operator delete(v18[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if ((*(unsigned char *)(a2 + 129) & 4) == 0) {
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)(a2 + 88);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_102489AC0 + 88);
  }
  if ((*(unsigned char *)(v9 + 44) & 4) != 0)
  {
    long long v14 = *(long long **)(v9 + 16);
    if (*((char *)v14 + 23) < 0)
    {
      sub_1000DC48C(&__str, *(void **)v14, *((void *)v14 + 1));
    }
    else
    {
      long long v15 = *v14;
      __str.__r_.__value_.__r.__words[2] = *((void *)v14 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v15;
    }
  }
  else
  {
LABEL_19:
    sub_100134750(&__str, "");
  }
  std::string::operator=(&__dst, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_100134750(&__str, "recording");
  sub_100134750(v18, "home");
  if (v5) {
    int v10 = "success";
  }
  else {
    int v10 = "fail";
  }
  sub_100134750(__p, v10);
  sub_1002F71BC(v8);
  sub_100272A28();
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (v19 < 0) {
    operator delete(v18[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v4 | v5;
}

void sub_1002A1EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A1F1C(uint64_t a1, void *a2, unsigned char *a3, double *a4)
{
  sub_10027E4B0(a2, a3, a4, v11);
  if (v11[0])
  {
    uint64_t v6 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_1001EE1F4(&v10);
    *(void *)&long long v14 = sub_1001EC8C4((ssize_t)&v10);
    *((void *)&v14 + 1) = v7;
    uint64_t v8 = v13;
    if (!v13) {
      uint64_t v8 = *(void *)(qword_102489AC0 + 24);
    }
    sub_1002A205C(&v14, v8, (uint64_t)v15, *a4);
    sub_100219EBC(v6, v15);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1001EF3E8((unsigned int *)&v10);
    sub_1002A1C30(a1, (uint64_t)v12);
  }
  return sub_10026633C(v12);
}

void sub_1002A201C(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A205C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6B94((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 32), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A20D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A20E8(uint64_t a1, uint64_t *a2, double *a3)
{
  sub_10027595C(a2, a3, v10);
  if (v10[0])
  {
    unsigned int v5 = *(uint64_t **)(a1 + 144);
    int v9 = 0;
    sub_1001EE1F4(&v9);
    *(void *)&long long v13 = sub_1001EC8C4((ssize_t)&v9);
    *((void *)&v13 + 1) = v6;
    uint64_t v7 = v12;
    if (!v12) {
      uint64_t v7 = *(void *)(qword_102489AC0 + 40);
    }
    sub_1002A2228(&v13, v7, (uint64_t)v14, *a3);
    sub_100219EBC(v5, v14);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
    sub_1001EF3E8((unsigned int *)&v9);
    sub_1002A1C30(a1, (uint64_t)v11);
  }
  return sub_10026633C(v11);
}

void sub_1002A21E8(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A2228(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6C34((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A22A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A22B4(uint64_t a1, int a2, double *a3)
{
  sub_1002F6E9C((unsigned char *)(a1 + 90), a2, a3, v10);
  unsigned int v5 = *(uint64_t **)(a1 + 144);
  int v9 = 0;
  sub_1001EE1F4(&v9);
  *(void *)&long long v13 = sub_1001EC8C4((ssize_t)&v9);
  *((void *)&v13 + 1) = v6;
  uint64_t v7 = v12;
  if (!v12) {
    uint64_t v7 = *(void *)(qword_102489AC0 + 32);
  }
  sub_1002A23F4(&v13, v7, (uint64_t)v14, *a3);
  sub_100219EBC(v5, v14);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
  sub_1001EF3E8((unsigned int *)&v9);
  if (v10[0]) {
    sub_1002A1C30(a1, (uint64_t)v11);
  }
  return sub_10026633C(v11);
}

void sub_1002A23B4(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A23F4(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6FF4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A246C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A2480(uint64_t a1, void *a2, double *a3)
{
  sub_1002C62E4(a2, a3, v14);
  if (v14[0])
  {
    if (v18 == 9)
    {
      int v9 = *(uint64_t **)(a1 + 144);
      int v13 = 0;
      sub_1001EE1F4(&v13);
      *(void *)&long long v19 = sub_1001EC8C4((ssize_t)&v13);
      *((void *)&v19 + 1) = v10;
      uint64_t v11 = v16;
      if (!v16) {
        uint64_t v11 = *(void *)(qword_102489AC0 + 56);
      }
      sub_1002A26D4(&v19, v11, (uint64_t)v20, *a3);
      sub_100219EBC(v9, v20);
    }
    else
    {
      if (v18 != 10)
      {
LABEL_12:
        uint64_t v8 = sub_1002A1C30(a1, (uint64_t)v15);
        goto LABEL_13;
      }
      unsigned int v5 = *(uint64_t **)(a1 + 144);
      int v13 = 0;
      sub_1001EE1F4(&v13);
      *(void *)&long long v19 = sub_1001EC8C4((ssize_t)&v13);
      *((void *)&v19 + 1) = v6;
      uint64_t v7 = v17;
      if (!v17) {
        uint64_t v7 = *(void *)(qword_102489AC0 + 64);
      }
      sub_1002A2648(&v19, v7, (uint64_t)v20, *a3);
      sub_100219EBC(v5, v20);
    }
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v21);
    sub_1001EF3E8((unsigned int *)&v13);
    goto LABEL_12;
  }
  uint64_t v8 = 0;
LABEL_13:
  sub_10026633C(v15);
  return v8;
}

void sub_1002A25FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v11 + 32));
  sub_1001EF3E8(&a10);
  sub_10026633C(v10);
  _Unwind_Resume(a1);
}

void sub_1002A2648(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6EB4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 48), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A26C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002A26D4(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6E14((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 64), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A274C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A2760(uint64_t a1, double *a2)
{
  sub_1003158AC(a2, v9);
  if (v9[0])
  {
    int v4 = *(uint64_t **)(a1 + 144);
    int v8 = 0;
    sub_1001EE1F4(&v8);
    *(void *)&long long v12 = sub_1001EC8C4((ssize_t)&v8);
    *((void *)&v12 + 1) = v5;
    uint64_t v6 = v11;
    if (!v11) {
      uint64_t v6 = *(void *)(qword_102489AC0 + 48);
    }
    sub_1002A28A0(&v12, v6, (uint64_t)v13, *a2);
    sub_100219EBC(v4, v13);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
    sub_1001EF3E8((unsigned int *)&v8);
    sub_1002A1C30(a1, (uint64_t)v10);
  }
  return sub_10026633C(v10);
}

void sub_1002A2860(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A28A0(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6D74((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A2918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A292C(uint64_t a1, void **a2, void *a3, double *a4)
{
  sub_1002C5F84(a2, a3, a4, v12);
  if (v12[0])
  {
    uint64_t v6 = *(uint64_t **)(a1 + 144);
    int v11 = 0;
    sub_1001EE1F4(&v11);
    *(void *)&long long v15 = sub_1001EC8C4((ssize_t)&v11);
    *((void *)&v15 + 1) = v7;
    uint64_t v8 = v14;
    if (!v14) {
      uint64_t v8 = *(void *)(qword_102489AC0 + 88);
    }
    sub_1002A2A7C(&v15, v8, (uint64_t)v16, *a4);
    sub_100219EBC(v6, v16);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v17);
    sub_1001EF3E8((unsigned int *)&v11);
    uint64_t v9 = sub_1002A1C30(a1, (uint64_t)v13);
  }
  else
  {
    uint64_t v9 = 0;
  }
  sub_10026633C(v13);
  return v9;
}

void sub_1002A2A3C(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A2A7C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7094((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A2AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A2B08(uint64_t a1, const std::string *a2, double *a3)
{
  sub_1002A5564(a2, a3, v11);
  if (v11[0])
  {
    uint64_t v5 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_1001EE1F4(&v10);
    *(void *)&long long v14 = sub_1001EC8C4((ssize_t)&v10);
    *((void *)&v14 + 1) = v6;
    uint64_t v7 = v13;
    if (!v13) {
      uint64_t v7 = *(void *)(qword_102489AC0 + 16);
    }
    sub_1002A2C58(&v14, v7, (uint64_t)v15, *a3);
    sub_100219EBC(v5, v15);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1001EF3E8((unsigned int *)&v10);
    uint64_t v8 = sub_1002A1C30(a1, (uint64_t)v12);
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_10026633C(v12);
  return v8;
}

void sub_1002A2C18(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A2C58(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E6CD4((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A2CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A2CE4(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  int v5 = *((char *)a2 + 23);
  if (v5 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3500);
      }
      int v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a2 + 23) >= 0) {
          int v11 = a2;
        }
        else {
          int v11 = (uint64_t *)*a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v23 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3500);
        }
        uint64_t v21 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMicroLocationLegacyClient::donateTruthTagLabel(const std::string &, const boost::uuids::uuid &, const boost::uuids::uuid &)", "%s\n", v21);
        if (v21 != (char *)buf) {
          free(v21);
        }
      }
      return 0;
    }
    uint64_t v6 = (uint64_t *)*a2;
  }
  else
  {
    uint64_t v6 = a2;
    if (v5 != 10) {
      goto LABEL_10;
    }
  }
  uint64_t v7 = *v6;
  int v8 = *((unsigned __int16 *)v6 + 4);
  if (v7 != 0x6F6D2D7375636F66 || v8 != 25956) {
    goto LABEL_10;
  }
  if (!*(unsigned char *)(a1 + 201)) {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 185);
  uint64_t v14 = *(void *)(a1 + 193);
  uint64_t v15 = a4[1];
  uint64_t v16 = *a3;
  uint64_t v17 = a3[1];
  int v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 128)
                                                                                                + 72);
  uint64_t v19 = *(void *)(a1 + 128);
  uint64_t v20 = *a4;

  return v18(v19, v13, v14, v20, v15, v16, v17);
}

uint64_t sub_1002A2F90(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = *((char *)a2 + 23);
  if (v9 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3500);
      }
      uint64_t v14 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a2 + 23) >= 0) {
          uint64_t v15 = a2;
        }
        else {
          uint64_t v15 = (uint64_t *)*a2;
        }
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", (uint8_t *)buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3500);
        }
        if (*((char *)a2 + 23) >= 0) {
          double v22 = a2;
        }
        else {
          double v22 = (uint64_t *)*a2;
        }
        int v24 = 136315138;
        int v25 = v22;
        long long v23 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "BOOL CLMicroLocationLegacyClient::donateTruthTagLabelForRecordingEventsBetweenDates(const std::string &, const boost::uuids::uuid &, NSDate *, NSDate *)", "%s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      return 0;
    }
    int v10 = (uint64_t *)*a2;
  }
  else
  {
    int v10 = a2;
    if (v9 != 10) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v10;
  int v12 = *((unsigned __int16 *)v10 + 4);
  if (v11 != 0x6F6D2D7375636F66 || v12 != 25956) {
    goto LABEL_10;
  }
  if (*(unsigned char *)(a1 + 201))
  {
    uint64_t v18 = *(void *)(a1 + 128);
    uint64_t v19 = *(void *)(a1 + 185);
    uint64_t v20 = *(void *)(a1 + 193);
    int v24 = 0;
    sub_1001EE1F4(&v24);
    *(void *)&buf[0] = sub_1001EC8C4((ssize_t)&v24);
    *((void *)&buf[0] + 1) = v21;
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 88))(v18, v19, v20, buf, a3, a4, a5);
    sub_1001EF3E8((unsigned int *)&v24);
    return v16;
  }
  return 0;
}

void sub_1002A3244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1001EF3E8((unsigned int *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A3260(uint64_t a1)
{
  return sub_1001F7E7C(a1 + 8);
}

uint64_t sub_1002A3268(uint64_t result, char a2)
{
  *(unsigned char *)(result + 202) = a2;
  return result;
}

BOOL sub_1002A3270(uint64_t a1, void *a2)
{
  return sub_1002C6FB8(a1 + 91, a2);
}

void sub_1002A3278(uint64_t a1)
{
  sub_1000C7F88(&__p);
  LOBYTE(v8) = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnabled", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1000D29FC((uint64_t)__p, (uint64_t)v2, (BOOL *)&v8);
  CFRelease(v2);
  int v4 = v8;
  if (v13) {
    sub_1000DB0A0(v13);
  }
  if (v4) {
    int v5 = v3;
  }
  else {
    int v5 = 0;
  }
  if (v5 == 1)
  {
    if (!*(unsigned char *)(a1 + 184))
    {
      sub_100134750(&__p, "milo-internal-legacy-client-name-unsupervised");
      uint64_t v11 = 1;
      uint64_t v6 = operator new(8uLL);
      *uint64_t v6 = 0;
      int v9 = v6 + 1;
      int v10 = v6 + 1;
      int v8 = v6;
      sub_1002A349C((void *)a1, (uint64_t)&__p, &v11, (uint64_t)&v8, (uint64_t *)&v15);
      *(_OWORD *)(a1 + 168) = v15;
      *(unsigned char *)(a1 + 184) = v16;
      operator delete(v6);
      if (v14 < 0) {
        operator delete(__p);
      }
    }
    if (!*(unsigned char *)(a1 + 201))
    {
      sub_100134750(&__p, "focus-mode");
      uint64_t v11 = 2;
      uint64_t v7 = operator new(8uLL);
      *uint64_t v7 = 0;
      int v9 = v7 + 1;
      int v10 = v7 + 1;
      int v8 = v7;
      sub_1002A349C((void *)a1, (uint64_t)&__p, &v11, (uint64_t)&v8, (uint64_t *)&v15);
      *(_OWORD *)(a1 + 185) = v15;
      *(unsigned char *)(a1 + 201) = v16;
      operator delete(v7);
      if (v14 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_1002A3448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  operator delete(v19);
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002A349C(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  *(unsigned char *)a5 = 0;
  *((unsigned char *)a5 + 16) = 0;
  uint64_t v10 = a1[16];
  sub_100134750(__p, "");
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, unsigned char *))(*(void *)v10 + 32))(&v29, v10, a2, __p);
  if (SBYTE3(v40) < 0) {
    operator delete(*(void **)__p);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3500);
  }
  uint64_t v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v12 = a2;
    }
    else {
      uint64_t v12 = *(void *)a2;
    }
    uint64_t v13 = *a3;
    *(void *)long long __p = 68289538;
    *(_WORD *)&__p[8] = 2082;
    *(void *)&std::string __p[10] = "";
    __int16 v39 = 2082;
    uint64_t v40 = v12;
    __int16 v41 = 2050;
    uint64_t v42 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect\", \"clientName\":%{public, location:escape_only}s, \"serviceType\":%{public}lld}", __p, 0x26u);
  }
  if (v29 != v30)
  {
    long long v14 = *(_OWORD *)v29;
LABEL_19:
    *(_OWORD *)a5 = v14;
    *((unsigned char *)a5 + 16) = 1;
    uint64_t v17 = a1[16];
    uint64_t v18 = *a5;
    uint64_t v19 = a5[1];
    uint64_t v20 = a1[19];
    uint64_t v21 = a1[20];
    sub_100134750(__p, "");
    uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)v17 + 40))(v17, a2, v18, v19, v20, v21, __p);
    if (SBYTE3(v40) < 0) {
      operator delete(*(void **)__p);
    }
    if (v22 != -1)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3500);
      }
      long long v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)long long __p = 68289282;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&std::string __p[10] = "";
        __int16 v39 = 2050;
        uint64_t v40 = v22;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to connect\", \"errorId\":%{public}lld}", __p, 0x1Cu);
      }
      *((unsigned char *)a5 + 16) = 0;
    }
    goto LABEL_27;
  }
  uint64_t v15 = a1[16];
  uint64_t v16 = *a3;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v26 = 0;
  sub_1001DD364(&v26, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_100134750(buf, "");
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, uint64_t, void **, uint8_t *))(*(void *)v15 + 16))(__p, v15, a2, v16, &v26, buf);
  if (SBYTE3(v35) < 0) {
    operator delete(*(void **)buf);
  }
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }
  if (v43 == -1 && BYTE2(v42))
  {
    long long v14 = *(_OWORD *)__p;
    goto LABEL_19;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3500);
  }
  int v24 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v32 = 2082;
    int v33 = "";
    __int16 v34 = 2050;
    uint64_t v35 = v43;
    __int16 v36 = 1026;
    int v37 = BYTE2(v42);
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service\", \"errorId\":%{public}lld, \"descriptorHasValue\":%{public}hhd}", buf, 0x22u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3500);
    }
  }
  int v25 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v32 = 2082;
    int v33 = "";
    __int16 v34 = 2050;
    uint64_t v35 = v43;
    __int16 v36 = 1026;
    int v37 = BYTE2(v42);
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service", "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service\", \"errorId\":%{public}lld, \"descriptorHasValue\":%{public}hhd}", buf, 0x22u);
  }
LABEL_27:
  if (v29)
  {
    char v30 = v29;
    operator delete(v29);
  }
}

void sub_1002A394C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A39CC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 96;
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 96))(*(void *)(a1 + 128));
  int v6 = sub_100315C34(v4, a2, v5);
  double v7 = *(double *)(a2 + 8);
  double v34 = v7;
  if (!v6) {
    return 0;
  }
  uint64_t v8 = sub_100316270(v4);
  unsigned __int8 v10 = v9;
  sub_1000C7F88(buf);
  LODWORD(v38) = 0;
  CFStringRef v11 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLocalizingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  int v12 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v11, &v38);
  CFRelease(v11);
  unsigned int v13 = v38;
  if (*(void *)v42) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v42);
  }
  double v14 = 300.0;
  if (v12) {
    double v14 = (double)v13;
  }
  if (sub_1003160E8(v7, v14, v4, v6, v8, v10))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3500);
    }
    uint64_t v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Legacy throttled request", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3500);
      }
      LOWORD(v38) = 0;
      int v33 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationLegacyClient::requestLocalizationIfPossible(const CLMicroLocationProto::RecordingEvent &)", "%s\n", v33);
      if (v33 != (char *)buf) {
        free(v33);
      }
    }
    sub_10023DE9C((uint64_t)&v38);
    v40 |= 2u;
    if ((_UNKNOWN *)v39 == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign((std::string *)v39, "");
    uint64_t v16 = *(uint64_t **)(a1 + 144);
    LODWORD(v37[0]) = 0;
    sub_1001EE1F4((int *)v37);
    long long __p = (void *)sub_1001EC8C4((ssize_t)v37);
    *(void *)&long long v36 = v17;
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_1002A44E8(&__p, (uint64_t)&v38, (uint64_t)buf, Current_5);
    sub_100219EBC(v16, (long long *)buf);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)((char *)&v46 + 2));
    sub_1001EF3E8((unsigned int *)v37);
    sub_10025D5FC((wireless_diagnostics::google::protobuf::MessageLite *)&v38);
    return 0;
  }
  if (*(unsigned char *)(a1 + 184))
  {
    *(_DWORD *)std::string buf = 0;
    sub_1001EE1F4((int *)buf);
    v37[0] = sub_1001EC8C4((ssize_t)buf);
    v37[1] = v19;
    sub_1001EF3E8((unsigned int *)buf);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3500);
    }
    uint64_t v20 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(unsigned char *)(a1 + 184)) {
        sub_10020D700();
      }
      uint64_t v21 = operator new(0x28uLL);
      __int16 v38 = v21;
      long long v39 = xmmword_101D048C0;
      _OWORD *v21 = 0u;
      v21[1] = 0u;
      *(void *)((char *)v21 + 29) = 0;
      sub_1001E0650(a1 + 168, v21);
      if (v39 >= 0) {
        uint64_t v22 = (char *)&v38;
      }
      else {
        uint64_t v22 = (char *)v38;
      }
      long long v23 = operator new(0x28uLL);
      long long __p = v23;
      long long v36 = xmmword_101D048C0;
      *long long v23 = 0u;
      v23[1] = 0u;
      *(void *)((char *)v23 + 29) = 0;
      sub_1001E0650((uint64_t)v37, v23);
      p_p = (char *)&__p;
      if (v36 < 0) {
        p_p = (char *)__p;
      }
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v42 = 2082;
      *(void *)&void v42[2] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v22;
      __int16 v45 = 2082;
      uint64_t v46 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: request localization for legacy unsupervised\", \"Service ID\":%{public, location:escape_only}s, \"Request ID\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(v36) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v39) < 0) {
        operator delete(v38);
      }
    }
    if (!*(unsigned char *)(a1 + 184)) {
      sub_10020D700();
    }
    uint64_t v25 = (*(uint64_t (**)(void, void, void, void *, double *, BOOL))(**(void **)(a1 + 128) + 56))(*(void *)(a1 + 128), *(void *)(a1 + 168), *(void *)(a1 + 176), v37, &v34, v6 == 1);
    uint64_t v26 = v25;
    uint64_t v27 = (unsigned char *)(a1 + 201);
    if (!*(unsigned char *)(a1 + 201))
    {
      if (!v25) {
        return v26;
      }
LABEL_41:
      sub_100316238(v4, (uint64_t *)&v34);
      return 1;
    }
LABEL_34:
    *(_DWORD *)std::string buf = 0;
    sub_1001EE1F4((int *)buf);
    __int16 v38 = (void *)sub_1001EC8C4((ssize_t)buf);
    *(void *)&long long v39 = v28;
    sub_1001EF3E8((unsigned int *)buf);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3500);
    }
    char v29 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (!*v27) {
        sub_10020D700();
      }
      char v30 = (char *)operator new(0x28uLL);
      *(void *)(v30 + 29) = 0;
      *(_OWORD *)char v30 = 0u;
      *((_OWORD *)v30 + 1) = 0u;
      sub_1001E0650(a1 + 185, v30);
      uint64_t v31 = (char *)operator new(0x28uLL);
      *(void *)(v31 + 29) = 0;
      *(_OWORD *)uint64_t v31 = 0u;
      *((_OWORD *)v31 + 1) = 0u;
      sub_1001E0650((uint64_t)&v38, v31);
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v42 = 2082;
      *(void *)&void v42[2] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v30;
      __int16 v45 = 2082;
      uint64_t v46 = v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: request localization for legacy focus client\", \"Service ID\":%{public, location:escape_only}s, \"Request ID\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v31);
      operator delete(v30);
    }
    if (!*v27) {
      sub_10020D700();
    }
    if (((v26 | (*(unsigned int (**)(void, void, void, void **, double *, BOOL))(**(void **)(a1 + 128) + 56))(*(void *)(a1 + 128), *(void *)(a1 + 185), *(void *)(a1 + 193), &v38, &v34, v6 == 1)) & 1) == 0)return 0; {
    goto LABEL_41;
    }
  }
  uint64_t v26 = 0;
  uint64_t v27 = (unsigned char *)(a1 + 201);
  if (*(unsigned char *)(a1 + 201)) {
    goto LABEL_34;
  }
  return v26;
}

void sub_1002A409C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27)
{
  operator delete(v28);
  operator delete(v27);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A4154(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 96;
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 96))(*(void *)(a1 + 128));
  unint64_t v6 = sub_100315C34(v4, a2, v5);
  double v7 = *(double *)(a2 + 8);
  double v32 = v7;
  if (!*(unsigned char *)(a1 + 184)) {
    return 0;
  }
  unint64_t v8 = HIDWORD(v6);
  BOOL v9 = !*(unsigned char *)(a1 + 201) || HIDWORD(v6) == 0;
  if (v9 || *(unsigned char *)(a1 + 202)) {
    return 0;
  }
  sub_1000C7F88(&v36);
  unsigned int v33 = 0;
  CFStringRef v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  int v11 = sub_1004D08E4(v36, (uint64_t)v10, &v33);
  CFRelease(v10);
  uint64_t v12 = v33;
  if (v37) {
    sub_1000DB0A0(v37);
  }
  if (v11) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 1200;
  }
  if (*(_DWORD *)(a1 + 204) == 1)
  {
    sub_1000C7F88(&v36);
    unsigned int v33 = 0;
    CFStringRef v14 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingThrottleDurationUnstableModel", 0x8000100u, kCFAllocatorNull);
    int v15 = sub_1004D08E4(v36, (uint64_t)v14, &v33);
    CFRelease(v14);
    uint64_t v13 = v33;
    if (v37) {
      sub_1000DB0A0(v37);
    }
    if (!v15) {
      uint64_t v13 = 60;
    }
  }
  uint64_t v16 = sub_10031627C(v4);
  if (sub_1003160E8(v7, (double)v13, v4, v8, v16, v17)) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 129) & 4) == 0) {
    goto LABEL_24;
  }
  uint64_t v18 = *(void *)(a2 + 88);
  if (!v18) {
    uint64_t v18 = *(void *)(qword_102489AC0 + 88);
  }
  if ((*(unsigned char *)(v18 + 44) & 8) != 0 && (sub_1002E594C(*(uint64_t ***)(v18 + 24), &v36), v38))
  {
    uint64_t v19 = v36;
    uint64_t v20 = v37;
  }
  else
  {
LABEL_24:
    LODWORD(v36) = 0;
    sub_1001EE1F4((int *)&v36);
    uint64_t v19 = sub_1001EC8C4((ssize_t)&v36);
    uint64_t v20 = v21;
    sub_1001EF3E8((unsigned int *)&v36);
  }
  if (*(unsigned char *)(a1 + 184))
  {
    uint64_t v22 = *(void *)(a1 + 128);
    uint64_t v23 = *(void *)(a1 + 168);
    uint64_t v24 = *(void *)(a1 + 176);
    LODWORD(v36) = 0;
    sub_1001EE1F4((int *)&v36);
    uint64_t v25 = sub_1001EC8C4((ssize_t)&v36);
    v35[0] = 0;
    v35[16] = 0;
    int v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, double *))(*(void *)v22 + 64))(v22, v23, v24, v25, v26, v35, &v32);
    sub_1001EF3E8((unsigned int *)&v36);
    if (!*(unsigned char *)(a1 + 201))
    {
      if (!v27) {
        return 0;
      }
LABEL_32:
      sub_100316254(v4, (uint64_t *)&v32);
      return 1;
    }
LABEL_31:
    uint64_t v29 = *(void *)(a1 + 128);
    uint64_t v30 = *(void *)(a1 + 185);
    uint64_t v31 = *(void *)(a1 + 193);
    v34[0] = 0;
    v34[16] = 0;
    if (((v27 | (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, std::__shared_weak_count *, unsigned char *, double *))(*(void *)v29 + 64))(v29, v30, v31, v19, v20, v34, &v32)) & 1) == 0)return 0; {
    goto LABEL_32;
    }
  }
  int v27 = 0;
  uint64_t result = 0;
  if (*(unsigned char *)(a1 + 201)) {
    goto LABEL_31;
  }
  return result;
}

void sub_1002A44A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1001EF3E8((unsigned int *)va);
  _Unwind_Resume(a1);
}

void sub_1002A44E8(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7A94((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A4560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_1002A4574(uint64_t a1, double *a2)
{
  uint64_t v4 = *(id **)(a1 + 136);
  id v5 = sub_1009C4678(a2);
  sub_10022D3E8(v4, v5);
  uint64_t v6 = *(void *)(a1 + 136);
  id v7 = sub_1009C4228((uint64_t)a2);

  return sub_10022D618(v6, v7);
}

void sub_1002A45DC(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = a4[18];
  uint64_t v7 = a4[19];
  if (v8 == v7)
  {
    BOOL v11 = 0;
  }
  else
  {
    uint64_t v9 = v8 + 4;
    do
    {
      int v10 = *(_DWORD *)(v9 - 4);
      BOOL v11 = v10 == 3;
      BOOL v12 = v10 == 3 || v9 == v7;
      v9 += 4;
    }
    while (!v12);
  }
  uint64_t v13 = *a4;
  uint64_t v14 = a4[1];
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3500);
  }
  int v15 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v26 = 2082;
    int v27 = "";
    __int16 v28 = 1026;
    BOOL v29 = v11;
    LOWORD(v30) = 1026;
    *(_DWORD *)((char *)&v30 + 2) = v13 == v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Not publishing to Legacy client\", \"because test FP is invalid\":%{public}hhd, \"because probability vector is empty\":%{public}hhd}", buf, 0x1Eu);
  }
  char v16 = v13 == v14 || v11;
  if ((v16 & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 184))
    {
      if (*(void *)(a1 + 168) == *a2 && *(void *)(a1 + 176) == a2[1])
      {
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        uint64_t v22 = (uint64_t *)&v23;
        CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
        sub_1002A4F00(buf, &xmmword_102489B40, (uint64_t)a4);
        sub_1002A51BC(&v22, (long long *)buf);
        if (__p)
        {
          char v38 = __p;
          operator delete(__p);
        }
        if (v36) {
          sub_1002220F0((uint64_t)v35);
        }
        if (v34 && v33 < 0) {
          operator delete(v32);
        }
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(*(void **)buf);
        }
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3500);
        }
        uint64_t v18 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::string buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v26 = 2082;
          int v27 = "";
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Legacy client Publishing unsupervised localization results to Biome\"}", buf, 0x12u);
        }
        sub_1002A4574(a1, &Current_5);
        sub_1002A50D0((uint64_t)&v22, v23);
      }
    }
    if (*(unsigned char *)(a1 + 201))
    {
      if (*(void *)(a1 + 185) == *a2 && *(void *)(a1 + 193) == a2[1])
      {
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        CFAbsoluteTime Current_5 = 0.0;
        uint64_t v22 = (uint64_t *)&v23;
        CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
        sub_1002A4F00(buf, &xmmword_102489B58, (uint64_t)a4);
        sub_1002A51BC(&v22, (long long *)buf);
        if (__p)
        {
          char v38 = __p;
          operator delete(__p);
        }
        if (v36) {
          sub_1002220F0((uint64_t)v35);
        }
        if (v34 && v33 < 0) {
          operator delete(v32);
        }
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(*(void **)buf);
        }
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3500);
        }
        uint64_t v20 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::string buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v26 = 2082;
          int v27 = "";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Legacy client Publishing focusMode localization results to Biome\"}", buf, 0x12u);
        }
        sub_1002A4574(a1, &Current_5);
        sub_1002A50D0((uint64_t)&v22, v23);
      }
    }
  }
}

void sub_1002A49D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  sub_1002A50D0(v11, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A4A30(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 176) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 152)) {
    sub_1002220F0(a1 + 112);
  }
  if (*(unsigned char *)(a1 + 104) && *(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002A4AAC(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 184))
  {
    if (*(void *)(a1 + 168) == a2[4] && *(void *)(a1 + 176) == a2[5])
    {
      uint64_t v6 = (void *)a2[1];
      id v5 = (void *)a2[2];
      if (v6 != v5)
      {
        while (*v6 != 1)
        {
          if (++v6 == v5)
          {
            uint64_t v6 = (void *)a2[2];
            break;
          }
        }
      }
      uint64_t v8 = (void *)a2[10];
      uint64_t v7 = (void *)a2[11];
      if (v8 != v7)
      {
        while (*v8 != 3)
        {
          if (++v8 == v7)
          {
            uint64_t v8 = (void *)a2[11];
            break;
          }
        }
      }
      uint64_t v9 = *a2;
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3500);
      }
      int v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = a2[9];
        *(_DWORD *)std::string buf = 68290050;
        int v24 = 0;
        __int16 v25 = 2082;
        __int16 v26 = "";
        __int16 v27 = 1026;
        BOOL v28 = v9 == 1;
        __int16 v29 = 1026;
        BOOL v30 = v6 != v5;
        __int16 v31 = 1026;
        BOOL v32 = v8 != v7;
        __int16 v33 = 1026;
        int v34 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient Service Status update\", \"isSuspended\":%{public}hhd, \"isReasonModelUnavailable\":%{public}hhd, \"isQualityReasonLowObservations\":%{public}hhd, \"service quality\":%{public}d}", buf, 0x2Au);
      }
      BOOL v12 = v6 != v5 && v9 == 1;
      if (v12 || v8 != v7)
      {
        int v13 = 1;
      }
      else if (*a2)
      {
        int v13 = 255;
      }
      else
      {
        int v13 = 2;
      }
      *(_DWORD *)(a1 + 204) = v13;
      sub_10023E064((uint64_t)v19);
      int v14 = *(_DWORD *)(a1 + 204);
      if (!sub_10023E7C0(v14)) {
        __assert_rtn("set_numberofobservationsstate", "microlocation.pb.h", 20901, "::CLMicroLocationProto::NumberOfObservationsStates_IsValid(value)");
      }
      v21 |= 2u;
      int v20 = v14;
      int v15 = *(uint64_t **)(a1 + 144);
      int v18 = 0;
      sub_1001EE1F4(&v18);
      *(void *)&long long v22 = sub_1001EC8C4((ssize_t)&v18);
      *((void *)&v22 + 1) = v16;
      double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
      sub_1002A4D74(&v22, (uint64_t)v19, (uint64_t)buf, Current_5);
      sub_100219EBC(v15, (long long *)buf);
      sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v32);
      sub_1001EF3E8((unsigned int *)&v18);
      sub_100268DE0((wireless_diagnostics::google::protobuf::MessageLite *)v19);
    }
  }
}

void sub_1002A4D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10, char a11)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v11 + 32));
  sub_1001EF3E8(&a10);
  sub_100268DE0((wireless_diagnostics::google::protobuf::MessageLite *)&a11);
  _Unwind_Resume(a1);
}

void sub_1002A4D74(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7C74((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002A4DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002A4E10(uint64_t a1)
{
  *(void *)a1 = off_1022A3498;
  if (*(unsigned char *)(a1 + 80)) {
    sub_100255458(a1 + 8);
  }
  return a1;
}

void sub_1002A4E60(uint64_t a1)
{
  *(void *)a1 = off_1022A3498;
  if (*(unsigned char *)(a1 + 80)) {
    sub_100255458(a1 + 8);
  }

  operator delete();
}

void sub_1002A4ED0(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1002A4F00(void *__dst, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  sub_1002A4F7C((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_1002A4F60(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A4F7C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1002227B8((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5);
  long long v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v4;
  sub_1000E3A78(a1 + 56, (long long *)(a2 + 56));
  sub_1002A5070((unsigned char *)(a1 + 88), a2 + 88);
  int v5 = *(_DWORD *)(a2 + 136);
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 136) = v5;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  sub_10010F834((void *)(a1 + 144), *(const void **)(a2 + 144), *(void *)(a2 + 152), (uint64_t)(*(void *)(a2 + 152) - *(void *)(a2 + 144)) >> 2);
  return a1;
}

void sub_1002A501C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 128)) {
    sub_1002220F0(v3);
  }
  if (*(unsigned char *)(v1 + 80) && *(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  int v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1002A5070(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    sub_100222178((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_1002A50B4(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 40)) {
    sub_1002220F0(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A50D0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1002A50D0(a1, *a2);
    sub_1002A50D0(a1, a2[1]);
    sub_1002A512C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1002A512C(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 176) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 152)) {
    sub_1002220F0(a1 + 112);
  }
  if (*(unsigned char *)(a1 + 104) && *(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    long long v4 = *(void **)a1;
    operator delete(v4);
  }
}

uint64_t *sub_1002A51BC(uint64_t **a1, long long *a2)
{
  long long v4 = (uint64_t *)(a1 + 1);
  v9[0] = (uint64_t *)operator new(0xE0uLL);
  v9[1] = v4;
  sub_1002A52E4((uint64_t)(v9[0] + 4), a2);
  char v10 = 1;
  int v5 = (uint64_t **)sub_1002A5268((uint64_t)a1, &v8, (const void **)v9[0] + 4);
  sub_1000EDF90(a1, v8, v5, v9[0]);
  uint64_t v6 = v9[0];
  v9[0] = 0;
  sub_1002A53D4((uint64_t)v9, 0);
  return v6;
}

void sub_1002A5250(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002A53D4((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_1002A5268(uint64_t a1, void *a2, const void **a3)
{
  int v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        int v5 = (void *)v4;
        if (!sub_100130070(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v5;
        uint64_t result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }
      uint64_t v4 = v5[1];
    }
    while (v4);
    uint64_t result = v5 + 1;
  }
  else
  {
    uint64_t result = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

uint64_t sub_1002A52E4(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  long long v5 = a2[3];
  long long v6 = *(long long *)((char *)a2 + 57);
  *(unsigned char *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 57) = v6;
  *(_OWORD *)(a1 + 48) = v5;
  *(unsigned char *)(a1 + 104) = 0;
  if (*((unsigned char *)a2 + 104))
  {
    long long v7 = a2[5];
    *(void *)(a1 + 96) = *((void *)a2 + 12);
    *(_OWORD *)(a1 + 80) = v7;
    *((void *)a2 + 11) = 0;
    *((void *)a2 + 12) = 0;
    *((void *)a2 + 10) = 0;
    *(unsigned char *)(a1 + 104) = 1;
  }
  *(unsigned char *)(a1 + 112) = 0;
  uint64_t v8 = a1 + 112;
  *(unsigned char *)(a1 + 152) = 0;
  if (*((unsigned char *)a2 + 152))
  {
    sub_1000E2908(v8, (uint64_t *)a2 + 14);
    *(unsigned char *)(a1 + 152) = 1;
  }
  *(_DWORD *)(a1 + 160) = *((_DWORD *)a2 + 40);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(long long *)((char *)a2 + 168);
  *(void *)(a1 + 184) = *((void *)a2 + 23);
  *((void *)a2 + 21) = 0;
  *((void *)a2 + 22) = 0;
  *((void *)a2 + 23) = 0;
  return a1;
}

void sub_1002A53D4(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002A512C((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

id sub_1002A54BC(uint64_t a1)
{
  id result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_10247A720 = (uint64_t)result;
  return result;
}

void sub_1002A5564(const std::string *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3520);
  }
  long long v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v7 = a1;
    }
    else {
      long long v7 = (const std::string *)a1->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289282;
    int v19 = 0;
    __int16 v20 = 2082;
    int v21 = "";
    __int16 v22 = 2082;
    uint64_t v23 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic: client request localization scan\", \"client\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  sub_10023D8C8(&v14);
  v17 |= 4u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v16, a1);
  int v8 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
  if (v8 < 0)
  {
    if (a1->__r_.__value_.__l.__size_ != 18)
    {
LABEL_19:
      int v12 = 1;
      goto LABEL_26;
    }
    a1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  else if (v8 != 18)
  {
    goto LABEL_19;
  }
  unint64_t v9 = 0x4E6F746966696361;
  unint64_t v10 = bswap64(a1->__r_.__value_.__r.__words[0]);
  if (v10 == 0x4E6F746966696361
    && (unint64_t v9 = 0x74696F6E43656E74, v10 = bswap64(a1->__r_.__value_.__l.__size_), v10 == 0x74696F6E43656E74)
    && (v10 = bswap32(LOWORD(a1->__r_.__value_.__r.__words[2])) >> 16, unint64_t v9 = 25970, v10 == 25970))
  {
    int v11 = 0;
  }
  else if (v10 < v9)
  {
    int v11 = -1;
  }
  else
  {
    int v11 = 1;
  }
  if (v11) {
    int v12 = 1;
  }
  else {
    int v12 = 3;
  }
LABEL_26:
  if (!sub_10023E790(v12)) {
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 12856, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  }
  v17 |= 2u;
  int v15 = v12;
  sub_1002A5850((uint64_t)&v14, 0, 0, 3u, (uint64_t)v13, *a2);
  buf[0] = 1;
  sub_1002660C8(&v20);
  *a3 = buf[0];
  sub_1002660C8(a3 + 8);
  sub_10026633C(&v20);
  sub_10026633C(v13);
  sub_10024DA38((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
}

void sub_1002A5810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_10026633C(v27);
  sub_10026633C(&a10);
  sub_10024DA38((wireless_diagnostics::google::protobuf::MessageLite *)&a27);
  _Unwind_Resume(a1);
}

void sub_1002A5850(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (!sub_10023E774(v12))
  {
    uint64_t v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    uint64_t v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    uint64_t v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    uint64_t v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E64B4(a5, a1);
}

void sub_1002A5938(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002A594C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002A597C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1022A3550;
  *(void *)(a1 + 8) = off_1022A3638;
  *(void *)(a1 + 16) = off_1022A3668;
  *(void *)(a1 + 24) = off_1022A36A0;
  *(void *)(a1 + 32) = off_1022A36F0;
  *(void *)(a1 + 40) = off_1022A3728;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  uint64_t v4 = a1 + 64;
  sub_1000E23EC((unsigned char *)(a1 + 64), (uint64_t)&byte_10248AB18);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  long long v5 = operator new(0x68uLL);
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 176) = (char *)v5 + 104;
  *long long v5 = xmmword_101D07BB0;
  v5[1] = xmmword_101D07BC0;
  _DWORD v5[2] = xmmword_101D07BD0;
  v5[3] = xmmword_101D07BE0;
  void v5[4] = xmmword_101D07BF0;
  v5[5] = xmmword_101D07C00;
  *((void *)v5 + 12) = 13;
  *(void *)(a1 + 160) = v5;
  *(void *)(a1 + 168) = (char *)v5 + 104;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 209) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 264) = a2;
  uint64_t v6 = 0;
  uint64_t v7 = sub_1002A5D0C();
  sub_1002A8C50((uint64_t)&v9, (uint64_t)&v8, a1 + 160, v4, &v7, (uint64_t)&v6, a1);
}

void sub_1002A5BB4(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *(void *)(v1 + 256);
  *(void *)(v1 + 256) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(v1 + 248);
  *(void *)(v1 + 248) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(v1 + 240);
  *(void *)(v1 + 240) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *v3;
  uint64_t *v3 = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  char v9 = *(std::__shared_weak_count **)(v1 + 208);
  if (v9) {
    sub_1000DB0A0(v9);
  }
  unint64_t v10 = *(std::__shared_weak_count **)(v1 + 192);
  if (v10) {
    sub_1000DB0A0(v10);
  }
  int v11 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 168) = v11;
    operator delete(v11);
  }
  if (*(unsigned char *)(v1 + 152) && *(char *)(v1 + 95) < 0) {
    operator delete(*(void **)(v1 + 72));
  }
  uint64_t v12 = *(void *)(v1 + 48);
  *(void *)(v1 + 48) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A5D0C()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLocalizingDurationMinimum", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 1200;
  }
}

void sub_1002A5DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A5DBC()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingDuration", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 3400;
  }
}

void sub_1002A5E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A5E70(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1002A5EB0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1002A5EF0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1002A5F30(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1002A5F70(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1002A5FB0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 224) = *(unsigned char *)a2;
  *(void *)(a1 + 216) = *(void *)(a2 + 8);
  uint64_t v3 = sub_1002A6368(a1);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v3);
  sub_1000C7F88(buf);
  v12[0] = 0;
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsScanWifiRSSIEnabled", 0x8000100u, kCFAllocatorNull);
  char v5 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v4, v12);
  CFRelease(v4);
  BOOL v6 = v12[0];
  if (v14) {
    sub_1000DB0A0(v14);
  }
  if (v6) {
    char v7 = 0;
  }
  else {
    char v7 = v5;
  }
  if (v7)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "SensorsDriver, Not scanning Wifi RSSI because it's not enabled", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3828);
      }
      *(_WORD *)uint64_t v12 = 0;
      char v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    unint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SensorsDriver, wifi, start scanning", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3828);
      }
      *(_WORD *)uint64_t v12 = 0;
      int v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
  }
}

void sub_1002A6344(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A6368(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 224);
  if (v1 == 1) {
    return sub_1002A5D0C() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  }
  if (v1 != 2)
  {
    if (*(unsigned char *)(result + 224)) {
      return result;
    }
    uint64_t result = sub_101A574D0(result);
    return sub_1002A5D0C() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  }

  return sub_1002A5DBC();
}

uint64_t sub_1002A63DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 16))();
}

uint64_t sub_1002A6404(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 128))();
}

uint64_t sub_1002A642C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 136))();
}

uint64_t sub_1002A6454(uint64_t result)
{
  *(void *)(result + 216) = 0;
  *(unsigned char *)(result + 224) = 0;
  return result;
}

void sub_1002A6460(uint64_t a1, double a2)
{
  int v5 = *(unsigned __int8 *)(a1 + 224);
  if (v5 == 1)
  {
    BOOL v6 = (uint64_t *)(a1 + 184);
  }
  else
  {
    if (v5 != 2)
    {
      if (*(unsigned char *)(a1 + 224))
      {
LABEL_8:
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3828);
        }
        char v7 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
        {
          int v13 = 68289282;
          int v14 = 0;
          __int16 v15 = 2082;
          uint64_t v16 = "";
          __int16 v17 = 2050;
          double v18 = *(double *)&v2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorDriver, Wifi scan timer stopped but but scanned AP requirements not met, extend timer\", \"by duration (ms)\":%{public}lld}", (uint8_t *)&v13, 0x1Cu);
        }
        return;
      }
      sub_101A57638();
      __break(1u);
    }
    BOOL v6 = (uint64_t *)(a1 + 200);
  }
  uint64_t v2 = sub_1001F5DC8(*v6);
  if (v2) {
    goto LABEL_8;
  }
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 120))(*(void *)(a1 + 264));
  if (v8)
  {
    uint64_t v9 = v8;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    unint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 68289282;
      int v14 = 0;
      __int16 v15 = 2082;
      uint64_t v16 = "";
      __int16 v17 = 2050;
      double v18 = (double)v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan extention due to backlight on\", \"backlightOnExtention_s\":\"%{public}.09f\"}", (uint8_t *)&v13, 0x1Cu);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v9);
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 264) + 152))(*(void *)(a1 + 264));
    (*(void (**)(void, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
    int v11 = *(void (**)(__n128))(**(void **)(a1 + 264) + 24);
    v12.n128_f64[0] = a2;
    v11(v12);
  }
}

uint64_t sub_1002A6750(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 224))
  {
    uint64_t v1 = a1;
    if (qword_102419450 == -1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_101A577A8(qword_102419450 == -1);
    __break(1u);
  }
  dispatch_once(&qword_102419450, &stru_1022A3828);
LABEL_3:
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    sub_100275744(*(unsigned char *)(v1 + 224), __p);
    if (v6 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 68289282;
    int v8 = 0;
    __int16 v9 = 2082;
    unint64_t v10 = "";
    __int16 v11 = 2082;
    __n128 v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorsDriver, received cancel wifi scan\", \"scan activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  return (*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 24))(*(void *)(v1 + 48), *(unsigned __int8 *)(v1 + 224));
}

uint64_t sub_1002A68B4(uint64_t result)
{
  *(unsigned char *)(result + 56) = 1;
  return result;
}

uint64_t sub_1002A68C0(uint64_t a1, uint64_t a2)
{
  sub_1000D9D94(a1 + 64, a2);
  *(unsigned char *)(a1 + 56) = 1;
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 264) + 40);

  return v3();
}

uint64_t sub_1002A692C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 64))(a1);
  uint64_t v5 = a1[24];
  *a2 = a1[23];
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1002A698C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 64))(a1);
  uint64_t v5 = a1[26];
  *a2 = a1[25];
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002A69EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Updating localizing scan strategy", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3828);
      }
      __int16 v13 = 0;
      __int16 v11 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationSensorsDriver::updateWifiScanStrategiesIfNecessary()", "%s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    uint64_t v3 = *(void *)(a1 + 184);
    memset(__p, 0, sizeof(__p));
    sub_1001DD364(__p, *(const void **)(a1 + 160), *(void *)(a1 + 168), (uint64_t)(*(void *)(a1 + 168) - *(void *)(a1 + 160)) >> 3);
    sub_1002A6CD4(v3, __p);
  }
  uint64_t v4 = *(void *)(a1 + 184);
  uint64_t v5 = sub_1002A5D0C();
  double v6 = *(double *)(a1 + 216);
  *(double *)(v4 + 192) = (v6 * 1000.0 + (double)v5) / 1000.0;
  sub_1001F451C();
  *(_DWORD *)(v4 + 184) = v7;
  *(double *)(v4 + 176) = v6 + sub_1001F4684();
  sub_1001F59E4(v4);
  uint64_t v8 = *(void *)(a1 + 200);
  *(double *)(v8 + 192) = (double)sub_1002A5DBC() / 1000.0;
  sub_1001F4928();
  *(_DWORD *)(v8 + 184) = v9;
  sub_1001F4A90();
  *(double *)(v8 + 176) = v10 + 0.0;
  sub_1001F59E4(v8);
}

void sub_1002A6CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (__p)
  {
    void *v14 = __p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A6CD4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = *a2;
  *a2 = v3;
  uint64_t v4 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = a2[1];
  a2[1] = v4;
  uint64_t v5 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = a2[2];
  a2[2] = v5;
  v10[0] = off_1022A38C0;
  v10[1] = sub_1001F43E0;
  uint64_t v10[3] = v10;
  sub_1002A96BC(v10, (void *)(a1 + 216));
  sub_1001F5F68(v10);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  long long __p = 0;
  sub_1001DD364(&__p, *(const void **)(a1 + 280), *(void *)(a1 + 288), (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3);
  uint64_t v6 = *(void *)(a1 + 240);
  if (v6)
  {
    (*(void (**)(void *__return_ptr))(*(void *)v6 + 48))(v10);
    sub_1001F71A4((void *)(a1 + 248), (uint64_t)v10);
    sub_1001F7120(v10);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
    sub_1001F4280();
    sub_1001F45D8();
    operator new();
  }
  sub_10015E48C();
}

void sub_1002A6F44(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  operator delete();
}

void sub_1002A6FC8(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = *a2;
  *a2 = v3;
  uint64_t v4 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = a2[1];
  a2[1] = v4;
  uint64_t v5 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = a2[2];
  a2[2] = v5;
  v10[0] = off_1022A38C0;
  v10[1] = sub_1001F47EC;
  uint64_t v10[3] = v10;
  sub_1002A96BC(v10, (void *)(a1 + 216));
  sub_1001F5F68(v10);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  long long __p = 0;
  sub_1001DD364(&__p, *(const void **)(a1 + 280), *(void *)(a1 + 288), (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3);
  uint64_t v6 = *(void *)(a1 + 240);
  if (v6)
  {
    (*(void (**)(void *__return_ptr))(*(void *)v6 + 48))(v10);
    sub_1001F71A4((void *)(a1 + 248), (uint64_t)v10);
    sub_1001F7120(v10);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
    sub_1001F468C();
    sub_1001F49E4();
    operator new();
  }
  sub_10015E48C();
}

void sub_1002A7238(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  operator delete();
}

uint64_t sub_1002A72BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 160);
  *(void *)(result + 160) = *a2;
  *a2 = v2;
  uint64_t v3 = *(void *)(result + 168);
  *(void *)(result + 168) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(result + 176);
  *(void *)(result + 176) = a2[2];
  a2[2] = v4;
  *(unsigned char *)(result + 56) = 1;
  return result;
}

uint64_t sub_1002A72F8(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 32))(*(void *)(a1 + 264));
  if (v2) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v2);
  }
  return v2;
}

uint64_t sub_1002A7378(uint64_t a1)
{
  return sub_1002A72F8(a1 - 8);
}

uint64_t sub_1002A7380(uint64_t a1)
{
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    int v7 = "";
    __int16 v8 = 2050;
    double v9 = Current_5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsDriver, stop wifi scan\", \"now\":\"%{public}.3f\"}", (uint8_t *)v5, 0x1Cu);
  }
  (*(void (**)(void))(**(void **)(a1 + 264) + 152))(*(void *)(a1 + 264));
  (*(void (**)(void, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
  return (*(uint64_t (**)(void, double))(**(void **)(a1 + 264) + 24))(*(void *)(a1 + 264), Current_5);
}

uint64_t sub_1002A74F8(uint64_t a1)
{
  return sub_1002A7380(a1 - 8);
}

uint64_t sub_1002A7500(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 48))();
}

uint64_t sub_1002A7528(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 48))();
}

uint64_t sub_1002A7550(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 56))();
}

uint64_t sub_1002A7578(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 56))();
}

uint64_t sub_1002A75A0(uint64_t a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, start session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    __int16 v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  if (!*(unsigned char *)(a2 + 9))
  {
    if (*(unsigned char *)(a1 + 224)) {
      sub_101A57934();
    }
    *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 232) + 16))(*(void *)(a1 + 232), a2);
}

uint64_t sub_1002A7780(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, stop session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::stopBleRssiSession()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 32))(*(void *)(a1 + 232));
}

uint64_t sub_1002A793C(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, request timeout", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationSensorsDriver::onBLEScanRequestTimeout()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 64))(*(void *)(a1 + 264));
}

uint64_t sub_1002A7AF8(uint64_t a1)
{
  return sub_1002A793C(a1 - 16);
}

uint64_t sub_1002A7B00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 72))();
}

uint64_t sub_1002A7B28(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 72))();
}

uint64_t sub_1002A7B50(uint64_t a1, uint64_t *a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    v8[0] = 68289538;
    v8[1] = 0;
    __int16 v9 = 2082;
    double v10 = "";
    __int16 v11 = 1026;
    int v12 = v5;
    __int16 v13 = 2050;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsDriver, uwb, set ranging rate\", \"rate\":%{public}d, \"duration\":\"%{public}f\"}", (uint8_t *)v8, 0x22u);
  }
  return (*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 240) + 32))(*(void *)(a1 + 240), a2);
}

uint64_t sub_1002A7C80(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, reset ranging rate", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::resetRangingRate()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 40))(*(void *)(a1 + 240));
}

uint64_t sub_1002A7E3C(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, start session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::startRanging()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 16))(*(void *)(a1 + 240));
}

uint64_t sub_1002A7FF8(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3828);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, stop session", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3828);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::stopRanging()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 24))(*(void *)(a1 + 240));
}

uint64_t sub_1002A81B4(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 264) + 104);

  return v3(v2);
}

uint64_t sub_1002A8210(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 240) + 104);

  return v3(v2);
}

uint64_t sub_1002A826C(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 264) + 104);

  return v3(v2);
}

uint64_t sub_1002A82C8(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 240) + 104);

  return v3(v2);
}

uint64_t sub_1002A8324(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 264) + 104);

  return v3(v2);
}

uint64_t sub_1002A8380(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 240) + 104);

  return v3(v2);
}

uint64_t sub_1002A83DC(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 264) + 104);

  return v3(v2);
}

uint64_t sub_1002A8438(uint64_t a1)
{
  v2.n128_f64[0] = j__CFAbsoluteTimeGetCurrent_5();
  uint64_t v3 = *(uint64_t (**)(__n128))(**(void **)(a1 + 240) + 104);

  return v3(v2);
}

uint64_t sub_1002A8494(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 112))();
}

uint64_t sub_1002A84BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 112))();
}

uint64_t sub_1002A84E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 80))();
}

uint64_t sub_1002A850C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 80))();
}

uint64_t sub_1002A8534(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 88))();
}

uint64_t sub_1002A855C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 88))();
}

uint64_t sub_1002A8584(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 80))();
}

uint64_t sub_1002A85AC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 80))();
}

uint64_t sub_1002A85D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 96))();
}

uint64_t sub_1002A85FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 96))();
}

uint64_t sub_1002A8624(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 144))();
}

uint64_t sub_1002A864C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 144))();
}

uint64_t sub_1002A8674(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 144))();
}

uint64_t sub_1002A869C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 16))();
}

uint64_t sub_1002A86C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 24))();
}

uint64_t sub_1002A86EC(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 248) + 32))(*(void *)(a1 + 248));
  __n128 v2 = *(uint64_t (**)(void))(**(void **)(a1 + 256) + 32);

  return v2();
}

uint64_t sub_1002A8768(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 248) + 40))(*(void *)(a1 + 248));
  __n128 v2 = *(uint64_t (**)(void))(**(void **)(a1 + 256) + 40);

  return v2();
}

uint64_t sub_1002A87E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 24))();
}

uint64_t sub_1002A880C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 16))();
}

uint64_t sub_1002A8834(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 224);
  if (v1 == 1)
  {
    __n128 v2 = (uint64_t *)(a1 + 184);
  }
  else
  {
    if (v1 != 2)
    {
      uint64_t v5 = sub_101A57A9C();
      return sub_1002A8880(v5);
    }
    __n128 v2 = (uint64_t *)(a1 + 200);
  }
  uint64_t v3 = *v2;

  return sub_10014D19C(v3);
}

void sub_1002A8884(uint64_t a1)
{
  sub_1002A8A40(a1);

  operator delete();
}

uint64_t sub_1002A88BC(uint64_t a1)
{
  return sub_1002A8A40(a1 - 8);
}

void sub_1002A88C4(uint64_t a1)
{
  sub_1002A8A40(a1 - 8);

  operator delete();
}

uint64_t sub_1002A8900(uint64_t a1)
{
  return sub_1002A8A40(a1 - 16);
}

void sub_1002A8908(uint64_t a1)
{
  sub_1002A8A40(a1 - 16);

  operator delete();
}

uint64_t sub_1002A8944(uint64_t a1)
{
  return sub_1002A8A40(a1 - 24);
}

void sub_1002A894C(uint64_t a1)
{
  sub_1002A8A40(a1 - 24);

  operator delete();
}

uint64_t sub_1002A8988(uint64_t a1)
{
  return sub_1002A8A40(a1 - 32);
}

void sub_1002A8990(uint64_t a1)
{
  sub_1002A8A40(a1 - 32);

  operator delete();
}

uint64_t sub_1002A89CC(uint64_t a1)
{
  return sub_1002A8A40(a1 - 40);
}

void sub_1002A89D4(uint64_t a1)
{
  sub_1002A8A40(a1 - 40);

  operator delete();
}

void sub_1002A8A10(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002A8A40(uint64_t a1)
{
  *(void *)a1 = off_1022A3550;
  *(void *)(a1 + 8) = off_1022A3638;
  *(void *)(a1 + 16) = off_1022A3668;
  *(void *)(a1 + 24) = off_1022A36A0;
  *(void *)(a1 + 32) = off_1022A36F0;
  *(void *)(a1 + 40) = off_1022A3728;
  uint64_t v2 = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 208);
  if (v6) {
    sub_1000DB0A0(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 192);
  if (v7) {
    sub_1000DB0A0(v7);
  }
  __int16 v8 = *(void **)(a1 + 160);
  if (v8)
  {
    *(void *)(a1 + 168) = v8;
    operator delete(v8);
  }
  if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  return a1;
}

void sub_1002A8C50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  __int16 v13 = operator new(0x148uLL);
  sub_1002A8CE4(v13, a2, a3, a4, a5, a6, a7);
}

void sub_1002A8CD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002A8CE4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022A3858;
  sub_1002A8E04((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
}

void sub_1002A8D54(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002A8D68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1022A3858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002A8D88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1022A3858;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002A8DDC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1002A8E04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  memset(__p, 0, sizeof(__p));
  sub_1001DD364(__p, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_1002A8EB0(a2, (uint64_t)__p, a5, *a6, a8 + 8);
}

void sub_1002A8E94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A8EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = off_10229EB00;
  *(void *)(a1 + 8) = a5;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  double v10 = "na";
  long long __src = xmmword_1022A3898;
  sub_1002A9098((char *)(a1 + 24), (char *)&__src, (uint64_t)&v11, 1uLL);
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_1002A6CD4(a1, __p);
}

void sub_1002A900C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v14 = *(void **)(v10 + 280);
  if (v14)
  {
    *(void *)(v10 + 288) = v14;
    operator delete(v14);
  }
  sub_1001F7120((void *)(v10 + 248));
  sub_1001F5F68((void *)(v10 + 216));
  if (*(unsigned char *)(v10 + 136) && *(char *)(v10 + 79) < 0) {
    operator delete(*(void **)(v10 + 56));
  }
  __int16 v15 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 32) = v15;
    operator delete(v15);
  }
  uint64_t v16 = *v11;
  uint64_t *v11 = 0;
  if (v16) {
    sub_1001F5FEC((uint64_t)v11, v16);
  }
  _Unwind_Resume(a1);
}

char *sub_1002A9098(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  char v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *char v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_1001D7FD4();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_1000DA584(v7, v12);
    uint64_t v14 = (char *)v7[1];
    __int16 v13 = (void **)(v7 + 1);
    uint64_t v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      double v18 = v9;
      int v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  __int16 v13 = (void **)(result + 8);
  __int16 v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    uint64_t v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    double v18 = v9;
    int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *__int16 v13 = &v9[v17];
  return result;
}

void sub_1002A91D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  __int16 v13 = operator new(0x148uLL);
  sub_1002A9268(v13, a2, a3, a4, a5, a6, a7);
}

void sub_1002A9254(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002A9268(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022A3858;
  sub_1002A92EC((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
}

void sub_1002A92D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002A92EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  memset(__p, 0, sizeof(__p));
  sub_1001DD364(__p, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_1002A9398(a2, (uint64_t)__p, a5, *a6, a8 + 8);
}

void sub_1002A937C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A9398(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = off_10229EB00;
  *(void *)(a1 + 8) = a5;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  unint64_t v10 = "na";
  long long __src = xmmword_1022A3898;
  sub_1002A9098((char *)(a1 + 24), (char *)&__src, (uint64_t)&v11, 1uLL);
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_1002A6FC8(a1, __p);
}

void sub_1002A94F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v14 = *(void **)(v10 + 280);
  if (v14)
  {
    *(void *)(v10 + 288) = v14;
    operator delete(v14);
  }
  sub_1001F7120((void *)(v10 + 248));
  sub_1001F5F68((void *)(v10 + 216));
  if (*(unsigned char *)(v10 + 136) && *(char *)(v10 + 79) < 0) {
    operator delete(*(void **)(v10 + 56));
  }
  __int16 v15 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 32) = v15;
    operator delete(v15);
  }
  uint64_t v16 = *v11;
  uint64_t *v11 = 0;
  if (v16) {
    sub_1001F5FEC((uint64_t)v11, v16);
  }
  _Unwind_Resume(a1);
}

void *sub_1002A9580(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A38C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1002A95C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A38C0;
  a2[1] = v2;
  return result;
}

void sub_1002A95F4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1002A95FC(uint64_t a1, uint64_t a2)
{
  if (sub_1000E9B14(a2, (uint64_t)&off_1022A3940)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002A963C()
{
  return &off_1022A3940;
}

void sub_1002A9648(void (**a1)(void **), uint64_t a2)
{
  uint64_t v2 = *a1;
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  v2(__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1002A96A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002A96BC(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1002A991C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_1002A9928(void *a1@<X0>, char **a2@<X8>)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v6 = a2 + 2;
  do
  {
    if ((*a1 >> v5))
    {
      if ((unint64_t)v4 >= *v6)
      {
        uint64_t v8 = *a2;
        uint64_t v9 = (v4 - *a2) >> 2;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 62) {
          sub_1001D7FD4();
        }
        uint64_t v11 = *v6 - (void)v8;
        if (v11 >> 1 > v10) {
          unint64_t v10 = v11 >> 1;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12)
        {
          __int16 v13 = (char *)sub_10017EA34((uint64_t)v6, v12);
          uint64_t v8 = *a2;
          uint64_t v4 = a2[1];
        }
        else
        {
          __int16 v13 = 0;
        }
        uint64_t v14 = &v13[4 * v9];
        *(_DWORD *)uint64_t v14 = v5;
        char v7 = v14 + 4;
        while (v4 != v8)
        {
          int v15 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *((_DWORD *)v14 - 1) = v15;
          v14 -= 4;
        }
        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[4 * v12];
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v4 = v5;
        char v7 = v4 + 4;
      }
      a2[1] = v7;
      uint64_t v4 = v7;
    }
    ++v5;
  }
  while (v5 != 56);
}

void sub_1002A9A44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A9A64(unsigned int a1@<W0>, char **a2@<X8>)
{
  sub_1000C7F88(&v12);
  sub_1000E9354(v11);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingEventsForModel", 0x8000100u, kCFAllocatorNull);
  BOOL v5 = sub_100186344(v12, (uint64_t)v4, v11);
  CFRelease(v4);
  if (v5)
  {
    sub_1004CE794(v10);
    sub_1002AA1C8((uint64_t)v10, &__p);
  }
  uint64_t v6 = operator new(0x18uLL);
  uint64_t v9 = (char *)(v6 + 3);
  _DWORD v6[2] = 30388;
  *(_OWORD *)uint64_t v6 = xmmword_101D08FC8;
  long long __p = v6;
  uint64_t v8 = v6 + 3;
  sub_10013F3C4(v11);
  if (v13) {
    sub_1000DB0A0(v13);
  }
  if (a1 >= (unint64_t)((v8 - (unsigned char *)__p) >> 3))
  {
    sub_101A57C18();
    abort_report_np();
    __break(1u);
  }
  else
  {
    uint64_t v12 = *((void *)__p + a1);
    sub_1002A9928(&v12, a2);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
  }
}

void sub_1002A9BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  sub_10013F3C4(&a15);
  sub_10013F3C4(&a17);
  int v19 = *(std::__shared_weak_count **)(v17 - 40);
  if (v19) {
    sub_1000DB0A0(v19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002A9C24()
{
  sub_1000C7F88(&v8);
  BOOL v7 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUseAlternativeSetting", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v2) {
    int v3 = v1;
  }
  else {
    int v3 = 0;
  }
  if (v3 != 1) {
    return 1;
  }
  LODWORD(v8) = 0;
  uint64_t v4 = sub_1000A6958();
  uint64_t v5 = 1;
  if ((sub_10013E418(v4, @"kMicroLocationConfigurationSelect", &v8) & 1) == 0)
  {
    if (arc4random_uniform(2u)) {
      uint64_t v5 = 2;
    }
    else {
      uint64_t v5 = 1;
    }
    LODWORD(v8) = v5;
    sub_1002A9D24(v5);
  }
  return v5;
}

void sub_1002A9D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A9D24(int a1)
{
  uint64_t v2 = sub_1000A6958();
  int v5 = a1;
  sub_1000EA2A4(v2, @"kMicroLocationConfigurationSelect", &v5);
  uint64_t v3 = *(void *)sub_1000A6958();
  return (*(uint64_t (**)(void))(v3 + 944))();
}

void sub_1002A9DA0(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
    case 1:
      sub_100134750(__p, "");
      sub_100315834(a2, __p);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
      return;
    case 2:
      sub_1000C7F88(&v14);
      sub_1000E9354(v13);
      CFStringRef v3 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCombinedEuclideanJaccardParams", 0x8000100u, kCFAllocatorNull);
      BOOL v4 = sub_100186344(v14, (uint64_t)v3, v13);
      CFRelease(v3);
      if (v4) {
        goto LABEL_11;
      }
      sub_100134750(__p, "{\"jaccard_threshold\" : 0.75, \"jaccard_scale_factor\" : 20.0}");
      sub_100315834(a2, __p);
      goto LABEL_16;
    case 3:
      sub_1000C7F88(&v14);
      sub_1000E9354(v13);
      CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsTanimotoBaseParams", 0x8000100u, kCFAllocatorNull);
      BOOL v6 = sub_100186344(v14, (uint64_t)v5, v13);
      CFRelease(v5);
      if (v6) {
        goto LABEL_11;
      }
      sub_100134750(__p, "{}");
      sub_100315834(a2, __p);
      goto LABEL_16;
    case 4:
      sub_1000C7F88(&v14);
      sub_1000E9354(v13);
      CFStringRef v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsWeightedEuclideanJaccardParams", 0x8000100u, kCFAllocatorNull);
      BOOL v8 = sub_100186344(v14, (uint64_t)v7, v13);
      CFRelease(v7);
      if (v8) {
        goto LABEL_11;
      }
      sub_100134750(__p, "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":true,\"ble\":false,\"uwb\":false}}}");
      sub_100315834(a2, __p);
      goto LABEL_16;
    case 5:
      sub_1000C7F88(&v14);
      sub_1000E9354(v13);
      CFStringRef v9 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsWeightedEuclideanJaccardTwoSidedParams", 0x8000100u, kCFAllocatorNull);
      BOOL v10 = sub_100186344(v14, (uint64_t)v9, v13);
      CFRelease(v9);
      if (v10)
      {
LABEL_11:
        sub_1004CE794(__p);
        sub_1004CE5C0(a2, (uint64_t)__p);
        *a2 = &off_1022A5E30;
        sub_10013F3C4(__p);
      }
      else
      {
        sub_100134750(__p, "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":false,\"ble\":false,\"uwb\":false}}}");
        sub_100315834(a2, __p);
LABEL_16:
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10013F3C4(v13);
      if (v15) {
        sub_1000DB0A0(v15);
      }
      return;
    default:
      sub_101A57DD4();
  }
}

void sub_1002AA1C8(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1002AA308((uint64_t)a2, 4uLL);
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  sub_1004CFF34(a1);
}

void sub_1002AA2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_1000A7B4C(&a16);
  double v18 = *(void **)v16;
  if (*(void *)v16)
  {
    *(void *)(v16 + 8) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void sub_1002AA308(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_1002AA338((char **)a1, a2 - v2);
  }
}

void sub_1002AA338(char **a1, unint64_t a2)
{
  BOOL v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  CFStringRef v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    BOOL v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_1001D7FD4();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)sub_1000DA54C(v4, v13);
      BOOL v8 = *a1;
      CFStringRef v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    int v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    if (v7 != v8)
    {
      do
      {
        uint64_t v18 = *((void *)v7 - 1);
        v7 -= 8;
        *((void *)v15 - 1) = v18;
        v15 -= 8;
      }
      while (v7 != v8);
      BOOL v8 = *a1;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_1002AA45C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002AA4D4(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419B10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419B10))
  {
    sub_1002AE4F4((std::string *)&xmmword_102419AF8);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102419AF8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419B10);
  }
  if (byte_102419B0F < 0)
  {
    sub_1000DC48C((unsigned char *)a1, (void *)xmmword_102419AF8, *((unint64_t *)&xmmword_102419AF8 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_102419AF8;
    *(void *)(a1 + 16) = unk_102419B08;
  }
}

void sub_1002AA590(_Unwind_Exception *a1)
{
}

void sub_1002AA5A8(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419B30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419B30))
  {
    sub_10022828C((std::string *)&xmmword_102419B18);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102419B18, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419B30);
  }
  if (byte_102419B2F < 0)
  {
    sub_1000DC48C((unsigned char *)a1, (void *)xmmword_102419B18, *((unint64_t *)&xmmword_102419B18 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_102419B18;
    *(void *)(a1 + 16) = unk_102419B28;
  }
}

void sub_1002AA664(_Unwind_Exception *a1)
{
}

uint64_t sub_1002AA67C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  sub_100243254(a1 + 32, a5);
  if ((a6 & 0xFF00000000) != 0) {
    int v9 = a6;
  }
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 112) = v9;
  return a1;
}

void sub_1002AA6C8(uint64_t *a1)
{
  BOOL v2 = sub_10014C3C0(*a1);
  *((unsigned char *)a1 + 8) = v2;
  if (v2)
  {
    long long v8 = off_1022A39F8;
    sub_1005F7B0C(*a1, "MicroLocationMeasurements", (const char **)&off_1022A3A28, (const std::string::value_type **)&v8, 0);
    char v3 = sub_1005F93E4(*a1, "MicroLocationMeasurements");
    *((unsigned char *)a1 + 8) = v3;
    if (v3)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3A08);
      }
      uint64_t v4 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v12 = "MicroLocationMeasurements";
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sucessfully created table if necessary: %{public}s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3A08);
        }
        int v9 = 136446210;
        unint64_t v10 = "MicroLocationMeasurements";
LABEL_19:
        BOOL v6 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationMeasurementTable::initTable()", "%s\n");
LABEL_29:
        if (v6 != buf) {
          free(v6);
        }
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3A08);
      }
      CFStringRef v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v12 = "MicroLocationMeasurements";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create table: %{public}s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A3A08);
        }
        int v9 = 136446210;
        unint64_t v10 = "MicroLocationMeasurements";
        BOOL v6 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMicroLocationMeasurementTable::initTable()", "%s\n");
        goto LABEL_29;
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3A08);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Database is not connected so we can't intialize our table", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A3A08);
      }
      LOWORD(v8) = 0;
      goto LABEL_19;
    }
  }
}

uint64_t sub_1002AAAC8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 8) = 0;
  sub_1002AA6C8((uint64_t *)a1);
  return a1;
}

uint64_t sub_1002AAAF8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v1 = *(void *)a1;
    if (byte_10247A747 >= 0) {
      BOOL v2 = &xmmword_10247A730;
    }
    else {
      BOOL v2 = (long long *)xmmword_10247A730;
    }
    sub_10014D518(v1, (uint64_t)v2);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3A08);
  }
  char v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't insert or replace", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3A08);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::insertOrReplace(const std::vector<Entry> &)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return 0;
}

void sub_1002AB188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,std::bad_cast a33)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a30) {
    (*(void (**)(uint64_t))(*(void *)a30 + 8))(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AB21C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *((unsigned char *)&v45.__r_.__value_.__s + 23) = 14;
  strcpy((char *)&v45, "SELECT * FROM ");
  char v44 = 8;
  strcpy(__s, "(SELECT ");
  BOOL v6 = std::string::append(&v45, __s, 8uLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_1002AA4D4((uint64_t)__p);
  if ((v42 & 0x80u) == 0) {
    long long v8 = __p;
  }
  else {
    long long v8 = (void **)__p[0];
  }
  if ((v42 & 0x80u) == 0) {
    std::string::size_type v9 = v42;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)__p[1];
  }
  unint64_t v10 = std::string::append(&v46, (const std::string::value_type *)v8, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = std::string::append(&v47, " FROM ");
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint64_t v14 = std::string::append(&v48, "MicroLocationMeasurements");
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  uint64_t v16 = std::string::append(&v49, " ");
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    int v19 = (const std::string::value_type *)a2;
  }
  else {
    int v19 = *(const std::string::value_type **)a2;
  }
  if (v18 >= 0) {
    std::string::size_type v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v20 = *(void *)(a2 + 8);
  }
  int v21 = std::string::append(&v50, v19, v20);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  uint64_t v23 = std::string::append(&v51, " ");
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  __int16 v25 = std::string::append(&v52, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  uint64_t v27 = std::string::append(&v53, "ScanCFTimestamp");
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  __int16 v29 = std::string::append(&v54, " DESC LIMIT ");
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v59.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v40, a3);
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    __int16 v31 = &v40;
  }
  else {
    __int16 v31 = (std::string *)v40.__r_.__value_.__r.__words[0];
  }
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v40.__r_.__value_.__l.__size_;
  }
  __int16 v33 = std::string::append(&v59, (const std::string::value_type *)v31, size);
  long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  uint64_t v35 = std::string::append(&v55, ") ORDER BY ");
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v58.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  int v37 = std::string::append(&v58, "ScanCFTimestamp");
  long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  int64_t v57 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)unint64_t v56 = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if ((char)v42 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v44 < 0) {
    operator delete(*(void **)__s);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (v57 >= 0) {
    long long v39 = v56;
  }
  else {
    long long v39 = (void **)v56[0];
  }
  sub_10014D518(a1, (uint64_t)v39);
}

void sub_1002AB7A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  std::string buf = &a59;
  sub_100216394(&buf);
  if (v70) {
    (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
  }
  if (a68 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002AB9B4()
{
}

void sub_1002ABB90()
{
}

void sub_1002ABBA4(void *a1, int a2)
{
  if (a2) {
    sub_1001C7F8C(a1);
  }
  JUMPOUT(0x1002AB9ACLL);
}

void sub_1002ABBB4(uint64_t a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, void *a6@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v79.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&v79, " WHERE ");
    uint64_t v12 = std::string::append(&v79, "RecordingUUID");
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v80.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    uint64_t v14 = std::string::append(&v80, " in ");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v81.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v81.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    uint64_t v16 = std::string::append(&v81, "(SELECT ");
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v82.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    int v18 = std::string::append(&v82, "RecordingUUID");
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v20 = std::string::append(&v83, " FROM ");
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v84.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v84.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    long long v22 = std::string::append(&v84, "MicroLocationRecordingEvents");
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    long long v24 = std::string::append(&v85, " WHERE ");
    long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    long long v26 = std::string::append(&v86, "EventType");
    long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    long long v28 = std::string::append(&v87, "=");
    long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v78, 1);
    if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v30 = &v78;
    }
    else {
      long long v30 = (std::string *)v78.__r_.__value_.__r.__words[0];
    }
    if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v78.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v78.__r_.__value_.__l.__size_;
    }
    BOOL v32 = std::string::append(&v88, (const std::string::value_type *)v30, size);
    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    long long v34 = std::string::append(&v89, " AND HEX(");
    long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v90.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v90.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    long long v36 = std::string::append(&v90, "Event");
    long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v91.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    long long v38 = std::string::append(&v91, ") LIKE ");
    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    std::string v40 = std::string::append(&v92, "'080111________________1A021002%'");
    long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    v93.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    unsigned __int8 v42 = std::string::append(&v93, " AND ");
    long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v94.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    char v44 = std::string::append(&v94, "RecordingTimestamp");
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v95.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    std::string v46 = std::string::append(&v95, " > ");
    long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v96.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    int v48 = *(char *)(a3 + 23);
    if (v48 >= 0) {
      std::string v49 = (const std::string::value_type *)a3;
    }
    else {
      std::string v49 = *(const std::string::value_type **)a3;
    }
    if (v48 >= 0) {
      std::string::size_type v50 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v50 = *(void *)(a3 + 8);
    }
    std::string v51 = std::string::append(&v96, v49, v50);
    long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v97.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v97.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    std::string v53 = std::string::append(&v97, " AND ");
    long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v98.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v98.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    std::string v55 = std::string::append(&v98, "RecordingTimestamp");
    long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    v99.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v99.__r_.__value_.__l.__data_ = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    int64_t v57 = std::string::append(&v99, "<= ");
    long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    v100.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    int v59 = *(char *)(a4 + 23);
    if (v59 >= 0) {
      uint64_t v60 = (const std::string::value_type *)a4;
    }
    else {
      uint64_t v60 = *(const std::string::value_type **)a4;
    }
    if (v59 >= 0) {
      std::string::size_type v61 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      std::string::size_type v61 = *(void *)(a4 + 8);
    }
    std::string v62 = std::string::append(&v100, v60, v61);
    long long v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v101.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0;
    v62->__r_.__value_.__r.__words[2] = 0;
    v62->__r_.__value_.__r.__words[0] = 0;
    uint64_t v64 = std::string::append(&v101, " AND ");
    long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v102.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v102.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    v64->__r_.__value_.__r.__words[0] = 0;
    sub_100134750(v74, "RtLoiGroupId");
    sub_10022B538((const void **)v74, a2, (uint64_t)__p);
    if ((v77 & 0x80u) == 0) {
      char v66 = __p;
    }
    else {
      char v66 = (void **)__p[0];
    }
    if ((v77 & 0x80u) == 0) {
      std::string::size_type v67 = v77;
    }
    else {
      std::string::size_type v67 = (std::string::size_type)__p[1];
    }
    long long v68 = std::string::append(&v102, (const std::string::value_type *)v66, v67);
    long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
    v103.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v69;
    v68->__r_.__value_.__l.__size_ = 0;
    v68->__r_.__value_.__r.__words[2] = 0;
    v68->__r_.__value_.__r.__words[0] = 0;
    uint64_t v70 = std::string::append(&v103, ")");
    long long v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
    std::string::size_type v105 = v70->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string buf = v71;
    v70->__r_.__value_.__l.__size_ = 0;
    v70->__r_.__value_.__r.__words[2] = 0;
    v70->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v103.__r_.__value_.__l.__data_);
    }
    if ((char)v77 < 0) {
      operator delete(__p[0]);
    }
    if (v75 < 0) {
      operator delete(v74[0]);
    }
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v102.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v101.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v100.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v99.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v98.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v97.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v96.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v95.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v94.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v93.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v90.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v78.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v88.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v85.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v84.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v83.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v82.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v81.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v80.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v79.__r_.__value_.__l.__data_);
    }
    sub_1002AB21C(*(void *)a1, (uint64_t)buf, a5);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3A08);
  }
  uint64_t v72 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't select all", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3A08);
    }
    LOWORD(v103.__r_.__value_.__l.__data_) = 0;
    int v73 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectLearningMeasurementsAtLoiBetweenTimes(const boost::uuids::uuid &, const std::string &, const std::string &, uint32_t)", "%s\n", v73);
    if (v73 != (char *)buf) {
      free(v73);
    }
  }
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
}

void sub_1002AC3DC(_Unwind_Exception *a1)
{
}

void sub_1002AC5FC()
{
}

void sub_1002AC604()
{
}

void sub_1002AC60C()
{
}

void sub_1002AC614()
{
}

void sub_1002AC61C()
{
}

void sub_1002AC624()
{
}

void sub_1002AC62C()
{
}

void sub_1002AC634()
{
}

void sub_1002AC63C()
{
}

void sub_1002AC644()
{
}

void sub_1002AC64C()
{
}

void sub_1002AC654()
{
}

void sub_1002AC65C()
{
}

void sub_1002AC664()
{
}

void sub_1002AC66C()
{
}

void sub_1002AC674()
{
}

void sub_1002AC67C()
{
}

void sub_1002AC684()
{
}

void sub_1002AC68C()
{
}

void sub_1002AC694()
{
}

void sub_1002AC69C(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v7 = *a2;
    if (*a2 != a2[1])
    {
      *((unsigned char *)&v45.__r_.__value_.__s + 23) = 1;
      LOWORD(v45.__r_.__value_.__l.__data_) = 34;
      memset(&__p, 0, sizeof(__p));
      if (sub_1001E86C0(v7, &__p))
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        long long v11 = std::string::append(&v45, (const std::string::value_type *)p_p, size);
        long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v46.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        long long v13 = std::string::append(&v46, "\"");
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v41.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v46.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v45.__r_.__value_.__l.__data_);
        }
        uint64_t v15 = a2[1];
        for (uint64_t i = *a2 + 16; i != v15; i += 16)
        {
          *((unsigned char *)&v43.__r_.__value_.__s + 23) = 1;
          LOWORD(v43.__r_.__value_.__l.__data_) = 44;
          long long v17 = std::string::append(&v43, "\"");
          long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          memset(&v42, 0, sizeof(v42));
          if ((sub_1001E86C0(i, &v42) & 1) == 0)
          {
            std::bad_cast::bad_cast((std::bad_cast *)buf);
            *(void *)std::string buf = &off_10229E8C8;
            sub_1001E91E8((uint64_t)buf);
          }
          if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v19 = &v42;
          }
          else {
            long long v19 = (std::string *)v42.__r_.__value_.__r.__words[0];
          }
          if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v20 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v20 = v42.__r_.__value_.__l.__size_;
          }
          long long v21 = std::string::append(&__p, (const std::string::value_type *)v19, v20);
          long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
          v45.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v22;
          v21->__r_.__value_.__l.__size_ = 0;
          v21->__r_.__value_.__r.__words[2] = 0;
          v21->__r_.__value_.__r.__words[0] = 0;
          long long v23 = std::string::append(&v45, "\"");
          long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
          v46.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v24;
          v23->__r_.__value_.__l.__size_ = 0;
          v23->__r_.__value_.__r.__words[2] = 0;
          v23->__r_.__value_.__r.__words[0] = 0;
          if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v25 = &v46;
          }
          else {
            long long v25 = (std::string *)v46.__r_.__value_.__r.__words[0];
          }
          if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v26 = HIBYTE(v46.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v26 = v46.__r_.__value_.__l.__size_;
          }
          std::string::append(&v41, (const std::string::value_type *)v25, v26);
          if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v46.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v45.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v42.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v43.__r_.__value_.__l.__data_);
          }
        }
        *((unsigned char *)&v42.__r_.__value_.__s + 23) = 7;
        strcpy((char *)&v42, " WHERE ");
        long long v27 = std::string::append(&v42, "RecordingUUID");
        long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v43.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        long long v29 = std::string::append(&v43, " in ");
        long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        __int16 v31 = std::string::append(&__p, "(");
        long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v45.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v33 = &v41;
        }
        else {
          long long v33 = (std::string *)v41.__r_.__value_.__r.__words[0];
        }
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v34 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v34 = v41.__r_.__value_.__l.__size_;
        }
        long long v35 = std::string::append(&v45, (const std::string::value_type *)v33, v34);
        long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        v46.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        long long v37 = std::string::append(&v46, ")");
        long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        int v48 = (_UNKNOWN **)v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string buf = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v46.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v45.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v43.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v42.__r_.__value_.__l.__data_);
        }
        sub_1002AB21C(*(void *)a1, (uint64_t)buf, a3);
      }
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    sub_101A581A4();
    __break(1u);
LABEL_70:
    dispatch_once(&qword_102419450, &stru_1022A3A08);
LABEL_66:
    LOWORD(v46.__r_.__value_.__l.__data_) = 0;
    std::string v40 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)", "%s\n", v40);
    if (v40 != (char *)buf) {
      free(v40);
    }
    goto LABEL_63;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3A08);
  }
  long long v39 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't select all", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_66;
    }
    goto LABEL_70;
  }
LABEL_63:
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
}

void sub_1002ACC84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002ACDFC(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v37.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v37, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v37, "MicroLocationMeasurements");
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    BOOL v6 = std::string::append(&v38, " WHERE ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    long long v8 = std::string::append(&v39, "ScanCFTimestamp");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    unint64_t v10 = std::string::append(&v40, " IN (");
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    long long v12 = std::string::append(&v41, "SELECT ");
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v42.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    long long v14 = std::string::append(&v42, "ScanCFTimestamp");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    uint64_t v16 = std::string::append(&v43, " FROM ");
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    long long v18 = std::string::append(&v44, "MicroLocationMeasurements");
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v20 = std::string::append(&v45, " ORDER BY ");
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    long long v22 = std::string::append(&v46, "ScanCFTimestamp");
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    long long v24 = std::string::append(&v47, " LIMIT ");
    long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v36, a2);
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v26 = &v36;
    }
    else {
      std::string::size_type v26 = (std::string *)v36.__r_.__value_.__r.__words[0];
    }
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v36.__r_.__value_.__l.__size_;
    }
    long long v28 = std::string::append(&v48, (const std::string::value_type *)v26, size);
    long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    long long v30 = std::string::append(&v51, ")");
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    int64_t v50 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v43.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v41.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v39.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v37.__r_.__value_.__l.__data_);
    }
    if (v50 >= 0) {
      long long v32 = __p;
    }
    else {
      long long v32 = (void **)__p[0];
    }
    sub_10014D518(*(void *)a1, (uint64_t)v32);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3A08);
  }
  long long v33 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v51.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't deleteOldestRows", (uint8_t *)&v51, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v51, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3A08);
    }
    LOWORD(__p[0]) = 0;
    long long v35 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)", "%s\n", (const char *)v35);
    if (v35 != &v51) {
      free(v35);
    }
  }
  return 0;
}

void sub_1002AD490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  if (v66) {
    (*(void (**)(uint64_t))(*(void *)v66 + 8))(v66);
  }
  if (a66 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002AD638(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v4 = *a2;
    if (*a2 != a2[1])
    {
      *((unsigned char *)&v56.__r_.__value_.__s + 23) = 1;
      LOWORD(v56.__r_.__value_.__l.__data_) = 34;
      memset(&__p, 0, sizeof(__p));
      if (sub_1001E86C0(v4, &__p))
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        long long v7 = std::string::append(&v56, (const std::string::value_type *)p_p, size);
        long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
        v57.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v8;
        v7->__r_.__value_.__l.__size_ = 0;
        v7->__r_.__value_.__r.__words[2] = 0;
        v7->__r_.__value_.__r.__words[0] = 0;
        long long v9 = std::string::append(&v57, "\"");
        long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
        v52.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v10;
        v9->__r_.__value_.__l.__size_ = 0;
        v9->__r_.__value_.__r.__words[2] = 0;
        v9->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v57.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v56.__r_.__value_.__l.__data_);
        }
        uint64_t v11 = a2[1];
        for (uint64_t i = *a2 + 16; i != v11; i += 16)
        {
          *((unsigned char *)&v54.__r_.__value_.__s + 23) = 1;
          LOWORD(v54.__r_.__value_.__l.__data_) = 44;
          long long v13 = std::string::append(&v54, "\"");
          long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
          v13->__r_.__value_.__l.__size_ = 0;
          v13->__r_.__value_.__r.__words[2] = 0;
          v13->__r_.__value_.__r.__words[0] = 0;
          memset(&v53, 0, sizeof(v53));
          if ((sub_1001E86C0(i, &v53) & 1) == 0)
          {
            std::bad_cast::bad_cast((std::bad_cast *)&v58);
            v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
            sub_1001E91E8((uint64_t)&v58);
          }
          if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v15 = &v53;
          }
          else {
            long long v15 = (std::string *)v53.__r_.__value_.__r.__words[0];
          }
          if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v16 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v16 = v53.__r_.__value_.__l.__size_;
          }
          long long v17 = std::string::append(&__p, (const std::string::value_type *)v15, v16);
          long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          v56.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          long long v19 = std::string::append(&v56, "\"");
          long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
          v57.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v20;
          v19->__r_.__value_.__l.__size_ = 0;
          v19->__r_.__value_.__r.__words[2] = 0;
          v19->__r_.__value_.__r.__words[0] = 0;
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v21 = &v57;
          }
          else {
            long long v21 = (std::string *)v57.__r_.__value_.__r.__words[0];
          }
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v22 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v22 = v57.__r_.__value_.__l.__size_;
          }
          std::string::append(&v52, (const std::string::value_type *)v21, v22);
          if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v57.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v56.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v53.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v54.__r_.__value_.__l.__data_);
          }
        }
        *((unsigned char *)&v50.__r_.__value_.__s + 23) = 12;
        strcpy((char *)&v50, "DELETE FROM ");
        long long v23 = std::string::append(&v50, "MicroLocationMeasurements");
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v51.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        long long v25 = std::string::append(&v51, " WHERE ");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        long long v27 = std::string::append(&v53, "RecordingUUID");
        long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        char v49 = 4;
        strcpy(__s, " IN ");
        long long v29 = std::string::append(&v54, __s, 4uLL);
        long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        char v47 = 1;
        strcpy(v46, "(");
        long long v31 = std::string::append(&__p, v46, 1uLL);
        long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v56.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v33 = &v52;
        }
        else {
          long long v33 = (std::string *)v52.__r_.__value_.__r.__words[0];
        }
        if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v34 = HIBYTE(v52.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v34 = v52.__r_.__value_.__l.__size_;
        }
        long long v35 = std::string::append(&v56, (const std::string::value_type *)v33, v34);
        long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        v58.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        char v45 = 1;
        strcpy(v44, ")");
        std::string v37 = std::string::append(&v58, v44, 1uLL);
        long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v57.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        if (v45 < 0) {
          operator delete(*(void **)v44);
        }
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v58.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v56.__r_.__value_.__l.__data_);
        }
        if (v47 < 0) {
          operator delete(*(void **)v46);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v49 < 0) {
          operator delete(*(void **)__s);
        }
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v54.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v53.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v51.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v50.__r_.__value_.__l.__data_);
        }
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string v39 = &v57;
        }
        else {
          std::string v39 = (std::string *)v57.__r_.__value_.__r.__words[0];
        }
        sub_10014D518(*(void *)a1, (uint64_t)v39);
      }
      std::bad_cast::bad_cast((std::bad_cast *)&v58);
      v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
      sub_1001E91E8((uint64_t)&v58);
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A3A08);
    }
    std::string v41 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v58.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#Warning No UUIDs are passed in to delete measurements entries", (uint8_t *)&v58, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      return 0;
    }
    bzero(&v58, 0x65CuLL);
    if (qword_102419450 == -1)
    {
LABEL_85:
      LOWORD(v57.__r_.__value_.__l.__data_) = 0;
      std::string v43 = (std::string *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)", "%s\n", (const char *)v43);
      if (v43 != &v58) {
        free(v43);
      }
      return 0;
    }
LABEL_89:
    dispatch_once(&qword_102419450, &stru_1022A3A08);
    goto LABEL_85;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A3A08);
  }
  std::string v40 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v58.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't delete measurements", (uint8_t *)&v58, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v58, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_85;
    }
    goto LABEL_89;
  }
  return 0;
}

void sub_1002ADFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
  if (a55 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void sub_1002AE1B0(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

sqlite3_int64 sub_1002AE1E0(sqlite3_stmt *a1, int a2)
{
  sqlite3_int64 result = sqlite3_column_int64(a1, a2);
  if (result < 0)
  {
    uint64_t v3 = sub_101A58310();
    return sub_1002AE200(v3);
  }
  return result;
}

uint64_t sub_1002AE200@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  BOOL v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    sub_101A58474(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_100134750(&v12, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v12);
    exception->__vftable = (std::runtime_error_vtbl *)&off_10229F018;
  }
  int v8 = v7;
  sub_10023D5C4(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v9, v6, v8);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_1002AE2E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1002433A8(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t sub_1002AE328(uint64_t *a1, _OWORD *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, int *a6)
{
  uint64_t v7 = *a1;
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v9 = v8 + 1;
  if (v8 + 1 > 0x222222222222222) {
    sub_1001D7FD4();
  }
  uint64_t v15 = (uint64_t)(a1 + 2);
  unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v7) >> 3);
  if (2 * v16 > v9) {
    unint64_t v9 = 2 * v16;
  }
  if (v16 >= 0x111111111111111) {
    unint64_t v17 = 0x222222222222222;
  }
  else {
    unint64_t v17 = v9;
  }
  long long v28 = a1 + 2;
  if (v17) {
    long long v18 = sub_10029BE4C(v15, v17);
  }
  else {
    long long v18 = 0;
  }
  long long v19 = (char *)&v18[30 * v8];
  v25[0] = v18;
  v25[1] = v19;
  long long v26 = v19;
  long long v27 = (char *)&v18[30 * v17];
  uint64_t v20 = *a3;
  uint64_t v21 = *a4;
  int v22 = *a6;
  *(_OWORD *)long long v19 = *a2;
  *((void *)v19 + 2) = v20;
  *((void *)v19 + 3) = v21;
  sub_100243254(v19 + 32, a5);
  v18[30 * v8 + 28] = v22;
  v26 += 120;
  sub_1002AE47C(a1, v25);
  uint64_t v23 = a1[1];
  sub_10029BFF4((uint64_t)v25);
  return v23;
}

void sub_1002AE468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10029BFF4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AE47C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10029BE94((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

double sub_1002AE4F4@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  sub_1002AE558(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_1002AE53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AE558(std::string *a1)
{
  sub_1002AE5B0(a1);
  sub_1002AE684(a1);
  sub_1002AE764(a1);
  sub_1002AE844(a1);
  sub_1002AE924(a1);

  return sub_1001E8488(a1);
}

uint64_t sub_1002AE5B0(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  BOOL v2 = std::string::append(&v7, "RecordingUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002AE650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AE684(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "ScanCFTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002AE730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AE764(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "ScanMCTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002AE810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AE844(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "Data");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002AE8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AE924(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "Flags");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002AE9D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AEA04()
{
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_101D04970;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  CFStringRef v0 = std::string::append(&v19, "MicroLocationMeasurements");
  long long v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v0->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  BOOL v2 = std::string::append(&v20, " (");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_1002AA4D4((uint64_t)v17);
  if ((v18 & 0x80u) == 0) {
    uint64_t v4 = v17;
  }
  else {
    uint64_t v4 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    std::string::size_type v5 = v18;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v17[1];
  }
  uint64_t v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  uint64_t v8 = std::string::append(&v22, ") ");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_1002AA5A8((uint64_t)__p);
  if ((v16 & 0x80u) == 0) {
    long long v10 = __p;
  }
  else {
    long long v10 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    std::string::size_type v11 = v16;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  std::string v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_10247A740 = *((void *)&v12->__r_.__value_.__l + 2);
  xmmword_10247A730 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if ((char)v18 < 0) {
    operator delete(v17[0]);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10247A730, (void *)&_mh_execute_header);
}

void sub_1002AEBFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v40 - 25) < 0) {
    operator delete(*(void **)(v40 - 48));
  }
  if (*(char *)(v40 - 57) < 0) {
    operator delete(*(void **)(v40 - 80));
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AECA8(uint64_t a1, uint64_t a2)
{
  std::to_string(&v4, *(_DWORD *)(a2 + 4));
  BOOL v2 = std::string::insert(&v4, 0, "LocalizationProcessing_modelType_");
  *(void *)long long v3 = v2->__r_.__value_.__l.__size_;
  *(void *)&v3[7] = *(std::string::size_type *)((char *)&v2->__r_.__value_.__r.__words[1] + 7);
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  operator new();
}

void sub_1002AF3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 8))(a18);
  }
  sub_1001E058C(v44);
  sub_10021E098(&a19, 0);
  _Unwind_Resume(a1);
}

void sub_1002AF558(void **a1, unint64_t a2)
{
  std::string v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      sub_1001D7FD4();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)sub_1001D9EDC(v3, a2);
    long long v7 = &v6[v5];
    long long v9 = &v6[32 * v8];
    std::string::size_type v11 = (char *)*a1;
    long long v10 = (char *)a1[1];
    std::string v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 20) = *(_OWORD *)(v10 - 20);
        *((_OWORD *)v12 - 2) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      long long v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t sub_1002AF610(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    sub_1002AF68C((void *)a1, a2);
  }
  else
  {
    sub_1002AF798(a1, a2);
    *(unsigned char *)(a1 + 32) = 1;
  }
  return a1;
}

void sub_1002AF65C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1002AF68C(void *a1, uint64_t a2)
{
  sub_1002AF710(a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *sub_1002AF710(void *a1)
{
  BOOL v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1002AF798(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void sub_1002AF818(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_1022A3C78;
  sub_10026E6A4((void *)(a1 + 8));
  *(void *)a1 = off_1022A3BA8;
  *(void *)(a1 + 8) = off_1022A3C10;
  *(void *)(a1 + 64) = &off_1022A3CE0;
  *(void *)(a1 + 72) = &off_1022A3D38;
  *(void *)(a1 + 80) = &off_1022A3D90;
  *(void *)(a1 + 88) = &off_1022A3DE8;
  *(void *)(a1 + 96) = &off_1022A3E40;
  *(void *)(a1 + 104) = &off_1022A3E98;
  *(void *)(a1 + 112) = &off_1022A3EF0;
  *(void *)(a1 + 120) = &off_1022A3F48;
  *(void *)(a1 + 128) = &off_1022A3FA0;
  *(void *)(a1 + 136) = &off_1022A3FE0;
  *(void *)(a1 + 144) = &off_1022A4020;
  *(void *)(a1 + 152) = &off_1022A4060;
  *(void *)(a1 + 160) = &off_1022A40B8;
  *(void *)(a1 + 168) = &off_1022A40F8;
  *(void *)(a1 + 176) = &off_1022A4138;
  *(void *)(a1 + 184) = &off_1022A4178;
  *(void *)(a1 + 192) = &off_1022A41B8;
  *(void *)(a1 + 200) = &off_1022A41F8;
  *(void *)(a1 + 208) = &off_1022A4238;
  *(void *)(a1 + 216) = &off_1022A4290;
  *(void *)(a1 + 224) = &off_1022A42E8;
  *(void *)(a1 + 232) = &off_1022A4340;
  *(void *)(a1 + 240) = &off_1022A4398;
  *(void *)(a1 + 248) = &off_1022A43F0;
  *(void *)(a1 + 256) = &off_1022A4448;
  *(void *)(a1 + 264) = &off_1022A4488;
  *(void *)(a1 + 272) = &off_1022A44C8;
  *(void *)(a1 + 280) = &off_1022A4508;
  *(void *)(a1 + 288) = &off_1022A4560;
  *(void *)(a1 + 296) = &off_1022A45B8;
  *(void *)(a1 + 304) = &off_1022A4610;
  *(void *)(a1 + 312) = a3;
  *(void *)(a1 + 328) = a2;
  *(void *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 472) = 0;
  *(unsigned char *)(a1 + 480) = 0;
  *(unsigned char *)(a1 + 484) = 0;
  *(void *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(unsigned char *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  sub_1002B6B58();
}

void sub_1002AFD94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (*(char *)(v37 - 89) < 0) {
    operator delete(*(void **)(v37 - 112));
  }
  std::string v39 = *(void **)(v34 + 440);
  if (v39)
  {
    *(void *)(v34 + 448) = v39;
    operator delete(v39);
  }
  if (*(char *)(v34 + 391) < 0) {
    operator delete(*(void **)(v34 + 368));
  }
  nullsub_41(v36, a2);
  nullsub_41(v35, v40);
  nullsub_41(v33, v41);
  nullsub_41(v32, v42);
  nullsub_41(v31, v43);
  nullsub_41(v30, v44);
  nullsub_41(a10, v45);
  nullsub_41(a11, v46);
  nullsub_41(a12, v47);
  nullsub_41(a13, v48);
  nullsub_41(a14, v49);
  nullsub_41(a15, v50);
  nullsub_41(a16, v51);
  nullsub_41(a17, v52);
  nullsub_41(a18, v53);
  nullsub_41(a19, v54);
  nullsub_41(a20, v55);
  nullsub_41(a21, v56);
  nullsub_41(a22, v57);
  nullsub_41(a23, v58);
  nullsub_41(a24, v59);
  nullsub_41(a25, v60);
  nullsub_41(a26, v61);
  nullsub_41(a27, v62);
  nullsub_41(a28, v63);
  nullsub_41(a29, v64);
  nullsub_41(*(void *)(v37 - 152), v65);
  nullsub_41(*(void *)(v37 - 144), v66);
  nullsub_41(*(void *)(v37 - 136), v67);
  nullsub_41(*(void *)(v37 - 128), v68);
  nullsub_41(*(void *)(v37 - 120), v69);
  sub_10026E720(v29);
  _Unwind_Resume(a1);
}

void *sub_1002AFEDC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}", buf, 0x12u);
  }
  [*(id *)(a2 + 32) coordinate];
  double v8 = v7;
  [*(id *)(a2 + 32) coordinate];
  if (sub_1002B8D3C(a1, v8, v9))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      std::string v21 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::VisitEntry(const CLMiLoLoiManagerLoiVisitEntryEvent *)", "%s\n", v21);
      if (v21 != buf) {
        free(v21);
      }
    }
    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      long long v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)std::string buf = v12;
    }
    if ((buf[23] & 0x80000000) != 0)
    {
      if (*(void *)&buf[8] != 17)
      {
        operator delete(*(void **)buf);
        goto LABEL_48;
      }
      BOOL v20 = **(void **)buf != 0x20656D6F48206E49
         || *(void *)(*(void *)buf + 8) != 0x7461745320494F4CLL
         || *(unsigned char *)(*(void *)buf + 16) != 101;
      operator delete(*(void **)buf);
      if (v20) {
        goto LABEL_48;
      }
    }
    else
    {
      if (buf[23] != 17) {
        goto LABEL_48;
      }
      BOOL v16 = *(void *)buf == 0x20656D6F48206E49 && *(void *)&buf[8] == 0x7461745320494F4CLL;
      if (!v16 || buf[16] != 101) {
        goto LABEL_48;
      }
    }
    sub_1002B90E8(a1, 1);
LABEL_48:
    double result = sub_100134750(buf, "In the process of entering Home LOI");
    goto LABEL_49;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  long long v13 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  long long v14 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
  double result = sub_100134750(buf, "Not in Active Location State");
LABEL_49:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B0384@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2 + 32;
  if (sub_1002B9204(a1, *(void *)(a2 + 32), *(void *)(a2 + 40)))
  {
    sub_1002B820C(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    double v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    double v9 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B92B4(a1, @"Generic Failure", @"Invalid Geofence Entry");
    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      long long v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)std::string buf = v12;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B06A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void *sub_1002B06E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handle leeched location notification\"}", buf, 0x12u);
  }
  [*(id *)(a2 + 32) coordinate];
  double v8 = v7;
  [*(id *)(a2 + 32) coordinate];
  if (sub_1002B8D3C(a1, v8, v9))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      long long v14 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::HandleLeechedLocation(const CLMiLoLoiManagerLeechedLocationEvent *)", "%s\n", v14);
      if (v14 != buf) {
        free(v14);
      }
    }
    double result = sub_100134750(buf, "In the process of entering Home LOI");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v12 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v13 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
    }
    double result = sub_100134750(buf, "Not in Active Location State");
  }
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B0A80@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(void *)double v9 = 68289026;
      *(_WORD *)&unsigned char v9[8] = 2082;
      *(void *)&v9[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}", v9, 0x12u);
    }
    *(_DWORD *)(a1 + 480) = 5;
    *(unsigned char *)(a1 + 484) = 1;
    sub_1002B8D3C(a1, *(double *)(a1 + 336), *(double *)(a1 + 344));
    sub_100134750(v9, "In the process of entering Home LOI");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(void *)double v9 = 68289026;
      *(_WORD *)&unsigned char v9[8] = 2082;
      *(void *)&v9[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, won't run, last location not set\"}", v9, 0x12u);
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_1000DC48C(v9, *(void **)(v6 + 8), *(void *)(v6 + 16));
    }
    else
    {
      long long v7 = *(_OWORD *)(v6 + 8);
      *(void *)&v9[16] = *(void *)(v6 + 24);
      *(_OWORD *)double v9 = v7;
    }
  }
  double result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(void *)(a2 + 16) = *(void *)&v9[16];
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

double sub_1002B0C64@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_DWORD *)(a1 + 480) = *(_DWORD *)(a2 + 32);
  *(unsigned char *)(a1 + 484) = 1;
  if (sub_1002B9384(a1))
  {
    sub_100134750(&v8, "In the process of entering Home LOI");
    double result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(void *)(a3 + 16) = v9;
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_1000DC48C(&v8, *(void **)(v6 + 8), *(void *)(v6 + 16));
    }
    else
    {
      long long v7 = *(_OWORD *)(v6 + 8);
      uint64_t v9 = *(void *)(v6 + 24);
      long long v8 = v7;
    }
    double result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(void *)(a3 + 16) = v9;
    *(unsigned char *)(a3 + 24) = 1;
  }
  return result;
}

double sub_1002B0D28@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v6 = 68289026;
    *(_WORD *)&v6[8] = 2082;
    *(void *)&v6[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitExit\"}", v6, 0x12u);
  }
  sub_1002B90E8(a1, 2);
  sub_100134750(v6, "Not in Active Location State");
  double result = *(double *)v6;
  *(_OWORD *)a2 = *(_OWORD *)v6;
  *(void *)(a2 + 16) = *(void *)&v6[16];
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

double sub_1002B0E48@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#LOI Manager, In Home LOI, exit it before creating custom LOI process", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi(const CLMiLoLoiManagerEnableCustomLoiEvent *)", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  sub_1002B90E8(a1, 9);
  sub_1002B84A8(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = v10;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B1024@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2 + 32;
  if (sub_1002B9204(a1, *(void *)(a2 + 32), *(void *)(a2 + 40)))
  {
    sub_1002B90E8(a1, 10);
    sub_1002B820C(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v9 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      uint64_t v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B92B4(a1, @"Generic Failure", @"Invalid Geofence Entry");
    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      long long v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)std::string buf = v12;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B1354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1002B1394@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(a2 + 32) == 3)
  {
    *(_DWORD *)(a1 + 480) = 3;
    *(unsigned char *)(a1 + 484) = 1;
    if (sub_1002B9384(a1))
    {
      sub_100134750(&v8, "In the process of entering Home LOI");
      double result = *(double *)&v8;
      *(_OWORD *)a3 = v8;
      *(void *)(a3 + 16) = v9;
      *(unsigned char *)(a3 + 24) = 1;
      return result;
    }
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(char *)(v6 + 31) < 0)
  {
    sub_1000DC48C(&v8, *(void **)(v6 + 8), *(void *)(v6 + 16));
  }
  else
  {
    long long v7 = *(_OWORD *)(v6 + 8);
    uint64_t v9 = *(void *)(v6 + 24);
    long long v8 = v7;
  }
  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B1464@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v21 = *(_OWORD *)(a2 + 32);
  if ((sub_1002B9204((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v13 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v14 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v14;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B92B4((uint64_t)a1, @"Generic Failure", @"Invalid Geofence Exit");
    uint64_t v10 = a1[2];
    if (*(char *)(v10 + 31) < 0) {
      goto LABEL_51;
    }
LABEL_41:
    long long v15 = *(_OWORD *)(v10 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v10 + 24);
    *(_OWORD *)std::string buf = v15;
    goto LABEL_52;
  }
  if (a1[49] != (void)v21 || a1[50] != *((void *)&v21 + 1))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v7 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v8 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      uint64_t v9 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v9;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v10 = a1[2];
    if (*(char *)(v10 + 31) < 0)
    {
LABEL_51:
      sub_1000DC48C(buf, *(void **)(v10 + 8), *(void *)(v10 + 16));
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  BOOL v16 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    unint64_t v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2081;
    *(void *)&buf[20] = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_1002B90E8((uint64_t)a1, 11);
  sub_100134750(buf, "Not in Active Location State");
LABEL_52:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B1B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1002B1B64@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v21 = *(_OWORD *)(a2 + 32);
  if ((sub_1002B9204((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v7 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v8 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B92B4((uint64_t)a1, @"Generic Failure", @"Invalid Geofence Entry");
  }
  if (a1[49] == (void)v21 && a1[50] == *((void *)&v21 + 1))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v12 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v13 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v14 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      long long v15 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v15;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      uint64_t v11 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B90E8((uint64_t)a1, 11);
    sub_1002B83F4((uint64_t)a1, v21, *((uint64_t *)&v21 + 1), 10);
  }
  uint64_t v16 = a1[2];
  if (*(char *)(v16 + 31) < 0)
  {
    sub_1000DC48C(buf, *(void **)(v16 + 8), *(void *)(v16 + 16));
  }
  else
  {
    long long v17 = *(_OWORD *)(v16 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v16 + 24);
    *(_OWORD *)std::string buf = v17;
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B21E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1002B223C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1002B9604(a1, *(void *)(a1 + 392), *(void *)(a1 + 400), a2 + 32);
  sub_1002B83F4(a1, *(void *)(a1 + 392), *(void *)(a1 + 400), 10);
  (***(void (****)(void))(a1 + 328))();
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(char *)(v5 + 31) < 0)
  {
    sub_1000DC48C(&v8, *(void **)(v5 + 8), *(void *)(v5 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v5 + 8);
    uint64_t v9 = *(void *)(v5 + 24);
    long long v8 = v6;
  }
  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B230C@<D0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  sub_1002B8734((uint64_t)a1, a2[4], a2[5], a2[6], a2[7], (uint64_t)&__p);
  if (v12 < 0) {
    operator delete(__p);
  }
  BOOL v6 = a1[49] == a2[4] && a1[50] == a2[5];
  if (v6 && sub_1002B8CB4((uint64_t)a1, a2[4], a2[5]))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}", buf, 0x12u);
    }
    sub_1002B90E8((uint64_t)a1, 9);
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    uint64_t v8 = a1[2];
    if (*(char *)(v8 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
    }
    else
    {
      long long v9 = *(_OWORD *)(v8 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v8 + 24);
      *(_OWORD *)std::string buf = v9;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B24A8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 40);
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
  sub_1002B84A8(a1, v5, v6, &v8);
  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_1002B253C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)(a1 + 488))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        uint64_t v44 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }
      int v23 = SHIBYTE(v44);
      long long v24 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      long long v25 = __dst;
      if (v23 < 0) {
        long long v25 = v24;
      }
      if (v42 >= 0) {
        long long v26 = __p;
      }
      else {
        long long v26 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v25;
      __int16 v46 = 2081;
      uint64_t v47 = v26;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v42 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v44) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v27 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v28 = *(void *)(a1 + 16);
      if (*(char *)(v28 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v28 + 8), *(void *)(v28 + 16));
      }
      else
      {
        long long v29 = *(_OWORD *)(v28 + 8);
        uint64_t v44 = *(void *)(v28 + 24);
        *(_OWORD *)std::string __dst = v29;
      }
      int v30 = SHIBYTE(v44);
      uint64_t v31 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      uint64_t v32 = __dst;
      if (v30 < 0) {
        uint64_t v32 = v31;
      }
      if (v42 >= 0) {
        uint64_t v33 = __p;
      }
      else {
        uint64_t v33 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v32;
      __int16 v46 = 2081;
      uint64_t v47 = v33;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v42 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v44) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v34 = *(void *)(a1 + 16);
    if (*(char *)(v34 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v34 + 8), *(void *)(v34 + 16));
      goto LABEL_78;
    }
    goto LABEL_76;
  }
  uint64_t v6 = *(void **)(a2 + 32);
  if (!v6)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    unsigned __int8 v18 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "#LOIManager, Received nil object in eventData, this shouldn't happen", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_42;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_26;
    }
    goto LABEL_106;
  }
  if (![v6 loiIdentifier])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    BOOL v20 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_42;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1) {
      goto LABEL_99;
    }
    goto LABEL_107;
  }
  sub_1002B9868((uint64_t)[*(id *)(a2 + 32) type], buf);
  long long v7 = (void **)(a1 + 368);
  if (*(char *)(a1 + 391) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)long long v7 = *(_OWORD *)buf;
  *(void *)(a1 + 384) = *(void *)&buf[16];
  long long v8 = (char *)[[[objc_msgSend(*(id *)(a2 + 32), "loiIdentifier") UUIDString] UTF8String];
  size_t v9 = strlen(v8);
  *(void *)(a1 + 408) = sub_1002383B4((uint64_t)buf, (unsigned __int8 *)v8, (unsigned __int8 *)&v8[v9]);
  *(void *)(a1 + 416) = v10;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    id v12 = [[*(id *)(a2 + 32) loiIdentifier] description];
    long long v13 = (void **)(a1 + 368);
    if (*(char *)(a1 + 391) < 0) {
      long long v13 = (void **)*v7;
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2113;
    *(void *)&buf[20] = v12;
    __int16 v46 = 2081;
    uint64_t v47 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved location of interest\", \"LOI ID\":%{private, location:escape_only}@, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);
  }
  int v14 = *(char *)(a1 + 391);
  if (v14 < 0)
  {
    if (*(void *)(a1 + 376) != 4) {
      goto LABEL_37;
    }
    long long v7 = (void **)*v7;
LABEL_36:
    if (*(_DWORD *)v7 != 1701670760) {
      goto LABEL_37;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v37 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      LOWORD(__dst[0]) = 0;
      uint64_t v40 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)", "%s\n", v40);
      if (v40 != buf) {
        free(v40);
      }
    }
    if (sub_1002B9B28(a1, (uint64_t)[*(id *)(a2 + 32) loiIdentifier]))
    {
      *(_WORD *)(a1 + 488) = 256;
      uint64_t v34 = *(void *)(a1 + 16);
      if (*(char *)(v34 + 31) < 0)
      {
        sub_1000DC48C(buf, *(void **)(v34 + 8), *(void *)(v34 + 16));
        goto LABEL_78;
      }
LABEL_76:
      long long v35 = *(_OWORD *)(v34 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v34 + 24);
      *(_OWORD *)std::string buf = v35;
      goto LABEL_78;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v38 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "LOI Manager, Failed To request related LOIs", buf, 2u);
    }
    if (!sub_10013D1A0(115, 0)) {
      goto LABEL_42;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 == -1)
    {
LABEL_26:
      LOWORD(__dst[0]) = 0;
      std::string v19 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)", "%s\n", v19);
      goto LABEL_100;
    }
LABEL_106:
    dispatch_once(&qword_102419450, &stru_1022A4658);
    goto LABEL_26;
  }
  if (v14 == 4) {
    goto LABEL_36;
  }
LABEL_37:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  long long v21 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "LOI Manager, Not a Home LOI", buf, 2u);
  }
  if (!sub_10013D1A0(115, 2)) {
    goto LABEL_42;
  }
  bzero(buf, 0x65CuLL);
  if (qword_102419450 == -1) {
    goto LABEL_99;
  }
LABEL_107:
  dispatch_once(&qword_102419450, &stru_1022A4658);
LABEL_99:
  LOWORD(__dst[0]) = 0;
  std::string v19 = (char *)_os_log_send_and_compose_impl();
  sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)", "%s\n", v19);
LABEL_100:
  if (v19 != buf) {
    free(v19);
  }
LABEL_42:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  std::string v22 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    LOWORD(__dst[0]) = 0;
    std::string v39 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)", "%s\n", v39);
    if (v39 != buf) {
      free(v39);
    }
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
  sub_100134750(buf, "Not in Active Location State");
LABEL_78:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B30E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B310C@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 488))
  {
    sub_1002B92B4(a1, @"Home LOI Entry Failure", @"LOI Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        uint64_t v26 = *(void *)(v7 + 24);
        *(_OWORD *)std::string __dst = v8;
      }
      int v9 = SHIBYTE(v26);
      uint64_t v10 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      uint64_t v11 = __dst;
      if (v9 < 0) {
        uint64_t v11 = v10;
      }
      if (v24 >= 0) {
        id v12 = __p;
      }
      else {
        id v12 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v28 = 2081;
      long long v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v13 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        uint64_t v26 = *(void *)(v14 + 24);
        *(_OWORD *)std::string __dst = v15;
      }
      int v16 = SHIBYTE(v26);
      long long v17 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      unsigned __int8 v18 = __dst;
      if (v16 < 0) {
        unsigned __int8 v18 = v17;
      }
      if (v24 >= 0) {
        std::string v19 = __p;
      }
      else {
        std::string v19 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v28 = 2081;
      long long v29 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v20 = *(void *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v20 + 8), *(void *)(v20 + 16));
    }
    else
    {
      long long v21 = *(_OWORD *)(v20 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)std::string buf = v21;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B3470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B3498(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)(a1 + 488))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    unsigned __int8 v18 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(a1 + 16);
      if (*(char *)(v19 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v19 + 8), *(void *)(v19 + 16));
      }
      else
      {
        long long v20 = *(_OWORD *)(v19 + 8);
        uint64_t v46 = *(void *)(v19 + 24);
        *(_OWORD *)std::string __dst = v20;
      }
      int v27 = SHIBYTE(v46);
      __int16 v28 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      long long v29 = __dst;
      if (v27 < 0) {
        long long v29 = v28;
      }
      if (v44 >= 0) {
        int v30 = __p;
      }
      else {
        int v30 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v29;
      __int16 v48 = 2081;
      uint64_t v49 = v30;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v44 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v46) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v31 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v32 = *(void *)(a1 + 16);
      if (*(char *)(v32 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v32 + 8), *(void *)(v32 + 16));
      }
      else
      {
        long long v33 = *(_OWORD *)(v32 + 8);
        uint64_t v46 = *(void *)(v32 + 24);
        *(_OWORD *)std::string __dst = v33;
      }
      int v34 = SHIBYTE(v46);
      long long v35 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      uint64_t v36 = __dst;
      if (v34 < 0) {
        uint64_t v36 = v35;
      }
      if (v44 >= 0) {
        uint64_t v37 = __p;
      }
      else {
        uint64_t v37 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v36;
      __int16 v48 = 2081;
      uint64_t v49 = v37;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v44 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v46) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v26 = *(void *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_81;
    }
    goto LABEL_79;
  }
  if (![*(id *)(a2 + 32) _loiIdentifier])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v21 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    std::string v22 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update", "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    }
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    goto LABEL_28;
  }
  [objc_msgSend(*(id *)(a2 + 32), "referenceLocation") coordinate];
  double v7 = v6;
  [objc_msgSend(*(id *)(a2 + 32), "referenceLocation") coordinate];
  sub_1002B9C20(a1, v7, v8);
  sub_1002B9C90((uint64_t)[*(id *)(a2 + 32) userType], buf);
  int v9 = (void **)(a1 + 368);
  if (*(char *)(a1 + 391) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)int v9 = *(_OWORD *)buf;
  *(void *)(a1 + 384) = *(void *)&buf[16];
  uint64_t v10 = (char *)[[[objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier") UUIDString] UTF8String];
  size_t v11 = strlen(v10);
  *(void *)(a1 + 408) = sub_1002383B4((uint64_t)buf, (unsigned __int8 *)v10, (unsigned __int8 *)&v10[v11]);
  *(void *)(a1 + 416) = v12;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  long long v13 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    id v14 = [[[*(id *)(a2 + 32) _loiIdentifier] UUIDString] UTF8String];
    long long v15 = (void **)(a1 + 368);
    if (*(char *)(a1 + 391) < 0) {
      long long v15 = (void **)*v9;
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2081;
    *(void *)&buf[20] = v14;
    __int16 v48 = 2081;
    uint64_t v49 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);
  }
  int v16 = *(char *)(a1 + 391);
  if ((v16 & 0x80000000) == 0)
  {
    long long v17 = (_DWORD *)(a1 + 368);
    if (v16 != 4) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (*(void *)(a1 + 376) == 4)
  {
    long long v17 = *v9;
LABEL_31:
    if (*v17 != 1701670760) {
      goto LABEL_32;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v25 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      LOWORD(__dst[0]) = 0;
      char v42 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v42);
      if (v42 != buf) {
        free(v42);
      }
    }
    if (!sub_1002B9B28(a1, (uint64_t)[*(id *)(a2 + 32) _loiIdentifier]))
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      std::string v39 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "LOI Manager, Failed To request related LOIs", buf, 2u);
      }
      if (!sub_10013D1A0(115, 0)) {
        goto LABEL_37;
      }
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      LOWORD(__dst[0]) = 0;
      uint64_t v40 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v40);
      goto LABEL_97;
    }
    *(_WORD *)(a1 + 488) = 256;
    uint64_t v26 = *(void *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_81;
    }
LABEL_79:
    long long v38 = *(_OWORD *)(v26 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v26 + 24);
    *(_OWORD *)std::string buf = v38;
    goto LABEL_81;
  }
LABEL_32:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  int v23 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "LOI Manager, Not a Home LOI", buf, 2u);
  }
  if (!sub_10013D1A0(115, 2)) {
    goto LABEL_37;
  }
  bzero(buf, 0x65CuLL);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  LOWORD(__dst[0]) = 0;
  uint64_t v40 = (char *)_os_log_send_and_compose_impl();
  sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v40);
LABEL_97:
  if (v40 != buf) {
    free(v40);
  }
LABEL_37:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  char v24 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    LOWORD(__dst[0]) = 0;
    uint64_t v41 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v41);
    if (v41 != buf) {
      free(v41);
    }
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
LABEL_28:
  (*(void (**)(void))(**(void **)(a1 + 328) + 32))(*(void *)(a1 + 328));
  sub_100134750(buf, "Not in Active Location State");
LABEL_81:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
}

void sub_1002B3FF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B4018@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  double v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "LOI Manager, Failed To fetch place inferences", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    LOWORD(__dst[0]) = 0;
    char v24 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::FailedToFetchedPlaceInference(const CLMiLoLoiManagerFailedToFetchPlaceInference *)", "%s\n", v24);
    if (v24 != buf) {
      free(v24);
    }
  }
  if (*(unsigned char *)(a1 + 488))
  {
    sub_1002B92B4(a1, @"Home LOI Entry Failure", @"Place Inference Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    (*(void (**)(void))(**(void **)(a1 + 328) + 32))(*(void *)(a1 + 328));
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    double v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        uint64_t v28 = *(void *)(v8 + 24);
        *(_OWORD *)std::string __dst = v9;
      }
      int v10 = SHIBYTE(v28);
      size_t v11 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      uint64_t v12 = __dst;
      if (v10 < 0) {
        uint64_t v12 = v11;
      }
      if (v26 >= 0) {
        long long v13 = __p;
      }
      else {
        long long v13 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v12;
      __int16 v30 = 2081;
      uint64_t v31 = v13;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    id v14 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v15 = *(void *)(a1 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        uint64_t v28 = *(void *)(v15 + 24);
        *(_OWORD *)std::string __dst = v16;
      }
      int v17 = SHIBYTE(v28);
      unsigned __int8 v18 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      uint64_t v19 = __dst;
      if (v17 < 0) {
        uint64_t v19 = v18;
      }
      if (v26 >= 0) {
        long long v20 = __p;
      }
      else {
        long long v20 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v19;
      __int16 v30 = 2081;
      uint64_t v31 = v20;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v21 = *(void *)(a1 + 16);
    if (*(char *)(v21 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v21 + 8), *(void *)(v21 + 16));
    }
    else
    {
      long long v22 = *(_OWORD *)(v21 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v21 + 24);
      *(_OWORD *)std::string buf = v22;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B44CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B44F4@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 489))
  {
    double v6 = (_OWORD *)(a1 + 368);
    *(void *)(a1 + 392) = (*(uint64_t (**)(void, uint64_t, uint64_t, char *))(**(void **)(a1 + 328) + 24))(*(void *)(a1 + 328), a1 + 368, a1 + 408, a2 + 32);
    *(void *)(a1 + 400) = v7;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v8 = (_OWORD *)(a1 + 392);
    long long v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(a1 + 392, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    if (*(unsigned char *)v8)
    {
LABEL_11:
      (*(void (**)(void))(**(void **)(a1 + 328) + 40))(*(void *)(a1 + 328));
      if (*(unsigned char *)(a1 + 484))
      {
        uint64_t v11 = *(unsigned int *)(a1 + 480);
        *(unsigned char *)(a1 + 484) = 0;
      }
      else
      {
        uint64_t v11 = 1;
      }
      uint64_t v17 = *(void *)(a1 + 328);
      if (*(char *)(a1 + 391) < 0)
      {
        sub_1000DC48C(v32, *(void **)(a1 + 368), *(void *)(a1 + 376));
      }
      else
      {
        *(_OWORD *)uint64_t v32 = *v6;
        uint64_t v33 = *(void *)(a1 + 384);
      }
      (*(void (**)(uint64_t, void **, void, void, uint64_t))(*(void *)v17 + 16))(v17, v32, *(void *)(a1 + 392), *(void *)(a1 + 400), v11);
      if (SHIBYTE(v33) < 0) {
        operator delete(v32[0]);
      }
      sub_100134750(buf, "In Home LOI State");
    }
    else
    {
      uint64_t v15 = 0;
      while (v15 != 15)
      {
        if (*(unsigned __int8 *)(a1 + 393 + v15++))
        {
          if ((unint64_t)(v15 - 1) < 0xF) {
            goto LABEL_11;
          }
          break;
        }
      }
      std::string::assign((std::string *)(a1 + 368), "unknown");
      *uint64_t v8 = 0u;
      *(_OWORD *)(a1 + 408) = 0u;
      *(void *)(a1 + 448) = *(void *)(a1 + 440);
      if (*(unsigned char *)(a1 + 484)) {
        *(unsigned char *)(a1 + 484) = 0;
      }
      sub_100134750(buf, "Not in Active Location State");
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v12 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(a1 + 16);
      if (*(char *)(v13 + 31) < 0)
      {
        sub_1000DC48C(&__p, *(void **)(v13 + 8), *(void *)(v13 + 16));
      }
      else
      {
        long long v14 = *(_OWORD *)(v13 + 8);
        __p.__r_.__value_.__r.__words[2] = *(void *)(v13 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
      }
      int v18 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
      sub_10026E398(a2, (uint64_t)v34);
      long long v20 = &__p;
      if (v18 < 0) {
        long long v20 = (std::string *)v19;
      }
      if (v35 >= 0) {
        uint64_t v21 = v34;
      }
      else {
        uint64_t v21 = (void **)v34[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v38 = 2081;
      std::string v39 = v21;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v35 < 0) {
        operator delete(v34[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v22 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v23 = *(void *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_1000DC48C(&__p, *(void **)(v23 + 8), *(void *)(v23 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)(v23 + 8);
        __p.__r_.__value_.__r.__words[2] = *(void *)(v23 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v24;
      }
      int v25 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v26 = __p.__r_.__value_.__r.__words[0];
      sub_10026E398(a2, (uint64_t)v34);
      int v27 = &__p;
      if (v25 < 0) {
        int v27 = (std::string *)v26;
      }
      if (v35 >= 0) {
        uint64_t v28 = v34;
      }
      else {
        uint64_t v28 = (void **)v34[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v38 = 2081;
      std::string v39 = v28;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v35 < 0) {
        operator delete(v34[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v29 = *(void *)(a1 + 16);
    if (*(char *)(v29 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v29 + 8), *(void *)(v29 + 16));
    }
    else
    {
      long long v30 = *(_OWORD *)(v29 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v29 + 24);
      *(_OWORD *)std::string buf = v30;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B4A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::bad_cast a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B4AD8@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 489))
  {
    sub_1002B92B4(a1, @"Home LOI Entry Failure", @"Related LOI Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    double v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        uint64_t v26 = *(void *)(v7 + 24);
        *(_OWORD *)std::string __dst = v8;
      }
      int v9 = SHIBYTE(v26);
      int v10 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      uint64_t v11 = __dst;
      if (v9 < 0) {
        uint64_t v11 = v10;
      }
      if (v24 >= 0) {
        uint64_t v12 = __p;
      }
      else {
        uint64_t v12 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v28 = 2081;
      uint64_t v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v13 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        uint64_t v26 = *(void *)(v14 + 24);
        *(_OWORD *)std::string __dst = v15;
      }
      int v16 = SHIBYTE(v26);
      uint64_t v17 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      int v18 = __dst;
      if (v16 < 0) {
        int v18 = v17;
      }
      if (v24 >= 0) {
        std::string::size_type v19 = __p;
      }
      else {
        std::string::size_type v19 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v28 = 2081;
      uint64_t v29 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v20 = *(void *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v20 + 8), *(void *)(v20 + 16));
    }
    else
    {
      long long v21 = *(_OWORD *)(v20 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)std::string buf = v21;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B4E3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B4E64@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v6 = (long long *)a1[55];
  uint64_t v7 = (long long *)a1[56];
  if (v6 == v7)
  {
LABEL_8:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(a2 + 32, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v12 = (_OWORD *)(a2 + 32);
    uint64_t v14 = (_OWORD *)a1[56];
    unint64_t v13 = a1[57];
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = a1[55];
      uint64_t v17 = ((uint64_t)v14 - v16) >> 4;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60) {
        sub_1001D7FD4();
      }
      uint64_t v19 = v13 - v16;
      if (v19 >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20) {
        long long v21 = (char *)sub_1000C571C((uint64_t)(a1 + 57), v20);
      }
      else {
        long long v21 = 0;
      }
      int v27 = &v21[16 * v17];
      __int16 v28 = &v21[16 * v20];
      *(_OWORD *)int v27 = *v12;
      long long v15 = v27 + 16;
      long long v30 = (char *)a1[55];
      uint64_t v29 = (char *)a1[56];
      if (v29 != v30)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v29 - 1);
          v27 -= 16;
          v29 -= 16;
        }
        while (v29 != v30);
        uint64_t v29 = (char *)a1[55];
      }
      a1[55] = v27;
      a1[56] = v15;
      a1[57] = v28;
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      _OWORD *v14 = *v12;
      long long v15 = v14 + 1;
    }
    a1[56] = v15;
    uint64_t v26 = a1[2];
    if (*(char *)(v26 + 31) < 0)
    {
LABEL_52:
      sub_1000DC48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_53;
    }
  }
  else
  {
    long long v8 = (void *)(a2 + 32);
    while (1)
    {
      long long v35 = *v6;
      if ((void)v35 == *v8 && *((void *)&v35 + 1) == *(void *)(a2 + 40)) {
        break;
      }
      if (++v6 == v7) {
        goto LABEL_8;
      }
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    long long v22 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      uint64_t v23 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    char v24 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      int v25 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v25;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got enable custom LOI request from the same service, ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v26 = a1[2];
    if (*(char *)(v26 + 31) < 0) {
      goto LABEL_52;
    }
  }
  long long v31 = *(_OWORD *)(v26 + 8);
  *(void *)&uint8_t buf[16] = *(void *)(v26 + 24);
  *(_OWORD *)std::string buf = v31;
LABEL_53:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B5388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1002B53D0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v24 = *(_OWORD *)(a2 + 32);
  if ((void)v24 == *(void *)(a1 + 408) && *((void *)&v24 + 1) == *(void *)(a1 + 416))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    sub_1002B9F50(a1);
    unint64_t v13 = *(_OWORD **)(a1 + 440);
    uint64_t v14 = *(_OWORD **)(a1 + 448);
    while (v13 != v14)
    {
      *(_OWORD *)std::string buf = *v13;
      sub_1002B9604(a1, v24, *((uint64_t *)&v24 + 1), (uint64_t)buf);
      ++v13;
    }
    uint64_t v15 = -1;
  }
  else
  {
    uint64_t v6 = a1 + 408;
    if (*(unsigned char *)(a1 + 408))
    {
LABEL_6:
      memset(&__p, 0, sizeof(__p));
      if ((sub_1001E86C0(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &off_10229E8C8;
        sub_1001E91E8((uint64_t)buf);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v7 = &__p;
      }
      else {
        uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      long long v8 = [+[NSString stringWithUTF8String:v7] uppercaseString];
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      [*(id *)(a1 + 320) removeGeofenceWithRegionId:v8];
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      unint64_t v16 = 0;
      while (v16 != 15)
      {
        unint64_t v17 = v16;
        if (*(unsigned __int8 *)(a1 + 409 + v16++))
        {
          if (v17 <= 0xE) {
            goto LABEL_6;
          }
          break;
        }
      }
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v19 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    unint64_t v20 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI", "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    uint64_t v15 = 35;
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
  sub_1002B83F4(a1, v24, *((uint64_t *)&v24 + 1), 10);
  (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), v15);
  sub_100134750(buf, "In Custom LOI State");
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B58D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

double sub_1002B5910@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)(a1 + 490))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        uint64_t v34 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }
      int v18 = SHIBYTE(v34);
      uint64_t v19 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      unint64_t v20 = __dst;
      if (v18 < 0) {
        unint64_t v20 = v19;
      }
      if (v32 >= 0) {
        long long v21 = __p;
      }
      else {
        long long v21 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v36 = 2081;
      uint64_t v37 = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v34) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    long long v22 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v23 = *(void *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v23 + 8), *(void *)(v23 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)(v23 + 8);
        uint64_t v34 = *(void *)(v23 + 24);
        *(_OWORD *)std::string __dst = v24;
      }
      int v25 = SHIBYTE(v34);
      uint64_t v26 = (void **)__dst[0];
      sub_10026E398((char *)a2, (uint64_t)__p);
      int v27 = __dst;
      if (v25 < 0) {
        int v27 = v26;
      }
      if (v32 >= 0) {
        __int16 v28 = __p;
      }
      else {
        __int16 v28 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v36 = 2081;
      uint64_t v37 = v28;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v34) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v14 = *(void *)(a1 + 16);
    if (*(char *)(v14 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v14 + 8), *(void *)(v14 + 16));
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  uint64_t v6 = *(void **)(a2 + 32);
  [v6 coordinate];
  *(void *)(a1 + 336) = v7;
  [v6 coordinate];
  *(void *)(a1 + 344) = v8;
  [*(id *)(a1 + 320) removeGeofencesNearLocationWithLatitude:*(double *)(a1 + 336)];
  [v6 horizontalAccuracy];
  *(void *)(a1 + 352) = v9;
  [v6 verticalAccuracy];
  *(void *)(a1 + 360) = v10;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 336);
    unint64_t v13 = *(void ***)(a1 + 344);
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2049;
    *(void *)&buf[20] = v12;
    __int16 v36 = 2049;
    uint64_t v37 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", buf, 0x26u);
  }
  [*(id *)(a1 + 320) setGeofenceAtLocation:v6];
  *(_WORD *)(a1 + 490) = 256;
  uint64_t v14 = *(void *)(a1 + 16);
  if ((*(char *)(v14 + 31) & 0x80000000) == 0)
  {
LABEL_39:
    long long v29 = *(_OWORD *)(v14 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v14 + 24);
    *(_OWORD *)std::string buf = v29;
    goto LABEL_40;
  }
  sub_1000DC48C(buf, *(void **)(v14 + 8), *(void *)(v14 + 16));
LABEL_40:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B5D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B5D4C@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  uint64_t v7 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo... aborting request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (*(unsigned char *)(a1 + 490))
  {
    sub_1002B92B4(a1, @"Custom LOI Entry Failure", @"Failed to get current Location");
    (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), 35);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        uint64_t v28 = *(void *)(v9 + 24);
        *(_OWORD *)std::string __dst = v10;
      }
      int v11 = SHIBYTE(v28);
      uint64_t v12 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      unint64_t v13 = __dst;
      if (v11 < 0) {
        unint64_t v13 = v12;
      }
      if (v26 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v30 = 2081;
      long long v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v15 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        uint64_t v28 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }
      int v18 = SHIBYTE(v28);
      uint64_t v19 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      unint64_t v20 = __dst;
      if (v18 < 0) {
        unint64_t v20 = v19;
      }
      if (v26 >= 0) {
        long long v21 = __p;
      }
      else {
        long long v21 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v30 = 2081;
      long long v31 = v21;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v22 = *(void *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v22 + 8), *(void *)(v22 + 16));
    }
    else
    {
      long long v23 = *(_OWORD *)(v22 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)std::string buf = v23;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B61E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B6210@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)(a1 + 491))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 16);
      if (*(char *)(v10 + 31) < 0)
      {
        sub_1000DC48C(&__p, *(void **)(v10 + 8), *(void *)(v10 + 16));
      }
      else
      {
        long long v11 = *(_OWORD *)(v10 + 8);
        __p.__r_.__value_.__r.__words[2] = *(void *)(v10 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v11;
      }
      int v12 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v13 = __p.__r_.__value_.__r.__words[0];
      sub_10026E398((char *)a2, (uint64_t)v25);
      p_p = &__p;
      if (v12 < 0) {
        p_p = (std::string *)v13;
      }
      if (v26 >= 0) {
        uint64_t v15 = v25;
      }
      else {
        uint64_t v15 = (void **)v25[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      __int16 v29 = 2081;
      __int16 v30 = v15;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(v25[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v16 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v17 = *(void *)(a1 + 16);
      if (*(char *)(v17 + 31) < 0)
      {
        sub_1000DC48C(&__p, *(void **)(v17 + 8), *(void *)(v17 + 16));
      }
      else
      {
        long long v18 = *(_OWORD *)(v17 + 8);
        __p.__r_.__value_.__r.__words[2] = *(void *)(v17 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
      }
      int v19 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v20 = __p.__r_.__value_.__r.__words[0];
      sub_10026E398((char *)a2, (uint64_t)v25);
      long long v21 = &__p;
      if (v19 < 0) {
        long long v21 = (std::string *)v20;
      }
      if (v26 >= 0) {
        uint64_t v22 = v25;
      }
      else {
        uint64_t v22 = (void **)v25[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v21;
      __int16 v29 = 2081;
      __int16 v30 = v22;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(v25[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v8 = *(void *)(a1 + 16);
    if (*(char *)(v8 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  *(_OWORD *)(a1 + 408) = *(_OWORD *)(a2 + 32);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0(a1 + 408, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    uint64_t v7 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2081;
    *(void *)&buf[20] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if ((*(char *)(v8 + 31) & 0x80000000) == 0)
  {
LABEL_43:
    long long v23 = *(_OWORD *)(v8 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v8 + 24);
    *(_OWORD *)std::string buf = v23;
    goto LABEL_44;
  }
  sub_1000DC48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
LABEL_44:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B6658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::bad_cast a20)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002B6694@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  uint64_t v7 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (*(unsigned char *)(a1 + 491))
  {
    sub_1002B92B4(a1, @"Custom LOI Entry Failure", @"Failed to set geofence");
    (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), 35);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 448) = *(void *)(a1 + 440);
    if (*(unsigned char *)(a1 + 484)) {
      *(unsigned char *)(a1 + 484) = 0;
    }
    sub_100134750(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        uint64_t v28 = *(void *)(v9 + 24);
        *(_OWORD *)std::string __dst = v10;
      }
      int v11 = SHIBYTE(v28);
      int v12 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      std::string::size_type v13 = __dst;
      if (v11 < 0) {
        std::string::size_type v13 = v12;
      }
      if (v26 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v30 = 2081;
      long long v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v15 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1000DC48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        uint64_t v28 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }
      int v18 = SHIBYTE(v28);
      int v19 = (void **)__dst[0];
      sub_10026E398(a2, (uint64_t)__p);
      std::string::size_type v20 = __dst;
      if (v18 < 0) {
        std::string::size_type v20 = v19;
      }
      if (v26 >= 0) {
        long long v21 = __p;
      }
      else {
        long long v21 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v30 = 2081;
      long long v31 = v21;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }
    uint64_t v22 = *(void *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_1000DC48C(buf, *(void **)(v22 + 8), *(void *)(v22 + 16));
    }
    else
    {
      long long v23 = *(_OWORD *)(v22 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)std::string buf = v23;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002B6B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B6B58()
{
}

void sub_1002B6DF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B6E64()
{
}

void sub_1002B70FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7170()
{
}

void sub_1002B7370(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B73DC()
{
}

void sub_1002B7714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7770()
{
}

void sub_1002B7790()
{
}

void sub_1002B7A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_101A57464();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B7AA8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1022A3BA8;
  uint64_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 8) = off_1022A3C10;
  uint64_t v4 = *(void **)(a1 + 440);
  if (v4)
  {
    *(void *)(a1 + 448) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 391) < 0) {
    operator delete(*(void **)(a1 + 368));
  }
  nullsub_41(a1 + 304, a2);
  nullsub_41(a1 + 296, v5);
  nullsub_41(a1 + 288, v6);
  nullsub_41(a1 + 280, v7);
  nullsub_41(a1 + 272, v8);
  nullsub_41(a1 + 264, v9);
  nullsub_41(a1 + 256, v10);
  nullsub_41(a1 + 248, v11);
  nullsub_41(a1 + 240, v12);
  nullsub_41(a1 + 232, v13);
  nullsub_41(a1 + 224, v14);
  nullsub_41(a1 + 216, v15);
  nullsub_41(a1 + 208, v16);
  nullsub_41(a1 + 200, v17);
  nullsub_41(a1 + 192, v18);
  nullsub_41(a1 + 184, v19);
  nullsub_41(a1 + 176, v20);
  nullsub_41(a1 + 168, v21);
  nullsub_41(a1 + 160, v22);
  nullsub_41(a1 + 152, v23);
  nullsub_41(a1 + 144, v24);
  nullsub_41(a1 + 136, v25);
  nullsub_41(a1 + 128, v26);
  nullsub_41(a1 + 120, v27);
  nullsub_41(a1 + 112, v28);
  nullsub_41(a1 + 104, v29);
  nullsub_41(a1 + 96, v30);
  nullsub_41(a1 + 88, v31);
  nullsub_41(a1 + 80, v32);
  nullsub_41(a1 + 72, v33);
  nullsub_41(a1 + 64, v34);
  sub_10026E720(v3);
  return a1;
}

uint64_t sub_1002B7C2C(uint64_t a1, uint64_t a2)
{
  return sub_1002B7AA8(a1 - 8, a2);
}

void sub_1002B7C34(uint64_t a1, uint64_t a2)
{
  sub_1002B7AA8(a1, a2);

  operator delete();
}

void sub_1002B7C6C(uint64_t a1, uint64_t a2)
{
  sub_1002B7AA8(a1 - 8, a2);

  operator delete();
}

id sub_1002B7CA8(uint64_t a1, void *a2)
{
  if (!a2)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "void CLMicroLocationLoiManager::setupWithLoiBridge(id<CLMicroLocationLoiBridgeProtocol>)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
  id v5 = a2;
  *(void *)(a1 + 320) = v5;
  return [v5 setMicroLocationLoiClient:a1];
}

void sub_1002B7E54(uint64_t a1, long long *a2)
{
  id v5 = off_1022A3438;
  uint64_t v4 = (std::string *)sub_100134750(&__p, "No Name Given");
  id v5 = off_1022A4688;
  long long v8 = *a2;
  std::string::assign(v4, "Enable Custom LOI");
  sub_10026ED70((void *)(a1 + 8), (uint64_t)&v5);
  id v5 = off_1022A3438;
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1002B7F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7F64(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v9 = off_1022A3438;
  long long v8 = (std::string *)sub_100134750(&__p, "No Name Given");
  uint64_t v9 = off_1022A46A8;
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  long long v14 = *a4;
  std::string::assign(v8, "Disable Custom LOI");
  sub_10026ED70((void *)(a1 + 8), (uint64_t)&v9);
  uint64_t v9 = off_1022A3438;
  if (v11 < 0) {
    operator delete(__p);
  }
}

void sub_1002B805C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B8088(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::string *)sub_100134750(v7, "No Name Given");
  uint64_t v6 = off_1022A46C8;
  std::string::assign(v4, "Leeched Location Update");
  v7[3] = a2;
  sub_10026ED70((void *)(a1 + 8), (uint64_t)&v6);
  return sub_1002C5384((uint64_t)&v6);
}

void sub_1002B8134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_1002B8168(uint64_t a1)
{
  sub_1002C53FC(v2);
  sub_10026ED70((void *)(a1 + 8), (uint64_t)v2);
  v2[0] = off_1022A3438;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_1002B81D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002B820C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  long long v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0((uint64_t)&v14, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v13 = 2082;
    *(void *)&void v13[2] = "";
    *(_WORD *)&v13[10] = 2081;
    *(void *)&v13[12] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry event for valid LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v5 = v14;
    uint64_t v4 = v15;
  }
  sub_1002B83F4(a1, v5, v4, 10);
  return sub_100134750(a4, "In Custom LOI State");
}

void sub_1002B83C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002B83F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1002BA0F0(a1, @"Custom Loi", @"Entry");
  sub_100134750(&__p, "custom");
  sub_1002BA01C(a1, a2, a3, &__p, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1002BA190(a1, a2, a3);
}

void sub_1002B848C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002B84A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  long long v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#LOI Manager, kick off creating custom LOI process", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::handleEnableCustomLoi(CLMiLoService::ServiceUuid)", "%s\n", v23);
    if (v23 != (char *)buf) {
      free(v23);
    }
  }
  [*(id *)(a1 + 320) getCurrentLocation];
  uint64_t v10 = *(void **)(a1 + 448);
  unint64_t v9 = *(void *)(a1 + 456);
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = *(void *)(a1 + 440);
    uint64_t v13 = ((uint64_t)v10 - v12) >> 4;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v15 = v9 - v12;
    if (v15 >> 3 > v14) {
      unint64_t v14 = v15 >> 3;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16) {
      uint64_t v17 = (char *)sub_1000C571C(a1 + 456, v16);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = &v17[16 * v13];
    uint64_t v19 = &v17[16 * v16];
    *(void *)uint64_t v18 = a2;
    *((void *)v18 + 1) = a3;
    char v11 = v18 + 16;
    uint64_t v21 = *(char **)(a1 + 440);
    uint64_t v20 = *(char **)(a1 + 448);
    if (v20 != v21)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v20 - 1);
        v18 -= 16;
        v20 -= 16;
      }
      while (v20 != v21);
      uint64_t v20 = *(char **)(a1 + 440);
    }
    *(void *)(a1 + 440) = v18;
    *(void *)(a1 + 448) = v11;
    *(void *)(a1 + 456) = v19;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    void *v10 = a2;
    v10[1] = a3;
    char v11 = v10 + 2;
  }
  *(void *)(a1 + 448) = v11;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  return sub_100134750(a4, "In the process of entering Custom LOI");
}

void *sub_1002B8734@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v25[0] = a2;
  v25[1] = a3;
  v24[0] = a4;
  v24[1] = a5;
  sub_1002B8A50(a1, a2, a3, (uint64_t)v24);
  if (sub_1002B8CB4(a1, a2, a3))
  {
    memset(&v19, 0, sizeof(v19));
    if ((sub_1001E86C0((uint64_t)v25, &v19) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0((uint64_t)v24, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &off_10229E8C8;
      sub_1001E91E8((uint64_t)buf);
    }
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v10 = &v19;
    }
    else {
      uint64_t v10 = (std::string *)v19.__r_.__value_.__r.__words[0];
    }
    char v11 = [+[NSString stringWithUTF8String:v10] uppercaseString];
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v12 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = &v19;
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v13 = (std::string *)v19.__r_.__value_.__r.__words[0];
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v21 = 2082;
      *(void *)&void v21[2] = "";
      *(_WORD *)&v21[10] = 2081;
      *(void *)&v21[12] = v13;
      __int16 v22 = 2081;
      uint64_t v23 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, No More services monitoring this LOI, disable geofence for LOI\", \"loiID\":%{private, location:escape_only}s, \"Service Id\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    [*(id *)(a1 + 320) removeGeofenceWithRegionId:v11];
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }
  double result = (void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 328) + 8))(*(void *)(a1 + 328), -1);
  uint64_t v16 = *(void *)(a1 + 16);
  if (*(char *)(v16 + 31) < 0) {
    return sub_1000DC48C((unsigned char *)a6, *(void **)(v16 + 8), *(void *)(v16 + 16));
  }
  long long v17 = *(_OWORD *)(v16 + 8);
  *(void *)(a6 + 16) = *(void *)(v16 + 24);
  *(_OWORD *)a6 = v17;
  return result;
}

void sub_1002B89F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::bad_cast a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void sub_1002B8A50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_1001E86C0(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)std::string buf = &off_10229E8C8;
    sub_1001E91E8((uint64_t)buf);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
      sub_1001E91E8((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    char v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      char v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)unint64_t v14 = 2082;
    *(void *)&long long v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    uint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Removing LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_100203860(*(void *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_1002B8C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::bad_cast a22,uint64_t a23,uint64_t a24,std::bad_cast a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1002B8CB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  sub_100203884(*(void *)(a1 + 312), (uint64_t)v7, v5);
  BOOL v3 = v5[1] == v5[0];
  uint64_t v6 = (void **)v5;
  sub_1000A7B4C(&v6);
  return v3;
}

BOOL sub_1002B8D3C(uint64_t a1, double a2, double a3)
{
  sub_100206EC0(*(void *)(a1 + 312));
  if (sub_1002083F4(*(void *)(a1 + 312)))
  {
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    if (!*(unsigned char *)(a1 + 472)) {
      goto LABEL_25;
    }
    double v7 = Current_5;
    double v8 = *(double *)(a1 + 464);
    sub_1000C7F88(buf);
    v18[0] = 0.0;
    CFStringRef v9 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRefreshRoutineStateThrottle", 0x8000100u, kCFAllocatorNull);
    int v10 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v9, v18);
    CFRelease(v9);
    double v11 = v7 - v8;
    double v12 = v18[0];
    if (v20) {
      sub_1000DB0A0(v20);
    }
    double v13 = 0.1;
    if (v10) {
      double v13 = v12;
    }
    if (v11 >= v13)
    {
LABEL_25:
      sub_1002B9C20(a1, a2, a3);
      return sub_1002BA2D4(a1);
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    unint64_t v14 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring refreshRoutineStateAtLocation request since last request was too recent", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
LABEL_22:
      LOWORD(v18[0]) = 0;
      long long v17 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationLoiManager::refreshRoutineStateAtLocation(double, double)", "%s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
      return 0;
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v16 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignoring refreshRoutineStateAtLocation request since keybag is not unlocked", buf, 2u);
    }
    BOOL result = sub_10013D1A0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      goto LABEL_22;
    }
  }
  return result;
}

void sub_1002B90C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B90E8(uint64_t a1, uint64_t a2)
{
  if (a2 == 11) {
    sub_1002BA0F0(a1, @"Custom Loi", @"Exit");
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 448) = *(void *)(a1 + 440);
  if (*(unsigned char *)(a1 + 484)) {
    *(unsigned char *)(a1 + 484) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_1000DC48C(__p, *(void **)(a1 + 368), *(void *)(a1 + 376));
    uint64_t v6 = *(void *)(a1 + 392);
    uint64_t v5 = *(void *)(a1 + 400);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 368);
    uint64_t v8 = *(void *)(a1 + 384);
  }
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, __p, v6, v5, a2);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B91E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B9204(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  sub_100203B78(*(void *)(a1 + 312), &v10);
  if (v10 == v11)
  {
    char v3 = 0;
    if (!v10) {
      return v3 & 1;
    }
    goto LABEL_11;
  }
  char v3 = 0;
  uint64_t v4 = v10;
  do
  {
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    v4 += 2;
    BOOL v8 = v12 == v5 && v13 == v6;
    v3 |= v8;
  }
  while (v4 != v11);
  if (v10) {
LABEL_11:
  }
    operator delete(v10);
  return v3 & 1;
}

void sub_1002B92B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = @"loiRelatedFailureOccurred";
  v6[1] = @"failureType";
  v7[0] = &off_1023924C8;
  v7[1] = a2;
  void v7[2] = a3;
  _DWORD v6[2] = @"failureReason";
  void v6[3] = @"fsmStateDuringFailure";
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)(v3 + 8);
  if (*(char *)(v3 + 31) < 0) {
    uint64_t v4 = (void *)*v4;
  }
  v7[3] = +[NSString stringWithUTF8String:v4];
  uint64_t v5 = +[NSDictionary dictionaryWithObjects:v7 forKeys:v6 count:4];
  sub_1002BA3E8((uint64_t)v5, @"com.apple.MicroLocation.LOIFailures", (uint64_t)v5);
}

BOOL sub_1002B9384(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  BOOL v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (!*(unsigned char *)(a1 + 484)) {
      sub_10020D700();
    }
    sub_1002E580C(*(_DWORD *)(a1 + 480), __p);
    if (v9 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    int v11 = 0;
    __int16 v12 = 2082;
    uint64_t v13 = "";
    __int16 v14 = 2081;
    __int16 v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Attempting to fetch place inference\", \"Reason:\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v4 = *(void *)(a1 + 320);
  if (v4)
  {
    (*(void (**)(void))(**(void **)(a1 + 328) + 40))(*(void *)(a1 + 328));
    [*(id *)(a1 + 320) fetchPlaceInferenceAtCurrentLocation];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    uint64_t v6 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Bridge not setup.", "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
    }
  }
  return v4 != 0;
}

void sub_1002B9604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_1001E86C0(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)std::string buf = &off_10229E8C8;
    sub_1001E91E8((uint64_t)buf);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_1001E86C0((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_10229E8C8;
      sub_1001E91E8((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    double v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      double v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)__int16 v14 = 2082;
    *(void *)&long long v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    uint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Adding LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_10020356C(*(void *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_1002B9810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::bad_cast a22,uint64_t a23,uint64_t a24,std::bad_cast a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void *sub_1002B9868@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case -1:
      uint64_t v3 = "other";
      goto LABEL_13;
    case 0:
      uint64_t v3 = "home";
      goto LABEL_13;
    case 1:
      uint64_t v3 = "work";
      goto LABEL_13;
    case 2:
      uint64_t v3 = "school";
      goto LABEL_13;
    case 3:
      uint64_t v3 = "gym";
LABEL_13:
      BOOL result = sub_100134750(a2, v3);
      break;
    default:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      uint64_t v4 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
        uint64_t v6 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)", "%s\n", v6);
        if (v6 != (char *)buf) {
          free(v6);
        }
      }
      BOOL result = sub_100134750(a2, "none");
      break;
  }
  return result;
}

BOOL sub_1002B9B28(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 320);
  if (v2)
  {
    [*(id *)(a1 + 320) fetchRelatedLoisForLoi:a2];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 68289026;
      v5[1] = 0;
      __int16 v6 = 2082;
      double v7 = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", (uint8_t *)v5, 0x12u);
    }
  }
  return v2 != 0;
}

void sub_1002B9C20(uint64_t a1, double a2, double a3)
{
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (!*(unsigned char *)(a1 + 472)) {
    *(unsigned char *)(a1 + 472) = 1;
  }
  *(double *)(a1 + 464) = Current_5;
  *(double *)(a1 + 336) = a2;
  *(double *)(a1 + 344) = a3;
  if (*(char *)(a1 + 391) < 0)
  {
    **(unsigned char **)(a1 + 368) = 0;
    *(void *)(a1 + 376) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 368) = 0;
    *(unsigned char *)(a1 + 391) = 0;
  }
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
}

void *sub_1002B9C90@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
      uint64_t v3 = "other";
      goto LABEL_13;
    case 1:
      uint64_t v3 = "home";
      goto LABEL_13;
    case 2:
      uint64_t v3 = "work";
      goto LABEL_13;
    case 3:
      uint64_t v3 = "school";
      goto LABEL_13;
    case 4:
      uint64_t v3 = "gym";
LABEL_13:
      BOOL result = sub_100134750(a2, v3);
      break;
    default:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      uint64_t v4 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", buf, 2u);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
        __int16 v6 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)", "%s\n", v6);
        if (v6 != (char *)buf) {
          free(v6);
        }
      }
      BOOL result = sub_100134750(a2, "none");
      break;
  }
  return result;
}

void sub_1002B9F50(uint64_t a1)
{
  v4[0] = &off_1023924C8;
  v3[0] = @"createdCustomLoi";
  v3[1] = @"geofenceLocationHorizontalAccuracy";
  v4[1] = +[NSNumber numberWithDouble:*(double *)(a1 + 352)];
  v3[2] = @"geofenceLocationVerticalAccuracy";
  v4[2] = +[NSNumber numberWithDouble:*(double *)(a1 + 360)];
  uint64_t v2 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:3];
  sub_1002BA3E8((uint64_t)v2, @"com.apple.MicroLocation.CustomLoiCreation", (uint64_t)v2);
}

void sub_1002BA01C(uint64_t a1, uint64_t a2, uint64_t a3, std::string *__str, uint64_t a5)
{
  *(void *)(a1 + 392) = a2;
  *(void *)(a1 + 400) = a3;
  uint64_t v7 = a1 + 368;
  std::string::operator=((std::string *)(a1 + 368), __str);
  uint64_t v8 = *(void *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_1000DC48C(__p, *(void **)(a1 + 368), *(void *)(a1 + 376));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v7;
    uint64_t v10 = *(void *)(v7 + 16);
  }
  (*(void (**)(uint64_t, void **, void, void, uint64_t))(*(void *)v8 + 16))(v8, __p, *(void *)(a1 + 392), *(void *)(a1 + 400), a5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002BA0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BA0F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = @"customLoiVisitOccurred";
  v4[1] = @"loiType";
  v5[0] = &off_1023924C8;
  v5[1] = a2;
  v4[2] = @"visitEventType";
  _DWORD v5[2] = a3;
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:3];
  sub_1002BA3E8((uint64_t)v3, @"com.apple.MicroLocation.CustomLoiVisitEvent", (uint64_t)v3);
}

void sub_1002BA190(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v16 = a2;
  *((void *)&v16 + 1) = a3;
  uint64_t v13 = 0;
  __int16 v14 = 0;
  __int16 v15 = 0;
  uint64_t v4 = (char *)sub_1000C571C((uint64_t)&v15, 1uLL);
  __int16 v6 = &v4[16 * v5];
  *(_OWORD *)uint64_t v4 = v16;
  uint64_t v7 = v4 + 16;
  std::string v9 = (char *)v13;
  uint64_t v8 = v14;
  if (v14 != v13)
  {
    do
    {
      *((_OWORD *)v4 - 1) = *((_OWORD *)v8 - 1);
      v4 -= 16;
      v8 -= 16;
    }
    while (v8 != v9);
    uint64_t v8 = (char *)v13;
  }
  uint64_t v13 = v4;
  __int16 v14 = v7;
  __int16 v15 = v6;
  if (v8) {
    operator delete(v8);
  }
  __int16 v14 = v7;
  uint64_t v10 = *(void *)(a1 + 312);
  sub_100134750(__p, "custom");
  sub_10020650C(v10, (uint64_t)&v16, (uint64_t)&v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v13)
  {
    __int16 v14 = (char *)v13;
    operator delete(v13);
  }
}

void sub_1002BA29C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002BA2D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 320);
  if (v1)
  {
    [*(id *)(a1 + 320) fetchLocationOfInterestAtLocation:[objc_alloc((Class)CLLocation) initWithLatitude:*(double *)(a1 + 336) longitude:*(double *)(a1 + 344)]];
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 68289026;
      v4[1] = 0;
      __int16 v5 = 2082;
      __int16 v6 = "";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", (uint8_t *)v4, 0x12u);
    }
  }
  return v1 != 0;
}

void sub_1002BA3E8(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1000C7F88(buf);
  v13[0] = 0;
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  char v6 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v5, v13);
  CFRelease(v5);
  BOOL v7 = v13[0];
  if (*(void *)v15) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v15);
  }
  if (v7) {
    char v8 = 0;
  }
  else {
    char v8 = v6;
  }
  if (v8)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    std::string v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#LOI Manager, CoreAnalytics Disabled", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      *(_WORD *)uint64_t v13 = 0;
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(NSString *, NSDictionary *)", "%s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      id v12 = [a2 UTF8String];
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v15 = 2082;
      *(void *)&long long v15[2] = "";
      __int16 v16 = 2081;
      id v17 = v12;
      __int16 v18 = 2113;
      uint64_t v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", buf, 0x26u);
    }
    AnalyticsSendEvent();
  }
}

void sub_1002BA698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1000DB0A0(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BA6BC(uint64_t a1, void *a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LOI Manager, handleVisitNotification", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  if ([a2 hasDepartureDate])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    CFStringRef v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit exit", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      char v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    *(void *)std::string buf = off_1022A3438;
    sub_100134750(&__p, "No Name Given");
    *(void *)std::string buf = off_1022A4708;
    id v12 = a2;
    std::string::assign(&__p, "LOI Visit Exit");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    *(void *)std::string buf = off_1022A4708;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    char v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit entry", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      std::string v9 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    *(void *)std::string buf = off_1022A3438;
    sub_100134750(&__p, "No Name Given");
    *(void *)std::string buf = off_1022A4728;
    id v12 = a2;
    std::string::assign(&__p, "LOI Visit Entry");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    *(void *)std::string buf = off_1022A4728;
  }
  *(void *)std::string buf = off_1022A3438;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1002BABD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BAC38(uint64_t a1)
{
  *(void *)a1 = off_1022A4708;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1002BACB0(uint64_t a1)
{
  *(void *)a1 = off_1022A4728;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1002BAD28(uint64_t a1, void *a2, void *a3)
{
  if (a3)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    char v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)[objc_msgSend(objc_msgSend(a3, "description"), "UTF8String") UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    BOOL v7 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      id v8 = [[objc_msgSend(a3, "description") UTF8String];
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Bridge, Failed To fetch place inferences", "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", buf, 0x1Cu);
    }
  }
  if (![a2 count])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v10 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LOI Bridge, received no place inferences, we will start leeching and wait for next location update", buf, 2u);
    }
    if (!sub_10013D1A0(115, 2)) {
      goto LABEL_25;
    }
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)", "%s\n", v11);
    goto LABEL_31;
  }
  id v9 = [a2 objectAtIndexedSubscript:0];
  if ([v9 _loiIdentifier])
  {
    *(void *)std::string buf = off_1022A3438;
    sub_100134750(&__p, "No Name Given");
    *(void *)std::string buf = off_1022A4768;
    id v15 = v9;
    std::string::assign(&__p, "Fetched Place Inference For Current Location");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    sub_1002C56B4((uint64_t)buf);
    return;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4658);
  }
  id v12 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)", "%s\n", v11);
LABEL_31:
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
LABEL_25:
  sub_1002C55D4(buf);
  sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
  *(void *)std::string buf = off_1022A3438;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1002BB224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
}

void sub_1002BB284(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    char v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136380675;
      *(void *)((char *)&buf + 4) = [objc_msgSend(a4, "description") UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#Warning LOI Manager, Error retrieving the current LOI. %{private}s", (uint8_t *)&buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
      [objc_msgSend(a4, "description") UTF8String];
      id v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleFetchedLocationOfInterestAtLocation(CLMicroLocationLoi *, CLLocation *, NSError *)", "%s\n", v8);
      if (v8 != (char *)&buf) {
        free(v8);
      }
    }
    sub_1002C572C(&buf);
    sub_10026ED70((void *)(a1 + 8), (uint64_t)&buf);
    *(void *)&long long buf = off_1022A3438;
  }
  else
  {
    sub_100134750((void *)&buf + 1, "No Name Given");
    *(void *)&long long buf = off_1022A47A8;
    id v11 = a2;
    std::string::assign((std::string *)((char *)&buf + 8), "Got LOI Event");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)&buf);
    *(void *)&long long buf = off_1022A47A8;

    *(void *)&long long buf = off_1022A3438;
  }
  if (v10 < 0) {
    operator delete(*((void **)&buf + 1));
  }
}

void sub_1002BB52C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_1001C7F8C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BB598(uint64_t a1)
{
  *(void *)a1 = off_1022A47A8;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1002BB610(uint64_t a1, void *a2, std::string::size_type a3)
{
  if (a3)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    CFStringRef v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    char v6 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Manager, Error retrieving related LOIs for Loi", "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
    }
    sub_1002C586C(buf);
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    *(void *)long long buf = off_1022A3438;
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v7 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_36:
      operator delete(v7);
    }
  }
  else
  {
    std::string __p = 0;
    long long v35 = 0;
    unint64_t v36 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v9 = [a2 countByEnumeratingWithState:&v30 objects:v40 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v31;
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v10) {
            objc_enumerationMutation(a2);
          }
          id v12 = (char *)[(*(id *)(*((void *)&v30 + 1) + 8 * i)) UUIDString UTF8String];
          size_t v13 = strlen(v12);
          uint64_t v14 = sub_1002383B4((uint64_t)buf, (unsigned __int8 *)v12, (unsigned __int8 *)&v12[v13]);
          uint64_t v16 = v14;
          uint64_t v17 = v15;
          __int16 v18 = v35;
          if ((unint64_t)v35 >= v36)
          {
            uint64_t v20 = ((char *)v35 - (unsigned char *)__p) >> 4;
            unint64_t v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 60) {
              sub_1001D7FD4();
            }
            uint64_t v22 = v36 - (void)__p;
            if ((uint64_t)(v36 - (void)__p) >> 3 > v21) {
              unint64_t v21 = v22 >> 3;
            }
            if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v23 = v21;
            }
            if (v23) {
              uint64_t v24 = (char *)sub_1000C571C((uint64_t)&v36, v23);
            }
            else {
              uint64_t v24 = 0;
            }
            uint64_t v25 = (uint64_t *)&v24[16 * v20];
            *uint64_t v25 = v16;
            v25[1] = v17;
            uint64_t v27 = __p;
            uint64_t v26 = v35;
            uint64_t v28 = (char *)v25;
            if (v35 != __p)
            {
              do
              {
                *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
                v28 -= 16;
                v26 -= 2;
              }
              while (v26 != v27);
              uint64_t v26 = __p;
            }
            uint64_t v19 = v25 + 2;
            std::string __p = v28;
            long long v35 = v25 + 2;
            unint64_t v36 = (unint64_t)&v24[16 * v23];
            if (v26) {
              operator delete(v26);
            }
          }
          else
          {
            *long long v35 = v14;
            v18[1] = v15;
            uint64_t v19 = v18 + 2;
          }
          long long v35 = v19;
        }
        id v9 = [a2 countByEnumeratingWithState:&v30 objects:v40 count:16];
      }
      while (v9);
    }
    *(void *)long long buf = off_1022A3438;
    sub_100134750(&v38, "No Name Given");
    *(void *)long long buf = off_1022A47E8;
    memset(v39, 0, 24);
    sub_10027C3B4((char *)v39, (char *)__p, (uint64_t)v35, ((char *)v35 - (unsigned char *)__p) >> 4);
    std::string::assign(&v38, "Got Related LOIs");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    sub_1002C594C((uint64_t)buf);
    BOOL v7 = __p;
    if (__p)
    {
      long long v35 = (uint64_t *)__p;
      goto LABEL_36;
    }
  }
}

void sub_1002BBA2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002BBAD4(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    CFStringRef v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v21 = 2114;
      uint64_t v22 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    char v6 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v21 = 2114;
      uint64_t v22 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    sub_1002C59C8(buf);
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    *(void *)long long buf = off_1022A3438;
    if (v23 < 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    sub_1002C5A70(buf, a2);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    id v8 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      [a2 coordinate];
      uint64_t v10 = v9;
      [a2 coordinate];
      v12[0] = 68289539;
      v12[1] = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2049;
      uint64_t v16 = v10;
      __int16 v17 = 2049;
      uint64_t v18 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", (uint8_t *)v12, 0x26u);
    }
    sub_10026ED70((void *)(a1 + 8), (uint64_t)buf);
    sub_1002C5B60((uint64_t)buf);
  }
}

void sub_1002BBD8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_1002BBDEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    sub_1002C5BD8(&v12);
    sub_10026ED70((void *)(a1 + 8), (uint64_t)&v12);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    BOOL v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    id v8 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    id v12 = off_1022A3438;
  }
  else
  {
    id v12 = off_1022A3438;
    uint64_t v11 = (std::string *)sub_100134750(&__p, "No Name Given");
    id v12 = off_1022A4868;
    uint64_t v15 = a3;
    uint64_t v16 = a4;
    std::string::assign(v11, "Started Process of Activaing Geofence");
    sub_10026ED70((void *)(a1 + 8), (uint64_t)&v12);
    id v12 = off_1022A3438;
  }
  if (v14 < 0) {
    operator delete(__p);
  }
}

void sub_1002BC040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BC090(uint64_t a1, void *a2, uint64_t a3)
{
  sub_100134750(&__p, (char *)[a2 UTF8String]);
  sub_1002E58D4((uint64_t)&__p, (uint64_t)&v25);
  if (SBYTE3(v21) < 0) {
    operator delete(__p);
  }
  if (v27)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    char v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v7;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Got Geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
    }
    if (a3 == 1)
    {
      if (!v27) {
        sub_10020D700();
      }
      uint64_t v8 = v25;
      uint64_t v9 = v26;
      std::string __p = off_1022A3438;
      uint64_t v10 = (std::string *)sub_100134750(v19, "No Name Given");
      std::string __p = off_1022A4888;
      *(void *)&void v23[2] = v8;
      uint64_t v24 = v9;
      std::string::assign(v10, "Geofence Entry");
      sub_10026ED70((void *)(a1 + 8), (uint64_t)&__p);
    }
    else
    {
      if (!v27) {
        sub_10020D700();
      }
      uint64_t v15 = v25;
      uint64_t v16 = v26;
      std::string __p = off_1022A3438;
      __int16 v17 = (std::string *)sub_100134750(v19, "No Name Given");
      std::string __p = &off_1022A48A8;
      *(void *)&void v23[2] = v15;
      uint64_t v24 = v16;
      std::string::assign(v17, "Geofence Exit");
      sub_10026ED70((void *)(a1 + 8), (uint64_t)&__p);
    }
    std::string __p = off_1022A3438;
    if ((v23[1] & 0x80000000) != 0) {
      operator delete(*(void **)v19);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    uint64_t v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      id v12 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v12;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got invalid geofence ID\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    __int16 v13 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      id v14 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v14;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got invalid geofence ID", "{\"msg%{public}.0s\":\"LOI Manager, Got invalid geofence ID\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
    }
  }
}

void sub_1002BC448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BC490(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    CFStringRef v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4658);
      }
    }
    char v6 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Failed to RemoveGeofence", "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
    id v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, didRemoveGeofenceWithId\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
    }
  }
}

void *sub_1002BC6D0@<X0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002AFEDC((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BCB70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BCB9C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  sub_1002B84A8((uint64_t)v5, v6[4], v6[5], buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002BD048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BD074@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  sub_1002B8734((uint64_t)v5, v6[4], v6[5], v6[6], v6[7], (uint64_t)buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002BD524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BD550@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B0384((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BD9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002BDA1C@<X0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        char v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B06E8((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BDEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BDEE8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    id v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      __int16 v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        id v7 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = (void **)v7;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B0A80((uint64_t)v5, a3);
}

void sub_1002BE384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BE3B0@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B0C64((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BE850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BE87C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    id v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      __int16 v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        id v7 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = (void **)v7;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B0D28((uint64_t)v5, a3);
}

void sub_1002BED18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BED44@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B0E48((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BF1E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BF210@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B1024((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BF6B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BF6DC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B1394((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002BFB7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002BFBA8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B1464(v5, (uint64_t)v6, a3);
}

void sub_1002C0048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C0074@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B1B64(v5, (uint64_t)v6, a3);
}

void sub_1002C0514(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C0540@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B223C((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C09E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C0A0C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B230C(v5, v6, a3);
}

void sub_1002C0EAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C0ED8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 8;
  if (!a2) {
    uint64_t v2 = 0;
  }
  *(_WORD *)(v2 + 488) = 1;
}

double sub_1002C0EF0@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B24A8((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C1390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C13BC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }
  sub_1002B820C((uint64_t)v5, v6[4], v6[5], buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_1002C1868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C1894@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B253C((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C1D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C1D60@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B310C((uint64_t)v5, v6, a3);
}

void sub_1002C2200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C222C(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    id v7 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }
        else
        {
          long long v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }
        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v15 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }
        else
        {
          long long v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }
        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (v7[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      __int16 v22 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }
        else
        {
          long long v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }
        int v25 = SHIBYTE(v31);
        id v7 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = (void **)v7;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  sub_1002B3498((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C26CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C26F8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B4018((uint64_t)v5, v6, a3);
}

void sub_1002C2B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C2BC4@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B44F4((uint64_t)v5, v6, a3);
}

void sub_1002C3064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C3090@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B4AD8((uint64_t)v5, v6, a3);
}

void sub_1002C3530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C355C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 8;
  if (!a2) {
    uint64_t v2 = 0;
  }
  *(_WORD *)(v2 + 490) = 1;
}

double sub_1002C3574@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B4E64(v5, (uint64_t)v6, a3);
}

void sub_1002C3A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C3A40@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B53D0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C3EE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C3F0C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B5910((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C43AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C43D8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B5D4C((uint64_t)v5, v6, a3);
}

void sub_1002C4878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C48A4@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B6210((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1002C4D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002C4D70@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0;
  }
  if (!lpsrc
  {
    int v8 = &qword_102419000;
    if (qword_102419450 != -1) {
      goto LABEL_54;
    }
    while (1)
    {
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        long long v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }
        else
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }
        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      uint64_t v16 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        long long v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }
        else
        {
          long long v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }
        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10026E398(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
        if (v8[138] != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4658);
        }
      }
      char v23 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        long long v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1000DC48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }
        else
        {
          long long v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }
        int v26 = SHIBYTE(v32);
        int v8 = (uint64_t *)__dst[0];
        CFStringRef v5 = __p;
        sub_10026E398(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = (void **)v8;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        char v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      sub_101A57498();
      __break(1u);
LABEL_54:
      dispatch_once(&qword_102419450, &stru_1022A4658);
    }
  }

  return sub_1002B6694((uint64_t)v5, v6, a3);
}

void sub_1002C5210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C523C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002C526C(uint64_t a1)
{
  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void sub_1002C52DC(uint64_t a1)
{
  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void sub_1002C534C(uint64_t a1)
{
  sub_1002C5384(a1);

  operator delete();
}

uint64_t sub_1002C5384(uint64_t a1)
{
  *(void *)a1 = off_1022A46C8;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1002C53FC(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A46E8;
  std::string::assign(v2, "Refresh Location on regular interval");
  return a1;
}

void sub_1002C5484(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C54A4(uint64_t a1)
{
  *(void *)a1 = off_1022A4708;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void sub_1002C553C(uint64_t a1)
{
  *(void *)a1 = off_1022A4728;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_1002C55D4(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A4748;
  std::string::assign(v2, "Failed To Fetched Place Inference");
  return a1;
}

void sub_1002C565C(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C567C(uint64_t a1)
{
  sub_1002C56B4(a1);

  operator delete();
}

uint64_t sub_1002C56B4(uint64_t a1)
{
  *(void *)a1 = off_1022A4768;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1002C572C(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A4788;
  std::string::assign(v2, "Failed to Get LOI Event");
  return a1;
}

void sub_1002C57B4(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C57D4(uint64_t a1)
{
  *(void *)a1 = off_1022A47A8;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_1002C586C(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A47C8;
  std::string::assign(v2, "Failed to Get Related LOIs");
  return a1;
}

void sub_1002C58F4(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C5914(uint64_t a1)
{
  sub_1002C594C(a1);

  operator delete();
}

uint64_t sub_1002C594C(uint64_t a1)
{
  *(void *)a1 = off_1022A47E8;
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1002C59C8(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A4808;
  std::string::assign(v2, "Failed To Get Location Update");
  return a1;
}

void sub_1002C5A50(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002C5A70(void *a1, void *a2)
{
  *a1 = off_1022A3438;
  uint64_t v4 = (std::string *)(a1 + 1);
  sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A4828;
  a1[4] = a2;
  std::string::assign(v4, "Got Location Update");
  return a1;
}

void sub_1002C5B08(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C5B28(uint64_t a1)
{
  sub_1002C5B60(a1);

  operator delete();
}

uint64_t sub_1002C5B60(uint64_t a1)
{
  *(void *)a1 = off_1022A4828;

  *(void *)a1 = off_1022A3438;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1002C5BD8(void *a1)
{
  *a1 = off_1022A3438;
  uint64_t v2 = (std::string *)sub_100134750(a1 + 1, "No Name Given");
  *a1 = off_1022A4848;
  std::string::assign(v2, "Failed To Set Geofence");
  return a1;
}

void sub_1002C5C60(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

std::runtime_error *sub_1002C5C80(std::runtime_error *a1, const std::string *a2)
{
  double result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&off_1022A2868;
  return result;
}

void sub_1002C5CB4(unsigned int a1)
{
  if (a1 < 2)
  {
    if (a1) {
      sub_1002C5E3C();
    }
    sub_1002C5D24();
  }
  sub_101A585E0();
}

void sub_1002C5D24()
{
}

void sub_1002C5DF8(uint64_t a1, ...)
{
  va_start(va1, a1);
  va_start(va, a1);
  uint64_t v1 = va_arg(va1, void);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  sub_1001EF958((uint64_t *)va);
  sub_1001EFA74((uint64_t *)va1);
  operator delete();
}

void sub_1002C5E3C()
{
}

void sub_1002C5F10(uint64_t a1, ...)
{
  va_start(va1, a1);
  va_start(va, a1);
  uint64_t v1 = va_arg(va1, void);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  sub_1001EF958((uint64_t *)va);
  sub_1001EFA74((uint64_t *)va1);
  operator delete();
}

void sub_1002C5F54(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002C5F84(void **a1@<X1>, void *a2@<X2>, double *a3@<X3>, unsigned char *a4@<X8>)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A48D8);
  }
  int v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a1 + 23) >= 0) {
      int v9 = a1;
    }
    else {
      int v9 = *a1;
    }
    *(_DWORD *)long long buf = 68289282;
    int v16 = 0;
    __int16 v17 = 2082;
    long long v18 = "";
    __int16 v19 = 2082;
    __int16 v20 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyEventRecordingRequest: client request recording scan\", \"client\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  if (*((char *)a1 + 23) < 0)
  {
    sub_1000DC48C(&__p, *a1, (unint64_t)a1[1]);
  }
  else
  {
    long long __p = *(_OWORD *)a1;
    int v12 = a1[2];
  }
  char v13 = 1;
  sub_1002E7EF4((uint64_t)&__p, a2, (uint64_t)v14);
  if (v13 && SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  sub_1002C61B8((uint64_t)v14, 0, 0, 3u, (uint64_t)v10, *a3);
  buf[0] = 1;
  sub_1002660C8(&v17);
  *a4 = buf[0];
  sub_1002660C8(a4 + 8);
  sub_10026633C(&v17);
  sub_10026633C(v10);
  sub_10024E568((wireless_diagnostics::google::protobuf::MessageLite *)v14);
}

void sub_1002C615C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1002C6198(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a33)
  {
    if (a32 < 0) {
      operator delete(__p);
    }
  }
  JUMPOUT(0x1002C6190);
}

void sub_1002C61B8(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (!sub_10023E774(v12))
  {
    __int16 v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    __int16 v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E6A54(a5, a1);
}

void sub_1002C62A0(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002C62B4(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002C62E4(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"])
  {
    sub_1002C6368(a1, a2, a3);
  }
  else
  {
    sub_1002C6904(a1, a2, a3);
  }
}

void sub_1002C6368(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  sub_10023DA98((uint64_t)v22);
  if ([a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"])
  {
    unsigned __int8 v6 = [[a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"] BOOLValue];
    v31 |= 0x100u;
    unsigned __int8 v27 = v6;
  }
  if ([a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"])
  {
    unsigned __int8 v7 = [[a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"] BOOLValue];
    v31 |= 0x200u;
    unsigned __int8 v28 = v7;
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"])
  {
    int v8 = (const std::string::value_type *)[objc_msgSend(a1[@"private.HomeKit.scene.actionSetUUID"], "UTF8String");
    v31 |= 2u;
    if (v23 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v23, v8);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetName"])
  {
    int v9 = (const std::string::value_type *)[a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetName"];
    v31 |= 4u;
    if (v24 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v24, v9);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetType"])
  {
    long long v10 = (const std::string::value_type *)[[[a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetType"] UTF8String];
    v31 |= 8u;
    if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v25, v10);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.clientName"])
  {
    long long v11 = (const std::string::value_type *)[[[a1 objectForKeyedSubscript:@"private.HomeKit.scene.clientName"] UTF8String];
    v31 |= 0x20u;
    if (v26 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v26, v11);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.source"])
  {
    unsigned int v12 = (const std::string::value_type *)[[[a1 objectForKeyedSubscript:@"private.HomeKit.scene.source"] UTF8String];
    v31 |= 0x80u;
    if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v29, v12);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.homeName"])
  {
    int v13 = (const std::string::value_type *)[a1 objectForKeyedSubscript:@"private.HomeKit.scene.homeName"];
    v31 |= 0x400u;
    if (v30 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v30, v13);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A48F8);
  }
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    __int16 v14 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      int v15 = v23;
      if (SHIBYTE(v23->__r_.__value_.__r.__words[2]) < 0) {
        int v15 = (std::string *)v23->__r_.__value_.__r.__words[0];
      }
      int v16 = v24;
      if (SHIBYTE(v24->__r_.__value_.__r.__words[2]) < 0) {
        int v16 = (std::string *)v24->__r_.__value_.__r.__words[0];
      }
      __int16 v17 = v25;
      if (SHIBYTE(v25->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v17 = (std::string *)v25->__r_.__value_.__r.__words[0];
      }
      long long v18 = v26;
      if (SHIBYTE(v26->__r_.__value_.__r.__words[2]) < 0) {
        long long v18 = (std::string *)v26->__r_.__value_.__r.__words[0];
      }
      __int16 v19 = v29;
      if (SHIBYTE(v29->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v19 = (std::string *)v29->__r_.__value_.__r.__words[0];
      }
      __int16 v20 = v30;
      if (SHIBYTE(v30->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v20 = (std::string *)v30->__r_.__value_.__r.__words[0];
      }
      uint64_t buf = 68291075;
      __int16 v33 = 2082;
      int v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v15;
      __int16 v37 = 2081;
      __int16 v38 = v16;
      __int16 v39 = 2081;
      __int16 v40 = v17;
      __int16 v41 = 2081;
      __int16 v42 = v18;
      __int16 v43 = 2081;
      char v44 = v19;
      __int16 v45 = 2081;
      uint64_t v46 = v20;
      __int16 v47 = 1025;
      int v48 = v27;
      __int16 v49 = 1025;
      int v50 = v28;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Scene\", \"actionSetUUID\":%{private, location:escape_only}s, \"actionSetName\":%{private, location:escape_only}s, \"actionSetType\":%{private, location:escape_only}s, \"clientName\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"homeName\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", (uint8_t *)&buf, 0x5Au);
    }
  }
  sub_1002C7024((uint64_t)v22, 0, 0, 3u, (uint64_t)v21, *a2);
  LOBYTE(buf) = 1;
  sub_1002660C8(&v33);
  *a3 = buf;
  sub_1002660C8(a3 + 8);
  sub_10026633C(&v33);
  sub_10026633C(v21);
  sub_1002538C0((wireless_diagnostics::google::protobuf::MessageLite *)v22);
}

void sub_1002C68C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_10026633C(v26);
  sub_10026633C(&a9);
  sub_1002538C0((wireless_diagnostics::google::protobuf::MessageLite *)&a26);
  _Unwind_Resume(a1);
}

void sub_1002C6904(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  sub_10023DA4C((uint64_t)v26);
  if ([a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"])
  {
    unsigned __int8 v6 = [[a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"] boolValue];
    v37 |= 0x400u;
    unsigned __int8 v30 = v6;
  }
  if ([a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"])
  {
    unsigned __int8 v7 = [[a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"] boolValue];
    v37 |= 0x800u;
    unsigned __int8 v31 = v7;
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"])
  {
    int v8 = (const std::string::value_type *)[[[a1 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"] UTF8String];
    v37 |= 2u;
    if (v27 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v27, v8);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceType"])
  {
    int v9 = (const std::string::value_type *)[a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceType"];
    v37 |= 0x10u;
    if (v28 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v28, v9);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.characteristicType"])
  {
    long long v10 = (const std::string::value_type *)[a1 objectForKeyedSubscript:@"private.HomeKit.accessory.characteristicType"];
    v37 |= 0x20u;
    if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v29, v10);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.source"])
  {
    long long v11 = (const std::string::value_type *)[a1 objectForKeyedSubscript:@"private.HomeKit.accessory.source"];
    v37 |= 0x100u;
    if (v32 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v32, v11);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.stateString"])
  {
    unsigned int v12 = (const std::string::value_type *)[[a1 objectForKeyedSubscript:@"private.HomeKit.accessory.stateString"] UTF8String];
    v37 |= 0x1000u;
    if (v34 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v34, v12);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceUUID"])
  {
    int v13 = (const std::string::value_type *)[objc_msgSend(a1[@"private.HomeKit.accessory.serviceUUID"], "UTF8String");
    v37 |= 0x200u;
    if (v33 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v33, v13);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceGroupUUID"])
  {
    __int16 v14 = (const std::string::value_type *)[objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", @"private.HomeKit.accessory.serviceGroupUUID"), "UTF8String");
    v37 |= 0x2000u;
    if (v35 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v35, v14);
  }
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.roomUUID"])
  {
    int v15 = (const std::string::value_type *)[((id)objc_msgSend(a1, "objectForKeyedSubscript:", @"private.HomeKit.accessory.roomUUID")) UTF8String];
    v37 |= 0x4000u;
    if (v36 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v36, v15);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A48F8);
  }
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    int v16 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      __int16 v17 = v27;
      if (SHIBYTE(v27->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v17 = (std::string *)v27->__r_.__value_.__r.__words[0];
      }
      long long v18 = v34;
      if (SHIBYTE(v34->__r_.__value_.__r.__words[2]) < 0) {
        long long v18 = (std::string *)v34->__r_.__value_.__r.__words[0];
      }
      __int16 v19 = v33;
      if (SHIBYTE(v33->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v19 = (std::string *)v33->__r_.__value_.__r.__words[0];
      }
      __int16 v20 = v35;
      if (SHIBYTE(v35->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v20 = (std::string *)v35->__r_.__value_.__r.__words[0];
      }
      id v21 = v28;
      if (SHIBYTE(v28->__r_.__value_.__r.__words[2]) < 0) {
        id v21 = (std::string *)v28->__r_.__value_.__r.__words[0];
      }
      __int16 v22 = v29;
      if (SHIBYTE(v29->__r_.__value_.__r.__words[2]) < 0) {
        __int16 v22 = (std::string *)v29->__r_.__value_.__r.__words[0];
      }
      char v23 = v32;
      if (SHIBYTE(v32->__r_.__value_.__r.__words[2]) < 0) {
        char v23 = (std::string *)v32->__r_.__value_.__r.__words[0];
      }
      long long v24 = v36;
      if (SHIBYTE(v36->__r_.__value_.__r.__words[2]) < 0) {
        long long v24 = (std::string *)v36->__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68291587;
      __int16 v40 = 2082;
      int v39 = 0;
      __int16 v41 = "";
      __int16 v42 = 2081;
      __int16 v43 = v17;
      __int16 v44 = 2081;
      __int16 v45 = v18;
      __int16 v46 = 2081;
      __int16 v47 = v19;
      __int16 v48 = 2081;
      __int16 v49 = v20;
      __int16 v50 = 2081;
      uint64_t v51 = v21;
      __int16 v52 = 2081;
      uint64_t v53 = v22;
      __int16 v54 = 2081;
      uint64_t v55 = v23;
      __int16 v56 = 2081;
      uint64_t v57 = v24;
      __int16 v58 = 1025;
      int v59 = v30;
      __int16 v60 = 1025;
      int v61 = v31;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Accessory\", \"accessoryUUID\":%{private, location:escape_only}s, \"accessoryState\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"serviceGroupUUID\":%{private, location:escape_only}s, \"serviceType\":%{private, location:escape_only}s, \"characteristicType\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"roomUUID\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", buf, 0x6Eu);
    }
  }
  sub_1002C7120((uint64_t)v26, 0, 0, 3u, (uint64_t)v25, *a2);
  buf[0] = 1;
  sub_1002660C8(&v40);
  *a3 = buf[0];
  sub_1002660C8(a3 + 8);
  sub_10026633C(&v40);
  sub_10026633C(v25);
  sub_100251E3C((wireless_diagnostics::google::protobuf::MessageLite *)v26);
}

void sub_1002C6F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_10026633C(v26);
  sub_10026633C(&a9);
  sub_100251E3C((wireless_diagnostics::google::protobuf::MessageLite *)&a26);
  _Unwind_Resume(a1);
}

BOOL sub_1002C6FB8(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0;
  }
  if ([a2 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"]) {
    return 1;
  }
  return [a2 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"] != 0;
}

void sub_1002C7024(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 48);
  if (!sub_10023E774(v12))
  {
    __int16 v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    __int16 v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E6694(a5, a1);
}

void sub_1002C710C(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002C7120(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  sub_10023DFC0(a5);
  unsigned int v12 = *(_DWORD *)(a1 + 64);
  if (!sub_10023E774(v12))
  {
    __int16 v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }
  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(unsigned char *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(unsigned char *)(a5 + 76) = a3;
  if ((sub_10023E744(a4) & 1) == 0)
  {
    __int16 v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1002E65F4(a5, a1);
}

void sub_1002C7208(_Unwind_Exception *a1)
{
  sub_10026633C(v1);
  _Unwind_Resume(a1);
}

void sub_1002C721C(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

double sub_1002C724C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_1022A4928;
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = a1 + 40;
  *(void *)(a1 + 48) = a1 + 40;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(void *)(a1 + 104) = a3;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = a2;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  return result;
}

void sub_1002C72BC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  sub_100203EA8(*(void *)(a1 + 104), a2, a3, &v21);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  unsigned __int8 v6 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = *(void *)a2;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v25 = 2082;
    uint64_t v26 = "";
    __int16 v27 = 2082;
    uint64_t v28 = v7;
    __int16 v29 = 2050;
    uint64_t v30 = 0x2E8BA2E8BA2E8BA3 * (v22 - v21);
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client queried services\", \"ClientId\":%{public, location:escape_only}s, \"NumServicesFound\":%{public}llu}", buf, 0x26u);
  }
  int v9 = v21;
  int v8 = v22;
  if (v21 != v22)
  {
    long long v18 = a4;
    do
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      long long v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v11 = a2;
        }
        else {
          uint64_t v11 = *(void *)a2;
        }
        uint64_t v12 = *v9;
        int v13 = operator new(0x28uLL);
        long long __p = v13;
        long long v20 = xmmword_101D048C0;
        *int v13 = 0u;
        v13[1] = 0u;
        *(void *)((char *)v13 + 29) = 0;
        sub_1001E0650((uint64_t)(v9 + 1), v13);
        p_p = &__p;
        if (v20 < 0) {
          p_p = __p;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v25 = 2082;
        uint64_t v26 = "";
        __int16 v27 = 2082;
        uint64_t v28 = v11;
        __int16 v29 = 2050;
        uint64_t v30 = v12;
        __int16 v31 = 2082;
        uint64_t v32 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client query result\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v20) < 0) {
          operator delete(__p);
        }
      }
      v9 += 11;
    }
    while (v9 != v8);
    int v15 = v21;
    int v16 = v22;
    char v23 = v18;
    while (v15 != v16)
    {
      __int16 v17 = v15 + 1;
      sub_1002D4958((__n128 *)buf, (__n128 *)(v15 + 1), *v15, *((unsigned int *)v15 + 14));
      sub_1002CE0E4(&v23, buf);
      int v15 = v17 + 10;
    }
  }
  *(void *)uint64_t buf = &v21;
  sub_10028B5B0((void ***)buf);
}

void sub_1002C759C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_1002C75EC(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (sub_1002083F4(*(void *)(a1 + 104)))
  {
    sub_100203EA8(*(void *)(a1 + 104), a2, a5, &v36);
    unint64_t v12 = sub_1002DC55C(a4);
    unint64_t v35 = v12;
    int v13 = v36;
    __int16 v14 = v37;
    if (v36 == v37)
    {
      unint64_t v15 = 0;
    }
    else
    {
      unint64_t v15 = 0;
      do
      {
        *(void *)uint64_t buf = sub_1002D4B0C(v13[7]);
        unint64_t v12 = sub_1002CE1DC(&v35, 0, (uint64_t)&v35, 0x20u, buf);
        uint64_t v16 = *v13;
        v13 += 11;
        if (v16 == a3) {
          uint64_t v17 = v12;
        }
        else {
          uint64_t v17 = 0;
        }
        v15 += v17;
      }
      while (v13 != v14);
    }
    if (sub_1002C7B30(v12, a3, v15))
    {
      *(_DWORD *)uint64_t buf = 0;
      sub_1001EE1F4((int *)buf);
      unint64_t v20 = sub_1001EC8C4((ssize_t)buf);
      uint64_t v22 = v21;
      v46.n128_u64[0] = v20;
      v46.n128_u64[1] = v21;
      sub_1001EF3E8((unsigned int *)buf);
      uint64_t v23 = *(void *)(a1 + 104);
      double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
      sub_1002DDA60((uint64_t)buf, v20, v22, a3, (long long *)a2, v35, (long long *)a5, Current_5);
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      int v34 = 0;
      __int16 v38 = &v32;
      char v39 = 0;
      uint64_t v32 = (char *)operator new(0x58uLL);
      uint64_t v33 = (uint64_t)v32;
      int v34 = v32 + 88;
      uint64_t v33 = sub_1002CE2A8((uint64_t)&v34, (uint64_t)buf, (uint64_t)&v46, (uint64_t)v32);
      sub_1002C7FA8(v23);
      __int16 v38 = &v32;
      sub_10028B5B0((void ***)&v38);
      if (v45 < 0) {
        operator delete(__p);
      }
      if (SBYTE5(v43) < 0) {
        operator delete(*(void **)&buf[32]);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      __int16 v25 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v26 = a2;
        }
        else {
          uint64_t v26 = *(void *)a2;
        }
        if (*(char *)(a5 + 23) < 0) {
          a5 = *(void *)a5;
        }
        __int16 v27 = (char *)operator new(0x28uLL);
        *(void *)(v27 + 29) = 0;
        *(_OWORD *)__int16 v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_1001E0650((uint64_t)&v46, v27);
        *(_DWORD *)uint64_t buf = 68290050;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v26;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = a5;
        *(_WORD *)&unsigned char buf[38] = 2050;
        unint64_t v41 = a3;
        __int16 v42 = 2082;
        __int16 v43 = v27;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager new service created for client\", \"ClientId\":%{public, location:escape_only}s, \"UserId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x3Au);
        operator delete(v27);
      }
      sub_1002D4958((__n128 *)buf, &v46, a3, v35);
      long long v28 = *(_OWORD *)&buf[16];
      *(_OWORD *)a6 = *(_OWORD *)buf;
      *(_OWORD *)(a6 + 16) = v28;
      *(unsigned char *)(a6 + 32) = 1;
      uint64_t v29 = -1;
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      uint64_t v30 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v31 = a2;
        }
        else {
          uint64_t v31 = *(void *)a2;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v31;
        *(_WORD *)&unsigned char buf[28] = 2050;
        *(void *)&buf[30] = a3;
        *(_WORD *)&unsigned char buf[38] = 2050;
        unint64_t v41 = v15;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager Client tried to create service, failed since not allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"NumIdenticalServices\":%{public}llu}", buf, 0x30u);
      }
      *(unsigned char *)a6 = 0;
      *(unsigned char *)(a6 + 32) = 0;
      uint64_t v29 = 21;
    }
    *(void *)(a6 + 40) = v29;
    *(void *)uint64_t buf = &v36;
    sub_10028B5B0((void ***)buf);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    long long v18 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = *(void *)a2;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v19;
      *(_WORD *)&unsigned char buf[28] = 2050;
      *(void *)&buf[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot create service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu}", buf, 0x26u);
    }
    *(unsigned char *)a6 = 0;
    *(unsigned char *)(a6 + 32) = 0;
    *(void *)(a6 + 40) = 22;
  }
}

void sub_1002C7A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char *a19)
{
  operator delete(v19);
  a19 = &a14;
  sub_10028B5B0((void ***)&a19);
  _Unwind_Resume(a1);
}

BOOL sub_1002C7B30(uint64_t a1, uint64_t a2, unint64_t a3)
{
  switch(a2)
  {
    case 1:
      sub_1000C7F88(buf);
      unsigned int v19 = 0;
      CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClient", 0x8000100u, kCFAllocatorNull);
      int v6 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v5, &v19);
      CFRelease(v5);
      goto LABEL_5;
    case 2:
      sub_1000C7F88(buf);
      unsigned int v19 = 0;
      CFStringRef v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClient", 0x8000100u, kCFAllocatorNull);
      int v6 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v7, &v19);
      CFRelease(v7);
      goto LABEL_5;
    case 3:
      sub_1000C7F88(buf);
      unsigned int v19 = 0;
      CFStringRef v8 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClient", 0x8000100u, kCFAllocatorNull);
      int v6 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v8, &v19);
      CFRelease(v8);
LABEL_5:
      unint64_t v9 = v19;
      if (*(void *)v21) {
        sub_1000DB0A0(*(std::__shared_weak_count **)v21);
      }
      if (v6) {
        unint64_t v10 = v9;
      }
      else {
        unint64_t v10 = 1;
      }
      goto LABEL_15;
    case 4:
      sub_1000C7F88(buf);
      unsigned int v19 = 0;
      CFStringRef v11 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClient", 0x8000100u, kCFAllocatorNull);
      int v12 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v11, &v19);
      CFRelease(v11);
      unint64_t v13 = v19;
      if (*(void *)v21) {
        sub_1000DB0A0(*(std::__shared_weak_count **)v21);
      }
      if (v12) {
        unint64_t v10 = v13;
      }
      else {
        unint64_t v10 = 50;
      }
LABEL_15:
      BOOL v14 = v10 > a3;
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      unint64_t v15 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68290050;
        *(_WORD *)unint64_t v21 = 2082;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(void *)&void v21[2] = "";
        __int16 v22 = 2050;
        uint64_t v23 = a2;
        __int16 v24 = 2050;
        unint64_t v25 = v10;
        __int16 v26 = 2050;
        uint64_t v27 = a3;
        __int16 v28 = 1026;
        BOOL v29 = v10 > a3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::isNewServiceAllowed\", \"ServiceType\":%{public}lu, \"Allowed\":%{public}lu, \"AlreadyCreated\":%{public}lu, \"Verdict\":%{public}hhd}", buf, 0x36u);
      }
      break;
    default:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      uint64_t v16 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v21 = 2082;
        *(void *)&void v21[2] = "";
        __int16 v22 = 2050;
        uint64_t v23 = a2;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", buf, 0x1Cu);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
      }
      uint64_t v17 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v21 = 2082;
        *(void *)&void v21[2] = "";
        __int16 v22 = 2050;
        uint64_t v23 = a2;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "unhandled serviceType", "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", buf, 0x1Cu);
      }
      BOOL v14 = 0;
      break;
  }
  return v14;
}

void sub_1002C7F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C7FA8(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 264);
    if (!v2) {
      operator new();
    }
    uint64_t v3 = sub_1002DE3E4(v2);
    sub_1002CE494(a1);
    return v3;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    CFStringRef v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      int v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMiLoServiceTable::Entry]", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    return 0;
  }
}

void sub_1002C81DC()
{
}

uint64_t sub_1002C8208(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

unint64_t sub_1002C824C@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int8 *a5@<X4>, __n128 *a6@<X8>)
{
  v32.n128_u64[0] = a3;
  v32.n128_u64[1] = a4;
  unint64_t result = sub_1002C84B0(a1, a3, a4);
  if (v13)
  {
    a6->n128_u8[0] = 0;
    a6[2].n128_u8[0] = 0;
    a6[2].n128_u64[1] = 23;
    return result;
  }
  sub_10020454C(*(void *)(a1 + 104), a3, a4, v25);
  if (v31)
  {
    uint64_t v14 = a2[23];
    if ((v14 & 0x80u) == 0) {
      uint64_t v15 = a2[23];
    }
    else {
      uint64_t v15 = *((void *)a2 + 1);
    }
    uint64_t v16 = v27;
    if ((v27 & 0x80u) != 0) {
      uint64_t v16 = v26[1];
    }
    if (v15 != v16) {
      goto LABEL_35;
    }
    if ((v27 & 0x80u) == 0) {
      uint64_t v17 = (unsigned __int8 *)v26;
    }
    else {
      uint64_t v17 = (unsigned __int8 *)v26[0];
    }
    if ((v14 & 0x80) != 0)
    {
      if (memcmp(*(const void **)a2, v17, *((void *)a2 + 1))) {
        goto LABEL_35;
      }
    }
    else if (a2[23])
    {
      while (*a2 == *v17)
      {
        ++a2;
        ++v17;
        if (!--v14) {
          goto LABEL_20;
        }
      }
      goto LABEL_35;
    }
LABEL_20:
    uint64_t v19 = a5[23];
    if ((v19 & 0x80u) == 0) {
      uint64_t v20 = a5[23];
    }
    else {
      uint64_t v20 = *((void *)a5 + 1);
    }
    uint64_t v21 = v30;
    if ((v30 & 0x80u) != 0) {
      uint64_t v21 = v29[1];
    }
    if (v20 == v21)
    {
      if ((v30 & 0x80u) == 0) {
        __int16 v22 = (unsigned __int8 *)v29;
      }
      else {
        __int16 v22 = (unsigned __int8 *)v29[0];
      }
      if ((v19 & 0x80) == 0)
      {
        if (a5[23])
        {
          while (*a5 == *v22)
          {
            ++a5;
            ++v22;
            if (!--v19) {
              goto LABEL_37;
            }
          }
          goto LABEL_35;
        }
LABEL_37:
        if (sub_10020488C(*(void *)(a1 + 104), a3, a4))
        {
          if (!v31) {
            sub_10020D700();
          }
          sub_1002D4958(v24, &v32, v25[0], v28);
          __n128 v23 = v24[1];
          *a6 = v24[0];
          a6[1] = v23;
          a6[2].n128_u8[0] = 1;
          uint64_t v18 = -1;
        }
        else
        {
          a6->n128_u8[0] = 0;
          a6[2].n128_u8[0] = 0;
          uint64_t v18 = 26;
        }
        goto LABEL_36;
      }
      if (!memcmp(*(const void **)a5, v22, *((void *)a5 + 1))) {
        goto LABEL_37;
      }
    }
LABEL_35:
    a6->n128_u8[0] = 0;
    a6[2].n128_u8[0] = 0;
    uint64_t v18 = 25;
    goto LABEL_36;
  }
  a6->n128_u8[0] = 0;
  a6[2].n128_u8[0] = 0;
  uint64_t v18 = 24;
LABEL_36:
  a6[2].n128_u64[1] = v18;
  return sub_1002CD4A4((uint64_t)v25);
}

void sub_1002C8490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1002CD4A4((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1002C84B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1 + 40;
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5 == a1 + 40) {
    return 0;
  }
  unsigned __int8 v6 = 0;
  do
  {
    uint64_t v7 = sub_1002D4C60(v5 + 16);
    if (v7 == a2 && v8 == a3)
    {
      unsigned __int8 v6 = v5 + 16;
      unint64_t v3 = (unint64_t)(v5 + 16) >> 8;
    }
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != v4);
  return v6 | (v3 << 8);
}

uint64_t sub_1002C8584(uint64_t *a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7)
{
  *(void *)&long long v116 = a3;
  *((void *)&v116 + 1) = a4;
  *(void *)&long long v115 = a5;
  *((void *)&v115 + 1) = a6;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  unint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFStringRef v11 = a2;
    }
    else {
      CFStringRef v11 = (size_t *)*a2;
    }
    int v12 = operator new(0x28uLL);
    __n128 v107 = (void **)v12;
    long long v108 = xmmword_101D048C0;
    *int v12 = 0u;
    v12[1] = 0u;
    *(void *)((char *)v12 + 29) = 0;
    sub_1001E0650((uint64_t)&v116, v12);
    if (v108 >= 0) {
      char v13 = (void **)&v107;
    }
    else {
      char v13 = v107;
    }
    if (*((char *)a7 + 23) >= 0) {
      uint64_t v14 = (void **)a7;
    }
    else {
      uint64_t v14 = (void **)*a7;
    }
    uint64_t v15 = operator new(0x28uLL);
    long long __p = v15;
    *(_OWORD *)__n = xmmword_101D048C0;
    _OWORD *v15 = 0u;
    v15[1] = 0u;
    *(void *)((char *)v15 + 29) = 0;
    sub_1001E0650((uint64_t)&v115, v15);
    p_p = &__p;
    if ((__n[1] & 0x8000000000000000) != 0) {
      p_p = __p;
    }
    *(_DWORD *)uint64_t buf = 68290050;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = v11;
    __int16 v99 = 2082;
    std::string v100 = v13;
    __int16 v101 = 2082;
    std::string v102 = v14;
    __int16 v103 = 2082;
    long long v104 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager connection parameters: \", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"connectionToken\":%{public, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v108) < 0) {
      operator delete(v107);
    }
  }
  if (*((char *)a7 + 23) >= 0) {
    size_t v17 = *((unsigned __int8 *)a7 + 23);
  }
  else {
    size_t v17 = (size_t)a7[1];
  }
  uint64_t v18 = &__p;
  sub_1001110E4((uint64_t)&__p, v17 + 20);
  if ((__n[1] & 0x8000000000000000) != 0) {
    uint64_t v18 = __p;
  }
  if (v17)
  {
    if (*((char *)a7 + 23) >= 0) {
      uint64_t v19 = a7;
    }
    else {
      uint64_t v19 = *a7;
    }
    memmove(v18, v19, v17);
  }
  strcpy((char *)v18 + v17, ":com.apple.locationd");
  sub_1002C84B0((uint64_t)a1, v116, *((uint64_t *)&v116 + 1));
  if (v20)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    uint64_t v21 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) < 0) {
        a2 = (size_t *)*a2;
      }
      __int16 v22 = (char *)operator new(0x28uLL);
      *(void *)(v22 + 29) = 0;
      *(_OWORD *)__int16 v22 = 0u;
      *((_OWORD *)v22 + 1) = 0u;
      sub_1001E0650((uint64_t)&v116, v22);
      *(_DWORD *)uint64_t buf = 68289538;
      int v94 = 0;
      __int16 v95 = 2082;
      std::string v96 = "";
      __int16 v97 = 2082;
      std::string v98 = a2;
      __int16 v99 = 2082;
      std::string v100 = (void **)v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service already has active connection\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v22);
    }
    uint64_t v23 = 18;
    goto LABEL_132;
  }
  if (sub_1002083F4(a1[13]))
  {
    sub_10020454C(a1[13], v116, *((uint64_t *)&v116 + 1), &v107);
    if (!v114)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A49F0);
      }
      __n128 v32 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) < 0) {
          a2 = (size_t *)*a2;
        }
        uint64_t v33 = (char *)operator new(0x28uLL);
        *(void *)(v33 + 29) = 0;
        *(_OWORD *)uint64_t v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_1001E0650((uint64_t)&v116, v33);
        *(_DWORD *)uint64_t buf = 68289538;
        int v94 = 0;
        __int16 v95 = 2082;
        std::string v96 = "";
        __int16 v97 = 2082;
        std::string v98 = a2;
        __int16 v99 = 2082;
        std::string v100 = (void **)v33;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service not found in database\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
        operator delete(v33);
      }
      uint64_t v23 = 19;
      goto LABEL_131;
    }
    uint64_t v24 = *((unsigned __int8 *)a2 + 23);
    if ((v24 & 0x80u) == 0) {
      size_t v25 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v25 = a2[1];
    }
    int v26 = (char)v111;
    if ((v111 & 0x80u) == 0) {
      uint64_t v27 = v111;
    }
    else {
      uint64_t v27 = v110;
    }
    if (v25 == v27)
    {
      if ((v111 & 0x80u) == 0) {
        unsigned int v28 = &v109;
      }
      else {
        unsigned int v28 = (unsigned __int8 **)v109;
      }
      if ((v24 & 0x80) != 0)
      {
        if (!memcmp((const void *)*a2, v28, a2[1])) {
          goto LABEL_97;
        }
      }
      else
      {
        if (!*((unsigned char *)a2 + 23)) {
          goto LABEL_97;
        }
        BOOL v29 = a2;
        while (*(unsigned __int8 *)v29 == *(unsigned __int8 *)v28)
        {
          BOOL v29 = (size_t *)((char *)v29 + 1);
          unsigned int v28 = (unsigned __int8 **)((char *)v28 + 1);
          if (!--v24) {
            goto LABEL_97;
          }
        }
      }
    }
    uint64_t v34 = HIBYTE(__n[1]);
    if ((__n[1] & 0x8000000000000000) == 0) {
      size_t v35 = HIBYTE(__n[1]);
    }
    else {
      size_t v35 = __n[0];
    }
    if (v35 == v27)
    {
      if (v26 >= 0) {
        __int16 v36 = &v109;
      }
      else {
        __int16 v36 = (unsigned __int8 **)v109;
      }
      if ((__n[1] & 0x8000000000000000) == 0)
      {
        if (HIBYTE(__n[1]))
        {
          int v37 = &__p;
          while (*(unsigned __int8 *)v37 == *(unsigned __int8 *)v36)
          {
            int v37 = (void **)((char *)v37 + 1);
            __int16 v36 = (unsigned __int8 **)((char *)v36 + 1);
            if (!--v34) {
              goto LABEL_97;
            }
          }
          goto LABEL_84;
        }
LABEL_97:
        uint64_t v42 = *((unsigned __int8 *)a7 + 23);
        if ((v42 & 0x80u) == 0) {
          __int16 v43 = (const void *)*((unsigned __int8 *)a7 + 23);
        }
        else {
          __int16 v43 = a7[1];
        }
        __int16 v44 = (const void *)v113;
        if ((v113 & 0x80u) != 0) {
          __int16 v44 = (const void *)v112[1];
        }
        if (v43 == v44)
        {
          if ((v113 & 0x80u) == 0) {
            char v45 = (unsigned __int8 *)v112;
          }
          else {
            char v45 = (unsigned __int8 *)v112[0];
          }
          if ((v42 & 0x80) == 0)
          {
            if (*((unsigned char *)a7 + 23))
            {
              __n128 v46 = a7;
              while (*(unsigned __int8 *)v46 == *v45)
              {
                __n128 v46 = (const void **)((char *)v46 + 1);
                ++v45;
                if (!--v42) {
                  goto LABEL_135;
                }
              }
              goto LABEL_113;
            }
            goto LABEL_135;
          }
          if (!memcmp(*a7, v45, (size_t)a7[1]))
          {
LABEL_135:
            uint64_t v53 = (uint64_t *)a1[6];
            if (v53 == a1 + 5)
            {
              uint64_t v54 = 0;
LABEL_156:
              switch((unint64_t)v107)
              {
                case 1uLL:
                  unint64_t v61 = sub_1002C9518();
                  goto LABEL_161;
                case 2uLL:
                  unint64_t v61 = sub_1002C95C4();
                  goto LABEL_161;
                case 3uLL:
                  unint64_t v61 = sub_1002C9670();
                  goto LABEL_161;
                case 4uLL:
                  unint64_t v61 = sub_1002C971C();
LABEL_161:
                  uint64_t v62 = (void *)(v54 + 1);
                  if (v54 + 1 <= v61)
                  {
                    if (qword_102419450 != -1) {
                      dispatch_once(&qword_102419450, &stru_1022A49F0);
                    }
                    uint64_t v68 = qword_102419458;
                    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
                    {
                      int v69 = *((char *)a2 + 23);
                      uint64_t v70 = (size_t *)*a2;
                      sub_1002811D4((uint64_t)&v116, (uint64_t)v89);
                      long long v71 = v69 >= 0 ? a2 : v70;
                      uint64_t v72 = v90 >= 0 ? v89 : (void **)v89[0];
                      *(_DWORD *)uint64_t buf = 68290050;
                      int v94 = 0;
                      __int16 v95 = 2082;
                      std::string v96 = "";
                      __int16 v97 = 2082;
                      std::string v98 = v71;
                      __int16 v99 = 2082;
                      std::string v100 = v72;
                      __int16 v101 = 2050;
                      std::string v102 = (void **)v107;
                      __int16 v103 = 2050;
                      long long v104 = v62;
                      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager client connected to service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"NumberOfConnectionsToServiceType\":%{public}lu}", buf, 0x3Au);
                      if (v90 < 0) {
                        operator delete(v89[0]);
                      }
                    }
                    if (!v114) {
                      sub_10020D700();
                    }
                    sub_1002D4B28((uint64_t)buf, (uint64_t)a1, (uint64_t)&v107, (uint64_t)(a1 + 1));
                    int v73 = sub_1002C97CC(a1 + 5, (long long *)buf);
                    sub_1002C981C((uint64_t)buf);
                    sub_1002CECD8((uint64_t)(a1 + 8), &v116, &v116, &v115);
                    if (v74)
                    {
                      char v75 = [[CLOSTransaction alloc] initWithDescription:"com.apple.locationd.microlocation-service-connect"];
                      sub_1002C9884((uint64_t)a1, (uint64_t)v73);
                      sub_1002C98DC((uint64_t)a1, v73);
                      sub_1002C9B40((uint64_t)a1);

                      uint64_t v23 = -1;
                    }
                    else
                    {
                      if (qword_102419450 != -1) {
                        dispatch_once(&qword_102419450, &stru_1022A49F0);
                      }
                      uint64_t v76 = qword_102419458;
                      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
                      {
                        if (*((char *)a2 + 23) >= 0) {
                          unsigned __int8 v77 = a2;
                        }
                        else {
                          unsigned __int8 v77 = (size_t *)*a2;
                        }
                        sub_1002811D4((uint64_t)&v116, (uint64_t)v89);
                        int v78 = v90;
                        std::string v79 = (void **)v89[0];
                        sub_1002811D4((uint64_t)&v115, (uint64_t)v87);
                        std::string v80 = v89;
                        if (v78 < 0) {
                          std::string v80 = v79;
                        }
                        if (v88 >= 0) {
                          std::string v81 = v87;
                        }
                        else {
                          std::string v81 = (void **)v87[0];
                        }
                        *(_DWORD *)uint64_t buf = 68289794;
                        int v94 = 0;
                        __int16 v95 = 2082;
                        std::string v96 = "";
                        __int16 v97 = 2082;
                        std::string v98 = v77;
                        __int16 v99 = 2082;
                        std::string v100 = v80;
                        __int16 v101 = 2082;
                        std::string v102 = v81;
                        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
                        if (v88 < 0) {
                          operator delete(v87[0]);
                        }
                        if (v90 < 0) {
                          operator delete(v89[0]);
                        }
                        if (qword_102419450 != -1) {
                          dispatch_once(&qword_102419450, &stru_1022A49F0);
                        }
                      }
                      std::string v82 = qword_102419458;
                      if (os_signpost_enabled((os_log_t)qword_102419458))
                      {
                        if (*((char *)a2 + 23) < 0) {
                          a2 = (size_t *)*a2;
                        }
                        sub_1002811D4((uint64_t)&v116, (uint64_t)v89);
                        int v83 = v90;
                        std::string v84 = (void **)v89[0];
                        sub_1002811D4((uint64_t)&v115, (uint64_t)v87);
                        std::string v85 = v89;
                        if (v83 < 0) {
                          std::string v85 = v84;
                        }
                        if (v88 >= 0) {
                          std::string v86 = v87;
                        }
                        else {
                          std::string v86 = (void **)v87[0];
                        }
                        *(_DWORD *)uint64_t buf = 68289794;
                        int v94 = 0;
                        __int16 v95 = 2082;
                        std::string v96 = "";
                        __int16 v97 = 2082;
                        std::string v98 = a2;
                        __int16 v99 = 2082;
                        std::string v100 = v85;
                        __int16 v101 = 2082;
                        std::string v102 = v86;
                        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v82, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap", "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
                        if (v88 < 0) {
                          operator delete(v87[0]);
                        }
                        if (v90 < 0) {
                          operator delete(v89[0]);
                        }
                      }
                      uint64_t v23 = 0;
                    }
                  }
                  else
                  {
                    if (qword_102419450 != -1) {
                      dispatch_once(&qword_102419450, &stru_1022A49F0);
                    }
                    uint64_t v63 = qword_102419458;
                    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
                    {
                      int v64 = *((char *)a2 + 23);
                      uint64_t v65 = (size_t *)*a2;
                      sub_1002811D4((uint64_t)&v116, (uint64_t)v89);
                      uint64_t v66 = v64 >= 0 ? a2 : v65;
                      uint64_t v67 = v90 >= 0 ? v89 : (void **)v89[0];
                      *(_DWORD *)uint64_t buf = 68289794;
                      int v94 = 0;
                      __int16 v95 = 2082;
                      std::string v96 = "";
                      __int16 v97 = 2082;
                      std::string v98 = v66;
                      __int16 v99 = 2082;
                      std::string v100 = v67;
                      __int16 v101 = 2050;
                      std::string v102 = (void **)v107;
                      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client has maxed out number of connections\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu}", buf, 0x30u);
                      if (v90 < 0) {
                        operator delete(v89[0]);
                      }
                    }
                    uint64_t v23 = 32;
                  }
                  break;
                default:
                  uint64_t v23 = 3;
                  break;
              }
              goto LABEL_131;
            }
            uint64_t v54 = 0;
            while (1)
            {
              uint64_t v55 = (unsigned __int8 *)sub_1002D4C6C((uint64_t)(v53 + 2));
              uint64_t v56 = v55[23];
              if ((v56 & 0x80u) == 0) {
                uint64_t v57 = v55[23];
              }
              else {
                uint64_t v57 = *((void *)v55 + 1);
              }
              uint64_t v58 = v111;
              if ((v111 & 0x80u) != 0) {
                uint64_t v58 = v110;
              }
              if (v57 != v58) {
                goto LABEL_153;
              }
              int v59 = (v111 & 0x80u) == 0 ? &v109 : (unsigned __int8 **)v109;
              if ((v56 & 0x80) == 0) {
                break;
              }
              if (!memcmp(*(const void **)v55, v59, *((void *)v55 + 1))) {
                goto LABEL_152;
              }
LABEL_153:
              uint64_t v53 = (uint64_t *)v53[1];
              if (v53 == a1 + 5) {
                goto LABEL_156;
              }
            }
            if (v55[23])
            {
              while (*v55 == *(unsigned __int8 *)v59)
              {
                ++v55;
                int v59 = (unsigned __int8 **)((char *)v59 + 1);
                if (!--v56) {
                  goto LABEL_152;
                }
              }
              goto LABEL_153;
            }
LABEL_152:
            __int16 v60 = (void **)sub_1002D4CD0((uint64_t)(v53 + 2));
            v54 += v60 == v107;
            goto LABEL_153;
          }
        }
LABEL_113:
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
        __int16 v47 = qword_102419458;
        if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_130;
        }
        if (*((char *)a2 + 23) < 0) {
          a2 = (size_t *)*a2;
        }
        __int16 v48 = (char *)operator new(0x28uLL);
        *(void *)(v48 + 29) = 0;
        *(_OWORD *)__int16 v48 = 0u;
        *((_OWORD *)v48 + 1) = 0u;
        sub_1001E0650((uint64_t)&v116, v48);
        if (!v114) {
          sub_10020D700();
        }
        if ((v111 & 0x80u) == 0) {
          __int16 v49 = (void **)&v109;
        }
        else {
          __int16 v49 = (void **)v109;
        }
        if (*((char *)a7 + 23) >= 0) {
          __int16 v50 = a7;
        }
        else {
          __int16 v50 = (void *)*a7;
        }
        if ((v113 & 0x80u) == 0) {
          uint64_t v51 = v112;
        }
        else {
          uint64_t v51 = (void *)v112[0];
        }
        *(_DWORD *)uint64_t buf = 68290306;
        int v94 = 0;
        __int16 v95 = 2082;
        std::string v96 = "";
        __int16 v97 = 2082;
        std::string v98 = a2;
        __int16 v99 = 2082;
        std::string v100 = (void **)v48;
        __int16 v101 = 2082;
        std::string v102 = v49;
        __int16 v103 = 2082;
        long long v104 = v50;
        __int16 v105 = 2082;
        __n128 v106 = v51;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service because client's user mismatched with service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"ExpectedUserID\":%{public, location:escape_only}s}", buf, 0x44u);
        unint64_t v41 = v48;
LABEL_129:
        operator delete(v41);
LABEL_130:
        uint64_t v23 = 20;
LABEL_131:
        sub_1002CD4A4((uint64_t)&v107);
        goto LABEL_132;
      }
      if (!memcmp(__p, v36, __n[0])) {
        goto LABEL_97;
      }
    }
LABEL_84:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    __int16 v38 = qword_102419458;
    if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_130;
    }
    if (*((char *)a2 + 23) < 0) {
      a2 = (size_t *)*a2;
    }
    sub_1002811D4((uint64_t)&v116, (uint64_t)v89);
    if (!v114) {
      sub_10020D700();
    }
    char v39 = v89;
    if (v90 < 0) {
      char v39 = (void **)v89[0];
    }
    __int16 v40 = (v111 & 0x80u) == 0 ? (void **)&v109 : (void **)v109;
    *(_DWORD *)uint64_t buf = 68289794;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = a2;
    __int16 v99 = 2082;
    std::string v100 = v39;
    __int16 v101 = 2082;
    std::string v102 = v40;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client unauthorised to connect\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s}", buf, 0x30u);
    if ((v90 & 0x80000000) == 0) {
      goto LABEL_130;
    }
    unint64_t v41 = v89[0];
    goto LABEL_129;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  unsigned __int8 v30 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (size_t *)*a2;
    }
    char v31 = (char *)operator new(0x28uLL);
    *(void *)(v31 + 29) = 0;
    *(_OWORD *)char v31 = 0u;
    *((_OWORD *)v31 + 1) = 0u;
    sub_1001E0650((uint64_t)&v116, v31);
    *(_DWORD *)uint64_t buf = 68289538;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = a2;
    __int16 v99 = 2082;
    std::string v100 = (void **)v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
    operator delete(v31);
  }
  uint64_t v23 = 33;
LABEL_132:
  if (SHIBYTE(__n[1]) < 0) {
    operator delete(__p);
  }
  return v23;
}

void sub_1002C9408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1002CD4A4(v27 - 224);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002C9518()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedUnsupervisedServicesPerClient", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 1;
  }
}

void sub_1002C95A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C95C4()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedBinaryRoiServicesPerClient", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 1;
  }
}

void sub_1002C9654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C9670()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedMulticlassServicesPerClient", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 1;
  }
}

void sub_1002C9700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C971C()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedSimilarityListServicesPerClient", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 10;
  }
}

void sub_1002C97B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002C97CC(uint64_t *a1, long long *a2)
{
  unint64_t v3 = sub_1002CEA08((uint64_t)a1, 0, 0, a2);
  uint64_t v4 = *a1;
  void *v3 = *a1;
  v3[1] = a1;
  *(void *)(v4 + 8) = v3;
  *a1 = (uint64_t)v3;
  ++a1[2];
  return v3 + 2;
}

uint64_t sub_1002C981C(uint64_t a1)
{
  sub_1002CD4F0((void *)(a1 + 376));
  sub_1002CD4F0((void *)(a1 + 304));
  sub_1002CD598(a1 + 112);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  return a1;
}

uint64_t sub_1002C9884(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = sub_1002D4C60(a2);
  uint64_t v5 = v4;
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();

  return sub_100205124(v2, v3, v5, Current_5);
}

void sub_1002C98DC(uint64_t a1, void *a2)
{
  uint64_t v4 = (unint64_t *)(a1 + 112);
  if (!*(unsigned char *)(a1 + 136) || !sub_1002D4CD8((uint64_t)a2, *v4)) {
    goto LABEL_13;
  }
  if (!*(unsigned char *)(a1 + 136)) {
    sub_10020D700();
  }
  if (*v4 != 2)
  {
    long long v18 = 0uLL;
    goto LABEL_16;
  }
  sub_1000C7F88(&v18);
  LOBYTE(v17) = 0;
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableServiceInCustomLOI", 0x8000100u, kCFAllocatorNull);
  char v6 = sub_1000D29FC(v18, (uint64_t)v5, (BOOL *)&v17);
  CFRelease(v5);
  int v7 = v17;
  if (*((void *)&v18 + 1)) {
    sub_1000DB0A0(*((std::__shared_weak_count **)&v18 + 1));
  }
  char v8 = v7 ? v6 : 0;
  if ((v8 & 1) == 0)
  {
LABEL_13:
    sub_1002CA27C(a1, (uint64_t)a2);
LABEL_14:
    sub_1002DB254(a2, v4);
    return;
  }
  int v9 = *(unsigned __int8 *)(a1 + 136);
  long long v18 = 0uLL;
  if (!v9) {
    sub_10020D700();
  }
LABEL_16:
  sub_1002CC078(a1, (uint64_t)a2, &v17);
  unint64_t v10 = (std::__shared_weak_count *)*((void *)&v18 + 1);
  long long v18 = v17;
  if (!v10)
  {
    uint64_t v11 = v17;
    if (!(void)v17) {
      goto LABEL_20;
    }
LABEL_25:
    uint64_t v15 = v11;
    uint64_t v16 = (std::__shared_weak_count *)*((void *)&v18 + 1);
    if (*((void *)&v18 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v18 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_1002D6B80((uint64_t)a2, &v15);
    if (v16) {
      sub_1000DB0A0(v16);
    }
    uint64_t v14 = (std::__shared_weak_count *)*((void *)&v18 + 1);
    long long v18 = 0uLL;
    if (v14)
    {
      sub_1000DB0A0(v14);
      if (*((void *)&v18 + 1)) {
        sub_1000DB0A0(*((std::__shared_weak_count **)&v18 + 1));
      }
    }
    goto LABEL_14;
  }
  sub_1000DB0A0(v10);
  uint64_t v11 = v18;
  if ((void)v18) {
    goto LABEL_25;
  }
LABEL_20:
  if (!*(unsigned char *)(a1 + 136)) {
    sub_10020D700();
  }
  sub_1002CAE00((uint64_t)a2, *(void *)(a1 + 104), a1 + 152, (uint64_t *)v4, &v17);
  long long v12 = v17;
  long long v17 = 0uLL;
  char v13 = (std::__shared_weak_count *)*((void *)&v18 + 1);
  long long v18 = v12;
  if (v13)
  {
    sub_1000DB0A0(v13);
    if (*((void *)&v17 + 1)) {
      sub_1000DB0A0(*((std::__shared_weak_count **)&v17 + 1));
    }
  }
  sub_1002CC214((uint64_t *)(a1 + 16), &v18);
  uint64_t v11 = v18;
  if ((void)v18) {
    goto LABEL_25;
  }
  sub_101A587BC();
  abort_report_np();
  __break(1u);
}

void sub_1002C9B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_1000DB0A0(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C9B40(uint64_t a1)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    int v4 = 0;
    do
    {
      v4 |= sub_1002D8F54(v3 + 16);
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
  CFStringRef v5 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 64);

  return v5();
}

uint64_t sub_1002C9BD4(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  v78[0] = a3;
  v78[1] = a4;
  unint64_t v8 = sub_1002C84B0((uint64_t)a1, a3, a4);
  if (v9)
  {
    uint64_t v10 = v8;
    uint64_t v11 = (unsigned __int8 *)sub_1002D4C6C(v8);
    uint64_t v12 = v11[23];
    if ((v12 & 0x80u) == 0) {
      uint64_t v13 = v11[23];
    }
    else {
      uint64_t v13 = *((void *)v11 + 1);
    }
    uint64_t v14 = a2[23];
    int v15 = (char)v14;
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *((void *)a2 + 1);
    }
    if (v13 == v14)
    {
      if (v15 >= 0) {
        uint64_t v16 = a2;
      }
      else {
        uint64_t v16 = *(unsigned __int8 **)a2;
      }
      if ((v12 & 0x80) == 0)
      {
        if (v11[23])
        {
          while (*v11 == *v16)
          {
            ++v11;
            ++v16;
            if (!--v12) {
              goto LABEL_32;
            }
          }
          goto LABEL_22;
        }
LABEL_32:
        unsigned int v28 = (unsigned __int8 *)sub_1002D4C74(v10);
        uint64_t v29 = v28[23];
        if ((v29 & 0x80u) == 0) {
          uint64_t v30 = v28[23];
        }
        else {
          uint64_t v30 = *((void *)v28 + 1);
        }
        uint64_t v31 = a5[23];
        int v32 = (char)v31;
        if ((v31 & 0x80u) != 0) {
          uint64_t v31 = *((void *)a5 + 1);
        }
        if (v30 == v31)
        {
          if (v32 >= 0) {
            uint64_t v33 = a5;
          }
          else {
            uint64_t v33 = *(unsigned __int8 **)a5;
          }
          if ((v29 & 0x80) == 0)
          {
            if (v28[23])
            {
              while (*v28 == *v33)
              {
                ++v28;
                ++v33;
                if (!--v29) {
                  goto LABEL_65;
                }
              }
              goto LABEL_47;
            }
            goto LABEL_65;
          }
          if (!memcmp(*(const void **)v28, v33, *((void *)v28 + 1)))
          {
LABEL_65:
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A49F0);
            }
            __n128 v46 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t buf = 68289026;
              int v64 = 0;
              __int16 v65 = 2082;
              uint64_t v66 = "";
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, releasing model and updating service time\"}", buf, 0x12u);
            }
            sub_1002CA27C((uint64_t)a1, v10);
            uint64_t v47 = a1[13];
            uint64_t v48 = sub_1002D4C60(v10);
            uint64_t v50 = v49;
            double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
            unsigned int v52 = sub_1002D4CD0(v10);
            uint64_t v53 = (long long *)sub_1002D4C6C(v10);
            uint64_t v54 = sub_1000E9360(v10);
            uint64_t v55 = (long long *)sub_1002D4C74(v10);
            sub_1002DDA60((uint64_t)buf, v48, v50, v52, v53, v54, v55, Current_5);
            uint64_t v58 = 0;
            uint64_t v59 = 0;
            __int16 v60 = 0;
            unint64_t v61 = &v58;
            char v62 = 0;
            uint64_t v58 = (char *)operator new(0x58uLL);
            uint64_t v59 = (uint64_t)v58;
            __int16 v60 = v58 + 88;
            uint64_t v59 = sub_1002CE2A8((uint64_t)&v60, (uint64_t)buf, (uint64_t)&v77, (uint64_t)v58);
            sub_1002C7FA8(v47);
            unint64_t v61 = &v58;
            sub_10028B5B0((void ***)&v61);
            if (v76 < 0) {
              operator delete(*(void **)((char *)__p + 4));
            }
            if (SBYTE5(v73) < 0) {
              operator delete(*(void **)&v70[2]);
            }
            uint64_t v56 = sub_1002D4C60(v10);
            sub_1002CA4A4(a1, v56, v57);
            return -1;
          }
        }
LABEL_47:
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
        uint64_t v34 = qword_102419458;
        if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
          return 28;
        }
        size_t v35 = (char *)operator new(0x28uLL);
        *(_OWORD *)size_t v35 = 0u;
        *((_OWORD *)v35 + 1) = 0u;
        *(void *)(v35 + 29) = 0;
        sub_1001E0650((uint64_t)v78, v35);
        if ((a2[23] & 0x80u) == 0) {
          __int16 v36 = a2;
        }
        else {
          __int16 v36 = *(unsigned __int8 **)a2;
        }
        uint64_t v37 = sub_1002D4C6C(v10);
        int v38 = *(char *)(v37 + 23);
        uint64_t v39 = *(void *)v37;
        int v40 = (char)a5[23];
        unint64_t v41 = *(unsigned __int8 **)a5;
        uint64_t v42 = sub_1002D4C74(v10);
        if (v40 >= 0) {
          __int16 v43 = a5;
        }
        else {
          __int16 v43 = v41;
        }
        if (v38 >= 0) {
          uint64_t v44 = v37;
        }
        else {
          uint64_t v44 = v39;
        }
        if (*(char *)(v42 + 23) >= 0) {
          uint64_t v45 = v42;
        }
        else {
          uint64_t v45 = *(void *)v42;
        }
        *(_DWORD *)uint64_t buf = 68290307;
        int v64 = 0;
        __int16 v65 = 2082;
        uint64_t v66 = "";
        __int16 v67 = 2081;
        uint64_t v68 = v35;
        __int16 v69 = 2081;
        *(void *)uint64_t v70 = v36;
        *(_WORD *)&v70[8] = 2081;
        uint64_t v71 = v44;
        __int16 v72 = 2081;
        int v73 = v43;
        __int16 v74 = 2081;
        __p[0] = v45;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service created by another user\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"loadedServiceUserId\":%{private, location:escape_only}s}", buf, 0x44u);
        uint64_t v27 = v35;
LABEL_63:
        operator delete(v27);
        return 28;
      }
      if (!memcmp(*(const void **)v11, v16, *((void *)v11 + 1))) {
        goto LABEL_32;
      }
    }
LABEL_22:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    char v20 = qword_102419458;
    if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
      return 28;
    }
    uint64_t v21 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v21 = 0u;
    *((_OWORD *)v21 + 1) = 0u;
    *(void *)(v21 + 29) = 0;
    sub_1001E0650((uint64_t)v78, v21);
    int v22 = (char)a2[23];
    uint64_t v23 = *(unsigned __int8 **)a2;
    uint64_t v24 = sub_1002D4C6C(v10);
    if (v22 >= 0) {
      size_t v25 = a2;
    }
    else {
      size_t v25 = v23;
    }
    if (*(char *)(v24 + 23) >= 0) {
      uint64_t v26 = v24;
    }
    else {
      uint64_t v26 = *(void *)v24;
    }
    *(_DWORD *)uint64_t buf = 68289795;
    int v64 = 0;
    __int16 v65 = 2082;
    uint64_t v66 = "";
    __int16 v67 = 2081;
    uint64_t v68 = v21;
    __int16 v69 = 2081;
    *(void *)uint64_t v70 = v25;
    *(_WORD *)&v70[8] = 2081;
    uint64_t v71 = v26;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s}", buf, 0x30u);
    uint64_t v27 = v21;
    goto LABEL_63;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  long long v17 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    long long v18 = (char *)operator new(0x28uLL);
    *(_OWORD *)long long v18 = 0u;
    *((_OWORD *)v18 + 1) = 0u;
    *(void *)(v18 + 29) = 0;
    sub_1001E0650((uint64_t)v78, v18);
    *(_DWORD *)uint64_t buf = 68289283;
    int v64 = 0;
    __int16 v65 = 2082;
    uint64_t v66 = "";
    __int16 v67 = 2081;
    uint64_t v68 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not connected to this service\", \"ServiceUUID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    operator delete(v18);
  }
  return 27;
}

void sub_1002CA208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  char v6 = va_arg(va1, void **);
  uint64_t v8 = va_arg(va1, void);
  sub_10028B5B0((void ***)va);
  sub_1002C8208((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1002CA27C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v4 = a1 + 16;
  sub_1002D7554(a2);
  uint64_t v8 = *(long long **)v4;
  int v7 = *(long long **)(v4 + 8);
  if (*(long long **)v4 == v7)
  {
    int v7 = *(long long **)v4;
  }
  else
  {
    char v9 = v8 + 1;
    while (1)
    {
      uint64_t v10 = *((void *)v9 - 1);
      if (v10)
      {
        if (!*(void *)(v10 + 8)) {
          break;
        }
      }
      if (v9++ == v7)
      {
        uint64_t v8 = *(long long **)(v4 + 8);
        goto LABEL_18;
      }
    }
    uint64_t v8 = v9 - 1;
    if (v9 - 1 != v7 && v9 != v7)
    {
      do
      {
        uint64_t v12 = *((void *)v9 + 1);
        if (!v12 || *(void *)(v12 + 8))
        {
          uint64_t v13 = *(void *)v9;
          *(void *)char v9 = 0;
          *((void *)v9 + 1) = 0;
          uint64_t v14 = (std::__shared_weak_count *)*((void *)v8 + 1);
          *(void *)uint64_t v8 = v13;
          *((void *)v8 + 1) = v12;
          if (v14) {
            sub_1000DB0A0(v14);
          }
          ++v8;
        }
        ++v9;
      }
      while (v9 != v7);
      int v7 = *(long long **)(a1 + 24);
    }
  }
LABEL_18:
  sub_1002CAD7C(v4, (uint64_t)v8, v7);
  uint64_t v16 = *(void *)(a1 + 16);
  uint64_t v15 = *(void *)(a1 + 24);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  long long v17 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v20[0] = sub_1002D4C60(a2);
    v20[1] = v18;
    uint64_t v19 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v19 = 0u;
    *((_OWORD *)v19 + 1) = 0u;
    *(void *)(v19 + 29) = 0;
    sub_1001E0650((uint64_t)v20, v19);
    *(_DWORD *)uint64_t buf = 68289795;
    int v22 = 0;
    __int16 v23 = 2082;
    uint64_t v24 = "";
    __int16 v25 = 2081;
    uint64_t v26 = v19;
    __int16 v27 = 2050;
    uint64_t v28 = (v6 - v5) >> 4;
    __int16 v29 = 2050;
    uint64_t v30 = (v15 - v16) >> 4;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::releaseModel, released model\", \"ServiceUUID\":%{private, location:escape_only}s, \"NumModelsBefore\":%{public}lu, \"NumModelsAfter\":%{public}lu}", buf, 0x30u);
    operator delete(v19);
  }
}

void sub_1002CA490(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1002CA4A4(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = a2;
  v10[1] = a3;
  uint64_t v4 = a1 + 5;
  uint64_t v5 = (uint64_t *)a1[6];
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  while (v5 != v4)
  {
    if (sub_1002D4C60((uint64_t)(v5 + 2)) == v11 && v6 == v12)
    {
      uint64_t v4 = v5;
      break;
    }
    uint64_t v5 = (uint64_t *)v5[1];
  }
  uint64_t v8 = *v4;
  *(void *)(v8 + 8) = v4[1];
  *(void *)v4[1] = v8;
  --a1[7];
  sub_1002CE068((uint64_t)(v4 + 2));
  operator delete(v4);
  return sub_100233B68(a1 + 8, v10);
}

void sub_1002CA578(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1002CA5F4(a2);
  if (v8)
  {
    int v9 = *(unsigned __int8 *)(a1 + 136);
    *(void *)(a1 + 112) = v7;
    *(void *)(a1 + 120) = a3;
    *(void *)(a1 + 128) = a4;
    if (!v9) {
      *(unsigned char *)(a1 + 136) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 136))
  {
    *(unsigned char *)(a1 + 136) = 0;
  }

  sub_1002CA728((void *)a1);
}

uint64_t sub_1002CA5F4(uint64_t *a1)
{
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    int v1 = *((unsigned __int8 *)a1 + 23);
    if (v1 != 4)
    {
      if (v1 != 6) {
        return 30;
      }
      if (*(_DWORD *)a1 != 1953723747 || *((_WORD *)a1 + 2) != 28015)
      {
LABEL_25:
        if (v1 == 4) {
          goto LABEL_26;
        }
        return 30;
      }
      return 2;
    }
    if (*(_DWORD *)a1 != 1701670760)
    {
      if (*(_DWORD *)a1 != 1802661751) {
        goto LABEL_25;
      }
      return 1;
    }
    return 0;
  }
  uint64_t v3 = a1[1];
  if (v3 == 4)
  {
    if (*(_DWORD *)*a1 == 1701670760) {
      return 0;
    }
    if (*(_DWORD *)*a1 == 1802661751) {
      return 1;
    }
    uint64_t v3 = a1[1];
  }
  if (v3 == 6)
  {
    if (*(_DWORD *)*a1 == 1953723747 && *(_WORD *)(*a1 + 4) == 28015) {
      return 2;
    }
    uint64_t v3 = a1[1];
  }
  if (v3 != 4) {
    return 30;
  }
  a1 = (uint64_t *)*a1;
LABEL_26:
  if (*(_DWORD *)a1 != 1701736302) {
    return 30;
  }
  return 0;
}

void sub_1002CA728(void *a1)
{
  uint64_t v3 = [[CLOSTransaction alloc] initWithDescription:"com.apple.locationd.microlocation-update-all-models"];
  sub_1002CA7BC(a1);
  for (uint64_t i = (void *)a1[6]; i != a1 + 5; uint64_t i = (void *)i[1])
    sub_1002C98DC((uint64_t)a1, i + 2);
  sub_1002C9B40((uint64_t)a1);
}

void sub_1002CA7BC(void *a1)
{
  uint64_t v2 = a1 + 5;
  for (uint64_t i = (void *)a1[6]; i != v2; uint64_t i = (void *)i[1])
    sub_1002CA27C((uint64_t)a1, (uint64_t)(i + 2));
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = a1 + 2;
  while (v4 != v5)
  {
    uint64_t v7 = *(void *)(v4 + 8);
    if (!v7 || *(void *)(v7 + 8)) {
      sub_101A5893C();
    }
    v4 += 16;
  }

  sub_1000C59A8(v6);
}

uint64_t sub_1002CA844(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, int a6)
{
  int v9 = (uint64_t *)sub_1002C84B0(a1, a2, a3);
  if (!v10) {
    return 0;
  }

  return sub_1002D98C0(v9, a4, a5, a6);
}

BOOL sub_1002CA8B0(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v4 = (void *)sub_1002C84B0(a1, *a2, a2[1]);
  uint64_t v6 = v5;
  if (v5) {
    sub_1002DC3D8(v4, a3);
  }
  return v6 != 0;
}

BOOL sub_1002CA8F4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (unsigned char *)sub_1002C84B0(a1, *a2, a2[1]);
  uint64_t v4 = v3;
  if (v3) {
    sub_1002DC3F0(v2);
  }
  return v4 != 0;
}

void sub_1002CA930(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (int64x2_t *)(a1 + 40);
  uint64_t v7 = *(int64x2_t **)(a1 + 48);
  if (v7 != (int64x2_t *)(a1 + 40))
  {
    do
    {
      v5 &= 0xFFFFFFFFFFFFFF00;
      v4 &= 0xFFFFFFFFFFFFFF00;
      uint64_t v11 = sub_1002D6B70((uint64_t)v7[1].i64);
      if (v12)
      {
        for (uint64_t i = *a2; i != a2[1]; i += 216)
        {
          if (*(_OWORD *)(i + 168) == *(_OWORD *)(v11 + 352))
          {
            uint64_t v5 = i;
            unint64_t v4 = v4 & 0xFFFFFFFFFFFFFF00 | 1;
          }
        }
      }
      sub_1002D5280(v7 + 1, v5, v4, a3, a4);
      uint64_t v7 = (int64x2_t *)v7->i64[1];
    }
    while (v7 != v6);
  }
}

void sub_1002CAA38(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  for (uint64_t i = *(void *)(a1 + 48); i != v1; uint64_t i = *(void *)(i + 8))
    sub_1002D65BC(i + 16);
}

void sub_1002CAA74(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_1002D65C4((uint64_t *)(v3 + 16), a2);
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t sub_1002CAAC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v12 = a4;
  *((void *)&v12 + 1) = a5;
  int v9 = (uint64_t *)sub_1002C84B0(a1, a2, a3);
  if (v10) {
    return sub_1002D9D58(v9, &v12, a6, a7);
  }
  else {
    return 0;
  }
}

BOOL sub_1002CAB44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v12[0] = a4;
  v12[1] = a5;
  v11[0] = a6;
  v11[1] = a7;
  uint64_t v7 = (void *)sub_1002C84B0(a1, a2, a3);
  uint64_t v9 = v8;
  if (v8) {
    sub_1002DB328(v7, v12, v11);
  }
  return v9 != 0;
}

BOOL sub_1002CABBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = (void *)sub_1002C84B0(a1, a2, a3);
  uint64_t v13 = v12;
  if (v12) {
    sub_1002DC0C8(v11, a4, a5, a6, a7);
  }
  return v13 != 0;
}

uint64_t sub_1002CAC20(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 32))();
}

uint64_t sub_1002CAC48(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 48))();
}

uint64_t sub_1002CAC70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 56))();
}

uint64_t sub_1002CAC98(uint64_t a1)
{
  return a1 + 16;
}

uint64_t sub_1002CACA0@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = result + 40;
  for (uint64_t i = *(void *)(result + 48); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v5)
    {
      *a4 = 0;
      a4[1] = 0;
      return result;
    }
    unint64_t result = sub_1002D4C60(i + 16);
    if (result == a2 && v7 == a3) {
      break;
    }
  }

  return sub_1002D6B54(i + 16, a4);
}

uint64_t sub_1002CAD7C(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    sub_1002CEF3C((uint64_t)&v10, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        unsigned __int8 v8 = *(std::__shared_weak_count **)(v7 - 8);
        if (v8) {
          sub_1000DB0A0(v8);
        }
        v7 -= 16;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_1002CAE00@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, void *a5@<X8>)
{
  LOBYTE(v104) = 0;
  char v111 = 0;
  if (sub_1002D4CD0(a1) == 1)
  {
    sub_1001FE6C0(a2, 0, a4[1], a4[2], __p);
    sub_100289C68((uint64_t)&v104, (uint64_t)__p);
    sub_1001EF39C((uint64_t)__p);
    if (!v111) {
      goto LABEL_15;
    }
    if (!v109)
    {
      sub_1002D4CC0(a1, __p);
      if (!v111) {
        sub_10020D700();
      }
      sub_1002CD60C(&v108, (const std::string *)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      if (!v111) {
        sub_10020D700();
      }
      sub_1002896EC(__p, &v104);
      memset(&v91, 0, sizeof(v91));
      LOBYTE(v65) = 0;
      v91.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x118uLL);
      v91.__r_.__value_.__l.__size_ = v91.__r_.__value_.__r.__words[0];
      v91.__r_.__value_.__r.__words[2] = v91.__r_.__value_.__r.__words[0] + 280;
      v91.__r_.__value_.__l.__size_ = (std::string::size_type)sub_10028976C((uint64_t)&v91.__r_.__value_.__r.__words[2], (long long *)__p, &v86, v91.__r_.__value_.__l.__data_);
      sub_1002891E4(a2);
      int v64 = &v91;
      sub_1002898E8((void ***)&v64);
      if (v85[0] && v84 < 0) {
        operator delete(v83);
      }
      sub_10024B47C((char *)&v74 + 2);
    }
  }
  else
  {
    sub_1002DA0B4(a1, &v91);
    sub_1001FF0AC(a2, (uint64_t)&v91, a4[1], a4[2], __p);
    sub_100289C68((uint64_t)&v104, (uint64_t)__p);
    sub_1001EF39C((uint64_t)__p);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
  }
  if (v111)
  {
LABEL_97:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    uint64_t v33 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (!v111 || !v109) {
        sub_10020D700();
      }
      if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v34 = &v108;
      }
      else {
        uint64_t v34 = (std::string *)v108.__r_.__value_.__r.__words[0];
      }
      size_t v35 = operator new(0x28uLL);
      int v64 = v35;
      long long v65 = xmmword_101D048C0;
      *size_t v35 = 0u;
      v35[1] = 0u;
      *(void *)((char *)v35 + 29) = 0;
      sub_1001E0650((uint64_t)&v104, v35);
      if (v65 >= 0) {
        __int16 v36 = (std::string *)&v64;
      }
      else {
        __int16 v36 = (std::string *)v64;
      }
      if (!v111) {
        sub_10020D700();
      }
      uint64_t v37 = (char *)v106;
      memset(v58, 0, 24);
      if ((sub_1001E86C0((uint64_t)v110, v58) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)&v91);
        v91.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
        sub_1001E91E8((uint64_t)&v91);
      }
      int v38 = v58;
      if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v38 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
      }
      *(void *)long long __p = 68290051;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&unsigned char __p[10] = "";
      *(_WORD *)&unsigned char __p[18] = 2082;
      *(void *)&__p[20] = v34;
      __int16 v73 = 2082;
      __int16 v74 = v36;
      __int16 v75 = 2050;
      char v76 = v37;
      __int16 v77 = 2081;
      int v78 = v38;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded model from DB:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", __p, 0x3Au);
      if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v58[0].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v65) < 0) {
        operator delete(v64);
      }
    }
    if (!v111) {
      sub_10020D700();
    }
    sub_100276BB4((uint64_t)&v107, a3, (uint64_t)__p);
    if (!v111) {
      sub_10020D700();
    }
    sub_1002D4CC0(a1, &v91);
    if (!v111) {
      sub_10020D700();
    }
    ((void (*)(void **__return_ptr, uint64_t))loc_1002D4968)(&v64, a1);
    if (!v111) {
      sub_10020D700();
    }
    sub_1002CEFA8((unsigned int *)__p, (uint64_t *)&v104, (long long *)&v91, v110, (long long *)&v64, &v105, a5);
    if (SHIBYTE(v65) < 0) {
      operator delete(v64);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    if (v90 < 0) {
      operator delete(v89);
    }
    if (v87)
    {
      char v88 = v87;
      operator delete(v87);
    }
    uint64_t v39 = (std::string *)__p;
    sub_1001EF1F0((uint64_t)v85);
    v91.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
    int v40 = (void ***)&v91;
    goto LABEL_129;
  }
LABEL_15:
  if (sub_1002D4CD0(a1) != 2) {
    goto LABEL_25;
  }
  uint64_t v9 = sub_1002D4C6C(a1);
  int v10 = *(char *)(v9 + 23);
  if (v10 < 0)
  {
    if (*(void *)(v9 + 8) != 10) {
      goto LABEL_25;
    }
    uint64_t v9 = *(void *)v9;
  }
  else if (v10 != 10)
  {
    goto LABEL_25;
  }
  if (*(void *)v9 != 0x6F6D2D7375636F66 || *(_WORD *)(v9 + 8) != 25956)
  {
LABEL_25:
    if (sub_1002D4CD0(a1) != 4) {
      goto LABEL_96;
    }
    uint64_t v13 = a4[1];
    uint64_t v12 = a4[2];
    *(void *)&long long v70 = v13;
    *((void *)&v70 + 1) = v12;
    sub_1001FE6C0(a2, 2u, v13, v12, &v91);
    sub_100134750(&v64, "");
    if ((_BYTE)v13)
    {
LABEL_27:
      uint64_t v14 = (char *)operator new(0x28uLL);
      *(void *)(v14 + 29) = 0;
      *(_OWORD *)uint64_t v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_1001E0650((uint64_t)&v70, v14);
      if (SHIBYTE(v65) < 0) {
        operator delete(v64);
      }
      int v64 = v14;
      long long v65 = xmmword_101D048C0;
    }
    else
    {
      uint64_t v15 = 1;
      while (v15 != 16)
      {
        if (*((unsigned __int8 *)&v70 + v15++))
        {
          if ((unint64_t)(v15 - 2) <= 0xE) {
            goto LABEL_27;
          }
          break;
        }
      }
    }
    if (v99)
    {
      sub_1002DA0B4(a1, (std::string *)__p);
      if (!v99) {
        sub_10020D700();
      }
      if (v98[0])
      {
        if (SHIBYTE(v97) < 0) {
          operator delete((void *)v96);
        }
        long long v96 = *(_OWORD *)__p;
        uint64_t v97 = *(void *)&__p[16];
      }
      else
      {
        long long v96 = *(_OWORD *)__p;
        uint64_t v97 = *(void *)&__p[16];
        v98[0] = 1;
      }
      if (v99)
      {
        if (v94)
        {
          sub_10024A54C(v94);
          v95 &= ~0x400u;
          if (!v99) {
            sub_10020D700();
          }
        }
        else
        {
          v95 &= ~0x400u;
        }
        *(_OWORD *)char v62 = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
        *(_DWORD *)long long __p = 0;
        sub_1001EE1F4((int *)__p);
        uint64_t v17 = sub_1001EC8C4((ssize_t)__p);
        if (!v99) {
          sub_10020D700();
        }
        v91.__r_.__value_.__r.__words[0] = v17;
        v91.__r_.__value_.__l.__size_ = v18;
        sub_1001EF3E8((unsigned int *)__p);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
        uint64_t v19 = qword_102419458;
        if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_93;
        }
        sub_1002DA0B4(a1, v58);
        if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v20 = v58;
        }
        else {
          char v20 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
        }
        if (!v99 || !v98[0]) {
          sub_10020D700();
        }
        if (v97 >= 0) {
          uint64_t v21 = (char *)&v96;
        }
        else {
          uint64_t v21 = (char *)v96;
        }
        int v22 = (char *)operator new(0x28uLL);
        *(void *)(v22 + 29) = 0;
        *(_OWORD *)int v22 = 0u;
        *((_OWORD *)v22 + 1) = 0u;
        sub_1001E0650((uint64_t)v62, v22);
        if (!v99) {
          sub_10020D700();
        }
        __int16 v23 = (char *)operator new(0x28uLL);
        *(void *)(v23 + 29) = 0;
        *(_OWORD *)__int16 v23 = 0u;
        *((_OWORD *)v23 + 1) = 0u;
        sub_1001E0650((uint64_t)&v91, v23);
        uint64_t v24 = &v64;
        if (v65 < 0) {
          uint64_t v24 = v64;
        }
        *(void *)long long __p = 68290562;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&unsigned char __p[10] = "";
        *(_WORD *)&unsigned char __p[18] = 2082;
        *(void *)&__p[20] = "LSL";
        __int16 v73 = 2082;
        __int16 v74 = v20;
        __int16 v75 = 2082;
        char v76 = v21;
        __int16 v77 = 2082;
        int v78 = (std::string *)v22;
        __int16 v79 = 2082;
        std::string v80 = v23;
        __int16 v81 = 2082;
        std::string v82 = v24;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"UsingModelOf\":%{public, location:escape_only}s, \"OriginalLSLModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", __p, 0x4Eu);
        operator delete(v23);
        __int16 v25 = v22;
        goto LABEL_91;
      }
    }
    else
    {
      sub_1001FE6C0(a2, 0, v70, *((uint64_t *)&v70 + 1), __p);
      sub_100289C68((uint64_t)&v91, (uint64_t)__p);
      sub_1001EF39C((uint64_t)__p);
      if (!v99)
      {
LABEL_93:
        if (SHIBYTE(v65) < 0) {
          operator delete(v64);
        }
        sub_100289C68((uint64_t)&v104, (uint64_t)&v91);
        sub_1001EF39C((uint64_t)&v91);
        goto LABEL_96;
      }
      sub_1002DA0B4(a1, (std::string *)__p);
      if (!v99) {
        sub_10020D700();
      }
      if (v98[0])
      {
        if (SHIBYTE(v97) < 0) {
          operator delete((void *)v96);
        }
        long long v96 = *(_OWORD *)__p;
        uint64_t v97 = *(void *)&__p[16];
      }
      else
      {
        long long v96 = *(_OWORD *)__p;
        uint64_t v97 = *(void *)&__p[16];
        v98[0] = 1;
      }
      if (v99)
      {
        int v92 = 2;
        if (!sub_100165F14(2u)) {
          __assert_rtn("set_modeltype", "microlocation.pb.h", 12283, "::CLMicroLocationProto::Model_ModelType_IsValid(value)");
        }
        v95 |= 0x10u;
        int v93 = 2;
        if (!v99) {
          sub_10020D700();
        }
        *(_OWORD *)char v62 = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
        *(_DWORD *)long long __p = 0;
        sub_1001EE1F4((int *)__p);
        uint64_t v26 = sub_1001EC8C4((ssize_t)__p);
        if (!v99) {
          sub_10020D700();
        }
        v91.__r_.__value_.__r.__words[0] = v26;
        v91.__r_.__value_.__l.__size_ = v27;
        sub_1001EF3E8((unsigned int *)__p);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
        uint64_t v28 = qword_102419458;
        if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_93;
        }
        __int16 v29 = v58;
        sub_1002DA0B4(a1, v58);
        if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          __int16 v29 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
        }
        uint64_t v30 = (char *)operator new(0x28uLL);
        *(void *)(v30 + 29) = 0;
        *(_OWORD *)uint64_t v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        sub_1001E0650((uint64_t)v62, v30);
        if (!v99) {
          sub_10020D700();
        }
        uint64_t v31 = (char *)operator new(0x28uLL);
        *(void *)(v31 + 29) = 0;
        *(_OWORD *)uint64_t v31 = 0u;
        *((_OWORD *)v31 + 1) = 0u;
        sub_1001E0650((uint64_t)&v91, v31);
        int v32 = (char *)&v64;
        if (v65 < 0) {
          int v32 = (char *)v64;
        }
        *(void *)long long __p = 68290306;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&unsigned char __p[10] = "";
        *(_WORD *)&unsigned char __p[18] = 2082;
        *(void *)&__p[20] = "unsupervised";
        __int16 v73 = 2082;
        __int16 v74 = v29;
        __int16 v75 = 2082;
        char v76 = v30;
        __int16 v77 = 2082;
        int v78 = (std::string *)v31;
        __int16 v79 = 2082;
        std::string v80 = v32;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"OriginalUnsupervisedModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", __p, 0x44u);
        operator delete(v31);
        __int16 v25 = v30;
LABEL_91:
        operator delete(v25);
        if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v58[0].__r_.__value_.__l.__data_);
        }
        goto LABEL_93;
      }
    }
    sub_10020D700();
  }
  sub_100134750(&v91, "focus-mode");
  sub_1001FF0AC(a2, (uint64_t)&v91, a4[1], a4[2], __p);
  sub_100289C68((uint64_t)&v104, (uint64_t)__p);
  sub_1001EF39C((uint64_t)__p);
  if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v91.__r_.__value_.__l.__data_);
  }
  if (!v111) {
    goto LABEL_130;
  }
  sub_1002DA0B4(a1, (std::string *)__p);
  if (!v111) {
    sub_10020D700();
  }
  if (v109)
  {
    if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v108.__r_.__value_.__l.__data_);
    }
    std::string v108 = *(std::string *)__p;
  }
  else
  {
    std::string v108 = *(std::string *)__p;
    char v109 = 1;
  }
  if (!v111) {
    sub_10020D700();
  }
  sub_1002896EC(__p, &v104);
  memset(&v91, 0, sizeof(v91));
  int v64 = &v91;
  LOBYTE(v65) = 0;
  v91.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x118uLL);
  v91.__r_.__value_.__l.__size_ = v91.__r_.__value_.__r.__words[0];
  v91.__r_.__value_.__r.__words[2] = v91.__r_.__value_.__r.__words[0] + 280;
  v91.__r_.__value_.__l.__size_ = (std::string::size_type)sub_10028976C((uint64_t)&v91.__r_.__value_.__r.__words[2], (long long *)__p, &v86, v91.__r_.__value_.__l.__data_);
  sub_1002891E4(a2);
  int v64 = &v91;
  sub_1002898E8((void ***)&v64);
  if (v85[0] && v84 < 0) {
    operator delete(v83);
  }
  sub_10024B47C((char *)&v74 + 2);
LABEL_96:
  if (v111) {
    goto LABEL_97;
  }
LABEL_130:
  sub_100275E9C(&v91);
  uint64_t v42 = sub_1002D4CD0(a1);
  HIDWORD(v91.__r_.__value_.__r.__words[0]) = sub_1002D8A94(v42, *a4);
  uint64_t v43 = sub_1002D4CD0(a1);
  LODWORD(v91.__r_.__value_.__l.__data_) = sub_1002D8AE0(v43, *a4);
  LODWORD(v70) = 0;
  sub_1001EE1F4((int *)&v70);
  uint64_t v44 = sub_1001EC8C4((ssize_t)&v70);
  uint64_t v46 = v45;
  sub_1002D4CC0(a1, &v64);
  uint64_t v47 = a4[1];
  uint64_t v48 = a4[2];
  ((void (*)(std::string *__return_ptr, uint64_t))loc_1002D4968)(v58, a1);
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  sub_1002CD678((uint64_t)__p, (unsigned int *)&v91, v44, v46, (long long *)&v64, v47, v48, (long long *)v58, Current_5);
  if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v65) < 0) {
    operator delete(v64);
  }
  sub_1001EF3E8((unsigned int *)&v70);
  int v59 = 0;
  sub_1001EE1F4(&v59);
  uint64_t v50 = sub_1001EC8C4((ssize_t)&v59);
  uint64_t v52 = v51;
  double v53 = j__CFAbsoluteTimeGetCurrent_5();
  sub_100275EA0((uint64_t)__p, (uint64_t)v58);
  sub_1002D4CC0(a1, v62);
  if (SHIBYTE(v63) < 0)
  {
    sub_1000DC48C(__dst, v62[0], (unint64_t)v62[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v62;
    uint64_t v56 = v63;
  }
  char v57 = 1;
  sub_100338C7C((uint64_t)&v64, v50, v52, (uint64_t)v58, (uint64_t)__dst, a4[1], a4[2], v53);
  long long v70 = 0uLL;
  uint64_t v71 = 0;
  __int16 v60 = (void **)&v70;
  char v61 = 0;
  *(void *)&long long v70 = operator new(0x118uLL);
  *((void *)&v70 + 1) = v70;
  uint64_t v71 = v70 + 280;
  *((void *)&v70 + 1) = sub_10028976C((uint64_t)&v71, (long long *)&v64, &v70, (_OWORD *)v70);
  sub_1002891E4(a2);
  __int16 v60 = (void **)&v70;
  sub_1002898E8(&v60);
  if (v69 && v68 < 0) {
    operator delete(v67);
  }
  sub_10024B47C(&v66);
  if (v57 && SHIBYTE(v56) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete(v62[0]);
  }
  sub_10024B47C(v58);
  sub_1001EF3E8((unsigned int *)&v59);
  sub_1002CF138((uint64_t)__p, a5);
  sub_1002CDE88((uint64_t)__p);
  if (v103 < 0) {
    operator delete(v102);
  }
  if (v100)
  {
    __int16 v101 = v100;
    operator delete(v100);
  }
  uint64_t v39 = &v91;
  sub_1001EF1F0((uint64_t)v98);
  *(void *)long long __p = &v96;
  int v40 = (void ***)__p;
LABEL_129:
  sub_1001EF278(v40);
  sub_1001EF318((uint64_t)&v39[3]);
  sub_1000D7D80((uint64_t)&v39->__r_.__value_.__r.__words[2]);
  return sub_1001EF39C((uint64_t)&v104);
}

void sub_1002CBD28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  operator delete(v56);
  operator delete(v55);
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  sub_1001EF39C((uint64_t)&STACK[0x488]);
  sub_1001EF39C((uint64_t)&STACK[0x5E8]);
  _Unwind_Resume(a1);
}

void *sub_1002CC078@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v13[0] = off_1022A4A70;
  void v13[3] = v13;
  v12[0] = off_1022A4B00;
  v12[1] = a2;
  v12[3] = v12;
  uint64_t v5 = *(void **)(a1 + 16);
  uint64_t v6 = *(void **)(a1 + 24);
  if (sub_1002D4CD0(a2) == 1) {
    uint64_t v7 = v13;
  }
  else {
    uint64_t v7 = v12;
  }
  sub_1002CFE98((uint64_t)v10, (uint64_t)v7);
  if (v5 != v6)
  {
    while (1)
    {
      if (!v11) {
        sub_10015E48C();
      }
      if ((*(uint64_t (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v5)) {
        break;
      }
      v5 += 2;
      if (v5 == v6)
      {
        uint64_t v5 = v6;
        break;
      }
    }
  }
  sub_1002CFCE0(v10);
  if (v5 == *(void **)(a1 + 24))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    *a3 = *v5;
    uint64_t v8 = v5[1];
    a3[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
  sub_1002CFCE0(v12);
  return sub_1002CFCE0(v13);
}

void sub_1002CC1E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_1002CFCE0((uint64_t *)va);
  sub_1002CFCE0((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **sub_1002CC214(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  unint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_1001D7FD4();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    uint64_t v14 = (char *)sub_1000C571C((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    double v18[2] = v15 + 16;
    sub_1002CFA80(a1, v18);
    uint64_t v9 = (void *)a1[1];
    unint64_t result = sub_1000C5898(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1002CC31C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C5898((void **)va);
  _Unwind_Resume(a1);
}

void sub_1002CC330(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_1002DA114((void *)(v3 + 16), a2);
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t sub_1002CC380(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4)
{
  uint64_t v4 = *(void *)(a1 + 144);
  uint64_t v5 = *a3;
  long long v7 = *a4;
  char v8 = *((unsigned char *)a4 + 16);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 24))(v4 + 8, a2, v5);
}

uint64_t sub_1002CC418(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&long long v9 = a2;
  long long v9 = *((_OWORD *)sub_1001F2690(a1 + 64, a2, (uint64_t)&unk_101D0B290, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, long long *))(**(void **)(a1 + 144) + 40))(*(void *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_1002CC4DC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&long long v9 = a2;
  long long v9 = *((_OWORD *)sub_1001F2690(a1 + 64, a2, (uint64_t)&unk_101D0B290, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, long long *))(**(void **)(a1 + 144) + 24))(*(void *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_1002CC5A0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&long long v9 = a2;
  long long v9 = *((_OWORD *)sub_1001F2690(a1 + 64, a2, (uint64_t)&unk_101D0B290, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, long long *))(**(void **)(a1 + 144) + 32))(*(void *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_1002CC664(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&long long v8 = a2;
  long long v8 = *((_OWORD *)sub_1001F2690(a1 + 64, a2, (uint64_t)&unk_101D0B290, (_OWORD **)&v8) + 2);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, long long *))(**(void **)(a1 + 144) + 48))(*(void *)(a1 + 144), a3, a4, &v8);
}

uint64_t sub_1002CC720(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4)
{
  uint64_t v4 = *(void *)(a1 + 144);
  uint64_t v5 = *a3;
  char v8 = *((unsigned char *)a4 + 16);
  long long v7 = *a4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 16))(v4 + 8, a2, v5);
}

uint64_t sub_1002CC7B4(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v5 = a2 + 32;
  long long v5 = *((_OWORD *)sub_1001F2690(a1 + 64, (void *)(a2 + 32), (uint64_t)&unk_101D0B290, (_OWORD **)&v5) + 2);
  return (*(uint64_t (**)(void, uint64_t, long long *))(**(void **)(a1 + 144) + 16))(*(void *)(a1 + 144), a2, &v5);
}

uint64_t sub_1002CC864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v22 = a3;
  uint64_t v23 = a4;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  long long v9 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *(void *)(v10 + 29) = 0;
    sub_1001E0650((uint64_t)&v22, v10);
    unint64_t v11 = (char *)operator new(0x28uLL);
    *(void *)(v11 + 29) = 0;
    *(_OWORD *)unint64_t v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_1001E0650((uint64_t)a5, v11);
    v15[0] = 68289538;
    v15[1] = 0;
    __int16 v16 = 2082;
    long long v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = v10;
    __int16 v20 = 2082;
    uint64_t v21 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::requestMicroLocationLearning\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}", (uint8_t *)v15, 0x26u);
    operator delete(v11);
    operator delete(v10);
    uint64_t v7 = v22;
    uint64_t v6 = v23;
  }
  uint64_t v12 = (void *)sub_1002C84B0(a1, v7, v6);
  if (v13) {
    return sub_1002DC5BC(v12, a5);
  }
  else {
    return 0;
  }
}

void sub_1002CC9F4(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002CCA24(void *a1)
{
  sub_1002CA728(a1);
  for (uint64_t i = (void *)a1[6]; i != a1 + 5; uint64_t i = (void *)i[1])
  {
    sub_1002C9884((uint64_t)a1, (uint64_t)(i + 2));
    sub_1002DC7FC((uint64_t)(i + 2));
  }
}

void sub_1002CCA80(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2 != a1 + 40)
  {
    uint64_t v3 = (_OWORD *)(a1 + 112);
    do
    {
      sub_1002DA27C(v2 + 16, v3, &v4);
      if (__p)
      {
        uint64_t v10 = __p;
        operator delete(__p);
      }
      if (v7)
      {
        char v8 = v7;
        operator delete(v7);
      }
      if (v5)
      {
        uint64_t v6 = v5;
        operator delete(v5);
      }
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != v1);
  }
}

void sub_1002CCB3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1 + 40;
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4 != a1 + 40)
  {
    do
    {
      sub_1002DC9A8((uint64_t *)(v4 + 16), a2, a3);
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != v3);
  }
}

uint64_t sub_1002CCB94(uint64_t a1, char a2, char a3)
{
  *(unsigned char *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 9) = a3;
  uint64_t v4 = a1 + 40;
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5 != a1 + 40)
  {
    do
    {
      sub_1002DC5B8(v5 + 16);
      sub_1002DB254((void *)(v5 + 16), (_OWORD *)(a1 + 112));
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v4);
  }

  return sub_1002C9B40(a1);
}

uint64_t sub_1002CCC18(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::triggerLearning\"}", (uint8_t *)v4, 0x12u);
  }
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 40))();
}

void sub_1002CCD1C(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1002CCD24(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 72))();
}

uint64_t sub_1002CCD4C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 144) + 8) + 80))();
}

void sub_1002CCD74(uint64_t a1@<X0>, uint64_t a2@<X1>, const void **a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
}

void sub_1002CCD84(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X8>)
{
}

uint64_t sub_1002CCD8C(void *a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  *(void *)&long long v20 = a2;
  *((void *)&v20 + 1) = a3;
  uint64_t v4 = a1 + 5;
  __int16 v5 = (void *)a1[6];
  *(void *)uint64_t v19 = a2;
  *(void *)&v19[8] = a3;
  if (v5 == a1 + 5) {
    goto LABEL_7;
  }
  while (*(void *)v19 != sub_1002D4C60((uint64_t)(v5 + 2)) || *(void *)&v19[8] != v8)
  {
    __int16 v5 = (void *)v5[1];
    if (v5 == v4) {
      goto LABEL_7;
    }
  }
  if (v5 == v4) {
LABEL_7:
  }
    sub_101A58ACC();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  uint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    unint64_t v11 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    *(void *)(v11 + 29) = 0;
    sub_1001E0650((uint64_t)&v20, v11);
    *(void *)uint64_t v19 = 68289282;
    *(_WORD *)&v19[8] = 2082;
    *(void *)&unsigned char v19[10] = "";
    *(_WORD *)&v19[18] = 2082;
    *(void *)&v19[20] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation for service\", \"serviceId\":%{public, location:escape_only}s}", v19, 0x1Cu);
    operator delete(v11);
  }
  *(_OWORD *)uint64_t v19 = *a4;
  *(_OWORD *)&v19[16] = v20;
  sub_1002CFF30(a1 + 24, (uint64_t)v19);
  unint64_t v12 = sub_1002C84B0((uint64_t)a1, v20, *((uint64_t *)&v20 + 1));
  if (v13)
  {
    uint64_t v14 = v12;
    if ((sub_1002D4CD8(v12, 2uLL) & 1) == 0)
    {
      sub_1002D4D0C(v14, 2uLL);
      uint64_t v15 = a1[13];
      long long v16 = v20;
      uint64_t v17 = sub_1000E9360(v14);
      sub_100205468(v15, v16, *((uint64_t *)&v16 + 1), v17);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1[18] + 8) + 88))();
}

void sub_1002CCF94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002CCFB0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 232))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    uint64_t v4 = qword_102419458;
    BOOL v5 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT);
    uint64_t v6 = *(void *)(a1 + 232);
    if (v5)
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 1026;
      *(_DWORD *)uint64_t v28 = v6 != 0;
      *(_WORD *)&v28[4] = 1026;
      *(_DWORD *)&v28[6] = a2 == -1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing create custom LOI at current location requests: \", \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x1Eu);
      uint64_t v6 = *(void *)(a1 + 232);
    }
    if (v6)
    {
      uint64_t v7 = a1 + 192;
      do
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 200) + ((*(void *)(a1 + 224) >> 4) & 0xFFFFFFFFFFFFFF8));
        uint64_t v9 = *(void *)(a1 + 224) & 0x7FLL;
        uint64_t v10 = v8 + 32 * v9;
        *(void *)uint64_t buf = v10 + 16;
        long long v30 = *((_OWORD *)sub_1001F2690(a1 + 64, (void *)(v10 + 16), (uint64_t)&unk_101D0B290, (_OWORD **)buf) + 2);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A49F0);
        }
        unint64_t v11 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
        {
          unint64_t v12 = operator new(0x28uLL);
          uint64_t v13 = v7;
          uint64_t v14 = a2;
          uint64_t v22 = v12;
          long long v23 = xmmword_101D048C0;
          *unint64_t v12 = 0u;
          v12[1] = 0u;
          *(void *)((char *)v12 + 29) = 0;
          sub_1001E0650(v10 + 16, v12);
          if (v23 >= 0) {
            uint64_t v15 = &v22;
          }
          else {
            uint64_t v15 = v22;
          }
          long long v16 = operator new(0x28uLL);
          long long __p = v16;
          long long v21 = xmmword_101D048C0;
          _OWORD *v16 = 0u;
          v16[1] = 0u;
          *(void *)((char *)v16 + 29) = 0;
          sub_1001E0650(v10, v16);
          p_p = &__p;
          if (v21 < 0) {
            p_p = __p;
          }
          *(_DWORD *)uint64_t buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v25 = 2082;
          uint64_t v26 = "";
          __int16 v27 = 2082;
          *(void *)uint64_t v28 = v15;
          *(_WORD *)&v28[8] = 2082;
          __int16 v29 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation completed for service\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}", buf, 0x26u);
          if (SHIBYTE(v21) < 0) {
            operator delete(__p);
          }
          a2 = v14;
          if (SHIBYTE(v23) < 0) {
            operator delete(v22);
          }
          uint64_t v7 = v13;
        }
        __int16 v18 = (uint64_t *)sub_1002C84B0(a1, *(void *)(v10 + 16), *(void *)(v8 + 32 * v9 + 24));
        if (v19) {
          sub_1002D689C(v18);
        }
        (*(void (**)(void, uint64_t, uint64_t, long long *))(**(void **)(a1 + 144) + 56))(*(void *)(a1 + 144), a2, v10, &v30);
        *(int64x2_t *)(a1 + 224) = vaddq_s64(*(int64x2_t *)(a1 + 224), (int64x2_t)xmmword_101D0A740);
        sub_1002D0514(v7, 1);
      }
      while (*(void *)(a1 + 232));
    }
  }
}

void sub_1002CD330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  operator delete(v25);
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1002CD370(void *a1)
{
  *a1 = off_1022A4928;
  uint64_t v2 = (void **)(a1 + 2);
  sub_1002CDF4C(a1 + 24);
  sub_100289BB4((uint64_t)(a1 + 19));
  sub_1000D7D80((uint64_t)(a1 + 8));
  sub_1002CDFF4(a1 + 5);
  uint64_t v4 = v2;
  sub_1000C5954(&v4);
  return a1;
}

void sub_1002CD3E8(void *a1)
{
  *a1 = off_1022A4928;
  uint64_t v2 = (void **)(a1 + 2);
  sub_1002CDF4C(a1 + 24);
  sub_100289BB4((uint64_t)(a1 + 19));
  sub_1000D7D80((uint64_t)(a1 + 8));
  sub_1002CDFF4(a1 + 5);
  uint64_t v3 = v2;
  sub_1000C5954(&v3);
  operator delete();
}

void sub_1002CD474(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002CD4A4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a1 + 87) < 0) {
      operator delete(*(void **)(a1 + 64));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
  }
  return a1;
}

uint64_t sub_1002CD4F0(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 62;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 124;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

uint64_t sub_1002CD598(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 184))
  {
    uint64_t v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(void *)(a1 + 152) = v2;
      operator delete(v2);
    }
    if (*(unsigned char *)(a1 + 128)) {
      sub_1002220F0(a1 + 88);
    }
    if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

std::string *sub_1002CD60C(std::string *__dst, const std::string *a2)
{
  if (__dst[1].__r_.__value_.__s.__data_[0])
  {
    std::string::operator=(__dst, a2);
  }
  else
  {
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_1000DC48C(__dst, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      long long v3 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      __dst->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = v3;
    }
    __dst[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return __dst;
}

uint64_t sub_1002CD678(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, uint64_t a7, long long *a8, double a9)
{
  uint64_t v18 = sub_1002CD7A8(a1, (uint64_t)a2);
  *(void *)(v18 + 352) = a3;
  *(void *)(v18 + 360) = a4;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1000DC48C((unsigned char *)(v18 + 368), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v19 = *a5;
    *(void *)(v18 + 384) = *((void *)a5 + 2);
    *(_OWORD *)(v18 + 368) = v19;
  }
  *(unsigned char *)(a1 + 392) = 1;
  *(void *)(a1 + 400) = a6;
  *(void *)(a1 + 408) = a7;
  sub_1001E17A4(a1 + 416, (unsigned __int8 *)a8, *a2);
  long long v20 = (unsigned char *)(a1 + 464);
  if (*((char *)a8 + 23) < 0)
  {
    sub_1000DC48C(v20, *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v21 = *a8;
    *(void *)(a1 + 480) = *((void *)a8 + 2);
    *(_OWORD *)long long v20 = v21;
  }
  *(double *)(a1 + 488) = a9;
  *(unsigned char *)(a1 + 496) = 0;
  *(unsigned char *)(a1 + 536) = 0;
  return a1;
}

void sub_1002CD764(_Unwind_Exception *a1)
{
  sub_1001E05E8(v3);
  if (*(unsigned char *)(v1 + 392))
  {
    if (*(char *)(v1 + 391) < 0) {
      operator delete(*v2);
    }
  }
  sub_1001EC93C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CD7A8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1001EF40C(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_1002CD90C((unsigned char *)(a1 + 72), a2 + 72);
  long long v4 = *(_OWORD *)(a2 + 200);
  long long v5 = *(_OWORD *)(a2 + 212);
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 212) = v5;
  *(_OWORD *)(a1 + 200) = v4;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  sub_1002CD964((void *)(a1 + 232), *(void *)(a2 + 232), *(void *)(a2 + 240), (uint64_t)(*(void *)(a2 + 240) - *(void *)(a2 + 232)) >> 5);
  sub_1002CDB00(a1 + 256, a2 + 256);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  sub_10010F834((void *)(a1 + 304), *(const void **)(a2 + 304), *(void *)(a2 + 312), (uint64_t)(*(void *)(a2 + 312) - *(void *)(a2 + 304)) >> 2);
  uint64_t v6 = (unsigned char *)(a1 + 328);
  if (*(char *)(a2 + 351) < 0)
  {
    sub_1000DC48C(v6, *(void **)(a2 + 328), *(void *)(a2 + 336));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 328);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(_OWORD *)uint64_t v6 = v7;
  }
  return a1;
}

void sub_1002CD8AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v4 + 312) = v8;
    operator delete(v8);
  }
  sub_1001EF1F0(v5);
  sub_1001EF278((void ***)va);
  sub_1001EF318(v3);
  sub_1000D7D80(v2);
  _Unwind_Resume(a1);
}

unsigned char *sub_1002CD90C(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(unsigned char *)(a2 + 120))
  {
    sub_10027C550((uint64_t)a1, a2);
    a1[120] = 1;
  }
  return a1;
}

void sub_1002CD950(_Unwind_Exception *a1)
{
  sub_1001EF318(v1);
  _Unwind_Resume(a1);
}

void *sub_1002CD964(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100222834(result, a4);
    unint64_t result = (void *)sub_1002CD9EC((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1002CD9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1001EF278(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CD9EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v9;
  void v7[2] = &v10;
  if (a2 != a3)
  {
    do
    {
      *(void *)uint64_t v4 = *(void *)a2;
      uint64_t v5 = *(void *)(a2 + 8);
      *(void *)(v4 + 8) = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
      v4 += 32;
      a2 += 32;
    }
    while (a2 != a3);
    uint64_t v10 = v4;
  }
  char v8 = 1;
  sub_1002CDA84((uint64_t)v7);
  return v4;
}

uint64_t sub_1002CDA84(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002CDABC(a1);
  }
  return a1;
}

void sub_1002CDABC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 - 24);
    if (v3) {
      sub_1000DB0A0(v3);
    }
    v1 -= 32;
  }
}

uint64_t sub_1002CDB00(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100100330(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_1002CDB78(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1002CDB60(_Unwind_Exception *a1)
{
  sub_1001EF1F0(v1);
  _Unwind_Resume(a1);
}

void *sub_1002CDB78(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = v6;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t result = (void *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = result[1];
          if (v11 == v6)
          {
            if (result[2] == *a2 && result[3] == a2[1]) {
              return result;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t result = (void *)*result;
        }
        while (result);
      }
    }
  }
  sub_1002CDDE8(a1, v6, a3, (uint64_t)&v21);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100100330(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  long long v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v21 = *v19;
    void *v19 = v21;
  }
  else
  {
    void *v21 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*v21)
    {
      unint64_t v20 = *(void *)(*v21 + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7) {
          v20 %= v7;
        }
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v20) = v21;
    }
  }
  unint64_t result = v21;
  ++*(void *)(a1 + 24);
  return result;
}

void sub_1002CDDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    sub_10027C94C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002CDDE8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x38uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *(_OWORD *)a3;
  v8[5] = 0;
  v8[6] = 0;
  void v8[4] = 0;
  unint64_t result = sub_10017C680(v8 + 4, *(const void **)(a3 + 16), *(void *)(a3 + 24), (uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 4);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1002CDE6C(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10027C94C(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CDE88(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 536)) {
    sub_100289AB8(a1 + 496);
  }
  if (*(char *)(a1 + 487) < 0) {
    operator delete(*(void **)(a1 + 464));
  }
  sub_10013F374((void *)(a1 + 440));
  sub_1000F5BB0(a1 + 416, *(void **)(a1 + 424));
  if (*(unsigned char *)(a1 + 392) && *(char *)(a1 + 391) < 0) {
    operator delete(*(void **)(a1 + 368));
  }
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  uint64_t v2 = *(void **)(a1 + 304);
  if (v2)
  {
    *(void *)(a1 + 312) = v2;
    operator delete(v2);
  }
  sub_1001EF1F0(a1 + 256);
  uint64_t v4 = (void **)(a1 + 232);
  sub_1001EF278(&v4);
  sub_1001EF318(a1 + 72);
  sub_1000D7D80(a1 + 16);
  return a1;
}

uint64_t sub_1002CDF4C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 64;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 128;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000D7EB4((uint64_t)a1);
}

void sub_1002CDFF4(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v3[1];
        sub_1002CE068((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_1002CE068(uint64_t a1)
{
  sub_1002CD4F0((void *)(a1 + 376));
  sub_1002CD4F0((void *)(a1 + 304));
  sub_1002CD598(a1 + 112);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_1000DB0A0(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    operator delete(v3);
  }
}

void ***sub_1002CE0E4(void ***a1, _OWORD *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  uint64_t v6 = *a1;
  unint64_t v9 = (unint64_t)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    uint64_t v12 = ((char *)v5 - (unsigned char *)*v4) >> 5;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59) {
      sub_1001D7FD4();
    }
    uint64_t v14 = v8 - (void)*v4;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      unint64_t v16 = (char *)sub_1001D9EDC(v7, v15);
    }
    else {
      unint64_t v16 = 0;
    }
    unint64_t v17 = &v16[32 * v12];
    size_t v18 = &v16[32 * v15];
    long long v19 = a2[1];
    *(_OWORD *)unint64_t v17 = *a2;
    *((_OWORD *)v17 + 1) = v19;
    unint64_t v11 = v17 + 32;
    long long v21 = (char *)*v4;
    unint64_t v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        long long v22 = *((_OWORD *)v20 - 1);
        *((_OWORD *)v17 - 2) = *((_OWORD *)v20 - 2);
        *((_OWORD *)v17 - 1) = v22;
        v17 -= 32;
        v20 -= 32;
      }
      while (v20 != v21);
      unint64_t v20 = (char *)*v4;
    }
    *uint64_t v4 = v17;
    v4[1] = v11;
    _DWORD v4[2] = v18;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v10 = a2[1];
    *unint64_t v5 = *a2;
    v5[1] = v10;
    unint64_t v11 = v5 + 2;
  }
  v4[1] = v11;
  return a1;
}

uint64_t sub_1002CE1DC(void *a1, unsigned int a2, uint64_t a3, unsigned int a4, void *a5)
{
  int64_t v5 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      if (v5 >= (unint64_t)(64 - a2)) {
        unint64_t v6 = 64 - a2;
      }
      else {
        unint64_t v6 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
      }
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v6)) & (-1 << a2) & (*a1 ^ *a5)) != 0) {
        return 0;
      }
      v5 -= v6;
      ++a5;
      ++a1;
    }
    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        uint64_t v7 = v5 - 64;
        ++a1;
        ++a5;
        BOOL v8 = v5 <= 127;
        v5 -= 64;
        if (v8) {
          goto LABEL_14;
        }
      }
      return 0;
    }
    uint64_t v7 = v5;
LABEL_14:
    if (v7 >= 1 && (*a1 ^ *a5) << -(char)v7) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_1002CE2A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  _DWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_1002CE354(a1, v4, v6);
      v6 += 88;
      uint64_t v4 = v12 + 88;
      v12 += 88;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_1002CE408((uint64_t)v9);
  return v4;
}

void sub_1002CE340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unsigned char *sub_1002CE354(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  uint64_t v6 = (unsigned char *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_1000DC48C(v6, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    long long v7 = *(_OWORD *)(a3 + 32);
    *(void *)(a2 + 48) = *(void *)(a3 + 48);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  unint64_t result = (unsigned char *)(a2 + 64);
  if (*(char *)(a3 + 87) < 0) {
    return sub_1000DC48C(result, *(void **)(a3 + 64), *(void *)(a3 + 72));
  }
  long long v9 = *(_OWORD *)(a3 + 64);
  *(void *)(a2 + 80) = *(void *)(a3 + 80);
  *(_OWORD *)unint64_t result = v9;
  return result;
}

void sub_1002CE3EC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002CE408(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002CE440((uint64_t *)a1);
  }
  return a1;
}

void sub_1002CE440(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 88;
      sub_10028B648(v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t sub_1002CE494(uint64_t a1)
{
  unsigned int v2 = sub_100291BF4(a1);
  if (sub_1002CE854() > v2) {
    return 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A49F0);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    BOOL v8 = "MiLoServices";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMiLoServiceTable]", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t result = sub_1002CE68C(a1);
  if (result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0) {
      uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_10003CC68(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_1002CE68C(uint64_t a1)
{
  unsigned int v2 = sub_100291BF4(a1);
  if (sub_1002CE854() <= v2)
  {
    unsigned int v4 = sub_100291BF4(a1);
    unint64_t v5 = v4 - (unint64_t)sub_1002CE854();
    unint64_t v6 = v5 + sub_1002CE904();
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A49F0);
    }
    long long v7 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      v8[0] = 68289538;
      v8[1] = 0;
      __int16 v9 = 2082;
      char v10 = "";
      __int16 v11 = 2050;
      unint64_t v12 = v6;
      __int16 v13 = 2082;
      uint64_t v14 = "MiLoServices";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Free up database space\", \"Rows to delete\":%{public}llu, \"Table name\":%{public, location:escape_only}s}", (uint8_t *)v8, 0x26u);
    }
    if (!*(void *)(a1 + 264)) {
      operator new();
    }
    sub_1002E317C();
  }
  return 1;
}

void sub_1002CE828()
{
}

uint64_t sub_1002CE854()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsServicesTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 256;
  }
}

void sub_1002CE8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002CE904()
{
  unsigned int v0 = sub_1002CE854();
  sub_1002CE94C();
  if (v1 < 0.0 || v1 > 1.0) {
    sub_101A58C5C();
  }
  return (float)(v1 * (float)v0);
}

void sub_1002CE94C()
{
  sub_1000C7F88(&v2);
  int v1 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsDatabaseFreeSpacePercentage", 0x8000100u, kCFAllocatorNull);
  sub_1004D123C(v2, (uint64_t)v0, (float *)&v1);
  CFRelease(v0);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_1002CE9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002CEA08(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  long long v7 = operator new(0x1E0uLL);
  *long long v7 = a2;
  v7[1] = a3;
  sub_1002CEA68((uint64_t)(v7 + 2), a4);
  return v7;
}

void sub_1002CEA54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CEA68(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  if (*((char *)a2 + 63) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 40), *((void **)a2 + 5), *((void *)a2 + 6));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 40);
    *(void *)(a1 + 56) = *((void *)a2 + 7);
    *(_OWORD *)(a1 + 40) = v6;
  }
  long long v7 = (unsigned char *)(a1 + 64);
  if (*((char *)a2 + 87) < 0)
  {
    sub_1000DC48C(v7, *((void **)a2 + 8), *((void *)a2 + 9));
  }
  else
  {
    long long v8 = a2[4];
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    *(_OWORD *)long long v7 = v8;
  }
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)(a1 + 96) = a2[6];
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  if (*((unsigned char *)a2 + 296))
  {
    sub_1002CEBF8(a1 + 112, (uint64_t)(a2 + 7));
    *(unsigned char *)(a1 + 296) = 1;
  }
  *(void *)(a1 + 304) = *((void *)a2 + 38);
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(void *)(a1 + 320) = *((void *)a2 + 40);
  *(void *)(a1 + 328) = *((void *)a2 + 41);
  a2[19] = 0u;
  a2[20] = 0u;
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(void *)(a1 + 344) = *((void *)a2 + 43);
  *((void *)a2 + 42) = 0;
  *((void *)a2 + 43) = 0;
  long long v9 = a2[22];
  *(unsigned char *)(a1 + 368) = *((unsigned char *)a2 + 368);
  *(_OWORD *)(a1 + 352) = v9;
  *(void *)(a1 + 376) = *((void *)a2 + 47);
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *(void *)(a1 + 392) = *((void *)a2 + 49);
  *(void *)(a1 + 400) = *((void *)a2 + 50);
  *(long long *)((char *)a2 + 376) = 0u;
  *(long long *)((char *)a2 + 392) = 0u;
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(void *)(a1 + 416) = *((void *)a2 + 52);
  *((void *)a2 + 51) = 0;
  *((void *)a2 + 52) = 0;
  long long v10 = *(long long *)((char *)a2 + 424);
  long long v11 = *(long long *)((char *)a2 + 440);
  *(_WORD *)(a1 + 456) = *((_WORD *)a2 + 228);
  *(_OWORD *)(a1 + 424) = v10;
  *(_OWORD *)(a1 + 440) = v11;
  return a1;
}

void sub_1002CEBDC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002CEBF8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v4 = *(_OWORD *)(a2 + 24);
  long long v5 = *(_OWORD *)(a2 + 33);
  *(unsigned char *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 33) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  *(unsigned char *)(a1 + 80) = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  *(unsigned char *)(a1 + 88) = 0;
  uint64_t v7 = a1 + 88;
  *(unsigned char *)(a1 + 128) = 0;
  if (*(unsigned char *)(a2 + 128))
  {
    sub_1000E2908(v7, (uint64_t *)(a2 + 88));
    *(unsigned char *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  return a1;
}

void *sub_1002CECD8(uint64_t a1, void *a2, _OWORD *a3, long long *a4)
{
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  do
    v9 ^= (v9 << 6) + (v9 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v8++);
  while (v8 != 16);
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      __int16 v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2 && v13[3] == a2[1]) {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          __int16 v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  __int16 v13 = operator new(0x30uLL);
  *__int16 v13 = 0;
  v13[1] = v9;
  long long v16 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100100330(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *__int16 v13 = *v24;
LABEL_44:
    *uint64_t v24 = v13;
    goto LABEL_45;
  }
  *__int16 v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v4) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1002CEF28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

long long *sub_1002CEF3C(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  long long v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)long long v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        sub_1000DB0A0(v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *sub_1002CEFA8@<X0>(unsigned int *a1@<X1>, uint64_t *a2@<X2>, long long *a3@<X3>, uint64_t *a4@<X4>, long long *a5@<X5>, double *a6@<X6>, void *a7@<X8>)
{
  unint64_t v14 = operator new(0x238uLL);
  uint64_t result = sub_1002CF03C(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_1002CF028(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002CF03C(void *a1, unsigned int *a2, uint64_t *a3, long long *a4, uint64_t *a5, long long *a6, double *a7)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022A4A20;
  sub_1002CD678((uint64_t)(a1 + 3), a2, *a3, a3[1], a4, *a5, a5[1], a6, *a7);
  return a1;
}

void sub_1002CF0A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002CF0B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1022A4A20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002CF0D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1022A4A20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002CF12C(uint64_t a1)
{
  return sub_1002CDE88(a1 + 24);
}

void *sub_1002CF138@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x238uLL);
  uint64_t result = sub_1002CF194(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002CF180(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002CF194(void *a1, uint64_t a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1022A4A20;
  sub_1002CF1F0((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1002CF1DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CF1F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1002CD7A8(a1, a2);
  *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 352);
  sub_1000E3A78(v4 + 368, (long long *)(a2 + 368));
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  sub_1002CF340((uint64_t *)(a1 + 416), a2 + 416);
  sub_1004CE5C0((void *)(a1 + 440), a2 + 440);
  *(void *)(a1 + 440) = &off_1022A5E30;
  *(void *)(a1 + 456) = *(void *)(a2 + 456);
  if (*(char *)(a2 + 487) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 464), *(void **)(a2 + 464), *(void *)(a2 + 472));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 464);
    *(void *)(a1 + 480) = *(void *)(a2 + 480);
    *(_OWORD *)(a1 + 464) = v5;
  }
  *(void *)(a1 + 488) = *(void *)(a2 + 488);
  sub_1002CF654((unsigned char *)(a1 + 496), a2 + 496);
  return a1;
}

void sub_1002CF2D0(_Unwind_Exception *a1)
{
  sub_1001E05E8(v3);
  if (*(unsigned char *)(v1 + 392))
  {
    if (*(char *)(v1 + 391) < 0) {
      operator delete(*v2);
    }
  }
  sub_1001EC93C(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1002CF340(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1002CF398(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1002CF380(_Unwind_Exception *a1)
{
  sub_1000F5BB0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1002CF398(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    long long v5 = (uint64_t **)result;
    long long v6 = result + 1;
    do
    {
      uint64_t result = sub_1002CF424(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      long long v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          long long v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1002CF424(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  long long v6 = sub_1002CF4AC(a1, a2, &v11, &v10, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    long long v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000EDF90(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_1002CF4AC(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  long long v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      __int16 v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        __int16 v13 = v10;
      }
      while (v14);
    }
    int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          float v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          long long v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        long long v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      float v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    unint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      unint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    BOOL v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      BOOL v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unint64_t v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          long long v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        long long v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      unint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

unsigned char *sub_1002CF654(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    sub_1002CF6B4((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_1002CF698(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 40)) {
    sub_100289AB8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002CF6B4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100100330(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_1002CF72C(a1, i + 2, (_OWORD *)i + 1);
  return a1;
}

void sub_1002CF714(_Unwind_Exception *a1)
{
  sub_100289AB8(v1);
  _Unwind_Resume(a1);
}

void *sub_1002CF72C(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = v6;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    BOOL v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == *a2 && v10[3] == a2[1]) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  sub_1002CF9AC(a1, v6, a3, (uint64_t)v22);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100100330(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  BOOL v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *(void *)v22[0] = *v19;
    void *v19 = v22[0];
  }
  else
  {
    *(void *)v22[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v22[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v22[0])
    {
      unint64_t v20 = *(void *)(*(void *)v22[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7) {
          v20 %= v7;
        }
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v20) = v22[0];
    }
  }
  uint64_t v10 = (void *)v22[0];
  v22[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1002CFA28((uint64_t)v22, 0);
  return v10;
}

void sub_1002CF994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002CFA28((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CF9AC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *a3;
  uint64_t result = sub_100222178((uint64_t)(v8 + 4), (uint64_t)(a3 + 1));
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1002CFA10(_Unwind_Exception *a1)
{
  sub_1002CFA28(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1002CFA28(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002220F0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_1002CFA80(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002CFAF8((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002CFAF8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1002CFB8C((uint64_t)v12);
  return v10;
}

uint64_t sub_1002CFB8C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002CFBC4(a1);
  }
  return a1;
}

void sub_1002CFBC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_1000DB0A0(v3);
    }
    v1 += 16;
  }
}

void sub_1002CFC0C()
{
}

void *sub_1002CFC20()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1022A4A70;
  return result;
}

void sub_1002CFC58(uint64_t a1, void *a2)
{
  *a2 = off_1022A4A70;
}

BOOL sub_1002CFC80(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(*(void *)a2 + 4) == 0;
}

uint64_t sub_1002CFC94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002CFCD4()
{
}

void *sub_1002CFCE0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1002CFD68()
{
}

void *sub_1002CFD7C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A4B00;
  result[1] = v3;
  return result;
}

uint64_t sub_1002CFDC4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A4B00;
  a2[1] = v2;
  return result;
}

BOOL sub_1002CFDF0(uint64_t a1, void *a2)
{
  uint64_t v2 = (unsigned __int8 *)(*a2 + 368);
  sub_1002DA0B4(*(void *)(a1 + 8), &__p);
  BOOL v3 = sub_10026F754(v2, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v3;
}

uint64_t sub_1002CFE4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002CFE8C()
{
}

uint64_t sub_1002CFE98(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

__n128 sub_1002CFF30(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002CFFC0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  uint64_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *uint64_t v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_1002CFFC0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C(v5, v33);
      size_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      size_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0x1000uLL);
  sub_1000DA434(&v54, &v53);
  __int16 v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1002D028C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002D02D8(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      BOOL v14 = (char *)sub_1000DA54C(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        int64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)int64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void sub_1002D03F8(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_1000DA54C(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      uint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        uint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

uint64_t sub_1002D0514(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x80) {
    a2 = 1;
  }
  if (v2 < 0x100) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 128;
  }
  return v4 ^ 1u;
}

BOOL sub_1002D0574()
{
  return os_log_type_enabled(v0, OS_LOG_TYPE_INFO);
}

void sub_1002D058C(uint64_t a1, xpc_object_t xdict)
{
}

void sub_1002D05A0(uint64_t a1, xpc_object_t xdict)
{
}

void sub_1002D05B0(const char **a1, xpc_object_t xdict)
{
}

uint64_t sub_1002D05C0(uint64_t result, char a2)
{
  *(unsigned char *)__n128 result = a2;
  *(void *)(result + 8) = XPC_ACTIVITY_ALLOW_BATTERY;
  return result;
}

uint64_t sub_1002D05D8(uint64_t result, char a2)
{
  *(unsigned char *)__n128 result = a2;
  *(void *)(result + 8) = XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP;
  return result;
}

void *sub_1002D05F0(void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = XPC_ACTIVITY_INTERVAL;
  return result;
}

void *sub_1002D0604(void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = XPC_ACTIVITY_PRIORITY;
  return result;
}

void **sub_1002D0618(void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    xpc_release(v2);
  }
  return a1;
}

uint64_t sub_1002D0650(uint64_t a1, long long *a2, void **a3, uint64_t a4)
{
  long long v7 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v7;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *((unsigned char *)&v16.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v16, "com.apple.locationd.");
  int v8 = *(char *)(a1 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v9 = *(const std::string::value_type **)a1;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v10 = *(void *)(a1 + 8);
  }
  unint64_t v11 = std::string::append(&v16, v9, v10);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t v18 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v18 >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = (void **)__p[0];
  }
  uint64_t v14 = *a3;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3321888768;
  handler[2] = sub_1002D0874;
  handler[3] = &unk_1022A4B70;
  uint64_t v19 = a1;
  sub_1002D0E24((uint64_t)v20, a4);
  handler[4] = v19;
  sub_1002D0E24((uint64_t)v22, (uint64_t)v20);
  xpc_activity_register((const char *)v13, v14, handler);
  sub_1002D0D70(v20);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  sub_1002D0D70(v22);
  return a1;
}

void sub_1002D080C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v24 = v22;
  sub_1002D0D70(v24);
  sub_1002D0D70(v23);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (*(char *)(v21 + 23) < 0) {
    operator delete(*(void **)v21);
  }
  _Unwind_Resume(a1);
}

void sub_1002D0874(uint64_t a1, xpc_activity_t activity)
{
  int v4 = *(uint64_t **)(a1 + 32);
  xpc_activity_t v9 = activity;
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state == 2)
  {
    sub_1002D0B1C(&v9, 4);
    sub_1002D0D1C(a1 + 40, (uint64_t)activity);
  }
  else if (!state)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4BA0);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      long long v7 = v4;
      if (*((char *)v4 + 23) < 0) {
        long long v7 = (uint64_t *)*v4;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Checking in for %{public}s", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4BA0);
      }
      if (*((char *)v4 + 23) < 0) {
        int v4 = (uint64_t *)*v4;
      }
      int v10 = 136446210;
      unint64_t v11 = v4;
      int v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "auto CLMicroLocationXPCActivityHelpers::XPCRegistration::XPCRegistration(std::string, const XPCCriteria &, XPCActivityHandler)::(anonymous class)::operator()(xpc_activity_t) const", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
}

uint64_t sub_1002D0AB0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return sub_1002D0E24(a1 + 40, a2 + 40);
}

void *sub_1002D0AC4(uint64_t a1)
{
  return sub_1002D0D70((void *)(a1 + 40));
}

const char *sub_1002D0AD0(const char *a1)
{
  uint64_t v1 = a1;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  xpc_activity_unregister(a1);
  if (v1[23] < 0) {
    operator delete(*(void **)v1);
  }
  return v1;
}

void sub_1002D0B1C(xpc_activity_t *a1, xpc_activity_state_t a2)
{
  if (!xpc_activity_set_state(*a1, a2))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4BA0);
    }
    int v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      xpc_activity_state_t state = xpc_activity_get_state(*a1);
      *(_DWORD *)uint64_t buf = 134349312;
      xpc_activity_state_t v8 = a2;
      __int16 v9 = 2050;
      xpc_activity_state_t v10 = state;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld", buf, 0x16u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4BA0);
      }
      xpc_activity_get_state(*a1);
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationXPCActivityHelpers::XPCActivity::setState(xpc_activity_state_t)", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

BOOL sub_1002D0D04(xpc_activity_t *a1)
{
  return xpc_activity_should_defer(*a1);
}

void sub_1002D0D0C(xpc_activity_t *a1)
{
}

void sub_1002D0D14(xpc_activity_t *a1)
{
}

uint64_t sub_1002D0D1C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10015E48C();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void *sub_1002D0D70(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1002D0DF4(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002D0E24(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

BOOL sub_1002D0EBC(uint64_t a1, uint64_t a2)
{
  return HIDWORD(a1) > HIDWORD(a2);
}

void *sub_1002D0ED0(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    uint64_t v4 = result;
    do
    {
      unsigned int v5 = *(_DWORD *)(v2 + 32);
      if (!sub_1001EF6E0(v4, &v5))
      {
        uint64_t v6 = &v5;
        *((_DWORD *)sub_1002D13C8((uint64_t)v4, &v5, (uint64_t)&unk_101D0B290, &v6) + 5) = 0;
      }
      uint64_t v6 = &v5;
      __n128 result = sub_1002D13C8((uint64_t)v4, &v5, (uint64_t)&unk_101D0B290, &v6);
      ++*((_DWORD *)result + 5);
      v2 += 48;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_1002D0F8C(uint64_t a1)
{
  return *(void *)(a1 + 24) == 0;
}

uint64_t sub_1002D0F9C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = 0;
    unsigned int v5 = a2 + 2;
    do
    {
      if ((unint64_t)v4 >= *v5)
      {
        uint64_t v6 = (uint64_t)&v4[-*a2] >> 3;
        if ((unint64_t)(v6 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v7 = *v5 - *a2;
        uint64_t v8 = v7 >> 2;
        if (v7 >> 2 <= (unint64_t)(v6 + 1)) {
          uint64_t v8 = v6 + 1;
        }
        if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v9 = v8;
        }
        xpc_activity_state_t v10 = (char *)sub_1000DA54C((uint64_t)(a2 + 2), v9);
        long long v12 = &v10[8 * v6];
        *(void *)long long v12 = v3[2];
        uint64_t v4 = v12 + 8;
        uint64_t v14 = (char *)*a2;
        uint64_t v13 = (char *)a2[1];
        if (v13 != (char *)*a2)
        {
          do
          {
            uint64_t v15 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v12 - 1) = v15;
            v12 -= 8;
          }
          while (v13 != v14);
          uint64_t v13 = (char *)*a2;
        }
        *a2 = (uint64_t)v12;
        a2[1] = (uint64_t)v4;
        a2[2] = (uint64_t)&v10[8 * v11];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *(void *)uint64_t v4 = v3[2];
        v4 += 8;
      }
      a2[1] = (uint64_t)v4;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  std::string v16 = a2 + 2;
  for (int i = 1; i != 14; ++i)
  {
    uint64_t v18 = *a2;
    uint64_t v19 = (char *)*a2;
    if ((char *)*a2 == v4)
    {
LABEL_23:
      if ((unint64_t)v4 >= *v16)
      {
        uint64_t v20 = (uint64_t)&v4[-v18] >> 3;
        if ((unint64_t)(v20 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v21 = *v16 - v18;
        uint64_t v22 = v21 >> 2;
        if (v21 >> 2 <= (unint64_t)(v20 + 1)) {
          uint64_t v22 = v20 + 1;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v22;
        }
        uint64_t v24 = (char *)sub_1000DA54C((uint64_t)(a2 + 2), v23);
        uint64_t v26 = (int *)&v24[8 * v20];
        *uint64_t v26 = i;
        v26[1] = 0;
        uint64_t v28 = (char *)*a2;
        __int16 v27 = (char *)a2[1];
        __int16 v29 = v26;
        if (v27 != (char *)*a2)
        {
          do
          {
            uint64_t v30 = *((void *)v27 - 1);
            v27 -= 8;
            *((void *)v29 - 1) = v30;
            v29 -= 2;
          }
          while (v27 != v28);
          __int16 v27 = (char *)*a2;
        }
        uint64_t v4 = (char *)(v26 + 2);
        *a2 = (uint64_t)v29;
        a2[1] = (uint64_t)(v26 + 2);
        a2[2] = (uint64_t)&v24[8 * v25];
        if (v27) {
          operator delete(v27);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v4 = i;
        *((_DWORD *)v4 + 1) = 0;
        v4 += 8;
      }
      a2[1] = (uint64_t)v4;
    }
    else
    {
      while (*(_DWORD *)v19 != i)
      {
        v19 += 8;
        if (v19 == v4) {
          goto LABEL_23;
        }
      }
    }
  }
  uint64_t v31 = *a2;
  unint64_t v32 = 126 - 2 * __clz((uint64_t)&v4[-*a2] >> 3);
  BOOL v33 = v4 == (char *)*a2;
  uint64_t v36 = sub_1002D0EBC;
  if (v33) {
    uint64_t v34 = 0;
  }
  else {
    uint64_t v34 = v32;
  }
  return sub_1002D15EC(v31, v4, (uint64_t (**)(uint64_t, uint64_t))&v36, v34, 1);
}

void sub_1002D11D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002D11FC(uint64_t a1@<X0>, void **a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40)) {
    sub_101A58DE4();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    uint64_t v3 = *(void *)(qword_102489B20 + 16);
  }
  uint64_t v4 = *(int *)(v3 + 16);
  if (v4)
  {
    unsigned int v5 = *(uint64_t **)(v3 + 8);
    uint64_t v6 = &v5[v4];
    do
    {
      sub_10026ABE0((uint64_t)v23, *v5);
      int v7 = v24;
      if ((v24 - 14) >= 0xFFFFFFF3)
      {
        int v8 = v23[2];
        xpc_activity_state_t v10 = a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v12 = ((char *)v10 - (unsigned char *)*a2) >> 3;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61) {
            sub_1001D7FD4();
          }
          uint64_t v14 = v9 - (void)*a2;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          std::string v16 = (char *)sub_1000DA54C((uint64_t)(a2 + 2), v15);
          uint64_t v18 = &v16[8 * v12];
          *(_DWORD *)uint64_t v18 = v7;
          *((_DWORD *)v18 + 1) = v8;
          uint64_t v20 = (char *)*a2;
          uint64_t v19 = (char *)a2[1];
          uint64_t v21 = v18;
          if (v19 != *a2)
          {
            do
            {
              uint64_t v22 = *((void *)v19 - 1);
              v19 -= 8;
              *((void *)v21 - 1) = v22;
              v21 -= 8;
            }
            while (v19 != v20);
            uint64_t v19 = (char *)*a2;
          }
          uint64_t v11 = v18 + 8;
          *a2 = v21;
          a2[1] = v18 + 8;
          a2[2] = &v16[8 * v17];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          _DWORD *v10 = v24;
          v10[1] = v8;
          uint64_t v11 = v10 + 2;
        }
        a2[1] = v11;
      }
      sub_10026ABE4((wireless_diagnostics::google::protobuf::MessageLite *)v23);
      ++v5;
    }
    while (v5 != v6);
  }
}

void sub_1002D1368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10026ABE4((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  uint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_1002D1398(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1002D13C8(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    xpc_activity_state_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = operator new(0x18uLL);
  void *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100100330(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    void *v11 = *v20;
LABEL_38:
    void *v20 = v11;
    goto LABEL_39;
  }
  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1002D15D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002D15EC(uint64_t result, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  xpc_activity_state_t v10 = (char *)result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    xpc_activity_state_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - v11;
    unint64_t v15 = (a2 - v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          __n128 result = (*a3)(*((void *)a2 - 1), *(void *)v11);
          if (result)
          {
            uint64_t v22 = *(void *)v11;
            *(void *)uint64_t v11 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v22;
          }
          break;
        case 3uLL:
          __n128 result = sub_1002D1B14(v11, (void *)v11 + 1, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 4uLL:
          __n128 result = sub_1002D1FF8(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 5uLL:
          __n128 result = sub_1002D20AC(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)v11 + 3, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_1002D2188(v11, a2, (uint64_t *)a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[8 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_1002D1B14(v11, &v11[8 * (v15 >> 1)], (void *)a2 - 1, (unsigned int (**)(void))a3);
      sub_1002D1B14((void *)v11 + 1, (void *)v17 - 1, (void *)a2 - 2, (unsigned int (**)(void))a3);
      sub_1002D1B14((void *)v11 + 2, &v11[8 * v16 + 8], (void *)a2 - 3, (unsigned int (**)(void))a3);
      sub_1002D1B14((void *)v17 - 1, v17, &v11[8 * v16 + 8], (unsigned int (**)(void))a3);
      uint64_t v18 = *(void *)v11;
      *(void *)uint64_t v11 = *(void *)v17;
      *(void *)unint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_1002D1B14(&v11[8 * (v15 >> 1)], v11, (void *)a2 - 1, (unsigned int (**)(void))a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (((*a3)(*((void *)v11 - 1), *(void *)v11) & 1) == 0)
    {
      __n128 result = (uint64_t)sub_1002D1C04((uint64_t *)v11, (uint64_t *)a2, a3);
      uint64_t v11 = (char *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = sub_1002D1D14((uint64_t *)v11, (uint64_t *)a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_1002D1E30(v11, v19, (unsigned int (**)(void))a3);
    uint64_t v11 = (char *)(v19 + 1);
    __n128 result = sub_1002D1E30(v19 + 1, a2, (unsigned int (**)(void))a3);
    if (result)
    {
      a4 = -v13;
      a2 = (char *)v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      __n128 result = sub_1002D15EC(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = (char *)(v19 + 1);
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return sub_1002D19B0((uint64_t)v11, (uint64_t *)a2, a3);
  }
  else
  {
    return sub_1002D1A78((uint64_t)v11, a2, a3);
  }
}

uint64_t sub_1002D19B0(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v4 = (void *)result;
    char v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0;
      unint64_t v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        unint64_t v8 = v5;
        __n128 result = (*a3)(v9, v10);
        if (result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            __n128 result = (*a3)(v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          *uint64_t v13 = v11;
        }
        char v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_1002D1A78(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    unint64_t v4 = (void *)result;
    for (int i = (void *)(result + 8); v4 + 1 != a2; int i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      unint64_t v4 = i;
      __n128 result = (*a3)(v7, v8);
      if (result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          void *v11 = v12;
          __n128 result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        void *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t sub_1002D1B14(void *a1, void *a2, void *a3, unsigned int (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(void, void))*a4)(*a2, *a1)) {
      return 1;
    }
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  uint64_t v10 = *a1;
  if (!result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3)) {
      return 1;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *sub_1002D1C04(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  unint64_t v4 = a2;
  uint64_t v6 = *a1;
  if ((*a3)(*a1, *(a2 - 1)))
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 1;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      uint64_t v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    uint64_t v11 = *v7;
    *uint64_t v7 = *v4;
    *unint64_t v4 = v11;
    do
    {
      uint64_t v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      uint64_t v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_1002D1D14(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  do
    char v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      uint64_t v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    uint64_t v13 = &a1[v6];
    uint64_t v14 = a2;
    do
    {
      uint64_t v15 = *v13;
      *uint64_t v13 = *v14;
      uint64_t *v14 = v15;
      do
      {
        uint64_t v16 = v13[1];
        ++v13;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *--v14;
      while (!(*a3)(v17, v7));
    }
    while (v13 < v14);
    uint64_t v10 = v13 - 1;
  }
  if (v10 != a1) {
    *a1 = *v10;
  }
  uint64_t *v10 = v7;
  return v10;
}

BOOL sub_1002D1E30(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      sub_1002D1B14(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1002D1FF8(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1002D20AC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v9 = a1 + 2;
      sub_1002D1B14(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      void *v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1002D1FF8(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  sub_1002D1B14(a1, a2, a3, a5);
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t sub_1002D20AC(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int (**a6)(void))
{
  sub_1002D1FF8(a1, a2, a3, a4, a6);
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1002D2188(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[8 * v10];
      do
      {
        sub_1002D22E0((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != (char *)a3)
    {
      uint64_t v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(void *)a1))
        {
          uint64_t v15 = *v14;
          uint64_t *v14 = *(void *)a1;
          *(void *)a1 = v15;
          sub_1002D22E0((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 8;
      do
      {
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = (char *)sub_1002D2408(a1, (unsigned int (**)(void, void))a4, v16);
        if (v17 == v19)
        {
          *(void *)uint64_t v19 = v18;
        }
        else
        {
          *(void *)uint64_t v19 = *(void *)v17;
          *(void *)uint64_t v17 = v18;
          sub_1002D24B8((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t sub_1002D22E0(uint64_t result, unsigned int (**a2)(void, void), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    char v5 = a4;
    uint64_t v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (void *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      uint64_t result = ((uint64_t (*)(void, void))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          *char v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (void *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              uint64_t v16 = 2 * v11 + 2;
            }
          }
          uint64_t result = ((uint64_t (*)(void, uint64_t))*a2)(*v12, v14);
          char v5 = v15;
          uint64_t v11 = v16;
        }
        while (!result);
        void *v15 = v14;
      }
    }
  }
  return result;
}

void *sub_1002D2408(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t sub_1002D24B8(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (*a3)(*v8, *(void *)(a2 - 8));
    if (result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        uint64_t result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }
      while ((result & 1) != 0);
      uint64_t *v11 = v10;
    }
  }
  return result;
}

double sub_1002D255C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    sub_101A58FBC();
  }
  return (float)(*(float *)(a1 + 12) - *(float *)(a2 + 12));
}

void sub_1002D2594(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12 = *a3;
  if (*((unsigned char *)a3 + 8)) {
    uint64_t v12 = (~*(unsigned char *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v12 & 0x7F;
  }
  uint64_t v22 = v12;
  uint64_t v13 = *(void **)(a1 + 16);
  if (v13)
  {
    uint64_t v14 = 0;
    double v15 = 0.0;
    double v16 = 0.0;
    do
    {
      uint64_t v17 = (double *)sub_1002D3074((void *)a2, (uint64_t)(v13 + 2));
      if (v17)
      {
        uint64_t v18 = (uint64_t)(v17 + 2);
        if (sub_1002D2884(&v22, a6, (uint64_t)(v13 + 2), v17[2]))
        {
          double v19 = (*(double (**)(uint64_t, void *))(*(void *)a5 + 16))(a5, v13 + 2);
          double v20 = (*(double (**)(uint64_t, void *))(*(void *)a4 + 16))(a4, v13 + 2);
          double v21 = sub_1002D255C((uint64_t)(v13 + 2), v18);
          double v16 = v16 + v20 * v21 * (v20 * v21) * v19;
          ++v14;
          double v15 = v15 + v19;
        }
      }
      uint64_t v13 = (void *)*v13;
    }
    while (v13);
  }
  else
  {
    uint64_t v14 = 0;
    double v16 = 0.0;
    double v15 = 0.0;
  }
  *(double *)a7 = v16;
  *(double *)(a7 + 8) = v15;
  *(void *)(a7 + 16) = v14;
}

uint64_t sub_1002D2708(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = *a3;
  if (*((unsigned char *)a3 + 8)) {
    uint64_t v6 = (~*(unsigned char *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v6 & 0x7F;
  }
  uint64_t v11 = v6;
  unint64_t v7 = *(void **)(a1 + 16);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = 0;
  do
  {
    uint64_t v9 = (double *)sub_1002D3074((void *)a2, (uint64_t)(v7 + 2));
    if (v9) {
      v8 += sub_1002D2884(&v11, a4, (uint64_t)(v7 + 2), v9[2]);
    }
    unint64_t v7 = (void *)*v7;
  }
  while (v7);
  return v8;
}

uint64_t sub_1002D27B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = *a4;
  if (*((unsigned char *)a4 + 8)) {
    uint64_t v9 = (~*(unsigned char *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v9 & 0x7F;
  }
  uint64_t v14 = v9;
  uint64_t v10 = *(void **)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 0;
    do
    {
      v11 += sub_1002D2884(&v14, a5, (uint64_t)(v10 + 2), *(double *)(a2 + 144));
      uint64_t v10 = (void *)*v10;
    }
    while (v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  for (int i = *(void **)(a2 + 16); i; int i = (void *)*i)
    v11 += sub_1002D2884(&v14, a5, (uint64_t)(i + 2), *(double *)(a1 + 144));
  return v11 - a3;
}

BOOL sub_1002D2884(void *a1, uint64_t a2, uint64_t a3, double a4)
{
  double v6 = a4;
  unsigned int v4 = *(_DWORD *)(a3 + 8);
  if (v4 >= 7) {
    sub_10000EDDC("bitset test argument out of range");
  }
  return ((*a1 >> v4) & 1) != 0 && (!*(unsigned char *)(a2 + 56) || (sub_100333FE4(a2, a3, &v6) & 1) != 0);
}

double sub_1002D28F4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *a3;
  if (*((unsigned char *)a3 + 8)) {
    uint64_t v13 = (~*(unsigned char *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v13 & 0x7F;
  }
  uint64_t v19 = v13;
  uint64_t v14 = *(void **)(a1 + 16);
  if (v14)
  {
    double v15 = 0.0;
    double v16 = 0.0;
    do
    {
      if (sub_1002D2884(&v19, a7, (uint64_t)(v14 + 2), *(double *)(a2 + 144)))
      {
        if (sub_1002D3074((void *)a2, (uint64_t)(v14 + 2))) {
          double v16 = v16 + (*(double (**)(uint64_t, void *))(*(void *)a4 + 16))(a4, v14 + 2);
        }
        else {
          double v15 = v15 + (*(double (**)(uint64_t, void *))(*(void *)a5 + 16))(a5, v14 + 2);
        }
      }
      uint64_t v14 = (void *)*v14;
    }
    while (v14);
  }
  else
  {
    double v15 = 0.0;
  }
  for (int i = *(void **)(a2 + 16); i; int i = (void *)*i)
  {
    if (sub_1002D2884(&v19, a7, (uint64_t)(i + 2), *(double *)(a1 + 144))
      && !sub_1002D3074((void *)a1, (uint64_t)(i + 2))
      && ((*(uint64_t (**)(uint64_t, void *))(*(void *)a6 + 16))(a6, i + 2) & 1) == 0)
    {
      double v15 = v15 + (*(double (**)(uint64_t, void *))(*(void *)a5 + 16))(a5, i + 2);
    }
  }
  return v15;
}

double sub_1002D2AD0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  sub_1002D2594(a1, a2, a3, (uint64_t)&qword_10247A748, (uint64_t)&qword_10247A768, a4, (uint64_t)v5);
  if (v6) {
    return sqrt(v5[0] / (double)v6);
  }
  else {
    return 1.79769313e308;
  }
}

double sub_1002D2B2C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = sub_1002D2708(a1, a2, a3, a4);
  uint64_t v9 = sub_1002D27B8(a1, a2, v8, a3, a4);
  if (v9) {
    return (double)(unint64_t)(v9 - v8) / (double)(unint64_t)v9;
  }
  else {
    return 1.79769313e308;
  }
}

uint64_t sub_1002D2BA8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  sub_1002D2594(a1, a2, a3, (uint64_t)&qword_10247A748, (uint64_t)&qword_10247A768, a4, (uint64_t)v9);
  return sub_1002D27B8(a1, a2, v9[2], a3, a4);
}

double sub_1002D2C98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, double a9, double a10, uint64_t a11)
{
  if (!(*(void *)(a1 + 24) | *(void *)(a2 + 24))) {
    return 1.79769313e308;
  }
  sub_1002D2594(a1, a2, a8, a3, a4, a11, (uint64_t)&v25);
  if (!v27) {
    return a9;
  }
  double v19 = sub_1002D28F4(a1, a2, a8, a5, a6, a7, a11);
  if (v26 == 0.0 || v20 == 0.0)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4BE0);
    }
    uint64_t v22 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4BE0);
      }
      int v24 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(const CLMicroLocationFingerprint &, const CLMicroLocationFingerprint &, double, double, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<BOOL> &, const EnabledTechnologiesConfig &, const std::optional<CLMicroLocationAnchorAppearanceMap> &)", "%s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
    return 1.79769313e308;
  }
  if (a10 <= 0.0 || a10 > 1.0) {
    sub_101A59140();
  }
  double v21 = v26 / (v26 + v20);
  if (a10 < 1.0) {
    double v21 = fmin(v21 / a10, 1.0);
  }
  return v19 / v20 * a9 * (1.0 - v21) + sqrt(v25 / (double)(unint64_t)v26) * v21;
}

void sub_1002D2F2C(void *a1, void *a2, long double a3)
{
  unint64_t v6 = (float *)a1[2];
  if (v6)
  {
    double v7 = 0.0;
    double v8 = 0.0;
    double v9 = 0.0;
    do
    {
      double v10 = pow(a3, v6[7]);
      uint64_t v11 = (float *)sub_1002D3074(a2, (uint64_t)(v6 + 4));
      if (v11)
      {
        long double v12 = pow(a3, v11[7]);
        double v8 = v8 + v10 * v12;
        double v9 = v9 + v12 * v12;
      }
      double v7 = v7 + v10 * v10;
      unint64_t v6 = *(float **)v6;
    }
    while (v6);
  }
  else
  {
    double v9 = 0.0;
  }
  for (int i = (float *)a2[2]; i; int i = *(float **)i)
  {
    if (!sub_1002D3074(a1, (uint64_t)(i + 4)))
    {
      long double v14 = pow(a3, i[7]);
      double v9 = v9 + v14 * v14;
    }
  }
}

void sub_1002D3044(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1002D3074(void *a1, uint64_t a2)
{
  unint64_t v4 = sub_10031EBEC((uint64_t)(a1 + 3), a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  double v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = (void *)*v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = v11[1];
      if (v6 == v13)
      {
        if (sub_10031EC4C(v12, (uint64_t)(v11 + 2), a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      uint64_t v11 = (void *)*v11;
    }
    while (v11);
  }
  return v11;
}

void *sub_1002D3178(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  int8x8_t v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *uint64_t result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    uint64_t result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    unint64_t v8 = &v5[v7];
    void *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

uint64_t sub_1002D322C()
{
  uint64_t v7 = 0;
  unint64_t v8 = &v7;
  int v9 = 0;
  sub_1002D3178(&v8, 7uLL);
  qword_102489B30 = v7;
  byte_102489B38 = 0;
  qword_10247A748 = (uint64_t)off_10229F0F0;
  __asm { FMOV            V0.2D, #1.0 }
  long long v6 = _Q0;
  *(_OWORD *)algn_10247A750 = _Q0;
  qword_10247A760 = 0x4008000000000000;
  __cxa_atexit((void (*)(void *))nullsub_41, &qword_10247A748, (void *)&_mh_execute_header);
  *(_OWORD *)algn_10247A770 = v6;
  qword_10247A780 = 0x3FF0000000000000;
  qword_10247A768 = (uint64_t)off_1022A4C10;
  return __cxa_atexit((void (*)(void *))nullsub_41, &qword_10247A768, (void *)&_mh_execute_header);
}

uint64_t sub_1002D3324(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1001DD364((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  *(_DWORD *)(a1 + 24) = 0;
  int v4 = sub_10029B910((void *)(a1 + 32), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  uint64_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  if (v5)
  {
    unint64_t v6 = v5 >> 3;
    uint64_t v7 = (_DWORD *)*v4;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    unint64_t v8 = (int *)(*(void *)a2 + 4);
    do
    {
      int v9 = *v8;
      v8 += 2;
      int v10 = *(_DWORD *)(a1 + 24) + v9;
      *(_DWORD *)(a1 + 24) = v10;
      *v7++ = v10;
      --v6;
    }
    while (v6);
  }
  return a1;
}

void sub_1002D33BC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1002D33DC@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v4 = (int *)*result;
  unint64_t v5 = (result[1] - *result) >> 3;
  if (v5 >= a2) {
    unint64_t v5 = a2;
  }
  unint64_t v8 = a3;
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    do
    {
      int v7 = *v4;
      uint64_t result = sub_10027DE2C((uint64_t *)&v8, &v7);
      v4 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void sub_1002D3454(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1002D3470(__int32 **a1, __int32 **a2)
{
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3)
  {
LABEL_8:
    unint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    unint64_t v5 = a2[1];
    while (1)
    {
      uint64_t v6 = wmemchr(*a2, *v2, v5 - *a2);
      int v7 = v6 ? v6 : v5;
      unint64_t v5 = a2[1];
      if (v7 == v5) {
        break;
      }
      v2 += 2;
      if (v2 == v3) {
        goto LABEL_8;
      }
    }
    uint64_t v9 = *v2;
    unint64_t v8 = &_mh_execute_header;
  }
  return v9 | (unint64_t)v8;
}

uint64_t sub_1002D34F4(uint64_t *a1, __int32 **a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = a2[1];
  do
  {
    int v7 = wmemchr(*a2, *(_DWORD *)v2, v6 - *a2);
    if (v7) {
      unint64_t v8 = v7;
    }
    else {
      unint64_t v8 = v6;
    }
    uint64_t v6 = a2[1];
    if (v8 == v6) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = *(unsigned int *)(v2 + 4);
    }
    v5 += v9;
    v2 += 8;
  }
  while (v2 != v3);
  return v5;
}

void sub_1002D3580(int **a1@<X0>, int **a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  long double v14 = 0;
  double v15 = 0;
  uint64_t v16 = 0;
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  uint64_t v5 = *a1;
  if (((char *)a2[1] - (char *)*a2) >> 3 >= (unint64_t)(((char *)a1[1] - (char *)*a1) >> 3)) {
    unint64_t v6 = ((char *)a1[1] - (char *)*a1) >> 3;
  }
  else {
    unint64_t v6 = ((char *)a2[1] - (char *)*a2) >> 3;
  }
  if (v6 >= a3) {
    unint64_t v6 = a3;
  }
  v18[0] = (uint64_t *)&v14;
  if (v6)
  {
    uint64_t v8 = 8 * v6;
    uint64_t v9 = 8 * v6;
    do
    {
      int v17 = *v5;
      sub_10027DE2C((uint64_t *)v18, &v17);
      v5 += 2;
      v9 -= 8;
    }
    while (v9);
    int v10 = *a2;
    v18[0] = (uint64_t *)&__p;
    do
    {
      int v17 = *v10;
      sub_10027DE2C((uint64_t *)v18, &v17);
      v10 += 2;
      v8 -= 8;
    }
    while (v8);
  }
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
  sub_1002D3748((uint64_t *)v14, v15, (uint64_t *)__p, v12, (uint64_t)a4, v18);
  if (__p)
  {
    uint64_t v12 = (uint64_t *)__p;
    operator delete(__p);
  }
  if (v14)
  {
    double v15 = (uint64_t *)v14;
    operator delete(v14);
  }
}

void sub_1002D36B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  double v15 = *(void **)v13;
  if (*(void *)v13)
  {
    *(void *)(v13 + 8) = v15;
    operator delete(v15);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1002D3700(uint64_t a1, __int32 **a2)
{
  uint64_t v3 = sub_1002D34F4((uint64_t *)a1, a2);
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4) {
    return COERCE_UNSIGNED_INT((float)(unint64_t)v3 / (float)v4) | (unint64_t)&_mh_execute_header;
  }
  else {
    return 0;
  }
}

uint64_t *sub_1002D3748@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t **a6@<X8>)
{
  uint64_t v11 = a5;
  if (result != a2)
  {
    uint64_t v9 = a3;
    if (a3 != a4)
    {
      int v10 = result;
      do
      {
        if (*(_DWORD *)v10 >= *(_DWORD *)v9)
        {
          if (*(_DWORD *)v9 >= *(_DWORD *)v10)
          {
            uint64_t result = sub_10027DE2C(&v11, v10);
            int v10 = (uint64_t *)((char *)v10 + 4);
          }
          uint64_t v9 = (uint64_t *)((char *)v9 + 4);
        }
        else
        {
          int v10 = (uint64_t *)((char *)v10 + 4);
        }
      }
      while (v10 != a2 && v9 != a4);
      a5 = v11;
    }
  }
  *a6 = a2;
  a6[1] = a4;
  a6[2] = (uint64_t *)a5;
  return result;
}

BOOL sub_1002D37F4(void *a1, void *a2)
{
  return *a1 != *a2 || a1[1] != a2[1];
}

uint64_t sub_1002D3820(void *a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a1 + 24))(*a1, a1[1]);
}

uint64_t sub_1002D384C(uint64_t result)
{
  return result;
}

void *sub_1002D385C(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

uint64_t sub_1002D386C(void *a1, unint64_t a2)
{
  if ((*(uint64_t (**)(void))(*(void *)*a1 + 16))(*a1) <= a2) {
    sub_101A592C4();
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)*a1 + 24);

  return v3();
}

uint64_t sub_1002D3900(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 16))();
}

BOOL sub_1002D3928(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 16))(*a1) == 0;
}

uint64_t sub_1002D396C(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1002D3978(void *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  return v1;
}

void sub_1002D39C8(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002D3A30@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (sub_100278D98(a1))
  {
    if (*(unsigned char *)(a3 + 32))
    {
      *(void *)a5 = 0;
      *(void *)(a5 + ++*(void *)(result + 8) = 0;
      *(void *)(a5 + 16) = 0;
      *(_DWORD *)(a5 + 24) = 3;
      *(unsigned char *)(a5 + 80) = 0;
      *(void *)(a5 + 40) = 0;
      *(void *)(a5 + 4++*(void *)(result + 8) = 0;
      *(void *)(a5 + 32) = 0;
      *(unsigned char *)(a5 + 56) = 0;
      v22[0] = 0;
      v22[1] = 0;
      double v21 = v22;
      uint64_t v11 = *(void **)(a1 + 232);
      int v10 = *(void **)(a1 + 240);
      while (v11 != v10)
      {
        uint64_t v12 = *(void *)(a3 + 24);
        if (!v12) {
          sub_10015E48C();
        }
        uint64_t v23 = (*(double (**)(uint64_t, void, uint64_t))(*(void *)v12 + 48))(v12, *v11, a2);
        sub_10007EF64(&v21, (double *)&v23);
        v11 += 4;
      }
      double v13 = sub_1001E1C8C(a4);
      double v14 = sub_1001E1CB8(a4);
      sub_1000C7F88(&v23);
      LODWORD(v20[0]) = 0;
      CFStringRef v15 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNullSpaceDistanceReductionFunction", 0x8000100u, kCFAllocatorNull);
      int v16 = sub_1004D08E4(v23, (uint64_t)v15, v20);
      CFRelease(v15);
      unsigned int v17 = v20[0];
      if (v24) {
        sub_1000DB0A0(v24);
      }
      if (v16) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 5;
      }
      ((void (*)(uint64_t *__return_ptr, uint64_t, void, double, double))loc_1002D3F78)(&v23, v18, 0, v13, v14);
      sub_1001E1CE8(a4, v20);
      sub_100217CDC((uint64_t)v20);
    }
    uint64_t result = sub_101A59498();
  }
  else
  {
    uint64_t result = sub_101A59608();
  }
  __break(1u);
  return result;
}

void sub_1002D3EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void *);
  uint64_t v12 = va_arg(va1, void);
  if (a7) {
    (*(void (**)(uint64_t))(*(void *)a7 + 8))(a7);
  }
  sub_1002D4768((uint64_t *)va1);
  sub_1000F5BB0((uint64_t)va, v11);
  sub_1001E058C(v7);
  _Unwind_Resume(a1);
}

void sub_1002D4180(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

double sub_1002D41B0(void *a1)
{
  if (!a1[2]) {
    sub_101A59DA4();
  }
  return *(double *)(*a1 + 32);
}

double sub_1002D41D8(void *a1)
{
  if (!a1[2]) {
    sub_101A59DD0();
  }
  uint64_t v3 = (double *)*a1;
  uint64_t v1 = (double *)(a1 + 1);
  uint64_t v2 = v3;
  if (v3 != v1)
  {
    unsigned int v4 = v2;
    while (1)
    {
      uint64_t v5 = (double *)*((void *)v4 + 1);
      unint64_t v6 = v4;
      if (v5)
      {
        do
        {
          unsigned int v4 = v5;
          uint64_t v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unsigned int v4 = (double *)*((void *)v6 + 2);
          BOOL v7 = *(void *)v4 == (void)v6;
          unint64_t v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1) {
        break;
      }
      if (v4[4] < v2[4]) {
        uint64_t v2 = v4;
      }
    }
  }
  return v2[4];
}

double sub_1002D4258(void *a1)
{
  unint64_t v1 = a1[2];
  if (!v1) {
    sub_101A59DFC();
  }
  unsigned int v4 = (void *)*a1;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v4;
  double v5 = 0.0;
  if (v4 != v2)
  {
    do
    {
      unint64_t v6 = (void *)v3[1];
      BOOL v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v8 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v7[2];
          BOOL v9 = *v8 == (void)v7;
          BOOL v7 = v8;
        }
        while (!v9);
      }
      double v5 = v5 + *((double *)v3 + 4);
      uint64_t v3 = v8;
    }
    while (v8 != v2);
  }
  return v5 / (double)v1;
}

double sub_1002D42D4(uint64_t a1)
{
  if (!*(void *)(a1 + 16)) {
    sub_101A59E28();
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  uint64_t v2 = v3;
  if (v3)
  {
    do
    {
      uint64_t v4 = v2;
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2);
  }
  else
  {
    do
    {
      uint64_t v4 = *(void *)(v1 + 16);
      BOOL v5 = *(void *)v4 == v1;
      uint64_t v1 = v4;
    }
    while (v5);
  }
  return *(double *)(v4 + 32);
}

double sub_1002D4324(void *a1)
{
  if (!a1[2]) {
    sub_101A59E54();
  }
  uint64_t v3 = (double *)*a1;
  uint64_t v1 = (double *)(a1 + 1);
  uint64_t v2 = v3;
  if (v3 != v1)
  {
    uint64_t v4 = v2;
    while (1)
    {
      BOOL v5 = (double *)*((void *)v4 + 1);
      unint64_t v6 = v4;
      if (v5)
      {
        do
        {
          uint64_t v4 = v5;
          BOOL v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v4 = (double *)*((void *)v6 + 2);
          BOOL v7 = *(void *)v4 == (void)v6;
          unint64_t v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1) {
        break;
      }
      if (v2[4] < v4[4]) {
        uint64_t v2 = v4;
      }
    }
  }
  return v2[4];
}

double sub_1002D43A4(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    sub_101A59E80();
  }
  uint64_t v3 = *(double **)a1;
  sub_1002D4510((void **)&v3, llround((double)v1 * 0.25));
  return v3[4];
}

double sub_1002D43F4(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    sub_101A59EAC();
  }
  uint64_t v3 = *(double **)a1;
  sub_1002D4510((void **)&v3, llround((double)v1 * 0.5));
  return v3[4];
}

void *sub_1002D4444(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1022A4CD0;
  result[1] = v3;
  return result;
}

uint64_t sub_1002D448C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1022A4CD0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1002D44B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_1002D44C4(uint64_t a1, uint64_t a2)
{
  if (sub_1000E9B14(a2, (uint64_t)&off_1022A4D50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002D4504()
{
  return &off_1022A4D50;
}

void **sub_1002D4510(void **result, uint64_t a2)
{
  if (a2 < 0)
  {
    BOOL v7 = *result;
    do
    {
      uint64_t v8 = (void *)*v7;
      if (*v7)
      {
        do
        {
          uint64_t v4 = v8;
          uint64_t v8 = (void *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v7[2];
          BOOL v5 = *v4 == (void)v7;
          BOOL v7 = v4;
        }
        while (v5);
      }
      BOOL v7 = v4;
    }
    while (!__CFADD__(a2++, 1));
  }
  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = *result;
    do
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (a2-- > 1);
  }
  *uint64_t result = v4;
  return result;
}

__n128 sub_1002D459C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1022A4D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++*(void *)(result + 8) = result;
  return result;
}

__n128 sub_1002D45E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1022A4D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + ++*(void *)(result + 8) = result;
  return result;
}

double sub_1002D4618(uint64_t a1, uint64_t a2)
{
  return sub_1002D4670(a2, *(double *)(a1 + 8), *(double *)(a1 + 16));
}

uint64_t sub_1002D4624(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002D4664()
{
}

double sub_1002D4670(uint64_t a1, double a2, double a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    sub_101A59ED8();
  }
  if (a3 > 1.0 || (a2 >= 0.0 ? (BOOL v4 = a2 > 1.0) : (BOOL v4 = 1), !v4 ? (v5 = a3 < a2) : (v5 = 1), v5)) {
    sub_101A59F04();
  }
  uint64_t v6 = llround(floor((double)v3 * a2));
  int64_t v7 = llround(ceil((double)v3 * a3));
  uint64_t v8 = v7 - v6;
  if (v7 <= v6) {
    sub_101A59F30();
  }
  int v16 = *(double **)a1;
  sub_1002D4510((void **)&v16, v6);
  BOOL v9 = v16;
  sub_1002D4510((void **)&v16, v8);
  double v10 = 0.0;
  if (v9 != v16)
  {
    do
    {
      uint64_t v11 = (double *)*((void *)v9 + 1);
      uint64_t v12 = v9;
      if (v11)
      {
        do
        {
          double v13 = v11;
          uint64_t v11 = *(double **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          double v13 = (double *)*((void *)v12 + 2);
          BOOL v14 = *(void *)v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      double v10 = v10 + v9[4];
      BOOL v9 = v13;
    }
    while (v13 != v16);
  }
  return v10 / (double)v8;
}

void *sub_1002D4768(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1002D47EC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + ++*(void *)(result + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_1002D4844((char *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1002D482C(_Unwind_Exception *a1)
{
  sub_1000F5BB0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_1002D4844(char *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    BOOL v4 = a2;
    BOOL v5 = (uint64_t **)result;
    uint64_t v6 = (double *)(result + 8);
    do
    {
      __n128 result = (char *)sub_1002D48CC(v5, v6, v4 + 4);
      int64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          BOOL v4 = v8;
        }
        while (!v9);
      }
      BOOL v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

void *sub_1002D48CC(uint64_t **a1, double *a2, void *a3)
{
  uint64_t v6 = operator new(0x28uLL);
  *((void *)v6 + 4) = *a3;
  int64_t v7 = sub_10027CE20(a1, a2, &v9, (double *)v6 + 4);
  sub_1000EDF90(a1, (uint64_t)v9, (uint64_t **)v7, (uint64_t *)v6);
  return v6;
}

void sub_1002D4944(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1002D4958(__n128 *a1, __n128 *a2, unint64_t a3, unint64_t a4)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a3;
  a1[1].n128_u64[1] = a4;
  return result;
}

uint64_t sub_1002D4A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, long long *a8, uint64_t a9)
{
  *(void *)a1 = a2;
  *(void *)(a1 + ++*(void *)(result + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  if (*((char *)a7 + 23) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 40), *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v11 = *a7;
    *(void *)(a1 + 56) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 40) = v11;
  }
  uint64_t v12 = (unsigned char *)(a1 + 64);
  if (*((char *)a8 + 23) < 0)
  {
    sub_1000DC48C(v12, *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v13 = *a8;
    *(void *)(a1 + 80) = *((void *)a8 + 2);
    *(_OWORD *)uint64_t v12 = v13;
  }
  *(unsigned char *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 36++*(void *)(result + 8) = 0;
  *(unsigned char *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(unsigned char *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40++*(void *)(result + 8) = 0u;
  *(void *)(a1 + 44++*(void *)(result + 8) = a9;
  *(_WORD *)(a1 + 456) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 8++*(void *)(result + 8) = 1;
  return a1;
}

void sub_1002D4AF0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1002D4B0C(unint64_t result)
{
  if (HIDWORD(result)) {
    sub_101A5A0DC();
  }
  return result;
}

uint64_t sub_1002D4B28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v10 = *(void *)a3;
  unint64_t v11 = *(void *)(a3 + 56);
  sub_1002D4B0C(v11);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_1000DC48C(__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a3 + 32);
    uint64_t v16 = *(void *)(a3 + 48);
  }
  if (*(char *)(a3 + 87) < 0)
  {
    sub_1000DC48C(__p, *(void **)(a3 + 64), *(void *)(a3 + 72));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a3 + 64);
    uint64_t v14 = *(void *)(a3 + 80);
  }
  sub_1002D4A18(a1, a2, v9, v8, v10, v11, (long long *)__dst, (long long *)__p, a4);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  return a1;
}

void sub_1002D4C2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002D4C60(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1002D4C6C(uint64_t a1)
{
  return a1 + 40;
}

uint64_t sub_1002D4C74(uint64_t a1)
{
  return a1 + 64;
}

void *sub_1002D4C7C@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (result == (void *)1) {
    return sub_100134750(a3, "kMiLoClientIdentifierUnsupervisedShared");
  }
  if (*(char *)(a2 + 23) < 0) {
    return sub_1000DC48C(a3, *(void **)a2, *(void *)(a2 + 8));
  }
  *(_OWORD *)a3 = *(_OWORD *)a2;
  a3[2] = *(void *)(a2 + 16);
  return result;
}

void *sub_1002D4CC0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1002D4C7C(*(void **)(a1 + 24), a1 + 40, a2);
}

uint64_t sub_1002D4CD0(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_1002D4CD8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x20) {
    sub_10000EDDC("bitset test argument out of range");
  }
  return (*(void *)(a1 + 32) >> a2) & 1;
}

uint64_t sub_1002D4D0C(uint64_t result, unint64_t a2)
{
  if (a2 >= 0x20) {
    sub_10000EDDC("bitset set argument out of range");
  }
  *(void *)(result + 32) |= 1 << a2;
  return result;
}

void sub_1002D4D48(char *a1, _OWORD *a2)
{
  if (a1[296])
  {
    BOOL v4 = a1 + 40;
    int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 88))();
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      int64_t v7 = operator new(0x28uLL);
      std::string __p = v7;
      long long v21 = xmmword_101D048C0;
      *int64_t v7 = 0u;
      v7[1] = 0u;
      *(void *)((char *)v7 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 8), v7);
      if (v21 >= 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = (char *)__p;
      }
      if (a1[63] < 0) {
        BOOL v4 = (void *)*v4;
      }
      if (!a1[296]) {
        sub_10020D700();
      }
      uint64_t v9 = (char *)operator new(0x28uLL);
      *(void *)(v9 + 29) = 0;
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      sub_1001E0650((uint64_t)(a1 + 280), v9);
      uint64_t v10 = (char *)operator new(0x28uLL);
      *(void *)(v10 + 29) = 0;
      *(_OWORD *)uint64_t v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      sub_1001E0650((uint64_t)a2, v10);
      *(_DWORD *)uint64_t buf = 68290306;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      int v24 = p_p;
      __int16 v25 = 2082;
      double v26 = v4;
      __int16 v27 = 2082;
      uint64_t v28 = v9;
      __int16 v29 = 2082;
      uint64_t v30 = v10;
      __int16 v31 = 1026;
      int v32 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending cached results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Cached LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"Succeeded to save trigger\":%{public}hhd}", buf, 0x40u);
      operator delete(v10);
      operator delete(v9);
      if (SHIBYTE(v21) < 0) {
        operator delete(__p);
      }
    }
    uint64_t v11 = *(void *)a1;
    *(_OWORD *)uint64_t buf = *a2;
    uint8_t buf[16] = 1;
    if (!a1[296]) {
      sub_10020D700();
    }
    (*(void (**)(uint64_t, char *, unsigned char *, char *))(*(void *)v11 + 32))(v11, a1 + 8, buf, a1 + 112);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v12 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      long long v13 = (char *)operator new(0x28uLL);
      *(_OWORD *)long long v13 = 0u;
      *((_OWORD *)v13 + 1) = 0u;
      *(void *)(v13 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 8), v13);
      uint64_t v14 = a1 + 40;
      if (a1[63] < 0) {
        uint64_t v14 = (void *)*v14;
      }
      CFStringRef v15 = (char *)operator new(0x28uLL);
      *(void *)(v15 + 29) = 0;
      *(_OWORD *)CFStringRef v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      sub_1001E0650((uint64_t)a2, v15);
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      int v24 = v13;
      __int16 v25 = 2082;
      double v26 = v14;
      __int16 v27 = 2082;
      uint64_t v28 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService tried to send cached results to client but no cache available:\", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
      operator delete(v15);
      operator delete(v13);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
    }
    uint64_t v16 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      unsigned int v17 = (char *)operator new(0x28uLL);
      *(void *)(v17 + 29) = 0;
      *(_OWORD *)unsigned int v17 = 0u;
      *((_OWORD *)v17 + 1) = 0u;
      sub_1001E0650((uint64_t)(a1 + 8), v17);
      uint64_t v18 = a1 + 40;
      if (a1[63] < 0) {
        uint64_t v18 = (void *)*v18;
      }
      double v19 = (char *)operator new(0x28uLL);
      *(void *)(v19 + 29) = 0;
      *(_OWORD *)double v19 = 0u;
      *((_OWORD *)v19 + 1) = 0u;
      sub_1001E0650((uint64_t)a2, v19);
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      int v24 = v17;
      __int16 v25 = 2082;
      double v26 = v18;
      __int16 v27 = 2082;
      uint64_t v28 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService tried to send cached results to client but no cache available:", "{\"msg%{public}.0s\":\"CLMiLoService tried to send cached results to client but no cache available:\", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
      operator delete(v19);
      operator delete(v17);
    }
  }
}

void sub_1002D51F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  operator delete(v15);
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_1002D5280(int64x2_t *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5)
{
  *(void *)&long long v70 = a4;
  *((void *)&v70 + 1) = a5;
  if (!a1[5].i64[1])
  {
    uint64_t v7 = a3;
    if (a3 && (!a1[28].i8[9] || !a1[28].i8[8] || (sub_1002D5C98() & 1) == 0))
    {
      sub_1002A4F7C((uint64_t)v49, a2);
      long long v8 = v70;
      sub_1002A4F7C((uint64_t)buf, (uint64_t)v49);
      long long v69 = v8;
      sub_1002D5D48((uint64_t)a1[7].i64, (uint64_t)buf);
      if (__p)
      {
        char v68 = __p;
        operator delete(__p);
      }
      if (v66[40]) {
        sub_1002220F0((uint64_t)v66);
      }
      if (v65 && v64 < 0) {
        operator delete(v63);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (v53)
      {
        long long v54 = v53;
        operator delete(v53);
      }
      if (v52[40]) {
        sub_1002220F0((uint64_t)v52);
      }
      if (v51 && v50 < 0) {
        operator delete(v49[7]);
      }
      if (v49[0])
      {
        v49[1] = v49[0];
        operator delete(v49[0]);
      }
    }
    uint64_t i64 = (uint64_t)a1[22].i64;
    if (a1[23].i8[0] && (a1[22].i64[0] == (void)v70 ? (BOOL v9 = a1[22].i64[1] == *((void *)&v70 + 1)) : (BOOL v9 = 0), v9))
    {
      a1[23].i8[0] = 0;
      if (v7)
      {
        if (a1[21].i64[1])
        {
          uint64_t v27 = (uint64_t)a1[19].i64;
          uint64_t v28 = &qword_102419000;
          __int16 v29 = &qword_102419000;
          do
          {
            long long v55 = *(_OWORD *)(*(void *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL)) + 33
                                                                                         * (a1[21].i64[0] % 0x7CuLL));
            if (v28[138] != -1) {
              dispatch_once(&qword_102419450, &stru_1022A4DF0);
            }
            uint64_t v30 = v29[139];
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v31 = operator new(0x28uLL);
              uint64_t v32 = v27;
              uint64_t v33 = a2;
              uint64_t v47 = v31;
              long long v48 = xmmword_101D048C0;
              *__int16 v31 = 0u;
              v31[1] = 0u;
              *(void *)((char *)v31 + 29) = 0;
              sub_1001E0650((uint64_t)&a1->i64[1], v31);
              uint64_t v34 = v29;
              if (v48 >= 0) {
                size_t v35 = (char *)&v47;
              }
              else {
                size_t v35 = (char *)v47;
              }
              uint64_t v36 = operator new(0x28uLL);
              uint64_t v37 = v28;
              uint64_t v45 = v36;
              long long v46 = xmmword_101D048C0;
              _OWORD *v36 = 0u;
              v36[1] = 0u;
              *(void *)((char *)v36 + 29) = 0;
              sub_1001E0650((uint64_t)&v70, v36);
              if (v46 >= 0) {
                int v38 = (char *)&v45;
              }
              else {
                int v38 = (char *)v45;
              }
              uint64_t v39 = operator new(0x28uLL);
              uint64_t v43 = v39;
              long long v44 = xmmword_101D048C0;
              *uint64_t v39 = 0u;
              v39[1] = 0u;
              *(void *)((char *)v39 + 29) = 0;
              sub_1001E0650((uint64_t)&v55, v39);
              uint64_t v40 = (char *)&v43;
              if (v44 < 0) {
                uint64_t v40 = (char *)v43;
              }
              *(_DWORD *)uint64_t buf = 68289794;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v57 = 2082;
              uint64_t v58 = v35;
              __int16 v59 = 2082;
              __int16 v60 = v38;
              __int16 v61 = 2082;
              char v62 = v40;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received localization results, sending results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
              if (SHIBYTE(v44) < 0) {
                operator delete(v43);
              }
              uint64_t v28 = v37;
              if (SHIBYTE(v46) < 0) {
                operator delete(v45);
              }
              __int16 v29 = v34;
              if (SHIBYTE(v48) < 0) {
                operator delete(v47);
              }
              a2 = v33;
              uint64_t v27 = v32;
            }
            uint64_t v41 = a1->i64[0];
            *(_OWORD *)uint64_t buf = v55;
            uint8_t buf[16] = 1;
            (*(void (**)(uint64_t, uint64_t *, unsigned char *, uint64_t))(*(void *)v41 + 32))(v41, &a1->i64[1], buf, a2);
            a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_101D0A740);
            sub_1002DCCEC(v27, 1);
          }
          while (a1[21].i64[1]);
        }
      }
      else
      {
        sub_1002D5DE8(a1, 3);
      }
    }
    else if (v7 && a1[28].i8[9])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = operator new(0x28uLL);
        uint64_t v47 = v11;
        long long v48 = xmmword_101D048C0;
        _OWORD *v11 = 0u;
        v11[1] = 0u;
        *(void *)((char *)v11 + 29) = 0;
        sub_1001E0650((uint64_t)&a1->i64[1], v11);
        if (v48 >= 0) {
          uint64_t v12 = (char *)&v47;
        }
        else {
          uint64_t v12 = (char *)v47;
        }
        long long v13 = operator new(0x28uLL);
        uint64_t v45 = v13;
        long long v46 = xmmword_101D048C0;
        *long long v13 = 0u;
        v13[1] = 0u;
        *(void *)((char *)v13 + 29) = 0;
        sub_1001E0650((uint64_t)&v70, v13);
        uint64_t v14 = (char *)&v45;
        if (v46 < 0) {
          uint64_t v14 = (char *)v45;
        }
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        uint64_t v58 = v12;
        __int16 v59 = 2082;
        __int16 v60 = v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received localization results, reporting to client with service updating params\", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v46) < 0) {
          operator delete(v45);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47);
        }
      }
      uint64_t v15 = a1->i64[0];
      *(_OWORD *)uint64_t buf = v70;
      uint8_t buf[16] = 1;
      (*(void (**)(uint64_t, uint64_t *, unsigned char *, uint64_t))(*(void *)v15 + 32))(v15, &a1->i64[1], buf, a2);
    }
    if (a1[23].i8[0])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v16 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        unsigned int v17 = operator new(0x28uLL);
        uint64_t v47 = v17;
        long long v48 = xmmword_101D048C0;
        _OWORD *v17 = 0u;
        v17[1] = 0u;
        *(void *)((char *)v17 + 29) = 0;
        sub_1001E0650((uint64_t)&a1->i64[1], v17);
        if (v48 >= 0) {
          uint64_t v18 = (char *)&v47;
        }
        else {
          uint64_t v18 = (char *)v47;
        }
        if (!a1[23].i8[0]) {
          sub_10020D700();
        }
        double v19 = operator new(0x28uLL);
        uint64_t v45 = v19;
        long long v46 = xmmword_101D048C0;
        _OWORD *v19 = 0u;
        v19[1] = 0u;
        *(void *)((char *)v19 + 29) = 0;
        sub_1001E0650(i64, v19);
        if (v46 >= 0) {
          double v20 = (char *)&v45;
        }
        else {
          double v20 = (char *)v45;
        }
        long long v21 = operator new(0x28uLL);
        uint64_t v43 = v21;
        long long v44 = xmmword_101D048C0;
        _OWORD *v21 = 0u;
        v21[1] = 0u;
        *(void *)((char *)v21 + 29) = 0;
        sub_1001E0650((uint64_t)&v70, v21);
        uint64_t v22 = (char *)&v43;
        if (v44 < 0) {
          uint64_t v22 = (char *)v43;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        uint64_t v58 = v18;
        __int16 v59 = 2082;
        __int16 v60 = v20;
        __int16 v61 = 2082;
        char v62 = v22;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService received localization results with unexpected / unmatching ID\", \"ServiceId\":%{public, location:escape_only}s, \"Expected localization ID\":%{public, location:escape_only}s, \"Received trigger ID\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v44) < 0) {
          operator delete(v43);
        }
        if (SHIBYTE(v46) < 0) {
          operator delete(v45);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47);
        }
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
      }
      __int16 v23 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v24 = (char *)operator new(0x28uLL);
        *(void *)(v24 + 29) = 0;
        *(_OWORD *)int v24 = 0u;
        *((_OWORD *)v24 + 1) = 0u;
        sub_1001E0650((uint64_t)&a1->i64[1], v24);
        if (!a1[23].i8[0]) {
          sub_10020D700();
        }
        __int16 v25 = (char *)operator new(0x28uLL);
        *(void *)(v25 + 29) = 0;
        *(_OWORD *)__int16 v25 = 0u;
        *((_OWORD *)v25 + 1) = 0u;
        sub_1001E0650(i64, v25);
        double v26 = (char *)operator new(0x28uLL);
        *(void *)(v26 + 29) = 0;
        *(_OWORD *)double v26 = 0u;
        *((_OWORD *)v26 + 1) = 0u;
        sub_1001E0650((uint64_t)&v70, v26);
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        uint64_t v58 = v24;
        __int16 v59 = 2082;
        __int16 v60 = v25;
        __int16 v61 = 2082;
        char v62 = v26;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService received localization results with unexpected / unmatching ID", "{\"msg%{public}.0s\":\"CLMiLoService received localization results with unexpected / unmatching ID\", \"ServiceId\":%{public, location:escape_only}s, \"Expected localization ID\":%{public, location:escape_only}s, \"Received trigger ID\":%{public, location:escape_only}s}", buf, 0x30u);
        operator delete(v26);
        operator delete(v25);
        operator delete(v24);
      }
      if (a1[23].i8[0]) {
        a1[23].i8[0] = 0;
      }
      sub_1002D5DE8(a1, 3);
    }
    sub_1002D62AC(a1->i64);
  }
}

void sub_1002D5B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  operator delete(v55);
  if (a31 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002D5C98()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsForcePredictionForLowLatencyServiceEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1002D5D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002D5D48(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 184))
  {
    sub_1000F4EBC(a1, (__n128 *)a2);
    long long v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v4;
    sub_1002DCC4C(a1 + 56, (__n128 *)(a2 + 56));
    sub_10022257C(a1 + 88, a2 + 88);
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
    sub_1000F4EBC(a1 + 144, (__n128 *)(a2 + 144));
    *(_OWORD *)(a1 + 16++*(void *)(result + 8) = *(_OWORD *)(a2 + 168);
  }
  else
  {
    sub_1002CEBF8(a1, a2);
    *(unsigned char *)(a1 + 184) = 1;
  }
  return a1;
}

void sub_1002D5DE8(int64x2_t *a1, int a2)
{
  uint64_t v4 = 29;
  if (!a2) {
    uint64_t v4 = -1;
  }
  uint64_t v19 = v4;
  if (a1[21].i64[1])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)std::string __p = v6;
      *(_OWORD *)&__p[8] = xmmword_101D048C0;
      *(_OWORD *)uint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *(void *)(v6 + 29) = 0;
      sub_1001E0650((uint64_t)&a1->i64[1], v6);
      uint64_t v7 = __p;
      if (__p[23] < 0) {
        uint64_t v7 = *(unsigned char **)__p;
      }
      BOOL v8 = a1[21].i64[1] != 0;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v34 = 2082;
      *(void *)&v34[2] = "";
      __int16 v35 = 2082;
      uint64_t v36 = v7;
      __int16 v37 = 1026;
      BOOL v38 = v8;
      __int16 v39 = 1026;
      BOOL v40 = a2 == 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService releasing prediction requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x28u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
  }
  if ((sub_1002758F8(a2) & 0xFF00000000) != 0)
  {
    unint64_t v9 = sub_1002758F8(a2);
    int v10 = v9;
    if ((v9 & 0xFF00000000) == 0) {
      sub_10020D700();
    }
    uint64_t v11 = operator new(4uLL);
    _DWORD *v11 = v10;
    uint64_t v12 = (uint64_t)(v11 + 1);
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  while (a1[21].i64[1])
  {
    unint64_t v13 = a1[21].u64[0];
    uint64_t v14 = *(void *)(a1[19].i64[1] + 8 * (v13 / 0x7C));
    unint64_t v15 = v13 % 0x7C;
    if (!a2)
    {
      uint64_t v16 = v14 + 33 * v15;
      if (*(unsigned char *)(v16 + 32))
      {
        sub_1002D92C0(a1->i64, (void *)v16, (_OWORD *)(v16 + 16));
        unint64_t v17 = a1[21].u64[0];
        uint64_t v14 = *(void *)(a1[19].i64[1] + 8 * (v17 / 0x7C));
        unint64_t v15 = v17 % 0x7C;
      }
    }
    (*(void (**)(uint64_t, uint64_t *, unint64_t, uint64_t))(*(void *)a1->i64[0] + 40))(a1->i64[0], &a1->i64[1], v14 + 33 * v15, v19);
    __int16 v29 = 0;
    uint64_t v30 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    long long v26 = 0uLL;
    LOBYTE(v23) = 0;
    char v25 = 0;
    __p[0] = 0;
    char v32 = 0;
    long long v21 = 0;
    uint64_t v22 = 0;
    double v20 = 0;
    sub_10010F834(&v20, v11, v12, (v12 - (uint64_t)v11) >> 2);
    sub_1002226D4((uint64_t)buf, (uint64_t)&v28, &v26, 0, &v23, (uint64_t)__p, 0, (uint64_t)&v20);
    if (v20)
    {
      long long v21 = v20;
      operator delete(v20);
    }
    if (v32) {
      sub_1002220F0((uint64_t)__p);
    }
    if (v25 && v24 < 0) {
      operator delete((void *)v23);
    }
    if (v28)
    {
      __int16 v29 = v28;
      operator delete(v28);
    }
    uint64_t v18 = a1->i64[0];
    *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL))
                               + 33 * (a1[21].i64[0] % 0x7CuLL));
    __p[16] = 1;
    (*(void (**)(uint64_t, uint64_t *, unsigned char *, uint8_t *))(*(void *)v18 + 32))(v18, &a1->i64[1], __p, buf);
    a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_101D0A740);
    sub_1002DCCEC((uint64_t)a1[19].i64, 1);
    if (v45)
    {
      long long v46 = v45;
      operator delete(v45);
    }
    if (v44[40]) {
      sub_1002220F0((uint64_t)v44);
    }
    if (v43 && v42 < 0) {
      operator delete(v41);
    }
    if (*(void *)buf)
    {
      *(void *)uint64_t v34 = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
  if (v11) {
    operator delete(v11);
  }
}

void sub_1002D622C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,int a34,__int16 a35,char a36,char a37)
{
  operator delete(v37);
  _Unwind_Resume(a1);
}

void sub_1002D62AC(uint64_t *a1)
{
  unint64_t v1 = a1[3];
  if (v1 >= 4)
  {
    if (v1 == 4)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = (char *)operator new(0x28uLL);
        *(_OWORD *)uint64_t v7 = 0u;
        *((_OWORD *)v7 + 1) = 0u;
        *(void *)(v7 + 29) = 0;
        sub_1001E0650((uint64_t)(a1 + 1), v7);
        int v8 = 68289283;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        __int16 v12 = 2081;
        unint64_t v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applying model with recent changes\", \"ServiceUUID\":%{private, location:escape_only}s}", (uint8_t *)&v8, 0x1Cu);
        operator delete(v7);
      }
      sub_1002D75B8(a1);
    }
    else if (v1 == 5)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      unint64_t v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax\"}", (uint8_t *)&v8, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
      }
      uint64_t v4 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax", "{\"msg%{public}.0s\":\"applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax\"}", (uint8_t *)&v8, 0x12u);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    BOOL v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2050;
      unint64_t v13 = (char *)v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"applying model with recent changes is not applicable\", \"Service Type\":%{public}lu}", (uint8_t *)&v8, 0x1Cu);
    }
  }
}

void sub_1002D65A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002D65BC(uint64_t a1)
{
}

void sub_1002D65C4(uint64_t *a1, int a2)
{
  if (!a1[11] && *((unsigned char *)a1 + 457))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = operator new(0x28uLL);
      std::string __p = v5;
      long long v22 = xmmword_101D048C0;
      *uint64_t v5 = 0u;
      v5[1] = 0u;
      *(void *)((char *)v5 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 1), v5);
      p_p = __p;
      if (v22 >= 0) {
        p_p = &__p;
      }
      uint64_t v7 = a1 + 5;
      if (*((char *)a1 + 63) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)char v25 = 2082;
      *(void *)&void v25[2] = "";
      __int16 v26 = 2082;
      uint64_t v27 = p_p;
      __int16 v28 = 2082;
      __int16 v29 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending invalid confidence empty results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(v22) < 0) {
        operator delete(__p);
      }
    }
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    long long v16 = 0uLL;
    LOBYTE(v13) = 0;
    char v15 = 0;
    LOBYTE(__p) = 0;
    char v23 = 0;
    int v8 = operator new(4uLL);
    __int16 v10 = v8;
    *int v8 = a2;
    uint64_t v11 = v8 + 1;
    __int16 v12 = v8 + 1;
    sub_1002226D4((uint64_t)buf, (uint64_t)&v18, &v16, 0, &v13, (uint64_t)&__p, 0, (uint64_t)&v10);
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }
    if (v23) {
      sub_1002220F0((uint64_t)&__p);
    }
    if (v15 && v14 < 0) {
      operator delete((void *)v13);
    }
    if (v18)
    {
      uint64_t v19 = v18;
      operator delete(v18);
    }
    uint64_t v9 = *a1;
    std::string __p = 0;
    *(void *)&long long v22 = 0;
    BYTE8(v22) = 1;
    (*(void (**)(uint64_t, uint64_t *, void **, uint8_t *))(*(void *)v9 + 32))(v9, a1 + 1, &__p, buf);
    if (v34)
    {
      __int16 v35 = v34;
      operator delete(v34);
    }
    if (v33[40]) {
      sub_1002220F0((uint64_t)v33);
    }
    if (v32 && v31 < 0) {
      operator delete(v30);
    }
    if (*(void *)buf)
    {
      *(void *)char v25 = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
}

void sub_1002D6870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  operator delete(v29);
  _Unwind_Resume(a1);
}

void sub_1002D689C(uint64_t *a1)
{
  if (!a1[11])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    BOOL v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v3 = (char *)operator new(0x28uLL);
      *(_OWORD *)unint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *(void *)(v3 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 1), v3);
      uint64_t v4 = a1 + 5;
      if (*((char *)a1 + 63) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      uint64_t buf = (void *)68289538;
      *(_WORD *)char v23 = 2082;
      *(void *)&void v23[2] = "";
      __int16 v24 = 2082;
      char v25 = v3;
      __int16 v26 = 2082;
      uint64_t v27 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending initial empty prediction to BlueAtlas client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
      operator delete(v3);
    }
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    long long v16 = 0;
    long long v14 = 0uLL;
    LOBYTE(v11) = 0;
    char v13 = 0;
    LOBYTE(v19[0]) = 0;
    char v21 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    std::string __p = 0;
    sub_1002226D4((uint64_t)&buf, (uint64_t)&v16, &v14, 0, &v11, (uint64_t)v19, 1, (uint64_t)&__p);
    if (__p)
    {
      uint64_t v9 = __p;
      operator delete(__p);
    }
    if (v21) {
      sub_1002220F0((uint64_t)v19);
    }
    if (v13 && v12 < 0) {
      operator delete((void *)v11);
    }
    if (v16)
    {
      uint64_t v17 = v16;
      operator delete(v16);
    }
    uint64_t v5 = *a1;
    int v7 = 0;
    sub_1001EE1F4(&v7);
    v19[0] = sub_1001EC8C4((ssize_t)&v7);
    v19[1] = v6;
    char v20 = 1;
    (*(void (**)(uint64_t, uint64_t *, void *, void **))(*(void *)v5 + 32))(v5, a1 + 1, v19, &buf);
    sub_1001EF3E8((unsigned int *)&v7);
    if (v32)
    {
      uint64_t v33 = v32;
      operator delete(v32);
    }
    if (v31[40]) {
      sub_1002220F0((uint64_t)v31);
    }
    if (v30 && v29 < 0) {
      operator delete(v28);
    }
    if (buf)
    {
      *(void *)char v23 = buf;
      operator delete(buf);
    }
  }
}

void sub_1002D6B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_1002D6B54@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 104);
  *a2 = *(void *)(result + 96);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1002D6B70(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void sub_1002D6B80(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    sub_101A5A268(qword_102419450 == -1);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0;
    sub_1001E0650(a1 + 8, v5);
    uint64_t v6 = *a2;
    int v7 = (char *)operator new(0x28uLL);
    *(void *)(v7 + 29) = 0;
    *(_OWORD *)int v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    sub_1001E0650(v6 + 352, v7);
    v11[0] = 68289538;
    v11[1] = 0;
    __int16 v12 = 2082;
    char v13 = "";
    __int16 v14 = 2082;
    uint64_t v15 = v5;
    __int16 v16 = 2082;
    uint64_t v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Model updated: \", \"ServiceId\":%{public, location:escape_only}s, \"ModelId\":%{public, location:escape_only}s}", (uint8_t *)v11, 0x26u);
    operator delete(v7);
    operator delete(v5);
  }
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v9;
  *(void *)(a1 + 104) = v8;
  if (v10) {
    sub_1000DB0A0(v10);
  }
  sub_1002D62AC((uint64_t *)a1);
  sub_1002D6D78((void *)a1);
  sub_1002D7264(a1);
  if (*(unsigned char *)(a1 + 457)) {
    sub_1002D730C((void *)a1, *(unsigned __int8 *)(a1 + 456));
  }
}

void sub_1002D6D48(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002D6D78(void *result)
{
  uint64_t v1 = result[12];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = v1 + 352;
    (*(void (**)(void *__return_ptr))(*(void *)*result + 120))(v17);
    if (v20)
    {
      if ((v19 & 0x10) == 0)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        uint64_t v4 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "ClusterAnchorValueStatistics has no data", buf, 2u);
        }
        if (!sub_10013D1A0(115, 0)) {
          return (void *)sub_100288C48((uint64_t)v17);
        }
        bzero(buf, 0x65CuLL);
        if (qword_102419450 == -1) {
          goto LABEL_24;
        }
LABEL_33:
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
LABEL_24:
        uint64_t v10 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMiLoService::loadAnchorValueStatistics()", "%s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
        return (void *)sub_100288C48((uint64_t)v17);
      }
      uint64_t v8 = v18;
      if (!v18) {
        uint64_t v8 = *(void *)(qword_102489B20 + 32);
      }
      if ((*(unsigned char *)(v8 + 32) & 2) == 0)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        uint64_t v9 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "ClusterAnchorValueStatistics has no data", buf, 2u);
        }
        if (!sub_10013D1A0(115, 0)) {
          return (void *)sub_100288C48((uint64_t)v17);
        }
        bzero(buf, 0x65CuLL);
        if (qword_102419450 == -1) {
          goto LABEL_24;
        }
        goto LABEL_33;
      }
      sub_1002D8A54(v2[12] + 496);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v5 = qword_102419458;
      if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
        return (void *)sub_100288C48((uint64_t)v17);
      }
      uint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)(v6 + 29) = 0;
      *(_OWORD *)uint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_1001E0650(v3, v6);
      *(_DWORD *)uint64_t buf = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2082;
      __int16 v16 = v6;
      int v7 = "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics loaded for model\", \"ModelUUID\":%{public, location:escape_only}s}";
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v5 = qword_102419458;
      if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
        return (void *)sub_100288C48((uint64_t)v17);
      }
      uint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)(v6 + 29) = 0;
      *(_OWORD *)uint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_1001E0650(v3, v6);
      *(_DWORD *)uint64_t buf = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2082;
      __int16 v16 = v6;
      int v7 = "{\"msg%{public}.0s\":\"no AnchorValueStatistics for model\", \"ModelUUID\":%{public, location:escape_only}s}";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, buf, 0x1Cu);
    operator delete(v6);
    return (void *)sub_100288C48((uint64_t)v17);
  }
  return result;
}

void sub_1002D721C(_Unwind_Exception *a1)
{
  sub_100288C48(v1 - 160);
  _Unwind_Resume(a1);
}

void sub_1002D7264(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1 != 2)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3 && sub_100278D98(v3) && **(unsigned char **)(a1 + 448))
    {
      *(void *)(a1 + 8++*(void *)(result + 8) = 0;
      if (v1)
      {
        sub_1002D8F84(a1, v1);
      }
    }
    else
    {
      *(void *)(a1 + 8++*(void *)(result + 8) = 1;
      if (v1 != 1)
      {
        sub_1002D90D0((int64x2_t *)a1, v1);
      }
    }
  }
}

void sub_1002D730C(void *a1, int a2)
{
  if (*((unsigned char *)a1 + 457))
  {
    if (a2 && !a1[11])
    {
      uint64_t v6 = (uint64_t)(a1 + 1);
      (*(void (**)(void, void *))(*(void *)*a1 + 128))(*a1, a1 + 1);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)uint64_t v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(void *)(v4 + 29) = 0;
        sub_1001E0650(v6, v4);
        int v7 = 68289283;
        int v8 = 0;
        __int16 v9 = 2082;
        uint64_t v10 = "";
        __int16 v11 = 2081;
        int v12 = v4;
        uint64_t v5 = "{\"msg%{public}.0s\":\"Enabling Low Latency updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}";
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v2 = (uint64_t)(a1 + 1);
      (*(void (**)(void, void *))(*(void *)*a1 + 136))(*a1, a1 + 1);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)uint64_t v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(void *)(v4 + 29) = 0;
        sub_1001E0650(v2, v4);
        int v7 = 68289283;
        int v8 = 0;
        __int16 v9 = 2082;
        uint64_t v10 = "";
        __int16 v11 = 2081;
        int v12 = v4;
        uint64_t v5 = "{\"msg%{public}.0s\":\"Enabling Legacy updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}";
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, v5, (uint8_t *)&v7, 0x1Cu);
        operator delete(v4);
      }
    }
  }
}

void sub_1002D753C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002D7554(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  if (v2) {
    sub_1000DB0A0(v2);
  }
  sub_1002D7264(a1);
  if (*(unsigned char *)(a1 + 457))
  {
    sub_1002D730C((void *)a1, 0);
  }
}

void sub_1002D75B8(uint64_t *a1)
{
  uint64_t v1 = a1[12];
  if (v1)
  {
    if (*(unsigned char *)(v1 + 192))
    {
      uint64_t v3 = 176;
      if (!*(unsigned char *)(v1 + 184)) {
        uint64_t v3 = 488;
      }
      double v4 = *(double *)(v1 + v3);
      uint64_t v5 = *a1;
      *(_OWORD *)uint64_t buf = *(_OWORD *)(a1 + 1);
      uint64_t v6 = (char *)(a1 + 5);
      (*(void (**)(uint64_t *__return_ptr, double))(*(void *)v5 + 112))(&v114, v4);
      if (v114 == v115)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        uint64_t v56 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t buf = 68289026;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no label entries for model\"}", buf, 0x12u);
        }
        goto LABEL_183;
      }
      double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
      uint64_t v8 = a1[12];
      if (!*(unsigned char *)(v8 + 184)) {
        *(unsigned char *)(v8 + 184) = 1;
      }
      *(double *)(v8 + 176) = Current_5;
      uint64_t v99 = a1[12];
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      __int16 v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = (uint64_t)(*(void *)(v99 + 104) - *(void *)(v99 + 96)) >> 4;
        *(void *)uint64_t buf = 68289282;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v118 = 2050;
        uint64_t v119 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"before update\":%{public}lu}", buf, 0x1Cu);
      }
      char v111 = 0;
      __n128 v112 = 0;
      unsigned __int8 v113 = 0;
      std::string v108 = 0;
      char v109 = 0;
      uint64_t v110 = 0;
      uint64_t v11 = v114;
      uint64_t v12 = v115;
      __int16 v13 = "ds";
      std::string v98 = a1;
      if (v114 != v115)
      {
        do
        {
          __int16 v15 = *(void **)(v99 + 96);
          __int16 v14 = *(void **)(v99 + 104);
          __int16 v16 = (void *)(v11 + 40);
          if (v15 != v14)
          {
            while (*v15 != *v16 || v15[1] != *(void *)(v11 + 48))
            {
              v15 += 2;
              if (v15 == v14)
              {
                __int16 v15 = *(void **)(v99 + 104);
                break;
              }
            }
          }
          if (v15 == v14)
          {
            __int16 v28 = v112;
            if (v112 >= v113)
            {
              uint64_t v30 = (v112 - (unsigned char *)v111) >> 4;
              unint64_t v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 60) {
                goto LABEL_185;
              }
              uint64_t v32 = v113 - (unsigned char *)v111;
              if ((v113 - (unsigned char *)v111) >> 3 > v31) {
                unint64_t v31 = v32 >> 3;
              }
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v33 = v31;
              }
              if (v33) {
                uint64_t v34 = (char *)sub_1000C571C((uint64_t)&v113, v33);
              }
              else {
                uint64_t v34 = 0;
              }
              __int16 v35 = &v34[16 * v30];
              *(_OWORD *)__int16 v35 = *(_OWORD *)v16;
              __int16 v37 = (char *)v111;
              uint64_t v36 = v112;
              BOOL v38 = v35;
              if (v112 != v111)
              {
                do
                {
                  *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
                  v38 -= 16;
                  v36 -= 16;
                }
                while (v36 != v37);
                uint64_t v36 = (char *)v111;
              }
              char v29 = v35 + 16;
              char v111 = v38;
              __n128 v112 = v35 + 16;
              unsigned __int8 v113 = &v34[16 * v33];
              if (v36) {
                operator delete(v36);
              }
            }
            else
            {
              *(_OWORD *)__n128 v112 = *(_OWORD *)v16;
              char v29 = v28 + 16;
            }
            __n128 v112 = v29;
            __int16 v39 = v109;
            if (v109 >= v110)
            {
              uint64_t v41 = (v109 - (unsigned char *)v108) >> 4;
              unint64_t v42 = v41 + 1;
              if ((unint64_t)(v41 + 1) >> 60) {
LABEL_185:
              }
                sub_1001D7FD4();
              uint64_t v43 = v110 - (unsigned char *)v108;
              if ((v110 - (unsigned char *)v108) >> 3 > v42) {
                unint64_t v42 = v43 >> 3;
              }
              if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v44 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v44 = v42;
              }
              if (v44) {
                uint64_t v45 = (char *)sub_1000C571C((uint64_t)&v110, v44);
              }
              else {
                uint64_t v45 = 0;
              }
              long long v46 = &v45[16 * v41];
              *(_OWORD *)long long v46 = *(_OWORD *)v11;
              long long v48 = (char *)v108;
              uint64_t v47 = v109;
              uint64_t v49 = v46;
              if (v109 != v108)
              {
                do
                {
                  *((_OWORD *)v49 - 1) = *((_OWORD *)v47 - 1);
                  v49 -= 16;
                  v47 -= 16;
                }
                while (v47 != v48);
                uint64_t v47 = (char *)v108;
              }
              BOOL v40 = v46 + 16;
              std::string v108 = v49;
              char v109 = v46 + 16;
              uint64_t v110 = &v45[16 * v44];
              if (v47) {
                operator delete(v47);
              }
            }
            else
            {
              *(_OWORD *)char v109 = *(_OWORD *)v11;
              BOOL v40 = v39 + 16;
            }
            char v109 = v40;
          }
          else
          {
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A4DF0);
            }
            uint64_t v18 = qword_102419458;
            if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
            {
              char v19 = (char *)operator new(0x28uLL);
              *(void *)long long v126 = v19;
              *(_OWORD *)&v126[8] = xmmword_101D048C0;
              *(_OWORD *)char v19 = 0u;
              *((_OWORD *)v19 + 1) = 0u;
              *(void *)(v19 + 29) = 0;
              sub_1001E0650(v11 + 40, v19);
              if (v126[23] >= 0) {
                char v20 = v126;
              }
              else {
                char v20 = *(unsigned char **)v126;
              }
              char v21 = operator new(0x28uLL);
              std::string __p = v21;
              long long v107 = xmmword_101D048C0;
              _OWORD *v21 = 0u;
              v21[1] = 0u;
              *(void *)((char *)v21 + 29) = 0;
              sub_1001E0650(v11, v21);
              if (v107 >= 0) {
                p_p = (char *)&__p;
              }
              else {
                p_p = (char *)__p;
              }
              *(void *)uint64_t buf = 68289538;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v118 = 2082;
              uint64_t v119 = (uint64_t)v20;
              __int16 v120 = 2082;
              uint64_t v121 = p_p;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x26u);
              if (SHIBYTE(v107) < 0) {
                operator delete(__p);
              }
              if ((v126[23] & 0x80000000) != 0) {
                operator delete(*(void **)v126);
              }
              if (qword_102419450 != -1) {
                dispatch_once(&qword_102419450, &stru_1022A4DF0);
              }
            }
            char v23 = qword_102419458;
            if (os_signpost_enabled((os_log_t)qword_102419458))
            {
              __int16 v24 = (char *)operator new(0x28uLL);
              *(void *)long long v126 = v24;
              *(_OWORD *)&v126[8] = xmmword_101D048C0;
              *(_OWORD *)__int16 v24 = 0u;
              *((_OWORD *)v24 + 1) = 0u;
              *(void *)(v24 + 29) = 0;
              sub_1001E0650(v11 + 40, v24);
              if (v126[23] >= 0) {
                char v25 = v126;
              }
              else {
                char v25 = *(unsigned char **)v126;
              }
              __int16 v26 = operator new(0x28uLL);
              std::string __p = v26;
              long long v107 = xmmword_101D048C0;
              *__int16 v26 = 0u;
              v26[1] = 0u;
              *(void *)((char *)v26 + 29) = 0;
              sub_1001E0650(v11, v26);
              if (v107 >= 0) {
                uint64_t v27 = (char *)&__p;
              }
              else {
                uint64_t v27 = (char *)__p;
              }
              *(void *)uint64_t buf = 68289538;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v118 = 2082;
              uint64_t v119 = (uint64_t)v25;
              __int16 v120 = 2082;
              uint64_t v121 = v27;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL", "{\"msg%{public}.0s\":\"CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x26u);
              if (SHIBYTE(v107) < 0) {
                operator delete(__p);
              }
              if ((v126[23] & 0x80000000) != 0) {
                operator delete(*(void **)v126);
              }
            }
          }
          v11 += 64;
        }
        while (v11 != v12);
        uint64_t v11 = v114;
        uint64_t v55 = v115;
        uint64_t v6 = (char *)(a1 + 5);
        if (v115 == v114)
        {
          __int16 v13 = "ds";
        }
        else
        {
          __int16 v13 = "kWorkoutRecorderMinimumPowerAssertionTimeSeconds" + 46;
          do
          {
            if (*(char *)(v55 - 25) < 0) {
              operator delete(*(void **)(v55 - 48));
            }
            v55 -= 64;
          }
          while (v55 != v11);
        }
      }
      uint64_t v115 = v11;
      sub_1002DCB3C(&v114);
      if (v112 == v111)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        uint64_t v94 = qword_102419458;
        if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_177;
        }
        if (*((char *)a1 + 63) < 0) {
          uint64_t v6 = *(char **)v6;
        }
        *(_OWORD *)long long v126 = *(_OWORD *)(a1 + 1);
        int v95 = (char *)operator new(0x28uLL);
        *(void *)(v95 + 29) = 0;
        *(_OWORD *)int v95 = 0u;
        *((_OWORD *)v95 + 1) = 0u;
        sub_1001E0650((uint64_t)v126, v95);
        *(void *)uint64_t buf = 68289539;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v118 = 2081;
        uint64_t v119 = (uint64_t)v6;
        __int16 v120 = 2081;
        uint64_t v121 = v95;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no labels from database to apply to LSL\", \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v95);
      }
      else
      {
        (*(void (**)(unsigned char *__return_ptr))(*(void *)*a1 + 104))(v126);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        __int16 v57 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a1 + 63) < 0) {
            uint64_t v6 = *(char **)v6;
          }
          __int16 v59 = v111;
          uint64_t v58 = v112;
          *(_OWORD *)long long v116 = *(_OWORD *)(a1 + 1);
          __int16 v60 = operator new(0x28uLL);
          std::string __p = v60;
          long long v100 = *((_OWORD *)v13 + 140);
          long long v107 = v100;
          *__int16 v60 = 0u;
          v60[1] = 0u;
          *(void *)((char *)v60 + 29) = 0;
          sub_1001E0650((uint64_t)v116, v60);
          if (v107 >= 0) {
            __int16 v61 = &__p;
          }
          else {
            __int16 v61 = __p;
          }
          uint64_t v62 = a1[12];
          uint64_t v63 = operator new(0x28uLL);
          long long v104 = v63;
          long long v105 = v100;
          _OWORD *v63 = 0u;
          v63[1] = 0u;
          *(void *)((char *)v63 + 29) = 0;
          sub_1001E0650(v62 + 352, v63);
          char v64 = &v104;
          if (v105 < 0) {
            char v64 = v104;
          }
          *(_DWORD *)uint64_t buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          __int16 v118 = 2050;
          uint64_t v119 = (v58 - v59) >> 4;
          __int16 v120 = 2081;
          uint64_t v121 = v6;
          __int16 v122 = 2081;
          uint64_t v123 = v61;
          __int16 v124 = 2081;
          int v125 = v64;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, found labels from database to apply to LSL\", \"NumLabels\":%{public}lu, \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (SHIBYTE(v105) < 0) {
            operator delete(v104);
          }
          if (SHIBYTE(v107) < 0) {
            operator delete(__p);
          }
        }
        std::string __p = 0;
        long long v107 = 0uLL;
        long long v104 = 0;
        long long v105 = 0uLL;
        sub_1000C7F88(buf);
        *(_DWORD *)long long v116 = 0;
        CFStringRef v65 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
        int v66 = sub_10013E418(*(uint64_t *)buf, (uint64_t)v65, v116);
        CFRelease(v65);
        unsigned int v67 = *(_DWORD *)v116;
        if (*(void *)&buf[8]) {
          sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v66) {
          unsigned int v68 = v67;
        }
        else {
          unsigned int v68 = 1000;
        }
        long long v69 = (char *)v111;
        if (v112 != v111)
        {
          uint64_t v70 = 0;
          unsigned int v71 = 0;
          unsigned int v72 = 0;
          long long v101 = *((_OWORD *)v13 + 140);
          while (1)
          {
            __int16 v73 = (char *)v108 + 16 * v70;
            __int16 v74 = sub_1001EFDE4(v126, v73);
            if (qword_102419450 != -1) {
              dispatch_once(&qword_102419450, &stru_1022A4DF0);
            }
            __int16 v75 = &v69[16 * v70];
            char v76 = qword_102419458;
            if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_141;
            }
            __int16 v77 = (char *)operator new(0x28uLL);
            *(void *)long long v116 = v77;
            *(_OWORD *)&v116[8] = v101;
            *(_OWORD *)__int16 v77 = 0u;
            *((_OWORD *)v77 + 1) = 0u;
            *(void *)(v77 + 29) = 0;
            sub_1001E0650((uint64_t)v75, v77);
            if (v116[23] >= 0) {
              int v78 = v116;
            }
            else {
              int v78 = *(unsigned char **)v116;
            }
            __int16 v79 = operator new(0x28uLL);
            std::string v102 = v79;
            long long v103 = v101;
            _OWORD *v79 = 0u;
            v79[1] = 0u;
            *(void *)((char *)v79 + 29) = 0;
            sub_1001E0650((uint64_t)v73, v79);
            std::string v80 = (char *)&v102;
            if (v103 < 0) {
              std::string v80 = (char *)v102;
            }
            *(void *)uint64_t buf = 68289795;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            __int16 v118 = 2081;
            uint64_t v119 = (uint64_t)v78;
            __int16 v120 = 2081;
            uint64_t v121 = v80;
            __int16 v122 = 1026;
            LODWORD(v123) = v74 != 0;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, per label info\", \"LabelUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{private, location:escape_only}s, \"validFingerprint\":%{public}hhd}", buf, 0x2Cu);
            if (SHIBYTE(v103) < 0) {
              operator delete(v102);
            }
            if ((v116[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v116);
              if (v74)
              {
LABEL_142:
                uint64_t v81 = v107;
                if ((unint64_t)v107 >= *((void *)&v107 + 1))
                {
                  uint64_t v82 = sub_1001F3358((uint64_t *)&__p, (uint64_t)(v74 + 4));
                }
                else
                {
                  sub_1001F3468((uint64_t)&v107 + 8, v107, (uint64_t)(v74 + 4));
                  uint64_t v82 = v81 + 192;
                }
                *(void *)&long long v107 = v82;
                uint64_t v83 = v105;
                if ((unint64_t)v105 >= *((void *)&v105 + 1))
                {
                  uint64_t v85 = (uint64_t)(v105 - (void)v104) >> 4;
                  unint64_t v86 = v85 + 1;
                  if ((unint64_t)(v85 + 1) >> 60) {
                    sub_1001D7FD4();
                  }
                  uint64_t v87 = *((void *)&v105 + 1) - (void)v104;
                  if ((uint64_t)(*((void *)&v105 + 1) - (void)v104) >> 3 > v86) {
                    unint64_t v86 = v87 >> 3;
                  }
                  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v88 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v88 = v86;
                  }
                  if (v88) {
                    std::string v89 = (char *)sub_1000C571C((uint64_t)&v105 + 8, v88);
                  }
                  else {
                    std::string v89 = 0;
                  }
                  char v90 = &v89[16 * v85];
                  *(_OWORD *)char v90 = *(_OWORD *)v75;
                  int v92 = (char *)v104;
                  std::string v91 = (char *)v105;
                  int v93 = v90;
                  if ((void *)v105 != v104)
                  {
                    do
                    {
                      *((_OWORD *)v93 - 1) = *((_OWORD *)v91 - 1);
                      v93 -= 16;
                      v91 -= 16;
                    }
                    while (v91 != v92);
                    std::string v91 = (char *)v104;
                  }
                  char v84 = v90 + 16;
                  long long v104 = v93;
                  *(void *)&long long v105 = v90 + 16;
                  *((void *)&v105 + 1) = &v89[16 * v88];
                  if (v91) {
                    operator delete(v91);
                  }
                }
                else
                {
                  *(_OWORD *)long long v105 = *(_OWORD *)v75;
                  char v84 = (_OWORD *)(v83 + 16);
                }
                *(void *)&long long v105 = v84;
                ++v72;
              }
            }
            else
            {
LABEL_141:
              if (v74) {
                goto LABEL_142;
              }
            }
            if (v72 < v68)
            {
              long long v69 = (char *)v111;
              uint64_t v70 = ++v71;
              if (v71 < (unint64_t)((v112 - (unsigned char *)v111) >> 4)) {
                continue;
              }
            }
            break;
          }
        }
        sub_10027AEA8(v98[12] + 72, v98[12], &__p, &v104);
        if (v104)
        {
          *(void *)&long long v105 = v104;
          operator delete(v104);
        }
        *(void *)uint64_t buf = &__p;
        sub_1001F2FE8((void ***)buf);
        sub_10023A88C((uint64_t)v126);
      }
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
LABEL_177:
      long long v96 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v97 = (uint64_t)(*(void *)(v99 + 104) - *(void *)(v99 + 96)) >> 4;
        *(void *)uint64_t buf = 68289282;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v118 = 2050;
        uint64_t v119 = v97;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"after update\":%{public}lu}", buf, 0x1Cu);
      }
      if (v108)
      {
        char v109 = (char *)v108;
        operator delete(v108);
      }
      if (v111)
      {
        __n128 v112 = (char *)v111;
        operator delete(v111);
      }
LABEL_183:
      *(void *)uint64_t buf = &v114;
      sub_1001E7FBC((void ***)buf);
      return;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    long long v54 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t buf = 68289026;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, model has no location similarity list\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
    }
    char v51 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(void *)uint64_t buf = 68289026;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      uint64_t v52 = "applyRecentLabelsToLSL, model has no location similarity list";
      double v53 = "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, model has no location similarity list\"}";
      goto LABEL_96;
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    char v50 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t buf = 68289026;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no current model\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
    }
    char v51 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(void *)uint64_t buf = 68289026;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      uint64_t v52 = "applyRecentLabelsToLSL, no current model";
      double v53 = "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no current model\"}";
LABEL_96:
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v51, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v52, v53, buf, 0x12u);
    }
  }
}

void sub_1002D8664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  operator delete(v45);
  if (__p) {
    operator delete(__p);
  }
  if (a34) {
    operator delete(a34);
  }
  *(void *)(v46 - 144) = &a37;
  sub_1001E7FBC((void ***)(v46 - 144));
  _Unwind_Resume(a1);
}

uint64_t sub_1002D87E0(int a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  double v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289538;
    int v12 = 0;
    __int16 v13 = 2082;
    __int16 v14 = "";
    __int16 v15 = 1026;
    int v16 = a1;
    __int16 v17 = 1026;
    int v18 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"internalToExternalServiceQuality\", \"qualityLevel\":%{public}d, \"candidateQualityLevel\":%{public}d}", buf, 0x1Eu);
  }
  if (a1 == 3)
  {
    uint64_t v5 = 29;
    if (a2 != 3) {
      uint64_t v5 = 30;
    }
    BOOL v6 = a2 == 1;
    uint64_t v7 = 28;
    goto LABEL_13;
  }
  if (a1 == 1)
  {
    uint64_t v5 = 9;
    if (a2 != 3) {
      uint64_t v5 = 10;
    }
    BOOL v6 = a2 == 1;
    uint64_t v7 = 8;
LABEL_13:
    if (v6) {
      return v7;
    }
    else {
      return v5;
    }
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  __int16 v9 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Service Quality is invalid", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static CLMiLoServiceQuality CLMiLoService::internalToExternalServiceQuality(CLMicroLocationProto::Model_ModelQualityLevel, CLMicroLocationProto::Model_ModelQualityLevel)", "%s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
  return 0;
}

uint64_t sub_1002D8A54(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    *(unsigned char *)(sub_100289AB8(a1) + 40) = 0;
  }
  uint64_t result = sub_10033460C();
  *(unsigned char *)(result + 40) = 1;
  return result;
}

uint64_t sub_1002D8A94(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a1 - 2) < 2) {
    return 1;
  }
  if (a1 == 1) {
    return 0;
  }
  if (a1 != 4) {
    sub_101A5A404();
  }
  if (a2 == 2) {
    return 3;
  }
  else {
    return 2;
  }
}

uint64_t sub_1002D8AE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 - 1;
  uint64_t result = 4;
  switch(v2)
  {
    case 0:
      goto LABEL_12;
    case 1:
      return result;
    case 2:
      uint64_t result = 3;
      break;
    case 3:
      if (a2 == 2)
      {
        uint64_t result = 5;
      }
      else
      {
LABEL_12:
        int v6 = sub_1002D8EA8();
        uint64_t result = sub_1002D8D08(v6);
      }
      break;
    default:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      double v4 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Get generation algorithm: Unknown service type", buf, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        uint64_t v7 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)", "%s\n", v7);
        if (v7 != (char *)buf) {
          free(v7);
        }
      }
      int v5 = sub_1002D8EA8();
      uint64_t result = sub_1002D8D08(v5);
      break;
  }
  return result;
}

uint64_t sub_1002D8D08(int a1)
{
  if (a1 == 1) {
    return 2;
  }
  if (a1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v1 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Get generation algorithm: Unknown learner type", buf, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "auto CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)::(anonymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const", "%s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
  return 1;
}

uint64_t sub_1002D8EA8()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 0;
  }
}

void sub_1002D8F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002D8F54(uint64_t a1)
{
  return *(void *)(a1 + 96) && *(void *)(a1 + 88) != 2 && **(unsigned char **)(a1 + 448) != 0;
}

void sub_1002D8F84(uint64_t a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  unsigned int v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0;
    sub_1001E0650(a1 + 8, v5);
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService state changed to running: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}", (uint8_t *)v6, 0x22u);
    operator delete(v5);
  }
  *(void *)(a1 + 8++*(void *)(result + 8) = 0;
}

void sub_1002D90BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002D90D0(int64x2_t *a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  unsigned int v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0;
    sub_1001E0650((uint64_t)&a1->i64[1], v5);
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService state changed to suspended: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}", (uint8_t *)v6, 0x22u);
    operator delete(v5);
  }
  sub_1002D9228(a1);
}

void sub_1002D920C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002D9228(int64x2_t *a1)
{
  sub_1002D5DE8(a1, 1);
  v5[0] = 0;
  v5[1] = 0;
  memset(v3, 0, sizeof(v3));
  unsigned int v4 = (uint64_t *)v5;
  int v6 = 2;
  int v2 = 2;
  sub_1000EDED4(&v4, &v2, &v2);
  sub_1002D962C(a1, (uint64_t)v3);
  sub_1000F5BB0((uint64_t)&v4, v5[0]);
}

void sub_1002D92A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  sub_1000F5BB0(v14, a14);
  _Unwind_Resume(a1);
}

void sub_1002D92C0(uint64_t *a1, void *a2, _OWORD *a3)
{
  unint64_t v4 = a1[3];
  if (v4 >= 4)
  {
    if (v4 == 4)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      __int16 v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = (char *)operator new(0x28uLL);
        *(_OWORD *)int v12 = 0u;
        *((_OWORD *)v12 + 1) = 0u;
        *(void *)(v12 + 29) = 0;
        sub_1001E0650((uint64_t)a2, v12);
        __int16 v13 = (char *)operator new(0x28uLL);
        *(void *)(v13 + 29) = 0;
        *(_OWORD *)__int16 v13 = 0u;
        *((_OWORD *)v13 + 1) = 0u;
        sub_1001E0650((uint64_t)a3, v13);
        int v14 = 68289538;
        int v15 = 0;
        __int16 v16 = 2082;
        __int16 v17 = "";
        __int16 v18 = 2082;
        char v19 = v12;
        __int16 v20 = 2082;
        char v21 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"adding a label to the LSL out of learning flow\", \"Trigger UUID\":%{public, location:escape_only}s, \"Label UUID\":%{public, location:escape_only}s}", (uint8_t *)&v14, 0x26u);
        operator delete(v13);
        operator delete(v12);
      }
      sub_1002DB624(a1, a2, a3);
    }
    else if (v4 == 5)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      __int16 v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v14 = 68289026;
        int v15 = 0;
        __int16 v16 = 2082;
        __int16 v17 = "";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax\"}", (uint8_t *)&v14, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
      }
      uint64_t v8 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v14 = 68289026;
        int v15 = 0;
        __int16 v16 = 2082;
        __int16 v17 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax", "{\"msg%{public}.0s\":\"should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax\"}", (uint8_t *)&v14, 0x12u);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      int v6 = (char *)*((unsigned int *)a1 + 6);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      __int16 v17 = "";
      __int16 v18 = 2050;
      char v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"not adding new truth label out of learning flow\", \"ServiceType\":%{public}lu}", (uint8_t *)&v14, 0x1Cu);
    }
  }
}

void sub_1002D95FC(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002D962C(void *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 48);
  if (v2) {
    uint64_t v3 = 12;
  }
  else {
    uint64_t v3 = -1;
  }
  if (a1[52])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    int v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v7 = (char *)operator new(0x28uLL);
      *(_OWORD *)__int16 v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *(void *)(v7 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 1), v7);
      BOOL v8 = a1[52] != 0;
      *(_DWORD *)uint64_t buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2082;
      int v15 = v7;
      __int16 v16 = 1026;
      BOOL v17 = v8;
      __int16 v18 = 1026;
      BOOL v19 = v2 == 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService releasing observation requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x28u);
      operator delete(v7);
    }
    while (a1[52])
    {
      unint64_t v9 = *(void *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL);
      if (!v2)
      {
        if (*(unsigned char *)(v9 + 32)) {
          sub_1002D92C0(a1, (void *)(*(void *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL)), (_OWORD *)(v9 + 16));
        }
      }
      (*(void (**)(void, void *, unint64_t, uint64_t))(*(void *)*a1 + 40))(*a1, a1 + 1, v9, v3);
      (*(void (**)(void, void *, unint64_t, uint64_t))(*(void *)*a1 + 48))(*a1, a1 + 1, v9, a2);
      *(int64x2_t *)(a1 + 51) = vaddq_s64(*(int64x2_t *)(a1 + 51), (int64x2_t)xmmword_101D0A740);
      sub_1002DCCEC((uint64_t)(a1 + 47), 1);
    }
  }
}

void sub_1002D98A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002D98C0(uint64_t *a1, _OWORD *a2, uint64_t a3, int a4)
{
  BOOL v7 = (a4 & 1) != 0 || *((unsigned char *)a1 + 296) == 0;
  if (sub_1002D5C98())
  {
    int v8 = *((unsigned __int8 *)a1 + 457);
    if (*((unsigned char *)a1 + 457)) {
      int v8 = *((unsigned __int8 *)a1 + 456);
    }
    BOOL v7 = (v8 | v7) != 0;
  }
  if (a1[11]) {
    goto LABEL_9;
  }
  if (!*((unsigned char *)a1 + 368))
  {
    uint64_t v22 = *a1;
    v24[0] = 0;
    v24[16] = 0;
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v22 + 16))(__p);
    if (__p[17])
    {
      sub_1002D4D48((char *)a1, a2);
    }
    else
    {
      if (!__p[16])
      {
LABEL_9:
        uint64_t v9 = 0;
        goto LABEL_10;
      }
      int v23 = *((unsigned __int8 *)a1 + 368);
      *((_OWORD *)a1 + 22) = *(_OWORD *)__p;
      if (!v23) {
        *((unsigned char *)a1 + 36++*(void *)(result + 8) = 1;
      }
      *(_OWORD *)__int16 v24 = *a2;
      v24[16] = 0;
      BYTE2(v2++*(void *)(result + 8) = 0;
      sub_1002DCDC0(a1 + 38, (uint64_t)v24);
    }
    uint64_t v9 = 1;
LABEL_10:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    goto LABEL_12;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  int v15 = qword_102419458;
  uint64_t v9 = 0;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)a1 + 368))
    {
      __int16 v16 = (char *)operator new(0x28uLL);
      *(void *)std::string __p = v16;
      *(_OWORD *)&__p[8] = xmmword_101D048C0;
      *(_OWORD *)__int16 v16 = 0u;
      *((_OWORD *)v16 + 1) = 0u;
      *(void *)(v16 + 29) = 0;
      sub_1001E0650((uint64_t)(a1 + 44), v16);
      BOOL v17 = __p;
      if (__p[23] < 0) {
        BOOL v17 = *(const char **)__p;
      }
      *(void *)__int16 v24 = 68289282;
      *(_WORD *)&v24[8] = 2082;
      *(void *)&v24[10] = "";
      __int16 v25 = 2082;
      __int16 v26 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService reject prediction request because other request in progress\", \"LocalizationId\":%{public, location:escape_only}s}", v24, 0x1Cu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    else
    {
      *(void *)__int16 v24 = 68289282;
      *(_WORD *)&v24[8] = 2082;
      *(void *)&v24[10] = "";
      __int16 v25 = 2082;
      __int16 v26 = "None";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService reject prediction request because other request in progress\", \"LocalizationId\":%{public, location:escape_only}s}", v24, 0x1Cu);
    }
    goto LABEL_9;
  }
LABEL_12:
  uint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = (char *)operator new(0x28uLL);
    *(void *)(v11 + 29) = 0;
    *(_OWORD *)int v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_1001E0650((uint64_t)(a1 + 1), v11);
    __int16 v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0;
    *(_OWORD *)__int16 v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_1001E0650((uint64_t)a2, v12);
    int v13 = *((unsigned __int8 *)a1 + 368);
    if (*((unsigned char *)a1 + 368))
    {
      __int16 v14 = (char *)operator new(0x28uLL);
      *(void *)(v14 + 29) = 0;
      *(_OWORD *)__int16 v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_1001E0650((uint64_t)(a1 + 44), v14);
    }
    else
    {
      __int16 v14 = "None";
    }
    int v18 = *((_DWORD *)a1 + 22);
    int v19 = *((unsigned __int8 *)a1 + 457);
    if (*((unsigned char *)a1 + 457)) {
      int v19 = *((unsigned __int8 *)a1 + 456);
    }
    int v20 = *((unsigned __int8 *)a1 + 296);
    *(void *)__int16 v24 = 68291330;
    *(_WORD *)&v24[8] = 2082;
    *(void *)&v24[10] = "";
    __int16 v25 = 2082;
    __int16 v26 = v11;
    __int16 v27 = 2082;
    __int16 v28 = v12;
    __int16 v29 = 2082;
    uint64_t v30 = v14;
    __int16 v31 = 1026;
    int v32 = v18;
    __int16 v33 = 1026;
    BOOL v34 = v7;
    __int16 v35 = 1026;
    int v36 = a4;
    __int16 v37 = 1026;
    int v38 = v19;
    __int16 v39 = 1026;
    int v40 = v20;
    __int16 v41 = 1026;
    int v42 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received prediction request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"State\":%{public}u, \"force verdict\":%{public}hhd, \"isForcedRequest\":%{public}hhd, \"Is low latency\":%{public}hhd, \"Has valid cache\":%{public}hhd, \"Success\":%{public}hhd}", v24, 0x54u);
    if (v13) {
      operator delete(v14);
    }
    operator delete(v12);
    operator delete(v11);
  }
  return v9;
}

void sub_1002D9D08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002D9D58(uint64_t *a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  if (!a1[12] || a1[11] == 2 || !*(unsigned char *)a1[56])
  {
    uint64_t v10 = 0;
    goto LABEL_8;
  }
  int v8 = (const void *)*a1;
  long long v26 = *(_OWORD *)(a1 + 1);
  sub_100239700((const void **)a1 + 5, (uint64_t)&v26, (std::string *)__p);
  uint64_t v9 = (*(uint64_t (**)(const void *, unsigned char *, _OWORD *, uint64_t, uint64_t))(*(void *)v8 + 24))(v8, __p, a2, a3, a4);
  uint64_t v10 = v9;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (!v10) {
      goto LABEL_8;
    }
  }
  else if (!v9)
  {
    goto LABEL_8;
  }
  long long v18 = *(_OWORD *)a3;
  *(_OWORD *)std::string __p = *a2;
  *(_OWORD *)&__p[16] = v18;
  __p[32] = *(unsigned char *)(a3 + 16);
  sub_1002DCDC0(a1 + 47, (uint64_t)__p);
  uint64_t v10 = 1;
LABEL_8:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  int v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0;
    *(_OWORD *)__int16 v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_1001E0650((uint64_t)(a1 + 1), v12);
    int v13 = (char *)operator new(0x28uLL);
    *(void *)(v13 + 29) = 0;
    *(_OWORD *)int v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_1001E0650((uint64_t)a2, v13);
    if (*(unsigned char *)(a3 + 16))
    {
      __int16 v14 = (char *)operator new(0x28uLL);
      *(void *)(v14 + 29) = 0;
      *(_OWORD *)__int16 v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_1001E0650(a3, v14);
      uint64_t v15 = a1[11];
      *(void *)std::string __p = 68290306;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&unsigned char __p[10] = "";
      *(_WORD *)&unsigned char __p[18] = 2082;
      *(void *)&__p[20] = v12;
      *(_WORD *)&unsigned char __p[28] = 2082;
      *(void *)&__p[30] = v13;
      __int16 v20 = 2082;
      char v21 = v14;
      __int16 v22 = 1026;
      int v23 = v15;
      __int16 v24 = 1026;
      int v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", __p, 0x3Cu);
      operator delete(v14);
    }
    else
    {
      uint64_t v16 = a1[11];
      *(void *)std::string __p = 68290306;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&unsigned char __p[10] = "";
      *(_WORD *)&unsigned char __p[18] = 2082;
      *(void *)&__p[20] = v12;
      *(_WORD *)&unsigned char __p[28] = 2082;
      *(void *)&__p[30] = v13;
      __int16 v20 = 2082;
      char v21 = "None";
      __int16 v22 = 1026;
      int v23 = v16;
      __int16 v24 = 1026;
      int v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", __p, 0x3Cu);
    }
    operator delete(v13);
    operator delete(v12);
  }
  return v10;
}

void sub_1002DA05C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002DA0B4(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 8);
  sub_100239700((const void **)(a1 + 40), (uint64_t)&v2, a2);
}

void sub_1002DA114(void *a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  unint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0;
    sub_1001E0650((uint64_t)(a1 + 1), v5);
    BOOL v6 = *(_DWORD *)(a2 + 48) == 0;
    v7[0] = 68289538;
    v7[1] = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2082;
    int v11 = v5;
    __int16 v12 = 1026;
    BOOL v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received recording stop: \", \"ServiceId\":%{public, location:escape_only}s, \"Success\":%{public}hhd}", (uint8_t *)v7, 0x22u);
    operator delete(v5);
  }
  sub_1002D962C(a1, a2);
}

void sub_1002DA260(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DA27C@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  a3[1] = 0;
  BOOL v6 = (void **)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  a3[7] = 0;
  *((unsigned char *)a3 + 64) = 0;
  *((unsigned char *)a3 + 6++*(void *)(result + 8) = 0;
  uint64_t v8 = *(void *)(a1 + 88);
  BOOL v7 = *(void **)(a1 + 96);
  *a3 = v8;
  *((_OWORD *)a3 + 5) = 0u;
  uint64_t v9 = (void **)(a3 + 10);
  *((unsigned char *)a3 + 152) = 0;
  *((_OWORD *)a3 + 6) = 0u;
  *((_OWORD *)a3 + 7) = 0u;
  *((unsigned char *)a3 + 12++*(void *)(result + 8) = 0;
  *(_OWORD *)((char *)a3 + 164) = 0u;
  *(_OWORD *)((char *)a3 + 180) = 0u;
  *((_DWORD *)a3 + 49) = 0;
  if (v7)
  {
    sub_100278CA4(v7, (uint64_t)buf);
    __int16 v10 = (void *)a3[13];
    if (v10)
    {
      a3[14] = (uint64_t)v10;
      operator delete(v10);
      a3[13] = 0;
      a3[14] = 0;
      a3[15] = 0;
    }
    *(_OWORD *)(a3 + 13) = *(_OWORD *)buf;
    a3[15] = *(void *)&buf[16];
    uint64_t v11 = *(void *)(a1 + 96);
    if (!v11 || !sub_100278D98(v11))
    {
      unint64_t v12 = a3[3];
      BOOL v13 = (char *)a3[2];
      if ((unint64_t)v13 >= v12)
      {
        uint64_t v16 = (char *)*v6;
        uint64_t v17 = (v13 - (unsigned char *)*v6) >> 3;
        unint64_t v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v19 = v12 - (void)v16;
        if (v19 >> 2 > v18) {
          unint64_t v18 = v19 >> 2;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20)
        {
          char v21 = (char *)sub_1000DA54C((uint64_t)(a3 + 3), v20);
          uint64_t v16 = (char *)a3[1];
          BOOL v13 = (char *)a3[2];
        }
        else
        {
          char v21 = 0;
        }
        __int16 v22 = &v21[8 * v17];
        int v23 = &v21[8 * v20];
        *(void *)__int16 v22 = 1;
        __int16 v14 = v22 + 8;
        while (v13 != v16)
        {
          uint64_t v24 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v22 - 1) = v24;
          v22 -= 8;
        }
        a3[1] = (uint64_t)v22;
        a3[2] = (uint64_t)v14;
        a3[3] = (uint64_t)v23;
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        *(void *)BOOL v13 = 1;
        __int16 v14 = v13 + 8;
      }
      a3[2] = (uint64_t)v14;
    }
  }
  else
  {
    uint64_t v15 = operator new(8uLL);
    void *v15 = 0;
    a3[2] = (uint64_t)(v15 + 1);
    a3[3] = (uint64_t)(v15 + 1);
    a3[1] = (uint64_t)v15;
  }
  if (!**(unsigned char **)(a1 + 448))
  {
    long long v26 = a3 + 3;
    unint64_t v25 = a3[3];
    __int16 v27 = (char *)a3[2];
    if ((unint64_t)v27 >= v25)
    {
      __int16 v29 = (char *)*v6;
      uint64_t v30 = (v27 - (unsigned char *)*v6) >> 3;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 61) {
        sub_1001D7FD4();
      }
      uint64_t v32 = v25 - (void)v29;
      if (v32 >> 2 > v31) {
        unint64_t v31 = v32 >> 2;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        BOOL v34 = (char *)sub_1000DA54C((uint64_t)(a3 + 3), v33);
        __int16 v29 = (char *)a3[1];
        __int16 v27 = (char *)a3[2];
      }
      else
      {
        BOOL v34 = 0;
      }
      __int16 v35 = &v34[8 * v30];
      int v36 = &v34[8 * v33];
      *(void *)__int16 v35 = 4;
      __int16 v28 = v35 + 8;
      while (v27 != v29)
      {
        uint64_t v37 = *((void *)v27 - 1);
        v27 -= 8;
        *((void *)v35 - 1) = v37;
        v35 -= 8;
      }
      a3[1] = (uint64_t)v35;
      a3[2] = (uint64_t)v28;
      a3[3] = (uint64_t)v36;
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      *(void *)__int16 v27 = 4;
      __int16 v28 = v27 + 8;
    }
    a3[2] = (uint64_t)v28;
    if (*(unsigned char *)(*(void *)(a1 + 448) + 1))
    {
      if ((unint64_t)v28 >= *v26)
      {
        __int16 v39 = (char *)*v6;
        uint64_t v40 = (v28 - (unsigned char *)*v6) >> 3;
        unint64_t v41 = v40 + 1;
        if ((unint64_t)(v40 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v42 = *v26 - (void)v39;
        if (v42 >> 2 > v41) {
          unint64_t v41 = v42 >> 2;
        }
        if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v43 = v41;
        }
        if (v43)
        {
          unint64_t v44 = (char *)sub_1000DA54C((uint64_t)(a3 + 3), v43);
          __int16 v39 = (char *)a3[1];
          __int16 v28 = (char *)a3[2];
        }
        else
        {
          unint64_t v44 = 0;
        }
        uint64_t v45 = &v44[8 * v40];
        uint64_t v46 = &v44[8 * v43];
        *(void *)uint64_t v45 = 2;
        int v38 = v45 + 8;
        while (v28 != v39)
        {
          uint64_t v47 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v45 - 1) = v47;
          v45 -= 8;
        }
        a3[1] = (uint64_t)v45;
        a3[2] = (uint64_t)v38;
        a3[3] = (uint64_t)v46;
        if (v39) {
          operator delete(v39);
        }
      }
      else
      {
        *(void *)__int16 v28 = 2;
        int v38 = v28 + 8;
      }
      a3[2] = (uint64_t)v38;
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    long long v48 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v49 = operator new(0x28uLL);
      std::string __p = v49;
      long long v138 = xmmword_101D048C0;
      *uint64_t v49 = 0u;
      v49[1] = 0u;
      *(void *)((char *)v49 + 29) = 0;
      sub_1001E0650(a1 + 8, v49);
      p_p = &__p;
      if (v138 < 0) {
        p_p = __p;
      }
      uint64_t v51 = *a3;
      uint64_t v52 = *(unsigned __int8 **)(a1 + 448);
      int v53 = *v52;
      LODWORD(v52) = v52[1];
      *(_DWORD *)uint64_t buf = 68290050;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = p_p;
      *(_WORD *)&unsigned char buf[28] = 1026;
      *(_DWORD *)&buf[30] = v51;
      __int16 v187 = 1026;
      int v188 = v53;
      __int16 v189 = 1026;
      int v190 = (int)v52;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService send status to client, MiLo Unavailable: \", \"ServiceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"isMiLoEnabled\":%{public}hhd, \"isLowPowerMode\":%{public}hhd}", buf, 0x2Eu);
      if (SHIBYTE(v138) < 0) {
        operator delete(__p);
      }
    }
  }
  if (*a3)
  {
    if (*a3 == 1 && a3[1] == a3[2])
    {
      sub_101A5A710(buf);
LABEL_171:
      uint64_t result = abort_report_np();
      __break(1u);
      return result;
    }
  }
  else if (a3[1] != a3[2])
  {
    sub_101A5A5A0(buf);
    goto LABEL_171;
  }
  long long v54 = *(_OWORD *)(a1 + 24);
  *((_OWORD *)a3 + 2) = *(_OWORD *)(a1 + 8);
  *((_OWORD *)a3 + 3) = v54;
  a3[9] = 0;
  sub_1002DD194((char *)a3 + 80, 0, 0, 0);
  uint64_t v55 = *(void *)(a1 + 96);
  if (v55)
  {
    int v56 = sub_100276834(v55);
    int v57 = sub_10027683C(*(void *)(a1 + 96));
    unint64_t v58 = sub_1002D87E0(v56, v57);
    a3[9] = v58;
    if (v58 <= 0xA)
    {
      unint64_t v59 = a3[12];
      __int16 v60 = (char *)a3[11];
      if ((unint64_t)v60 >= v59)
      {
        uint64_t v62 = (char *)*v9;
        uint64_t v63 = (v60 - (unsigned char *)*v9) >> 3;
        unint64_t v64 = v63 + 1;
        if ((unint64_t)(v63 + 1) >> 61) {
          sub_1001D7FD4();
        }
        uint64_t v65 = v59 - (void)v62;
        if (v65 >> 2 > v64) {
          unint64_t v64 = v65 >> 2;
        }
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v64;
        }
        if (v66)
        {
          unsigned int v67 = (char *)sub_1000DA54C((uint64_t)(a3 + 12), v66);
          uint64_t v62 = (char *)a3[10];
          __int16 v60 = (char *)a3[11];
        }
        else
        {
          unsigned int v67 = 0;
        }
        unsigned int v68 = &v67[8 * v63];
        long long v69 = &v67[8 * v66];
        *(void *)unsigned int v68 = 3;
        __int16 v61 = v68 + 8;
        while (v60 != v62)
        {
          uint64_t v70 = *((void *)v60 - 1);
          v60 -= 8;
          *((void *)v68 - 1) = v70;
          v68 -= 8;
        }
        a3[10] = (uint64_t)v68;
        a3[11] = (uint64_t)v61;
        a3[12] = (uint64_t)v69;
        if (v62) {
          operator delete(v62);
        }
      }
      else
      {
        *(void *)__int16 v60 = 3;
        __int16 v61 = v60 + 8;
      }
      a3[11] = (uint64_t)v61;
      unsigned int v71 = (void *)sub_100276844(*(void *)(a1 + 96));
      if (v71[1] != *v71)
      {
        uint64_t v72 = sub_100276844(*(void *)(a1 + 96));
        __int16 v73 = *(_DWORD **)v72;
        __int16 v74 = *(_DWORD **)(v72 + 8);
        *(void *)uint64_t buf = a3 + 10;
        while (v73 != v74)
        {
          uint64_t v75 = (*v73 - 1);
          if (v75 < 8) {
            char v76 = (void *)(v75 + 1);
          }
          else {
            char v76 = 0;
          }
          std::string __p = v76;
          sub_10029CE5C((uint64_t *)buf, &__p);
          ++v73;
        }
      }
    }
    *((_DWORD *)a3 + 40) = sub_1002765A8(*(void *)(a1 + 96));
    uint64_t v77 = *(void *)(a1 + 96);
    *((_DWORD *)a3 + 42) = *(_DWORD *)(v77 + 204);
    *((_DWORD *)a3 + 45) = sub_100277B94(v77);
    uint64_t v78 = *(void *)(a1 + 96);
    *((_DWORD *)a3 + 46) = (*(void *)(v78 + 240) - *(void *)(v78 + 232)) >> 5;
    *(uint64_t *)((char *)a3 + 18++*(void *)(result + 8) = *(void *)(v78 + 216);
    *((_DWORD *)a3 + 49) = *(_DWORD *)(v78 + 224);
    *((_DWORD *)a3 + 41) = *(_DWORD *)(v78 + 200);
    *(uint64_t *)((char *)a3 + 172) = *(void *)(v78 + 208);
  }
  *((_OWORD *)a3 + ++*(void *)(result + 8) = *a2;
  *(_OWORD *)((char *)a3 + 137) = *(_OWORD *)((char *)a2 + 9);
  sub_10010F274((uint64_t)buf);
  __int16 v79 = (uint64_t *)a3[1];
  for (int i = (uint64_t *)a3[2]; v79 != i; ++v79)
  {
    sub_1002DB110(*v79, &__p);
    if (v138 >= 0) {
      uint64_t v81 = &__p;
    }
    else {
      uint64_t v81 = __p;
    }
    if (v138 >= 0) {
      uint64_t v82 = HIBYTE(v138);
    }
    else {
      uint64_t v82 = v138;
    }
    uint64_t v83 = sub_100132EFC(&buf[16], (uint64_t)v81, v82);
    sub_100132EFC(v83, (uint64_t)" ", 1);
    if (SHIBYTE(v138) < 0) {
      operator delete(__p);
    }
  }
  std::stringbuf::str();
  sub_10010F274((uint64_t)&__p);
  char v84 = (uint64_t *)a3[10];
  for (j = (uint64_t *)a3[11]; v84 != j; ++v84)
  {
    sub_1002DB124(*v84, v144);
    if (SBYTE3(v147) >= 0) {
      unint64_t v86 = v144;
    }
    else {
      unint64_t v86 = *(uint8_t **)v144;
    }
    if (SBYTE3(v147) >= 0) {
      uint64_t v87 = BYTE3(v147);
    }
    else {
      uint64_t v87 = *(void *)v145;
    }
    unint64_t v88 = sub_100132EFC((void *)&v138 + 1, (uint64_t)v86, v87);
    sub_100132EFC(v88, (uint64_t)" ", 1);
    if (SBYTE3(v147) < 0) {
      operator delete(*(void **)v144);
    }
  }
  std::stringbuf::str();
  if (*((unsigned char *)a3 + 152))
  {
    std::string v89 = operator new(0x28uLL);
    unint64_t v133 = v89;
    long long v134 = xmmword_101D048C0;
    *std::string v89 = 0u;
    v89[1] = 0u;
    *(void *)((char *)v89 + 29) = 0;
    sub_1001E0650((uint64_t)(a3 + 17), v89);
  }
  else
  {
    sub_100134750(&v133, "None");
  }
  if (*((unsigned char *)a3 + 152)) {
    sub_1002DB138(a3[16], v131);
  }
  else {
    sub_100134750(v131, "None");
  }
  if (*(unsigned char *)(a1 + 457))
  {
    if (*(unsigned char *)(a1 + 456)) {
      char v90 = "low latency";
    }
    else {
      char v90 = "not low latency";
    }
  }
  else
  {
    char v90 = "stopped";
  }
  sub_100134750(v129, v90);
  if (qword_102419460 != -1) {
    dispatch_once(&qword_102419460, &stru_1022A4E10);
  }
  std::string v91 = qword_102419468;
  if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEFAULT))
  {
    int v92 = operator new(0x28uLL);
    int64_t v127 = v92;
    long long v128 = xmmword_101D048C0;
    *int v92 = 0u;
    v92[1] = 0u;
    *(void *)((char *)v92 + 29) = 0;
    sub_1001E0650(a1 + 8, v92);
    int v93 = &v127;
    if (v128 < 0) {
      int v93 = v127;
    }
    __int16 v122 = v93;
    uint64_t v94 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v94 = (void *)*v94;
    }
    int v95 = *(_DWORD *)(a1 + 24);
    sub_100134750(v125, (&off_1022A4EA0)[*a3]);
    int v96 = v126;
    uint64_t v97 = (void **)v125[0];
    int v98 = v143;
    uint64_t v99 = (void **)v142;
    sub_1002DB17C(a3[9], v123);
    long long v100 = &v142;
    if (v98 < 0) {
      long long v100 = v99;
    }
    long long v101 = (void **)v123[0];
    std::string v102 = v125;
    if (v96 < 0) {
      std::string v102 = v97;
    }
    long long v103 = v135;
    if (v124 >= 0) {
      long long v101 = v123;
    }
    if (v136 >= 0) {
      long long v103 = &v135;
    }
    long long v104 = &v133;
    if (v134 < 0) {
      long long v104 = v133;
    }
    long long v105 = (void **)v131[0];
    if (v132 >= 0) {
      long long v105 = v131;
    }
    unsigned int v106 = v129;
    if (v130 < 0) {
      unsigned int v106 = (void **)v129[0];
    }
    int v107 = *((_DWORD *)a3 + 40);
    int v108 = *((_DWORD *)a3 + 41);
    int v110 = *((_DWORD *)a3 + 42);
    int v109 = *((_DWORD *)a3 + 43);
    int v111 = *((_DWORD *)a3 + 44);
    int v112 = *((_DWORD *)a3 + 45);
    int v113 = *((_DWORD *)a3 + 46);
    int v114 = *((_DWORD *)a3 + 47);
    int v115 = *((_DWORD *)a3 + 48);
    int v116 = *((_DWORD *)a3 + 49);
    *(_DWORD *)uint64_t v144 = 68294147;
    *(_DWORD *)&v144[4] = 0;
    *(_WORD *)int v145 = 2082;
    *(void *)&v145[2] = "";
    __int16 v146 = 2082;
    __int16 v147 = v122;
    __int16 v148 = 2082;
    long long v149 = v94;
    __int16 v150 = 1026;
    int v151 = v95;
    __int16 v152 = 2082;
    int v153 = v102;
    __int16 v154 = 2082;
    int v155 = v100;
    __int16 v156 = 2082;
    v157 = v101;
    __int16 v158 = 2082;
    long long v159 = v103;
    __int16 v160 = 2081;
    uint64_t v161 = v104;
    __int16 v162 = 2081;
    uint64_t v163 = v105;
    __int16 v164 = 2082;
    uint64_t v165 = v106;
    __int16 v166 = 1026;
    int v167 = v107;
    __int16 v168 = 1026;
    int v169 = v108;
    __int16 v170 = 1026;
    int v171 = v110;
    __int16 v172 = 1026;
    int v173 = v111;
    __int16 v174 = 1026;
    int v175 = v109;
    __int16 v176 = 1026;
    int v177 = v112;
    __int16 v178 = 1026;
    int v179 = v113;
    __int16 v180 = 1026;
    int v181 = v114;
    __int16 v182 = 1026;
    int v183 = v115;
    __int16 v184 = 1026;
    int v185 = v116;
    _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService send status to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Service Type\":%{public}u, \"State\":%{public, location:escape_only}s, \"Suspend Reasons\":%{public, location:escape_only}s, \"Quality\":%{public, location:escape_only}s, \"Quality Reasons\":%{public, location:escape_only}s, \"Current LOI ID\":%{private, location:escape_only}s, \"Current LOI Type\":%{private, location:escape_only}s, \"Updates Status:\":%{public, location:escape_only}s, \"Number of clusters learned in model\":%{public}u, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of Fingerprints Before Pruning\":%{public}u, \"Number of Fingerprints After Pruning\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}", v144, 0xAEu);
    if (v124 < 0) {
      operator delete(v123[0]);
    }
    if (v126 < 0) {
      operator delete(v125[0]);
    }
    if (SHIBYTE(v128) < 0) {
      operator delete(v127);
    }
  }
  if (v130 < 0) {
    operator delete(v129[0]);
  }
  if (v132 < 0) {
    operator delete(v131[0]);
  }
  if (SHIBYTE(v134) < 0) {
    operator delete(v133);
  }
  if (v136 < 0) {
    operator delete(v135);
  }
  *(void **)((char *)&__p
  uint64_t v120 = v118;
  *((void *)&v138 + 1) = v118;
  if (v141 < 0) {
    operator delete(v140);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (v143 < 0) {
    operator delete(v142);
  }
  *(void *)uint64_t buf = v117;
  *(void *)&buf[*(void *)(v117 - 24)] = v119;
  *(void *)&uint8_t buf[16] = v120;
  if (v192 < 0) {
    operator delete(v191);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1002DAFAC(_Unwind_Exception *a1)
{
  operator delete(v2);
  sub_1002DB200(v1);
  _Unwind_Resume(a1);
}

void *sub_1002DB110@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_100134750(a2, (&off_1022A4E30)[a1]);
}

void *sub_1002DB124@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_100134750(a2, (&off_1022A4E58)[a1]);
}

void *sub_1002DB138@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = "Home";
  uint64_t v5 = "Custom";
  if (a1 != 2) {
    uint64_t v5 = "Other";
  }
  if (a1) {
    unint64_t v4 = "Work";
  }
  if (a1 <= 1) {
    BOOL v6 = (char *)v4;
  }
  else {
    BOOL v6 = (char *)v5;
  }
  return sub_100134750(a2, v6);
}

void *sub_1002DB17C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = "Low";
  uint64_t v5 = "HighCandidateHigh";
  if (a1 != 29) {
    uint64_t v5 = "High";
  }
  BOOL v6 = "Medium";
  if (a1 != 20) {
    BOOL v6 = "HighCandidateLow";
  }
  if (a1 <= 28) {
    uint64_t v5 = v6;
  }
  if (a1 == 9) {
    unint64_t v4 = "LowCandidateHigh";
  }
  BOOL v7 = "Invalid";
  if (a1) {
    BOOL v7 = "LowCandidateLow";
  }
  if (a1 <= 8) {
    unint64_t v4 = v7;
  }
  if (a1 <= 19) {
    uint64_t v8 = (char *)v4;
  }
  else {
    uint64_t v8 = (char *)v5;
  }
  return sub_100134750(a2, v8);
}

void *sub_1002DB200(void *a1)
{
  long long v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1002DB254(void *a1, _OWORD *a2)
{
  sub_1002DA27C((uint64_t)a1, a2, &v3);
  (*(void (**)(void, uint64_t *))(*(void *)*a1 + 64))(*a1, &v3);
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }
  if (v6)
  {
    BOOL v7 = v6;
    operator delete(v6);
  }
  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }
}

void sub_1002DB30C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002DB328(void *a1, void *a2, void *a3)
{
  if ((unint64_t)(a1[3] - 2) <= 2 && a1[12] && a1[11] != 2 && *(unsigned char *)a1[56])
  {
    uint64_t v6 = *a1;
    long long v30 = *(_OWORD *)(a1 + 1);
    sub_100239700((const void **)a1 + 5, (uint64_t)&v30, (std::string *)&__p);
    int v7 = (*(uint64_t (**)(uint64_t, void **, void, void, void, void))(*(void *)v6 + 72))(v6, &__p, *a2, a2[1], *a3, a3[1]);
    int v8 = v7;
    if (SBYTE3(v21) < 0)
    {
      operator delete(__p);
      if (v8) {
        goto LABEL_7;
      }
    }
    else if (v7)
    {
LABEL_7:
      sub_1002D92C0(a1, a2, a3);
      int v9 = 1;
      goto LABEL_10;
    }
  }
  int v9 = 0;
LABEL_10:
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  __int16 v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = (char *)operator new(0x28uLL);
    *(void *)(v11 + 29) = 0;
    *(_OWORD *)uint64_t v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_1001E0650((uint64_t)(a1 + 1), v11);
    unint64_t v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0;
    *(_OWORD *)unint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_1001E0650((uint64_t)a2, v12);
    BOOL v13 = (char *)operator new(0x28uLL);
    *(void *)(v13 + 29) = 0;
    *(_OWORD *)BOOL v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_1001E0650((uint64_t)a3, v13);
    uint64_t v14 = a1[11];
    std::string __p = (void *)68290306;
    __int16 v18 = 2082;
    uint64_t v19 = "";
    __int16 v20 = 2082;
    char v21 = v11;
    __int16 v22 = 2082;
    int v23 = v12;
    __int16 v24 = 2082;
    unint64_t v25 = v13;
    __int16 v26 = 1026;
    int v27 = v14;
    __int16 v28 = 1026;
    int v29 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService label observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", (uint8_t *)&__p, 0x3Cu);
    operator delete(v13);
    operator delete(v12);
    operator delete(v11);
  }
  if (v9) {
    uint64_t v15 = -1;
  }
  else {
    uint64_t v15 = 13;
  }
  return (*(uint64_t (**)(void, void *, void *, uint64_t))(*(void *)*a1 + 40))(*a1, a1 + 1, a2, v15);
}

void sub_1002DB5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002DB624(uint64_t *a1, void *a2, _OWORD *a3)
{
  if (*((unsigned char *)a1 + 368))
  {
    if (a1[44] == *a2 && a1[45] == a2[1])
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      int v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = operator new(0x28uLL);
        std::string __p = v8;
        long long v39 = xmmword_101D048C0;
        *int v8 = 0u;
        v8[1] = 0u;
        *(void *)((char *)v8 + 29) = 0;
        sub_1001E0650((uint64_t)a2, v8);
        p_p = &__p;
        if (v39 < 0) {
          p_p = __p;
        }
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)uint64_t v45 = 2082;
        *(void *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2082;
        *(void *)&v45[12] = p_p;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Attempting to apply truth label for a currently running localization\", \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x1Cu);
        if (SHIBYTE(v39) < 0) {
          operator delete(__p);
        }
      }
    }
  }
  uint64_t v10 = a1[12];
  if (v10)
  {
    if (*(unsigned char *)(v10 + 192))
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      uint64_t v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v12 = operator new(0x28uLL);
        std::string __p = v12;
        long long v39 = xmmword_101D048C0;
        *unint64_t v12 = 0u;
        v12[1] = 0u;
        *(void *)((char *)v12 + 29) = 0;
        sub_1001E0650((uint64_t)(a1 + 1), v12);
        if (v39 >= 0) {
          BOOL v13 = &__p;
        }
        else {
          BOOL v13 = __p;
        }
        uint64_t v14 = operator new(0x28uLL);
        uint64_t v42 = v14;
        long long v43 = xmmword_101D048C0;
        _OWORD *v14 = 0u;
        v14[1] = 0u;
        *(void *)((char *)v14 + 29) = 0;
        sub_1001E0650((uint64_t)a2, v14);
        if (v43 >= 0) {
          uint64_t v15 = (char *)&v42;
        }
        else {
          uint64_t v15 = (char *)v42;
        }
        uint64_t v16 = operator new(0x28uLL);
        uint64_t v40 = v16;
        long long v41 = xmmword_101D048C0;
        _OWORD *v16 = 0u;
        v16[1] = 0u;
        *(void *)((char *)v16 + 29) = 0;
        sub_1001E0650((uint64_t)a3, v16);
        uint64_t v17 = &v40;
        if (v41 < 0) {
          uint64_t v17 = v40;
        }
        *(_DWORD *)uint64_t buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)uint64_t v45 = 2082;
        *(void *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v13;
        __int16 v46 = 2082;
        uint64_t v47 = v15;
        __int16 v48 = 2082;
        *(void *)&long long v49 = v17;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"service is appending an event to similarity list\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v41) < 0) {
          operator delete(v40);
        }
        if (SHIBYTE(v43) < 0) {
          operator delete(v42);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(__p);
        }
      }
      uint64_t v18 = *a1;
      uint64_t v19 = operator new(0x10uLL);
      *(void *)uint64_t buf = v19;
      *(void *)&v45[8] = v19 + 1;
      _OWORD *v19 = *(_OWORD *)a2;
      *(void *)uint64_t v45 = v19 + 1;
      (*(void (**)(void **__return_ptr, uint64_t, uint8_t *))(*(void *)v18 + 104))(&__p, v18, buf);
      if (*(void *)buf)
      {
        *(void *)uint64_t v45 = *(void *)buf;
        operator delete(*(void **)buf);
      }
      __int16 v20 = sub_1001EFDE4(&__p, a2);
      char v21 = v20;
      if (v20)
      {
        uint64_t v22 = a1[12];
        sub_1001F03C4((uint64_t)buf, (uint64_t)(v20 + 4));
        long long v49 = *(_OWORD *)(v21 + 9);
        uint64_t v50 = v21[11];
        sub_1001F08B0((uint64_t)v51, (uint64_t)(v21 + 12));
        sub_1001F0B48((uint64_t)v52, (uint64_t)(v21 + 17));
        *(_OWORD *)&v52[40] = *((_OWORD *)v21 + 11);
        int v53 = *((_DWORD *)v21 + 48);
        uint64_t v55 = 0;
        uint64_t v56 = 0;
        long long v54 = 0;
        sub_10010F834(&v54, (const void *)v21[25], v21[26], (uint64_t)(v21[26] - v21[25]) >> 2);
        uint64_t v42 = 0;
        long long v43 = 0uLL;
        uint64_t v40 = &v42;
        LOBYTE(v41) = 0;
        uint64_t v42 = operator new(0xC0uLL);
        *(void *)&long long v43 = v42;
        *((void *)&v43 + 1) = (char *)v42 + 192;
        *(void *)&long long v43 = sub_1002DD2A0((uint64_t)&v43 + 8, (uint64_t)buf, (uint64_t)&v57, (uint64_t)v42);
        int v23 = operator new(0x10uLL);
        *(void *)&long long v41 = v23 + 1;
        *((void *)&v41 + 1) = v23 + 1;
        *int v23 = *a3;
        uint64_t v40 = v23;
        sub_10027AEA8(v22 + 72, v22, &v42, &v40);
        if (v40)
        {
          *(void *)&long long v41 = v40;
          operator delete(v40);
        }
        uint64_t v40 = &v42;
        sub_1001F2FE8((void ***)&v40);
        if (v54)
        {
          uint64_t v55 = v54;
          operator delete(v54);
        }
        sub_1000D7D80((uint64_t)v52);
        sub_1000D7D80((uint64_t)v51);
        sub_1001F00CC((uint64_t)buf);
      }
      else
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
        BOOL v34 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v35 = (char *)operator new(0x28uLL);
          *(void *)(v35 + 29) = 0;
          *(_OWORD *)__int16 v35 = 0u;
          *((_OWORD *)v35 + 1) = 0u;
          sub_1001E0650((uint64_t)(a1 + 1), v35);
          int v36 = (char *)operator new(0x28uLL);
          *(void *)(v36 + 29) = 0;
          *(_OWORD *)int v36 = 0u;
          *((_OWORD *)v36 + 1) = 0u;
          sub_1001E0650((uint64_t)a2, v36);
          uint64_t v37 = (char *)operator new(0x28uLL);
          *(void *)(v37 + 29) = 0;
          *(_OWORD *)uint64_t v37 = 0u;
          *((_OWORD *)v37 + 1) = 0u;
          sub_1001E0650((uint64_t)a3, v37);
          *(_DWORD *)uint64_t buf = 68289795;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)uint64_t v45 = 2082;
          *(void *)&v45[2] = "";
          *(_WORD *)&v45[10] = 2081;
          *(void *)&v45[12] = v35;
          __int16 v46 = 2082;
          uint64_t v47 = v36;
          __int16 v48 = 2082;
          *(void *)&long long v49 = v37;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"event not appended to similarity list, fingerprint not created!\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}", buf, 0x30u);
          operator delete(v37);
          operator delete(v36);
          operator delete(v35);
        }
      }
      sub_10023A88C((uint64_t)&__p);
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
      __int16 v26 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v27 = (char *)operator new(0x28uLL);
        *(void *)(v27 + 29) = 0;
        *(_OWORD *)int v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_1001E0650((uint64_t)(a1 + 1), v27);
        uint64_t v28 = a1[12];
        int v29 = (char *)operator new(0x28uLL);
        *(void *)(v29 + 29) = 0;
        *(_OWORD *)int v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
        sub_1001E0650(v28 + 352, v29);
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)uint64_t v45 = 2082;
        *(void *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v27;
        __int16 v46 = 2081;
        uint64_t v47 = v29;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"when appending event to similarity list, model has no similarity list!\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v29);
        operator delete(v27);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4DF0);
        }
      }
      long long v30 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        unint64_t v31 = (char *)operator new(0x28uLL);
        *(void *)(v31 + 29) = 0;
        *(_OWORD *)unint64_t v31 = 0u;
        *((_OWORD *)v31 + 1) = 0u;
        sub_1001E0650((uint64_t)(a1 + 1), v31);
        uint64_t v32 = a1[12];
        unint64_t v33 = (char *)operator new(0x28uLL);
        *(void *)(v33 + 29) = 0;
        *(_OWORD *)unint64_t v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_1001E0650(v32 + 352, v33);
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)uint64_t v45 = 2082;
        *(void *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v31;
        __int16 v46 = 2081;
        uint64_t v47 = v33;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "when appending event to similarity list, model has no similarity list!", "{\"msg%{public}.0s\":\"when appending event to similarity list, model has no similarity list!\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v33);
        operator delete(v31);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    __int16 v24 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v45 = 2082;
      *(void *)&v45[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"when appending event to similarity list, service has no current model!\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4DF0);
      }
    }
    unint64_t v25 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v45 = 2082;
      *(void *)&v45[2] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "when appending event to similarity list, service has no current model!", "{\"msg%{public}.0s\":\"when appending event to similarity list, service has no current model!\"}", buf, 0x12u);
    }
  }
}

void sub_1002DBF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30)
{
  operator delete(v31);
  operator delete(v30);
  operator delete(v32);
  sub_10023A88C((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DC0C8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1[3];
  if ((unint64_t)(v8 - 2) > 2
    || !a1[12]
    || a1[11] == 2
    || ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2 ? (BOOL v9 = *(unsigned char *)a1[56] == 0) : (BOOL v9 = 1), v9))
  {
    int v10 = 0;
  }
  else
  {
    char v21 = (const void *)*a1;
    long long v38 = *(_OWORD *)(a1 + 1);
    sub_100239700((const void **)a1 + 5, (uint64_t)&v38, (std::string *)&__p);
    int v22 = (*(uint64_t (**)(const void *, void **, uint64_t, uint64_t, uint64_t))(*(void *)v21 + 80))(v21, &__p, a3, a4, a5);
    int v10 = v22;
    if (SBYTE3(v27) < 0) {
      operator delete(__p);
    }
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  uint64_t v11 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0;
    *(_OWORD *)unint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_1001E0650((uint64_t)(a1 + 1), v12);
    uint64_t v13 = *((unsigned int *)a1 + 6);
    uint64_t v14 = (char *)operator new(0x28uLL);
    *(void *)(v14 + 29) = 0;
    *(_OWORD *)uint64_t v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    sub_1001E0650(a2, v14);
    uint64_t v15 = (char *)operator new(0x28uLL);
    *(void *)(v15 + 29) = 0;
    *(_OWORD *)uint64_t v15 = 0u;
    *((_OWORD *)v15 + 1) = 0u;
    sub_1001E0650(a3, v15);
    uint64_t v16 = a1[11];
    std::string __p = (void *)68290562;
    __int16 v24 = 2082;
    unint64_t v25 = "";
    __int16 v26 = 2082;
    int v27 = v12;
    __int16 v28 = 2050;
    uint64_t v29 = v13;
    __int16 v30 = 2082;
    unint64_t v31 = v14;
    __int16 v32 = 2082;
    unint64_t v33 = v15;
    __int16 v34 = 1026;
    int v35 = v16;
    __int16 v36 = 1026;
    int v37 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService label observation request Between dates: \", \"ServiceId\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", (uint8_t *)&__p, 0x46u);
    operator delete(v15);
    operator delete(v14);
    operator delete(v12);
  }
  if (v10) {
    uint64_t v17 = -1;
  }
  else {
    uint64_t v17 = 14;
  }
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(*(void *)*a1 + 40))(*a1, a1 + 1, a2, v17);
}

void sub_1002DC380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002DC3D8(void *a1, int a2)
{
  if (!*((unsigned char *)a1 + 457)) {
    *((unsigned char *)a1 + 457) = 1;
  }
  *((unsigned char *)a1 + 456) = a2;
  sub_1002D730C(a1, a2);
}

void sub_1002DC3F0(unsigned char *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 8);
  (*(void (**)(void, unsigned char *))(**(void **)a1 + 136))(*(void *)a1, a1 + 8);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
  {
    unint64_t v4 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *(void *)(v4 + 29) = 0;
    sub_1001E0650(v2, v4);
    v5[0] = 68289283;
    v5[1] = 0;
    __int16 v6 = 2082;
    int v7 = "";
    __int16 v8 = 2081;
    BOOL v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Disabling Low Latency updates if exist for Service:\", \"ServiceId\":%{private, location:escape_only}s}", (uint8_t *)v5, 0x1Cu);
    operator delete(v4);
  }
  if (a1[457]) {
    a1[457] = 0;
  }
}

void sub_1002DC548(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DC55C(uint64_t a1)
{
  int v1 = *(void **)a1;
  uint64_t v2 = *(void **)(a1 + 8);
  if (*(void **)a1 == v2) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if (*v1 >= 0x20uLL) {
      sub_10000EDDC("bitset set argument out of range");
    }
    result |= 1 << *v1++;
  }
  while (v1 != v2);
  return result;
}

uint64_t sub_1002DC5BC(void *a1, _OWORD *a2)
{
  if (*((unsigned char *)a1 + 440))
  {
    uint64_t v4 = 31;
    (*(void (**)(void))(*(void *)*a1 + 40))();
  }
  else
  {
    uint64_t v4 = -1;
  }
  unint64_t v5 = a1[11];
  if (v5 >= 2)
  {
    if (v5 == 2)
    {
      uint64_t v4 = 6;
      (*(void (**)(void, void *, _OWORD *, uint64_t))(*(void *)*a1 + 40))(*a1, a1 + 1, a2, 6);
    }
    uint64_t v7 = 0;
  }
  else
  {
    int v6 = *((unsigned __int8 *)a1 + 440);
    *(_OWORD *)(a1 + 53) = *a2;
    if (!v6) {
      *((unsigned char *)a1 + 440) = 1;
    }
    (*(void (**)(void))(*(void *)*a1 + 96))();
    uint64_t v7 = 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  __int16 v8 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = (char *)operator new(0x28uLL);
    *(_OWORD *)BOOL v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(void *)(v9 + 29) = 0;
    sub_1001E0650((uint64_t)a2, v9);
    uint64_t v10 = a1[11];
    v12[0] = 68290050;
    v12[1] = 0;
    __int16 v13 = 2082;
    uint64_t v14 = "";
    __int16 v15 = 2082;
    uint64_t v16 = v9;
    __int16 v17 = 1026;
    int v18 = v7;
    __int16 v19 = 1026;
    int v20 = v10;
    __int16 v21 = 2050;
    uint64_t v22 = v4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::requestMicroLocationLearning\", \"RequestId\":%{public, location:escape_only}s, \"Will Start\":%{public}hhd, \"State\":%{public}u, \"Error Code\":%{public}ld}", (uint8_t *)v12, 0x32u);
    operator delete(v9);
  }
  return v7;
}

void sub_1002DC7E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DC7FC(uint64_t result)
{
  if (*(unsigned char *)(result + 440))
  {
    int v1 = (unsigned char *)result;
    uint64_t v2 = result + 424;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4DF0);
    }
    uint64_t v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      if (!v1[440]) {
        sub_10020D700();
      }
      uint64_t v4 = (char *)operator new(0x28uLL);
      *(_OWORD *)uint64_t v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *(void *)(v4 + 29) = 0;
      sub_1001E0650(v2, v4);
      v5[0] = 68289538;
      v5[1] = 0;
      __int16 v6 = 2082;
      uint64_t v7 = "";
      __int16 v8 = 2082;
      BOOL v9 = v4;
      __int16 v10 = 2050;
      uint64_t v11 = -1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::onLearningCompleted send completion to client\", \"RequestId\":%{public, location:escape_only}s, \"Error Code\":%{public}ld}", (uint8_t *)v5, 0x26u);
      operator delete(v4);
    }
    if (!v1[440]) {
      sub_10020D700();
    }
    uint64_t result = (*(uint64_t (**)(void, unsigned char *, uint64_t, uint64_t))(**(void **)v1 + 40))(*(void *)v1, v1 + 8, v2, -1);
    if (v1[440]) {
      v1[440] = 0;
    }
  }
  return result;
}

void sub_1002DC98C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002DC9A8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v9[0] = a2;
  v9[1] = a3;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4DF0);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    std::string __p = (void *)68289026;
    LOWORD(v++*(void *)(result + 8) = 2082;
    *(void *)((char *)&v8 + 2) = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::onLocalizationStart send event to client\"}", (uint8_t *)&__p, 0x12u);
  }
  uint64_t v5 = *a1;
  __int16 v6 = operator new(0x28uLL);
  std::string __p = v6;
  long long v8 = xmmword_101D048C0;
  *__int16 v6 = 0u;
  v6[1] = 0u;
  *(void *)((char *)v6 + 29) = 0;
  sub_1001E0650((uint64_t)v9, v6);
  (*(void (**)(uint64_t, uint64_t *, void, void **))(*(void *)v5 + 56))(v5, a1 + 1, 0, &__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
}

void sub_1002DCB0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002DCB3C(uint64_t *a1)
{
  uint64_t v3 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = (v5 - *a1) >> 6;
  if (v6 < (v3 - *a1) >> 6)
  {
    uint64_t v13 = result;
    if (v5 == v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v7 = (char *)sub_10017EAF0(result, v6);
    }
    BOOL v9 = v7;
    __int16 v10 = &v7[64 * v6];
    uint64_t v11 = v10;
    unint64_t v12 = &v7[64 * v8];
    sub_1001E7D78(a1, &v9);
    return sub_1001E7F2C((uint64_t)&v9);
  }
  return result;
}

void sub_1002DCBC4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_1002DCBEC(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002DCC1C(id a1)
{
  qword_102419468 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

__n128 sub_1002DCC4C(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      __n128 result = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = result;
      a2[1].n128_u8[7] = 0;
      a2->n128_u8[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t sub_1002DCCEC(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x7C) {
    a2 = 1;
  }
  if (v2 < 0xF8) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 124;
  }
  return v4 ^ 1u;
}

void sub_1002DCD4C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 184))
  {
    unint64_t v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(void *)(a1 + 152) = v2;
      operator delete(v2);
    }
    if (*(unsigned char *)(a1 + 128)) {
      sub_1002220F0(a1 + 88);
    }
    if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + ++*(void *)(result + 8) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 184) = 0;
  }
}

__n128 sub_1002DCDC0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 124 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002DCE7C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x7C)) + 33 * (v7 % 0x7C);
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *(unsigned char *)(v8 + 32) = *(unsigned char *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

void sub_1002DCE7C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x7C;
  unint64_t v4 = v2 - 124;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int16 v34 = (char *)sub_1000DA54C(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      long long v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        long long v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)long long v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    __int16 v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      BOOL v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFFCuLL);
      sub_10017F0B4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFFCuLL);
    sub_1002D02D8((uint64_t)a1, &v54);
    unint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    BOOL v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int16 v34 = (char *)sub_1000DA54C((uint64_t)(a1 + 3), v46);
      int v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      __int16 v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      long long v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000DA54C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  int v53 = operator new(0xFFCuLL);
  sub_1000DA434(&v54, &v53);
  int v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002D03F8((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1002DD148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *sub_1002DD194(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 >> 61) {
      sub_1001D7FD4();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = sub_1001DCF60(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    BOOL v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      __int16 v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    BOOL v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    __int16 v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t sub_1002DD2A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_1001F3468(a1, v4, v6);
      v6 += 192;
      uint64_t v4 = v12 + 192;
      v12 += 192;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_1002DD34C((uint64_t)v9);
  return v4;
}

void sub_1002DD338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002DD34C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002DD384((uint64_t *)a1);
  }
  return a1;
}

uint64_t *sub_1002DD384(uint64_t *result)
{
  unint64_t v2 = (uint64_t *)result[1];
  int v1 = (uint64_t *)result[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *result;
    do
    {
      v3 -= 192;
      __n128 result = (uint64_t *)sub_1001F0024(v5, v3);
    }
    while (v3 != v4);
  }
  return result;
}

void sub_1002DD3D8(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419B50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419B50))
  {
    sub_1002E48E0((std::string *)&xmmword_102419B38);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102419B38, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419B50);
  }
  if (byte_102419B4F < 0)
  {
    sub_1000DC48C((unsigned char *)a1, (void *)xmmword_102419B38, *((unint64_t *)&xmmword_102419B38 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_102419B38;
    *(void *)(a1 + 16) = unk_102419B48;
  }
}

void sub_1002DD494(_Unwind_Exception *a1)
{
}

void sub_1002DD4AC(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_102419B70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_102419B70))
  {
    sub_1002E4DF8((std::string *)&xmmword_102419B58);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102419B58, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_102419B70);
  }
  if (byte_102419B6F < 0)
  {
    sub_1000DC48C((unsigned char *)a1, (void *)xmmword_102419B58, *((unint64_t *)&xmmword_102419B58 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_102419B58;
    *(void *)(a1 + 16) = unk_102419B68;
  }
}

void sub_1002DD568(_Unwind_Exception *a1)
{
}

void sub_1002DD580(uint64_t *a1)
{
  BOOL v2 = sub_10014C3C0(*a1);
  *((unsigned char *)a1 + ++*(void *)(result + 8) = v2;
  if (v2)
  {
    sub_1002DDA64(a1);
    sub_1005F7B0C(*a1, "MiLoServices", (const char **)&off_1022A4ED8, 0, 0);
    char v3 = sub_1005F93E4(*a1, "MiLoServices");
    *((unsigned char *)a1 + ++*(void *)(result + 8) = v3;
    if (v3)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4EB8);
      }
      uint64_t v4 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        BOOL v9 = "MiLoServices";
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sucessfully created table if necessary: %s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 == -1) {
          goto LABEL_16;
        }
        goto LABEL_28;
      }
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4EB8);
      }
      unint64_t v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 136446210;
        BOOL v9 = "MiLoServices";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create table: %{public}s", buf, 0xCu);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A4EB8);
        }
        uint64_t v6 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "void CLMiLoServiceTable::initTable()", "%s\n");
        goto LABEL_26;
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Database is not connected so we can't intialize our table", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 == -1)
      {
LABEL_16:
        uint64_t v6 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 2, "void CLMiLoServiceTable::initTable()", "%s\n");
LABEL_26:
        if (v6 != buf) {
          free(v6);
        }
        return;
      }
LABEL_28:
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
      goto LABEL_16;
    }
  }
}

uint64_t sub_1002DD978(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + ++*(void *)(result + 8) = 0;
  sub_1002DD580((uint64_t *)a1);
  return a1;
}

uint64_t sub_1002DD9A8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, long long *a5, uint64_t a6, long long *a7, double a8)
{
  *(void *)a1 = a4;
  *(void *)(a1 + ++*(void *)(result + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a8;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 32), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    *(void *)(a1 + 4++*(void *)(result + 8) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 32) = v11;
  }
  *(void *)(a1 + 56) = a6;
  uint64_t v12 = (unsigned char *)(a1 + 64);
  if (*((char *)a7 + 23) < 0)
  {
    sub_1000DC48C(v12, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v13 = *a7;
    *(void *)(a1 + 80) = *((void *)a7 + 2);
    *(_OWORD *)uint64_t v12 = v13;
  }
  return a1;
}

void sub_1002DDA44(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002DDA64(uint64_t *a1)
{
  uint64_t result = sub_1005F93E4(*a1, "MiLoServices");
  if (result)
  {
    uint64_t v3 = *a1;
    return sub_1001E1DE8(v3, (uint64_t *)&off_1022A4ED8, 7, "MiLoServices");
  }
  return result;
}

void sub_1002DDACC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *((unsigned char *)&v41.__r_.__value_.__s + 23) = 15;
  strcpy((char *)&v41, "SELECT * FROM (");
  char v40 = 7;
  strcpy(__s, "SELECT ");
  uint64_t v6 = std::string::append(&v41, __s, 7uLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_1002DD3D8((uint64_t)__p);
  if ((v38 & 0x80u) == 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  if ((v38 & 0x80u) == 0) {
    std::string::size_type v9 = v38;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)__p[1];
  }
  char v10 = std::string::append(&v42, (const std::string::value_type *)v8, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = std::string::append(&v43, " FROM ");
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  BOOL v14 = std::string::append(&v44, "MiLoServices");
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  uint64_t v16 = std::string::append(&v45, " ");
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    __int16 v19 = (const std::string::value_type *)a2;
  }
  else {
    __int16 v19 = *(const std::string::value_type **)a2;
  }
  if (v18 >= 0) {
    std::string::size_type v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v20 = *(void *)(a2 + 8);
  }
  uint64_t v21 = std::string::append(&v50, v19, v20);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  char v36 = 7;
  strcpy(v35, " LIMIT ");
  uint64_t v23 = std::string::append(&v51, v35, 7uLL);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v34, a3);
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v25 = &v34;
  }
  else {
    unint64_t v25 = (std::string *)v34.__r_.__value_.__r.__words[0];
  }
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v34.__r_.__value_.__l.__size_;
  }
  int v27 = std::string::append(&v46, (const std::string::value_type *)v25, size);
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  char v33 = 1;
  strcpy(v32, ")");
  uint64_t v29 = std::string::append(&v49, v32, 1uLL);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  int64_t v48 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v47 = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  if (v33 < 0) {
    operator delete(*(void **)v32);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v36 < 0) {
    operator delete(*(void **)v35);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if ((char)v38 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (v40 < 0) {
    operator delete(*(void **)__s);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (v48 >= 0) {
    long long v31 = v47;
  }
  else {
    long long v31 = (void **)v47[0];
  }
  sub_10014D518(a1, (uint64_t)v31);
}

void sub_1002DDFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void **buf)
{
  uint64_t buf = &a45;
  sub_10028B5B0(&buf);
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
  }
  if (a54 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002DE3E4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v1 = *(void *)a1;
    if (byte_10247A79F >= 0) {
      BOOL v2 = &xmmword_10247A788;
    }
    else {
      BOOL v2 = (long long *)xmmword_10247A788;
    }
    sub_10014D518(v1, (uint64_t)v2);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  uint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't insert or replace", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::insertOrReplace(const std::vector<CLMiLoServiceTable::Entry> &)", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return 0;
}

void sub_1002DEA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,std::bad_cast a26)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a23) {
    (*(void (**)(uint64_t))(*(void *)a23 + 8))(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002DEAAC(uint64_t a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v48.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v48, "WHERE ");
    char v10 = std::string::append(&v48, "ClientID");
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    char v47 = 2;
    strcpy(__s, "=\"");
    uint64_t v12 = std::string::append(&v49, __s, 2uLL);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    int v14 = *(char *)(a2 + 23);
    if (v14 >= 0) {
      long long v15 = (const std::string::value_type *)a2;
    }
    else {
      long long v15 = *(const std::string::value_type **)a2;
    }
    if (v14 >= 0) {
      std::string::size_type v16 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      std::string::size_type v16 = *(void *)(a2 + 8);
    }
    long long v17 = std::string::append(&v50, v15, v16);
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    char v45 = 1;
    strcpy(v44, "\"");
    __int16 v19 = std::string::append(&v51, v44, 1uLL);
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    char v43 = 5;
    strcpy(v42, " AND ");
    uint64_t v21 = std::string::append(&v52, v42, 5uLL);
    long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v53, "UserId");
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    char v41 = 2;
    strcpy(v40, "=\"");
    unint64_t v25 = std::string::append(&v54, v40, 2uLL);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v55.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    int v27 = *(char *)(a3 + 23);
    if (v27 >= 0) {
      long long v28 = (const std::string::value_type *)a3;
    }
    else {
      long long v28 = *(const std::string::value_type **)a3;
    }
    if (v27 >= 0) {
      std::string::size_type v29 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v29 = *(void *)(a3 + 8);
    }
    long long v30 = std::string::append(&v55, v28, v29);
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    char v39 = 1;
    strcpy(v38, "\"");
    long long v32 = std::string::append(&v56, v38, 1uLL);
    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    std::string::size_type v58 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    if (v39 < 0) {
      operator delete(*(void **)v38);
    }
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v56.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__r_.__value_.__l.__data_);
    }
    if (v41 < 0) {
      operator delete(*(void **)v40);
    }
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v54.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
    if (v43 < 0) {
      operator delete(*(void **)v42);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (v45 < 0) {
      operator delete(*(void **)v44);
    }
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    if (v47 < 0) {
      operator delete(*(void **)__s);
    }
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v49.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    sub_1002DDACC(*(void *)a1, (uint64_t)__p, a4);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string v34 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v35 = (const std::string::value_type *)a2;
    }
    else {
      int v35 = *(const std::string::value_type **)a2;
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v35;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for client ID %s", (uint8_t *)__p, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v36 = a2;
    }
    else {
      std::string::size_type v36 = *(void *)a2;
    }
    LODWORD(v56.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v56.__r_.__value_.__r.__words + 4) = v36;
    int v37 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForClientAndUserId(const std::string &, const std::string &, uint32_t)", "%s\n", v37);
    if (v37 != (char *)__p) {
      free(v37);
    }
  }
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
}

void sub_1002DEFB8(_Unwind_Exception *a1)
{
}

void sub_1002DF0F8()
{
}

void sub_1002DF100(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v23.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v23, "WHERE ");
    uint64_t v8 = std::string::append(&v23, "ServiceType");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v24.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    char v22 = 2;
    strcpy(__s, "= ");
    char v10 = std::string::append(&v24, __s, 2uLL);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v20, a2);
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v12 = &v20;
    }
    else {
      uint64_t v12 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v20.__r_.__value_.__l.__size_;
    }
    int v14 = std::string::append(&v25, (const std::string::value_type *)v12, size);
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p[0].__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (v22 < 0) {
      operator delete(*(void **)__s);
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v23.__r_.__value_.__l.__data_);
    }
    sub_1002DDACC(*(void *)a1, (uint64_t)__p, a3);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string::size_type v16 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string(__p, a2);
    long long v17 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? __p
        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
    LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for service Type %s", (uint8_t *)&v25, 0xCu);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    std::to_string(&v25, a2);
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v18 = &v25;
    }
    else {
      long long v18 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
    LODWORD(v24.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    __int16 v19 = (std::string *)_os_log_send_and_compose_impl();
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForServiceType(uint32_t, uint32_t)", "%s\n", (const char *)v19);
    if (v19 != __p) {
      free(v19);
    }
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
}

void sub_1002DF478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
}

void sub_1002DF508(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  v27[0] = a2;
  v27[1] = a3;
  memset(&__p, 0, sizeof(__p));
  if ((sub_1001E86C0((uint64_t)v27, &__p) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&buf);
    *(void *)&long long buf = &off_10229E8C8;
    sub_1001E91E8((uint64_t)&buf);
  }
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v20.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v20, "WHERE ");
    uint64_t v6 = std::string::append(&v20, "ServiceUUID");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    uint64_t v8 = std::string::append(&v21, "= \"");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v12 = std::string::append(&v22, (const std::string::value_type *)p_p, size);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v24.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    int v14 = std::string::append(&v24, "\"");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    long long v26 = (_UNKNOWN **)v14->__r_.__value_.__r.__words[2];
    long long buf = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
    sub_1002DDACC(*(void *)a1, (uint64_t)&buf, 1u);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string::size_type v16 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    long long v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for UUID %s", (uint8_t *)&buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    long long v18 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(v24.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::optional<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getServiceByUuid(boost::uuids::uuid)", "%s\n", v19);
    if (v19 != (char *)&buf) {
      free(v19);
    }
  }
  *a4 = 0;
  a4[88] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1002DF8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,std::bad_cast a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002DF994(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v41[0] = a2;
  v41[1] = a3;
  if (*((unsigned char *)a1 + 8))
  {
    *((unsigned char *)&v29.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v29, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v29, "MiLoServices");
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    uint64_t v6 = std::string::append(&v30, " WHERE ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    uint64_t v8 = std::string::append(&v31, "ServiceUUID");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    char v28 = 4;
    strcpy(__s, " IN ");
    char v10 = std::string::append(&v32, __s, 4uLL);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    char v26 = 2;
    strcpy(v25, "(\"");
    uint64_t v12 = std::string::append(&v33, v25, 2uLL);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    memset(&__p, 0, sizeof(__p));
    if (sub_1001E86C0((uint64_t)v41, &__p))
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v16 = std::string::append(&v34, (const std::string::value_type *)p_p, size);
      long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v35.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      HIBYTE(v40) = 2;
      strcpy(v38, "\")");
      long long v18 = std::string::append(&v35, v38, 2uLL);
      long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      int64_t v37 = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string::size_type v36 = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v40) < 0) {
        operator delete(*(void **)v38);
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
      if (v26 < 0) {
        operator delete(*(void **)v25);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
      if (v28 < 0) {
        operator delete(*(void **)__s);
      }
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      if (v37 >= 0) {
        std::string v20 = v36;
      }
      else {
        std::string v20 = (void **)v36[0];
      }
      sub_10014D518(*a1, (uint64_t)v20);
    }
    std::bad_cast::bad_cast((std::bad_cast *)v38);
    *(void *)unsigned __int8 v38 = &off_10229E8C8;
    sub_1001E91E8((uint64_t)v38);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string v21 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v38 = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't Service", (uint8_t *)v38, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(v38, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    LOWORD(v36[0]) = 0;
    std::string v23 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteServiceForUuid(boost::uuids::uuid)", "%s\n", v23);
    if (v23 != v38) {
      free(v23);
    }
  }
  return 0;
}

void sub_1002DFF9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
  }
  if (a52 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E00F0(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    *((unsigned char *)&v34.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v34, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v34, "MiLoServices");
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    if (a2[1] != *a2)
    {
      *((unsigned char *)&v30.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v30, " WHERE ");
      uint64_t v6 = std::string::append(&v30, "ClientID");
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      char v29 = 8;
      strcpy(__s, " NOT IN ");
      uint64_t v8 = std::string::append(&v31, __s, 8uLL);
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v32.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      char v27 = 1;
      strcpy(v26, "(");
      char v10 = std::string::append(&v32, v26, 1uLL);
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v34.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = &v34;
      }
      else {
        uint64_t v12 = (std::string *)v34.__r_.__value_.__r.__words[0];
      }
      if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v34.__r_.__value_.__l.__size_;
      }
      std::string::append(&v33, (const std::string::value_type *)v12, size);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
      if (v27 < 0) {
        operator delete(*(void **)v26);
      }
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (v29 < 0) {
        operator delete(*(void **)__s);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      if (a2[1] != *a2)
      {
        uint64_t v14 = 0;
        unsigned int v15 = 1;
        do
        {
          std::operator+<char>();
          std::string::size_type v16 = std::string::append(&v32, "\"");
          long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
          v34.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v17;
          v16->__r_.__value_.__l.__size_ = 0;
          v16->__r_.__value_.__r.__words[2] = 0;
          v16->__r_.__value_.__r.__words[0] = 0;
          if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v18 = &v34;
          }
          else {
            long long v18 = (std::string *)v34.__r_.__value_.__r.__words[0];
          }
          if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v19 = HIBYTE(v34.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v19 = v34.__r_.__value_.__l.__size_;
          }
          std::string::append(&v33, (const std::string::value_type *)v18, v19);
          if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v34.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v32.__r_.__value_.__l.__data_);
          }
          unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3);
          if (v20 - 1 != v14)
          {
            std::string::append(&v33, ", ");
            unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3);
          }
          uint64_t v14 = v15;
        }
        while (v20 > v15++);
      }
      std::string::append(&v33, ")");
    }
    if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v22 = &v33;
    }
    else {
      std::string v22 = (std::string *)v33.__r_.__value_.__r.__words[0];
    }
    sub_10014D518(*(void *)a1, (uint64_t)v22);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string v23 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v34.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so all services will not be deleted", (uint8_t *)&v34, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v34, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    LOWORD(v33.__r_.__value_.__l.__data_) = 0;
    std::string v25 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteAllServices(const std::vector<std::string> &)", "%s\n", (const char *)v25);
    if (v25 != &v34) {
      free(v25);
    }
  }
  return 0;
}

void sub_1002E0724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
  }
  if (a49 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E084C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1002E28A0((uint64_t *)a1, &v4);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  uint64_t v1 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so service maintenance will not run and nothing will be deleted", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  return 0;
}

void sub_1002E2288(_Unwind_Exception *a1)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  if (SLOBYTE(STACK[0x4B7]) < 0) {
    operator delete((void *)STACK[0x4A0]);
  }
  sub_100286A7C((uint64_t)&STACK[0x340]);
  STACK[0x4C0] = (unint64_t)&STACK[0x430];
  sub_1002E504C((void ***)&STACK[0x4C0]);
  if (SLOBYTE(STACK[0x45F]) < 0) {
    operator delete((void *)STACK[0x448]);
  }
  STACK[0x4C0] = (unint64_t)&STACK[0x460];
  sub_1002E4F50((void ***)&STACK[0x4C0]);
  _Unwind_Resume(a1);
}

void sub_1002E28A0(uint64_t *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *((unsigned char *)&v29.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v29, "SELECT ");
  uint64_t v3 = std::string::append(&v29, "ClientID");
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  long long v5 = std::string::append(&v30, ", ");
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  long long v7 = std::string::append(&v31, "ServiceType");
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  long long v9 = std::string::append(&v32, ", ");
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  long long v11 = (char *)operator new(0x20uLL);
  strcpy(v11, "COUNT(*) as RowCount FROM ");
  uint64_t v12 = std::string::append(&v33, v11, 0x1AuLL);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint64_t v14 = std::string::append(&v34, "MiLoServices");
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  char v28 = 10;
  strcpy(__s, " GROUP BY ");
  std::string::size_type v16 = std::string::append(&v35, __s, 0xAuLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v36.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  long long v18 = std::string::append(&v36, "ClientID");
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  char v26 = 2;
  strcpy(v25, ", ");
  unint64_t v20 = std::string::append(&v40, v25, 2uLL);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  std::string v22 = std::string::append(&__dst, "ServiceType");
  long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  int64_t v38 = v22->__r_.__value_.__r.__words[2];
  long long __p = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v26 < 0) {
    operator delete(*(void **)v25);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v36.__r_.__value_.__l.__data_);
  }
  if (v28 < 0) {
    operator delete(*(void **)__s);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  operator delete(v11);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (v38 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (long long *)__p;
  }
  sub_10014D518(*a1, (uint64_t)p_p);
}

void sub_1002E2D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t buf)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  sub_1002E4F50((void ***)&buf);
  _Unwind_Resume(a1);
}

char *sub_1002E30E4(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  long long v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1000DC48C(v6, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)long long v6 = v7;
  }
  return __dst;
}

void sub_1002E3160(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002E317C()
{
  if (qword_102419450 != -1) {
    goto LABEL_11;
  }
  while (1)
  {
    CFStringRef v0 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      long long v6 = "";
      __int16 v7 = 2082;
      long long v8 = "assert";
      __int16 v9 = 2081;
      long long v10 = "false";
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4EB8);
      }
    }
    uint64_t v1 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      long long v6 = "";
      __int16 v7 = 2082;
      long long v8 = "assert";
      __int16 v9 = 2081;
      long long v10 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v1, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Delete Olders rows in service table. Should never be here!", "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A4EB8);
      }
    }
    BOOL v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      long long v6 = "";
      __int16 v7 = 2082;
      long long v8 = "assert";
      __int16 v9 = 2081;
      long long v10 = "false";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_11:
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
}

uint64_t sub_1002E33A0(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  v47[0] = a2;
  v47[1] = a3;
  if (*(unsigned char *)(a1 + 8))
  {
    memset(&v45, 0, sizeof(v45));
    if (sub_1001E86C0((uint64_t)v47, &v45))
    {
      *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v40, " WHERE ");
      long long v6 = std::string::append(&v40, "ServiceUUID");
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      long long v8 = std::string::append(&v41, "= \"");
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v10 = &v45;
      }
      else {
        long long v10 = (std::string *)v45.__r_.__value_.__r.__words[0];
      }
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v45.__r_.__value_.__l.__size_;
      }
      uint64_t v12 = std::string::append(&v42, (const std::string::value_type *)v10, size);
      long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v46.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      uint64_t v14 = std::string::append(&v46, "\"");
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      int64_t v44 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v42.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      *((unsigned char *)&v37.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v37, "UPDATE ");
      std::string::size_type v16 = std::string::append(&v37, "MiLoServices");
      long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      long long v18 = std::string::append(&v38, " SET ");
      long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      unint64_t v20 = std::string::append(&v39, "LastActiveTimestamp");
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      std::string v22 = std::string::append(&v40, "=");
      long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v36, a4);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v24 = &v36;
      }
      else {
        std::string v24 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v25 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v25 = v36.__r_.__value_.__l.__size_;
      }
      char v26 = std::string::append(&v41, (const std::string::value_type *)v24, v25);
      long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v46.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      if (v44 >= 0) {
        char v28 = __p;
      }
      else {
        char v28 = (void **)__p[0];
      }
      if (v44 >= 0) {
        std::string::size_type v29 = HIBYTE(v44);
      }
      else {
        std::string::size_type v29 = (std::string::size_type)__p[1];
      }
      std::string v30 = std::string::append(&v46, (const std::string::value_type *)v28, v29);
      long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v39.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v38.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v32 = &v42;
      }
      else {
        std::string v32 = (std::string *)v42.__r_.__value_.__r.__words[0];
      }
      sub_10014D518(*(void *)a1, (uint64_t)v32);
    }
    std::bad_cast::bad_cast((std::bad_cast *)&v46);
    v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
    sub_1001E91E8((uint64_t)&v46);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string v33 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v46.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't update service", (uint8_t *)&v46, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v46, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    LOWORD(v45.__r_.__value_.__l.__data_) = 0;
    std::string v35 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::updateServiceLastActiveTime(boost::uuids::uuid, cl::chrono::CFAbsoluteTimeClock::time_point)", "%s\n", (const char *)v35);
    if (v35 != &v46) {
      free(v35);
    }
  }
  return 0;
}

void sub_1002E3A60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E3BF4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v47[0] = a2;
  v47[1] = a3;
  if (*(unsigned char *)(a1 + 8))
  {
    memset(&v45, 0, sizeof(v45));
    if (sub_1001E86C0((uint64_t)v47, &v45))
    {
      *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v40, " WHERE ");
      long long v6 = std::string::append(&v40, "ServiceUUID");
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      long long v8 = std::string::append(&v41, "= \"");
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v10 = &v45;
      }
      else {
        long long v10 = (std::string *)v45.__r_.__value_.__r.__words[0];
      }
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v45.__r_.__value_.__l.__size_;
      }
      uint64_t v12 = std::string::append(&v42, (const std::string::value_type *)v10, size);
      long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v46.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      uint64_t v14 = std::string::append(&v46, "\"");
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      int64_t v44 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v42.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      *((unsigned char *)&v37.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v37, "UPDATE ");
      std::string::size_type v16 = std::string::append(&v37, "MiLoServices");
      long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      long long v18 = std::string::append(&v38, " SET ");
      long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      unint64_t v20 = std::string::append(&v39, "LocationTypes");
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      std::string v22 = std::string::append(&v40, "=");
      long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v36, a4);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v24 = &v36;
      }
      else {
        std::string v24 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v25 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v25 = v36.__r_.__value_.__l.__size_;
      }
      char v26 = std::string::append(&v41, (const std::string::value_type *)v24, v25);
      long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v46.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      if (v44 >= 0) {
        char v28 = __p;
      }
      else {
        char v28 = (void **)__p[0];
      }
      if (v44 >= 0) {
        std::string::size_type v29 = HIBYTE(v44);
      }
      else {
        std::string::size_type v29 = (std::string::size_type)__p[1];
      }
      std::string v30 = std::string::append(&v46, (const std::string::value_type *)v28, v29);
      long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v39.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v38.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v32 = &v42;
      }
      else {
        std::string v32 = (std::string *)v42.__r_.__value_.__r.__words[0];
      }
      sub_10014D518(*(void *)a1, (uint64_t)v32);
    }
    std::bad_cast::bad_cast((std::bad_cast *)&v46);
    v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10229E8C8;
    sub_1001E91E8((uint64_t)&v46);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A4EB8);
  }
  std::string v33 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v46.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't update service", (uint8_t *)&v46, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(&v46, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A4EB8);
    }
    LOWORD(v45.__r_.__value_.__l.__data_) = 0;
    std::string v35 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)", "%s\n", (const char *)v35);
    if (v35 != &v46) {
      free(v35);
    }
  }
  return 0;
}

void sub_1002E42AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  _Unwind_Resume(a1);
}

void sub_1002E4440(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002E4470(uint64_t *a1, uint64_t *a2, double *a3, unsigned int *a4, long long *a5, uint64_t *a6, long long *a7)
{
  uint64_t v8 = *a1;
  uint64_t v9 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_1001D7FD4();
  }
  uint64_t v17 = (uint64_t)(a1 + 2);
  unint64_t v18 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v8) >> 3);
  if (2 * v18 > v10) {
    unint64_t v10 = 2 * v18;
  }
  if (v18 >= 0x1745D1745D1745DLL) {
    unint64_t v19 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v19 = v10;
  }
  long long v27 = a1 + 2;
  if (v19) {
    unint64_t v20 = (char *)sub_1000DA8B4(v17, v19);
  }
  else {
    unint64_t v20 = 0;
  }
  long long v23 = v20;
  std::string v24 = &v20[88 * v9];
  uint64_t v25 = (uint64_t)v24;
  char v26 = &v20[88 * v19];
  sub_1002DD9A8((uint64_t)v24, *a2, a2[1], *a4, a5, *a6, a7, *a3);
  uint64_t v25 = (uint64_t)(v24 + 88);
  sub_1002E45C8(a1, &v23);
  uint64_t v21 = a1[1];
  sub_1002E47A4(&v23);
  return v21;
}

void sub_1002E45B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002E47A4((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E45C8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002E4640((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002E4640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  long long v14[2] = &v17;
  if (a3 == a5)
  {
    uint64_t v12 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 88);
      *(_OWORD *)(v8 - 72) = *(_OWORD *)(a3 - 72);
      *(_OWORD *)(v8 - 8++*(void *)(result + 8) = v9;
      long long v10 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v10;
      *(void *)(a3 - 4++*(void *)(result + 8) = 0;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 56) = 0;
      *(void *)(v8 - 32) = *(void *)(a3 - 32);
      long long v11 = *(_OWORD *)(a3 - 24);
      *(void *)(v8 - ++*(void *)(result + 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v8 - 24) = v11;
      v8 -= 88;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - ++*(void *)(result + 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 88;
      a3 -= 88;
    }
    while (a3 != a5);
    *((void *)&v17 + 1) = v8;
    uint64_t v12 = v17;
  }
  char v15 = 1;
  sub_1002E4718((uint64_t)v14);
  return v12;
}

uint64_t sub_1002E4718(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002E4750((uint64_t *)a1);
  }
  return a1;
}

void sub_1002E4750(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10028B648(v3, v1);
      v1 += 88;
    }
    while (v1 != v2);
  }
}

void **sub_1002E47A4(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1002E47D8(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 88;
    sub_10028B648(v4, i - 88);
  }
}

uint64_t sub_1002E4820(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_1000DC48C((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 4++*(void *)(result + 8) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  uint64_t v6 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_1000DC48C(v6, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(unsigned char *)(a1 + 8++*(void *)(result + 8) = 1;
  return a1;
}

void sub_1002E48C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002E48E0@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  sub_1002E4944(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_1002E4928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4944(std::string *a1)
{
  sub_1002E49A4(a1);
  sub_1002E4A78(a1);
  sub_1002E4B58(a1);
  sub_1001E81E8(a1);
  sub_1002E4C38(a1);
  sub_1001E8488(a1);

  return sub_1002E4D18(a1);
}

uint64_t sub_1002E49A4(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "ServiceUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    long long v4 = __p;
  }
  else {
    long long v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002E4A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4A78(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LastActiveTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    long long v4 = __p;
  }
  else {
    long long v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002E4B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4B58(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ServiceType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    long long v4 = __p;
  }
  else {
    long long v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002E4C04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4C38(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LocationTypes");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    long long v4 = __p;
  }
  else {
    long long v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002E4CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4D18(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "UserId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    long long v4 = __p;
  }
  else {
    long long v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1002E4DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002E4DF8@<D0>(std::string *a1@<X8>)
{
  sub_100134750(&v11, "VALUES (");
  uint64_t v2 = 7;
  do
  {
    if (v2 == 7)
    {
      *((unsigned char *)&v8.__r_.__value_.__s + 23) = 0;
      v8.__r_.__value_.__s.__data_[0] = 0;
    }
    else
    {
      *((unsigned char *)&v8.__r_.__value_.__s + 23) = 2;
      strcpy((char *)&v8, ", ");
    }
    long long v3 = std::string::append(&v8, "?");
    long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    int64_t v10 = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    if (v10 >= 0) {
      std::string::size_type v5 = __p;
    }
    else {
      std::string::size_type v5 = (void **)__p[0];
    }
    if (v10 >= 0) {
      std::string::size_type v6 = HIBYTE(v10);
    }
    else {
      std::string::size_type v6 = (std::string::size_type)__p[1];
    }
    std::string::append(&v11, (const std::string::value_type *)v5, v6);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v8.__r_.__value_.__l.__data_);
    }
    --v2;
  }
  while (v2);
  std::string::append(&v11, ")");
  double result = *(double *)&v11.__r_.__value_.__l.__data_;
  *a1 = v11;
  return result;
}

void sub_1002E4F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002E4F50(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1002E4FA4((uint64_t *)v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

void sub_1002E4FA4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 17) < 0) {
      operator delete(*(void **)(i - 40));
    }
  }
  a1[1] = v2;
}

void sub_1002E4FF4(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_1002E504C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    std::string::size_type v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_1002E4FF4(v4);
      }
      while ((void *)v4 != v2);
      std::string::size_type v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1002E50D0(uint64_t *a1)
{
  if (*a1)
  {
    sub_1002E4FA4(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 sub_1002E510C(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(*(unsigned char **)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  __n128 result = *(__n128 *)((char *)a2 + 24);
  *(__n128 *)(v4 + 24) = result;
  *(void *)(a1 + ++*(void *)(result + 8) = v4 + 40;
  return result;
}

void sub_1002E5174(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++*(void *)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1002E517C(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x333333333333333) {
    unint64_t v9 = 0x666666666666666;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v18 = a1 + 2;
  if (v9) {
    int64_t v10 = (char *)sub_1002E5328(v7, v9);
  }
  else {
    int64_t v10 = 0;
  }
  std::string v11 = &v10[40 * v4];
  v15[0] = v10;
  v15[1] = v11;
  long long v16 = v11;
  long long v17 = &v10[40 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000DC48C(v11, *(void **)a2, *((void *)a2 + 1));
    std::string v11 = v16;
  }
  else
  {
    long long v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string v11 = v12;
  }
  *(_OWORD *)&v10[40 * v4 + 24] = *(long long *)((char *)a2 + 24);
  long long v16 = v11 + 40;
  sub_1002E52B0(a1, v15);
  uint64_t v13 = a1[1];
  sub_1002E549C((uint64_t)v15);
  return v13;
}

void sub_1002E529C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002E549C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E52B0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002E5370((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002E5328(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    sub_1001D7FA0();
  }
  return operator new(40 * a2);
}

uint64_t sub_1002E5370(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  _DWORD v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(_OWORD *)(v7 - 40) = v8;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 40) = 0;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(a3 - 16);
      uint64_t v7 = *((void *)&v14 + 1) - 40;
      *((void *)&v14 + 1) -= 40;
      a3 -= 40;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_1002E541C((uint64_t)v11);
  return v9;
}

uint64_t sub_1002E541C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002E5454(a1);
  }
  return a1;
}

void sub_1002E5454(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 40;
  }
}

uint64_t sub_1002E549C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002E54D4(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 5;
      *(void *)(a1 + 16) = v2 - 5;
      if (*((char *)v2 - 17) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_1002E552C()
{
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_101D04970;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  CFStringRef v0 = std::string::append(&v19, "MiLoServices");
  long long v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v0->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  uint64_t v2 = std::string::append(&v20, " (");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_1002DD3D8((uint64_t)v17);
  if ((v18 & 0x80u) == 0) {
    unint64_t v4 = v17;
  }
  else {
    unint64_t v4 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    std::string::size_type v5 = v18;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v17[1];
  }
  uint64_t v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  long long v8 = std::string::append(&v22, ") ");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_1002DD4AC((uint64_t)__p);
  if ((v16 & 0x80u) == 0) {
    int64_t v10 = __p;
  }
  else {
    int64_t v10 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    std::string::size_type v11 = v16;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  char v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_10247A798 = *((void *)&v12->__r_.__value_.__l + 2);
  xmmword_10247A788 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if ((char)v18 < 0) {
    operator delete(v17[0]);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10247A788, (void *)&_mh_execute_header);
}

void sub_1002E5724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v40 - 25) < 0) {
    operator delete(*(void **)(v40 - 48));
  }
  if (*(char *)(v40 - 57) < 0) {
    operator delete(*(void **)(v40 - 80));
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002E57D0@<X0>(_DWORD *a1@<X0>, void *a2@<X8>)
{
  if (*a1) {
    uint64_t v2 = "recording";
  }
  else {
    uint64_t v2 = "localization";
  }
  return sub_100134750(a2, v2);
}

void *sub_1002E57F4@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_1022A50A0[*a1]);
}

void *sub_1002E580C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_1022A50D0[a1 - 1]);
}

void sub_1002E5824(int *a1@<X0>, uint64_t a2@<X8>)
{
  sub_10023D524((uint64_t)v7);
  uint64_t v8 = *((void *)a1 + 7);
  float v4 = (float)a1[8];
  v12 |= 6u;
  float v9 = v4;
  uint64_t v6 = *(void *)a1;
  uint64_t v10 = sub_1000D8908((uint64_t)&v6);
  int v5 = a1[10];
  v12 |= 0x18u;
  int v11 = v5;
  sub_10023F7D0(a2, v7);
  *(unsigned char *)(a2 + 4++*(void *)(result + 8) = 1;
  sub_10023F7D4((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_1002E58BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10023F7D4((wireless_diagnostics::google::protobuf::MessageLite *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E58D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 23);
  if ((v3 & 0x80u) == 0) {
    float v4 = (unsigned __int8 *)a1;
  }
  else {
    float v4 = *(unsigned __int8 **)a1;
  }
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t result = sub_1001E70CC((uint64_t)&v7, v4, &v4[v3]);
  *(void *)a2 = result;
  *(void *)(a2 + ++*(void *)(result + 8) = v6;
  *(unsigned char *)(a2 + 16) = 1;
  return result;
}

uint64_t **sub_1002E594C@<X0>(uint64_t **result@<X0>, unsigned char *a2@<X8>)
{
  int v2 = *((char *)result + 23);
  if (v2 < 0)
  {
    if (result[1] != (uint64_t *)16)
    {
LABEL_7:
      char v3 = 0;
      *a2 = 0;
      goto LABEL_8;
    }
    uint64_t result = (uint64_t **)*result;
  }
  else if (v2 != 16)
  {
    goto LABEL_7;
  }
  *(_OWORD *)a2 = *(_OWORD *)result;
  char v3 = 1;
LABEL_8:
  a2[16] = v3;
  return result;
}

id sub_1002E5990@<X0>(id result@<X0>, uint64_t a2@<X8>)
{
  if (result)
  {
    long long v4 = 0uLL;
    uint64_t result = [result getUUIDBytes:&v4];
    *(_OWORD *)a2 = v4;
    char v3 = 1;
  }
  else
  {
    char v3 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 16) = v3;
  return result;
}

void sub_1002E5A10(id *a1@<X0>, unsigned char *a2@<X8>)
{
  sub_10023D4E8((uint64_t)v11);
  if (!*a1 || ![*a1 idsDeviceID])
  {
LABEL_17:
    *a2 = 0;
    a2[72] = 0;
    goto LABEL_22;
  }
  [*a1 bleAdvertisementTimestamp];
  v18 |= 2u;
  uint64_t v12 = v4;
  int v5 = [*a1 bleRSSI];
  v18 |= 4u;
  float v13 = (float)v5;
  unsigned int v6 = [*a1 bleChannel];
  v18 |= 0x10u;
  unsigned int v17 = v6;
  id v7 = [*a1 discoveryFlags];
  v18 |= 0x20u;
  id v14 = v7;
  sub_100134750(__p, (char *)[[*a1 idsDeviceID] UTF8String]);
  sub_1002E58D4((uint64_t)__p, (uint64_t)__s);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if (!__s[16])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5080);
    }
    float v9 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid CBDevice IDS UUID", (uint8_t *)__p, 2u);
    }
    if (sub_10013D1A0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5080);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 0, "static std::optional<CLMicroLocationProto::BleLeechedBeacons> CLMicroLocationProtobufHelper::protobufFromNative(const CLMicroLocationBleWrapperForCBDevice &)", "%s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
    goto LABEL_17;
  }
  v18 |= 0x80u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::assign(v16, __s, 0x10uLL);
  if ([*a1 model])
  {
    uint64_t v8 = (const std::string::value_type *)[(*a1) model UTF8String];
    v18 |= 0x40u;
    if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v15, v8);
  }
  else
  {
    v18 |= 0x40u;
    if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v15, "Undefined Model");
  }
  sub_10023EAA4((uint64_t)a2, (uint64_t)v11);
  a2[72] = 1;
LABEL_22:
  sub_10023EB9C((wireless_diagnostics::google::protobuf::MessageLite *)v11);
}

void sub_1002E5D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_1002E5DC4(uint64_t *a1@<X0>, unsigned char *a2@<X8>)
{
  if (*((unsigned char *)a1 + 68) == 1)
  {
    sub_10023D580((uint64_t)v13);
    uint64_t v14 = *a1;
    int v4 = *((_DWORD *)a1 + 2);
    v20 |= 6u;
    int v15 = v4;
    if (*((char *)a1 + 55) < 0)
    {
      sub_1000DC48C(__p, (void *)a1[4], a1[5]);
    }
    else
    {
      *(_OWORD *)long long __p = *((_OWORD *)a1 + 2);
      uint64_t v22 = a1[6];
    }
    sub_1002E58D4((uint64_t)__p, (uint64_t)__s);
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
    if (__s[16])
    {
      v20 |= 0x10u;
      if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::assign(v17, __s, 0x10uLL);
      v20 |= 8u;
      int v5 = v16;
      if (!v16) {
        operator new();
      }
      int v6 = *((_DWORD *)a1 + 4);
      v16[6] |= 1u;
      _DWORD v5[2] = v6;
      v20 |= 8u;
      int v7 = *((_DWORD *)a1 + 5);
      v5[6] |= 2u;
      void v5[3] = v7;
      v20 |= 8u;
      int v8 = *((_DWORD *)a1 + 6);
      v5[6] |= 4u;
      void v5[4] = v8;
      int v9 = *((unsigned __int8 *)a1 + 56);
      if (!sub_10023E7A0(v9)) {
        __assert_rtn("set_devicetype", "microlocation.pb.h", 9831, "::CLMicroLocationProto::UwbRange_DeviceType_IsValid(value)");
      }
      int v18 = v9;
      v20 |= 0xE0u;
      uint64_t v19 = *(uint64_t *)((char *)a1 + 60);
      sub_1002406A8(a2, v13);
      char v10 = 1;
    }
    else
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5080);
      }
      int v11 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid UwbRange IDS UUID", (uint8_t *)__p, 2u);
      }
      if (sub_10013D1A0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5080);
        }
        uint64_t v12 = (char *)_os_log_send_and_compose_impl();
        sub_1004BA5E4("Generic", 1, 0, 0, "static std::optional<CLMicroLocationProto::UwbRange> CLMicroLocationProtobufHelper::protobufFromNative(const CLHomeNearbyObjectInternal &)", "%s\n", v12);
        if (v12 != (char *)__p) {
          free(v12);
        }
      }
      char v10 = 0;
      *a2 = 0;
    }
    a2[64] = v10;
    sub_100240760((wireless_diagnostics::google::protobuf::MessageLite *)v13);
  }
  else
  {
    *a2 = 0;
    a2[64] = 0;
  }
}

void sub_1002E6138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_1002E6194(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 4u;
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    operator new();
  }

  sub_10023FDF8(v2, a2);
}

void sub_1002E6210()
{
}

void sub_1002E6234(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 0x40u;
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    operator new();
  }

  sub_10023F5A8(v2, a2);
}

void sub_1002E62B0()
{
}

float sub_1002E62D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 0x80u;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    operator new();
  }

  return sub_100241158(v2, a2);
}

void sub_1002E6350()
{
}

void sub_1002E6374(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 8u;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    operator new();
  }

  sub_10024F9F0(v2, a2);
}

void sub_1002E63F0()
{
}

void sub_1002E6414(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x20u;
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    operator new();
  }

  sub_100250584(v2, a2);
}

void sub_1002E6490()
{
}

void sub_1002E64B4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 4u;
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    operator new();
  }

  sub_10024E2D8(v2, a2);
}

void sub_1002E6530()
{
}

void sub_1002E6554(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x40u;
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    operator new();
  }

  sub_100251554(v2, a2);
}

void sub_1002E65D0()
{
}

void sub_1002E65F4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x80u;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    operator new();
  }

  sub_100253228(v2, a2);
}

void sub_1002E6670()
{
}

void sub_1002E6694(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x100u;
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    operator new();
  }

  sub_1002547D8(v2, a2);
}

void sub_1002E6710()
{
}

void sub_1002E6734(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 4u;
  uint64_t v2 = *(_DWORD **)(a1 + 16);
  if (!v2) {
    operator new();
  }

  sub_10026B72C(v2, a2);
}

void sub_1002E67B0()
{
}

void sub_1002E67D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 8u;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    operator new();
  }

  sub_10026BE78(v2, a2);
}

void sub_1002E6850()
{
}

void sub_1002E6874(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 0x10u;
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    operator new();
  }

  sub_10026C814(v2, a2);
}

void sub_1002E68F0()
{
}

void sub_1002E6914(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x200u;
  uint64_t v2 = *(void *)(a1 + 80);
  if (!v2) {
    operator new();
  }

  sub_100255F34(v2, a2);
}

void sub_1002E6990()
{
}

void sub_1002E69B4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x10u;
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    operator new();
  }

  sub_1002500E4(v2, a2);
}

void sub_1002E6A30()
{
}

void sub_1002E6A54(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x400u;
  uint64_t v2 = *(void *)(a1 + 88);
  if (!v2) {
    operator new();
  }

  sub_10024EE10(v2, a2);
}

void sub_1002E6AD0()
{
}

void sub_1002E6AF4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x1000u;
  uint64_t v2 = *(void *)(a1 + 96);
  if (!v2) {
    operator new();
  }

  sub_1002510B4(v2, a2);
}

void sub_1002E6B70()
{
}

void sub_1002E6B94(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 2u;
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    operator new();
  }

  sub_10024F9F0(v2, a2);
}

void sub_1002E6C10()
{
}

void sub_1002E6C34(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 8u;
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    operator new();
  }

  sub_100250584(v2, a2);
}

void sub_1002E6CB0()
{
}

void sub_1002E6CD4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 1u;
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    operator new();
  }

  sub_10024E2D8(v2, a2);
}

void sub_1002E6D50()
{
}

void sub_1002E6D74(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10u;
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    operator new();
  }

  sub_100251554(v2, a2);
}

void sub_1002E6DF0()
{
}

void sub_1002E6E14(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20u;
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    operator new();
  }

  sub_100253228(v2, a2);
}

void sub_1002E6E90()
{
}

void sub_1002E6EB4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40u;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    operator new();
  }

  sub_1002547D8(v2, a2);
}

void sub_1002E6F30()
{
}

void sub_1002E6F54(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x80u;
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    operator new();
  }

  sub_100255F34(v2, a2);
}

void sub_1002E6FD0()
{
}

void sub_1002E6FF4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 4u;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    operator new();
  }

  sub_1002500E4(v2, a2);
}

void sub_1002E7070()
{
}

void sub_1002E7094(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x100u;
  uint64_t v2 = *(void *)(a1 + 72);
  if (!v2) {
    operator new();
  }

  sub_10024EE10(v2, a2);
}

void sub_1002E7110()
{
}

void sub_1002E7134(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x400u;
  uint64_t v2 = *(void *)(a1 + 88);
  if (!v2) {
    operator new();
  }

  sub_1002563D4(v2, a2);
}

void sub_1002E71B0()
{
}

void sub_1002E71D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x800u;
  uint64_t v2 = *(void *)(a1 + 96);
  if (!v2) {
    operator new();
  }

  sub_100256874(v2, a2);
}

void sub_1002E7250()
{
}

void sub_1002E7274(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x1000u;
  uint64_t v2 = *(void *)(a1 + 104);
  if (!v2) {
    operator new();
  }

  sub_100256D14(v2, a2);
}

void sub_1002E72F0()
{
}

void sub_1002E7314(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x2000u;
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2) {
    operator new();
  }

  sub_1002571B4(v2, a2);
}

void sub_1002E7390()
{
}

void sub_1002E73B4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x4000u;
  uint64_t v2 = *(void *)(a1 + 120);
  if (!v2) {
    operator new();
  }

  sub_100257654(v2, a2);
}

void sub_1002E7430()
{
}

void sub_1002E7454(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x8000u;
  uint64_t v2 = *(void *)(a1 + 128);
  if (!v2) {
    operator new();
  }

  sub_100257E28(v2, a2);
}

void sub_1002E74D0()
{
}

void sub_1002E74F4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10000u;
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2) {
    operator new();
  }

  sub_10025876C(v2, a2);
}

void sub_1002E7570()
{
}

void sub_1002E7594(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20000u;
  uint64_t v2 = *(void *)(a1 + 144);
  if (!v2) {
    operator new();
  }

  sub_100258FF4(v2, a2);
}

void sub_1002E7610()
{
}

void sub_1002E7634(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40000u;
  uint64_t v2 = *(void *)(a1 + 152);
  if (!v2) {
    operator new();
  }

  sub_10025987C(v2, a2);
}

void sub_1002E76B0()
{
}

void sub_1002E76D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x80000u;
  uint64_t v2 = *(void *)(a1 + 160);
  if (!v2) {
    operator new();
  }

  sub_10025A200(v2, a2);
}

void sub_1002E7750()
{
}

void sub_1002E7774(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x100000u;
  uint64_t v2 = *(void *)(a1 + 168);
  if (!v2) {
    operator new();
  }

  sub_10025AA88(v2, a2);
}

void sub_1002E77F0()
{
}

void sub_1002E7814(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x200000u;
  uint64_t v2 = *(void *)(a1 + 176);
  if (!v2) {
    operator new();
  }

  sub_10025B77C(v2, a2);
}

void sub_1002E7890()
{
}

void sub_1002E78B4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x400000u;
  uint64_t v2 = *(void *)(a1 + 184);
  if (!v2) {
    operator new();
  }

  sub_10025C1B8(v2, a2);
}

void sub_1002E7930()
{
}

void sub_1002E7954(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x800000u;
  uint64_t v2 = *(void *)(a1 + 192);
  if (!v2) {
    operator new();
  }

  sub_10025C8AC(v2, a2);
}

void sub_1002E79D0()
{
}

void sub_1002E79F4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x1000000u;
  uint64_t v2 = *(void *)(a1 + 200);
  if (!v2) {
    operator new();
  }

  sub_10025D44C(v2, a2);
}

void sub_1002E7A70()
{
}

void sub_1002E7A94(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x2000000u;
  uint64_t v2 = *(void *)(a1 + 208);
  if (!v2) {
    operator new();
  }

  sub_10025DB40(v2, a2);
}

void sub_1002E7B10()
{
}

void sub_1002E7B34(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x4000000u;
  uint64_t v2 = *(void *)(a1 + 216);
  if (!v2) {
    operator new();
  }

  sub_10025E85C(v2, a2);
}

void sub_1002E7BB0()
{
}

void sub_1002E7BD4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x8000000u;
  uint64_t v2 = *(void *)(a1 + 224);
  if (!v2) {
    operator new();
  }

  sub_100268D5C(v2, a2);
}

void sub_1002E7C50()
{
}

void sub_1002E7C74(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10000000u;
  uint64_t v2 = *(_DWORD **)(a1 + 232);
  if (!v2) {
    operator new();
  }

  sub_100269254(v2, a2);
}

void sub_1002E7CF0()
{
}

void sub_1002E7D14(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20000000u;
  uint64_t v2 = *(void *)(a1 + 240);
  if (!v2) {
    operator new();
  }

  sub_100269710(v2, a2);
}

void sub_1002E7D90()
{
}

void sub_1002E7DB4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40000000u;
  uint64_t v2 = *(void *)(a1 + 248);
  if (!v2) {
    operator new();
  }

  sub_100269F50(v2, a2);
}

void sub_1002E7E30()
{
}

void sub_1002E7E54(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 296) |= 4u;
  uint64_t v2 = *(void *)(a1 + 280);
  if (!v2) {
    operator new();
  }

  sub_10025EF50(v2, a2);
}

void sub_1002E7ED0()
{
}

void sub_1002E7EF4(uint64_t a1@<X0>, id a2@<X1>, uint64_t a3@<X8>)
{
  sub_10023D900((void *)a3);
  if (*(unsigned char *)(a1 + 24))
  {
    int v6 = (const char *)a1;
    if (*(char *)(a1 + 23) < 0) {
      int v6 = *(const char **)a1;
    }
    *(_DWORD *)(a3 + 44) |= 4u;
    int v7 = *(std::string **)(a3 + 16);
    if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v7, (const std::string *)a1);
    if (a2) {
      goto LABEL_7;
    }
LABEL_15:
    id v9 = 0;
    int v8 = 1;
    goto LABEL_22;
  }
  int v6 = "";
  if (!a2) {
    goto LABEL_15;
  }
LABEL_7:
  if ([objc_msgSend(objc_msgSend(a2, "objectForKey:", @"private.MicroLocation.forced.recordingRequest"), "BOOLValue"]) int v8 = 2; {
  else
  }
    int v8 = 1;
  if ([a2 objectForKey:@"private.MicroLocation.truthtag.identifier"])
  {
    id v9 = [a2 objectForKeyedSubscript:@"private.MicroLocation.truthtag.identifier"];
    uint64_t v16 = 0;
    *(void *)unsigned int v17 = 0;
    [v9 getUUIDBytes:&v16];
    *(_DWORD *)(a3 + 44) |= 0x10u;
    char v10 = *(std::string **)(a3 + 32);
    if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v10, (const std::string::value_type *)&v16, 0x10uLL);
  }
  else
  {
    id v9 = 0;
  }
  if ([a2 objectForKey:@"private.MicroLocation.recordingTriggerUUID"])
  {
    a2 = [a2 objectForKeyedSubscript:@"private.MicroLocation.recordingTriggerUUID"];
    uint64_t v16 = 0;
    *(void *)unsigned int v17 = 0;
    [a2 getUUIDBytes:&v16];
    *(_DWORD *)(a3 + 44) |= 8u;
    int v11 = *(std::string **)(a3 + 24);
    if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::assign(v11, (const std::string::value_type *)&v16, 0x10uLL);
  }
  else
  {
    a2 = 0;
  }
LABEL_22:
  if (!sub_10023E7A0(v8)) {
    __assert_rtn("set_recordingrequesttype", "microlocation.pb.h", 13116, "::CLMicroLocationProto::RecordingRequestType_IsValid(value)");
  }
  *(_DWORD *)(a3 + 44) |= 2u;
  *(_DWORD *)(a3 + 12) = v8;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5080);
  }
  uint64_t v12 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    if (v8 == 2) {
      float v13 = "YES";
    }
    else {
      float v13 = "NO";
    }
    if (v9) {
      uint64_t v14 = (const char *)[v9 UUIDString];
    }
    else {
      uint64_t v14 = "";
    }
    if (a2) {
      int v15 = (const char *)[objc_msgSend(a2, "UUIDString") UTF8String];
    }
    else {
      int v15 = "";
    }
    uint64_t v16 = 68290051;
    *(_WORD *)unsigned int v17 = 2082;
    *(void *)&void v17[2] = "";
    __int16 v18 = 2082;
    uint64_t v19 = v6;
    __int16 v20 = 2082;
    std::string v21 = v13;
    __int16 v22 = 2081;
    std::string v23 = v14;
    __int16 v24 = 2082;
    uint64_t v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"client request, recording scan\", \"client\":%{public, location:escape_only}s, \"forced?\":%{public, location:escape_only}s, \"truth label\":%{private, location:escape_only}s, \"recording trigger UUID\":%{public, location:escape_only}s}", (uint8_t *)&v16, 0x3Au);
  }
}

void sub_1002E8260(_Unwind_Exception *a1)
{
  sub_10024E568(v1);
  _Unwind_Resume(a1);
}

id sub_1002E8284(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  id v6 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:v17];
  if (*(unsigned char *)(a4 + 16))
  {
    id v7 = objc_alloc((Class)NSUUID);
    if (!*(unsigned char *)(a4 + 16)) {
      sub_10020D700();
    }
    id v8 = [v7 initWithUUIDBytes:a4];
    id v9 = objc_alloc((Class)NSDictionary);
    if (a1) {
      char v10 = &__kCFBooleanTrue;
    }
    else {
      char v10 = &__kCFBooleanFalse;
    }
    id v11 = [v9 initWithObjectsAndKeys:v10, @"private.MicroLocation.forced.recordingRequest", v6, @"private.MicroLocation.recordingTriggerUUID", v8, @"private.MicroLocation.truthtag.identifier", 0];
  }
  else
  {
    id v12 = objc_alloc((Class)NSDictionary);
    if (a1) {
      float v13 = &__kCFBooleanTrue;
    }
    else {
      float v13 = &__kCFBooleanFalse;
    }
    id v11 = [v12 initWithObjectsAndKeys:v13, @"private.MicroLocation.forced.recordingRequest", v6, @"private.MicroLocation.recordingTriggerUUID", 0, v15, v16];
  }
  return v11;
}

uint64_t sub_1002E83D4@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  int v2 = *(_DWORD *)(result + 128);
  if ((v2 & 4) == 0) {
    goto LABEL_8;
  }
  uint64_t v3 = *(void *)(result + 16);
  if (!v3) {
    uint64_t v3 = *(void *)(qword_102489AC0 + 16);
  }
  if ((*(unsigned char *)(v3 + 44) & 8) != 0)
  {
    int v5 = *(uint64_t ***)(v3 + 24);
  }
  else
  {
LABEL_8:
    if ((v2 & 0x400) == 0) {
      goto LABEL_17;
    }
    uint64_t v4 = *(void *)(result + 88);
    if (!v4) {
      uint64_t v4 = *(void *)(qword_102489AC0 + 88);
    }
    if ((*(unsigned char *)(v4 + 44) & 8) == 0) {
      goto LABEL_17;
    }
    int v5 = *(uint64_t ***)(v4 + 24);
  }
  int v6 = *((char *)v5 + 23);
  if (v6 < 0)
  {
    if (v5[1] != (uint64_t *)16)
    {
LABEL_17:
      char v7 = 0;
      *a2 = 0;
      goto LABEL_18;
    }
    int v5 = (uint64_t **)*v5;
  }
  else if (v6 != 16)
  {
    goto LABEL_17;
  }
  *(_OWORD *)a2 = *(_OWORD *)v5;
  char v7 = 1;
LABEL_18:
  a2[16] = v7;
  return result;
}

CFAbsoluteTime sub_1002E8470(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 128) & 2) != 0) {
    return *(double *)(a1 + 8);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5080);
  }
  long long v1 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Event Received without Timestamp!", buf, 2u);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5080);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "static cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationProtobufHelper::getEventReceivedTS(const CLMicroLocationProto::RecordingEvent &)", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  return j__CFAbsoluteTimeGetCurrent_5();
}

void sub_1002E860C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_10023D5C4((uint64_t)v6);
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_10023E734(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_1002E6194((uint64_t)v6, a1);
  sub_100243254(a2, v6);
  *(unsigned char *)(a2 + 80) = 1;
  sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_1002E86BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_1002E86D0(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 64))
  {
    case 1:
      uint64_t v1 = *(void *)(a1 + 16);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 16);
      }
      goto LABEL_14;
    case 2:
      uint64_t v1 = *(void *)(a1 + 24);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 24);
      }
      goto LABEL_14;
    case 3:
      uint64_t v1 = *(void *)(a1 + 32);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 32);
      }
      goto LABEL_14;
    case 4:
      uint64_t v1 = *(void *)(a1 + 40);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 40);
      }
      goto LABEL_14;
    case 5:
      uint64_t v1 = *(void *)(a1 + 48);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 48);
      }
      goto LABEL_14;
    case 6:
      uint64_t v1 = *(void *)(a1 + 56);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_102489958 + 56);
      }
LABEL_14:
      double result = *(float *)(v1 + 20);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1002E87CC(uint64_t a1, uint64_t a2)
{
  return sub_10006DF94();
}

unsigned char *sub_1002E8808@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (char *)operator new(0x28uLL);
  *(void *)a2 = v4;
  *(_OWORD *)(a2 + ++*(void *)(result + 8) = xmmword_101D048C0;
  *(_OWORD *)int v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(void *)(v4 + 29) = 0;
  return sub_1001E0650(a1, v4);
}

void sub_1002E8868(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

double sub_1002E887C(int a1)
{
  double result = -110.0;
  if (((a1 - 2) & 0xFFFFFFFB) == 0) {
    return 20.0;
  }
  return result;
}

void *sub_1002E8898@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if ((result - 2) >= 2)
  {
    if (result == 1)
    {
      if ((byte_102489B6F & 0x80000000) == 0)
      {
        int v2 = &xmmword_102489B58;
        goto LABEL_9;
      }
      uint64_t v3 = &xmmword_102489B58;
    }
    else
    {
      if ((byte_102489B57 & 0x80000000) == 0)
      {
        int v2 = &xmmword_102489B40;
        goto LABEL_9;
      }
      uint64_t v3 = &xmmword_102489B40;
    }
  }
  else
  {
    if ((byte_102489B9F & 0x80000000) == 0)
    {
      int v2 = &xmmword_102489B88;
LABEL_9:
      *(_OWORD *)a2 = *v2;
      *(void *)(a2 + 16) = *((void *)v2 + 2);
      return result;
    }
    uint64_t v3 = &xmmword_102489B88;
  }
  return sub_1000DC48C((unsigned char *)a2, *(void **)v3, *((void *)v3 + 1));
}

uint64_t sub_1002E8930(uint64_t *a1)
{
  int v1 = *((unsigned __int8 *)a1 + 23);
  if (*((char *)a1 + 23) < 0)
  {
    uint64_t v7 = a1[1];
    if (v7 != 15) {
      goto LABEL_35;
    }
    int v8 = (uint64_t *)*a1;
    if (*(void *)*a1 == 0x5F4C41434947414DLL && *(void *)(*a1 + 7) == 0x53544E454D4F4D5FLL) {
      return 0;
    }
    uint64_t v10 = *v8;
    uint64_t v11 = *(uint64_t *)((char *)v8 + 7);
    if (v10 == 0x5055535F494D4553 && v11 == 0x4445534956524550) {
      return 1;
    }
    uint64_t v7 = a1[1];
    if (v7 != 15) {
      goto LABEL_35;
    }
    if (*(void *)*a1 == 0x4952414C494D4953 && *(void *)(*a1 + 7) == 0x5453494C5F595449) {
      return 2;
    }
    if ((v1 & 0x80) == 0)
    {
      int v2 = a1;
      if (v1 != 10) {
        goto LABEL_45;
      }
    }
    else
    {
LABEL_35:
      if (v7 != 10) {
        goto LABEL_45;
      }
      int v2 = (uint64_t *)*a1;
    }
  }
  else
  {
    int v2 = a1;
    if (v1 != 10)
    {
      if (v1 != 15) {
        goto LABEL_45;
      }
      if (*a1 != 0x5F4C41434947414DLL || *(uint64_t *)((char *)a1 + 7) != 0x53544E454D4F4D5FLL)
      {
        if (*a1 != 0x5055535F494D4553 || *(uint64_t *)((char *)a1 + 7) != 0x4445534956524550)
        {
          if (*a1 != 0x4952414C494D4953 || *(uint64_t *)((char *)a1 + 7) != 0x5453494C5F595449) {
            goto LABEL_45;
          }
          return 2;
        }
        return 1;
      }
      return 0;
    }
  }
  uint64_t v14 = *v2;
  int v15 = *((unsigned __int16 *)v2 + 4);
  if (v14 != 0x4C54415F45554C42 || v15 != 21313)
  {
LABEL_45:
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5080);
    }
    unsigned int v17 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_FAULT))
    {
      __int16 v18 = a1;
      if (*((char *)a1 + 23) < 0) {
        __int16 v18 = (uint64_t *)*a1;
      }
      *(_DWORD *)long long buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      long long v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v18;
      __int16 v30 = 2082;
      long long v31 = "assert";
      __int16 v32 = 2081;
      std::string v33 = "false";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5080);
      }
    }
    uint64_t v19 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      __int16 v20 = a1;
      if (*((char *)a1 + 23) < 0) {
        __int16 v20 = (uint64_t *)*a1;
      }
      *(_DWORD *)long long buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      long long v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v20;
      __int16 v30 = 2082;
      long long v31 = "assert";
      __int16 v32 = 2081;
      std::string v33 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Can't find a model type that corresponds to string", "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5080);
      }
    }
    std::string v21 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
    {
      __int16 v22 = a1;
      if (*((char *)a1 + 23) < 0) {
        __int16 v22 = (uint64_t *)*a1;
      }
      *(_DWORD *)long long buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      long long v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v22;
      __int16 v30 = 2082;
      long long v31 = "assert";
      __int16 v32 = 2081;
      std::string v33 = "false";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }
    abort_report_np();
    __break(1u);
  }
  return 3;
}

void *sub_1002E8E04@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_1022A5128[a1]);
}

void sub_1002E8E18(void *a1, unsigned __int8 **a2, uint64_t a3)
{
  int v4 = a2;
  int v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v11 = (const char *)[a1 UTF8String];
  LOBYTE(v4) = sub_1002E93EC(v6, v7, &v11) != v4[1];
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1002E8EE4;
  block[3] = &unk_1022A5060;
  char v10 = (char)v4;
  block[4] = a1;
  block[5] = a3;
  dispatch_async(global_queue, block);
}

void sub_1002E8EE4(uint64_t a1)
{
  sub_10023D8A0((uint64_t)v7);
  if (objc_opt_class())
  {
    unsigned __int8 v2 = [[+[AVSystemController sharedAVSystemController](AVSystemController, "sharedAVSystemController") hasRouteSharingPolicyLongFormVideo:*(void *)(a1 + 32)];
    int v3 = v8 | 1;
    unsigned char v7[8] = v2;
  }
  else
  {
    int v3 = v8;
  }
  char v4 = *(unsigned char *)(a1 + 48);
  int v8 = v3 | 2;
  v7[9] = v4;
  uint64_t v5 = *(void *)(a1 + 40);
  sub_10024D304(v6, v7);
  (*(void (**)(uint64_t, unsigned char *))(v5 + 16))(v5, v6);
  sub_10024D308((wireless_diagnostics::google::protobuf::MessageLite *)v6);
  sub_10024D308((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_1002E8F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

CFStringRef sub_1002E8FB0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 72);
  CFStringRef result = @"receivedEventAction";
  switch(v1)
  {
    case 1:
      return result;
    case 2:
      CFStringRef result = @"appLaunch";
      break;
    case 3:
    case 6:
    case 8:
    case 11:
      goto LABEL_6;
    case 4:
      CFStringRef result = @"backlightOn";
      break;
    case 5:
      CFStringRef result = @"batteryChargerConnected";
      break;
    case 7:
      CFStringRef result = @"forcedRecording";
      break;
    case 9:
      CFStringRef result = @"homekitAccessory";
      break;
    case 10:
      CFStringRef result = @"homekitScene";
      break;
    case 12:
      CFStringRef result = @"nowPlaying";
      break;
    case 13:
      CFStringRef result = @"recordingRequest";
      break;
    case 14:
      CFStringRef result = @"truthLabelDonation";
      break;
    default:
      if (v1 == 42)
      {
        CFStringRef result = @"RequestObservation";
      }
      else if (v1 == 43)
      {
        CFStringRef result = @"RequestPrediction";
      }
      else
      {
LABEL_6:
        CFStringRef result = @"triggerInvalid";
      }
      break;
  }
  return result;
}

void *sub_1002E90C0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_100134750(a2, off_1022A5148[a1]);
}

uint64_t sub_1002E90D4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1) {
    return (*(unsigned __int8 *)(a1 + 81) >> 4) & 1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1002E90F4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1) {
    return *(unsigned __int8 *)(a1 + 81) >> 7;
  }
  else {
    return 0;
  }
}

void sub_1002E9114(void *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1002E9238(a2, 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[1] - *a1) >> 3));
  char v4 = (int *)a1[1];
  if ((int *)*a1 != v4)
  {
    uint64_t v5 = (int *)(*a1 + 48);
    do
    {
      sub_1002E860C((uint64_t)(v5 - 12), (uint64_t)v9);
      if (v10)
      {
        unint64_t v6 = a2[1];
        if (v6 >= a2[2])
        {
          uint64_t v7 = sub_1002E9518(a2, (uint64_t)v9, v5);
        }
        else
        {
          sub_1002E9640(a2[1], (uint64_t)v9, *v5);
          uint64_t v7 = v6 + 88;
          a2[1] = v6 + 88;
        }
        a2[1] = v7;
        if (v10) {
          sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)v9);
        }
      }
      int v8 = v5 + 2;
      v5 += 14;
    }
    while (v8 != v4);
  }
}

void sub_1002E91F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100221EA8((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E9238(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
      sub_1001D7FD4();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_1000DA8B4(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 88 * v6;
    sub_1002E94A0(a1, v7);
    return sub_10022334C((uint64_t)v7);
  }
  return result;
}

void sub_1002E92E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10022334C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002E92F8(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1002E9328(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000E6574();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *std::string __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void sub_1002E93D4()
{
}

unsigned __int8 *sub_1002E93EC(unsigned __int8 *a1, unsigned __int8 *a2, const char **a3)
{
  int v3 = a1;
  if (a1 != a2)
  {
    uint64_t v5 = *a3;
    size_t v6 = strlen(*a3);
    while (1)
    {
      if ((char)v3[23] < 0)
      {
        if (v6 == *((void *)v3 + 1))
        {
          if (v6 == -1) {
LABEL_14:
          }
            sub_1002E93D4();
          size_t v7 = *(unsigned __int8 **)v3;
LABEL_10:
          if (!memcmp(v7, v5, v6)) {
            return v3;
          }
        }
      }
      else if (v6 == v3[23])
      {
        size_t v7 = v3;
        if (v6 == -1) {
          goto LABEL_14;
        }
        goto LABEL_10;
      }
      v3 += 24;
      if (v3 == a2) {
        return a2;
      }
    }
  }
  return v3;
}

uint64_t sub_1002E94A0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10022320C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002E9518(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_1001D7FD4();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x1745D1745D1745DLL) {
    unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v19 = a1 + 2;
  if (v11) {
    id v12 = (char *)sub_1000DA8B4(v9, v11);
  }
  else {
    id v12 = 0;
  }
  int v15 = v12;
  uint64_t v16 = &v12[88 * v5];
  uint64_t v17 = (uint64_t)v16;
  __int16 v18 = &v12[88 * v11];
  sub_1002E9640((uint64_t)v16, a2, *a3);
  uint64_t v17 = (uint64_t)(v16 + 88);
  sub_1002E94A0(a1, &v15);
  uint64_t v13 = a1[1];
  sub_10022334C((uint64_t)&v15);
  return v13;
}

void sub_1002E962C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10022334C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E9640(uint64_t a1, uint64_t a2, int a3)
{
  sub_10023D5C4(a1);
  *(_DWORD *)(v6 + 80) = a3;
  sub_10024433C(v6, a2);
  return a1;
}

void sub_1002E9684(_Unwind_Exception *a1)
{
  sub_1002433A8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E9698()
{
  sub_100134750(&xmmword_102489B40, "com.apple.magicalmoments");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102489B40, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_102489B58, "com.apple.microlocation.semisupervised");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102489B58, (void *)&_mh_execute_header);
  sub_100134750(&qword_102489B70, "com.apple.microlocation.homeloi");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_102489B70, (void *)&_mh_execute_header);
  sub_100134750(&xmmword_102489B88, "com.apple.microlocation.similarity");

  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102489B88, (void *)&_mh_execute_header);
}

void sub_1002E9780(uint64_t a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "not running";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BLE spyscan session set to %{public}s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setBleSpyscanSessionRunning(BOOL)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  *(unsigned char *)(a1 + 160) = a2;
}

void sub_1002E9964(uint64_t a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "stopped";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ranging session set to %{public}s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setRangingSessionRunning(BOOL)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  *(unsigned char *)(a1 + 161) = a2;
}

uint64_t sub_1002E9B48(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 264);
}

void sub_1002E9B50(uint64_t a1, int a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "stopped";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Motion fence set to %{public}s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setMotionSessionState(BOOL)", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  *(unsigned char *)(a1 + 162) = a2;
}

void sub_1002E9D34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_1022A51A0;
  sub_10023DFC0(a1 + 8);
  *(unsigned char *)(a1 + 145) = 2;
  *(unsigned char *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 16++*(void *)(result + 8) = 0;
  *(unsigned char *)(a1 + 170) = 0;
  sub_1000E23EC((unsigned char *)(a1 + 176), (uint64_t)&byte_10248AB18);
  *(_WORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 28++*(void *)(result + 8) = 0xFFEFFFFFFFFFFFFFLL;
  *(unsigned char *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = a2;
  *(void *)(a1 + 312) = a3;
  sub_1002A5E6C(a1 + 320, a1);
}

void sub_1002EA064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24)
{
  if (a23) {
    sub_1000DB0A0(a23);
  }
  sub_1002F2F70(v26 + 816);
  a24 = v26 + 784;
  sub_1002F2ED0((void ***)&a24);
  sub_1002EA174(v28);
  sub_1002EA174(v27);
  sub_1002F2E4C((void ***)&a24);
  sub_1002A8A40(v25);
  sub_1002EA1B4(v24);
  _Unwind_Resume(a1);
}

void sub_1002EA13C()
{
}

void sub_1002EA158()
{
}

uint64_t sub_1002EA174(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  sub_1002F2764(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

uint64_t sub_1002EA1B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 256) && *(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }

  return sub_10026633C(a1);
}

uint64_t sub_1002EA204(uint64_t a1)
{
  *(void *)a1 = off_1022A51A0;
  if (*(unsigned char *)(a1 + 808) == 1 || *(unsigned char *)(a1 + 809) == 1)
  {
    sub_1002A7780(a1 + 320);
    *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unsigned __int8 v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationSensorsLogic: DTOR", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sub_1002F2F70(a1 + 816);
  *(void *)long long buf = a1 + 784;
  sub_1002F2ED0((void ***)buf);
  if (*(char *)(a1 + 767) < 0) {
    operator delete(*(void **)(a1 + 744));
  }
  sub_1002F2764(a1 + 720, *(void **)(a1 + 728));
  if (*(char *)(a1 + 703) < 0) {
    operator delete(*(void **)(a1 + 680));
  }
  sub_1002F2764(a1 + 656, *(void **)(a1 + 664));
  *(void *)long long buf = a1 + 608;
  sub_1002F2E4C((void ***)buf);
  sub_1002A8A40(a1 + 320);
  if (*(unsigned char *)(a1 + 264) && *(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  sub_10026633C(a1 + 8);
  return a1;
}

void sub_1002EA464(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1001C7F8C(a1);
}

void sub_1002EA474(uint64_t a1)
{
  sub_1002EA204(a1);

  operator delete();
}

uint64_t sub_1002EA4AC(uint64_t a1)
{
  return sub_1002A68B4(a1 + 320);
}

uint64_t sub_1002EA4B4(unsigned char *a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unsigned __int8 v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "cancel a requested Ble and WiFi scan", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted()", "%s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  if (a1[809] == 1)
  {
    int v3 = a1[808];
    sub_1002A7780((uint64_t)(a1 + 320));
    *((_WORD *)a1 + 404) = 0;
    if (v3 == 2) {
      sub_1002EA694((uint64_t)a1);
    }
  }
  uint64_t result = sub_1002A6750((uint64_t)(a1 + 320));
  if (a1[296])
  {
    uint64_t result = sub_1002A7C80((uint64_t)(a1 + 320));
    a1[296] = 0;
  }
  return result;
}

void sub_1002EA694(uint64_t a1)
{
  char v2 = sub_1002EB064(a1);
  memset(v5, 0, sizeof(v5));
  sub_1002F3070(v5, *(id **)(a1 + 784), *(id **)(a1 + 792), (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3);
  __n128 v3 = 0uLL;
  uint64_t v4 = 0;
  sub_10027575C((uint64_t)v6, 0, 1, v2, (uint64_t)v5, &v3, 0.0);
  uint64_t v9 = &v3;
  sub_1000A7B4C((void ***)&v9);
  uint64_t v9 = (__n128 *)v5;
  sub_1002F2ED0((void ***)&v9);
  sub_1002EB344(a1, (uint64_t)v6);
  uint64_t v9 = (__n128 *)&v8;
  sub_1000A7B4C((void ***)&v9);
  uint64_t v9 = (__n128 *)&v7;
  sub_1002F2ED0((void ***)&v9);
}

void sub_1002EA764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1002EB640((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1002EA798(void *result, void *a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = result;
    [a2 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (uint64_t)(v5[99] - v5[98]) >> 3) forKeyedSubscript:@"BleIdentitiesFamilyCount"];
    [a2 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5[105]) forKeyedSubscript:@"BleIdentitiesSameAccountCount"];
    [a2 setObject:+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5[105] + ((uint64_t)(v5[99] - v5[98]) >> 3)) forKeyedSubscript:@"BleIdentitiesTotal"];
    uint64_t v6 = +[NSNumber numberWithBool:a3];
    return [a2 setObject:v6 forKeyedSubscript:@"BleIsScanRequested"];
  }
  return result;
}

void sub_1002EA87C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 872) = *a2;
  sub_1000C7F88(&v8);
  int v7 = 0;
  CFStringRef v3 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleActiveScanRate", 0x8000100u, kCFAllocatorNull);
  int v4 = sub_10013E418(v8, (uint64_t)v3, &v7);
  CFRelease(v3);
  int v5 = v7;
  if (v9) {
    sub_1000DB0A0(v9);
  }
  if (v4) {
    int v6 = v5;
  }
  else {
    int v6 = 40;
  }
  *(_DWORD *)(a1 + 880) = v6;
}

void sub_1002EA928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002EA944(uint64_t a1)
{
  char v2 = (uint64_t *)sub_1002A8834(a1 + 320);
  sub_1001F6F78((uint64_t)v4, v2);
  CFStringRef v3 = (void *)sub_1002CAC98((uint64_t)v4);
  *(double *)(a1 + 864) = *(double *)(a1 + 864) + (double)(unint64_t)((uint64_t)(v3[1] - *v3) >> 2) * 0.11;
  if (v8 < 0) {
    operator delete(__p);
  }
  if (v5)
  {
    int v6 = v5;
    operator delete(v5);
  }
}

void sub_1002EA9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002EA9E4(void *a1, uint64_t a2, char a3, uint64_t *a4, void *a5)
{
  sub_100267D64((uint64_t)(a1 + 1), a2);
  *((unsigned char *)a1 + 144) = a3;
  *((unsigned char *)a1 + 145) = 0;
  uint64_t v9 = *a4;
  if (!*((unsigned char *)a1 + 160)) {
    *((unsigned char *)a1 + 160) = 1;
  }
  a1[19] = v9;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unint64_t v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    sub_100275744(a3, &__p);
    if (!*((unsigned char *)a1 + 160)) {
      sub_10020D700();
    }
    p_p = &__p;
    if (v42 < 0) {
      p_p = __p;
    }
    uint64_t v12 = a1[19];
    *(_DWORD *)long long buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)char v47 = 2082;
    *(void *)&void v47[2] = "";
    *(_WORD *)&v47[10] = 2082;
    *(void *)&v47[12] = p_p;
    __int16 v48 = 2050;
    uint64_t v49 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, started activity\", \"ActivityType\":%{public, location:escape_only}s, \"recOrLocStartTime_s\":\"%{public}.09f\"}", buf, 0x26u);
    if (SHIBYTE(v42) < 0) {
      operator delete(__p);
    }
  }
  sub_1000C7F88(buf);
  LOBYTE(__p) = 0;
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateRateEnabled", 0x8000100u, kCFAllocatorNull);
  char v14 = sub_1000D29FC(*(uint64_t *)buf, (uint64_t)v13, (BOOL *)&__p);
  CFRelease(v13);
  int v15 = __p;
  if (*(void *)v47) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v47);
  }
  if (v15) {
    char v16 = 0;
  }
  else {
    char v16 = v14;
  }
  if ((v16 & 1) == 0)
  {
    sub_1000C7F88(buf);
    LODWORD(__p) = 0;
    CFStringRef v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateRate", 0x8000100u, kCFAllocatorNull);
    int v18 = sub_10013E418(*(uint64_t *)buf, (uint64_t)v17, &__p);
    CFRelease(v17);
    uint64_t v19 = (int)__p;
    if (*(void *)v47) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v47);
    }
    if (v18) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = 1;
    }
    sub_1000C7F88(buf);
    *(double *)&long long __p = 0.0;
    CFStringRef v21 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateDuration", 0x8000100u, kCFAllocatorNull);
    int v22 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v21, &__p);
    CFRelease(v21);
    std::string v23 = __p;
    if (*(void *)v47) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v47);
    }
    double v24 = 2.5;
    if (v22) {
      double v24 = *(double *)&v23;
    }
    *(void *)long long buf = v20;
    *(double *)char v47 = v24;
    sub_1002A7B50((uint64_t)(a1 + 40), (uint64_t *)buf);
    *((unsigned char *)a1 + 296) = 1;
  }
  *(double *)&long long __p = 0.0;
  std::string v41 = 0;
  uint64_t v25 = (void *)a1[104];
  uint64_t v42 = 0;
  for (i = &__p; v25; uint64_t v25 = (void *)*v25)
  {
    uint64_t v26 = (char *)operator new(0x28uLL);
    *(void *)long long buf = v26;
    *(_OWORD *)char v47 = xmmword_101D048C0;
    *(_OWORD *)uint64_t v26 = 0u;
    *((_OWORD *)v26 + 1) = 0u;
    *(void *)(v26 + 29) = 0;
    sub_1001E0650((uint64_t)(v25 + 2), v26);
    sub_1002748CC((uint64_t **)&i, (long long *)buf);
    if ((v47[15] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1000C7F88(&i);
  double v45 = 0.0;
  CFStringRef v27 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleRequestedScanLength", 0x8000100u, kCFAllocatorNull);
  int v28 = sub_1000A6A10((uint64_t)i, (uint64_t)v27, &v45);
  CFRelease(v27);
  double v29 = v45;
  if (v44) {
    sub_1000DB0A0(v44);
  }
  if (!v28) {
    double v29 = 1.6;
  }
  char v30 = sub_1002EB064((uint64_t)a1);
  memset(v39, 0, sizeof(v39));
  sub_1002F3070(v39, (id *)a1[98], (id *)a1[99], (uint64_t)(a1[99] - a1[98]) >> 3);
  __n128 v37 = 0uLL;
  uint64_t v38 = 0;
  sub_1001D857C((char *)&v37, (long long *)__p, v41, 0xAAAAAAAAAAAAAAABLL * (((char *)v41 - (unsigned char *)__p) >> 3));
  sub_10027575C((uint64_t)buf, a3, 0, v30, (uint64_t)v39, &v37, v29);
  uint64_t i = (void **)&v37;
  sub_1000A7B4C(&i);
  uint64_t i = v39;
  sub_1002F2ED0(&i);
  int v31 = *((unsigned __int8 *)a1 + 808);
  sub_1000C7F88(&i);
  LOBYTE(v45) = 0;
  CFStringRef v32 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleRequestedScanEnabled", 0x8000100u, kCFAllocatorNull);
  char v33 = sub_1000D29FC((uint64_t)i, (uint64_t)v32, (BOOL *)&v45);
  CFRelease(v32);
  int v34 = LOBYTE(v45);
  if (v44) {
    sub_1000DB0A0(v44);
  }
  if (v34) {
    char v35 = 0;
  }
  else {
    char v35 = v33;
  }
  if ((v35 & 1) != 0 || !sub_1002EB064((uint64_t)a1) && __p == v41)
  {
    sub_1002EB1A4((uint64_t)a1, v31 == 1);
    (*(void (**)(void *))(*a1 + 64))(a1);
    uint64_t v36 = 0;
  }
  else
  {
    sub_1002A7780((uint64_t)(a1 + 40));
    *((_WORD *)a1 + 404) = 0;
    sub_1002EB1A4((uint64_t)a1, v31 == 1);
    sub_1002EB344((uint64_t)a1, (uint64_t)buf);
    uint64_t v36 = 1;
  }
  sub_1002EA798(a1, a5, v36);
  uint64_t i = (void **)&v50;
  sub_1000A7B4C(&i);
  uint64_t i = (void **)&v47[8];
  sub_1002F2ED0(&i);
  *(void *)long long buf = &__p;
  sub_1000A7B4C((void ***)buf);
}

void sub_1002EAF6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,int a28,__int16 a29,char a30,char a31)
{
  if (a27) {
    sub_1000DB0A0(a27);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002EB064(uint64_t a1)
{
  BOOL v2 = *(void *)(a1 + 784) != *(void *)(a1 + 792) && *(unsigned char *)(a1 + 170) != 0;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  CFStringRef v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3;
    uint64_t v5 = *(unsigned __int8 *)(a1 + 170);
    v7[0] = 68289794;
    v7[1] = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 1026;
    BOOL v11 = v2;
    __int16 v12 = 2050;
    uint64_t v13 = v4;
    __int16 v14 = 2050;
    uint64_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, shouldScanNearbyInfoV2\", \"should scan?\":%{public}hhd, \"num of entries in oObkey\":%{public}lu, \"is motion session running?\":%{public}lu}", (uint8_t *)v7, 0x2Cu);
  }
  return v2;
}

void sub_1002EB1A4(uint64_t a1, int a2)
{
  if (a2)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    CFStringRef v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setting BLE background-scan session status to paused", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::pauseBackgroundBleSessionIfNeeded(const BOOL)", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    *(unsigned char *)(a1 + 80++*(void *)(result + 8) = 2;
  }
}

uint64_t sub_1002EB344(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 9))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Register for BLE background-scan session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    *(unsigned char *)(a1 + 80++*(void *)(result + 8) = 1;
  }
  else
  {
    sub_1002EA87C(a1, (void *)a2);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Register for BLE initiated-scan session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      __int16 v8 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    *(unsigned char *)(a1 + 809) = 1;
  }
  return sub_1002A75A0(a1 + 320, a2);
}

uint64_t sub_1002EB640(uint64_t a1)
{
  CFStringRef v3 = (void **)(a1 + 40);
  sub_1000A7B4C(&v3);
  CFStringRef v3 = (void **)(a1 + 16);
  sub_1002F2ED0(&v3);
  return a1;
}

void sub_1002EB68C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 296))
  {
    sub_1002A7C80(a1 + 320);
    *(unsigned char *)(a1 + 296) = 0;
  }
  sub_1002EB75C(a1, v3);
  sub_10030D1A8(*(uint64_t **)(a1 + 304), v3);
  sub_1002EC6F0(a1, (uint64_t *)v2);
  sub_10030D1A8(*(uint64_t **)(a1 + 304), (uint64_t *)v2);
  if (*(unsigned char *)(a1 + 160)) {
    *(unsigned char *)(a1 + 160) = 0;
  }
  uint64_t v4 = v2;
  sub_100221EA8((void ***)&v4);
  v2[0] = (void **)v3;
  sub_100221EA8(v2);
}

void sub_1002EB728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 24) = v13;
  sub_100221EA8((void ***)(v14 - 24));
  a10 = (void **)&a13;
  sub_100221EA8(&a10);
  _Unwind_Resume(a1);
}

void sub_1002EB75C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 160))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v14 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
    }
    uint64_t v15 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!", "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (!*(unsigned char *)(a1 + 160)) {
    sub_10020D700();
  }
  double v5 = Current_5;
  double v6 = Current_5 - *(double *)(a1 + 152);
  sub_1002ED16C();
  double v99 = 0.0;
  __int16 v8 = &qword_102419000;
  uint64_t v9 = &qword_102419000;
  if (v6 < v7)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    char v16 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&uint8_t buf[18] = 2050;
      *(double *)&buf[20] = v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BLE Scan duration\", \"duration\":\"%{public}.5f\"}", buf, 0x1Cu);
    }
    if (!*(unsigned char *)(a1 + 160)) {
      sub_10020D700();
    }
    sub_1000C7F88(buf);
    *(void *)long long v100 = 0;
    CFStringRef v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleScanMaximalAgeForValidityFromScanStart", 0x8000100u, kCFAllocatorNull);
    unint64_t v12 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v17, v100);
    CFRelease(v17);
    double v18 = *(double *)v100;
    if (*(void *)&buf[8]) {
      sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
    }
    double v19 = 1.0;
    if (v12) {
      double v19 = v18;
    }
    double v13 = *(double *)(a1 + 152) - v19;
  }
  else
  {
    double v10 = v7;
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    BOOL v11 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&uint8_t buf[18] = 2050;
      *(double *)&buf[20] = v6;
      __int16 v109 = 2050;
      double v110 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
    }
    unint64_t v12 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&uint8_t buf[18] = 2050;
      *(double *)&buf[20] = v6;
      __int16 v109 = 2050;
      double v110 = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, (os_log_t)v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Scan duration is exceeded threshold", "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
    }
    double v13 = v5 - v10;
  }
  double v99 = v13;
  char v98 = 0;
  sub_1002ED224(a1 + 648, &v99, &v98, &v96);
  *(_OWORD *)long long __p = 0u;
  long long v94 = 0u;
  float v95 = 1.0;
  uint64_t v20 = v96;
  uint64_t v21 = v97;
  char v90 = a2;
  if (v96 == v97)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_159;
  }
  do
  {
    if ((*(unsigned char *)(v20 + 72) & 0x40) == 0) {
      goto LABEL_140;
    }
    uint64_t v22 = *(void *)(v20 + 48);
    if (!v22) {
      uint64_t v22 = *(void *)(qword_102489958 + 48);
    }
    double v23 = *(double *)(v22 + 8);
    float v24 = *(float *)(v22 + 20);
    unint64_t v25 = sub_10011116C((uint64_t)v100, *(char **)(v22 + 48));
    unint64_t v26 = 0xC6A4A7935BD1E995 * LODWORD(v24);
    if (v24 == 0.0) {
      unint64_t v26 = 0;
    }
    unint64_t v27 = 0xC6A4A7935BD1E995 * (v26 ^ (v26 >> 47));
    unint64_t v28 = 0xC6A4A7935BD1E995 * *(void *)&v23;
    if (v23 == 0.0) {
      unint64_t v28 = 0;
    }
    unint64_t v29 = (0xC6A4A7935BD1E995 * (v27 ^ (0x35A98F4D286A90B9 * (v28 ^ (v28 >> 47)) + 3864292196u)) + 3864292196u) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v25) ^ ((0xC6A4A7935BD1E995 * v25) >> 47)));
    unint64_t v30 = 0xC6A4A7935BD1E995 * v29 + 3864292196u;
    unint64_t v31 = (unint64_t)__p[1];
    if (__p[1])
    {
      uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v32.i16[0] = vaddlv_u8(v32);
      unint64_t v33 = v32.u32[0];
      if (v32.u32[0] > 1uLL)
      {
        unint64_t v12 = 0xC6A4A7935BD1E995 * v29 + 3864292196u;
        if ((void *)v30 >= __p[1]) {
          unint64_t v12 = v30 % (unint64_t)__p[1];
        }
      }
      else
      {
        unint64_t v12 = ((unint64_t)__p[1] - 1) & v30;
      }
      int v34 = (void *)*((void *)__p[0] + v12);
      if (v34)
      {
        char v35 = (void *)*v34;
        if (*v34)
        {
          uint64_t v36 = qword_102489958;
          while (1)
          {
            unint64_t v37 = v35[1];
            if (v37 == v30) {
              break;
            }
            if (v33 > 1)
            {
              if ((void *)v37 >= __p[1]) {
                v37 %= (unint64_t)__p[1];
              }
            }
            else
            {
              v37 &= (unint64_t)__p[1] - 1;
            }
            if (v37 != v12) {
              goto LABEL_84;
            }
LABEL_78:
            char v35 = (void *)*v35;
            if (!v35) {
              goto LABEL_84;
            }
          }
          uint64_t v38 = *(void *)(v35[2] + 48);
          uint64_t v39 = v38;
          if (!v38) {
            uint64_t v39 = *(void *)(v36 + 48);
          }
          uint64_t v40 = *(void *)(v20 + 48);
          uint64_t v41 = v40;
          if (!v40) {
            uint64_t v41 = *(void *)(v36 + 48);
          }
          if (*(double *)(v39 + 8) != *(double *)(v41 + 8)) {
            goto LABEL_78;
          }
          uint64_t v42 = *(void *)(v35[2] + 48);
          if (!v38) {
            uint64_t v42 = *(void *)(v36 + 48);
          }
          uint64_t v43 = *(void *)(v20 + 48);
          if (!v40) {
            uint64_t v43 = *(void *)(v36 + 48);
          }
          if (*(float *)(v42 + 20) != *(float *)(v43 + 20)) {
            goto LABEL_78;
          }
          if (v38)
          {
            if (v40) {
              goto LABEL_59;
            }
          }
          else
          {
            uint64_t v38 = *(void *)(v36 + 48);
            if (v40) {
              goto LABEL_59;
            }
          }
          uint64_t v40 = *(void *)(v36 + 48);
LABEL_59:
          int64_t v44 = *(unsigned __int8 **)(v38 + 48);
          double v45 = *(unsigned __int8 **)(v40 + 48);
          uint64_t v46 = v44[23];
          if ((v46 & 0x80u) == 0) {
            uint64_t v47 = v44[23];
          }
          else {
            uint64_t v47 = *((void *)v44 + 1);
          }
          uint64_t v48 = v45[23];
          int v49 = (char)v48;
          if ((v48 & 0x80u) != 0) {
            uint64_t v48 = *((void *)v45 + 1);
          }
          if (v47 == v48)
          {
            if (v49 >= 0) {
              uint64_t v50 = v45;
            }
            else {
              uint64_t v50 = *(unsigned __int8 **)v45;
            }
            if ((v46 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)v44, v50, *((void *)v44 + 1))) {
                goto LABEL_140;
              }
            }
            else
            {
              if (!v44[23]) {
                goto LABEL_140;
              }
              while (*v44 == *v50)
              {
                ++v44;
                ++v50;
                if (!--v46) {
                  goto LABEL_140;
                }
              }
            }
          }
          goto LABEL_78;
        }
      }
    }
LABEL_84:
    std::string v51 = operator new(0x18uLL);
    *std::string v51 = 0;
    v51[1] = v30;
    v51[2] = v20;
    float v52 = (float)(unint64_t)(*((void *)&v94 + 1) + 1);
    if (!v31 || (float)(v95 * (float)v31) < v52)
    {
      BOOL v53 = (v31 & (v31 - 1)) == 0;
      if (v31 < 3) {
        BOOL v53 = 0;
      }
      unint64_t v54 = (2 * v31) | !v53;
      unint64_t v55 = vcvtps_u32_f32(v52 / v95);
      if (v54 <= v55) {
        int8x8_t prime = (int8x8_t)v55;
      }
      else {
        int8x8_t prime = (int8x8_t)v54;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v31 = (unint64_t)__p[1];
      }
      if (*(void *)&prime > v31) {
        goto LABEL_96;
      }
      if (*(void *)&prime < v31)
      {
        unint64_t v63 = vcvtps_u32_f32((float)*((unint64_t *)&v94 + 1) / v95);
        if (v31 < 3 || (uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v31), v64.i16[0] = vaddlv_u8(v64), v64.u32[0] > 1uLL))
        {
          unint64_t v63 = std::__next_prime(v63);
        }
        else
        {
          uint64_t v65 = 1 << -(char)__clz(v63 - 1);
          if (v63 >= 2) {
            unint64_t v63 = v65;
          }
        }
        if (*(void *)&prime <= v63) {
          int8x8_t prime = (int8x8_t)v63;
        }
        if (*(void *)&prime >= v31)
        {
          unint64_t v31 = (unint64_t)__p[1];
        }
        else
        {
          if (prime)
          {
LABEL_96:
            if (*(void *)&prime >> 61) {
              sub_1001D7FA0();
            }
            uint64_t v57 = operator new(8 * *(void *)&prime);
            std::string::size_type v58 = __p[0];
            __p[0] = v57;
            if (v58) {
              operator delete(v58);
            }
            uint64_t v59 = 0;
            __p[1] = (void *)prime;
            do
              *((void *)__p[0] + v59++) = 0;
            while (*(void *)&prime != v59);
            __int16 v60 = (void **)v94;
            if ((void)v94)
            {
              unint64_t v61 = *(void *)(v94 + 8);
              uint8x8_t v62 = (uint8x8_t)vcnt_s8(prime);
              v62.i16[0] = vaddlv_u8(v62);
              if (v62.u32[0] > 1uLL)
              {
                if (v61 >= *(void *)&prime) {
                  v61 %= *(void *)&prime;
                }
              }
              else
              {
                v61 &= *(void *)&prime - 1;
              }
              *((void *)__p[0] + v61) = &v94;
              for (i = *v60; i; unint64_t v61 = v67)
              {
                unint64_t v67 = i[1];
                if (v62.u32[0] > 1uLL)
                {
                  if (v67 >= *(void *)&prime) {
                    v67 %= *(void *)&prime;
                  }
                }
                else
                {
                  v67 &= *(void *)&prime - 1;
                }
                if (v67 != v61)
                {
                  if (!*((void *)__p[0] + v67))
                  {
                    *((void *)__p[0] + v67) = v60;
                    goto LABEL_121;
                  }
                  *__int16 v60 = (void *)*i;
                  void *i = **((void **)__p[0] + v67);
                  **((void **)__p[0] + v67) = i;
                  uint64_t i = v60;
                }
                unint64_t v67 = v61;
LABEL_121:
                __int16 v60 = (void **)i;
                uint64_t i = (void *)*i;
              }
            }
            unint64_t v31 = (unint64_t)prime;
            goto LABEL_125;
          }
          unsigned int v71 = __p[0];
          __p[0] = 0;
          if (v71) {
            operator delete(v71);
          }
          unint64_t v31 = 0;
          __p[1] = 0;
        }
      }
LABEL_125:
      if ((v31 & (v31 - 1)) != 0)
      {
        if (v30 >= v31) {
          unint64_t v12 = v30 % v31;
        }
        else {
          unint64_t v12 = v30;
        }
      }
      else
      {
        unint64_t v12 = (v31 - 1) & v30;
      }
    }
    unsigned int v68 = __p[0];
    long long v69 = (void *)*((void *)__p[0] + v12);
    if (v69)
    {
      *std::string v51 = *v69;
LABEL_138:
      *long long v69 = v51;
      goto LABEL_139;
    }
    *std::string v51 = v94;
    *(void *)&long long v94 = v51;
    v68[v12] = &v94;
    if (*v51)
    {
      unint64_t v70 = *(void *)(*v51 + 8);
      if ((v31 & (v31 - 1)) != 0)
      {
        if (v70 >= v31) {
          v70 %= v31;
        }
      }
      else
      {
        v70 &= v31 - 1;
      }
      long long v69 = (char *)__p[0] + 8 * v70;
      goto LABEL_138;
    }
LABEL_139:
    ++*((void *)&v94 + 1);
LABEL_140:
    v20 += 80;
  }
  while (v20 != v21);
  uint64_t v72 = (void *)v94;
  a2 = v90;
  v90[1] = 0;
  _OWORD v90[2] = 0;
  uint64_t *v90 = 0;
  uint64_t v9 = &qword_102419000;
  __int16 v8 = &qword_102419000;
  if (v72)
  {
    unint64_t v73 = 0;
    do
    {
      uint64_t v74 = v72[2];
      if (v73 >= v90[2])
      {
        unint64_t v73 = sub_1002F35D4(v90, v74);
      }
      else
      {
        sub_100243254(v73, v74);
        *(_DWORD *)(v73 + 80) = 0;
        v73 += 88;
        v90[1] = v73;
      }
      v90[1] = v73;
      uint64_t v72 = (void *)*v72;
    }
    while (v72);
  }
LABEL_159:
  if (v8[138] != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v75 = v9[139];
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v76 = 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((v97 - v96) >> 4);
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v76;
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)", buf, 0x16u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (v8[138] != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v88 = 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)long long v100 = 134218240;
    *(void *)&v100[4] = 0xCCCCCCCCCCCCCCCDLL * ((v97 - v96) >> 4);
    *(_WORD *)&v100[12] = 2048;
    *(void *)&v100[14] = v88;
    std::string v89 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getBleMeasurements()", "%s\n", v89);
    if (v89 != buf) {
      free(v89);
    }
  }
  if (v8[138] != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  if (os_log_type_enabled((os_log_t)v9[139], OS_LOG_TYPE_DEBUG))
  {
    uint64_t v77 = *v90;
    uint64_t v78 = v90[1];
    if (*v90 != v78)
    {
      do
      {
        sub_100243254(buf, v77);
        uint64_t v79 = v111;
        if (!v111) {
          uint64_t v79 = *(void *)(qword_102489958 + 48);
        }
        sub_1002E594C(*(uint64_t ***)(v79 + 48), v107);
        if (qword_102419460 != -1) {
          dispatch_once(&qword_102419460, &stru_1022A5288);
        }
        std::string v80 = qword_102419468;
        if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v81 = v111;
          if (!v111) {
            uint64_t v81 = *(void *)(qword_102489958 + 48);
          }
          int v82 = (int)*(float *)(v81 + 20);
          if (v107[16])
          {
            uint64_t v83 = operator new(0x28uLL);
            std::string v91 = v83;
            long long v92 = xmmword_101D048C0;
            *uint64_t v83 = 0u;
            v83[1] = 0u;
            *(void *)((char *)v83 + 29) = 0;
            sub_1001E0650((uint64_t)v107, v83);
            char v84 = (const char *)&v91;
            if (v92 < 0) {
              char v84 = (const char *)v91;
            }
            uint64_t v85 = v111;
            if (!v111) {
              uint64_t v85 = *(void *)(qword_102489958 + 48);
            }
            unint64_t v86 = *(uint64_t **)(v85 + 40);
            if (*((char *)v86 + 23) < 0) {
              unint64_t v86 = (uint64_t *)*v86;
            }
            *(_DWORD *)long long v100 = 68290051;
            *(_DWORD *)&v100[4] = 0;
            *(_WORD *)&v100[8] = 2082;
            *(void *)&v100[10] = "";
            *(_WORD *)&v100[18] = 1025;
            *(_DWORD *)&v100[20] = v82;
            __int16 v101 = 2081;
            std::string v102 = v84;
            __int16 v103 = 2081;
            long long v104 = v86;
            __int16 v105 = 2050;
            uint64_t v106 = *(void *)&buf[8];
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"BLE cached scan\", \"rssi\":%{private}d, \"uuid\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s, \"time_s\":\"%{public}.09f\"}", v100, 0x36u);
            if (SHIBYTE(v92) < 0) {
              operator delete(v91);
            }
          }
          else
          {
            uint64_t v87 = *(uint64_t **)(v81 + 40);
            if (*((char *)v87 + 23) < 0) {
              uint64_t v87 = (uint64_t *)*v87;
            }
            *(_DWORD *)long long v100 = 68290051;
            *(_DWORD *)&v100[4] = 0;
            *(_WORD *)&v100[8] = 2082;
            *(void *)&v100[10] = "";
            *(_WORD *)&v100[18] = 1025;
            *(_DWORD *)&v100[20] = v82;
            __int16 v101 = 2081;
            std::string v102 = "not available";
            __int16 v103 = 2081;
            long long v104 = v87;
            __int16 v105 = 2050;
            uint64_t v106 = *(void *)&buf[8];
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"BLE cached scan\", \"rssi\":%{private}d, \"uuid\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s, \"time_s\":\"%{public}.09f\"}", v100, 0x36u);
          }
        }
        sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v77 += 88;
      }
      while (v77 != v78);
    }
  }
  if (v98)
  {
    sub_100134750(buf, "BLE spyscan buffer overflow");
    sub_10031A230((uint64_t *)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1000D7D80((uint64_t)__p);
  *(void *)long long buf = &v96;
  sub_1002F3514((void ***)buf);
}

void sub_1002EC628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  long long __p = a12;
  sub_100221EA8((void ***)&__p);
  sub_1000D7D80((uint64_t)&a21);
  long long __p = &a26;
  sub_1002F3514((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1002EC6F0(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 160))
  {
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    if (!*(unsigned char *)(a1 + 160)) {
      sub_10020D700();
    }
    double v5 = Current_5;
    double v6 = Current_5 - *(double *)(a1 + 152);
    sub_1002ED16C();
    double v47 = 0.0;
    if (v6 < v7)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v14 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v56 = 2050;
        double v57 = v6;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"UWB Scan duration\", \"duration\":\"%{public}.5f\"}", buf, 0x1Cu);
      }
      if (!*(unsigned char *)(a1 + 160)) {
        sub_10020D700();
      }
      sub_1000C7F88(buf);
      *(void *)uint64_t v48 = 0;
      CFStringRef v15 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeMaximalAgeForValidityFromScanStart", 0x8000100u, kCFAllocatorNull);
      int v16 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v15, v48);
      CFRelease(v15);
      double v17 = *(double *)v48;
      if (*(void *)&buf[8]) {
        sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
      }
      double v18 = 1.0;
      if (v16) {
        double v18 = v17;
      }
      double v11 = *(double *)(a1 + 152) - v18;
    }
    else
    {
      double v8 = v7;
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v56 = 2050;
        double v57 = v6;
        __int16 v58 = 2050;
        CFAbsoluteTime v59 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      double v10 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        *(_DWORD *)long long buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v56 = 2050;
        double v57 = v6;
        __int16 v58 = 2050;
        CFAbsoluteTime v59 = v8;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Scan duration is exceeded threshold", "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
      }
      double v11 = v5 - v8;
    }
    double v47 = v11;
    char v46 = 0;
    sub_1002ED224(a1 + 712, &v47, &v46, &v44);
    if (v46)
    {
      sub_100134750(buf, "UWB range buffer overflow");
      sub_10031A230((uint64_t *)buf);
      if (SBYTE3(v57) < 0) {
        operator delete(*(void **)buf);
      }
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    double v19 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 134349056;
      *(void *)&uint8_t buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((v45 - v44) >> 4);
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "uwb cached scan, read %{public}lu measurements", buf, 0xCu);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      *(_DWORD *)uint64_t v48 = 134349056;
      *(void *)&v48[4] = 0xCCCCCCCCCCCCCCCDLL * ((v45 - v44) >> 4);
      uint64_t v39 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getUwbMeasurements()", "%s\n", v39);
      if (v39 != buf) {
        free(v39);
      }
    }
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    BOOL v20 = os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG);
    uint64_t v22 = v44;
    uint64_t v21 = v45;
    if (v20)
    {
      if (v45 == v44)
      {
        *a2 = 0;
        a2[1] = 0;
        a2[2] = 0;
LABEL_79:
        *(void *)long long buf = &v44;
        sub_1002F3514((void ***)buf);
        return;
      }
      uint64_t v23 = 0;
      unint64_t v24 = 0;
      do
      {
        uint64_t v25 = *(void *)(v22 + v23 + 56);
        if (!v25) {
          uint64_t v25 = *(void *)(qword_102489958 + 56);
        }
        sub_1002E594C(*(uint64_t ***)(v25 + 32), v53);
        if (qword_102419460 != -1) {
          dispatch_once(&qword_102419460, &stru_1022A5288);
        }
        unint64_t v26 = qword_102419468;
        if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEBUG))
        {
          int v27 = v54;
          if (v54)
          {
            unint64_t v28 = operator new(0x28uLL);
            long long __p = v28;
            long long v43 = xmmword_101D048C0;
            *unint64_t v28 = 0u;
            v28[1] = 0u;
            *(void *)((char *)v28 + 29) = 0;
            sub_1001E0650((uint64_t)v53, v28);
            if (v43 >= 0) {
              p_p = (const char *)&__p;
            }
            else {
              p_p = (const char *)__p;
            }
          }
          else
          {
            p_p = "not available";
          }
          uint64_t v30 = *(void *)(v44 + v23 + 56);
          if (!v30) {
            uint64_t v30 = *(void *)(qword_102489958 + 56);
          }
          float v31 = *(float *)(v30 + 20);
          CFAbsoluteTime v32 = CFAbsoluteTimeGetCurrent() - *(double *)(v44 + v23 + 8);
          *(_DWORD *)long long buf = 67240963;
          *(_DWORD *)&uint8_t buf[4] = v24;
          *(_WORD *)&uint8_t buf[8] = 2081;
          *(void *)&buf[10] = p_p;
          __int16 v56 = 2049;
          double v57 = v31;
          __int16 v58 = 2050;
          CFAbsoluteTime v59 = v32;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f", buf, 0x26u);
          if (v27 && SHIBYTE(v43) < 0) {
            operator delete(__p);
          }
        }
        if (sub_10013D1A0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_102419460 != -1) {
            dispatch_once(&qword_102419460, &stru_1022A5288);
          }
          int v33 = v54;
          if (v54)
          {
            sub_1002811D4((uint64_t)v53, (uint64_t)v40);
            if (v41 >= 0) {
              int v34 = v40;
            }
            else {
              int v34 = (void **)v40[0];
            }
          }
          else
          {
            int v34 = (void **)"not available";
          }
          uint64_t v35 = *(void *)(v44 + v23 + 56);
          if (!v35) {
            uint64_t v35 = *(void *)(qword_102489958 + 56);
          }
          float v36 = *(float *)(v35 + 20);
          CFAbsoluteTime v37 = CFAbsoluteTimeGetCurrent() - *(double *)(v44 + v23 + 8);
          *(_DWORD *)uint64_t v48 = 67240963;
          *(_DWORD *)&v48[4] = v24;
          *(_WORD *)&v48[8] = 2081;
          *(void *)&v48[10] = v34;
          __int16 v49 = 2049;
          double v50 = v36;
          __int16 v51 = 2050;
          CFAbsoluteTime v52 = v37;
          uint64_t v38 = (char *)_os_log_send_and_compose_impl();
          if (v33 && v41 < 0) {
            operator delete(v40[0]);
          }
          sub_1004BA5E4("Generic", 1, 0, 2, "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getUwbMeasurements()", "%s\n", v38);
          if (v38 != buf) {
            free(v38);
          }
        }
        ++v24;
        uint64_t v22 = v44;
        uint64_t v21 = v45;
        v23 += 80;
      }
      while (0xCCCCCCCCCCCCCCCDLL * ((v45 - v44) >> 4) > v24);
    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    v53[0] = a2;
    while (v22 != v21)
    {
      sub_100243254(buf, v22);
      int v60 = 0;
      sub_1002F3700(v53, (uint64_t)buf);
      sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)buf);
      v22 += 80;
    }
    goto LABEL_79;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unint64_t v12 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
  }
  double v13 = qword_102419458;
  if (os_signpost_enabled((os_log_t)qword_102419458))
  {
    *(_DWORD *)long long buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!", "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sub_1002ED0A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  a35 = &a30;
  sub_1002F3514((void ***)&a35);
  _Unwind_Resume(a1);
}

void sub_1002ED16C()
{
  sub_1000C7F88(&v2);
  uint64_t v1 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsScanDurationThreshold", 0x8000100u, kCFAllocatorNull);
  sub_1000A6A10(v2, (uint64_t)v0, &v1);
  CFRelease(v0);
  if (v3) {
    sub_1000DB0A0(v3);
  }
}

void sub_1002ED208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002ED224@<X0>(uint64_t a1@<X0>, double *a2@<X1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  *a3 = 0;
  double v7 = *(double **)(a1 + 8);
  double v11 = v10;
  v10[1] = 0;
  double v8 = sub_1002F3218(v7, (double *)(a1 + 16), a2);
  if (*(double **)(a1 + 8) == v8 && *(unsigned char *)(a1 + 56)) {
    *a3 = 1;
  }
  return sub_1002F3300(a4, v8, (void *)(a1 + 16));
}

void sub_1002ED2B4(uint64_t a1, double a2)
{
  *(unsigned char *)(a1 + 145) = 2;
  if (*(unsigned char *)(a1 + 272) && *(unsigned char *)(a1 + 273))
  {
    unint64_t v4 = sub_1002F9708((uint64_t *)(a1 + 608));
    sub_1000C7F88(buf);
    unsigned int v11 = 0;
    CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumWiFiNumberOfMeasurementsForScanExtension", 0x8000100u, kCFAllocatorNull);
    int v6 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v5, &v11);
    CFRelease(v5);
    unint64_t v7 = v11;
    if (*(void *)v13) {
      sub_1000DB0A0(*(std::__shared_weak_count **)v13);
    }
    unint64_t v8 = 2;
    if (v6) {
      unint64_t v8 = v7;
    }
    if (v4 >= v8)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = sub_1002F9708((uint64_t *)(a1 + 608));
        *(_DWORD *)long long buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)double v13 = 2082;
        *(void *)&void v13[2] = "";
        __int16 v14 = 2050;
        uint64_t v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received valid scan results, clearing WiFi scan error state\", \"number of APs in scan buffer\":%{public}llu}", buf, 0x1Cu);
      }
      *(unsigned char *)(a1 + 272) = 0;
    }
  }
  sub_10030D248(*(unsigned __int8 **)(a1 + 304), (a1 + 8), a2);
  *(_WORD *)(a1 + 272) = 0;
}

void sub_1002ED478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002ED49C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 304);
  unint64_t v4 = sub_1002F9708((uint64_t *)(a1 + 608));

  return sub_10030E3A8(v3, a2, v4);
}

void sub_1002ED4E4(uint64_t a1)
{
  sub_1000C7F88(&v11);
  BOOL v10 = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsScanBleLeechedBeaconsRSSIEnabled", 0x8000100u, kCFAllocatorNull);
  char v3 = sub_1000D29FC(v11, (uint64_t)v2, &v10);
  CFRelease(v2);
  BOOL v4 = v10;
  if (v12) {
    sub_1000DB0A0(v12);
  }
  if (v4) {
    char v5 = 0;
  }
  else {
    char v5 = v3;
  }
  if (v5) {
    sub_1002ED9EC(a1);
  }
  else {
    sub_1002ED634(a1);
  }
  sub_1000C7F88(&v11);
  BOOL v10 = 0;
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsScanUWBRangeEnabled", 0x8000100u, kCFAllocatorNull);
  char v7 = sub_1000D29FC(v11, (uint64_t)v6, &v10);
  CFRelease(v6);
  BOOL v8 = v10;
  if (v12) {
    sub_1000DB0A0(v12);
  }
  if (v8) {
    char v9 = 0;
  }
  else {
    char v9 = v7;
  }
  if (v9) {
    sub_1002EDFD8(a1);
  }
  else {
    sub_1002EDCFC(a1);
  }
}

void sub_1002ED610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002ED634(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v1 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v1, OS_LOG_TYPE_DEFAULT, "BLE spyscan session already running", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      LOWORD(v10[0]) = 0;
      uint64_t v2 = _os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleSpyscanSessionIfStopped()", "%s\n", (const char *)v2);
      if ((uint8_t *)v2 != buf) {
        free((void *)v2);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v4, OS_LOG_TYPE_DEFAULT, "Start BLE spyscan session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      LOWORD(v10[0]) = 0;
      uint64_t v6 = _os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleSpyscanSessionIfStopped()", "%s\n", (const char *)v6);
      if ((uint8_t *)v6 != buf) {
        free((void *)v6);
      }
    }
    sub_1002EE30C((uint64_t *)a1);
    char v5 = sub_1002EB064(a1);
    memset(v9, 0, sizeof(v9));
    sub_1002F3070(v9, *(id **)(a1 + 784), *(id **)(a1 + 792), (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3);
    __n128 v7 = 0uLL;
    uint64_t v8 = 0;
    sub_10027575C((uint64_t)buf, 0, 1, v5, (uint64_t)v9, &v7, 0.0);
    v10[0] = (void **)&v7;
    sub_1000A7B4C(v10);
    v10[0] = (void **)v9;
    sub_1002F2ED0(v10);
    sub_1002EB344(a1, (uint64_t)buf);
    sub_1002E9780(a1 + 8, 1);
    v10[0] = (void **)&v13;
    sub_1000A7B4C(v10);
    v10[0] = (void **)&v12;
    sub_1002F2ED0(v10);
  }
}

void sub_1002ED9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1000A7B4C((void ***)va);
  sub_1002F2ED0((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1002ED9EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping BLE spyscan session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::stopBleSpyscanSessionIfRunning()", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    sub_1002A7780(a1 + 320);
    *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
    sub_1002F2764(a1 + 656, *(void **)(a1 + 664));
    *(void *)(a1 + 656) = a1 + 664;
    *(void *)(a1 + 672) = 0;
    *(void *)(a1 + 664) = 0;
    sub_1002EE6E0(a1);
    sub_1002F47CC(a1 + 816);
    sub_1002E9780(a1 + 8, 0);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    char v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "BLE spyscan session already stopped", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      char v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::stopBleSpyscanSessionIfRunning()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_1002EDCFC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 169))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v1 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ranging session already running", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v2 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startRangingSessionIfStopped()", "%s\n", v2);
      if (v2 != (char *)buf) {
        free(v2);
      }
    }
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "start a ranging session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      char v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startRangingSessionIfStopped()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    sub_1002A7E3C(a1 + 320);
    sub_1002E9964(a1 + 8, 1);
  }
}

void sub_1002EDFD8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 169))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "stop a ranging session", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::stopRangingSessionIfRunning()", "%s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
    sub_1002A7FF8(a1 + 320);
    sub_1002F2764(a1 + 720, *(void **)(a1 + 728));
    *(void *)(a1 + 720) = a1 + 728;
    *(void *)(a1 + 736) = 0;
    *(void *)(a1 + 72++*(void *)(result + 8) = 0;
    sub_1002E9964(a1 + 8, 0);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    char v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "ranging session already stopped", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      char v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::stopRangingSessionIfRunning()", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_1002EE2D4(uint64_t a1)
{
  sub_1002ED9EC(a1);

  sub_1002EDFD8(a1);
}

void sub_1002EE30C(uint64_t *a1)
{
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  char v3 = +[NSDate date];
  sub_1000C7F88(buf);
  LODWORD(__p[0]) = 0;
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberDaysToUseBtIdentities", 0x8000100u, kCFAllocatorNull);
  int v5 = sub_1004D08E4(*(uint64_t *)buf, (uint64_t)v4, __p);
  CFRelease(v4);
  int v6 = (int)__p[0];
  if (*(void *)&buf[8]) {
    sub_1000DB0A0(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v5) {
    int v7 = ~v6;
  }
  else {
    int v7 = -29;
  }
  double v8 = sub_100342BCC((uint64_t)v3, v7);
  std::to_string(&v27, v8);
  std::to_string(&v26, Current_5 + 86400.0);
  sub_100203208(a1[39], (uint64_t)&v27, (uint64_t)&v26, &v24);
  uint64_t v9 = v24;
  for (uint64_t i = v25; v9 != i; v9 += 72)
  {
    uint64_t v11 = (void **)(v9 + 16);
    if (*(char *)(v9 + 39) < 0)
    {
      unint64_t v13 = *(void *)(v9 + 24);
      if (v13)
      {
        sub_1000DC48C(buf, *v11, v13);
        goto LABEL_12;
      }
    }
    else if (*(unsigned char *)(v9 + 39))
    {
      long long v12 = *(_OWORD *)v11;
      *(void *)&uint8_t buf[16] = *(void *)(v9 + 32);
      *(_OWORD *)long long buf = v12;
LABEL_12:
      char v14 = 1;
      goto LABEL_14;
    }
    char v14 = 0;
    buf[0] = 0;
LABEL_14:
    unsigned char buf[24] = v14;
    uint64_t v15 = (void **)(v9 + 40);
    if (*(char *)(v9 + 63) < 0)
    {
      unint64_t v17 = *(void *)(v9 + 48);
      if (v17)
      {
        sub_1000DC48C(__p, *v15, v17);
        goto LABEL_19;
      }
    }
    else if (*(unsigned char *)(v9 + 63))
    {
      long long v16 = *(_OWORD *)v15;
      uint64_t v22 = *(void *)(v9 + 56);
      *(_OWORD *)long long __p = v16;
LABEL_19:
      char v18 = 1;
      goto LABEL_21;
    }
    char v18 = 0;
    LOBYTE(__p[0]) = 0;
LABEL_21:
    char v23 = v18;
    sub_1002F4824(a1 + 102, (_OWORD *)v9, (long long *)buf, (long long *)__p, (uint64_t)"", (void *)(v9 + 64));
    if (v23 && SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
    if (buf[24] && (buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  double v19 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = a1[105];
    *(_DWORD *)long long buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 2050;
    *(void *)&buf[20] = 0x8E38E38E38E38E39 * ((v25 - v24) >> 3);
    __int16 v29 = 2050;
    uint64_t v30 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, loadBleIdentitiesFromDb\", \"num of entries loaded\":%{public}lu, \"Total number of identities in memory\":%{public}lu}", buf, 0x26u);
  }
  *(void *)long long buf = &v24;
  sub_10021D730((void ***)buf);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
}

void sub_1002EE634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002EE6E0(uint64_t a1)
{
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 832);
  if (v1)
  {
    do
    {
      if (*((unsigned char *)v1 + 56))
      {
        if (*((char *)v1 + 55) < 0)
        {
          sub_1000DC48C(buf, (void *)v1[4], v1[5]);
        }
        else
        {
          *(_OWORD *)long long buf = *((_OWORD *)v1 + 2);
          *(void *)&uint8_t buf[16] = v1[6];
        }
      }
      else
      {
        memset(buf, 0, 24);
      }
      if (*((unsigned char *)v1 + 88))
      {
        if (*((char *)v1 + 87) < 0)
        {
          sub_1000DC48C(__p, (void *)v1[8], v1[9]);
        }
        else
        {
          *(_OWORD *)long long __p = *((_OWORD *)v1 + 4);
          uint64_t v7 = v1[10];
        }
      }
      else
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v7 = 0;
      }
      unint64_t v3 = v9;
      if (v9 >= v10)
      {
        uint64_t v4 = sub_1002F42D0(&v8, v1 + 2, (uint64_t)buf, (uint64_t)__p, (double *)v1 + 16);
      }
      else
      {
        sub_1002F4420((uint64_t)&v10, v9, v1 + 2, (uint64_t)buf, (uint64_t)__p, (double *)v1 + 16);
        uint64_t v4 = v3 + 72;
      }
      unint64_t v9 = v4;
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v1 = (uint64_t *)*v1;
    }
    while (v1);
    if (v9 != v8)
    {
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v5 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2050;
        *(void *)&buf[20] = 0x8E38E38E38E38E39 * ((uint64_t)(v9 - v8) >> 3);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, back up BT identities data to DB\", \"Num Entries\":%{public}lu}", buf, 0x1Cu);
      }
      sub_1002F10EC(*(void *)(a1 + 312));
    }
  }
  *(void *)long long buf = &v8;
  sub_10021D730((void ***)buf);
}

void sub_1002EE928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, char *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  long long __p = &a15;
  sub_10021D730((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1002EE984(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "stop a motion state-machine", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::stopMotionSM()", "%s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  sub_1002F1398((unsigned int *)(a1 + 592), 5);
}

void sub_1002EEB24(uint64_t a1, int a2)
{
  if (!a2 || !*(_DWORD *)(a1 + 592))
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    unint64_t v3 = (unsigned int *)(a1 + 592);
    uint64_t v4 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "start motion state-machine geofence", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::setFence(BOOL)", "%s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
    sub_1002F1398(v3, 0);
  }
}

void sub_1002EECD4(unsigned char *a1)
{
  if (!a1[170])
  {
    sub_10023E090((uint64_t)v5);
    v6 |= 2u;
    v5[12] = 1;
    int v4 = 0;
    sub_1001EE1F4(&v4);
    *(void *)&long long v7 = sub_1001EC8C4((ssize_t)&v4);
    *((void *)&v7 + 1) = v2;
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_1002EEE1C(&v7, (uint64_t)v5, (uint64_t)v8, Current_5);
    (*(void (**)(unsigned char *, unsigned char *))(*(void *)a1 + 144))(a1, v8);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
    sub_1001EF3E8((unsigned int *)&v4);
    sub_1002A86EC((uint64_t)(a1 + 320));
    sub_1002E9B50((uint64_t)(a1 + 8), 1);
    sub_1002692D8((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  }
}

void sub_1002EEDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, char a12)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v12 + 32));
  sub_1001EF3E8(&a11);
  sub_1002692D8((wireless_diagnostics::google::protobuf::MessageLite *)&a12);
  _Unwind_Resume(a1);
}

void sub_1002EEE1C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  sub_10023DF50((uint64_t)v8);
  sub_1002E7D14((uint64_t)v8, a2);
  sub_10031A9F0(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1002EEE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002EEEA8(unsigned char *a1)
{
  if (a1[170])
  {
    sub_10023E090((uint64_t)v5);
    v6 |= 2u;
    v5[12] = 0;
    int v4 = 0;
    sub_1001EE1F4(&v4);
    *(void *)&long long v7 = sub_1001EC8C4((ssize_t)&v4);
    *((void *)&v7 + 1) = v2;
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    sub_1002EEE1C(&v7, (uint64_t)v5, (uint64_t)v8, Current_5);
    (*(void (**)(unsigned char *, unsigned char *))(*(void *)a1 + 144))(a1, v8);
    sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
    sub_1001EF3E8((unsigned int *)&v4);
    sub_1002A8768((uint64_t)(a1 + 320));
    sub_1002E9B50((uint64_t)(a1 + 8), 0);
    sub_1002692D8((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  }
}

void sub_1002EEFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, char a12)
{
  sub_100260A2C((wireless_diagnostics::google::protobuf::MessageLite *)(v12 + 32));
  sub_1001EF3E8(&a11);
  sub_1002692D8((wireless_diagnostics::google::protobuf::MessageLite *)&a12);
  _Unwind_Resume(a1);
}

void sub_1002EEFEC(uint64_t a1, uint64_t *a2)
{
  if (*a2 != a2[1])
  {
    *(unsigned char *)(a1 + 273) = 1;
    sub_1002F8D88(a1 + 608, a2, v13);
    sub_1002E9114(v13, &v11);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v4 = v11;
      for (uint64_t i = v12; v4 != i; v4 += 88)
      {
        uint64_t v6 = *(void *)(v4 + 16);
        if (!v6) {
          uint64_t v6 = *(void *)(qword_102489958 + 16);
        }
        uint64_t v15 = nullsub_41(*(void *)(v6 + 24), v3);
        if (qword_102419460 != -1) {
          dispatch_once(&qword_102419460, &stru_1022A5288);
        }
        long long v7 = qword_102419468;
        if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEBUG))
        {
          float v8 = *(float *)(v6 + 20);
          sub_100B39278(&__p);
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          int v10 = *(_DWORD *)(v6 + 32);
          *(_DWORD *)long long buf = 68289795;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v17 = 2082;
          char v18 = "";
          __int16 v19 = 1025;
          int v20 = (int)v8;
          __int16 v21 = 2081;
          uint64_t v22 = p_p;
          __int16 v23 = 1025;
          int v24 = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Wifi AP received\", \"rssi\":%{private}d, \"mac\":%{private, location:escape_only}s, \"channel\":%{private}d}", buf, 0x28u);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
    }
    sub_10030D1A8(*(uint64_t **)(a1 + 304), &v11);
    *(void *)long long buf = &v11;
    sub_100221EA8((void ***)buf);
    *(void *)long long buf = v13;
    sub_1002F2E4C((void ***)buf);
  }
}

void sub_1002EF230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21)
{
  a21 = (void **)&a11;
  sub_100221EA8(&a21);
  a21 = (void **)&a14;
  sub_1002F2E4C(&a21);
  _Unwind_Resume(a1);
}

void sub_1002EF270(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    int v5 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sensorLogic, received wifi scan error\"}", (uint8_t *)v3, 0x12u);
  }
  *(unsigned char *)(a1 + 272) = 1;
}

void sub_1002EF354(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  uint64_t v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    int v5 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sensorLogic, received wifi scan error busy\"}", (uint8_t *)v3, 0x12u);
  }
  *(unsigned char *)(a1 + 272) = 1;
}

void sub_1002EF438(uint64_t a1, uint64_t a2)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  __int16 v4 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    sub_100D54C68(a2);
    if (v7 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 68289282;
    int v9 = 0;
    __int16 v10 = 2082;
    uint64_t v11 = "";
    __int16 v12 = 2082;
    unint64_t v13 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Logic, onAssociatedStateChange\", \"state\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (v7 < 0) {
      operator delete(__p);
    }
  }
  sub_1000D9D94(a1 + 176, a2);
  sub_100311A84(*(void *)(a1 + 304), a2);
}

void sub_1002EF574(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 809) != 1)
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v2 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      int v3 = *(unsigned __int8 *)(a1 + 809);
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      __int16 v10 = "";
      __int16 v11 = 1026;
      int v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Ble requested scan timeout but the session state is not running\", \"fBleSessionStatusRequested\":%{public}u}", (uint8_t *)&v7, 0x18u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
    }
    __int16 v4 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      int v5 = *(unsigned __int8 *)(a1 + 809);
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      __int16 v10 = "";
      __int16 v11 = 1026;
      int v12 = v5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Ble requested scan timeout but the session state is not running", "{\"msg%{public}.0s\":\"Ble requested scan timeout but the session state is not running\", \"fBleSessionStatusRequested\":%{public}u}", (uint8_t *)&v7, 0x18u);
    }
  }
  int v6 = *(unsigned __int8 *)(a1 + 808);
  sub_1002A7780(a1 + 320);
  *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
  if (v6 == 2) {
    sub_1002EA694(a1);
  }
  sub_1002EF738(a1);
}

void sub_1002EF738(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 160))
  {
    double v2 = *(double *)(a1 + 152);
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    int v3 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v15 = 2082;
      *(void *)&void v15[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!\"}", buf, 0x12u);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
    }
    __int16 v4 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      *(_DWORD *)long long buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v15 = 2082;
      *(void *)&void v15[2] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!", "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!\"}", buf, 0x12u);
    }
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    double v2 = Current_5;
    if (!*(unsigned char *)(a1 + 160)) {
      *(unsigned char *)(a1 + 160) = 1;
    }
    *(double *)(a1 + 152) = Current_5;
  }
  sub_1000C7F88(buf);
  v12[0] = 0;
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumAgeForValidity", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1000A6A10(*(uint64_t *)buf, (uint64_t)v6, v12);
  CFRelease(v6);
  double v8 = *(double *)v12;
  if (*(void *)v15) {
    sub_1000DB0A0(*(std::__shared_weak_count **)v15);
  }
  if (v7) {
    double v9 = v8;
  }
  else {
    double v9 = 1.0;
  }
  sub_1002F92A8(a1 + 608, v13, v2, v9);
  *(void *)long long buf = v13;
  sub_1002F2E4C((void ***)buf);
  memset(v12, 0, sizeof(v12));
  sub_1002F4158(v12, *(void *)(a1 + 608), *(void *)(a1 + 616), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 616) - *(void *)(a1 + 608)) >> 3));
  sub_1002E9114(v12, v11);
  buf[0] = *(unsigned char *)(a1 + 144);
  *(void *)uint64_t v15 = 0;
  sub_1002A5FB0(a1 + 320, (uint64_t)buf);
  *(unsigned char *)(a1 + 145) = 1;
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  __int16 v10 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v15 = 2082;
    *(void *)&void v15[2] = "";
    __int16 v16 = 2050;
    uint64_t v17 = 0x2E8BA2E8BA2E8BA3 * ((v11[1] - v11[0]) >> 3);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan starts\", \"Num Valid Buffered WiFi APs\":%{public}lu}", buf, 0x1Cu);
  }
  sub_10030D1A8(*(uint64_t **)(a1 + 304), v11);
  *(void *)long long buf = v11;
  sub_100221EA8((void ***)buf);
  *(void *)long long buf = v12;
  sub_1002F2E4C((void ***)buf);
}

void sub_1002EFAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a10;
  sub_100221EA8(&a19);
  a19 = (void **)&a13;
  sub_1002F2E4C(&a19);
  _Unwind_Resume(a1);
}

void sub_1002EFB08(uint64_t a1, double *a2, uint64_t a3)
{
  sub_1000C7F88(&v11);
  double v15 = 0.0;
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleScanMaximalAgeForValidity", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1000A6A10(v11, (uint64_t)v6, &v15);
  CFRelease(v6);
  double v8 = v15;
  if (v12) {
    sub_1000DB0A0(v12);
  }
  double v9 = 1.0;
  if (v7) {
    double v9 = v8;
  }
  double v14 = v9;
  sub_1002EFC60(a3, (uint64_t)&v11);
  if (v13)
  {
    __int16 v10 = (std::locale::__imp **)sub_10030A440(*(void *)(a1 + 304));
    if (sub_1001F82A4(a2, (uint64_t)&v11, &v14, v10))
    {
      if (!v13) {
        sub_10020D700();
      }
      sub_1002F3908(a1 + 656, (uint64_t)&v11);
      sub_1002F38A8((uint64_t *)(a1 + 648));
    }
    if (v13) {
      sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)&v11);
    }
  }
}

void sub_1002EFC2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a11) {
    sub_1000DB0A0(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002EFC60(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_10023D5C4((uint64_t)v6);
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_10023E734(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_1002E6234((uint64_t)v6, a1);
  sub_100243254(a2, v6);
  *(unsigned char *)(a2 + 80) = 1;
  sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_1002EFD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002EFD24(uint64_t *a1, uint64_t a2)
{
  if (a1[105] >= (unint64_t)a1[107])
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    double v15 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = a1[105];
      int v19 = 68289283;
      int v20 = 0;
      __int16 v21 = 2082;
      uint64_t v22 = "";
      __int16 v23 = 2049;
      int v24 = (char *)v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"fSameAccountBleIdentities exceeded max entries\", \"Size\":%{private}lu}", (uint8_t *)&v19, 0x1Cu);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
    }
    uint64_t v17 = qword_102419458;
    if (os_signpost_enabled((os_log_t)qword_102419458))
    {
      uint64_t v18 = a1[105];
      int v19 = 68289283;
      int v20 = 0;
      __int16 v21 = 2082;
      uint64_t v22 = "";
      __int16 v23 = 2049;
      int v24 = (char *)v18;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "fSameAccountBleIdentities exceeded max entries", "{\"msg%{public}.0s\":\"fSameAccountBleIdentities exceeded max entries\", \"Size\":%{private}lu}", (uint8_t *)&v19, 0x1Cu);
    }
  }
  else if (*(unsigned char *)(a2 + 104))
  {
    uint64_t v4 = a2 + 80;
    uint64_t v5 = (std::locale::__imp **)sub_10030A440(a1[38]);
    if (sub_1001F8820(a2 + 80, v5))
    {
      sub_1002F3B0C((uint64_t)(a1 + 102), a2, a2);
      if (v6)
      {
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
        int v7 = qword_102419458;
        if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
        {
          int v8 = (char *)operator new(0x28uLL);
          *(_OWORD *)int v8 = 0u;
          *((_OWORD *)v8 + 1) = 0u;
          *(void *)(v8 + 29) = 0;
          sub_1001E0650(a2, v8);
          if (!*(unsigned char *)(a2 + 104)) {
            sub_10020D700();
          }
          uint64_t v11 = *(const char **)(a2 + 48);
          uint64_t v10 = a2 + 48;
          double v9 = v11;
          if (*(char *)(v10 + 23) >= 0) {
            double v9 = (const char *)v10;
          }
          if (!*(unsigned char *)(v10 + 24)) {
            double v9 = "";
          }
          if (*(char *)(v10 - 9) >= 0) {
            int v12 = (const char *)(v10 - 32);
          }
          else {
            int v12 = *(const char **)(v10 - 32);
          }
          if (!*(unsigned char *)(v10 - 8)) {
            int v12 = "";
          }
          if (*(char *)(v10 + 55) >= 0) {
            uint64_t v13 = v4;
          }
          else {
            uint64_t v13 = *(void *)(v10 + 32);
          }
          uint64_t v14 = *(void *)(v10 + 64);
          int v19 = 68290307;
          int v20 = 0;
          __int16 v21 = 2082;
          uint64_t v22 = "";
          __int16 v23 = 2081;
          int v24 = v8;
          __int16 v25 = 2081;
          std::string v26 = v12;
          __int16 v27 = 2081;
          unint64_t v28 = v9;
          __int16 v29 = 2081;
          uint64_t v30 = v13;
          __int16 v31 = 2050;
          uint64_t v32 = v14;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"buffered a same icloud account BT identity\", \"BT uuid\":%{private, location:escape_only}s, \"Device name\":%{private, location:escape_only}s, \"Stable identifier\":%{private, location:escape_only}s, \"device model\":%{private, location:escape_only}s, \"Time stamp_s\":\"%{public}.09f\"}", (uint8_t *)&v19, 0x44u);
          operator delete(v8);
        }
      }
    }
  }
}

void sub_1002F0048(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1002F0060(uint64_t a1, uint64_t *a2, double a3)
{
  double v16 = a3;
  sub_1002F0314(a2, (uint64_t)&v14);
  v21[0] = 1.79769313e308;
  *(void *)long long buf = 0;
  *(void *)uint64_t v18 = 0;
  *(void *)&v18[8] = 0;
  sub_1001F8688(&v16, &v14, v21, (std::locale::__imp **)buf);
  std::string __p = buf;
  sub_1000A7B4C((void ***)&__p);
  sub_1002F3F0C(v14, v15, a1 + 720, a1 + 728, (uint64_t *)buf);
  sub_1002F38A8((uint64_t *)(a1 + 712));
  uint64_t v4 = v14;
  for (uint64_t i = v15; v4 != i; v4 += 80)
  {
    uint64_t v6 = *(void *)(v4 + 56);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_102489958 + 56);
    }
    sub_1002E594C(*(uint64_t ***)(v6 + 32), v21);
    if (v22)
    {
      int v7 = operator new(0x28uLL);
      std::string __p = v7;
      long long v13 = xmmword_101D048C0;
      *int v7 = 0u;
      v7[1] = 0u;
      *(void *)((char *)v7 + 29) = 0;
      sub_1001E0650((uint64_t)v21, v7);
    }
    else
    {
      sub_100134750(&__p, "");
    }
    if (qword_102419460 != -1) {
      dispatch_once(&qword_102419460, &stru_1022A5288);
    }
    int v8 = qword_102419468;
    if (os_log_type_enabled((os_log_t)qword_102419468, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(v4 + 56);
      if (!v9) {
        uint64_t v9 = *(void *)(qword_102489958 + 56);
      }
      double v10 = *(float *)(v9 + 20);
      p_p = &__p;
      if (v13 < 0) {
        p_p = __p;
      }
      *(_DWORD *)long long buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v18 = 2082;
      *(void *)&double v18[2] = "";
      *(_WORD *)&v18[10] = 2050;
      *(double *)&v18[12] = v10;
      __int16 v19 = 2081;
      int v20 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Ingested UWB range measurement\", \"range\":\"%{public}.3f\", \"device ID\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(__p);
    }
  }
  *(void *)long long buf = &v14;
  sub_1002F3514((void ***)buf);
}

void sub_1002F02C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, char a17)
{
  a14 = (void **)&a17;
  sub_1002F3514(&a14);
  _Unwind_Resume(a1);
}

void sub_1002F0314(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  long long v10 = 0uLL;
  unint64_t v11 = 0;
  sub_1002F2824((uint64_t *)&v10, (a1[1] - *a1) >> 6);
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  while (v4 != v5)
  {
    sub_1002F28D8(v4, (uint64_t)v8);
    if (v9)
    {
      uint64_t v6 = *((void *)&v10 + 1);
      if (*((void *)&v10 + 1) >= v11)
      {
        uint64_t v7 = sub_1002F2B0C((uint64_t *)&v10, (uint64_t)v8);
      }
      else
      {
        sub_100243254(*((void *)&v10 + 1), v8);
        uint64_t v7 = v6 + 80;
      }
      *((void *)&v10 + 1) = v7;
      if (v9) {
        sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)v8);
      }
    }
    v4 += 64;
  }
  *(_OWORD *)a2 = v10;
  *(void *)(a2 + 16) = v11;
  unint64_t v11 = 0;
  long long v10 = 0uLL;
  v8[0] = (void **)&v10;
  sub_1002F3514(v8);
}

void sub_1002F03F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 - 64);
  sub_1002F3514(&a10);
  _Unwind_Resume(a1);
}

void sub_1002F0438(uint64_t a1)
{
}

void sub_1002F0444(uint64_t a1)
{
  sub_100134750(&__p, "onFailureToReceiveGeofenceStatusReports: ");
  sub_100134750(&v29, "");
  if (*(_DWORD *)(a1 + 592) == 1)
  {
    std::string::assign(&v29, "Restarting Geofence. ");
    sub_1002F1398((unsigned int *)(a1 + 592), 0);
  }
  else
  {
    std::string::assign(&v29, "Ignoring failure. ");
  }
  sub_1000C7F88(&v33);
  v27[0] = 0;
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaxTimeAllowedWithoutFenceStatusReport", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1000A6A10((uint64_t)v33.__r_.__value_.__l.__data_, (uint64_t)v2, v27);
  CFRelease(v2);
  double v4 = *(double *)v27;
  if (v33.__r_.__value_.__l.__size_) {
    sub_1000DB0A0((std::__shared_weak_count *)v33.__r_.__value_.__l.__size_);
  }
  if (!v3) {
    double v4 = 600.0;
  }
  sub_1000C7F88(&v33);
  v27[0] = 0;
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaxDelayAfterFenceStatusReportTimerFires", 0x8000100u, kCFAllocatorNull);
  int v6 = sub_1000A6A10((uint64_t)v33.__r_.__value_.__l.__data_, (uint64_t)v5, v27);
  CFRelease(v5);
  double v7 = *(double *)v27;
  if (v33.__r_.__value_.__l.__size_) {
    sub_1000DB0A0((std::__shared_weak_count *)v33.__r_.__value_.__l.__size_);
  }
  if (!v6) {
    double v7 = 30.0;
  }
  std::to_string(&v26, v4);
  int v8 = std::string::insert(&v26, 0, " Running with FenceStatusTimeout: ");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  uint64_t v10 = std::string::append(&v34, "and RaceDelayTimeout: ");
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v25, v7);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v12 = &v25;
  }
  else {
    int v12 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v25.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = std::string::append(&v33, (const std::string::value_type *)v12, size);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  int64_t v28 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)__int16 v27 = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  sub_1002F0A00((const void **)&__p, (const void **)&v29.__r_.__value_.__l.__data_, (uint64_t)&v33);
  if (v28 >= 0) {
    double v16 = v27;
  }
  else {
    double v16 = (void **)v27[0];
  }
  if (v28 >= 0) {
    std::string::size_type v17 = HIBYTE(v28);
  }
  else {
    std::string::size_type v17 = (std::string::size_type)v27[1];
  }
  uint64_t v18 = std::string::append(&v33, (const std::string::value_type *)v16, v17);
  __int16 v19 = (void *)v18->__r_.__value_.__r.__words[0];
  v34.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
  *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
  char v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (v32 < 0) {
    operator delete(__p);
  }
  std::string __p = v19;
  *(void *)__int16 v31 = v34.__r_.__value_.__r.__words[0];
  *(void *)&v31[7] = *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + 7);
  char v32 = v20;
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  __int16 v21 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
  {
    p_p = &__p;
    if (v32 < 0) {
      p_p = __p;
    }
    LODWORD(v33.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v33.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v33, 0xCu);
  }
  if (sub_10013D1A0(115, 0))
  {
    bzero(&v33, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    __int16 v23 = &__p;
    if (v32 < 0) {
      __int16 v23 = __p;
    }
    LODWORD(v34.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    int v24 = (std::string *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 0, "virtual void CLMicroLocationSensorsLogic::onFailureToReceiveGeofenceStatusReports()", "%s\n", (const char *)v24);
    if (v24 != &v33) {
      free(v24);
    }
  }
  sub_10031A230((uint64_t *)&__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (v32 < 0) {
    operator delete(__p);
  }
}

void sub_1002F0904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F0A00@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_1001110E4(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    int v8 = (char *)result;
  }
  else {
    int v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      long long v9 = a1;
    }
    else {
      long long v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  uint64_t v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v11 = a2;
    }
    else {
      long long v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void sub_1002F0ACC(uint64_t a1)
{
}

uint64_t sub_1002F0AD8(uint64_t result, int a2, double a3)
{
  *(double *)(result + 28++*(void *)(result + 8) = a3;
  *(_DWORD *)(result + 280) = a2;
  return result;
}

uint64_t sub_1002F0AE4(uint64_t result)
{
  if (*(unsigned char *)(result + 296))
  {
    uint64_t v1 = result;
    uint64_t result = sub_1002A7C80(result + 320);
    *(unsigned char *)(v1 + 296) = 0;
  }
  return result;
}

void sub_1002F0B18(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 320;
  std::string __p = 0;
  double v4 = 0;
  uint64_t v5 = 0;
  sub_1001DD364(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  sub_1002A72BC(v2, &__p);
  if (__p)
  {
    double v4 = __p;
    operator delete(__p);
  }
}

void sub_1002F0B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002F0B98(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 280);
  return j__CFAbsoluteTimeGetCurrent_5() - *(double *)(a1 + 288) < (double)a2 / 1000.0 || v2 != 1;
}

uint64_t sub_1002F0BEC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48))(&v6);
  sub_1002A5E70(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002F0C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_101A5A880();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F0CA8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48))(&v6);
  sub_1002A5EB0(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002F0D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_101A5A8B4();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F0D64(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48))(&v6);
  sub_1002A5EF0(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002F0E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_101A5A8E8();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F0E20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48))(&v6);
  sub_1002A5F30(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002F0EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_101A5A91C();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F0EDC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_10015E48C();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48))(&v6);
  sub_1002A5F70(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1002F0F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_101A5A950();
  }
  _Unwind_Resume(exception_object);
}

void sub_1002F0F98(uint64_t a1, int a2, void *a3)
{
  if (a2)
  {
    *(void *)(a1 + 776) = *a3;
    int v3 = 1;
  }
  else
  {
    int v3 = 2;
  }
  sub_1002F1398((unsigned int *)(a1 + 592), v3);
}

uint64_t sub_1002F0FB8(uint64_t a1)
{
  double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (*(unsigned char *)(a1 + 169)
    && (v3 = Current_5, double v4 = Current_5 - *(double *)(a1 + 776), v4 * 1000.0 < (double)sub_1002F1040()))
  {
    return (uint64_t)((double)sub_1002F1040() + (v3 - *(double *)(a1 + 776)) * -1000.0);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1002F1040()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLocalizingBacklightOnInitialScanDelay", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  uint64_t v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 0;
  }
}

void sub_1002F10D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F10EC(uint64_t a1)
{
  if (sub_10014C3C0(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 296);
    if (!v2) {
      operator new();
    }
    uint64_t v3 = sub_10021B4C0(v2);
    sub_1002F4524(a1);
    return v3;
  }
  else
  {
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    uint64_t v5 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_10013D1A0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationBluetoothIdentityTable::Entry]", "%s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    return 0;
  }
}

void sub_1002F1320()
{
}

uint64_t sub_1002F134C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 304) + 152))();
}

__n128 sub_1002F1374@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = a1[54];
  *a2 = result;
  a2[1].n128_u64[0] = a1[55].n128_u64[0];
  return result;
}

double sub_1002F1388(uint64_t a1)
{
  *(_DWORD *)(a1 + 880) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 864) = 0u;
  return result;
}

void sub_1002F1398(unsigned int *a1, int a2)
{
  int v8 = (char *)*a1;
  switch((int)v8)
  {
    case 0:
      sub_1002F1798((uint64_t)a1, a2);
      char v5 = 0;
      LOBYTE(v4) = 0;
      LOBYTE(v3) = 0;
      BOOL v2 = 0;
      break;
    case 1:
      unsigned int v9 = sub_1002F1A78((uint64_t)a1, a2);
      goto LABEL_5;
    case 2:
      unsigned int v9 = sub_1002F1D00((uint64_t)a1, a2);
LABEL_5:
      BOOL v2 = 0;
      char v5 = v9 & 1;
      int v4 = (v9 >> 8) & 1;
      LOBYTE(v3) = (v9 & 0xFFFF0000) != 0;
      break;
    case 3:
      unsigned int v10 = sub_1002F2034((uint64_t)a1, a2);
      char v5 = v10 & 1;
      int v4 = (v10 >> 8) & 1;
      int v3 = HIWORD(v10) & 1;
      BOOL v2 = (v10 & 0xFF000000) != 0;
      break;
    default:
      break;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  long long v11 = qword_102419458;
  if (!os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_29;
  }
  switch(a2)
  {
    case 1:
      char v23 = 8;
      uint64_t v12 = 0x6E4F6E6565726353;
      goto LABEL_13;
    case 2:
      char v23 = 9;
      strcpy((char *)v22, "ScreenOff");
      break;
    case 3:
      char v23 = 10;
      LOWORD(v22[1]) = 29555;
      long long v13 = "FenceCross";
      goto LABEL_17;
    case 4:
      char v23 = 10;
      LOWORD(v22[1]) = 28271;
      long long v13 = "StopMotion";
LABEL_17:
      v22[0] = *(void **)v13;
      BYTE2(v22[1]) = 0;
      break;
    case 5:
      char v23 = 4;
      strcpy((char *)v22, "Stop");
      break;
    default:
      char v23 = 8;
      uint64_t v12 = 0x65636E6546746553;
LABEL_13:
      v22[0] = (void *)v12;
      LOBYTE(v22[1]) = 0;
      break;
  }
  sub_1002F2514(v8, (uint64_t)v20);
  int v14 = v21;
  long long v15 = (void **)v20[0];
  sub_1002F2514((char *)*a1, (uint64_t)__p);
  double v16 = v20;
  if (v14 < 0) {
    double v16 = v15;
  }
  if (v19 >= 0) {
    std::string::size_type v17 = __p;
  }
  else {
    std::string::size_type v17 = (void **)__p[0];
  }
  *(_DWORD *)long long buf = 68290818;
  int v25 = 0;
  __int16 v26 = 2082;
  __int16 v27 = "";
  __int16 v28 = 2082;
  std::string v29 = v22;
  __int16 v30 = 2082;
  __int16 v31 = v16;
  __int16 v32 = 2082;
  std::string v33 = v17;
  __int16 v34 = 1026;
  int v35 = v5 & 1;
  __int16 v36 = 1026;
  int v37 = v4 & 1;
  __int16 v38 = 1026;
  int v39 = v3 & 1;
  __int16 v40 = 1026;
  int v41 = v2;
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MotionSM::transitionLogic\", \"event\":%{public, location:escape_only}s, \"prevState\":%{public, location:escape_only}s, \"currState\":%{public, location:escape_only}s, \"startInMotion\":%{public}hhd, \"ongoingInMotion\":%{public}hhd, \"stopMotion\":%{public}hhd, \"resumeInMotion\":%{public}hhd}", buf, 0x48u);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  if ((v23 & 0x80000000) == 0)
  {
LABEL_29:
    if ((v5 & 1) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  operator delete(v22[0]);
  if (v5) {
LABEL_30:
  }
    sub_10030DC08(*(void *)(*((void *)a1 + 1) + 304), 0);
LABEL_31:
  if (v4) {
    sub_10030DC08(*(void *)(*((void *)a1 + 1) + 304), 1);
  }
  if (v3) {
    sub_10030DED8(*(void *)(*((void *)a1 + 1) + 304));
  }
  if (v2) {
    sub_10030DC08(*(void *)(*((void *)a1 + 1) + 304), 2);
  }
}

void sub_1002F1738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (v22 < 0) {
    operator delete(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F1798(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      sub_1002A869C(*(void *)(a1 + 8) + 320);
      *(_DWORD *)a1 = 1;
      break;
    case 1:
      *(unsigned char *)(a1 + 4) = 1;
      break;
    case 2:
      *(unsigned char *)(a1 + 4) = 0;
      break;
    case 3:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state\"}", (uint8_t *)&v9, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        char v5 = "MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state";
        uint64_t v6 = "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state\"}";
        goto LABEL_19;
      }
      break;
    case 4:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      double v7 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state\"}", (uint8_t *)&v9, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        char v5 = "MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state";
        uint64_t v6 = "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state\"}";
LABEL_19:
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v5, v6, (uint8_t *)&v9, 0x12u);
      }
      break;
    default:
      return 0;
  }
  return 0;
}

uint64_t sub_1002F1A78(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      sub_1002A86C4(*(void *)(a1 + 8) + 320);
      sub_1002A869C(*(void *)(a1 + 8) + 320);
      int v3 = 0;
      int v4 = 0;
      *(_DWORD *)a1 = 1;
      return v3 & 0x10000 | v4;
    case 1:
      int v3 = 0;
      int v4 = 0;
      *(unsigned char *)(a1 + 4) = 1;
      return v3 & 0x10000 | v4;
    case 2:
      int v3 = 0;
      int v4 = 0;
      *(unsigned char *)(a1 + 4) = 0;
      return v3 & 0x10000 | v4;
    case 3:
      if (!*(unsigned char *)(a1 + 4)) {
        goto LABEL_18;
      }
      if (sub_1002F2684())
      {
        int v3 = 0;
        int v5 = 2;
        int v4 = 1;
        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 4)) {
        goto LABEL_20;
      }
LABEL_18:
      if (sub_1002F2684())
      {
        int v4 = 0;
        int v5 = 3;
      }
      else
      {
LABEL_20:
        int v4 = 0;
        int v5 = 0;
      }
      int v3 = 0x10000;
LABEL_22:
      sub_1002F2604(a1, 1, v5);
      return v3 & 0x10000 | v4;
    case 4:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionLogicGeofence, shouldn't receive StopMotion at Geofence state\"}", (uint8_t *)&v9, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      double v7 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        uint64_t v12 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MotionSM::transitionLogicGeofence, shouldn't receive StopMotion at Geofence state", "{\"msg%{public}.0s\":\"MotionSM::transitionLogicGeofence, shouldn't receive StopMotion at Geofence state\"}", (uint8_t *)&v9, 0x12u);
      }
      goto LABEL_15;
    case 5:
      sub_1002A86C4(*(void *)(a1 + 8) + 320);
      int v3 = 0;
      int v4 = 0;
      *(_DWORD *)a1 = 0;
      return v3 & 0x10000 | v4;
    default:
LABEL_15:
      int v3 = 0;
      int v4 = 0;
      return v3 & 0x10000 | v4;
  }
}

uint64_t sub_1002F1D00(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state\"}", (uint8_t *)&v8, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      uint64_t result = os_signpost_enabled((os_log_t)qword_102419458);
      if (result)
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state", "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state\"}", (uint8_t *)&v8, 0x12u);
        goto LABEL_9;
      }
      break;
    case 1:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      uint64_t v6 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state\"}", (uint8_t *)&v8, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      double v7 = qword_102419458;
      if (os_signpost_enabled((os_log_t)qword_102419458))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state", "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state\"}", (uint8_t *)&v8, 0x12u);
      }
      uint64_t result = 0;
      *(unsigned char *)(a1 + 4) = 1;
      break;
    case 2:
      *(unsigned char *)(a1 + 4) = 0;
      sub_1002A880C(*(void *)(a1 + 8) + 320);
      *(_DWORD *)a1 = 3;
      goto LABEL_21;
    case 3:
      uint64_t result = 256;
      break;
    case 4:
      sub_1002A880C(*(void *)(a1 + 8) + 320);
      *(_DWORD *)a1 = 0;
LABEL_21:
      uint64_t result = 0x10000;
      break;
    case 5:
      sub_1002A880C(*(void *)(a1 + 8) + 320);
      uint64_t result = 0;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_9:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1002F2034(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v3 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at PendingResumeStopDetection state\"}", (uint8_t *)&v11, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      uint64_t result = os_signpost_enabled((os_log_t)qword_102419458);
      if (result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at PendingResumeStopDetection state";
        double v7 = "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at P"
             "endingResumeStopDetection state\"}";
        goto LABEL_31;
      }
      break;
    case 1:
      *(unsigned char *)(a1 + 4) = 1;
      sub_1002A87E4(*(void *)(a1 + 8) + 320);
      *(_DWORD *)a1 = 2;
      uint64_t result = 0x1000000;
      break;
    case 2:
      *(unsigned char *)(a1 + 4) = 0;
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v8 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at PendingResumeStopDetection state\"}", (uint8_t *)&v11, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      uint64_t result = os_signpost_enabled((os_log_t)qword_102419458);
      if (result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at PendingResumeStopDetection state";
        double v7 = "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at "
             "PendingResumeStopDetection state\"}";
        goto LABEL_31;
      }
      break;
    case 3:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      int v9 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at PendingResumeStopDetection state\"}", (uint8_t *)&v11, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      uint64_t result = os_signpost_enabled((os_log_t)qword_102419458);
      if (result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at PendingResumeStopDetection state";
        double v7 = "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at"
             " PendingResumeStopDetection state\"}";
        goto LABEL_31;
      }
      break;
    case 4:
      if (qword_102419450 != -1) {
        dispatch_once(&qword_102419450, &stru_1022A5268);
      }
      __int16 v10 = qword_102419458;
      if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at PendingResumeStopDetection state\"}", (uint8_t *)&v11, 0x12u);
        if (qword_102419450 != -1) {
          dispatch_once(&qword_102419450, &stru_1022A5268);
        }
      }
      int v4 = qword_102419458;
      uint64_t result = os_signpost_enabled((os_log_t)qword_102419458);
      if (result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        int v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at PendingResumeStopDetection state";
        double v7 = "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at"
             " PendingResumeStopDetection state\"}";
LABEL_31:
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v6, v7, (uint8_t *)&v11, 0x12u);
        goto LABEL_32;
      }
      break;
    case 5:
      uint64_t result = 0;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_32:
      uint64_t result = 0;
      break;
  }
  return result;
}

char *sub_1002F2514@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  switch((int)result)
  {
    case 1:
      *(unsigned char *)(a2 + 23) = 8;
      strcpy((char *)a2, "Geofence");
      break;
    case 2:
      *(unsigned char *)(a2 + 23) = 13;
      strcpy((char *)a2, "StopDetection");
      break;
    case 3:
      uint64_t result = (char *)operator new(0x20uLL);
      *(void *)a2 = result;
      *(_OWORD *)(a2 + ++*(void *)(result + 8) = xmmword_101D0AE20;
      strcpy(result, "PendingResumeStopDetection");
      break;
    default:
      *(unsigned char *)(a2 + 23) = 4;
      strcpy((char *)a2, "Idle");
      break;
  }
  return result;
}

uint64_t sub_1002F2604(uint64_t result, int a2, int a3)
{
  uint64_t v4 = result;
  if (a2 == 2)
  {
    uint64_t result = sub_1002A880C(*(void *)(result + 8) + 320);
  }
  else if (a2 == 1)
  {
    uint64_t result = sub_1002A86C4(*(void *)(result + 8) + 320);
  }
  if (a3 == 2)
  {
    uint64_t result = sub_1002A87E4(*(void *)(v4 + 8) + 320);
  }
  else if (a3 == 1)
  {
    uint64_t result = sub_1002A869C(*(void *)(v4 + 8) + 320);
  }
  *(_DWORD *)uint64_t v4 = a3;
  return result;
}

uint64_t sub_1002F2684()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMotionStopDetectionModuleEnable", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1002F2718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002F2734(id a1)
{
  qword_102419458 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002F2764(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1002F2764(a1, *a2);
    sub_1002F2764(a1, a2[1]);
    (*(void (**)(void))a2[4])();
    operator delete(a2);
  }
}

void sub_1002F27F4(id a1)
{
  qword_102419468 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

uint64_t sub_1002F2824(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334) {
      sub_1001D7FD4();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_100214C7C(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 80 * v6;
    sub_1002F299C(a1, v7);
    return sub_1002F2AA0((uint64_t)v7);
  }
  return result;
}

void sub_1002F28C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002F2AA0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002F28D8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_10023D5C4((uint64_t)v6);
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_10023E734(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_1002E62D4((uint64_t)v6, a1);
  sub_100243254(a2, v6);
  *(unsigned char *)(a2 + 80) = 1;
  sub_1002433A8((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_1002F2988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002F299C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002F2A14((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002F2A14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0; a3 + i != a5; sub_100243254(i + a7, i + a3))
    i -= 80;
  return a6;
}

uint64_t sub_1002F2AA0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    int v4 = *(void (***)(void))(i - 80);
    *(void *)(a1 + 16) = i - 80;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1002F2B0C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x199999999999999) {
    unint64_t v9 = 0x333333333333333;
  }
  else {
    unint64_t v9 = v5;
  }
  std::string::size_type v17 = a1 + 2;
  if (v9) {
    __int16 v10 = (char *)sub_100214C7C(v7, v9);
  }
  else {
    __int16 v10 = 0;
  }
  __int16 v13 = v10;
  int v14 = &v10[80 * v4];
  double v16 = &v10[80 * v9];
  sub_100243254(v14, a2);
  long long v15 = v14 + 80;
  sub_1002F299C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1002F2AA0((uint64_t)&v13);
  return v11;
}

void sub_1002F2C00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002F2AA0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F2C14(uint64_t a1, uint64_t a2, std::string *__str)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + ++*(void *)(result + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  unint64_t v4 = (void *)(a1 + 32);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 4++*(void *)(result + 8) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  std::string::operator=((std::string *)(a1 + 32), __str);
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unint64_t v5 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v4;
    if (*(char *)(a1 + 55) < 0) {
      uint64_t v6 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136315138;
    __int16 v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Initialize EventsBuffer %s", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    unint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::CLEventsBuffer(size_t, std::string) [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]", "%s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  return a1;
}

void sub_1002F2E20(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  sub_1002F2764(v2, *v4);
  _Unwind_Resume(a1);
}

void sub_1002F2E4C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        sub_10023F7D4((wireless_diagnostics::google::protobuf::MessageLite *)(v4 - 56));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1002F2ED0(void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    sub_1002F2F24((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1002F2F24(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 8)
  {
    unint64_t v5 = *(void **)(i - 8);
  }
  *(void *)(a1 + ++*(void *)(result + 8) = a2;
}

uint64_t sub_1002F2F70(uint64_t a1)
{
  sub_1002F2FAC(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1002F2FAC(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_1002F2FF0((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_1002F2FF0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 104) && *(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(unsigned char *)(a1 + 72) && *(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(unsigned char *)(a1 + 40) && *(char *)(a1 + 39) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

void *sub_1002F3070(void *result, id *a2, id *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001DCF60(result, a4);
    uint64_t result = sub_1002F30F8((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1002F30D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_1002F2ED0(&a9);
  _Unwind_Resume(a1);
}

void *sub_1002F30F8(uint64_t a1, id *a2, id *a3, void *a4)
{
  unint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  _DWORD v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *unint64_t v4 = 0;
      *unint64_t v4 = *v6++;
      unint64_t v4 = ++v11;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  sub_1002F31A0((uint64_t)v8);
  return v4;
}

void sub_1002F318C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002F31A0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002F31D8(a1);
  }
  return a1;
}

void sub_1002F31D8(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 - 8);
    v1 -= 8;
  }
}

double *sub_1002F3218(double *a1, double *a2, double *a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    unint64_t v5 = 0;
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = (double *)*((void *)v6 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = *(double **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (double *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v8 == (void)v6;
          uint64_t v6 = v8;
        }
        while (!v9);
      }
      ++v5;
      uint64_t v6 = v8;
    }
    while (v8 != a2);
    do
    {
      unint64_t v10 = v5 >> 1;
      int v14 = v3;
      sub_1002D4510((void **)&v14, v5 >> 1);
      uint64_t v11 = v14;
      if (v14[5] < *a3)
      {
        int v12 = (double *)*((void *)v14 + 1);
        if (v12)
        {
          do
          {
            uint64_t v3 = v12;
            int v12 = *(double **)v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v3 = (double *)*((void *)v11 + 2);
            BOOL v9 = *(void *)v3 == (void)v11;
            uint64_t v11 = v3;
          }
          while (!v9);
        }
        unint64_t v10 = v5 + ~v10;
      }
      unint64_t v5 = v10;
    }
    while (v10);
  }
  return v3;
}

void *sub_1002F3300(void *a1, void *a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2;
    do
    {
      uint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unint64_t v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      unint64_t v5 = v7;
    }
    while (v7 != a3);
  }
  sub_1002F3388(a1, a2, a3, v4);
  return a1;
}

void *sub_1002F3388(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002F3410(result, a4);
    uint64_t result = (void *)sub_1002F3464((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1002F33F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_1002F3514(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002F3410(void *a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334) {
    sub_1001D7FD4();
  }
  uint64_t result = (char *)sub_100214C7C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

uint64_t sub_1002F3464(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a2 == a3) {
    return a4;
  }
  unint64_t v5 = a2;
  uint64_t v6 = a4;
  do
  {
    sub_100243254(v6, v5 + 4);
    uint64_t v7 = (void *)v5[1];
    if (v7)
    {
      do
      {
        BOOL v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        BOOL v8 = (void *)v5[2];
        BOOL v9 = *v8 == (void)v5;
        unint64_t v5 = v8;
      }
      while (!v9);
    }
    v6 += 80;
    unint64_t v5 = v8;
  }
  while (v8 != a3);
  return v6;
}

void sub_1002F3514(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 80;
      uint64_t v7 = v4 - 80;
      BOOL v8 = v4 - 80;
      do
      {
        BOOL v9 = *(void (***)(char *))v8;
        v8 -= 80;
        (*v9)(v7);
        v6 -= 80;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1002F35D4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  std::string::size_type v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_1000DA8B4(v7, v9);
  }
  else {
    BOOL v10 = 0;
  }
  __int16 v13 = v10;
  int v14 = &v10[88 * v4];
  long long v15 = v14;
  double v16 = &v10[88 * v9];
  sub_100243254(v14, a2);
  *((_DWORD *)v14 + 20) = 0;
  v15 += 88;
  sub_1002E94A0(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10022334C((uint64_t)&v13);
  return v11;
}

void sub_1002F36EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10022334C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1002F3700(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  if (v5 >= (*a1)[2])
  {
    uint64_t v6 = sub_1002F3778(*a1, a2);
  }
  else
  {
    sub_100243254((*a1)[1], a2);
    *(_DWORD *)(v5 + 80) = *(_DWORD *)(a2 + 80);
    uint64_t v6 = v5 + 88;
    v4[1] = v5 + 88;
  }
  v4[1] = v6;
  return a1;
}

void sub_1002F3770(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++*(void *)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F3778(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_1001D7FD4();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  std::string::size_type v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_1000DA8B4(v7, v9);
  }
  else {
    BOOL v10 = 0;
  }
  __int16 v13 = v10;
  int v14 = &v10[88 * v4];
  long long v15 = v14;
  double v16 = &v10[88 * v9];
  sub_100243254(v14, a2);
  *((_DWORD *)v14 + 20) = *(_DWORD *)(a2 + 80);
  v15 += 88;
  sub_1002E94A0(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10022334C((uint64_t)&v13);
  return v11;
}

void sub_1002F3894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10022334C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1002F38A8(uint64_t *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = v1 - *result;
  if (v1 > *result)
  {
    *((unsigned char *)result + 56) = 1;
    uint64_t v3 = (uint64_t **)(result + 1);
    uint64_t v4 = (uint64_t *)result[1];
    sub_1002D4510(&v4, v2);
    return sub_1002F3A84(v3, *v3, v4);
  }
  return result;
}

uint64_t *sub_1002F3908(uint64_t a1, uint64_t a2)
{
  sub_1002F39A0(a1, a2, (uint64_t)v8);
  uint64_t v3 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (*((double *)v8[0] + 5) >= *((double *)v4 + 5)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        unint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    unint64_t v5 = v3 + 1;
  }
  else
  {
    unint64_t v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  sub_1000EDF90((uint64_t **)a1, (uint64_t)v3, v5, v8[0]);
  uint64_t v6 = v8[0];
  v8[0] = 0;
  sub_1002F3A0C((uint64_t)v8, 0);
  return v6;
}

uint64_t sub_1002F39A0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x70uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(void *)(result + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = sub_100243254(v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1002F39F4(_Unwind_Exception *a1)
{
  sub_1002F3A0C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1002F3A0C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (****)(void))a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      (*v2[4])();
    }
    operator delete(v2);
  }
}

uint64_t *sub_1002F3A84(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v6 = sub_1000F0A30(a1, v4);
      (*(void (**)(void))v4[4])();
      operator delete(v4);
      uint64_t v4 = v6;
    }
    while (v6 != a3);
  }
  return a3;
}

void *sub_1002F3B0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_1002757C4(a1 + 24, a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    __int16 v13 = *(void **)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      int v14 = (void *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v9)
          {
            if (sub_1002757FC(a1 + 32, (uint64_t)(v14 + 2), a2)) {
              return v14;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3) {
              break;
            }
          }
          int v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
  sub_1002F3D90(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100100330(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  int v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *int v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  int v14 = (void *)v25[0];
  v25[0] = 0;
  ++*v7;
  sub_1002F3EB4((uint64_t)v25, 0);
  return v14;
}

void sub_1002F3D78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002F3EB4((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F3D90@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x88uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + ++*(void *)(result + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  uint64_t result = sub_1002F3E08(v7, (uint64_t)(v8 + 2), a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1002F3DF0(_Unwind_Exception *a1)
{
  sub_1002F3EB4(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F3E08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  sub_1000E3A78(a2 + 16, (long long *)(a3 + 16));
  sub_1000E3A78(a2 + 48, (long long *)(a3 + 48));
  uint64_t result = sub_1000E3A78(a2 + 80, (long long *)(a3 + 80));
  *(void *)(a2 + 112) = *(void *)(a3 + 112);
  return result;
}

void sub_1002F3E70(_Unwind_Exception *exception_object)
{
  if (v1[72] && v1[71] < 0) {
    operator delete(*v3);
  }
  if (v1[40])
  {
    if (v1[39] < 0) {
      operator delete(*v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1002F3EB4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002F2FF0((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t sub_1002F3F0C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5 = result;
  uint64_t v8 = a3;
  uint64_t v9 = a4;
  if (result != a2)
  {
    do
    {
      uint64_t result = sub_1002F3F78((uint64_t)&v8, v5);
      v5 += 80;
    }
    while (v5 != a2);
    a3 = v8;
    a4 = v9;
    uint64_t v5 = a2;
  }
  *a5 = v5;
  a5[1] = a3;
  a5[2] = a4;
  return result;
}

uint64_t sub_1002F3F78(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = sub_1002F3FE0(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(void *)(a1 + ++*(void *)(result + 8) = v3;
  uint64_t v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      uint64_t v5 = (uint64_t *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      unint64_t v3 = v5;
    }
    while (!v6);
  }
  *(void *)(a1 + ++*(void *)(result + 8) = v5;
  return a1;
}

uint64_t *sub_1002F3FE0(uint64_t **a1, double *a2, uint64_t a3)
{
  sub_1002F39A0((uint64_t)a1, a3, (uint64_t)v9);
  uint64_t v5 = sub_1002F4070(a1, a2, &v8, (uint64_t)(v9[0] + 4));
  sub_1000EDF90(a1, (uint64_t)v8, (uint64_t **)v5, v9[0]);
  BOOL v6 = v9[0];
  v9[0] = 0;
  sub_1002F3A0C((uint64_t)v9, 0);
  return v6;
}

void sub_1002F4058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002F3A0C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double *sub_1002F4070(void *a1, double *a2, double **a3, uint64_t a4)
{
  uint64_t v4 = (double *)(a1 + 1);
  if (a1 + 1 != (void *)a2)
  {
    double v5 = *(double *)(a4 + 8);
    if (a2[5] < v5)
    {
      while (1)
      {
        uint64_t v6 = *(void *)v4;
        a2 = v4;
        if (!*(void *)v4) {
          break;
        }
        while (1)
        {
          uint64_t v4 = (double *)v6;
          if (*(double *)(v6 + 40) >= v5) {
            break;
          }
          uint64_t v6 = *(void *)(v6 + 8);
          if (!v6) {
            goto LABEL_19;
          }
        }
      }
LABEL_20:
      *a3 = v4;
      return a2;
    }
  }
  double v7 = *a2;
  if ((double *)*a1 == a2)
  {
    uint64_t v9 = a2;
  }
  else
  {
    if (v7 == 0.0)
    {
      unint64_t v10 = a2;
      do
      {
        uint64_t v9 = (double *)*((void *)v10 + 2);
        BOOL v11 = *(void *)v9 == (void)v10;
        unint64_t v10 = v9;
      }
      while (v11);
    }
    else
    {
      double v8 = *a2;
      do
      {
        uint64_t v9 = *(double **)&v8;
        double v8 = *(double *)(*(void *)&v8 + 8);
      }
      while (v8 != 0.0);
    }
    double v12 = *(double *)(a4 + 8);
    if (v12 < v9[5])
    {
      while (1)
      {
        uint64_t v13 = *(void *)v4;
        a2 = v4;
        if (!*(void *)v4) {
          goto LABEL_20;
        }
        while (1)
        {
          uint64_t v4 = (double *)v13;
          if (v12 < *(double *)(v13 + 40)) {
            break;
          }
          uint64_t v13 = *(void *)(v13 + 8);
          if (!v13)
          {
LABEL_19:
            a2 = v4 + 1;
            goto LABEL_20;
          }
        }
      }
    }
  }
  if (v7 == 0.0)
  {
    *a3 = a2;
  }
  else
  {
    *a3 = v9;
    return v9 + 1;
  }
  return a2;
}

void *sub_1002F4158(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002F41E0(result, a4);
    uint64_t result = (void *)sub_1002F4238((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1002F41C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_1002F2E4C(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002F41E0(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_1001D7FD4();
  }
  uint64_t result = (char *)sub_10017EA6C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t sub_1002F4238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      *(_DWORD *)(sub_10023F7D0(a4 + v7, a2 + v7) + 4++*(void *)(result + 8) = *(_DWORD *)(a2 + v7 + 48);
      v7 += 56;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1002F42AC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 56;
    do
    {
      sub_10023F7D4((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 56;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F42D0(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, double *a5)
{
  unint64_t v6 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x38E38E38E38E38ELL) {
    sub_1001D7FD4();
  }
  if (0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3) > v7) {
    unint64_t v7 = 0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v12 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v12 = v7;
  }
  unint64_t v20 = a1 + 2;
  if (v12) {
    uint64_t v13 = (char *)sub_10021D4B8((uint64_t)(a1 + 2), v12);
  }
  else {
    uint64_t v13 = 0;
  }
  float v16 = v13;
  float v17 = &v13[72 * v6];
  unint64_t v19 = &v13[72 * v12];
  sub_1002F4420((uint64_t)(a1 + 2), (uint64_t)v17, a2, a3, a4, a5);
  BOOL v18 = v17 + 72;
  sub_10021D440(a1, &v16);
  uint64_t v14 = a1[1];
  sub_10021D6B4(&v16);
  return v14;
}

void sub_1002F440C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10021D6B4((void **)va);
  _Unwind_Resume(a1);
}

void sub_1002F4420(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, double *a6)
{
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*(char *)(a4 + 23) < 0)
  {
    sub_1000DC48C(__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a4;
    uint64_t v14 = *(void *)(a4 + 16);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_1000DC48C(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v12 = *(void *)(a5 + 16);
  }
  sub_10021B4BC(a2, v9, v10, __dst, __p, *a6);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1002F44F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F4524(uint64_t a1)
{
  unsigned int v2 = sub_10020F9B4(a1);
  if (sub_1002F471C() > v2) {
    return 1;
  }
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A5268);
  }
  unint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446210;
    double v8 = "MicroLocationBluetoothIdentityTable";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A5268);
    }
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationBluetoothIdentityTable]", "%s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t result = sub_10020822C(a1);
  if (result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0) {
      uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_10003CC68(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_1002F471C()
{
  sub_1000C7F88(&v5);
  unsigned int v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBluetoothIdentityTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1004D08E4(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  unsigned int v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v1) {
    return v2;
  }
  else {
    return 96;
  }
}

void sub_1002F47B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002F47CC(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1002F2FAC(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void *sub_1002F4824(void *a1, _OWORD *a2, long long *a3, long long *a4, uint64_t a5, void *a6)
{
  sub_1002F489C((uint64_t)a1, a2, a3, a4, a5, a6, (uint64_t)v10);
  unint64_t v7 = sub_1002F4964(a1, v10[0]);
  if (v8) {
    v10[0] = 0;
  }
  sub_1002F3EB4((uint64_t)v10, 0);
  return v7;
}

void sub_1002F4884(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002F3EB4((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

unint64_t sub_1002F489C@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, long long *a3@<X2>, long long *a4@<X3>, uint64_t a5@<X4>, void *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14 = a1 + 16;
  unint64_t v15 = operator new(0x88uLL);
  *(void *)a7 = v15;
  *(void *)(a7 + ++*(void *)(result + 8) = v14;
  *(unsigned char *)(a7 + 16) = 0;
  void *v15 = 0;
  v15[1] = 0;
  sub_1002F49D8(v14, (uint64_t)(v15 + 2), a2, a3, a4, a5, a6);
  *(unsigned char *)(a7 + 16) = 1;
  unint64_t result = sub_1002757C4(a1 + 24, (uint64_t)(v15 + 2));
  v15[1] = result;
  return result;
}

void sub_1002F494C(_Unwind_Exception *a1)
{
  sub_1002F3EB4(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_1002F4964(void *a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (uint64_t)(a2 + 2);
  unint64_t v5 = sub_1002757C4((uint64_t)(a1 + 3), (uint64_t)(a2 + 2));
  v2[1] = v5;
  unint64_t v6 = sub_1002F4B20((uint64_t)a1, v5, v4);
  if (v6) {
    return v6;
  }
  sub_1002F4C78(a1, v2);
  return v2;
}

void sub_1002F49D8(uint64_t a1, uint64_t a2, _OWORD *a3, long long *a4, long long *a5, uint64_t a6, void *a7)
{
  LOBYTE(__p) = 0;
  char v9 = 0;
  sub_1002F4A60(a2, a3, a4, a5, &__p, a7);
  if (v9)
  {
    if (v8 < 0) {
      operator delete((void *)__p);
    }
  }
}

void sub_1002F4A3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F4A60(uint64_t a1, _OWORD *a2, long long *a3, long long *a4, long long *a5, void *a6)
{
  *(_OWORD *)a1 = *a2;
  sub_1000E3A78(a1 + 16, a3);
  sub_1000E3A78(a1 + 48, a4);
  sub_1000E3A78(a1 + 80, a5);
  *(void *)(a1 + 112) = *a6;
  return a1;
}

void sub_1002F4ADC(_Unwind_Exception *exception_object)
{
  if (v1[72] && v1[71] < 0) {
    operator delete(*v3);
  }
  if (v1[40])
  {
    if (v1[39] < 0) {
      operator delete(*v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002F4B20(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v7.i16[0] = vaddlv_u8(v7);
    unint64_t v8 = v7.u32[0];
    if (v7.u32[0] > 1uLL) {
      uint64_t v9 = v4 <= a2 ? a2 % v4 : a2;
    }
    else {
      uint64_t v9 = (v4 - 1) & a2;
    }
    uint64_t v10 = *(void **)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      BOOL v11 = (void *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == a2)
          {
            if (sub_1002757FC(a1 + 32, (uint64_t)(v11 + 2), a3)) {
              return v11;
            }
          }
          else
          {
            if (v8 > 1)
            {
              if (v12 >= v4) {
                v12 %= v4;
              }
            }
            else
            {
              v12 &= v4 - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v4 || (float)(v14 * (float)v4) < v13)
  {
    BOOL v15 = 1;
    if (v4 >= 3) {
      BOOL v15 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v4);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100100330(a1, v18);
  }
  return 0;
}

void *sub_1002F4C78(void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  unint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *unint64_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    unint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

void *sub_1002F4D30(void *a1, void *a2, uint64_t a3)
{
  *a1 = off_1022A52B8;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = a2;
  a1[4] = a3;
  a1[5] = 0;
  a1[5] = [objc_msgSend(objc_msgSend(a2, "silo"), "newTimer")];
  return a1;
}

uint64_t sub_1002F4D88(uint64_t a1)
{
  *(void *)a1 = off_1022A52B8;
  [*(id *)(a1 + 8) invalidate];

  *(void *)(a1 + ++*(void *)(result + 8) = 0;
  if (*(void *)(a1 + 16) && sub_1002F4E04())
  {
    [*(id *)(a1 + 16) invalidate];

    *(void *)(a1 + 16) = 0;
  }
  return a1;
}

uint64_t sub_1002F4E04()
{
  sub_1000C7F88(&v5);
  BOOL v4 = 0;
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleNonLeechingScannerEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1000D29FC(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  BOOL v2 = v4;
  if (v6) {
    sub_1000DB0A0(v6);
  }
  if (v2) {
    return 1;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1002F4E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002F4EB8(uint64_t a1)
{
  sub_1002F4D88(a1);

  operator delete();
}

uint64_t sub_1002F4EF0(uint64_t a1)
{
  [*(id *)(a1 + 24) silo];
  CFAbsoluteTime Current_5 = j__CFAbsoluteTimeGetCurrent_5();
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A53B0);
  }
  unint64_t v3 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint8x8_t v7 = "";
    __int16 v8 = 2050;
    CFAbsoluteTime v9 = Current_5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CBDiscovery, a BLE session timer stopped\", \"now\":\"%{public}.3f\"}", (uint8_t *)v5, 0x1Cu);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32));
}

void sub_1002F5018(id *a1, uint64_t a2)
{
  (*((void (**)(id *))*a1 + 5))(a1);
  sub_1002F51D0((uint64_t)a1, a2);
  if (!*(unsigned char *)(a2 + 9))
  {
    double v4 = *(double *)a2;
    double Current_5 = j__CFAbsoluteTimeGetCurrent_5();
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A53B0);
    }
    __int16 v6 = qword_102419458;
    if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = (uint64_t)v4;
      double v8 = v4 + Current_5;
      *(_DWORD *)long long buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      float v13 = "";
      __int16 v14 = 2050;
      double v15 = Current_5;
      __int16 v16 = 2050;
      uint64_t v17 = v7;
      __int16 v18 = 2050;
      double v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CBDiscovery, Starting BLE scan timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}", buf, 0x30u);
    }
    else
    {
      double v8 = v4 + Current_5;
    }
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    void v9[2] = sub_1002F52BC;
    void v9[3] = &unk_1022A3020;
    void v9[4] = a1;
    [a1[5] setHandler:v9];
    [a1[5] setNextFireTime:v8];
  }
}

void sub_1002F51D0(uint64_t a1, uint64_t a2)
{
  sub_1002F5AD4(a1, a2);
  if (*(void *)(a1 + 16) && sub_1002F4E04())
  {
    if (*(unsigned char *)(a2 + 10)) {
      goto LABEL_10;
    }
    sub_1000C7F88(&v9);
    BOOL v8 = 0;
    CFStringRef v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleForceScanNearbyInfoV2", 0x8000100u, kCFAllocatorNull);
    int v5 = sub_1000D29FC(v9, (uint64_t)v4, &v8);
    CFRelease(v4);
    BOOL v6 = v8;
    if (v10) {
      sub_1000DB0A0(v10);
    }
    int v7 = v6 ? v5 : 0;
    if (v7 == 1) {
LABEL_10:
    }
      sub_1002F5FB4(a1, a2);
  }
}

void sub_1002F52A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000DB0A0(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F52BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

id sub_1002F52E4(uint64_t a1)
{
  if (qword_102419450 != -1) {
    dispatch_once(&qword_102419450, &stru_1022A53B0);
  }
  BOOL v2 = qword_102419458;
  if (os_log_type_enabled((os_log_t)qword_102419458, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Unregister all BLE scan sessions", buf, 2u);
  }
  if (sub_10013D1A0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_102419450 != -1) {
      dispatch_once(&qword_102419450, &stru_1022A53B0);
    }
    CFStringRef v4 = (char *)_os_log_send_and_compose_impl();
    sub_1004BA5E4("Generic", 1, 0, 2, "virtual void CLMicroLocationBLERssiBridge::stopBleRssiSession()", "%s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  [*(id *)(a1 + 40) invalidate];
  return sub_1002F5488(a1);
}

id sub_1002F5488(uint64_t a1)
{
  [*(id *)(a1 + 8) removeAllDiscoveryTypes];
  [*(id *)(a1 + 8) setDiscoveryFlags:0];
  [*(id *)(a1 + 8) setDeviceFilter:0];
  id result = (id)sub_1002F4E04();
  if (result)
  {
    [*(id *)(a1 + 16) removeAllDiscoveryTypes];
    [*(id *)(a1 + 16) setDiscoveryFlags:0];
    [*(id *)(a1 + 16) setDeviceFilter:0];
    unint64_t v3 = *(void **)(a1 + 16);
    return [v3 setOobKeys:0];
  }
  return result;
}